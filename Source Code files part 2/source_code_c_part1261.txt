le(
    LPWSTR pszFileName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    
    if (!SetFileSecurity(
            pszFileName,
            secInfo,
            pSD
            )
        ) {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    } 
    else {
        RRETURN(S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromFileShare - Helper routine.
//
// Synopsis:   Gets the security descriptor from the fileshare in bin format.
//
// Arguments:  pszFileShareName  -   Name of fileshare to get sd from.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromFileShare(
    LPWSTR pszFileShareName,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerName = NULL;
    LPWSTR pszShareName = NULL;
    
    DWORD dwLength = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SHARE_INFO_502 * pShareInfo502 = NULL;
    NET_API_STATUS nasStatus = NERR_Success;

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileShareName,
             &pszServerName,
             &pszShareName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Only 502 level call returns the SD Info.
    //
    nasStatus = NetShareGetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE *)&pShareInfo502
                    );    
    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

    //
    // If the SD is non NULL process the SD.
    //
    if (pShareInfo502->shi502_security_descriptor) {
        //
        // Get the length of the SD, it should not be 0.
        //
        SetLastError(0);
        dwLength = GetSecurityDescriptorLength(
                       pShareInfo502->shi502_security_descriptor
                       );


        //
        // The return length should not be zero.
        //
        if (dwLength == 0) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        
        pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
        
        if (!pSD) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        memcpy(pSD, pShareInfo502->shi502_security_descriptor, dwLength);
    
        *ppSD = pSD;
        *pdwLength = dwLength;
    }
    else {
        //
        // The SD was NULL the ret values are set correctly
        //
        ;
    }

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszShareName) {
        FreeADsStr(pszShareName);
    }

    if (pShareInfo502) {
        NetApiBufferFree(pShareInfo502);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToFileShare - Helper routine.
//
// Synopsis:   Sets the binary SD on the fileshare.
//
// Arguments:  pszFileShare      -   Name of fileshare to set sd on.
//             pSD              -   The SD to set.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT 
SetRawSDToFileShare(
    LPWSTR pszFileShare,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerName = NULL;
    LPWSTR pszShareName = NULL;
    SHARE_INFO_502 * pShareInfo502 = NULL;
    NET_API_STATUS nasStatus = NERR_Success;
    PSECURITY_DESCRIPTOR pTempSD = NULL;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileShare,
             &pszServerName,
             &pszShareName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Ideally we should use 1501 level but that is only on Win2k. So
    // we need to read the info, update SD and then set it.
    //
    nasStatus = NetShareGetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE *) &pShareInfo502
                    );
    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

    //
    // Store away the SD so we restore before free.
    //
    pTempSD = pShareInfo502->shi502_security_descriptor;

    pShareInfo502->shi502_security_descriptor = pSD;

    nasStatus = NetShareSetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE) pShareInfo502,
                    NULL
                    );

    pShareInfo502->shi502_security_descriptor = pTempSD;

    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

error:

    if (pShareInfo502) {
        NetApiBufferFree(pShareInfo502);
    }

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }
    if (pszShareName) {
        FreeADsStr(pszShareName);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromRegistry - Helper routine.
//
// Synopsis:   Gets the security descriptor from the registry in bin format.
//
// Arguments:  pszFileRegKeyName -   Name of fileshare to get sd from.
//             secInfo           -   Security mask to use for the operation.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromRegistry(
    LPWSTR pszFileRegKeyName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr;
    LPWSTR pszServerName = NULL;
    LPWSTR pszKeyName = NULL;
    LPWSTR pszSubKey = NULL;
    DWORD dwLength = 0;
    DWORD dwErr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HKEY hKey = NULL;
    HKEY hKeyRoot = NULL;
    HKEY hKeyMachine = NULL;

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileRegKeyName,
             &pszServerName,
             &pszKeyName
             );
    BAIL_ON_FAILURE(hr);


    //
    // pszKeyName has to have a valid string. We need to process it
    // to find out which key set we need to open (such as HKLM).
    //
    hr = GetKeyRootAndSubKey(pszKeyName, &pszSubKey, &hKeyRoot);
    BAIL_ON_FAILURE(hr);

    //
    // Need to open the hKeyRoot on the appropriate machine.
    // If the serverName is NULL it will be local machine.
    //
    dwErr = RegConnectRegistry(
                pszServerName,
                hKeyRoot,
                &hKeyMachine
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    //
    // Open the key and try and read the security descriptor
    //
    dwErr = RegOpenKeyEx(
                hKeyMachine,
                pszSubKey,
                0,
                KEY_READ,
                &hKey
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    dwErr = RegGetKeySecurity(
                hKey,
                secInfo,
                pSD,
                &dwLength
                );
    if (dwLength == 0) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
    if (!pSD) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    dwErr = RegGetKeySecurity(
                hKey,
                secInfo,
                pSD,
                &dwLength
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    *ppSD = pSD;
    *pdwLength = dwLength;

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszKeyName) {
        FreeADsStr(pszKeyName);
    }

    if (pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (hKeyMachine) {
        RegCloseKey(hKeyMachine);
    }

    if (FAILED(hr) && pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToRegistry - Helper routine.
//
// Synopsis:   Sets the security descriptor to the specified key.
//
// Arguments:  pszFileRegKeyName -   Name of fileshare to set sd on.
//             secInfo           -   Security mask to use for the operation.
//             pSD               -   SD to set on the reg key.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
SetRawSDToRegistry(
    LPWSTR pszFileRegKeyName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr;
    LPWSTR pszServerName = NULL;
    LPWSTR pszKeyName = NULL;
    LPWSTR pszSubKey = NULL;
    DWORD dwErr;
    HKEY hKey = NULL;
    HKEY hKeyRoot = NULL;
    HKEY hKeyMachine = NULL;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileRegKeyName,
             &pszServerName,
             &pszKeyName
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // pszKeyName has to have a valid string. We need to process it
    // to find out which key set we need to open (such as HKLM).
    //
    hr = GetKeyRootAndSubKey(pszKeyName, &pszSubKey, &hKeyRoot);
    BAIL_ON_FAILURE(hr);

    //
    // Need to open the hKeyRoot on the appropriate machine.
    // If the serverName is NULL it will be local machine.
    //
    dwErr = RegConnectRegistry(
                pszServerName,
                hKeyRoot,
                &hKeyMachine
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }
    
    //
    // Open the key and try and read the security descriptor
    //
    dwErr = RegOpenKeyEx(
                hKeyMachine,
                pszSubKey,
                0,
                KEY_WRITE,
                &hKey
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    dwErr = RegSetKeySecurity(
                hKey,
                secInfo,
                pSD
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszKeyName) {
        FreeADsStr(pszKeyName);
    }

    if (pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (hKeyMachine) {
        RegCloseKey(hKeyMachine);
    }

    RRETURN(hr);
}

/****************************************************************************/
//
// CADsSecurityUtility Class.
//
/****************************************************************************/

DEFINE_IDispatch_Implementation(CADsSecurityUtility)

//+---------------------------------------------------------------------------
// Function:   CSecurity::CSecurityDescriptor - Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CADsSecurityUtility::CADsSecurityUtility():
    _secInfo( DACL_SECURITY_INFORMATION
             | GROUP_SECURITY_INFORMATION
             | OWNER_SECURITY_INFORMATION
            ),
    _pDispMgr(NULL)
{
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::~CADsSecurityUtility - Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CADsSecurityUtility::~CADsSecurityUtility()
{
    //
    // Only the dispmgr needs to be cleaned up.
    //
    delete _pDispMgr;
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::AllocateADsSecurityUtilityObject -
//             Static helper method.
//
// Synopsis:   Standard static allocation routine.
//
// Arguments:  ppADsSecurityUtil    -   Return ptr.
//
// Returns:    S_OK on success or appropriate error code on failure.
//
// Modifies:   *ppADsSecurity.
//
//----------------------------------------------------------------------------
HRESULT
CADsSecurityUtility::AllocateADsSecurityUtilityObject(
    CADsSecurityUtility **ppADsSecurityUtil
    )
{
    HRESULT hr = S_OK;
    CADsSecurityUtility FAR * pADsSecurityUtil = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;

    pADsSecurityUtil = new CADsSecurityUtility();

    if (!pADsSecurityUtil) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDispMgr = new CDispatchMgr;

    if (!pDispMgr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsSecurityUtility,
             (IADsSecurityUtility *)pADsSecurityUtil,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    pADsSecurityUtil->_pDispMgr = pDispMgr;
    *ppADsSecurityUtil = pADsSecurityUtil;

    RRETURN(hr);

error:

    delete pADsSecurityUtil;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::CreateADsSecurityUtility - Static 
//          helper method.
//
// Synopsis:   Standard static class factor helper method.
//
// Arguments:  riid             -   IID needed on returned object.
//             ppvObj           -   Return ptr.
//
// Returns:    S_OK on success or appropriate error code on failure.
//
// Modifies:   *ppvObj is suitably modified.
//
//----------------------------------------------------------------------------
HRESULT
CADsSecurityUtility::CreateADsSecurityUtility(
    REFIID riid,
    void **ppvObj
    )
{
    CADsSecurityUtility FAR * pADsSecurityUtil = NULL;
    HRESULT hr = S_OK;

    hr = AllocateADsSecurityUtilityObject(&pADsSecurityUtil);
    BAIL_ON_FAILURE(hr);

    hr = pADsSecurityUtil->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pADsSecurityUtil->Release();

    RRETURN(hr);

error:
    delete pADsSecurityUtil;

    RRETURN_EXP_IF_ERR(hr);

}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::QueryInterface --- IUnknown support.
//
// Synopsis:   Standard query interface method.
//
// Arguments:  iid           -  Interface requested.
//             ppInterface   -  Return pointer to interface requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT hr = S_OK;

    if (!ppInterface) {
        RRETURN(E_INVALIDARG);
    }

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSecurityUtility)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) {
        *ppInterface = (ISupportErrorInfo *) this;
    }
    else {
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::InterfaceSupportserrorInfo
//                           ISupportErrorInfo support.
//
// Synopsis:   N/A.
//
// Arguments:  riid          -  Interface being tested..
//
// Returns:    S_OK or S_FALSE on failure.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsSecurityUtility)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::GetSecurityDescriptor - 
//          IADsSecurityUtility support.
//
// Synopsis:   Gets the security descriptor from the named object.
//
// Arguments:  varPath           -   Path of object to get SD from.
//             lPathFormat       -   Specifies type of object path.
//                                  Only ADS_PATH_FILE, ADS_PATH_FILESHARE
//                                  and ADS_PATH_REGISTRY are supported.
//             lOutFormat        -   Specifies output SD format.
//             pVariant          -   Return value for SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant is update appropriately.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::GetSecurityDescriptor(
    IN VARIANT varPath,
    IN long lPathFormat, 
    IN OPTIONAL long lOutFormat, 
    OUT VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwLength = 0;
    VARIANT *pvPath = NULL;

    //
    // Make sure the params are correct.
    //
    if (!pVariant) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    VariantInit(pVariant);
    
    if (lPathFormat < ADS_PATH_FILE
        || lPathFormat > ADS_PATH_REGISTRY
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Make sure we handle byRef params correctly.
    //
    pvPath = &varPath;
    if (V_VT(pvPath) == (VT_BYREF|VT_VARIANT)) {
        pvPath = V_VARIANTREF(&varPath);
    }
    
    //
    // For the path to be valid for now, it has to be a string.
    //
    if (pvPath->vt != VT_BSTR) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (pvPath->bstrVal == NULL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (lOutFormat < ADS_SD_FORMAT_IID 
        || lOutFormat > ADS_SD_FORMAT_HEXSTRING
        ) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // Time to get the raw sd from the source.
    //
    switch (lPathFormat) {
    case ADS_PATH_FILE:
        hr = GetRawSDFromFile(
                 pvPath->bstrVal,
                 _secInfo,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;

    case ADS_PATH_FILESHARE:
        hr = GetRawSDFromFileShare(
                 pvPath->bstrVal,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;
        
    case ADS_PATH_REGISTRY:
        hr = GetRawSDFromRegistry(
                 pvPath->bstrVal,
                 _secInfo,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    } // end of case to read sd.

    BAIL_ON_FAILURE(hr);
    
    //
    // Now convert the sd to the required format.
    //
    switch (lOutFormat) {
    case ADS_SD_FORMAT_IID:
        hr = BinarySDToSecurityDescriptor(
                 pSecurityDescriptor,
                 pVariant,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW:
        hr = ConvertRawSDToBinary(
                 pSecurityDescriptor,
                 dwLength,
                 pVariant
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertRawSDToHexString(
                 pSecurityDescriptor,
                 dwLength,
                 pVariant
                 );
        break;

    default:
        hr = E_INVALIDARG;
    } // end of case for output format.

error:

    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::SetSecurityDescriptor - 
//          IADsSecurityUtility support.
//
// Synopsis:   Sets the security descriptor from the named object.
//
// Arguments:  varPath           -   Path of object to set SD on.
//             lPathFormat       -   Format of path.
//             varData           -   Variant with SD to set.
//             lDataFormat       -   Format of the SD data.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::SetSecurityDescriptor(
    IN VARIANT varPath,
    IN long lPathFormat,
    IN VARIANT varData,
    IN long lDataFormat
    )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT *pvPath = NULL;
    VARIANT *pvData = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLength = 0;

    if ((lPathFormat < ADS_PATH_FILE)
        || (lPathFormat > ADS_PATH_REGISTRY)
        || (lDataFormat < ADS_SD_FORMAT_IID)
        || (lDataFormat > ADS_SD_FORMAT_HEXSTRING)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    //
    // Make sure we handle byRef params correctly.
    //
    pvPath = &varPath;
    if (V_VT(pvPath) == (VT_BYREF | VT_VARIANT)) {
        pvPath = V_VARIANTREF(&varPath);
    }

    pvData = &varData;
    if (V_VT(pvData) == (VT_BYREF | VT_VARIANT)) {
        pvData = V_VARIANTREF(&varData);
    }

    //
    // Find out what format the SD is in and convert to raw binary
    // format as that is what we need to set.
    //
    switch (lDataFormat) {
    case ADS_SD_FORMAT_IID:
        hr = SecurityDescriptorToBinarySD(
                 *pvData,
                 &pSD,
                 &dwLength,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        if (V_VT(pvData) == VT_BSTR) {
            hr = ConvertHexSDToRawSD(
                     pvData,
                     &pSD,
                     &dwLength
                     );
        }
        break;

    case ADS_SD_FORMAT_RAW:
        if (V_VT(pvData) == (VT_UI1 | VT_ARRAY)) {
            hr = ConvertBinarySDToRawSD(
                     pvData,
                     &pSD,
                     &dwLength
                     );
        }

    default:
        hr = E_INVALIDARG;
        break;
    } // end switch type of input data.

    //
    // This will catch conversion failures as well as bad params.
    //
    BAIL_ON_FAILURE(hr); 
    
    //
    // For now the path has to be a string.
    //
    if (pvPath->vt != VT_BSTR) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    switch (lPathFormat) {
    case ADS_PATH_FILE:
        hr = SetRawSDToFile(
                 pvPath->bstrVal,
                 _secInfo,
                 pSD
                 );
        break;

    case ADS_PATH_FILESHARE:
        hr = SetRawSDToFileShare(
                 pvPath->bstrVal,
                 pSD
                 );
        break;

    case ADS_PATH_REGISTRY:
        hr = SetRawSDToRegistry(
                 pvPath->bstrVal,
                 _secInfo,
                 pSD
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::ConvertSecurityDescriptor - 
//          IADsSecurityUtility method.
//
// Synopsis:   Converts the input SD to the appropriate format requested.
//
// Arguments:  varData           -   Input SD to convert.
//             lDataFormat       -   Input SD format.
//             loutFormat        -   Format of output SD.
//             pvResult          -   Return value.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pvResult with appropriate value.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::ConvertSecurityDescriptor(
    IN VARIANT varData,
    IN long lDataFormat, 
    IN long lOutFormat, 
    OUT VARIANT *pvResult
    )
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLenSD;
    VARIANT *pVarData = &varData;

    if (!pvResult) {
        BAIL_ON_FAILURE(hr= E_INVALIDARG);
    }

    if (V_VT(pVarData) == (VT_BYREF | VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }
     
    //
    // We will convert to binary format and then to 
    // the requested format.
    //
    switch (lDataFormat) {
    case ADS_SD_FORMAT_IID:
        hr = SecurityDescriptorToBinarySD(
                 *pVarData,
                 &pSD,
                 &dwLenSD,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW : 
        hr = ConvertBinarySDToRawSD(
                 pVarData,
                 &pSD,
                 &dwLenSD
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertHexSDToRawSD(
                 pVarData,
                 &pSD,
                 &dwLenSD
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Convert to the requested format.
    //
    switch (lOutFormat) {
    case ADS_SD_FORMAT_IID:
        hr = BinarySDToSecurityDescriptor(
                 pSD,
                 pvResult,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW:
        hr = ConvertRawSDToBinary(
                 pSD,
                 dwLenSD,
                 pvResult
                 );
        break;
        
    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertRawSDToHexString(
                 pSD,
                 dwLenSD,
                 pvResult
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

error:

    if (pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

STDMETHODIMP
CADsSecurityUtility::put_SecurityMask(
    long lSecurityMask
    )
{
    _secInfo = (SECURITY_INFORMATION) lSecurityMask;
    RRETURN(S_OK);
}

STDMETHODIMP
CADsSecurityUtility::get_SecurityMask(
    long *plSecurityMask
    )
{
    if (!plSecurityMask) {
        RRETURN(E_INVALIDARG);
    }

    *plSecurityMask = (long) _secInfo;

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\ccommand.cxx ===
//
// Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccommand.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

static WCHAR gpszADsPathAttr[] = L"ADsPath";

static BOOL
IsAutomatable(
    DBTYPE dbType
    );

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::AddRefAccessor
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::AddRefAccessor(
        HACCESSOR hAccessor,
    DBREFCOUNT *  pcRefCount
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->AddRefAccessor(
                    hAccessor,
                    pcRefCount) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CreateAccessor
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR *     phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->CreateAccessor(
                    dwAccessorFlags,
                    cBindings,
                    rgBindings,
                    cbRowSize,
                    phAccessor,
                    rgStatus) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::ReleaseAccessor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::ReleaseAccessor(
     HACCESSOR hAccessor,
     DBREFCOUNT * pcRefCount
     )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->ReleaseAccessor(
                    hAccessor,
                    pcRefCount) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetBindings
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      prgBindings
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->GetBindings(
                    hAccessor,
                    pdwAccessorFlags,
                                                                                                pcBindings, prgBindings) );
}


STDMETHODIMP
CCommandObject::GetColumnInfo2(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** prgInfo,
    OLECHAR **      ppStringBuffer,
    BOOL **         ppfMultiValued
    )
{
    HRESULT hr;
    ULONG pos, nStringBufLen;
    DBCOLUMNINFO *pInfo=NULL;
    OLECHAR* pStringBuffer=NULL ;
    DWORD i;
    DBTYPE wType;
    DWORD cAttrsReturned;
    LPWSTR *ppszTmpAttrs = NULL;
    DWORD cTmpAttrs;

    IDirectorySchemaMgmt *pDSAttrMgmt = NULL;
    PADS_ATTR_DEF pAttrDefinition = NULL;

    ADsAssert(_pIMalloc != NULL);

    //
    // IMalloc->Alloc is the way we have to allocate memory for out parameters
    //
    nStringBufLen = 0;
    for (i=0; i < _cAttrs; i++) {
        nStringBufLen += (wcslen(_ppszAttrs[i]) + 1) * sizeof (WCHAR);
    }

    nStringBufLen+= sizeof(WCHAR);        // For the bookmark column which is a null string

    //
    // No. of DBCOLUMN structures to be allocated
    //
    pInfo = (DBCOLUMNINFO *)_pIMalloc->Alloc((_cAttrs+1)*sizeof(DBCOLUMNINFO));
    if( !pInfo ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    memset(pInfo, 0, (_cAttrs*sizeof(DBCOLUMNINFO)));

    pStringBuffer = (WCHAR *)_pIMalloc->Alloc(nStringBufLen);
    if( !pStringBuffer ) {
        hr = E_OUTOFMEMORY;
        goto error;
    };
    memset(pStringBuffer, 0, nStringBufLen);

    //
    // Get the attribute types by enquiring the DS schema
    //
    hr = _pDSSearch->QueryInterface(
                                IID_IDirectorySchemaMgmt,
                                (void**)&pDSAttrMgmt
                                );
    BAIL_ON_FAILURE( hr );

    // Fix for #285757. We should not send the ADsPath attribute to the
    // server. So, search for occurences of this attribute and remove them.

    ppszTmpAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * _cAttrs);
    if(NULL == ppszTmpAttrs)
    {
         hr = E_OUTOFMEMORY;
         BAIL_ON_FAILURE(hr);
    } 
    cTmpAttrs = 0;
    for(i = 0; i < _cAttrs; i++)
    {
         if( _wcsicmp(L"ADsPath", _ppszAttrs[i]) )
         {
              ppszTmpAttrs[cTmpAttrs] = _ppszAttrs[i];
              cTmpAttrs++;
         }
    }     

    // Request attributes only if there is some attribute other than ADsPath
    if(cTmpAttrs)
         hr = pDSAttrMgmt->EnumAttributes(
                        ppszTmpAttrs,
                        cTmpAttrs,
                        &pAttrDefinition,
                        &cAttrsReturned
                        );
    else
    {
         cAttrsReturned = 0;
         pAttrDefinition = NULL;
    }

    if(ppszTmpAttrs != NULL)
         FreeADsMem(ppszTmpAttrs);

    pDSAttrMgmt->Release();
    BAIL_ON_FAILURE( hr );

    //fill up the Bookmark column

    // bookmark name is empty string
    pInfo[0].pwszName                = NULL;

    pInfo[0].columnid.eKind          = DBKIND_GUID_PROPID;
    pInfo[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
    pInfo[0].columnid.uName.ulPropid = 2;    // Value from note about
                                             // bookmarks in spec.
    pInfo[0].pTypeInfo               = NULL;
    pInfo[0].iOrdinal                = 0;
    pInfo[0].ulColumnSize            = sizeof(ULONG);
    pInfo[0].wType                   = DBTYPE_UI4;
    pInfo[0].bPrecision              = 10;       // Precision for I4.
    pInfo[0].bScale                  = (BYTE) ~ 0;
    pInfo[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK
                                                                                | DBCOLUMNFLAGS_ISFIXEDLENGTH;

    //
    // Fill up the columnsinfo by getting the attribute types
    //
    pos = 0;
    for(i=0; i < _cAttrs; i++) {
        wcscpy(&pStringBuffer[pos], _ppszAttrs[i]);
        pInfo[i+1].pwszName= &pStringBuffer[pos];

        //
        // Get the type and size of the attribute
        //
        // Because of a Temporary bug in TmpTable, ~0 (specifying variable
        // size) is replaced by 256. This does not actually put a memory
        // restriction on the column size, but done merely to avoid the bug.
        //
        if( _wcsicmp(_ppszAttrs[i], L"ADsPath") == 0) {
            pInfo[i+1].wType = DBTYPE_WSTR|DBTYPE_BYREF;
            // pInfo[i+1].ulColumnSize = (ULONG) ~0;
            pInfo[i+1].ulColumnSize = (ULONG)256;
        }
        else {
            hr = GetDBType(
                      pAttrDefinition,
                      cAttrsReturned,
                      _ppszAttrs[i],
                      &pInfo[i+1].wType,
                      &pInfo[i+1].ulColumnSize
                      );

            if( FAILED(hr) )
                BAIL_ON_FAILURE( hr=E_FAIL );
        }

        wType = pInfo[i+1].wType & ~DBTYPE_BYREF;

        // any change made to setting dwFlags below should also be made in
        // GetRestrictedColumnInfo in row.cxx, for consistency
        if( (wType == DBTYPE_STR)  ||
            (wType == DBTYPE_WSTR) ||
            (wType == DBTYPE_BYTES) )
            pInfo[i+1].dwFlags = DBCOLUMNFLAGS_ISNULLABLE;
        else {
            // Temporary check
            // pInfo[i+1].dwFlags = (0);
            pInfo[i+1].dwFlags = DBCOLUMNFLAGS_ISNULLABLE |
                                 DBCOLUMNFLAGS_ISFIXEDLENGTH;
        }

        pInfo[i+1].pTypeInfo = NULL;
        pInfo[i+1].iOrdinal = i+1;
        pInfo[i+1].bPrecision = SetPrecision(wType);
        pInfo[i+1].bScale = (UCHAR) ~0;
        pInfo[i+1].columnid.eKind=DBKIND_NAME;
        pInfo[i+1].columnid.uGuid.guid=GUID_NULL;
        pInfo[i+1].columnid.uName.pwszName=pInfo[i+1].pwszName;

        pos += (wcslen(_ppszAttrs[i]) + 1);
    }

    if( ppfMultiValued ) {
                //
                // Filling in MultiValue array
                //
        BOOL * pfMultiValuedTemp;

                pfMultiValuedTemp= (BOOL *) AllocADsMem(sizeof(BOOL) * (_cAttrs+1));
        if( !(pfMultiValuedTemp) ) {
            hr=E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
                }

        pfMultiValuedTemp[0] = FALSE;   // First one is bookmark which is always FALSE

        for(ULONG j=0; j < _cAttrs; j++) {
            for(ULONG k=0; k < cAttrsReturned; k++) {
                if( !_wcsicmp(_ppszAttrs[j], pAttrDefinition[k].pszAttrName) )
                    break;
            }

            if( (k != cAttrsReturned) &&
                (pAttrDefinition[k].fMultiValued &&
                 IsAutomatable(g_MapADsTypeToVarType[pAttrDefinition[k].dwADsType]))) {
                pfMultiValuedTemp[j+1] = TRUE;
                        }
            else {
                pfMultiValuedTemp[j+1] = FALSE;
                        }
        }
        *ppfMultiValued = pfMultiValuedTemp;
    }

    if( pAttrDefinition ) {
        FreeADsMem(pAttrDefinition);
        }

    *pcColumns      = _cAttrs + 1;
    *prgInfo        = pInfo;
    *ppStringBuffer = pStringBuffer;

    RRETURN( S_OK );

error:

    if( pInfo != NULL )
        _pIMalloc->Free(pInfo);

    if( pStringBuffer != NULL )
        _pIMalloc->Free(pStringBuffer);

    if( pAttrDefinition ) {
        FreeADsMem(pAttrDefinition);
        }

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetColumnInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    10-10-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetColumnInfo(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** prgInfo,
    OLECHAR **      ppStringBuffer
    )
{
    if( pcColumns )
        *pcColumns = 0;

    if( prgInfo )
        *prgInfo = NULL;

    if( ppStringBuffer )
        *ppStringBuffer = NULL;

    if( !pcColumns || !prgInfo || !ppStringBuffer )
        RRETURN( E_INVALIDARG );

    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( !IsCommandPrepared() )
        RRETURN( DB_E_NOTPREPARED );

    RRETURN( GetColumnInfo2(
                pcColumns,
                prgInfo,
                ppStringBuffer,
                NULL
                ) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::MapColumnIDs
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::MapColumnIDs(
        DBORDINAL  cColumnIDs,
        const DBID rgColumnIDs[],
        DBORDINAL  rgColumns[]
        )
{
    DBORDINAL cValidCols = 0;

    //
    // No Column IDs are set when GetColumnInfo returns ColumnsInfo structure.
    // Hence, any value of ID will not match with any column
    //
    DBORDINAL iCol;

    if( cColumnIDs == 0 )
        RRETURN( S_OK );

    // Spec-defined checks.
    // Note that this guarantees we can access rgColumnIDs[] in loop below.
    // (Because we'll just fall through.)
    if ( cColumnIDs && (!rgColumnIDs || !rgColumns) )
        RRETURN( E_INVALIDARG );

    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( !IsCommandPrepared() )
        RRETURN( DB_E_NOTPREPARED );

    //
    // Set the columns ordinals to invalid values
    //
    for(iCol=0; iCol < cColumnIDs; iCol++) {
        // Initialize
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        //
        // The columnid with the Bookmark ID
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_GUID_PROPID &&
            rgColumnIDs[iCol].uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumnIDs[iCol].uName.ulPropid == 2 ) {

            rgColumns[iCol] = 0;
            cValidCols++;
            continue;
        }

        //
        // The columnid with the Column Name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_NAME &&
            rgColumnIDs[iCol].uName.pwszName ) {

            //
            // Find the name in the list of Attributes
            //
            for (ULONG iOrdinal=0; iOrdinal < _cAttrs; iOrdinal++) {
                if( !_wcsicmp(_ppszAttrs[iOrdinal],
                    rgColumnIDs[iCol].uName.pwszName) ) {

                    rgColumns[iCol] = iOrdinal+1;
                    cValidCols++;
                    break;
                }
            }
        }
    }

    if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::Cancel
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::Cancel(
        void
        )
{
    //
    // Need to protect _dwStatus for mutual exclusion when we support
    // multiple threads acting on the same Command object
    //
    _dwStatus |= CMD_EXEC_CANCELLED;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::Execute
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::Execute(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    DBPARAMS *  pParams,
    DBROWCOUNT *pcRowsAffected,
    IUnknown ** ppRowset
    )
{
    HRESULT          hr;
    DWORD            dwFlags = 0;
    ULONG            cAccessors = 0;
    HACCESSOR        *prgAccessors = NULL;
    BOOL             *pbMultiValued = NULL;
    CRowProvider     *pRowProvider  = NULL;
    DBORDINAL        cColumns       = 0;
    DBCOLUMNINFO     *prgInfo       = NULL;
    WCHAR            *pStringBuffer = NULL;
    ULONG            cPropertySets = 0;
    DBPROPSET        *prgPropertySets = NULL;
    ULONG            i, j;

    ADsAssert(_pIMalloc != NULL);
    ADsAssert(_pAccessor != NULL);
    ADsAssert(_pCSession != NULL);

    if( ppRowset )
        *ppRowset = NULL;

    if( pcRowsAffected )
        *pcRowsAffected= -1;

    //
    // If the IID asked for is IID_NULL, then we can expect
    // that this is a non-row returning statement
    //
    if( riid == IID_NULL )
        dwFlags |= EXECUTE_NOROWSET;

    //
    // Check Arguments - Only check on row returning statements
    //
    if( !(dwFlags & EXECUTE_NOROWSET) &&
         (ppRowset == NULL) )
        RRETURN( E_INVALIDARG );

    //
    // Only 1 ParamSet if ppRowset is non-null
    //
    if( pParams &&
        (pParams->cParamSets > 1) &&
         ppRowset )
        RRETURN( E_INVALIDARG );

    //
    // Check that a command has been set
    //
    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( pUnkOuter )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // Prepare the Command if not already done
    //
    if( !IsCommandPrepared() ) {
        hr = PrepareHelper();
        BAIL_ON_FAILURE( hr );
    }

    //
    // Check for a non row returning statement
    //
    if( dwFlags & EXECUTE_NOROWSET )
        RRETURN( S_OK );

    //
    // Get ColumnsInfo based on the list of attributes that we want to be
    // returned
    //
    hr = GetColumnInfo2(
             &cColumns,
             &prgInfo,
             &pStringBuffer,
             &pbMultiValued
             );

        BAIL_ON_FAILURE( hr );

    //
    // Commit the properties in the Command Object as the preferences to the
    // search
    //
    hr = SetSearchPrefs();
    BAIL_ON_FAILURE( hr );

    //
    // Create RowProvider object to pass to rowset code
    //
    _pDSSearch->AddRef();

    hr= CRowProvider::CreateRowProvider(
            _pDSSearch,
            _pszSearchFilter,
            _ppszAttrs,
            _cAttrs,
            cColumns,
            prgInfo,
            pStringBuffer,
            IID_IRowProvider,
            pbMultiValued,
            _fADSPathPresent,
            NULL,
            (void **) &pRowProvider);

    BAIL_ON_FAILURE( hr );

    pbMultiValued = NULL; // RowProvider responsible for deallocation

    //
    // We no longer need the ColumnsInfo; Release it
    //
    if (prgInfo)
    {
        _pIMalloc->Free(prgInfo);
        prgInfo = NULL;
    }

    if (pStringBuffer)
    {
        _pIMalloc->Free(pStringBuffer);
        pStringBuffer = NULL;
    }

    if( _pAccessor &&
        _pAccessor->_pextbuffer ) {
        cAccessors = _pAccessor->_pextbuffer->GetLastHandleCount();
        if( cAccessors > 0 ) {
            prgAccessors = (HACCESSOR *) AllocADsMem(
                               sizeof(HACCESSOR) * cAccessors
                                                           );
            if( !prgAccessors )
                cAccessors = 0;
            else
                for(ULONG i=0; i<cAccessors; i++)
                    prgAccessors[i] = i+1;
        }
    }

    hr = GetProperties(0, NULL, &cPropertySets, &prgPropertySets);
    BAIL_ON_FAILURE( hr );

    hr= CRowset::CreateRowset(
            pRowProvider,
            (LPUNKNOWN)(IAccessor FAR *)this ,
            NULL,
            this,
            cPropertySets,
            prgPropertySets,
            cAccessors,
            prgAccessors,
            _fADSPathPresent,
            _fAllAttrs,
            riid,
            ppRowset
            );

    if (prgAccessors)
    {
        FreeADsMem(prgAccessors);
        prgAccessors = NULL;
    }

    BAIL_ON_FAILURE( hr );

error:

    if (FAILED(hr))
    {
        //
        // Remove the Prepare flag,
        //
        _dwStatus &= ~(CMD_PREPARED);
    }

    //
    // Free the memory
    //
    if( pRowProvider )
        pRowProvider->Release();

    if( prgInfo )
        _pIMalloc->Free(prgInfo);

    if( pStringBuffer )
        _pIMalloc->Free(pStringBuffer);

    if( prgAccessors )
        FreeADsMem(prgAccessors);

    if( pbMultiValued )     {
        FreeADsMem(pbMultiValued);
    }

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        _pIMalloc->Free(prgPropertySets[i].rgProperties);
    }

    _pIMalloc->Free(prgPropertySets);

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetDBSession
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetDBSession(
     REFIID      riid,
     IUnknown ** ppSession
     )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(_pCSession);

    //
    // Check Arguments
    //
    if( ppSession == NULL )
        RRETURN( E_INVALIDARG );

    //
    // Query for the interface on the session object.  If failure,
    // return the error from QueryInterface.
    //
    RRETURN( (_pCSession)->QueryInterface(riid, (VOID**)ppSession) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetProperties
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetProperties(
    const ULONG       cPropIDSets,
    const DBPROPIDSET rgPropIDSets[],
    ULONG *           pcPropSets,
    DBPROPSET **      pprgPropSets
    )
{
    //
        // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Check in-params and NULL out-params in case of error
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_COMMAND);

    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_COMMAND) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::SetProperties
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::SetProperties(
    ULONG     cPropertySets,
    DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

        // Don't allow properties to be set if we've got a rowset open
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            PROPSET_COMMAND) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetCommandText(
    GUID * pguidDialect,
    LPOLESTR *  ppwszCommand
    )
{
    HRESULT hr = S_OK;

    ADsAssert(_pIMalloc!= NULL);

    //
    // Check Function Arguments
    //
    if( ppwszCommand == NULL ) {
        hr = E_INVALIDARG;
        goto error;
        }

    *ppwszCommand = NULL;

    //
    // If the command has not been set, make sure the buffer
    // contains an empty stringt to return to the consumer
    //
    if( !IsCommandSet() ) {
        hr = DB_E_NOCOMMAND;
        goto error;
    }

    //
    // Allocate memory for the string we're going to return to the caller
    //
    *ppwszCommand = (LPWSTR)_pIMalloc->Alloc((wcslen(_pszCommandText)+1) * sizeof(WCHAR));

    if( !*ppwszCommand ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Copy our saved text into the newly allocated string
    //
    wcscpy(*ppwszCommand, _pszCommandText);

    //
    // If the text we're giving back is a different dialect than was
    // requested, let the caller know what dialect the text is in
    //
    if( pguidDialect != NULL && *pguidDialect != _guidCmdDialect)
    {
        hr = DB_S_DIALECTIGNORED;
        *pguidDialect = _guidCmdDialect;
    }

error:

    if( FAILED(hr) ) {
        if( pguidDialect )
            memset(pguidDialect, 0, sizeof(GUID));
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::SetCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::SetCommandText(
    REFGUID   rguidDialect,
    LPCOLESTR pszCommand
    )
{
    // Don't allow text to be set if we've got a rowset open
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    // Check Dialect
    if( rguidDialect != DBGUID_LDAPDialect &&
        rguidDialect != DBGUID_DBSQL &&
        rguidDialect != DBGUID_SQL &&
        rguidDialect != DBGUID_DEFAULT )

        RRETURN( DB_E_DIALECTNOTSUPPORTED );

    //
    // If a CommandText is set  with a Null or an empty string, it effectively
    // unsets the CommandText to a null string
    //
    if( (pszCommand == NULL) ||
        (*pszCommand == L'\0') ) {

        if( _dwStatus & CMD_TEXT_SET )
            FreeADsStr(_pszCommandText);
        _pszCommandText = NULL;
        _dwStatus &= ~(CMD_TEXT_SET | CMD_PREPARED);

        RRETURN( S_OK );
    }

    //
    // Set the CommandText
    //
    LPWSTR pszSQLCmd = (LPWSTR)AllocADsMem((wcslen(pszCommand)+1) * sizeof(WCHAR));

    if( !pszSQLCmd )
        RRETURN( E_OUTOFMEMORY );

    //
    // Free the old memory, and set new text
    //
    if( _dwStatus & CMD_TEXT_SET )
        FreeADsMem(_pszCommandText);

    _pszCommandText = pszSQLCmd;
    wcscpy(_pszCommandText, pszCommand);

        //
        // Reset adspath present flag.
        //
    _fADSPathPresent = FALSE;

    //
    // Set status flag that we have set text
    //
    _dwStatus |= CMD_TEXT_SET;
    _dwStatus &= ~CMD_PREPARED;

    //
    // Remember the dialect that was passed in
    //
    _guidCmdDialect = rguidDialect;


    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CanConvert
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::CanConvert(
    DBTYPE          wFromType,
    DBTYPE          wToType,
    DBCONVERTFLAGS  dwConvertFlags
    )
{
    RRETURN( CanConvertHelper(
                    wFromType,
                    wToType,
                    dwConvertFlags) );
}

//+---------------------------------------------------------------------------
//
//  Function:  SplitCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//
//
//
//
//
//  Returns:    HRESULT
//                  S_OK                    NO ERROR
//                  E_ADS_BAD_PARAMETER   bad parameter
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//              11-21-96   Felix Wong  modified to get only bind and attr
//----------------------------------------------------------------------------
HRESULT
CCommandObject::SplitCommandText(
        LPWSTR pszParsedCmd
        )
{
    LPWSTR pszAttrs = NULL;
    LPWSTR pszFirstAttr = NULL;
    LPWSTR pszCurrentAttr = NULL;
    LPWSTR pszSearchScope = NULL;
    LPWSTR pszTemp = NULL;
    HRESULT hr;
    LPWSTR ptr;

    // Command Text is the concatenation of three components separated by
    // semicolons
    //
    // 1. ADsPathName of the object of the root of the search  which contains
    //    the host name and the context enclosed by '<' and '>'
    // 2. The LDAP search string
    // 3. The list of names of the attributes to be returned separated by
    //    commas
    //
    // If the attributes have any specifiers like Range (for eg.,
    // objectclass;Range=0-1, we need to do some special processing to include
    // it in the list of attributes
    //
    // The fourth component is optional
    //
    // 4. The scope of the search: Either "Base", "Onelevel", "SubTree"
    //    (case insensitve)
    //
    // Search defaults to Subtree
    //
    // White spaces are insignificant

    _searchScope     = ADS_SCOPE_SUBTREE;
    _pszADsContext   = NULL;
    _pszSearchFilter = NULL;

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
        _ppszAttrs = NULL;
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
        _pszCommandTextCp = NULL;
    }

    _pszCommandTextCp = AllocADsStr(pszParsedCmd);
    if( !_pszCommandTextCp)
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    _pszADsContext = RemoveWhiteSpaces(_pszCommandTextCp);

    if( _pszADsContext[0] != L'<' )     {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    _pszADsContext++;
    ptr = _pszADsContext;

    hr = SeekPastADsPath(ptr, &ptr);
    BAIL_ON_FAILURE( hr );

    if( *ptr != L'>' || *(ptr+1) != L';') {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    *ptr = L'\0';
    //
    // If the command text does not contain a filter, set it to NULL
    //
    if (*(ptr + 2) == L';') {
        _pszSearchFilter = NULL;
        ptr+=2;
    }
    else {
        _pszSearchFilter = ptr + 2;
        _pszSearchFilter = RemoveWhiteSpaces(_pszSearchFilter);
        hr = SeekPastSearchFilter(_pszSearchFilter, &ptr);
        BAIL_ON_FAILURE( hr );
    }


    if (*ptr != L';') {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    *ptr = L'\0';
    ptr++;

    //
    // The next component is the list of attributes followed by (optionally)
    // the scope of the search
    //

    // Since the attributes themselves can contain a ';' because of some
    // attribute specifiers, we need to make sure which ';' we are looking at.
    pszAttrs = ptr;

    while ((pszTemp = wcschr(ptr, ';')) != NULL)
        if ( !_wcsicmp(pszTemp+1, L"Base")     ||
             !_wcsicmp(pszTemp+1, L"Onelevel") ||
             !_wcsicmp(pszTemp+1, L"Subtree") )  {
            //
            // we have hit the end of the attribute list
            //
            *pszTemp = L'\0';
            pszSearchScope = pszTemp+1;
            break;
        }
        else {
            ptr = pszTemp + 1;
        }

    if( pszSearchScope ) {
        if(!_wcsicmp(pszSearchScope, L"Base"))
            _searchScope = ADS_SCOPE_BASE;
        else if(!_wcsicmp(pszSearchScope, L"Onelevel"))
            _searchScope = ADS_SCOPE_ONELEVEL;
        else if(!_wcsicmp(pszSearchScope, L"SubTree"))
            _searchScope = ADS_SCOPE_SUBTREE;
        else
            BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);

        //
        // set the search preference property
        //
        DBPROPSET rgCmdPropSet[1];
        DBPROP rgCmdProp[1];

        rgCmdPropSet[0].rgProperties    = rgCmdProp;
        rgCmdPropSet[0].cProperties     = 1;
        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH;

        rgCmdProp[0].dwPropertyID = ADS_SEARCHPREF_SEARCH_SCOPE;
        rgCmdProp[0].dwOptions = DBPROPOPTIONS_REQUIRED;
        rgCmdProp[0].vValue.vt = VT_I4;
        V_I4(&rgCmdProp[0].vValue) = _searchScope;

        hr = SetProperties(
                     1,
                     rgCmdPropSet);
        BAIL_ON_FAILURE( hr );
    }

    pszCurrentAttr = pszFirstAttr = wcstok(pszAttrs, L",");

    for (_cAttrs=0; pszCurrentAttr != NULL; _cAttrs++ )     {
        pszCurrentAttr = wcstok(NULL, L",");
    }

    if( _cAttrs == 0 ) {
        hr=DB_E_ERRORSINCOMMAND;
        goto error;
    }

    pszFirstAttr = RemoveWhiteSpaces(pszFirstAttr);

    if( _cAttrs == 1 && !wcscmp( pszFirstAttr, L"*")) {

        // _cAttrs=1; Just ADsPath and Class attribute is sent
        _ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * _cAttrs);

        if( !_ppszAttrs )
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

        _ppszAttrs[0] = gpszADsPathAttr;
        _fADSPathPresent = TRUE;
        _fAllAttrs = TRUE;
    }
    else {
        // Allocate memory for all the string pointers
        _ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * (_cAttrs+1));

        if( !_ppszAttrs ) {
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
        }

        pszCurrentAttr = pszFirstAttr;

        // Remember  if adspath and rdn are avaialble or not.
        for (ULONG i=0 ; i < _cAttrs; i++) {
            if( !_wcsicmp(L"ADsPath", pszCurrentAttr) )
                _fADSPathPresent = TRUE;

            _ppszAttrs[i] = pszCurrentAttr;
            pszCurrentAttr += wcslen(pszCurrentAttr) + 1;
            _ppszAttrs[i] = RemoveWhiteSpaces(_ppszAttrs[i]);
        }

        //
        // If adspath is not in the list add it
        //
        if( _fADSPathPresent == FALSE )
            _ppszAttrs[i] = L"ADsPath";

        _fAllAttrs = FALSE; // not a SELECT * query
    }

    RRETURN( S_OK );

error:

    _pszADsContext = NULL;

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
        _ppszAttrs = NULL;
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
        _pszCommandTextCp = NULL;
    }

    RRETURN( hr );
}

//
// Look up for the given attribute name in the list of ADS_ATTR_DEF structures.
// Convert the ADSTYPE to the appropriate OLE DB type.
//
STDMETHODIMP
CCommandObject::GetDBType(
    PADS_ATTR_DEF pAttrDefinition,
    DWORD         dwNumAttrs,
    LPWSTR        pszAttrName,
    WORD *        pwType,
    DBLENGTH *    pulSize
    )
{
    HRESULT hr = S_OK;

    ADsAssert(pwType && pulSize);

    for (ULONG i=0; i < dwNumAttrs; i++) {
        if( !_wcsicmp(pszAttrName, pAttrDefinition[i].pszAttrName) )
            break;
    }

    if( i == dwNumAttrs )
    BAIL_ON_FAILURE( hr=E_ADS_PROPERTY_NOT_FOUND );

    if( pAttrDefinition[i].fMultiValued &&
        IsAutomatable(g_MapADsTypeToVarType[pAttrDefinition[i].dwADsType])) {
        //
        // Can be represented it as a variant
        //
        *pwType =  DBTYPE_VARIANT | DBTYPE_BYREF;
        *pulSize = sizeof(VARIANT);

    }
    else if( (ULONG)pAttrDefinition[i].dwADsType >= g_cMapADsTypeToDBType ||
             pAttrDefinition[i].dwADsType == ADSTYPE_INVALID              ||
             pAttrDefinition[i].dwADsType == ADSTYPE_PROV_SPECIFIC) {
        BAIL_ON_FAILURE( hr=E_ADS_CANT_CONVERT_DATATYPE );
    }
    else {
        *pwType =  g_MapADsTypeToDBType[pAttrDefinition[i].dwADsType].wType;
        *pulSize = g_MapADsTypeToDBType[pAttrDefinition[i].dwADsType].ulSize;
    }

error:

    RRETURN (hr);
}


STDMETHODIMP
CCommandObject::SetSearchPrefs(
        void
        )
{
    PROPSET              *pPropSet;
    PADS_SEARCHPREF_INFO  pSearchPref = NULL;
    HRESULT               hr = S_OK;
    ULONG                 i;

    //
    // Asserts
    //
    ADsAssert(_pUtilProp);
    ADsAssert(_pDSSearch);

    pPropSet = _pUtilProp->GetPropSetFromGuid(DBPROPSET_ADSISEARCH);

    if( !pPropSet || !pPropSet->cProperties )
        RRETURN( S_OK );

    pSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem(
                                                 pPropSet->cProperties *
                                                 sizeof(ADS_SEARCHPREF_INFO)
                                                 );
    if( !pSearchPref )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    for (i=0; i<pPropSet->cProperties; i++) {
        hr = _pUtilProp->GetSearchPrefInfo(
                             pPropSet->pUPropInfo[i].dwPropertyID,
                             &pSearchPref[i]
                                                         );
        BAIL_ON_FAILURE( hr );
    }

    hr = _pDSSearch->SetSearchPreference(
                                pSearchPref,
                                pPropSet->cProperties
                                );

    _pUtilProp->FreeSearchPrefInfo(pSearchPref, pPropSet->cProperties);

    BAIL_ON_FAILURE( hr );

error:

    if( pSearchPref )
        FreeADsMem(pSearchPref);

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CCommandObject
//
//  Synopsis:  Constructor
//
//  Arguments:
//             pUnkOuter         Outer Unkown Pointer
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CCommandObject::CCommandObject(
    LPUNKNOWN pUnkOuter       // Outer Unkown Pointer
    )
{
    //    Initialize simple member vars
    _pUnkOuter       = pUnkOuter ? pUnkOuter : (IAccessor FAR *) this;
    _dwStatus        = 0L;
    _cRowsetsOpen    = 0;
    _pAccessor       = NULL;
    _pUtilProp       = NULL;
    _pDSSearch       = NULL;
    _fADSPathPresent = FALSE;
    _fAllAttrs       = FALSE;

    ENLIST_TRACKING(CCommandObject);
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::~CCommandObject
//
//  Synopsis:  Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CCommandObject::~CCommandObject( )
{
    if( _pCSession ) {
        _pCSession->DecrementOpenCommands();
        _pCSession->Release();
    }

    delete _pUtilProp;

    if( _pszCommandText ) {
        FreeADsMem(_pszCommandText);
    }

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
    }

    if( _pAccessor )
        delete _pAccessor;

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pDSSearch ) {
        _pDSSearch->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::FInit
//
//  Synopsis:  Initialize the data source Object
//
//  Arguments:
//
//  Returns:
//             Did the Initialization Succeed
//                  TRUE        Initialization succeeded
//                  FALSE       Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL
CCommandObject::FInit(
    CSessionObject * pSession,
    CCredentials&    Credentials
    )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(pSession);
    ADsAssert(&Credentials);

    _pCSession = pSession;
    _pCSession->AddRef();
    _pCSession->IncrementOpenCommands();

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();
    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&Credentials);
    BAIL_ON_FAILURE(hr);

    // IAccessor is always instantiated.
    _pAccessor = new CImpIAccessor(this, _pUnkOuter);
    if( _pAccessor == NULL || FAILED(_pAccessor->FInit()) )
        return FALSE;

    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    if( FAILED(hr) )
        return FALSE;

    _Credentials = Credentials;

    return TRUE;

error:

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::QueryInterface
//
//  Synopsis:  Returns a pointer to a specified interface. Callers use
//             QueryInterface to determine which interfaces the called object
//             supports.
//
//  Arguments:
//            riid     Interface ID of the interface being queried for
//            ppv      Pointer to interface that was instantiated
//
//  Returns:
//             S_OK               Interface is supported and ppvObject is set.
//             E_NOINTERFACE      Interface is not supported by the object
//             E_INVALIDARG       One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCommandObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    // Is the pointer bad?
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IAccessor) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IColumnsInfo) ) {
        *ppv = (IColumnsInfo FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommand) ) {
        *ppv = (ICommand FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandProperties) ) {
        *ppv = (ICommandProperties FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandText) ) {
        *ppv = (ICommandText FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IConvertType) ) {
        *ppv = (IConvertType FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandPrepare) ) {
        *ppv = (ICommandPrepare FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

BOOL
IsAutomatable(
    DBTYPE dbType
    )
{
    if (dbType != DBTYPE_NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HRESULT
CCommandObject::SeekPastADsPath(
    IN  LPWSTR   pszIn,
    OUT LPWSTR * ppszOut
    )
{
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;
    WCHAR ch = 0;

    // No. of LParans '<' over RParans '>'
    DWORD dwParanOffset = 1;

    ADsAssert(pszIn);
    ADsAssert(ppszOut);

    while (1) {

        ch = *pszIn;

        if( ch == TEXT('\0') ) {
            break;
        }

        if( fEscapeOn ) {
            fEscapeOn = FALSE;
                }
        else if( fQuotingOn ) {
            if( ch == TEXT('"') ) {
                fQuotingOn = FALSE;
            }
        }
        else if( ch == TEXT('\\') ) {
            fEscapeOn = TRUE;
        }
        else if( ch == TEXT('"') ) {
            fQuotingOn = TRUE;
        }
        else if( ch == L'<' ) {
            dwParanOffset++;
        }
        else if( ch == L'>' ) {
            if( --dwParanOffset == 0)
                break;
        }

        pszIn++;
    }

    if( fEscapeOn || fQuotingOn || dwParanOffset != 0 ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
    }

    *ppszOut = pszIn;

    RRETURN( S_OK );
}


HRESULT
CCommandObject::SeekPastSearchFilter(
    IN  LPWSTR   pszIn,
    OUT LPWSTR * ppszOut
    )
{
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;
    DWORD dwParanOffset = 0;

    ADsAssert(pszIn);

    if( *pszIn != L'(' ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
        }

    //
    // No. of LParans over RParans
    //
    dwParanOffset = 1;
    pszIn++;

    while (*pszIn && (*pszIn != L')' || dwParanOffset != 1)) {

        if( *pszIn == L'(' ) {
            dwParanOffset++;
        }

        if( *pszIn == L')' ) {
            dwParanOffset--;
        }

        pszIn++;
    }

    if( *pszIn != L')' ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
    }

    *ppszOut = pszIn + 1;

    RRETURN( S_OK );
}


HRESULT
CCommandObject::Prepare(
    ULONG cExpectedRuns
    )
{
    //
    // If the command has not been set, make sure the buffer
    // contains an empty stringt to return to the consumer
    //
    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    //
    // Don't allow prepare if we've got a rowset open
    //
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // SQL dialect: Convert to LDAP and save
    //
    HRESULT hr = PrepareHelper();

    //
    // Fixup the HRESULT
    //
    if( hr == DB_E_NOTABLE )
        hr = DB_E_ERRORSINCOMMAND;

    BAIL_ON_FAILURE( hr );

    //
    // Set the Prepare state
    //
    _dwStatus |= CMD_PREPARED;

error:

    RRETURN( hr );
}


HRESULT
CCommandObject::Unprepare()
{
    //
    // Don't allow unprepare if we've got a rowset open
    //
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // Reset the Prepare state
    //
    _dwStatus &= ~(CMD_PREPARED);

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::PrepareHelper
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::PrepareHelper(void)
{
    LPWSTR  pszOrderList = NULL;
    LPWSTR  pszSelect    = NULL;
    LPWSTR  pszLocation  = NULL;
    LPWSTR  pszLdapQuery = NULL;
    LPWSTR  pszParsedCmd = NULL;

    //
    // SQL dialect: Convert to LDAP and save
    // If SQLParse Fails the function cleans up memory
    //
    HRESULT hr = SQLParse(
                     (const LPWSTR) _pszCommandText,
                     &pszLocation,
                     &pszLdapQuery,
                     &pszSelect,
                     &pszOrderList
                     );

    if( FAILED(hr) && hr != E_ADS_INVALID_FILTER)
        RRETURN( hr=DB_E_ERRORSINCOMMAND );

    if (SUCCEEDED(hr))
    {
        //
        // the ldap query is optional, it can be NULL. When it is NULL, it 
        // implies a * search.
        //
        DWORD dwLdapQuery = 0;
        if (pszLdapQuery) {
            dwLdapQuery = wcslen(pszLdapQuery);
        }
        pszParsedCmd =(LPWSTR) AllocADsMem((wcslen(pszLocation) +
                                            dwLdapQuery+
                                            wcslen(pszSelect) +
                                            5 + // 2 semicolons and 2 <
                                            1) * sizeof(WCHAR));

        if( !pszParsedCmd ) {
            _dwStatus &= ~CMD_TEXT_SET;
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
        }

        //
        // Put the statement together.
        //
        wcscpy(pszParsedCmd, L"<");
        wcscat(pszParsedCmd, pszLocation);
        wcscat(pszParsedCmd, L">;");
        if (pszLdapQuery)
            wcscat(pszParsedCmd, pszLdapQuery);
        wcscat(pszParsedCmd, L";");
        wcscat(pszParsedCmd, pszSelect);

        hr = SplitCommandText(pszParsedCmd);
    }
    else
    {
        //
        // Assume valid LDAP filter
        //

        hr = SplitCommandText(_pszCommandText);
    }

    BAIL_ON_FAILURE( hr )

    //
    // Set the sort preference property if necessary
    //
    if( pszOrderList ) {

        DBPROPSET rgCmdPropSet[1];
        DBPROP rgCmdProp[1];

        rgCmdPropSet[0].rgProperties    = rgCmdProp;
        rgCmdPropSet[0].cProperties     = 1;
        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH;

        rgCmdProp[0].dwPropertyID = ADSIPROP_SORT_ON;
        rgCmdProp[0].dwOptions    = DBPROPOPTIONS_REQUIRED;
        rgCmdProp[0].vValue.vt    = VT_BSTR;
        V_BSTR (&rgCmdProp[0].vValue) = pszOrderList;

        hr = SetProperties(1, rgCmdPropSet);
        BAIL_ON_FAILURE( hr );
    }

    if( _pDSSearch ) {
        _pDSSearch->Release();
        _pDSSearch = NULL;
    }

    //
    // If integrated security is being used, impersonate the caller
    //
    BOOL fImpersonating;

    fImpersonating = FALSE;
    if(_pCSession->IsIntegratedSecurity())
    {
        HANDLE ThreadToken = _pCSession->GetThreadToken();

        ASSERT(ThreadToken != NULL);
        if (ThreadToken)
        {
            if (!ImpersonateLoggedOnUser(ThreadToken))
                RRETURN(E_FAIL);
            fImpersonating = TRUE;
        }
        else
            RRETURN(E_FAIL);
    }

    hr = GetDSInterface(_pszADsContext,
                        _Credentials,
                        IID_IDirectorySearch,
                        (void **)&_pDSSearch);

   if (fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    BAIL_ON_FAILURE( hr );

error:

    if( pszLocation )
        FreeADsMem(pszLocation);

    if( pszLdapQuery )
       FreeADsMem(pszLdapQuery);

    if( pszSelect )
        FreeADsMem(pszSelect);

    if( pszOrderList )
        FreeADsStr(pszOrderList);

    if( pszParsedCmd )
        FreeADsStr(pszParsedCmd);

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdnstrcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdnstrcf.cxx
//
//  Contents:  DN With String Object class factory
//
//             CADsDNWithStringCF::CreateInstance
//
//  History:   04-26-1999     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsDNWithStringCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsDNWithStringCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CDNWithString::CreateDNWithString(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdbprop.cxx ===
#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

// ---------------- C D B P R O P E R T I E S   C O D E  ----------------------


//-----------------------------------------------------------------------------
// CDBProperties::CDBProperties
//
// @mfunc
// CDBProperties constructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CDBProperties::CDBProperties():
        _cPropSets(0),
        _aPropSets(0),
        _cPropInfoSets(0),
        _aPropInfoSets(0)
{
}

//-----------------------------------------------------------------------------
// CDBProperties::~CDBProperties
//
// @mfunc
// CDBProperties destructor. Release storage used by CDBProperties.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CDBProperties::~CDBProperties()
{
        ULONG iSet, iProp, iSetInfo;

        for (iSet=0; iSet<_cPropSets; ++iSet)
        {
                for (iProp=0; iProp <_aPropSets[iSet].cProperties; ++iProp)
                        VariantClear(&(_aPropSets[iSet].rgProperties[iProp].vValue));
                delete [] _aPropSets[iSet].rgProperties;
        }
        delete [] _aPropSets;

        for (iSet=0; iSet<_cPropInfoSets; ++iSet)
        {
                delete [] _aPropInfoSets[iSet].rgPropertyInfos;
        }
        delete [] _aPropInfoSets;
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertySet
//
// @mfunc Looks up a property set by its GUID.
//
// @rdesc Pointer to desired property set, or 0 if not found.
//-----------------------------------------------------------------------------

DBPROPSET*
CDBProperties::GetPropertySet(const GUID& guid) const
{
        DBPROPSET* pPropSet = 0;                // the answer, assume not found

        // linear search
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
        {
                if (IsEqualGUID(guid, _aPropSets[iPropSet].guidPropertySet))
                {
                        pPropSet = &_aPropSets[iPropSet];
                        break;
                }
        }

        return ( pPropSet );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertyInfoSet
//
// @mfunc Looks up a property info set by its GUID.
//
// @rdesc Pointer to desired property info set, or 0 if not found.
//-----------------------------------------------------------------------------

DBPROPINFOSET*
CDBProperties::GetPropertyInfoSet(const GUID& guid) const
{
        DBPROPINFOSET* pPropInfoSet = 0;                // the answer, assume not found

        // linear search
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<_cPropInfoSets; ++iPropSet)
        {
                if (IsEqualGUID(guid, _aPropInfoSets[iPropSet].guidPropertySet))
                {
                        pPropInfoSet = &_aPropInfoSets[iPropSet];
                        break;
                }
        }

        return ( pPropInfoSet );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertySet
//
// @mfunc Makes a copy of a property set, given its GUID.
//
// @rdesc
//              @flag S_OK                      | copying succeeded,
//              @flag E_FAIL        | no property set for given GUID,
//              @flag E_OUTOFMEMORY | copying failed because of memory allocation.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertySet(const GUID& guid, DBPROPSET* pPropSetDst) const
{
    ADsAssert(pPropSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
        const DBPROPSET* pPropSetSrc = GetPropertySet(guid);
        ULONG iProp;

    if (pPropSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropSetDst = *pPropSetSrc;

    // allocate property array
    pPropSetDst->rgProperties = (DBPROP*)
                    CoTaskMemAlloc(pPropSetSrc->cProperties * sizeof(DBPROP));
    if (pPropSetDst->rgProperties == 0)
    {
        pPropSetDst->cProperties = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

        memcpy( pPropSetDst->rgProperties,
                        pPropSetSrc->rgProperties,
                        pPropSetSrc->cProperties*sizeof(DBPROP));

    // copy the property array
    for (iProp=0; iProp<pPropSetSrc->cProperties; ++iProp)
    {
                VariantInit(&(pPropSetDst->rgProperties[iProp].vValue));
                if(FAILED(hr = VariantCopy(&(pPropSetDst->rgProperties[iProp].vValue),
                                        (VARIANT *)&(pPropSetSrc->rgProperties[iProp].vValue))))
                {
                        while(iProp)
                        {
                                iProp--;
                                VariantClear(&(pPropSetDst->rgProperties[iProp].vValue));
                        }
                        CoTaskMemFree(pPropSetDst->rgProperties);
                        pPropSetDst->rgProperties = NULL;
                        pPropSetDst->cProperties = 0;       // defensive
                        goto Cleanup;
                }
    }

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertyInfoSet
//
// @mfunc Makes a copy of a property info set, given its GUID.
//
// @rdesc
//              @flag S_OK                      | copying succeeded,
//              @flag E_FAIL        | no property set for given GUID,
//              @flag E_OUTOFMEMORY | copying failed because of memory allocation.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertyInfoSet
        (
        const GUID&             guid,
        DBPROPINFOSET*  pPropInfoSetDst,
        WCHAR**                 ppDescBuffer,
        ULONG_PTR*                  pcchDescBuffer,
        ULONG_PTR*                  pichCurrent
        ) const
{
    ADsAssert(pPropInfoSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
        const DBPROPINFOSET* pPropInfoSetSrc = GetPropertyInfoSet(guid);

    if (pPropInfoSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropInfoSetDst = *pPropInfoSetSrc;

    // allocate property array
    pPropInfoSetDst->rgPropertyInfos = (DBPROPINFO *) CoTaskMemAlloc(
                                                pPropInfoSetSrc->cPropertyInfos * sizeof(DBPROPINFO));

    if (pPropInfoSetDst->rgPropertyInfos == 0)
    {
        pPropInfoSetDst->cPropertyInfos = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

        memcpy( pPropInfoSetDst->rgPropertyInfos,
                        pPropInfoSetSrc->rgPropertyInfos,
                        pPropInfoSetSrc->cPropertyInfos*sizeof(DBPROPINFO));

        if(FAILED(hr =CopyPropertyDescriptions(
                                                pPropInfoSetDst,
                                                ppDescBuffer,
                                                pcchDescBuffer,
                                                pichCurrent)))
        {
                CoTaskMemFree(pPropInfoSetDst->rgPropertyInfos);
                pPropInfoSetDst->rgPropertyInfos = NULL;
                pPropInfoSetDst->cPropertyInfos = 0;       // defensive
                hr = E_OUTOFMEMORY;
        }

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetProperty
//
// @mfunc Looks up a property by its property set GUID and ID.
//
// @rdesc Pointer to DBPROP for the property, or 0 if not found.
//-----------------------------------------------------------------------------

const DBPROP*
CDBProperties::GetProperty(const GUID& guid, DBPROPID dwId) const
{
        ULONG iProp;
        const DBPROPSET* pPropSet = GetPropertySet(guid);
        const DBPROP*   pProp = 0;              // the answer, assume not found

        if (pPropSet == 0)                      // no properties for desired property set
                goto Cleanup;

        // look up the desired property in the property set
        for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
        {
                if (dwId == pPropSet->rgProperties[iProp].dwPropertyID)
                {
                        pProp = & pPropSet->rgProperties[iProp];
                        break;
                }
        }

Cleanup:
        return ( pProp );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertyInfo
//
// @mfunc Looks up a property info by its property set GUID and ID.
//
// @rdesc Pointer to DBPROPINFO for the property info, or 0 if not found.
//-----------------------------------------------------------------------------

const DBPROPINFO UNALIGNED*
CDBProperties::GetPropertyInfo(const GUID& guid, DBPROPID dwId) const
{
        ULONG iPropInfo;
        const DBPROPINFOSET* pPropInfoSet = GetPropertyInfoSet(guid);
        const DBPROPINFO UNALIGNED* pPropInfo = 0;          // the answer, assume not found

        if (pPropInfoSet == 0)                  // no properties for desired property set
                goto Cleanup;

        // look up the desired property in the property set
        for (iPropInfo=0; iPropInfo <pPropInfoSet->cPropertyInfos; ++iPropInfo)
        {
                if (dwId == pPropInfoSet->rgPropertyInfos[iPropInfo].dwPropertyID)
                {
                        pPropInfo = & pPropInfoSet->rgPropertyInfos[iPropInfo];
                        break;
                }
        }

Cleanup:
        return ( pPropInfo );
}

//-----------------------------------------------------------------------------
// CDBProperties::SetProperty
//
// @mfunc Adds a new property, or resets an existing one
//        This overloaded function is same as the other except that the
//        last parameter is of type PWSTR [mgorti]
//
// @rdesc
//              @flag S_OK                      | property added/reset,
//              @flag E_OUTOFMEMORY | no memory for new property set or new property.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::SetProperty(const GUID& guid,
                                                   const DBPROP& prop,
                                                   BOOL fAddNew,
                                                   PWSTR pwszDesc)
{
        HRESULT hr;
        DBPROP *pProp;                  // pointer to array entry for new property
        ULONG iProp;
        DBPROPSET* pPropSet = GetPropertySet(guid);

        if (pPropSet == 0)              // no properties yet in desired property set
        {
                if(!fAddNew)
                {
                        hr = E_FAIL;
                        goto Cleanup;
                }

                // get a new property set array
                DBPROPSET * aNewPropSets = new DBPROPSET[_cPropSets + 1];
                if (aNewPropSets == 0)
                {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                }
                memcpy(aNewPropSets, _aPropSets, _cPropSets *sizeof(DBPROPSET));

                // add the new property set
                pPropSet = & aNewPropSets[_cPropSets];
                pPropSet->guidPropertySet = guid;
                pPropSet->cProperties = 0;
                pPropSet->rgProperties = 0;

                // release the old array, install the new one
                delete [] _aPropSets;
                _aPropSets = aNewPropSets;
                ++ _cPropSets;
        }

        // look for the desired property.
        if(!fAddNew)
        {
                pProp = 0;
                for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
                {
                        if (pPropSet->rgProperties[iProp].dwPropertyID ==
                                prop.dwPropertyID)
                        {
                                pProp = &pPropSet->rgProperties[iProp];
                                break;
                        }
                }
                if (pProp == 0)
                {
                        hr = E_FAIL;
                        goto Cleanup;
                }
        }

        // if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
        // portion in the array of DBPROPS, so we must reallocate the array every
        // time we add a property.
        else
        {
                ULONG cPropLeftOver;

                // allocate new property array
                cPropLeftOver =
                        C_PROP_INCR -
                                (pPropSet->cProperties + C_PROP_INCR - 1)%C_PROP_INCR - 1;
                if(cPropLeftOver)
                {
                        pProp = &pPropSet->rgProperties[pPropSet->cProperties];
                }
                else
                {
                        DBPROP* aNewProperties =
                                new DBPROP[pPropSet->cProperties + C_PROP_INCR];
                        if (aNewProperties == 0)
                        {
                                hr = E_OUTOFMEMORY;
                                goto Cleanup;
                        }

                        // copy old array into new
                        memcpy( aNewProperties,
                                        pPropSet->rgProperties,
                                        pPropSet->cProperties *sizeof(DBPROP));

                        // prepare to use new property entry
                        pProp = & aNewProperties[pPropSet->cProperties];

                        // release old array, install new
                        delete [] pPropSet->rgProperties;
                        pPropSet->rgProperties = aNewProperties;
                }
                ++ pPropSet->cProperties;
        }

        // copy the property into my array
        if(!fAddNew)
        {
                DBPROP propSave;

                propSave = *pProp;
                *pProp = prop;
                VariantInit(&(pProp->vValue));
                if(FAILED(hr = VariantCopy(     &(pProp->vValue),
                                                                        (VARIANT *)&(prop.vValue))))
                {
                        *pProp = propSave;
                        goto Cleanup;
                }
        }
        else
        {
                DBPROPINFO propinfo;

                *pProp = prop;
                propinfo.pwszDescription = pwszDesc;
                propinfo.dwPropertyID = prop.dwPropertyID;
                propinfo.dwFlags = DBPROPFLAGS_READ;
                if(guid == DBPROPSET_DBINIT)
                        propinfo.dwFlags |= DBPROPFLAGS_DBINIT;
                else if(guid == DBPROPSET_DATASOURCEINFO)
                        propinfo.dwFlags |= DBPROPFLAGS_DATASOURCEINFO;
                else
                        propinfo.dwFlags |= DBPROPFLAGS_ROWSET;
                propinfo.vtType = V_VT(&(prop.vValue));
                VariantInit(&(propinfo.vValues));
                if(FAILED(hr = SetPropertyInfo(guid, propinfo)))
                        goto Cleanup;
        }

        hr = S_OK;

Cleanup:
        RRETURN ( hr );
}

//-----------------------------------------------------------------------------
// CDBProperties::SetPropertyInfo
//
// @mfunc Adds a new property info, or resets an existing one.
//
// @rdesc
//              @flag S_OK                      | property info added/reset,
//              @flag E_OUTOFMEMORY | no memory for new property info set
//                                                        or new property info.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::SetPropertyInfo(const GUID& guid, const DBPROPINFO& propinfo)
{
        HRESULT hr;
        PDBPROPINFO pPropInfo;          // pointer to array entry for new property
        ULONG iPropInfo;
        DBPROPINFOSET* pPropInfoSet = GetPropertyInfoSet(guid);

        if (pPropInfoSet == 0)          // no properties yet in desired property set
        {

                // get a new property set array
                DBPROPINFOSET * aNewPropInfoSets =
                        new DBPROPINFOSET[_cPropInfoSets + 1];

                if (aNewPropInfoSets == 0)
                {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                }

                memcpy( aNewPropInfoSets,
                                _aPropInfoSets,
                                _cPropInfoSets *sizeof(DBPROPINFOSET));

                // add the new property set
                pPropInfoSet = & aNewPropInfoSets[_cPropInfoSets];
                pPropInfoSet->guidPropertySet = guid;
                pPropInfoSet->cPropertyInfos = 0;
                pPropInfoSet->rgPropertyInfos = 0;

                // release the old array, install the new one
                delete [] _aPropInfoSets;
                _aPropInfoSets = aNewPropInfoSets;
                ++ _cPropInfoSets;
        }

        // look for the desired property.
        pPropInfo = 0;
        for (iPropInfo=0; iPropInfo<pPropInfoSet->cPropertyInfos; ++iPropInfo)
        {
                if (pPropInfoSet->rgPropertyInfos[iPropInfo].dwPropertyID ==
                        propinfo.dwPropertyID)
                {
                        pPropInfo = &pPropInfoSet->rgPropertyInfos[iPropInfo];
                        break;
                }
        }

        // if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
        // portion in the array of DBPROPS, so we must reallocate the array every
        // time we add a property.
        if (pPropInfo == 0)
        {
                ULONG cPropLeftOver;

                // allocate new property array
                cPropLeftOver =
                        C_PROP_INCR -
                                (pPropInfoSet->cPropertyInfos + C_PROP_INCR - 1)%C_PROP_INCR - 1;

                if(cPropLeftOver)
                {
                        pPropInfo =
                                &pPropInfoSet->rgPropertyInfos[pPropInfoSet->cPropertyInfos];
                }
                else
                {
                        DBPROPINFO* aNewPropertyInfos =
                                new DBPROPINFO[pPropInfoSet->cPropertyInfos + C_PROP_INCR];

                        if (aNewPropertyInfos == 0)
                        {
                                hr = E_OUTOFMEMORY;
                                goto Cleanup;
                        }

                        // copy old array into new
                        memcpy( aNewPropertyInfos,
                                        pPropInfoSet->rgPropertyInfos,
                                        pPropInfoSet->cPropertyInfos *sizeof(DBPROPINFO));

                        // prepare to use new property entry
                        pPropInfo = & aNewPropertyInfos[pPropInfoSet->cPropertyInfos];

                        // release old array, install new
                        delete [] pPropInfoSet->rgPropertyInfos;
                        pPropInfoSet->rgPropertyInfos = aNewPropertyInfos;
                }
                ++ pPropInfoSet->cPropertyInfos;
        }

        // copy the property into my array
        *pPropInfo = propinfo;

        hr = S_OK;

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::LoadDescription
//
// @mfunc Loads a localized string from the localization DLL.
//
// @rdesc Count of characters returned in the buffer.
//-----------------------------------------------------------------------------

int
CDBProperties::LoadDescription
        (
        ULONG   ids,            //@parm IN | String ID
        PWSTR   pwszBuff,       //@parm OUT | Temporary buffer
        ULONG   cchBuff         //@parm IN | Count of characters buffer can hold
        ) const
{
        return ( 0 );
//              return( LoadStringW(g_hinstDll, ids, pwszBuff, cchBuff) );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertyDescriptions
//
// @mfunc Copies into a buffer descriptions of properties in a given set.
//
// @rdesc
//              @flag S_OK                      | copying of property descriptions succeeded,
//              @flag E_OUTOFMEMORY | buffer for property descriptions could not
//                                                        be allocated/extended.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertyDescriptions
        (
        DBPROPINFOSET*  pPropInfoSet,
        WCHAR**                 ppDescBuffer,
        ULONG_PTR*                  pcchDescBuffer,
        ULONG_PTR*                  pichCurrent
        ) const
{
        LONG iprop, cchLeft, cchNew;
        int cchCopied;
        WCHAR *pwszTmp;

        if(ppDescBuffer)
        {
                cchLeft = (LONG)*pcchDescBuffer - (LONG)*pichCurrent;
                for(iprop =0; (ULONG)iprop <pPropInfoSet->cPropertyInfos; iprop++)
                {
                        if(pPropInfoSet->rgPropertyInfos[iprop].dwFlags ==
                                DBPROPFLAGS_NOTSUPPORTED)
                                continue;

                        if(cchLeft < (LONG)CCHAR_MAX_PROP_STR_LENGTH)
                        {
                                cchNew = CCHAR_AVERAGE_PROP_STR_LENGTH *
                                                        (pPropInfoSet->cPropertyInfos - iprop - 1) +
                                                                CCHAR_MAX_PROP_STR_LENGTH +
                                                                        *pcchDescBuffer - cchLeft;

                                pwszTmp = (WCHAR *)CoTaskMemAlloc(cchNew *sizeof(WCHAR));
                                if(pwszTmp == NULL)
                                        RRETURN ( E_OUTOFMEMORY );

                                if(*ppDescBuffer)
                                {
                                        memcpy( pwszTmp,
                                                        *ppDescBuffer,
                                                        (*pcchDescBuffer -cchLeft)*sizeof(WCHAR));

                                        CoTaskMemFree(*ppDescBuffer);
                                }
                                cchLeft += cchNew -(LONG)*pcchDescBuffer;
                                *ppDescBuffer = pwszTmp;
                                *pcchDescBuffer = cchNew;
                        }

                        //?? Do we need to load these strings from resources ??
                        //$TODO$ Raid #86943 Copy property descriptions from source to destination buffer.
                        cchCopied = wcslen(pPropInfoSet->rgPropertyInfos[iprop].pwszDescription);
                        wcscpy((WCHAR *)(*ppDescBuffer) + *pichCurrent,
                          pPropInfoSet->rgPropertyInfos[iprop].pwszDescription);
                        pPropInfoSet->rgPropertyInfos[iprop].pwszDescription =
                                (WCHAR *)(*pichCurrent);

                        *pichCurrent += (cchCopied +1);
                        cchLeft -= (cchCopied +1);
                }
        }
        else {
                //      We need to NULL out the pwszDescription values:
                //

                for(iprop =0; (ULONG)iprop <pPropInfoSet->cPropertyInfos; iprop++)
                {
                        pPropInfoSet->rgPropertyInfos[iprop].pwszDescription = NULL;
                }
        }

        RRETURN ( NOERROR );
}

//-----------------------------------------------------------------------------
// CDBProperties::CheckAndInitPropArgs
//
// @mfunc Helper function used while getting property sets.
//        Used to check and get information about property sets.
//        Tells if the caller is requesting
//        special sets or the set of properties in error.
//
// @rdesc
//              @flag S_OK                      | check succeeded,
//              @flag E_INVALIDARG  | one of the arguments is invalid.
//-----------------------------------------------------------------------------
HRESULT
CDBProperties::CheckAndInitPropArgs
        (
        ULONG                           cPropertySets,    // IN | Number of property sets
        const DBPROPIDSET       rgPropertySets[], // IN | Property Sets
        ULONG                           *pcPropertySets,  // OUT | Count of structs returned
        void                            **prgPropertySets,// OUT | Array of Properties
        BOOL                            *pfPropInError,
        BOOL                            *pfPropSpecial
        )
{
        LONG    ipropset;
        ULONG   cpropsetSpecial;

        // Initialize
        if( pcPropertySets )
                *pcPropertySets = 0;
        if( prgPropertySets )
                *prgPropertySets = NULL;
        if(pfPropInError)
                *pfPropInError = FALSE;
        if(pfPropSpecial)
                *pfPropSpecial = FALSE;

        // Check Arguments, on failure post HRESULT to error queue
        if( ((cPropertySets > 0) && !rgPropertySets) ||
                !pcPropertySets ||
                !prgPropertySets )
                RRETURN ( E_INVALIDARG );

        // New argument check for > 1 cPropertyIDs and NULL pointer for
        // array of property ids.
        for(ipropset=0, cpropsetSpecial = 0;
            (ULONG)ipropset<cPropertySets;
                ipropset++)
        {
                if( rgPropertySets[ipropset].cPropertyIDs &&
                        !(rgPropertySets[ipropset].rgPropertyIDs) )
                        RRETURN (E_INVALIDARG);

                //when passing property set DBPROPSET_PROPERTIESINERROR,
                //this is the only set the caller can ask. Also, the
                //count of propertyIDs and the propertyID array must be
                //NULL in this case.
                if( rgPropertySets[ipropset].guidPropertySet ==
                        DBPROPSET_PROPERTIESINERROR )
                {
                        if(pfPropInError)
                        {
                                if(cPropertySets >1
                                   || rgPropertySets[ipropset].cPropertyIDs
                                   || rgPropertySets[ipropset].rgPropertyIDs)
                                        RRETURN (E_INVALIDARG);
                                else
                                        *pfPropInError = TRUE;
                        }
                }
                //Count the number of special property sets being asked.
                else if( rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DATASOURCEALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DATASOURCEINFOALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DBINITALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_SESSIONALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_ROWSETALL)
                        cpropsetSpecial++;
        }

        //When requesting special property sets, all of them
        //must be special or none.
        if(cpropsetSpecial)
        {
                if(pfPropSpecial)
                        *pfPropSpecial = TRUE;
                if(cpropsetSpecial < cPropertySets)
                        RRETURN (E_INVALIDARG);
        }
        else if(pfPropSpecial)
                *pfPropSpecial = FALSE;

        RRETURN ( NOERROR );
}

//-----------------------------------------------------------------------------
// CDBProperties::VerifySetPropertiesArgs
//
// @mfunc Helper function used in IDBProperties::SetProperties. Validates
//        arguments passed to IDBProperties::SetProperties.
//
// @rdesc
//              @flag S_OK                      | Validation succeeded.
//              @flag E_INVALIDARG  | Validation failed - one of the arguments
//                                                        is in error.
//-----------------------------------------------------------------------------
HRESULT
CDBProperties::VerifySetPropertiesArgs
        (
        ULONG           cPropertySets,          //@parm IN | Count of properties
        DBPROPSET       rgPropertySets[]        //@parm IN | Properties
        )
{
        ULONG ipropset;

        if(cPropertySets && rgPropertySets == NULL)
                RRETURN (E_INVALIDARG);

        for(ipropset =0; ipropset <cPropertySets; ipropset++)
                if(     rgPropertySets[ipropset].cProperties &&
                        rgPropertySets[ipropset].rgProperties == NULL)
                        RRETURN (E_INVALIDARG);

        RRETURN ( NOERROR );
}


//-----------------------------------------------------------------------------
// VariantsEqual
//
// @mfunc Tests two variants holding property values for equality.
//
// @rdesc
//              @flag TRUE      | values equal,
//              @flag FALSE | values unequal.
//-----------------------------------------------------------------------------
BOOL VariantsEqual
        (
        VARIANT *pvar1,
        VARIANT *pvar2
        )
{
        if(V_VT(pvar1) != V_VT(pvar1))
                return ( FALSE );
        else if(V_VT(pvar1) == VT_I2)
                return (V_I2(pvar1) == V_I2(pvar2));
        else if(V_VT(pvar1) == VT_BOOL)
                return (V_BOOL(pvar1) == V_BOOL(pvar2));
        else if(V_VT(pvar1) == VT_BSTR)
        {
                if(V_BSTR(pvar1) == NULL || V_BSTR(pvar2) == NULL)
                        return (V_BSTR(pvar1) == V_BSTR(pvar2));
                else
                        return (wcscmp(V_BSTR(pvar1), V_BSTR(pvar2)) == 0);
        }
        else
                return (V_I4(pvar1) == V_I4(pvar2));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdnbincf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdnbincf.cxx
//
//  Contents:  DN With Binary Object class factory
//
//             CADsDNWithBinaryCF::CreateInstance
//
//  History:   04-26-1999     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsDNWithBinaryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsDNWithBinaryCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CDNWithBinary::CreateDNWithBinary(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdnstr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:  CDNWithString.cxx
//
//  Contents:  DNWithString object
//
//  History:   4-23-99     AjayR    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CDNWithString

DEFINE_IDispatch_Implementation(CDNWithString)

CDNWithString::CDNWithString():
        _pszStrVal(NULL),
        _pszDNStr(NULL)
{
    ENLIST_TRACKING(CDNWithString);
}


HRESULT
CDNWithString::CreateDNWithString(
    REFIID riid,
    void **ppvObj
    )
{
    CDNWithString FAR * pDNWithString = NULL;
    HRESULT hr = S_OK;

    hr = AllocateDNWithStringObject(&pDNWithString);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithString->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDNWithString->Release();

    RRETURN(hr);

error:
    delete pDNWithString;

    RRETURN_EXP_IF_ERR(hr);

}


CDNWithString::~CDNWithString( )
{
    delete _pDispMgr;

    if (_pszStrVal) {
        FreeADsStr(_pszStrVal);
    }

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
    }
}

STDMETHODIMP
CDNWithString::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDNWithString))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CDNWithString::AllocateDNWithStringObject(
    CDNWithString ** ppDNWithString
    )
{
    CDNWithString FAR * pDNWithString = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDNWithString = new CDNWithString();
    if (pDNWithString == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDNWithString,
                (IADsDNWithString *)pDNWithString,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pDNWithString->_pDispMgr = pDispMgr;
    *ppDNWithString = pDNWithString;

    RRETURN(hr);

error:

    delete pDNWithString;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CDNWithString::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsDNWithString)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// Methods to get and put the string part.
//

STDMETHODIMP
CDNWithString::get_StringValue(THIS_ BSTR FAR* pbstrValue)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrValue))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszStrVal, pbstrValue);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CDNWithString::put_StringValue(THIS_ BSTR bstrValue)
{

    HRESULT hr = S_OK;

    if (_pszStrVal) {
        FreeADsStr(_pszStrVal);
        _pszStrVal = NULL;
    }

    _pszStrVal = AllocADsStr(bstrValue);
    if (bstrValue && !_pszStrVal) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//
// Methods to get and put the DN string.
//
STDMETHODIMP
CDNWithString::get_DNString(THIS_ BSTR FAR* pbstrDNString)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrDNString))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszDNStr, pbstrDNString);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CDNWithString::put_DNString(THIS_ BSTR bstrDNString)
{

    HRESULT hr = S_OK;

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
        _pszDNStr = NULL;
    }

    _pszDNStr = AllocADsStr(bstrDNString);

    if (bstrDNString && !_pszDNStr) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdsocf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  ADSI DSO Object Class Factory Code
//
//             CDSOCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CDSOCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    // Create Instance code here

    hr = CDSOObject::CreateDSOObject(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cenumvar.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

CEnumVariant::CEnumVariant()
{
    _cRef = 1;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);

    _lpCurrentRouterEntry = g_pRouterHead;

}

CEnumVariant::~CEnumVariant()
{

}


HRESULT
CEnumVariant::Create(IEnumVARIANT **ppenum)
{
    HRESULT     hr;
    CEnumVariant * pEnum;

    pEnum = new CEnumVariant();

    if (!pEnum) {
        RRETURN (E_OUTOFMEMORY);
    }

    if (pEnum)
    {
        hr = pEnum->QueryInterface(IID_IEnumVARIANT,
                                    (void **)ppenum);

        pEnum->Release();
    }
    else
    {
        *ppenum = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

STDMETHODIMP
CEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG)
CEnumVariant::AddRef(void)
{

    return ++_cRef;
}


STDMETHODIMP_(ULONG)
CEnumVariant::Release(void)
{


    if(--_cRef == 0){

        delete this;
        return 0;
    }

    return _cRef;
}

STDMETHODIMP
CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched)
{
    DWORD dwFound = 0;
    PROUTER_ENTRY lpRouter = _lpCurrentRouterEntry;
    HRESULT hr;
    IDispatch * lpDispatch;

    while (lpRouter && (dwFound  < cElements)) {
        hr = CoCreateInstance(*lpRouter->pNamespaceClsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDispatch,
                              (void **)&lpDispatch
                              );
        if (FAILED(hr)) {
            lpRouter = lpRouter->pNext;
            continue;
        }

        VariantInit(&pvar[dwFound]);
        pvar[dwFound].vt = VT_DISPATCH;
        pvar[dwFound].punkVal = lpDispatch;
        dwFound++;

        lpRouter = lpRouter->pNext;
    }
    _lpCurrentRouterEntry = lpRouter;

    //
    // Hack for VB -- it passes NULL always
    //
    if (pcElementFetched) {
        *pcElementFetched = dwFound;
    }
    if (dwFound < cElements) {
        RRETURN(S_FALSE);
    }
    RRETURN(S_OK);
}


STDMETHODIMP
CEnumVariant::Skip(ULONG cElements)
{

    RRETURN(ResultFromScode(E_FAIL));

}

STDMETHODIMP
CEnumVariant::Reset()
{
    RRETURN(ResultFromScode(S_OK));
}

STDMETHODIMP
CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(ResultFromScode(E_FAIL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cextbuff.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  caccess.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//             Implementation of the Extended Buffer Object used for storing
//             accessor handles.
//
//  History:   10-01-96     shanksh    Created.
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


// ---------------------------  C E X T B U F F E R ---------------------------
//
// Implementation class for the Extended Buffer object.


//-----------------------------------------------------------------------------
// CExtBuff::CExtBuff
//
// @mfunc CExtBuff constructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CExtBuff::CExtBuff(
    void
    )
{
    _cItem    = 0;
    _cItemMax = 0;
    _rgItem   = NULL;
}


//-----------------------------------------------------------------------------
// CExtBuff::~CExtBuff
//
// @mfunc CExtBuff destructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CExtBuff::~CExtBuff(
    void
    )
{
    if (_rgItem)
        FreeADsMem(_rgItem);
}


//-----------------------------------------------------------------------------
// FInit::CExtBuff
//
//      CExtBuff initialization (memory allocation for the default item
//      happens  here).
//
// @rdesc Did the Initialization Succeed
//      @flag  TRUE  | Initialization succeeded
//        @flag  FALSE | Initializtion failed
//-----------------------------------------------------------------------------

BOOL CExtBuff::FInit(
    ULONG       cbItem,           // size of items to store
    VOID        *pvItemDefault    // points to a default value to return
                                  // when an element asked for doesn't exist
    )
{
    ULONG_PTR  hItemDefault;

    ADsAssert(cbItem);
    ADsAssert(HIWORD(cbItem) == 0);

    _cbItem = cbItem;
    _rgItem = (BYTE *)AllocADsMem((CEXTBUFFER_DITEM*_cbItem));

    if (_rgItem == NULL)
        return FALSE;

    _cItemMax = CEXTBUFFER_DITEM;

    // It's the first insertion so hItemDefault is always 0 and consequently
    // we don't need to store it.
    if (pvItemDefault)
        return (InsertIntoExtBuffer(pvItemDefault, hItemDefault) == NOERROR);
    else
        return TRUE;
}


//------------------------------------------------------------------------------
// CExtBuff::InsertIntoExtBuffer
//
// @mfunc Stores an item in the Extended Buffer.
//
// @rdesc Returns one of the following values:
//         @flag S_OK          | insertion succeeded,
//         @flag E_OUTOFMEMORY | insertion failed because of memory allocation
 //                              failure
//-----------------------------------------------------------------------------------

STDMETHODIMP CExtBuff::InsertIntoExtBuffer(
    VOID        *pvItem,    // pointer to item to be stored
    ULONG_PTR   &hItem      // points to where the item handle is returned
    )
{
    // If the buffer capacity is exhausted it needs to be reallocated. Buffer capacity
    // is increased by a fixed quantum.
    if (_cItem == _cItemMax) {
        BYTE *pbTmp;

        pbTmp = (BYTE *)ReallocADsMem(
                            _rgItem,
                            _cItemMax * _cbItem,
                            (_cItemMax +CEXTBUFFER_DITEM)*_cbItem
                            );
        if (pbTmp == NULL)
            RRETURN (E_OUTOFMEMORY);

        // Buffer capacity increased.
        _cItemMax += CEXTBUFFER_DITEM;
        _rgItem    = pbTmp;
    }

    // Copy the item.
    memcpy( (_rgItem + _cItem*_cbItem), (BYTE *)pvItem, _cbItem );
    _cItem++;

    // Index of the item constitues its handle.
    hItem = _cItem -1;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cdso.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdso.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//------------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern LONG glnOledbObjCnt; 

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::CreateDSOObject
//
//  Synopsis:  Creates a new DB Session object from the DSO, and returns the
//             requested interface on the newly created object.
//
//  Arguments: pUnkOuter         Controlling IUnknown if being aggregated
//             riid              The ID of the interface
//             ppDBSession       A pointer to memory in which to return the
//                               interface pointer
//
//  Returns:
//                 S_OK                  The method succeeded.
//                 E_INVALIDARG          ppDBSession was NULL
//                 DB_E_NOAGGREGATION    pUnkOuter was not NULL (this object
//                                       does not support being aggregated)
//                 E_FAIL                Provider-specific error. This
//                 E_OUTOFMEMORY         Out of memory
//                 E_NOINTERFACE         Could not obtain requested interface on
//                                       DBSession object
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CDSOObject::CreateDSOObject(
    IUnknown * pUnkOuter,
    REFIID     riid,
    void **    ppvObj
    )
{
    CDSOObject* pDSO = NULL;
    HRESULT hr;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppvObj )
        *ppvObj = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )// && !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // open a DBSession object
    //
    pDSO = new CDSOObject(pUnkOuter);
    if( !pDSO )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( !pDSO->FInit() ) {
        delete pDSO;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DSO Object
    //
    hr = pDSO->QueryInterface( riid, (void **)ppvObj);
    if( FAILED( hr ) ) {
        delete pDSO;
        RRETURN( hr );
    }

    pDSO->Release();

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::Initialize
//
//  Synopsis:  Initializes the DataSource object.
//
//  Arguments:
//
//
//  Returns:   HRESULT
//                  S_OK
//                  E_FAIL
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::Initialize(
    void
    )
{
    HRESULT hr = S_OK;

    if( _fDSOInitialized )
        RRETURN( DB_E_ALREADYINITIALIZED);

    if(IsIntegratedSecurity())
    {
        //
        // If using integrated security, we need to save the calling thread's
        // security context here. Reason is that when we actually connect to
        // the directory, we could be running on a different context, and we
        // need to impersonate this context to work correctly.
        //
        if (!OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_ALL_ACCESS,
                 TRUE,
                 &_ThreadToken))
        {
            //
            // If thread doesn't have a token, use process token
            //
            if (GetLastError() != ERROR_NO_TOKEN ||
                !OpenProcessToken(
                     GetCurrentProcess(),
                     TOKEN_ALL_ACCESS,
                     &_ThreadToken))
            {
                GetLastError();
                BAIL_ON_FAILURE(hr = E_FAIL);

            }
        }
    }

    _fDSOInitialized = TRUE;

error:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::Uninitialize
//
//  Synopsis:  Returns the Data Source Object to an uninitialized state
//
//  Arguments:
//
//
//  Returns:   HRESULT
//                  S_OK            |   The method succeeded
//                  DB_E_OBJECTOPEN |   A DBSession object was already created
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::Uninitialize(
    void
    )
{
    //
    // data source object is not initialized; do nothing
    //
    if( !_fDSOInitialized ) {
        RRETURN( S_OK );
    }
    else {
        if( !IsSessionOpen() ) {
            //
            // DSO initialized, but no DBSession is open.
            // So, reset DSO to uninitialized state
            //

            if (_ThreadToken)
            {
                CloseHandle(_ThreadToken);
                _ThreadToken = NULL;
            }

            _fDSOInitialized = FALSE;
            RRETURN( S_OK );
        }
        else {
            //
            // DBSession has already been created; trying to uninit
            // the DSO now is an error
            //
            RRETURN( DB_E_OBJECTOPEN );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetProperties
//
//  Synopsis:  Returns current settings of all properties in the
//             DBPROPFLAGS_DATASOURCE property group
//
//  Arguments:
//             cPropertySets       count of restiction guids
//             rgPropertySets      restriction guids
//             pcProperties        count of properties returned
//             pprgProperties      property information returned
//
//  Returns:   HRESULT
//                  S_OK          | The method succeeded
//                  E_FAIL        | Provider specific error
//                  E_INVALIDARG  | pcPropertyInfo or prgPropertyInfo was NULL
//                  E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetProperties(
    ULONG             cPropIDSets,
    const DBPROPIDSET rgPropIDSets[],
    ULONG *           pcPropSets,
    DBPROPSET **      pprgPropSets
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // If the Data Source object is initialized.
    //
    DWORD dwBitMask = PROPSET_DSO;

    if( _fDSOInitialized )
    dwBitMask |= PROPSET_INIT;

    //
    // Validate the GetProperties Arguments
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                                cPropIDSets,
                                rgPropIDSets,
                                pcPropSets,
                                pprgPropSets,
                                dwBitMask);
    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            dwBitMask ) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetPropertyInfo
//
//  Synopsis:  Returns information about rowset and data source properties supported
//             by the provider
//
//  Arguments:
//             cPropertySets        Number of properties being asked about
//             rgPropertySets       Array of cPropertySets properties about
//                                  which to return information
//             pcPropertyInfoSets   Number of properties for which information
//                                  is being returned
//             prgPropertyInfoSets  Buffer containing default values returned
//             ppDescBuffer         Buffer containing property descriptions
//
//  Returns:   HRESULT
//                  S_OK          | The method succeeded
//                  E_FAIL        | Provider specific error
//                  E_INVALIDARG  | pcPropertyInfo or prgPropertyInfo was NULL
//                  E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetPropertyInfo(
    ULONG             cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG *           pcPropertyInfoSets,
    DBPROPINFOSET **  pprgPropertyInfoSets,
    WCHAR **          ppDescBuffer)
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetPropertyInfo(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertyInfoSets,
                            pprgPropertyInfoSets,
                            ppDescBuffer,
                            _fDSOInitialized) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::SetProperties
//
//  Synopsis:  Set properties in the DBPROPFLAGS_DATASOURCE property group
//
//  Arguments:
//             cPropertySets
//             rgPropertySets
//
//  Returns:   HRESULT
//                  E_INVALIDARG  | cProperties was not equal to 0 and
//                                  rgProperties was NULL
//                  E_FAIL        | Provider specific error
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::SetProperties(
    ULONG     cPropertySets,
    DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // If the Data Source object is initialized.
    //
    DWORD dwBitMask = PROPSET_DSO;

    if( _fDSOInitialized )
        dwBitMask |= PROPSET_INIT;

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            dwBitMask) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetClassID
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetClassID(
        CLSID * pClassID
    )
{
    if( pClassID )
    {
        memcpy(pClassID, &CLSID_ADsDSOObject, sizeof(CLSID));
        RRETURN( S_OK );
    }

    RRETURN( E_FAIL );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::CreateSession
//
//  Synopsis:  Creates a new DB Session object from the DSO, and returns the
//             requested interface on the newly created object.
//
//  Arguments:
//             pUnkOuter,        Controlling IUnknown if being aggregated
//             riid,             The ID of the interface
//             ppDBSession       A pointer to memory in which to return the
//                               interface pointer
//
//  Returns:   HRESULT
//                 S_OK                  The method succeeded.
//                 E_INVALIDARG          ppDBSession was NULL
//                 DB_E_NOAGGREGATION    pUnkOuter was not NULL (this object
//                                       does not support being aggregated)
//                 E_FAIL                Provider-specific error. This
//                                       provider can only create one DBSession
//                 E_OUTOFMEMORY         Out of memory
//                 E_NOINTERFACE         Could not obtain requested interface
//                                       on DBSession object
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::CreateSession(
        IUnknown *  pUnkOuter,
    REFIID      riid,
    IUnknown ** ppDBSession
    )
{
    CSessionObject* pDBSession = NULL;
    HRESULT                     hr;
    BOOL                        fSuccess;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppDBSession )
        *ppDBSession = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    if( !_fDSOInitialized ) {
        RRETURN(E_UNEXPECTED);
    }

    //
    // open a DBSession object
    //
    pDBSession = new CSessionObject(pUnkOuter);
    if( !pDBSession )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( _pUtilProp->IsIntegratedSecurity() )
    {
        CCredentials    tempCreds;

        tempCreds.SetUserName(NULL);
        tempCreds.SetPassword(NULL);
        tempCreds.SetAuthFlags(_Credentials.GetAuthFlags());

        fSuccess = pDBSession->FInit(this, tempCreds);
    }
    else
    {
        fSuccess = pDBSession->FInit(this, _Credentials);
    }

    if (!fSuccess) {
        delete pDBSession;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DBSession
    //
    hr = pDBSession->QueryInterface( riid, (void **) ppDBSession );
    if( FAILED( hr ) ) {
        delete pDBSession;
        RRETURN( hr );
    }

    pDBSession->Release();

    RRETURN( S_OK );
}

//+-----------------------------------------------------------------------------
//
//  Function:  CDSOObject::CDSOObject
//
//  Synopsis:  Constructor
//
//  Arguments:
//             pUnkOuter         Outer Unkown Pointer
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CDSOObject::CDSOObject(
        LPUNKNOWN pUnkOuter
    )
{
    //  Initialize simple member vars
    _pUnkOuter       = pUnkOuter ? pUnkOuter : (IDBInitialize FAR *) this;
    _fDSOInitialized = FALSE;
    _cSessionsOpen   = FALSE;
    _pUtilProp       = NULL;
    _ThreadToken     = NULL;

    // Set defaults
    _Credentials.SetUserName(NULL);
    _Credentials.SetPassword(NULL);
    _Credentials.SetAuthFlags(0);

    ENLIST_TRACKING(CDSOObject);

    // make sure DLL isn't unloaded until all data source objects are destroyed
    InterlockedIncrement(&glnOledbObjCnt);
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::~CDSOObject
//
//  Synopsis:  Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CDSOObject::~CDSOObject( )
{
    //
    // Free properties management object
    //
    delete _pUtilProp;

    if (_ThreadToken)
        CloseHandle(_ThreadToken);

    InterlockedDecrement(&glnOledbObjCnt);
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::FInit
//
//  Synopsis:  Initialize the data source Object
//
//  Arguments:
//
//  Returns:
//             Did the Initialization Succeed
//                  TRUE        Initialization succeeded
//                  FALSE       Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL CDSOObject::FInit(
    void
    )
{
    HRESULT hr;

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();

    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&_Credentials);
    BAIL_ON_FAILURE( hr );

    return TRUE;

error:
    return FALSE;

}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::QueryInterface
//
//  Synopsis:  Returns a pointer to a specified interface. Callers use
//             QueryInterface to determine which interfaces the called object
//             supports.
//
//  Arguments:
//            riid     Interface ID of the interface being queried for
//            ppv      Pointer to interface that was instantiated
//
//  Returns:
//             S_OK               Interface is supported and ppvObject is set.
//             E_NOINTERFACE      Interface is not supported by the object
//             E_INVALIDARG       One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IDBInitialize FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBInitialize) ) {
        *ppv = (IDBInitialize FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBProperties) ) {
        *ppv = (IDBProperties FAR *) this;
    }
    else if( _fDSOInitialized &&
             IsEqualIID(iid, IID_IDBCreateSession) ) {
        *ppv = (IDBCreateSession FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IPersist) ) {
        *ppv = (IPersist FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cenumacl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumacl.cxx
//
//  Contents:  Access Control List Enumerator Code
//
//             CAccCtrlListEnum::Create
//             CAccCtrlListEnum::CAccCtrlListEnum
//             CAccCtrlListEnum::~CAccCtrlListEnum
//             CAccCtrlListEnum::QueryInterface
//             CAccCtrlListEnum::AddRef
//             CAccCtrlListEnum::Release
//             CAccCtrlListEnum::Next
//             CAccCtrlListEnum::Skip
//             CAccCtrlListEnum::Clone
//
//  History:    03-26-98    AjayR Created.
//           This file was cloned from ldap\cenumvar.cxx
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::CAccCtrlListEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    03-26-96   AjayR     Cloned from ldap\cenumvar.
//
//----------------------------------------------------------------------------
CAccCtrlListEnum::CAccCtrlListEnum()
{
    //
    // Set the reference count on the enumerator.
    //
    _cRef = 1;

    _pACL = NULL;
    _curElement = 0;

}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::~CAccCtrlListEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CAccCtrlListEnum::~CAccCtrlListEnum()
{
    //
    // Bump down the reference count on the Collection object
    //

    //
    // Remove its entry (in ACL) as an enumerator of the ACL
    //
    if (_pACL) {
        _pACL->RemoveEnumerator(this);
    }

    // Release the ACL if we have a ref on it
    if (_pACL) {
        _pACL->Release();
        _pACL = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::QueryInterface(
    REFIID iid,
    void FAR* FAR* ppv
    )
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccCtrlListEnum::AddRef(void)
{
    return ++_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccCtrlListEnum::Release(void)
{

    if(--_cRef == 0){

        delete this;
        return 0;
    }

    return _cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnum]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Create
//
//  Synopsis: Create the enumeration object and initialise the
//           the member variables with the appropritate values.
//
//  Arguments:  [ppEnumVariant]
//              [pACL] Pointer to CAccessControlList
//
//  Returns:    HRESULT
//
//  Modifies:   [ppEnumVariant]
//
//----------------------------------------------------------------------------
HRESULT
CAccCtrlListEnum::CreateAclEnum(
    CAccCtrlListEnum FAR* FAR* ppEnumVariant,
    CAccessControlList *pACL
    )
{
    HRESULT hr = S_OK;
    CAccCtrlListEnum FAR* pEnumVariant = NULL;

    *ppEnumVariant = NULL;

    pEnumVariant = new CAccCtrlListEnum();

    if (!pEnumVariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    // Note that we need to release this when we get rid of this object
    pACL->AddRef();
    pEnumVariant->_pACL = pACL;

error:
    if (FAILED(hr))
        delete pEnumVariant;
    else
        *ppEnumVariant = pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);

}


// This method only returns one element at a time even if more
// than one element is asked for, of course pcElmentFetched is
// returned as one.
STDMETHODIMP
CAccCtrlListEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    DWORD dwAceCount = 0;
    IADsAccessControlEntry *pAce = NULL;
    IDispatch *pDispatch = NULL;
    PVARIANT pThisVar = pvar;

    if (pcElementFetched) {
        *pcElementFetched = 0;
    }

    if (_pACL == NULL) {
        RRETURN(hr = S_FALSE);
    }

    // Will get the ace count each time so that changes in the
    // ACL do not affect the enum object

    //
    // ** Changes in ACL does affect the enum object. We should still get 
    // AceCount and check if _curElement within bounds as defensive
    // programming - especially since current model does not add critical
    // section protection on the enumerator for multi-threaded model.
    //  

    hr = _pACL->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);

    if (dwAceCount == 0) {
        hr = S_FALSE;
        RRETURN(hr);
    }

    //
    // valid dwAceCount here (See **) 
    //

    if (_curElement < dwAceCount) {

        // bump up the curElement as we start at 0
        _curElement++;

        // get the corresponding acl pointer and QI it
        hr = _pACL->GetElement(_curElement, &pAce);
        BAIL_ON_FAILURE(hr);

        if (hr != S_FALSE) {


            hr = pAce->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                           );
            BAIL_ON_FAILURE(hr);

            V_DISPATCH(pThisVar) = pDispatch;
            V_VT(pThisVar) = VT_DISPATCH;

            if (pcElementFetched) {
                *pcElementFetched = 1;
            }
        } else {
            RRETURN_EXP_IF_ERR(hr);
        }
    } else {

        // In this case, we need to set hr to S_FALSE
        // as we have returned all the aces.
        hr = S_FALSE;
    }

    RRETURN(hr);

error:

    // if the disp pointer is valid then need to release on ACE
    if (pDispatch) {
        pAce->Release();
    }

    RRETURN(hr);
}


BOOL
CAccCtrlListEnum::
DecrementCurElement(
    )
{
    if (_pACL && _curElement>=1) {

        _curElement--;
        return TRUE;

    } else {    // !pACL || _curElement ==0
        
        //
        // do not decrement _curElement since lower bound limit on curElement
        // is 0.
        //

        return FALSE;
    }
}
        
BOOL
CAccCtrlListEnum::
IncrementCurElement(
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwAceCount;

    if (!_pACL) 
        return FALSE;
    
    hr = _pACL->get_AceCount((long *)&dwAceCount);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (_curElement>=dwAceCount-1) {

        //
        // do not increment _curElement since upper bound limit on curElement
        // already reached; upperbound limit is actually dwAceCount-1 since
        // Next() increment _curElement by 1 before calling 
        // GetElement(_curElement). See Next() for details.
        //

        return FALSE;
    }

    _curElement++;
    return TRUE;
}

DWORD
CAccCtrlListEnum::
GetCurElement(
    )
{
    return _curElement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\clgint.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLargeInteger.cxx
//
//  Contents:  LargeInteger object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CLargeInteger

DEFINE_IDispatch_Implementation(CLargeInteger)

CLargeInteger::CLargeInteger():
        _pDispMgr(NULL),
        _dwHighPart(0),
        _dwLowPart(0)
{
    ENLIST_TRACKING(CLargeInteger);
}


HRESULT
CLargeInteger::CreateLargeInteger(
    REFIID riid,
    void **ppvObj
    )
{
    CLargeInteger FAR * pLargeInteger = NULL;
    HRESULT hr = S_OK;

    hr = AllocateLargeIntegerObject(&pLargeInteger);
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pLargeInteger->Release();

    RRETURN(hr);

error:
    delete pLargeInteger;

    RRETURN_EXP_IF_ERR(hr);

}


CLargeInteger::~CLargeInteger( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CLargeInteger::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsLargeInteger))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLargeInteger::AllocateLargeIntegerObject(
    CLargeInteger ** ppLargeInteger
    )
{
    CLargeInteger FAR * pLargeInteger = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pLargeInteger = new CLargeInteger();
    if (pLargeInteger == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsLargeInteger,
                (IADsLargeInteger *)pLargeInteger,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pLargeInteger->_pDispMgr = pDispMgr;
    *ppLargeInteger = pLargeInteger;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLargeInteger::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsLargeInteger)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CLargeInteger::get_HighPart(THIS_  LONG *retval)
{
   *retval = _dwHighPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::put_HighPart(THIS_   LONG lnHighPart)
{
   _dwHighPart = lnHighPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::get_LowPart(THIS_  LONG *retval)
{
   *retval = _dwLowPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::put_LowPart(THIS_   LONG lnLowPart)
{
   _dwLowPart = lnLowPart;
   RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\clgintcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsLagreIntegerCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsLargeIntegerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsLargeIntegerCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLargeInteger::CreateLargeInteger(
                iid,
                ppv
                );

    RRETURN(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cnamesps.cxx ===
#include "oleds.hxx"
#pragma hdrstop

#define DISPID_REGULAR      1
//  Class CADsNamespaces

DEFINE_IDispatch_Implementation(CADsNamespaces)
DEFINE_IADs_Implementation(CADsNamespaces)


CADsNamespaces::CADsNamespaces():
    _pDispMgr(NULL),
    _bstrDefaultContainer(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CADsNamespaces);
}

HRESULT
CADsNamespaces::CreateNamespaces(
    BSTR Parent,
    BSTR NamespacesName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CADsNamespaces FAR * pNamespaces = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespacesObject(&pNamespaces);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->InitializeCoreObject(Parent,
                                           NamespacesName,
                                           L"Namespaces",
                                           CLSID_ADsNamespaces,
                                           dwObjectState);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespaces->Release();

    RRETURN(hr);

error:

    delete pNamespaces;
    RRETURN_EXP_IF_ERR(hr);
}


CADsNamespaces::~CADsNamespaces( )
{
    ADsFreeString(_bstrDefaultContainer);
    delete _pDispMgr;

}

STDMETHODIMP
CADsNamespaces::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNamespaces))
    {
        *ppv = (IADsNamespaces FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CADsNamespaces::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsNamespaces)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CADsNamespaces::SetInfo()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::GetInfo()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsContainer methods */

STDMETHODIMP
CADsNamespaces::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CADsNamespaces::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vFilter);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::get_Hints(THIS_ VARIANT FAR* pHints)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::put_Hints(THIS_ VARIANT Hints)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    wcscpy(szBuffer, RelativeName);

    hr = ::GetObject(
                szBuffer,
                IID_IDispatch,
                (LPVOID *)ppObject,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CEnumVariant::Create(&penum);
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(IID_IUnknown,
                               (VOID FAR* FAR*)retval);

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// IADsNamespaces methods
//

STDMETHODIMP
CADsNamespaces::get_DefaultContainer(THIS_ BSTR FAR* retval)
{

    LPTSTR pszDefContainer = NULL;
    HRESULT hr;

    hr = QueryKeyValue(DEF_CONT_REG_LOCATION,
                       TEXT("DefaultContainer"),
                       &pszDefContainer);

    BAIL_IF_ERROR(hr);

    hr = ADsAllocString(pszDefContainer, retval);

cleanup:
    if(pszDefContainer){
        FreeADsMem(pszDefContainer);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::put_DefaultContainer(THIS_ BSTR bstrDefaultContainer)
{
    HRESULT hr =  S_OK;

    hr = SetKeyAndValue(DEF_CONT_REG_LOCATION,
                        TEXT("DefaultContainer"),
                        NULL,
                        bstrDefaultContainer);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CADsNamespaces::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CADsNamespaces::AllocateNamespacesObject(
    CADsNamespaces ** ppNamespaces
    )
{
    CADsNamespaces FAR * pNamespaces = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespaces = new CADsNamespaces();
    if (pNamespaces == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespaces,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespaces,
                           DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);

    pNamespaces->_pDispMgr = pDispMgr;
    *ppNamespaces = pNamespaces;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cnamscf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsNamespacesCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsNamespacesCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CADsNamespaces *     pDomain;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CADsNamespaces::CreateNamespaces(
             L"",
             L"ADs:",
             ADS_OBJECT_BOUND,
             iid,
             ppv
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString(Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}


CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}




HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Name, retval));
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsPath, retval));

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsClass, retval));
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Parent, retval));
}



HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsGuid, retval));
}


STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CADsProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//  Class CADsProvider

CADsProvider::CADsProvider()
{

}

HRESULT
CADsProvider::Create(CADsProvider FAR * FAR * ppProvider)
{
    CADsProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CADsProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CADsProvider::~CADsProvider( )
{
    ENLIST_TRACKING(CADsProvider);
}

STDMETHODIMP
CADsProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CADsProvider::ParseDisplayName(IBindCtx* pbc, WCHAR* szDisplayName, ULONG* pchEaten, IMoniker** ppmk)
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN(hr);
}


HRESULT
CADsProvider::ResolvePathName(IBindCtx* pbc,
                WCHAR* szDisplayName,
                ULONG* pchEaten,
                IMoniker** ppmk
                )
{
    HRESULT hr = S_OK;
    LPUNKNOWN pUnknown = NULL;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;

    //
    // The ADs: Path would only work if it contains the exact
    // text L"ADs:" or L"ADs://" for backward compatibility.
    //
    if ((_wcsicmp(szDisplayName,L"ADs:") != 0)
        && (_wcsicmp(szDisplayName, L"ADs://") != 0 )) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_IF_ERROR(hr);
    }

    hr = CADsNamespaces::CreateNamespaces(
             L"",
             L"ADs:",
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cprop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPropertyEntry.cxx
//
//  Contents:  PropertyEntry object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CPropertyEntry

DEFINE_IDispatch_Implementation(CPropertyEntry)

CPropertyEntry::CPropertyEntry():
        _pDispMgr(NULL),
        _lpName(NULL),
        _dwValueCount(0),
        _dwADsType(0),
        _dwControlCode(0)
{
    ENLIST_TRACKING(CPropertyEntry);
}


HRESULT
CPropertyEntry::CreatePropertyEntry(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyEntry FAR * pPropertyEntry = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyEntryObject(&pPropertyEntry);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyEntry->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyEntry->Release();

    RRETURN(hr);

error:
    delete pPropertyEntry;

    RRETURN_EXP_IF_ERR(hr);

}


CPropertyEntry::~CPropertyEntry( )
{
   VariantClear(&_propVar);

   if (_lpName) {
       FreeADsStr(_lpName);
   }

   delete _pDispMgr;
}

STDMETHODIMP
CPropertyEntry::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyEntry))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPropertyEntry::AllocatePropertyEntryObject(
    CPropertyEntry ** ppPropertyEntry
    )
{
    CPropertyEntry FAR * pPropertyEntry = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyEntry = new CPropertyEntry();
    if (pPropertyEntry == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyEntry,
                (IADsPropertyEntry *)pPropertyEntry,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyEntry->_pDispMgr = pDispMgr;
    *ppPropertyEntry = pPropertyEntry;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CPropertyEntry::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsPropertyEntry)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CPropertyEntry::get_Values(THIS_ VARIANT FAR * retval)
{
    HRESULT hr;
    VariantInit(retval);
    hr = VariantCopy(retval, &_propVar);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CPropertyEntry::put_Values(THIS_ VARIANT vValues)
{
    HRESULT hr;

    // set the values only if it is valid
    if ( (V_VT(&vValues) == (VT_ARRAY | VT_VARIANT))
         || (V_VT(&vValues) == (VT_EMPTY))) {

        hr = VariantCopy(&_propVar, &vValues);
        RRETURN_EXP_IF_ERR(hr);

    } else {

        RRETURN(hr=E_ADS_BAD_PARAMETER);

    }
}


STDMETHODIMP
CPropertyEntry::get_ValueCount(THIS_ long FAR * retval)
{
    *retval = _dwValueCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ValueCount(THIS_ long lnValueCount)
{

    _dwValueCount = lnValueCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyEntry::get_ADsType(THIS_ long FAR * retval)
{
    *retval = _dwADsType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ADsType(THIS_ long lnADsType)
{
    _dwADsType = lnADsType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::get_ControlCode(THIS_ long FAR * retval)
{
    *retval = _dwControlCode;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ControlCode(THIS_ long lnControlCode)
{
    _dwControlCode = lnControlCode;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::get_Name(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CPropertyEntry::put_Name(THIS_ BSTR bstrName)
{

    if (!bstrName) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    if (_lpName) {
        FreeADsStr(_lpName);
    }

    _lpName = AllocADsStr(bstrName);

    if (!_lpName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CPropertyEntry::Clear(THIS_ )
{
    _dwADsType = 0;

    _dwControlCode = 0;

    _dwValueCount = 0;

    VariantClear(&_propVar);

    if (_lpName) {
        FreeADsStr(_lpName);
        _lpName = NULL;
    }

    RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cpropcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsPropertyEntryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsPropertyEntryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyEntry::CreatePropertyEntry(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\common.cxx ===
#include "oleds.hxx"
#pragma hdrstop

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Router routines and properties that are common to
//              all Router objects. Router objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


//+------------------------------------------------------------------------
//
//  Function:   BuildADsPath
//
//  Synopsis:   Returns the ADs path for Router Objects. Note that there
//              is *** ONLY ONE *** Router Object and that is the Namespaces
//              Object.
//              The ADsPath for the Namespaces Object is the same as its
//              Name -- L"ADs:"
//
//  Arguments:  [Parent]  - is NULL and ignored
//              [Name]    - is L"ADs:"
//              [pADsPath] - pointer to a BSTR
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    HRESULT hr = S_OK;

    ADsAssert(pADsPath);

    hr = ADsAllocString(Name, pADsPath);

    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }
 
    RRETURN(ADsAllocString(ADsClass, pADsClass));
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  ADs Provider Object Class Factory Code
//
//             CADsProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CADsProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CADsProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CADsProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\crowprov.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       crowprov.cxx
//
//  Contents:   IProvider implementation for ADSI rowsets
//
//  Functions:
//
//  Notes:
//
//
//  History:    07/10/96  | RenatoB   | Created, lifted most from EricJ code
//-----------------------------------------------------------------------------

// Includes
#include "oleds.hxx"

HRESULT
PackLargeInteger(
    LARGE_INTEGER *plargeint,
    PVARIANT pVarDestObject
    );

HRESULT
PackDNWithBinary(
    PADS_DN_WITH_BINARY pDNWithBinary,
    PVARIANT pVarDestObject
    );

HRESULT
PackDNWithString(
    PADS_DN_WITH_STRING pDNWithString,
    PVARIANT pVarDestObject
    );

//+---------------------------------------------------------------------------
//
//  Function:  CreateRowProvider
//
//  Synopsis:  @mfunc Creates and initializes a Row provider .
//
//----------------------------------------------------------------------------
HRESULT
CRowProvider::CreateRowProvider(
    IDirectorySearch * pDSSearch,
    LPWSTR             pszFilter,
    LPWSTR *           ppszAttrs,
    DWORD              cAttrs,
    DBORDINAL          cColumns,               // count of the rowset's columns
    DBCOLUMNINFO *     rgInfo,                 // array of cColumns DBCOLUMNINFO's
    OLECHAR*           pStringsBuffer,         // the names of the columns are here
    REFIID             riid,
    BOOL *             pMultiValued,
    BOOL               fADSPathPresent,
    CCredentials *     pCredentials,
    void **            ppvObj                  // the created Row provider
    )
{
    HRESULT        hr;
    CRowProvider * pRowProvider = NULL;

    if( ppvObj )
        *ppvObj = NULL;
    else
        BAIL_ON_FAILURE( hr = E_INVALIDARG );

    pRowProvider = new CRowProvider();
    if( pRowProvider == NULL )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

    //
    //initialize rowprovider with the search filter and the columnsinfo
    //
    hr = pRowProvider->FInit(
                        pDSSearch,
                        pszFilter,
                        ppszAttrs,
                        cAttrs,
                        cColumns,
                        rgInfo,
                        pStringsBuffer,
                        pMultiValued,
                        fADSPathPresent,
                        pCredentials
                        );

    if( FAILED(hr) ) {
        delete pRowProvider;
        BAIL_ON_FAILURE( hr );
    }

    //
    // This interface pointer is embedded in the pRowProvider.
    //
    pDSSearch = NULL;

    hr = pRowProvider->QueryInterface( riid, ppvObj);
    if( FAILED(hr) ) {
        delete pRowProvider;
        BAIL_ON_FAILURE( hr );
    }

    pRowProvider->Release();

    RRETURN( S_OK );

error:

    if( pDSSearch )
        pDSSearch->Release();

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::CRowProvider
//
//----------------------------------------------------------------------------
CRowProvider::CRowProvider()
:
    _pMalloc         (NULL),
    _cColumns        (0),
    _ColInfo         (NULL),
    _pwchBuf         (NULL),
    _hSearchHandle   (NULL),
    _pdbSearchCol    (NULL),
    _pDSSearch       (NULL),
    _pMultiValued    (NULL),
    _fADSPathPresent (FALSE),
    _iAdsPathIndex   (0),
    _pCredentials    (NULL)

{
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::~CRowProvider
//
//----------------------------------------------------------------------------
CRowProvider::~CRowProvider()
{
    ULONG i;

    if( _hSearchHandle != NULL )
        _pDSSearch->CloseSearchHandle(_hSearchHandle);

    if( _pDSSearch != NULL )
        _pDSSearch->Release();

    // Release the memory allocated for columns and ColumnsInfo
    if (_pMalloc != NULL) {
        if( _pdbSearchCol != NULL ) {
            _pMalloc->Free((void*)_pdbSearchCol);
        }

        if( _ColInfo != NULL )
            _pMalloc->Free(_ColInfo);

        if( _pwchBuf != NULL )
            _pMalloc->Free(_pwchBuf);

        _pMalloc->Release();
    }

    if( _pMultiValued ) {
        FreeADsMem(_pMultiValued);
    }

    if( _pCredentials )
        delete _pCredentials;
};



//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::Finit
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::FInit(
    IDirectorySearch * pDSSearch,
    LPWSTR             pszFilter,
    LPWSTR *           ppszAttrs,
    DWORD              cAttrs,
    DBORDINAL          cColumns,
    DBCOLUMNINFO *     rgInfo,
    OLECHAR *          pStringsBuffer,
    BOOL *             pMultiValued,
    BOOL                   fADSPathPresent,
    CCredentials *     pCredentials)
{
    HRESULT hr;
    ULONG i;
    ULONG cChars, cCharDispl;

    //
    // Asserts
    //
    ADsAssert(cColumns);
    ADsAssert(rgInfo);
    ADsAssert(pDSSearch);

    _cColumns= cColumns;

    hr = CoGetMalloc(MEMCTX_TASK, &_pMalloc);
    BAIL_ON_FAILURE( hr );

    _ColInfo = (DBCOLUMNINFO*)_pMalloc->Alloc((size_t)(cColumns *sizeof(DBCOLUMNINFO)));
    if( _ColInfo == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(_ColInfo, rgInfo, (size_t)(cColumns * sizeof(DBCOLUMNINFO)));

    cChars = _pMalloc->GetSize(pStringsBuffer);
    _pwchBuf = (WCHAR*)_pMalloc->Alloc(cChars);
    if( _pwchBuf == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(_pwchBuf, (void*)pStringsBuffer , cChars);

    for (i=0; i<_cColumns; i++) {
        if( rgInfo[i].pwszName ) {
            cCharDispl = (ULONG)(rgInfo[i].pwszName - pStringsBuffer);
            _ColInfo[i].pwszName = _pwchBuf + cCharDispl;
            _ColInfo[i].columnid.uName.pwszName = _pwchBuf + cCharDispl;
        }
    }

    // We have adspath at the end of the attribute list.
    _fADSPathPresent  = fADSPathPresent ;

    //Store credentials if non-NULL.
    if( pCredentials ) {
        //We don't expect that _pCredentials is already non-NULL
        ADsAssert(_pCredentials == NULL);
        _pCredentials = new CCredentials(*pCredentials);
        if( !_pCredentials )
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
    }

    if( _fADSPathPresent == FALSE )
        cAttrs++;

    //
    // Create _pdbSearchCol, a member containing an array
    // of DB_SEARCH_COLUMN.
    // Reason for this is that trowset.cpp sometimes asks
    // for GetColumn twice: one to get the size of the column
    // and one to get the data.
    // Since OLEDP copies data, we do not want to have two copies
    // around
    //
    _pdbSearchCol = (PDB_SEARCH_COLUMN)_pMalloc->Alloc((ULONG)((cColumns + 1)*sizeof(DB_SEARCH_COLUMN)));
    if( _pdbSearchCol == NULL ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pDSSearch = pDSSearch;

    hr = _pDSSearch->ExecuteSearch(
             pszFilter,
             ppszAttrs,
             cAttrs,
             &_hSearchHandle
              );
    BAIL_ON_FAILURE( hr );

    _pMultiValued = pMultiValued;

    RRETURN( hr );

error:

    if( _pMalloc != NULL ) {
        if( _pdbSearchCol != NULL ) {
            _pMalloc->Free((void*)_pdbSearchCol);
            _pdbSearchCol= NULL;
        };
        if( _ColInfo != NULL ) {
            _pMalloc->Free(_ColInfo);
            _ColInfo = NULL;
        }

        if( _pwchBuf != NULL ) {
            _pMalloc->Free(_pwchBuf);
            _pwchBuf = NULL;
        }

        _pMalloc->Release();
        _pMalloc = NULL;
    };

    if (_hSearchHandle != NULL)
        _pDSSearch->CloseSearchHandle(_hSearchHandle);

    _hSearchHandle = NULL;

    _pDSSearch = NULL;

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::QueryInterface
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::QueryInterface(
        REFIID   riid,
        LPVOID * ppv)
{
    if( !ppv )
        RRETURN( E_INVALIDARG );

    if( riid == IID_IUnknown
        ||  riid == IID_IRowProvider )
        *ppv = (IRowProvider FAR *) this;
    else if( riid == IID_IColumnsInfo )
        *ppv = (IColumnsInfo FAR *) this;
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
//
//  Function:  CRowProvider::NextRow
//
//  Synopsis:  Advance to the next row.
//
//             Called by: Client.
//             Called when: To advance to next row.
//             This sets the "current" row.
//             Initially the "current" row is prior to the first actual row.
//             (Which means This must be called prior to the first GetColumn call.)
//
//----------------------------------------------------------------------------

STDMETHODIMP
CRowProvider::NextRow()
{
    HRESULT hr;
    ULONG i;
    DWORD dwType, dwExtError = ERROR_SUCCESS;
    VARTYPE vType = VT_NULL;
    const int ERROR_BUF_SIZE = 512;
    const int NAME_BUF_SIZE = 128;
    WCHAR ErrorBuf[ERROR_BUF_SIZE];
    WCHAR NameBuf[NAME_BUF_SIZE];

    do {
        // Clear the ADSI extended error, so that after the call to GetNextRow,
        // we can safely check if an extended error was set.
        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);
        dwExtError = ERROR_SUCCESS;

        //
        // read the next row
        //
        hr = _pDSSearch->GetNextRow(
                        _hSearchHandle
                        );

        // we should treat SIZE_LIMIT_EXCEEDED error message as
        // S_ADS_NOMORE_ROWS
        // in the future, we might want to return this error message
        // to the user under non-paged search situation
        if (LIMIT_EXCEEDED_ERROR(hr))
            hr = S_ADS_NOMORE_ROWS;
        
		BAIL_ON_FAILURE( hr );

        if (hr == S_ADS_NOMORE_ROWS)
        {
            // check if more results are likely (pagedTimeLimit search). If so,
            // we will keep trying till a row is obtained.
            hr = ADsGetLastError(&dwExtError, ErrorBuf, ERROR_BUF_SIZE,
                        NameBuf, NAME_BUF_SIZE);
            BAIL_ON_FAILURE(hr);

            if (dwExtError != ERROR_MORE_DATA)
            // we really have no more data
                RRETURN(DB_S_ENDOFROWSET);
        }
    } while(ERROR_MORE_DATA == dwExtError);

    //
    //read all the columnsinto _pdbSearchCol leaving the bookmark column
    //
    for (i=1; i<_cColumns; i++) {

        hr = _pDSSearch->GetColumn(
                 _hSearchHandle,
                 _ColInfo[i].pwszName,
                 &(_pdbSearchCol[i].adsColumn)
                 );
        if (FAILED(hr)  && hr != E_ADS_COLUMN_NOT_SET)
            goto error;

        if (hr == E_ADS_COLUMN_NOT_SET ||
            _pdbSearchCol[i].adsColumn.dwNumValues == 0) {

            _pdbSearchCol[i].dwStatus = DBSTATUS_S_ISNULL;
            _pdbSearchCol[i].dwType = DBTYPE_EMPTY;
            _pdbSearchCol[i].dwLength = 0;
            hr = S_OK;

        }
        else if (_ColInfo[i].wType == (DBTYPE_VARIANT | DBTYPE_BYREF)) {
            _pdbSearchCol[i].dwStatus = DBSTATUS_S_OK;
            _pdbSearchCol[i].dwType = _ColInfo[i].wType;
            _pdbSearchCol[i].dwLength = sizeof(VARIANT);
        }
        else if ((ULONG) _pdbSearchCol[i].adsColumn.dwADsType >= g_cMapADsTypeToDBType ||
            g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].wType == DBTYPE_NULL) {
            _pdbSearchCol[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            _pdbSearchCol[i].dwType = DBTYPE_EMPTY;
            _pdbSearchCol[i].dwLength = 0;
        }
        else {
            _pdbSearchCol[i].dwStatus = DBSTATUS_S_OK;
            _pdbSearchCol[i].dwType = g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].wType;

            switch (_pdbSearchCol[i].dwType & ~DBTYPE_BYREF) {
            case DBTYPE_WSTR:
                _pdbSearchCol[i].dwLength =
                (wcslen( _pdbSearchCol[i].adsColumn.pADsValues[0].CaseIgnoreString)) *
                sizeof (WCHAR);
                break;

            case DBTYPE_BYTES:
                if(_pdbSearchCol[i].adsColumn.dwADsType == ADSTYPE_OCTET_STRING)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].OctetString.dwLength;
                else if(_pdbSearchCol[i].adsColumn.dwADsType ==
                                         ADSTYPE_NT_SECURITY_DESCRIPTOR)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].SecurityDescriptor.dwLength;
                else if(_pdbSearchCol[i].adsColumn.dwADsType ==
                                          ADSTYPE_PROV_SPECIFIC)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].ProviderSpecific.dwLength;

                break;

            default:
                _pdbSearchCol[i].dwLength = g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].ulSize;
            }
        }
    }

    if ((FALSE == _fADSPathPresent))
    {
        hr = _pDSSearch->GetColumn(
                 _hSearchHandle,
                 L"AdsPath",
                 &(_pdbSearchCol[i].adsColumn)
                 );
        if FAILED(hr)
            goto error;
    }

    RRETURN(hr);

error:
    RRETURN(hr);
}


//-----------------------------------------------------------------------------
//
//  Function:  CRowProvider::GetColumn
//
//  Synopsis:  @mfunc Get a column value.
//
//             We only provide a ptr to the value -- retained in our memory
//             space.
//
//             Called by: Client.
//             Called when: After NextRow, once for each column.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CRowProvider::GetColumn(
    ULONG        iCol,
    DBSTATUS    *pdbStatus,
    ULONG        *pdwLength,
    BYTE        *pbData
    )
{

    DBTYPE columnType = 0;
    DBSTATUS dbStatus_temp = 0;
    BOOL is_Ref = FALSE;
    HRESULT hr = S_OK;

    ADsAssert( 1 <= iCol && iCol <= _cColumns );

    //
    // Note that the caller gives us a ptr to where to put the data.
    // We can fill in dwStatus, dwLength.
    // For pbData, we assume this is a ptr to where we are to write our ptr.
    //
    columnType = _ColInfo[iCol].wType;
    if ((columnType & DBTYPE_ARRAY) || (columnType & DBTYPE_VECTOR) ) {
        if (pdbStatus != NULL)
            *pdbStatus= DBSTATUS_E_UNAVAILABLE;

        if (pdwLength != NULL)
            *pdwLength = 0;

        RRETURN(DB_S_ERRORSOCCURRED);
    }

    if (pdwLength!= NULL)
        *pdwLength = _pdbSearchCol[iCol].dwLength;

    dbStatus_temp = _pdbSearchCol[iCol].dwStatus;

    if (columnType & DBTYPE_BYREF)
        is_Ref = TRUE;

    columnType &= (~DBTYPE_BYREF);

    if (pbData != NULL && dbStatus_temp == DBSTATUS_S_OK) {
        switch (columnType) {
            case DBTYPE_BOOL:
                * (VARIANT_BOOL*) pbData =  _pdbSearchCol[iCol].adsColumn.pADsValues[0].Boolean ?
                                            VARIANT_TRUE: VARIANT_FALSE;
                break;
            case DBTYPE_I4:
                * (DWORD*) pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].Integer;
                break;
            case DBTYPE_WSTR:
                *(WCHAR**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].CaseIgnoreString;
                break;
            case DBTYPE_BYTES:
                if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                 ADSTYPE_OCTET_STRING)
                    *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].OctetString.lpValue;
                else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_NT_SECURITY_DESCRIPTOR)
                     *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].SecurityDescriptor.lpValue;

                else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                 ADSTYPE_PROV_SPECIFIC)
                     *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].ProviderSpecific.lpValue;

                break;
            case DBTYPE_DATE:
                {
                double date = 0;
                hr = SystemTimeToVariantTime(
                                &_pdbSearchCol[iCol].adsColumn.pADsValues[0].UTCTime,
                                &date);
                if( FAILED(hr) )
                    if (pdbStatus != NULL)
                        *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;

                BAIL_ON_FAILURE(hr);
                *(double*)pbData = date;
                break;
                }
            case DBTYPE_VARIANT:
                if (_pMultiValued[iCol] == FALSE) {
                    PVARIANT pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
                    if (!pVariant) {
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                        hr = E_OUTOFMEMORY;
                        BAIL_ON_FAILURE(hr);
                    }

                    if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_LARGE_INTEGER)
                        hr = PackLargeInteger(
                                  &_pdbSearchCol[iCol].adsColumn.pADsValues[0].LargeInteger, pVariant);
                    else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_DN_WITH_BINARY)
                        hr = PackDNWithBinary(_pdbSearchCol[iCol].adsColumn.pADsValues[0].pDNWithBinary, pVariant);

                    else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_DN_WITH_STRING)
                        hr = PackDNWithString(_pdbSearchCol[iCol].adsColumn.pADsValues[0].pDNWithString, pVariant);

                    if( FAILED(hr) )
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                    BAIL_ON_FAILURE(hr);
                    *((PVARIANT*)pbData) = pVariant;
                }
                else {
                    hr = CopyADs2VariantArray(
                         &_pdbSearchCol[iCol].adsColumn,
                         (PVARIANT *) pbData
                         );
                    if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
                        dbStatus_temp= DBSTATUS_E_UNAVAILABLE;
                        break;
                    }
                    if( FAILED(hr) )
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                    BAIL_ON_FAILURE(hr);
                }
                break;

            default:
                dbStatus_temp= DBSTATUS_E_UNAVAILABLE;
                break;
        };
    };
    if (pdbStatus == 0)
        RRETURN(S_OK);

    if (pdbStatus != NULL)

        *pdbStatus = dbStatus_temp;

    if (dbStatus_temp == DBSTATUS_S_OK || dbStatus_temp == DBSTATUS_S_ISNULL)
        RRETURN(S_OK);
    else
        RRETURN(DB_S_ERRORSOCCURRED);

error:
    RRETURN(hr);
}


HRESULT CRowProvider::GetIndex(
    IColumnsInfo* pColumnsInfo,
    LPWSTR lpwszColName,
    int& iIndex
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    int iColumn;
    DBCOLUMNINFO* pColumnInfo = NULL;
    DBORDINAL cColumns = 0;
    OLECHAR* pStringsBuffer = NULL;

    iIndex = 0;
    hr = pColumnsInfo->GetColumnInfo(&cColumns, &pColumnInfo, &pStringsBuffer);
    BAIL_ON_FAILURE(hr);

    for(iColumn = 0; iColumn < cColumns; iColumn++)
    {
        if(pColumnInfo[iColumn].pwszName == NULL || lpwszColName == NULL)
            continue;

        if(!_wcsicmp(pColumnInfo[iColumn].pwszName, lpwszColName))
        {
            iIndex = iColumn;
            break;
        }
    }

    if (pColumnInfo)
        _pMalloc->Free((void*)pColumnInfo);
    if (pStringsBuffer)
        _pMalloc->Free((void*)pStringsBuffer);

    RRETURN(S_OK);

error:
    if (pColumnInfo)
        _pMalloc->Free((void*)pColumnInfo);
    if (pStringsBuffer)
        _pMalloc->Free((void*)pStringsBuffer);
    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif
}

STDMETHODIMP CRowProvider::GetURLFromHROW(
    HROW hRow,
    LPOLESTR  *ppwszURL,
    IRowset* pRowset
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    auto_rel<IAccessor> pAccessor;
    auto_rel<IColumnsInfo> pColumnsInfo;
    HACCESSOR hAccessor = NULL;
    DBBINDING Bindings[1];
    CComVariant   varData;

    if ((NULL == hRow) || (NULL == ppwszURL) || (NULL == pRowset))
        RRETURN(E_INVALIDARG);

    *ppwszURL = NULL;

    // If adspath is in the list of columns selected
    // return that value.
    if (_fADSPathPresent)
    {
        VariantInit(&varData);

        Bindings[0].dwPart      = DBPART_VALUE;
        Bindings[0].dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
        Bindings[0].eParamIO    = DBPARAMIO_NOTPARAM;
        Bindings[0].wType       = DBTYPE_VARIANT;
        Bindings[0].pTypeInfo   = NULL;
        Bindings[0].obValue     = 0;
        Bindings[0].bPrecision  = 0;
        Bindings[0].bScale      = 0;
        Bindings[0].cbMaxLen    = sizeof(VARIANT);
        Bindings[0].pObject     = NULL;
        Bindings[0].pBindExt    = NULL;
        Bindings[0].dwFlags     = 0;

        hr = pRowset->QueryInterface(IID_IAccessor, (void**)&pAccessor);
        BAIL_ON_FAILURE(hr);

        if (_iAdsPathIndex == 0)
        {
            hr = pRowset->QueryInterface(__uuidof(IColumnsInfo), (void **)&pColumnsInfo);
            BAIL_ON_FAILURE(hr);

            hr = GetIndex(pColumnsInfo, L"AdsPath", _iAdsPathIndex);
            if (0 == _iAdsPathIndex)
                hr = E_UNEXPECTED;

            BAIL_ON_FAILURE(hr);
        }

        Bindings[0].iOrdinal    = _iAdsPathIndex;
        Bindings[0].obValue     = NULL;

        hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,sizeof(Bindings)/sizeof(Bindings[0]) , Bindings, 0, &hAccessor, NULL);
        BAIL_ON_FAILURE(hr);
        hr = pRowset->GetData(hRow, hAccessor, &varData);
        BAIL_ON_FAILURE(hr);

        ADsAssert(varData.vt == VT_BSTR);
        ADsAssert(varData.bstrVal);

        // allocate the string and copy data
        *ppwszURL = (LPWSTR ) _pMalloc->Alloc(sizeof(WCHAR) * (wcslen(varData.bstrVal) + 1));
        if (NULL == *ppwszURL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(*ppwszURL, varData.bstrVal);

        if (hAccessor)
            pAccessor->ReleaseAccessor(hAccessor, NULL);

    }
    else
    {
        ADS_CASE_IGNORE_STRING padsPath;

        hr = ((CRowset *)pRowset)->GetADsPathFromHROW(hRow, &padsPath);
        BAIL_ON_FAILURE(hr);

        *ppwszURL = (LPWSTR ) _pMalloc->Alloc(sizeof(WCHAR) *
                        (wcslen(padsPath)  +1));
        if (NULL == *ppwszURL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        wcscpy(*ppwszURL, padsPath);

    }

    RRETURN(S_OK);

error:
    if (hAccessor)
        pAccessor->ReleaseAccessor(hAccessor, NULL);
    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif

}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::GetColumnInfo
//
//  Synopsis:  @mfunc Get Column Info.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::GetColumnInfo(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** pprgInfo,
    WCHAR **        ppStringsBuffer
    )
{
    DBORDINAL i;
    ULONG cChars, cCharDispl;
    HRESULT                hr             = S_OK;
    DBCOLUMNINFO * prgInfo    = NULL;
    WCHAR *        pStrBuffer = NULL;

    //
    // Asserts
    //
    ADsAssert(_pMalloc);
    ADsAssert(_cColumns);
    ADsAssert(_ColInfo);
    ADsAssert(_pwchBuf);

    if( pcColumns )
        *pcColumns = 0;

    if( pprgInfo )
        *pprgInfo = NULL;

    if( ppStringsBuffer )
        *ppStringsBuffer = NULL;

    if( (pcColumns == NULL) || (pprgInfo == NULL) || (ppStringsBuffer == NULL) )
        BAIL_ON_FAILURE( hr=E_INVALIDARG );

    prgInfo = (DBCOLUMNINFO*)_pMalloc->Alloc((ULONG)(_cColumns * sizeof(DBCOLUMNINFO)));
    if( prgInfo == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(prgInfo, _ColInfo, (size_t)(_cColumns * sizeof(DBCOLUMNINFO)));

    cChars = _pMalloc->GetSize(_pwchBuf);
    pStrBuffer  = (WCHAR*)_pMalloc->Alloc(cChars);
    if( pStrBuffer == NULL )
    BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(pStrBuffer, (void*)_pwchBuf , cChars);

    for (i=1; i<_cColumns; i++) {
        cCharDispl = (ULONG)(_ColInfo[i].pwszName - _pwchBuf);
        prgInfo[i].pwszName = pStrBuffer + cCharDispl;
        prgInfo[i].columnid.uName.pwszName = pStrBuffer + cCharDispl;
    };

    *pcColumns       = _cColumns;
    *pprgInfo        = prgInfo;
    *ppStringsBuffer = pStrBuffer;

    RRETURN( S_OK );

error:

    if( !prgInfo )
        _pMalloc->Free(prgInfo);

    if( pStrBuffer != NULL )
        _pMalloc->Free(pStrBuffer);

    RRETURN( hr );
};


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::MapColumnIDs
//
//  Synopsis:  @mfunc Map Column IDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::MapColumnIDs(
    DBORDINAL  cColumnIDs,
    const DBID rgColumnIDs[],
    DBORDINAL  rgColumns[]
    )
{
    ULONG        found = 0;
    DBORDINAL i;

    DBORDINAL cValidCols = 0;
    //
    // No Column IDs are set when GetColumnInfo returns ColumnsInfo structure.
    // Hence, any value of ID will not match with any column
    //
    DBORDINAL iCol;

    //
    // No-Op if cColumnIDs is 0
    //
    if( cColumnIDs == 0 )
        RRETURN( S_OK );

    // Spec-defined checks.
    // Note that this guarantees we can access rgColumnIDs[] in loop below.
    // (Because we'll just fall through.)
    if( cColumnIDs && (!rgColumnIDs || !rgColumns) )
        RRETURN( E_INVALIDARG );

    //
    // Set the columns ordinals to invalid values
    //
    for (iCol=0; iCol < cColumnIDs; iCol++) {
        // Initialize
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        //
        // The columnid with the Bookmark or the same name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_GUID_PROPID &&
            rgColumnIDs[iCol].uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumnIDs[iCol].uName.ulPropid == 2 ) {
            rgColumns[iCol] = 0;
            cValidCols++;
            continue;
        }

        //
        // The columnid with the Column Name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_NAME &&
            rgColumnIDs[iCol].uName.pwszName ) {
            //
            // Find the name in the list of Attributes
            //
            for (ULONG iOrdinal=0; iOrdinal < _cColumns; iOrdinal++) {
                if( _ColInfo[iOrdinal].columnid.eKind == DBKIND_NAME &&
                        !_wcsicmp(_ColInfo[iOrdinal].columnid.uName.pwszName,
                        rgColumnIDs[iCol].uName.pwszName) ) {
                        rgColumns[iCol] = iOrdinal;
                        cValidCols++;
                        break;
                }
            }
        }
    }

    if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}


STDMETHODIMP
CRowProvider::CopyADs2VariantArray(
     PADS_SEARCH_COLUMN pADsColumn,
     PVARIANT *ppVariant
     )
{
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    VARTYPE vType = VT_NULL;
    HRESULT hr = S_OK;
    ULONG i;
    PVARIANT pVariant = NULL, pVarArray = NULL;


    ADsAssert(ppVariant);
    *ppVariant = NULL;

    aBound.lLbound = 0;
    aBound.cElements = pADsColumn->dwNumValues;

    pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
    if (!pVariant) {
        RRETURN(E_OUTOFMEMORY);
    }

    if ((ULONG) pADsColumn->dwADsType >= g_cMapADsTypeToVarType ||
        (vType = g_MapADsTypeToVarType[pADsColumn->dwADsType]) == VT_NULL) {

        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if (aList == NULL)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = SafeArrayAccessData( aList, (void **) &pVarArray );
    if (FAILED(hr)) {
        SafeArrayDestroy( aList );
        goto error;
    }

    for (i=0; i<aBound.cElements; i++) {

        (V_VT(pVarArray+i)) = vType;

        switch (vType) {
        case VT_I4:
            V_I4(pVarArray+i) = pADsColumn->pADsValues[i].Integer;
            break;

        case VT_DISPATCH:
            if(pADsColumn->dwADsType == ADSTYPE_LARGE_INTEGER)
                hr = PackLargeInteger(&pADsColumn->pADsValues[i].LargeInteger,
                                  pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_DN_WITH_BINARY)
                hr = PackDNWithBinary(pADsColumn->pADsValues[i].pDNWithBinary,
                                  pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_DN_WITH_STRING)
                hr = PackDNWithString(pADsColumn->pADsValues[i].pDNWithString,
                                  pVarArray+i);

            BAIL_ON_FAILURE(hr);
            break;

        case VT_BOOL:
            V_I4(pVarArray+i) = pADsColumn->pADsValues[i].Boolean ?
                                          VARIANT_TRUE: VARIANT_FALSE;
            break;

        case VT_BSTR:
            hr = ADsAllocString (
                     pADsColumn->pADsValues[i].CaseIgnoreString,
                     &(V_BSTR(pVarArray+i))
                     );
            if (FAILED(hr)) {
                SafeArrayUnaccessData( aList );
                SafeArrayDestroy( aList );
                goto error;
            }
            break;

       case VT_DATE:
            {
            double date = 0;
            hr = SystemTimeToVariantTime(
                            &pADsColumn->pADsValues[i].UTCTime,
                            &date);
            BAIL_ON_FAILURE(hr);
            V_DATE(pVarArray+i)= date;
            break;
            }

        case (VT_UI1 | VT_ARRAY):
            VariantInit(pVarArray+i);

            if(pADsColumn->dwADsType == ADSTYPE_OCTET_STRING)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].OctetString.dwLength,
                        pADsColumn->pADsValues[i].OctetString.lpValue,
                        pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].SecurityDescriptor.dwLength,
                        pADsColumn->pADsValues[i].SecurityDescriptor.lpValue,
                        pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_PROV_SPECIFIC)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].ProviderSpecific.dwLength,
                        pADsColumn->pADsValues[i].ProviderSpecific.lpValue,
                        pVarArray+i);

            BAIL_ON_FAILURE(hr);
            break;

        default:
            SafeArrayUnaccessData( aList );
            SafeArrayDestroy( aList );
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
            break;
        }

    }

    SafeArrayUnaccessData( aList );

    V_VT((PVARIANT)pVariant) = VT_ARRAY | VT_VARIANT;
    V_ARRAY((PVARIANT)pVariant) = aList;

    *ppVariant = pVariant;

    RRETURN(S_OK);

error:

    if (pVariant) {
        FreeADsMem(pVariant);
    }
    RRETURN(hr);


}


HRESULT
PackLargeInteger(
    LARGE_INTEGER *plargeint,
    PVARIANT pVarDestObject
    )
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_LowPart(plargeint->LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(plargeint->HighPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   V_VT(pVarDestObject) = VT_DISPATCH;
   V_DISPATCH(pVarDestObject) =  pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }
   RRETURN(hr);
}

HRESULT
PackDNWithBinary(
    PADS_DN_WITH_BINARY pDNWithBinary,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr;
    IADsDNWithBinary *pIADsDNWithBinary = NULL;
    BSTR bstrTemp = NULL;
    SAFEARRAYBOUND aBound;
    SAFEARRAY *aList = NULL;
    CHAR HUGEP *pArray = NULL;
    IDispatch *pIDispatch = NULL;

    if( (NULL == pDNWithBinary) || (NULL == pVarDestObject) )
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    hr = CoCreateInstance(
             CLSID_DNWithBinary,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithBinary,
             (void **) &pIADsDNWithBinary
             );
    BAIL_ON_FAILURE(hr);

    if (pDNWithBinary->pszDNString) {
        hr = ADsAllocString(pDNWithBinary->pszDNString, &bstrTemp);
        BAIL_ON_FAILURE(hr);

        //
        // Put the value in the object - we can only set BSTR's
        //
        hr = pIADsDNWithBinary->put_DNString(bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    hr = pIADsDNWithBinary->put_BinaryValue(*pVarDestObject);
    VariantClear(pVarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pIADsDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) &pIDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pIDispatch;

error:
    if(pIADsDNWithBinary)
        pIADsDNWithBinary->Release();

    if (bstrTemp)
        ADsFreeString(bstrTemp);

    RRETURN(hr);
}

HRESULT
PackDNWithString(
    PADS_DN_WITH_STRING pDNWithString,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr;
    IADsDNWithString *pIADsDNWithString = NULL;
    BSTR bstrDNVal = NULL;
    BSTR bstrStrVal = NULL;
    IDispatch *pIDispatch;

    if( (NULL == pDNWithString) || (NULL == pVarDestObject) )
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pIADsDNWithString
             );
    BAIL_ON_FAILURE(hr);

    if (pDNWithString->pszDNString) {
        hr = ADsAllocString(pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pIADsDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pIADsDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pIADsDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) &pIDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pIDispatch;

error:

    if(pIADsDNWithString)
        pIADsDNWithString->Release();

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}

HRESULT
CRowProvider::SeekToNextRow(void)
{
    HRESULT hr;
    DWORD dwExtError = ERROR_SUCCESS;
    const int ERROR_BUF_SIZE = 512;
    const int NAME_BUF_SIZE = 128;
    WCHAR ErrorBuf[ERROR_BUF_SIZE];
    WCHAR NameBuf[NAME_BUF_SIZE];

    do {
        // Clear the ADSI extended error, so that after the call to GetNextRow,
        // we can safely check if an extended error was set.
        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);
        dwExtError = ERROR_SUCCESS;

        //
        // read the next row
        //
        hr = _pDSSearch->GetNextRow(
                        _hSearchHandle
                        );

        // we should treat SIZE_LIMIT_EXCEEDED error message as
        // S_ADS_NOMORE_ROWS
        // in the future, we might want to return this error message
        // to the user under non-paged search situation
        if (LIMIT_EXCEEDED_ERROR(hr))
            hr = S_ADS_NOMORE_ROWS;
        
        BAIL_ON_FAILURE( hr );

        if (hr == S_ADS_NOMORE_ROWS)
        {
            // check if more results are likely (pagedTimeLimit search). If so,
            // we will keep trying till a row is obtained.
            hr = ADsGetLastError(&dwExtError, ErrorBuf, ERROR_BUF_SIZE,
                        NameBuf, NAME_BUF_SIZE);
            BAIL_ON_FAILURE(hr);

            if (dwExtError != ERROR_MORE_DATA)
            // we really have no more data
                RRETURN(S_ADS_NOMORE_ROWS);
        }
    } while(ERROR_MORE_DATA == dwExtError);

error:
    RRETURN(hr);
}

HRESULT
CRowProvider::SeekToPreviousRow(void)
{
    RRETURN( _pDSSearch->GetPreviousRow(_hSearchHandle) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\crowset.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       crowset.cxx
//
//  Contents:   IRowset implementation for ADSI OLEDB provider
//
//--------------------------------------------------------------------------

#include "oleds.hxx"

//-----------------------------------------------------------------------------
// Note on nomenclature
//
// Index - index within the rowset cache.
// 0 <= (Index <= m_cNumRowsCached - 1)
//
// Row - index within the entire rowset (not just the cache).
// 0 <= Row <= #rows in rowset - 1
//
// Bookmark - a unique value associated with each row. Currently, this is the
// same as the row value.
//
// Row handle - handle to a row in the rowset cache that is returned to the
// user. This value has to be unique across all rows currently in the cache
// (rows that the user has a reference on). Although we could use the index
// as this unique value, we will use the row (+1, since 0 == DB_NULL_HROW and
// hence row 0 cannot have a handle of 0). Using the row has the advantage
// that we will be able to detect stale row handles passed in by the user in
// most cases. This would be more difficult with the index as the index can
// be reused.
//
// The rowset cache contains a fixed number of rows, specified by the
// DBPROP_MAXOPENROWS property (if this property is set to 0, the rowset may
// contain as many rows as possble). A row remains in the cache as long as the
// consumer has a reference to the row. A row is removed from the cache when
// its reference count goes to 0, as a result of a call to ReleaseRows. If the
// cache becomes full, subsequent calls to fetch more rows in to the cache will
// return DB_S_ROWLIMITEXCEEDED. The rows in the cache need not be contiguous.
// For example, the consumer might fetch rows 1,2,3 and then call ReleaseRows
// only on 2. In this case, 1 and 3 would still be in the cache. Each row in
// the cache contains its "row" value. Currently, this value is also used as
// the bookmark to the row.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CreateRowset
//
// Creates and initializes a rowset object. Called by a command or session
// object. The rows are brought in only on demand.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::CreateRowset(
    CRowProvider   *pIRowProvider,  // The Row provider
    IUnknown       *pParentObj,     // parent object, a command or a session
    CSessionObject *pCSession,      // Session Object
    CCommandObject *pCCommand,      // Command Object
    ULONG          cPropertySets,   // # property sets in rowset property group
    DBPROPSET      rgPropertySets[],// properties in rowset property group
    ULONG          cAccessors,      // accessor count
    HACCESSOR      rgAccessors[],   // accessors on command object
    BOOL           fadsPathPresent, // Is ADsPath present in query
    BOOL           fAllAttrs,       // Return all attrs from row object?
    REFIID         riid,            // Interface desired
    IUnknown       **ppIRowset      // pointer to desired interface
    )
{
    HRESULT        hr;
    CRowset        *pCRowset = NULL;
    BOOL           fGotWarning = FALSE, fRowObjRequested;
    DBCOUNTITEM    cRowsObtained;
    HROW           *phRow = NULL;

    if( ppIRowset != NULL)
        *ppIRowset = NULL;

    pCRowset = new CRowset();
    if( NULL == pCRowset )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

    hr = pCRowset->FInit(
            pIRowProvider,
            pParentObj,
            pCSession,
            pCCommand,
            cPropertySets,
            rgPropertySets,
            cAccessors,
            rgAccessors,
            fadsPathPresent,
            fAllAttrs
            );
    BAIL_ON_FAILURE(hr);
    if( hr != S_OK )
        fGotWarning = TRUE;

    if( ppIRowset != NULL )
    {
#if (!defined(BUILD_FOR_NT40))
        // If the client requested IRow, create a rowset and get a row object
        // off the rowset. Once we make the provider read/write, we should add
        // IRowChange and IRowSchmaChange here in addition to IRow. If the
        // client set the DBPROP_IRow property, then we always create a row
        // object by default.
        hr = pCRowset->IsRowObjRequested(&fRowObjRequested);
        BAIL_ON_FAILURE( hr );

        if( IsEqualIID(riid, IID_IRow) || (fRowObjRequested) )
        {
            hr = pCRowset->GetNextRows(NULL, 0, 1, &cRowsObtained, &phRow);
            BAIL_ON_FAILURE(hr);

            if( DB_S_ENDOFROWSET == hr )
                BAIL_ON_FAILURE( hr = DB_E_NOTFOUND );

            if( hr != S_OK )
                BAIL_ON_FAILURE( E_FAIL );

            ADsAssert( (1 == cRowsObtained ) && (phRow != NULL) &&
                       (*phRow != DB_NULL_HROW) );

            // Bump up reference count of rowset. This is to avoid the
            // destruction of the rowset if the call below fails. Artificially
            // incrementing the reference count by one will ensure that any
            // call to Release() on the rowset (say, from the destructor of
            // the row object) will not end up in the rowset object being
            // deleted.
            pCRowset->m_cRef++;

            hr = pCRowset->m_pCRowsetInfo->GetRowFromHROW(
                         NULL,
                         *phRow,
                         riid,
                         ppIRowset,
                         FALSE, // this is not a tear-off
                         pCRowset->m_fAllAttrs
                         );

            // Restore reference count
            pCRowset->m_cRef--;

            BAIL_ON_FAILURE(hr);

            // Release the row handle since the row object now has a reference
            // to it. The reference count of the rowset is at 1 now since the
            // row object stored off a pointer to the rowset. The rowset will
            // be freed when the row is released.
            hr = pCRowset->ReleaseRows(1, phRow, NULL, NULL, NULL);
            BAIL_ON_FAILURE(hr);

            // we won't bother returning DB_S_NOTSINGLETON if there are more
            // rows in the rowset since the spec doesn't require it.
        }
        else
#endif
        {
            hr = pCRowset->QueryInterface(riid, (void **)ppIRowset);
            BAIL_ON_FAILURE(hr);
        }
    }
    else // OpenRowset may pass in NULL as ppIRowset
        delete pCRowset;

    if( fGotWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );

error:

    if( pCRowset )
        delete pCRowset;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
// IsRowObjRequested
//
// From the properties specified by the client, check if DBPROP_IRow is set
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::IsRowObjRequested(BOOL *pfRowObjRequested)
{
#if (!defined(BUILD_FOR_NT40))
    DBPROPIDSET rgPropertyIDSets;
    DBPROPID    dbPropId;
    ULONG       cPropSets;
    DBPROPSET   *prgPropertySets;
    VARIANT     *pVariant;
    HRESULT     hr;
    int         i, j;

    if( NULL == pfRowObjRequested )
        BAIL_ON_FAILURE( hr = E_INVALIDARG );

    dbPropId = DBPROP_IRow;
    cPropSets = 0;
    prgPropertySets = NULL;

    rgPropertyIDSets.cPropertyIDs = 1;
    rgPropertyIDSets.rgPropertyIDs = &dbPropId;
    rgPropertyIDSets.guidPropertySet = DBPROPSET_ROWSET;

    hr = m_pCUtilProp->GetProperties(1,
                                     &rgPropertyIDSets,
                                     &cPropSets,
                                     &prgPropertySets,
                                     PROPSET_COMMAND
                                    );
    BAIL_ON_FAILURE( hr );

    ADsAssert( (1 == cPropSets) && (prgPropertySets != NULL) );
    ADsAssert( (1 == prgPropertySets->cProperties) &&
                       (prgPropertySets->rgProperties != NULL) );

    pVariant = &(prgPropertySets->rgProperties[0].vValue);
    *pfRowObjRequested =  V_BOOL( pVariant );

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropSets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN( S_OK );

error:

    RRETURN( hr );
#else
    RRETURN(E_FAIL);
#endif
}

//-----------------------------------------------------------------------------
// CRowset
//
// Constructor initializes all fields to NULL
//
//-----------------------------------------------------------------------------
CRowset::CRowset(void)
{
    m_pCRowsetInfo = NULL;
    m_pCAccessor = NULL;
    m_pCRowProvider = NULL;
    m_pCUtilProp = NULL;

    m_pIDataConvert = NULL;
    m_pIColumnsInfo = NULL;
    m_pIRowProvider = NULL;
    m_pIMalloc = NULL;

    m_lLastFetchRow = RESET_ROW;
    m_cRowBytes = 0;
    m_cCol = 0;

    m_pColData = NULL;

    m_fCritSectionInitialized = FALSE;
    m_fEndOfRowset = FALSE;
    m_fadsPathPresent = TRUE;
    m_fAllAttrs = FALSE;

    m_cNumRowsCached = 0;
    m_LastFetchDir = FORWARD;

    m_pRowsPtr = NULL;
    m_dwRowCacheSize = 0;
    m_lCurrentRow = 0;

    m_cRef = 0;
}

//-----------------------------------------------------------------------------
// ~Crowset
//
// Destructor releases all resources
//
//-----------------------------------------------------------------------------
CRowset::~CRowset(void)
{
    if( m_pRowsPtr )
    {
        int iRow;

        for(iRow = 0; iRow < m_cNumRowsCached; iRow++)
        {
            ADsAssert(m_pRowsPtr[iRow] != NULL);
            FreeRow(m_pRowsPtr[iRow]);
        }

        FreeADsMem(m_pRowsPtr);
    }

    if( m_pCRowsetInfo )
        delete m_pCRowsetInfo;
    if( m_pCAccessor )
        delete m_pCAccessor;
    if( m_pCUtilProp )
        delete m_pCUtilProp;
    // Shouldn't delete m_pCRowProvider since we didn't allocate it

    if( m_pIDataConvert )
        m_pIDataConvert->Release();
    if( m_pIColumnsInfo )
        m_pIColumnsInfo->Release();
    if( m_pIMalloc )
        m_pIMalloc->Release();
    // Shouldn't release m_pIRowProvider since we didn't AddRef it

    if( m_pColData )
        FreeADsMem(m_pColData);

    if( m_fCritSectionInitialized )
        DeleteCriticalSection(&m_RowsetCritSection);
}

//-----------------------------------------------------------------------------
// FInit
//
// Initializes rowset object
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::FInit(
    CRowProvider   *pIRowProvider,  // The Row provider
    IUnknown       *pParentObj,     // parent object, a command or a session
    CSessionObject *pCSession,      // Session Object
    CCommandObject *pCCommand,      // Command Object
    ULONG          cPropertySets,   // # property sets in rowset property group
    DBPROPSET      rgPropertySets[],// properties in rowset property group
    ULONG          cAccessors,      // accessor count
    HACCESSOR      rgAccessors[],   // accessors on command object
    BOOL           fadsPathPresent, // Is ADsPath present in query
    BOOL           fAllAttrs        // Return all attrs from row object?
    )
{
    HRESULT        hr;
    BOOL           fGotWarning = FALSE;

    InitializeCriticalSection(&m_RowsetCritSection);
    m_fCritSectionInitialized = TRUE;

    m_pCRowsetInfo = new CRowsetInfo(NULL, pParentObj, pCSession, pCCommand,
                                           pIRowProvider);

    if( NULL == m_pCRowsetInfo )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCRowsetInfo->FInit( (IUnknown *) ((IAccessor *)this) );
    BAIL_ON_FAILURE(hr);

    m_pCAccessor = new CImpIAccessor(this, NULL);
    if( NULL == m_pCAccessor )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCAccessor->FInit();
    BAIL_ON_FAILURE(hr);

    m_pCRowProvider = pIRowProvider;

    m_pCUtilProp = new CUtilProp();
    if( NULL == m_pCUtilProp )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCUtilProp->FInit(NULL);
    BAIL_ON_FAILURE(hr);

    // Set the properties. Use PROPSET_COMMAND as we only want to set
    // properties in the rowset property group. Any other properties
    // should return error.
    hr = m_pCUtilProp->SetProperties(cPropertySets,
                                     rgPropertySets,
                                     PROPSET_COMMAND
                                     );

    // On session object, we need to check DBPROPOPTIONS to really decide if
    // there was a serious error. See comment before SetSearchPrefs in
    // csession.cxx
    if( pCSession &&
              ((DB_E_ERRORSOCCURRED == hr) || (DB_S_ERRORSOCCURRED == hr)) )
    {
        ULONG i, j;

        for(i = 0; i < cPropertySets; i++)
            for(j = 0; j < rgPropertySets[i].cProperties; j++)
                if( rgPropertySets[i].rgProperties[j].dwStatus !=
                               DBPROPSTATUS_OK )
                    if( rgPropertySets[i].rgProperties[j].dwOptions !=
                               DBPROPOPTIONS_OPTIONAL )
                    {
                        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
                    }
                    else
                        fGotWarning = TRUE;

        // if we get here, then there was all required properties were set
        // successfully. However, hr could still be DB_ERRORSOCCURRED if all
        // properties were optional and all of them could not be set. This
        // condition is not an error for OpenRowset as noted in the comment
        // in csession.cxx. Hence reset hr to S_OK.

        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);
    if( hr != S_OK ) // warning needs to be returned to user
        fGotWarning = TRUE;

    // Get the maximum number of rows the rowset cache should support
    hr = GetMaxCacheSize();
    BAIL_ON_FAILURE(hr);

    // Get IDataConvert interface for later use by IRowset->GetData
    hr = CoCreateInstance(
            CLSID_OLEDB_CONVERSIONLIBRARY,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDataConvert,
            (void **)&m_pIDataConvert
            );
    BAIL_ON_FAILURE(hr);

    // Get IColumnsInfo interface pointer from row provider
    hr = pIRowProvider->QueryInterface(
            IID_IColumnsInfo,
            (void **)&m_pIColumnsInfo
            );
    BAIL_ON_FAILURE(hr);

    // No need to AddRef below since row provider is contained in CRowsetInfo
    // and CRowsetInfo's lifetime is within CRowset.
    m_pIRowProvider = pIRowProvider;

    // Copy inherited accessors from the command object
    hr = CopyAccessors(cAccessors, pCCommand, rgAccessors);
    BAIL_ON_FAILURE(hr);

    hr = CoGetMalloc(MEMCTX_TASK, &m_pIMalloc);
    BAIL_ON_FAILURE(hr);

    // get the column offsets from the row provider
    hr = GetColOffsets();
    BAIL_ON_FAILURE(hr);

    m_fadsPathPresent = fadsPathPresent;
    m_fAllAttrs = fAllAttrs;

    if( fGotWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );

error:

    if( m_pCRowsetInfo != NULL )
        delete m_pCRowsetInfo; // Releases pParentObj, pCCommand, pCSession and
                               // pIRowProvider

    if( m_pCAccessor != NULL )
        delete m_pCAccessor;
    if( m_pCUtilProp != NULL )
        delete m_pCUtilProp;
    if( m_pIDataConvert != NULL )
        m_pIDataConvert->Release();
    if( m_pIColumnsInfo != NULL )
        m_pIColumnsInfo->Release();
    if( m_pIMalloc )
        m_pIMalloc->Release();
    if( m_fCritSectionInitialized )
        DeleteCriticalSection(&m_RowsetCritSection);

    m_pCRowsetInfo = NULL;
    m_pCAccessor = NULL;
    m_pCRowProvider = NULL;
    m_pCUtilProp = NULL;
    m_pIDataConvert = NULL;
    m_pIColumnsInfo = NULL;
    m_pIRowProvider = NULL;
    m_pIMalloc = NULL;

    m_fCritSectionInitialized = FALSE;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetMaxCacheSize
//
// From the properties specified by the client, get the maximum number of rows
// that the rowset cache should support.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetMaxCacheSize(void)
{
    DBPROPIDSET rgPropertyIDSets;
    DBPROPID    dbPropId;
    ULONG       cPropSets;
    DBPROPSET   *prgPropertySets;
    VARIANT     *pVariant;
    HRESULT     hr;
    ULONG       i, j;

    dbPropId = DBPROP_MAXOPENROWS;
    cPropSets = 0;
    prgPropertySets = NULL;

    rgPropertyIDSets.cPropertyIDs = 1;
    rgPropertyIDSets.rgPropertyIDs = &dbPropId;
    rgPropertyIDSets.guidPropertySet = DBPROPSET_ROWSET;

    hr = m_pCUtilProp->GetProperties(1,
                                     &rgPropertyIDSets,
                                     &cPropSets,
                                     &prgPropertySets,
                                     PROPSET_COMMAND
                                    );
    BAIL_ON_FAILURE( hr );

    ADsAssert( (1 == cPropSets) && (prgPropertySets != NULL) );
    ADsAssert( (1 == prgPropertySets->cProperties) &&
                       (prgPropertySets->rgProperties != NULL) );

    pVariant = &(prgPropertySets->rgProperties[0].vValue);
    m_dwMaxCacheSize =  V_I4( pVariant );

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropSets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN( S_OK );

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// CopyAccessors
//
// Copies inherited accessors from the command object to the rowset object. If
// the rowset is being created by a session object, nothing has to be done.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::CopyAccessors(
    ULONG          cAccessors,      // accessor count
    CCommandObject *pCCommand,      // Command Object
    HACCESSOR      rgAccessors[]    // accessors on command object
    )
{
    HRESULT        hr = S_OK;
    IAccessor      *pIAccessorCommand = NULL; // Command's IAccessor
    IAccessor      *pIAccessorRowset = NULL;  // Rowset's IAccessor

    // Bump up reference count so that call to Release at the end of this
    // function doesn't delete rowset object.
    CAutoBlock cab(&m_RowsetCritSection);
    ++m_cRef;

    if( (cAccessors > 0) && (pCCommand != NULL) )
    {
        hr = pCCommand->QueryInterface(
                    IID_IAccessor,
                    (void **)&pIAccessorCommand
                    );
        BAIL_ON_FAILURE(hr);

        hr = this->QueryInterface(
                    IID_IAccessor,
                    (void **)&pIAccessorRowset
                    );
        BAIL_ON_FAILURE(hr);

        hr = CpAccessors2Rowset(
                    pIAccessorCommand,
                    pIAccessorRowset,
                    cAccessors,
                    rgAccessors,
                    m_pCAccessor);
        BAIL_ON_FAILURE(hr);
    }

error:

    if( pIAccessorCommand )
        pIAccessorCommand->Release();
    if( pIAccessorRowset )
        pIAccessorRowset->Release();

    --m_cRef;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetColOffsets
//
// Decides the offets of the columns in thr row buffer based on the column
// info from the row provider
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetColOffsets(void)
{
    HRESULT      hr;
    DBCOLUMNINFO *pColInfo = NULL;
    OLECHAR      *pColNames = NULL;
    DWORD        dwOffset, i;

    hr = m_pIColumnsInfo->GetColumnInfo(&m_cCol, &pColInfo, &pColNames);
    BAIL_ON_FAILURE( hr );

    // we don't need the column names
    m_pIMalloc->Free(pColNames);

    m_pColData = (COLDATA *) AllocADsMem(sizeof(COLDATA) * m_cCol);
    if( NULL == m_pColData )
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // Account for fields such as the row reference count that occur
    // before all columns in the row buffer
    dwOffset = sizeof(ROWBUFFER);

    for(i = 0; i < m_cCol; i++)
    {
        dwOffset = ColumnAlign(dwOffset);
        m_pColData[i].dwColOffset = dwOffset;

        // Account for the length and status fields of OLEDB data
        dwOffset += FIELD_OFFSET(OLEDBDATA, OledbValue);

        // Row provider returns all variable-length data types as BYREF
        if( pColInfo[i].wType & DBTYPE_BYREF )
            dwOffset += sizeof(char *);
        else
            dwOffset += (DWORD)pColInfo[i].ulColumnSize;

        m_pColData[i].wType = pColInfo[i].wType;
    }

    m_cRowBytes = dwOffset;
    m_pIMalloc->Free(pColInfo);

    RRETURN( S_OK );

error:

    if( pColInfo != NULL )
        m_pIMalloc->Free(pColInfo);
    if( m_pColData != NULL )
    {
        FreeADsMem(m_pColData);
        m_pColData = NULL;
    }
    m_cCol = m_cRowBytes = 0;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetNextRows
//
// Gets rows using the row provider into the rowset's cache. Handles for these
// rows are returned to the caller. The caller then retrieves the rows using
// GetData.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetNextRows(
    HCHAPTER    hChapter, // ignored since this is not a chaptered rowset
    DBROWOFFSET lRowsOffset,
    DBROWCOUNT  cRows,
    DBCOUNTITEM *pcRowsObtained,
    HROW        **prghRows
    )
{
    HRESULT   hr;
    RBOOKMARK StartRowBmk;                 // bookmark of first row to fetch
    ULONG     cbBookmark = ADSI_BMK_SIZE;  // size in bytes of the bookmark

    if( (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;
        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( 0 == cRows )
        RRETURN( S_OK );

    CAutoBlock cab(&m_RowsetCritSection);

    if( RESET_ROW == m_lLastFetchRow )
    // this is the first fetch OR RestartPosition was called prior to this
    {
        if( (lRowsOffset > 0) || ((0 == lRowsOffset) && (cRows > 0)) )
        {
            StartRowBmk = DBBMK_FIRST;
            cbBookmark = STD_BMK_SIZE;
        }
        else if( (lRowsOffset < 0) || ((0 == lRowsOffset) && (cRows < 0)) )
        {
            // can't set StartRowBmk to DBBMK_LAST as we want to set it one
            // beyond the end of the rowset

            // Seek to end of rowset
            hr = SeekToEnd();
            if( FAILED(hr) )
                RRETURN( hr );

            // m_lCurrentRow is now 2 off the last row of the rowset
            StartRowBmk = RowToBmk(m_lCurrentRow - 1);
        }

        if( cRows < 0 )
        // the first row we want to fetch is one before that specified by
        // the combination of StartRowBmk and lRowsOffset
            lRowsOffset--;
    }
    else // we have fetched rows before OR RestartPosition was not called
    {
        // except in the 3rd case below, it is possible that StartRowBmk
        // will end up pointing to a row that is outside the rowset
        if( (FORWARD == m_LastFetchDir) && (cRows > 0) )
                StartRowBmk = RowToBmk(m_lLastFetchRow + 1);
        else if( (BACKWARD == m_LastFetchDir) && (cRows < 0) )
                StartRowBmk = RowToBmk(m_lLastFetchRow - 1);
        else // first row returned will be same as last row returned previously
                StartRowBmk = RowToBmk(m_lLastFetchRow);
    }

    hr = GetRowsAt(NULL, hChapter, cbBookmark, (BYTE *) &StartRowBmk,
                         lRowsOffset, cRows, pcRowsObtained, prghRows);

    if( SUCCEEDED(hr) )
    {
        // If we return DB_S_ENDOFROWSET because lRowsOffset indicated a
        // position outside the rowset, then we do not modify m_lLastFetchRow.
        // Only if we walked off either end of the rowset AND fetched at least
        // a row is m_lLastFetchRow updated. If no rows are returned due to
        // lack of space in the rowset cache, we do not modify m_lLastFetchRow.
        if( *pcRowsObtained )
        {
            m_LastFetchDir = (cRows > 0) ? FORWARD:BACKWARD;
            m_lLastFetchRow = HROWToRow( (*prghRows)[*pcRowsObtained - 1] );
        }
    }

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetRowsAt
//
// Fetches rows starting from a given offset from a bookmark. Handles for
// rows fetched are returned to the caller. The caller may send in an invalid
// bookmark i.e, a bookmark that was not returned by a previous invocation of
// GetData. Although, this is an error, the spec does not require the provider
// to detect this condition. So, the user can send in a random bookmark and the
// provider will return the correct row if there is a row that corresponds to
// the bookmark and DB_S_ENDOFROWSET otherwise. We make use of this fact when
// GetNextRows calls GetRowsAt. The bookmark passed in by GetNextRows may be
// for a row that is not yet in the provider's cache.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetRowsAt(
    HWATCHREGION hReserved, // Reserved for future use. Ignored.
    HCHAPTER     hChapter,  // ignored as this is not a chaptered rowset
    DBBKMARK     cbBookmark,
    const BYTE   *pBookmark,
    DBROWOFFSET  lRowsOffset,
    DBROWCOUNT   cRows,
    DBCOUNTITEM  *pcRowsObtained,
    HROW         **prghRows
    )
{
    LONG         lStartRow, // first row returned
                 lBmkRow,   // row corresponding to bookmark
                 lNextRow,
                 lRowIndex;
    int          iStep;
    HROW         *phRow;
    ROWBUFFER    *pRowBuffer;
    HRESULT      hr;
    BOOL         fMemAllocated = FALSE;
    DBCOUNTITEM  iRow;
    ULONG_PTR    ulRowsOffset;

    if( (0 == cbBookmark) || (NULL == pBookmark) ||
        (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;

        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( (cbBookmark != STD_BMK_SIZE) && (cbBookmark != ADSI_BMK_SIZE) )
        RRETURN( DB_E_BADBOOKMARK );

    if( 0 == cRows )
        RRETURN( S_OK ); // don't have to check for any errors

    CAutoBlock cab(&m_RowsetCritSection);

    // rowset can't have more than 2^32 rows. So, if offset points to beyond
    // that return eof.
    ulRowsOffset = (lRowsOffset > 0) ? lRowsOffset : -lRowsOffset;
    if( ulRowsOffset & 0xffffffff00000000 )
        RRETURN( DB_S_ENDOFROWSET );

    // Get first row to fetch
    hr = BmkToRow(cbBookmark, pBookmark, &lBmkRow);
    if( FAILED(hr) )
        RRETURN( hr );
    lStartRow = lBmkRow + lRowsOffset;

    if( lStartRow < FIRST_ROW )
        RRETURN( DB_S_ENDOFROWSET );

    lNextRow = lStartRow;
    if( NULL == *prghRows ) // provider has to allocate memory for handles
    {
        ULONG_PTR cNumHandles, cRowsAbs;

        // not sure if there is an abs64
        if(cRows < 0)
            cRowsAbs = -cRows;
        else
            cRowsAbs = cRows;

        // Guard against user requesting too many rows - maximum we can
        // return is the size of the rowset cache
        if( m_dwMaxCacheSize > 0 ) // user specified some max value
            cNumHandles = Min(cRowsAbs, (ULONG_PTR) m_dwMaxCacheSize);
        else
            cNumHandles = cRowsAbs;

        if( 0 == (cNumHandles * sizeof(HROW)) ) // numeric overflow
            *prghRows = NULL;
        else
            *prghRows = (HROW *) m_pIMalloc->Alloc(cNumHandles * sizeof(HROW));

        if( NULL == *prghRows )
            RRETURN( E_OUTOFMEMORY );
        fMemAllocated = TRUE;
    }

    iStep = (cRows > 0) ? 1 : -1;
    phRow = *prghRows;

    // fetch rows
    while( cRows )
    {
        hr = SeekToRow(lNextRow);
        BAIL_ON_FAILURE(hr);

        if( DB_S_ENDOFROWSET == hr )
        // we reached the end of the rowset OR we have reached the end of
        // whatever portion of the results set that ADSI has cached (depends
        // on the ADSIPROP_CACHE_RESULTS property)
        {
            if( (0 == *pcRowsObtained) && fMemAllocated )
            {
                m_pIMalloc->Free(*prghRows);
                *prghRows = NULL;
            }

            RRETURN( DB_S_ENDOFROWSET );
        }

        // Bring in the row that we just seeked to
        hr = BringInRow();

        BAIL_ON_FAILURE(hr);

        if( (DB_S_ROWLIMITEXCEEDED == hr) || (DB_S_ENDOFROWSET == hr) )
        // no more space in rowset cache OR end of rowset. We will hit end
        // of rowset only if m_lCurrentRow was one/two beyond the end of the
        // rowset when SeekToRow was called above AND lNextRow == m_lCurrentRow
        // (in which case, SeekToRow would just return without doing anything).
        {
            if( (0 == *pcRowsObtained) && fMemAllocated )
            {
                m_pIMalloc->Free(*prghRows);
                *prghRows = NULL;
            }

            RRETURN( hr );
        }

        // Get the index of the row within the rowset cache
        *phRow = RowToHROW(lNextRow);
        lRowIndex = HROWToIndex(*phRow);

        // Increment reference count of row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert(pRowBuffer != NULL);
        IncrRefCount(pRowBuffer);

        phRow++;
        (*pcRowsObtained)++;
        lNextRow += iStep;
        cRows += (-iStep);

    } // while (cRows)

    RRETURN( S_OK );

error:
    // release any rows that were brought into the cache
    phRow = *prghRows;
    for(iRow = 0; iRow < *pcRowsObtained; iRow++)
    {
        ULONG ulRefCount;

        ReleaseRows(1, phRow, NULL, &ulRefCount, NULL); //ignore ret value

        phRow++;
    }

    if( fMemAllocated )
    {
        m_pIMalloc->Free(*prghRows);
        *prghRows = NULL;
    }

    *pcRowsObtained = 0;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
// BmkToRow
//
// Converts a bookmark to a row within the rowset.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::BmkToRow(
    ULONG      cbBookmark, // number of bytes in the bookmark
    const BYTE *pBookmark, //  pointer to bookmark
    LONG       *plRow
    )
{
    HRESULT    hr;

    ADsAssert( plRow != NULL );

    if( STD_BMK_SIZE == cbBookmark )
    {
        // If pBookmark is a pointer passed in from GetNextRows, then it is
        // actually a LONG *. Accessing *pBookmark to get the LSByte of the
        // bookmark below assumes LITTLE ENDIAN format.

        if( DBBMK_FIRST == *pBookmark )
            *plRow = FIRST_ROW;
        else if( DBBMK_LAST == *pBookmark )
        {
            CAutoBlock cab(&m_RowsetCritSection); // protect access to m_ fields

            // Seek to end of rowset
            hr = SeekToEnd();

            if( FAILED(hr) )
                RRETURN( hr );
            
            // should have reached end of rowset
            ADsAssert( DB_S_ENDOFROWSET == hr );

            // Seeking to end of rowset sets current row to MAX + 2, if there
            // is at least one row in the result. If the result is empty, we
            // will return -1 in *plRow below, but that's OK as -1 implies
            // DB_S_ENDOFROWSET in GetRowsAt()
            *plRow = m_lCurrentRow - 2;
        }
        else
            RRETURN( DB_E_BADBOOKMARK );
    }
    else if( ADSI_BMK_SIZE == cbBookmark )
        *plRow = *((LONG *) pBookmark);

    else // should never get in here
        ADsAssert( FALSE );

    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// SeekToRow
//
// Positions the IDirectorySearch cursor such that the next call to GetNextRow
// will fetch the row lTargetRow. If we hit the end of the rowset before
// seeking to lTargetRow, returns DB_S_ENDOFROWSET.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::SeekToRow(LONG lTargetRow)
{
    HRESULT hr;

    CAutoBlock cab(&m_RowsetCritSection);

    if( lTargetRow == m_lCurrentRow ) // already at the right row
        RRETURN( S_OK );

    if( lTargetRow < m_lCurrentRow )
    {
        while( lTargetRow != m_lCurrentRow )
        {
            hr = m_pCRowProvider->SeekToPreviousRow();
            BAIL_ON_FAILURE(hr);

            // m_fEndOfRowset is set to TRUE only if we hit the end of the
            // rowset while moving forward
            m_fEndOfRowset = FALSE;

            if( m_lCurrentRow > 0 )
                m_lCurrentRow--;

            if( S_ADS_NOMORE_ROWS == hr )
                if( m_lCurrentRow != lTargetRow )
                    RRETURN( DB_S_ENDOFROWSET );
        }
    }
    else
    {
        while( lTargetRow != m_lCurrentRow )
        {
            hr = m_pCRowProvider->SeekToNextRow();
            BAIL_ON_FAILURE(hr);

            m_lCurrentRow++;

            if( S_ADS_NOMORE_ROWS == hr )
            {
                // if we were already at the end of the rowset, then reset
                // m_lCurrentRow to its original value
                if( m_fEndOfRowset)
                    m_lCurrentRow--;
                else
                    m_fEndOfRowset = TRUE;

                RRETURN( DB_S_ENDOFROWSET );
            }
        }

        m_fEndOfRowset = FALSE;

    }

    RRETURN( S_OK );

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// SeekToEnd
//
// Moves the IDirectorySearch cursor forward till it hits the end of the
// rowset.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::SeekToEnd(void)
{
    HRESULT hr = S_OK;

    CAutoBlock cab(&m_RowsetCritSection);

    while(1) // till we reach end of rowset
    {
        hr = m_pCRowProvider->SeekToNextRow();

        BAIL_ON_FAILURE(hr);

        m_lCurrentRow++;

        if( S_ADS_NOMORE_ROWS == hr )
        {
            // if we were already at the end of the rowset, then reset
            // m_lCurrentRow to its original value
            if( m_fEndOfRowset)
                m_lCurrentRow--;
            else
                m_fEndOfRowset = TRUE;

            RRETURN( DB_S_ENDOFROWSET );
        }
    }

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// BringInRow
//
// Brings in the row that we seeked to last. Only one row is brought in.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::BringInRow(void)
{
    HRESULT   hr;
    ROWBUFFER *pRowBuffer = NULL;
    DWORD     cColErrors; // #columns in a row that had an error when retrieved
    int       iCol, iRow;
    HROW      hRow;
    LONG      lIndex;
    DBSTATUS  *pdbStatus;

    CAutoBlock cab(&m_RowsetCritSection);

    // check if the row is already in the cache

    hRow = RowToHROW(m_lCurrentRow);
    lIndex = HROWToIndex(hRow);

    if(lIndex != -1)
    // row is already in cache
    {
        pRowBuffer = m_pRowsPtr[lIndex];
        ADsAssert(pRowBuffer != NULL);

        if( pRowBuffer->cColErrors )
            RRETURN( DB_S_ERRORSOCCURRED );
        else
            RRETURN( S_OK );
    }

    // check if we have room in the cache
    if( (m_dwMaxCacheSize > 0) && ((DWORD)m_cNumRowsCached == m_dwMaxCacheSize) )
        RRETURN( DB_S_ROWLIMITEXCEEDED );

    // Allocate more space in the cache, if we have run out
    if( (DWORD)m_cNumRowsCached == m_dwRowCacheSize ) // no more space for rows
    {
        DWORD     dwTmpSize;
        ROWBUFFER **pTmpRowsPtr;

        dwTmpSize = (0 == m_dwRowCacheSize) ? 1 : (m_dwRowCacheSize*2);

        // make sure we don't overflow the cache
        if( (m_dwMaxCacheSize > 0) && (dwTmpSize > m_dwMaxCacheSize) )
            dwTmpSize = m_dwMaxCacheSize;

        pTmpRowsPtr = (ROWBUFFER **) ReallocADsMem(m_pRowsPtr,
                                      m_dwRowCacheSize*sizeof(ROWBUFFER *),
                                      dwTmpSize*sizeof(ROWBUFFER *));
        if( NULL == pTmpRowsPtr )
            BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

        m_dwRowCacheSize = dwTmpSize;
        m_pRowsPtr = pTmpRowsPtr;
    }

    // Allocate memory for a new row
    pRowBuffer = (ROWBUFFER *) AllocADsMem(m_cRowBytes);
    if( NULL == pRowBuffer )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    // initialize row to 0 (reference count initialized to 0 here)
    memset((char *) pRowBuffer, 0, m_cRowBytes);

    pRowBuffer->lRow = m_lCurrentRow;

    // use row provider to get the next row
    hr = m_pIRowProvider->NextRow();

    BAIL_ON_FAILURE(hr);

    m_lCurrentRow++;

    if( DB_S_ENDOFROWSET == hr )
    {
        if( m_fEndOfRowset )
            m_lCurrentRow--;
        else
            m_fEndOfRowset = TRUE;
        FreeADsMem(pRowBuffer);
        RRETURN( DB_S_ENDOFROWSET );
    }
    else
        m_fEndOfRowset = FALSE;

    cColErrors = 0;

    for(iCol = 1; (DBORDINAL)iCol < m_cCol; iCol++)
    {
        hr = m_pIRowProvider->GetColumn(
            iCol,
            (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, dbStatus) + (char *)pRowBuffer ),
            (ULONG *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, dwLength) + (char *)pRowBuffer ),
            (BYTE *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, OledbValue) + (char *)pRowBuffer )
        );

        if( FAILED(hr) )
            cColErrors++;

        // store the ADS_SEARCH_COLUMN if the DS returned any data. Even if
        // GetColumn fails, this has to be done to ensure that the
        // ADS_SEARCH_COLUMN structure is freed later.
        pdbStatus = (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                    FIELD_OFFSET(OLEDBDATA, dbStatus) + (char *)pRowBuffer );
        if( *pdbStatus != DBSTATUS_S_ISNULL )
            memcpy((void *) ((char *)pRowBuffer + m_pColData[iCol].dwColOffset
                              + FIELD_OFFSET(OLEDBDATA, adsSearchCol)),
                   (void *) (&(m_pCRowProvider->_pdbSearchCol[iCol].adsColumn)),
                   sizeof(ADS_SEARCH_COLUMN) );
    }

    // Copy over the ADsPath search column, if required
    if( FALSE == m_fadsPathPresent )
        memcpy( (void *) (&(pRowBuffer->adsSearchCol)),
                (void *) (&(m_pCRowProvider->_pdbSearchCol[iCol].adsColumn)),
                sizeof(ADS_SEARCH_COLUMN) );

    if( cColErrors == (m_cCol - 1) ) // all columns were in error
    {
        // any failure after this point should do this
        FreeRow(pRowBuffer);
        pRowBuffer = NULL; // so that we don't try to free again later

        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
    }

    // fill in the bookmark column
    *( (DBSTATUS *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, dbStatus)+(char *)pRowBuffer) ) = DBSTATUS_S_OK;
    *( (ULONG *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, dwLength)+(char *)pRowBuffer) ) = ADSI_BMK_SIZE;
    // bookmark value is same as row
    *( (ULONG *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, OledbValue)+(char *)pRowBuffer) ) =
                                                m_lCurrentRow - 1;

    // Store pointer to new row
    m_pRowsPtr[m_cNumRowsCached] = pRowBuffer;

    m_cNumRowsCached++;

    if( cColErrors )
    {
        pRowBuffer->cColErrors = cColErrors;
        RRETURN( DB_S_ERRORSOCCURRED );
    }

    RRETURN( S_OK );

error:
    if( pRowBuffer )
        FreeADsMem(pRowBuffer);

    RRETURN( hr );
}

//----------------------------------------------------------------------------- // GetData
//
// Returns the data from the rowset cache in the format requested by the
// client. This routine performs deferred accessor validation i.e, checks that
// could not be done when the accessor was created due to lack of info. about
// the rowset.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetData(
    HROW      hRow,
    HACCESSOR hAccessor,
    void      *pData
    )
{
    HRESULT         hr;
    LONG            lRowIndex;
    DBACCESSORFLAGS dwAccessorFlags;
    DBCOUNTITEM     cBindings = 0, cErrors = 0;
    DBBINDING       *prgBindings = NULL;
    ROWBUFFER       *pRowBuffer;
    int             iBind;
    ULONG           ulCol;
    ULONG           *pulProvLength;
    DBLENGTH        *pulConsLength;
    DBSTATUS        *pdbConsStatus, *pdbProvStatus;
    void            *pConsValue, *pProvValue;
    OLEDBDATA       *pProvOledbData;

    if( NULL == pData ) // we don't supprt NULL accessor. So, this is an error
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    lRowIndex = HROWToIndex(hRow);
    if( (lRowIndex < FIRST_ROW) || (lRowIndex >= m_cNumRowsCached) )
        RRETURN( DB_E_BADROWHANDLE );

    // Get pointer to the specified row
    pRowBuffer = m_pRowsPtr[lRowIndex];
    ADsAssert( pRowBuffer != NULL );
    if( RefCount(pRowBuffer) <= 0 )
        RRETURN( DB_E_BADROWHANDLE );

    ADsAssert( m_pCAccessor );

    hr = m_pCAccessor->GetBindings( // this call validates hAccessor
                hAccessor,
                &dwAccessorFlags,
                &cBindings,
                &prgBindings
                );

    if( FAILED(hr) )
        RRETURN( hr );

    ADsAssert( cBindings ); // NULL accessor is disallowed

    for(iBind = 0; (DBCOUNTITEM)iBind < cBindings; iBind++)
    {
        // Free pObject in the binding, if any
        if( prgBindings[iBind].pObject )
            m_pIMalloc->Free(prgBindings[iBind].pObject);

        // these types are disallowed
        ADsAssert( !((prgBindings[iBind].wType & DBTYPE_VECTOR) ||
                   (prgBindings[iBind].wType & DBTYPE_ARRAY)) );

        // Get pointers to consumer's OLEDB data using the bindings
        if( prgBindings[iBind].dwPart & DBPART_STATUS )
            pdbConsStatus = (DBSTATUS *) ( (char *)pData +
                                          prgBindings[iBind].obStatus );
        else
            pdbConsStatus = NULL;

        if( prgBindings[iBind].dwPart & DBPART_LENGTH )
            pulConsLength = (DBLENGTH *) ( (char *)pData +
                                          prgBindings[iBind].obLength );
        else
            pulConsLength = NULL;

        if( prgBindings[iBind].dwPart & DBPART_VALUE )
            pConsValue = (void *) ( (char *)pData +
                                          prgBindings[iBind].obValue );
        else
            pConsValue = NULL;

        // Check if accessor points to a valid column
        ulCol = prgBindings[iBind].iOrdinal;
        if( ulCol >= m_cCol )
        {
            if( pdbConsStatus )
                *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
            cErrors++;
            continue;
        }

        // Get pointers to providers OLEDB data from the row buffer cache
        pProvOledbData = (OLEDBDATA *) ((char *)pRowBuffer +
                                         m_pColData[ulCol].dwColOffset);
        pdbProvStatus = &(pProvOledbData->dbStatus);
        pulProvLength = &(pProvOledbData->dwLength);
        pProvValue = &(pProvOledbData->OledbValue);

        if( DBMEMOWNER_PROVIDEROWNED == prgBindings[iBind].dwMemOwner )
        {
            if( pdbConsStatus )
                *pdbConsStatus = *pdbProvStatus;
            if( pulConsLength )
                *pulConsLength = *pulProvLength;

            if( prgBindings[iBind].wType & DBTYPE_BYREF )
            {
                // If a binding specifies provider owned memory, and specifies
                // type X | BYREF, and the provider's copy is not X or
                // X | BYREF, return error
                if( (prgBindings[iBind].wType & (~DBTYPE_BYREF)) !=
                        (m_pColData[ulCol].wType & (~DBTYPE_BYREF)) )
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
                    cErrors++;
                    continue;
                }

                if( m_pColData[ulCol].wType & DBTYPE_BYREF )
                // provider's type exactly matches consumer's type
                {
                    if( pConsValue )
                        *(void **) pConsValue = *(void **) pProvValue;
                }
                else
                // provider actually has the data, not a pointer to the data
                {
                    if( pConsValue )
                        *(void **) pConsValue = pProvValue;
                }
            }
            else if( DBTYPE_BSTR == prgBindings[iBind].wType )
            {
                if( DBTYPE_BSTR != m_pColData[ulCol].wType )
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
                    cErrors++;
                    continue;
                }

                if( pConsValue )
                    *(void **) pConsValue = *(void **) pProvValue;
            }
            else // we should never get here
                ADsAssert( FALSE );
        }
        else // binding specified client-owned memory
        {
            // workaround for bug in IDataConvert. Variant to Variant
            // conversions may not always work (depending on the type in the
            // variant). So, handle that case separately.

            DBTYPE dbSrcType, dbDstType;

            dbSrcType = m_pColData[ulCol].wType & (~DBTYPE_BYREF);
            dbDstType = prgBindings[iBind].wType & (~DBTYPE_BYREF);

            if( (DBTYPE_VARIANT == dbSrcType) &&
                (DBTYPE_VARIANT == dbDstType) )
            {
                PVARIANT pSrcVariant, pDstVariant = NULL;

                if( (*pdbProvStatus != DBSTATUS_S_OK) &&
                    (*pdbProvStatus != DBSTATUS_S_ISNULL) )
                // provider wasn't able to get value from DS. Return bad
                // status to consumer
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = *pdbProvStatus;
                    if( pulConsLength )
                        *pulConsLength = 0;
                    // value will not be set

                    cErrors++;
                    continue; // to next binding
                }

                if( m_pColData[ulCol].wType & DBTYPE_BYREF )
                    pSrcVariant = *(PVARIANT *)pProvValue;
                else
                    pSrcVariant = (PVARIANT)pProvValue;

                if( (prgBindings[iBind].wType & DBTYPE_BYREF) && pConsValue )
                {
                    pDstVariant = (PVARIANT)m_pIMalloc->Alloc(sizeof(VARIANT));
                    if( NULL == pDstVariant )
                        hr = E_OUTOFMEMORY;
                }
                else
                    pDstVariant = (PVARIANT)pConsValue;

                if( pdbConsStatus )
                   *pdbConsStatus = *pdbProvStatus;
                if( pulConsLength )
                   *pulConsLength = *pulProvLength;

                if( pDstVariant )
                {
                    VariantInit(pDstVariant);

                    if( DBSTATUS_S_ISNULL == *pdbProvStatus )
                    // provider couldn't get this column from DS (probably
                    // because there was no attribute with this name)
                    {
                        if( prgBindings[iBind].wType & DBTYPE_BYREF )
                        // don't allocate anything if returning NULL status
                            m_pIMalloc->Free(pDstVariant);
                        else
                            V_VT(pDstVariant) = VT_EMPTY;

                        hr = S_OK;
                    }
                    else
                    {
                        hr = VariantCopy(pDstVariant, pSrcVariant);
                        if( SUCCEEDED(hr) )
                        {
                            if( pConsValue &&
                                (prgBindings[iBind].wType & DBTYPE_BYREF) )
                                *(void **) pConsValue = pDstVariant;
                        }
                        else if( prgBindings[iBind].wType & DBTYPE_BYREF )
                            m_pIMalloc->Free(pDstVariant);
                    } // else
                } // if( pDstvariant)
            } // if( DBTYPE_VARIANT == ...)
            else
            {
                DBLENGTH dbTmpLen = 0;

                hr = m_pIDataConvert->DataConvert(
                    m_pColData[ulCol].wType,
                    prgBindings[iBind].wType,
                    *pulProvLength,
                    &dbTmpLen,
                    pProvValue,
                    pConsValue,
                    prgBindings[iBind].cbMaxLen,
                    *pdbProvStatus,
                    pdbConsStatus,
                    prgBindings[iBind].bPrecision,
                    prgBindings[iBind].bScale,
                    DBDATACONVERT_DEFAULT
                    );
                if( pulConsLength )
                    *pulConsLength = dbTmpLen;

                // if the binding specified DBTYPE_VARIANT | DBTYPE_BYREF, then
                // IDataConvert does not allocate a VT_NULL variant. Instead it
                // returns nothing in pConsValue. If it is not BYREF, then
                // return VT_EMPTY instead of VT_NULL.
                if( SUCCEEDED(hr) && (DBSTATUS_S_ISNULL == *pdbProvStatus) &&
                    (prgBindings[iBind].wType == DBTYPE_VARIANT) &&
                     pConsValue )
                {
                    PVARIANT pVariant;

                    pVariant = (PVARIANT)pConsValue;

                    V_VT(pVariant) = VT_EMPTY;
                }

            }

            if( FAILED(hr) )
            {
                if( pdbConsStatus )
                    *pdbConsStatus = DBSTATUS_E_CANTCONVERTVALUE;
                cErrors++;
                continue;
            }
        } // client-owned memory
    }

    m_pIMalloc->Free(prgBindings);

    if( cErrors )
        if( cErrors != cBindings ) // not all columns had error
            RRETURN( DB_S_ERRORSOCCURRED );
        else
            RRETURN( DB_E_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// AddRefRows
//
// Increments reference count of specified rows
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::AddRefRows(
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    ULONG        rgRefCounts[],
    DBROWSTATUS  rgRowStatus[]
    )
{
    int       iRow;
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;
    DBCOUNTITEM cErrors = 0;

    if( (NULL == rghRows) && (cRows != 0) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    for(iRow = 0; (DBCOUNTITEM)iRow < cRows; iRow++)
    {
        lRowIndex = HROWToIndex(rghRows[iRow]);
        if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        // Get pointer to the specified row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert( pRowBuffer != NULL );
        if( RefCount(pRowBuffer) <= 0 )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        IncrRefCount(pRowBuffer);

        if( rgRefCounts )
            rgRefCounts[iRow] = RefCount(pRowBuffer);
        if( rgRowStatus )
            rgRowStatus[iRow] = DBROWSTATUS_S_OK;
    }

    if( cErrors )
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// ReleaseRows
//
// Decrements reference count of specified rows. The rows are not freed even
// if the reference count goes down to 0.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::ReleaseRows(
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    DBROWOPTIONS rgRowOptions[], // ignored
    ULONG        rgRefCounts[],
    DBROWSTATUS  rgRowStatus[]
    )
{
    int       iRow;
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;
    DBCOUNTITEM cErrors = 0;

    if( (NULL == rghRows) && (cRows != 0) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    for(iRow = 0; (DBCOUNTITEM)iRow < cRows; iRow++)
    {
        lRowIndex = HROWToIndex(rghRows[iRow]);
        if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        // Get pointer to the specified row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert( pRowBuffer != NULL );
        if( RefCount(pRowBuffer) <= 0 )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        DecrRefCount(pRowBuffer);

        if( rgRefCounts )
            rgRefCounts[iRow] = RefCount(pRowBuffer);
        if( rgRowStatus )
            rgRowStatus[iRow] = DBROWSTATUS_S_OK;

        // Free the row's memory
        if( 0 == RefCount(pRowBuffer) )
        {
            int i;

            FreeRow(pRowBuffer);
            m_cNumRowsCached--;

            // compact the cache
            for(i = lRowIndex; i < m_cNumRowsCached; i++)
                m_pRowsPtr[i] = m_pRowsPtr[i+1];
        }
    }

    if( cErrors )
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// RestartPosition
//
// Repositions the next fetch poition to the initial position
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::RestartPosition(
    HCHAPTER hChapter // ignored
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    m_lLastFetchRow = RESET_ROW;

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// FreeRow
//
// Frees the memory used by a row in the rowset cache. Also frees the ADsColumn
// structures contained within the row.
//
//----------------------------------------------------------------------------
void
CRowset::FreeRow(
    ROWBUFFER *pRowBuffer
    )
{
    int               iCol;
    ADS_SEARCH_COLUMN *pADsCol;
    DBSTATUS          *pdbStatus;
    PVARIANT          pVariant;

    CAutoBlock cab(&m_RowsetCritSection);

    // start with column 1. Bookmark column is ignored.
    for(iCol = 1; (DBORDINAL)iCol < m_cCol; iCol++)
    {
        pADsCol = (ADS_SEARCH_COLUMN *) ((char *)pRowBuffer +
                       m_pColData[iCol].dwColOffset +
                       FIELD_OFFSET(OLEDBDATA, ,adsSearchCol));
        pdbStatus = (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                       FIELD_OFFSET(OLEDBDATA, dbStatus) +
                       (char *)pRowBuffer );

        if( *pdbStatus != DBSTATUS_S_ISNULL )
        {
            if( (DBSTATUS_S_OK == *pdbStatus) &&
                ((m_pColData[iCol].wType & (~DBTYPE_BYREF)) == DBTYPE_VARIANT) )
            // variant (or variant array) needs to be freed
            {
                pVariant = *(PVARIANT *) ( (m_pColData[iCol].dwColOffset +
                               FIELD_OFFSET(OLEDBDATA, OledbValue) +
                               (char *)pRowBuffer) );

                if( V_VT(pVariant) & VT_ARRAY )
                    SafeArrayDestroy(V_ARRAY(pVariant));
                else
                    VariantClear(pVariant);

                FreeADsMem(pVariant);
            }

            // ignore error return
            m_pCRowProvider->_pDSSearch->FreeColumn(pADsCol);
        }
    }

    if( FALSE == m_fadsPathPresent )
        // ignore error return
        m_pCRowProvider->_pDSSearch->FreeColumn(&(pRowBuffer->adsSearchCol));

    FreeADsMem(pRowBuffer);

    return;
}

//-----------------------------------------------------------------------------
// GetADsPathFromHROW
//
// Gets the ADsPath corresponding to a HROW. This function is called by
// GetURLFromHROW, only if m_fadsPathPresent is FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetADsPathFromHROW(
    HROW hRow,
    ADS_CASE_IGNORE_STRING *padsPath
    )
{
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;

    ADsAssert(FALSE == m_fadsPathPresent);

    CAutoBlock cab(&m_RowsetCritSection);

    lRowIndex = HROWToIndex(hRow);
    if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        RRETURN(E_HANDLE);

    // Get pointer to the specified row
    pRowBuffer = m_pRowsPtr[lRowIndex];
    ADsAssert( pRowBuffer != NULL );
    if( RefCount(pRowBuffer) <= 0 )
        RRETURN(E_HANDLE);

    if( NULL == padsPath )
        RRETURN(E_INVALIDARG);
    *padsPath =
        pRowBuffer->adsSearchCol.pADsValues[0].CaseIgnoreString;

    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CRowset::QueryInterface(
    THIS_ REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if( NULL == ppvObj )
        RRETURN( E_INVALIDARG );

    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IUnknown) )
        *ppvObj = (IUnknown FAR *) ((IAccessor *) this);
    else if( IsEqualIID(riid, IID_IAccessor) )
        *ppvObj = (IAccessor FAR *) this;
    else if( IsEqualIID(riid, IID_IColumnsInfo) )
        *ppvObj = (IColumnsInfo FAR *) this;
    else if( IsEqualIID(riid, IID_IConvertType) )
        *ppvObj = (IConvertType FAR *) this;
#if (!defined(BUILD_FOR_NT40))
    else if( IsEqualIID(riid, IID_IGetRow) )
        *ppvObj = (IGetRow FAR *) this;
#endif
    else if( IsEqualIID(riid, IID_IRowset) )
        *ppvObj = (IRowset FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetIdentity) )
        *ppvObj = (IRowsetIdentity FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetInfo) )
        *ppvObj = (IRowsetInfo FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetLocate) )
        *ppvObj = (IRowsetLocate FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetScroll) )
        *ppvObj = (IRowsetScroll FAR *) this;
    else
         RRETURN( E_NOINTERFACE );

    AddRef();
    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// AddRef
//
// Increments reference count of this object
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRowset::AddRef(
    void
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    ADsAssert(((LONG)m_cRef) >= 0);

    return ++m_cRef;
}

//-----------------------------------------------------------------------------
// Release
//
// Decrements reference count of this object
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRowset::Release(
    void
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    ADsAssert(m_cRef > 0);

    m_cRef--;

    if( 0 == m_cRef )
    {
        cab.UnBlock();
        delete this;

        return 0;
    }

    return m_cRef;
}

//-----------------------------------------------------------------------------
// IAccessor methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::AddRefAccessor(
    HACCESSOR  hAccessor,
    DBREFCOUNT *pcRefCount
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->AddRefAccessor(hAccessor, pcRefCount) );
}

STDMETHODIMP
CRowset::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR *     phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN(m_pCAccessor->CreateAccessor(
                    dwAccessorFlags,
                    cBindings,
                    rgBindings,
                    cbRowSize,
                    phAccessor,
                    rgStatus)
                    );
}

STDMETHODIMP
CRowset::ReleaseAccessor(
     HACCESSOR  hAccessor,
     DBREFCOUNT *pcRefCount
     )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->ReleaseAccessor(
                    hAccessor,
                    pcRefCount)
                    );
}

STDMETHODIMP
CRowset::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      prgBindings
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->GetBindings(
                    hAccessor,
                    pdwAccessorFlags,
                    pcBindings,
                    prgBindings)
                    );
}

//-----------------------------------------------------------------------------
// IColumnsInfo methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetColumnInfo(
    DBORDINAL       *pcColumns,
    DBCOLUMNINFO    **pprgInfo,
    WCHAR **        ppStringBuffer
    )
{
    ADsAssert(m_pIColumnsInfo);

    RRETURN( m_pIColumnsInfo->GetColumnInfo(
                    pcColumns,
                    pprgInfo,
                    ppStringBuffer)
                    );
}

STDMETHODIMP
CRowset::MapColumnIDs(
    DBORDINAL  cColumnIDs,
    const DBID rgColumnIDs[],
    DBORDINAL  rgColumns[]
    )
{
    ADsAssert(m_pIColumnsInfo);

    RRETURN( m_pIColumnsInfo->MapColumnIDs(
                    cColumnIDs,
                    rgColumnIDs,
                    rgColumns)
                    );
}

//-----------------------------------------------------------------------------
// IConvertType methods (mandatory for IRowset)
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::CanConvert(
    DBTYPE         wFromType,
    DBTYPE         wToType,
    DBCONVERTFLAGS dwConvertFlags
    )
{
    HRESULT hr;

    if( dwConvertFlags & DBCONVERTFLAGS_PARAMETER ) // not allowed on rowset
        RRETURN( DB_E_BADCONVERTFLAG );

    if( (dwConvertFlags & (~(DBCONVERTFLAGS_ISLONG |
                            DBCONVERTFLAGS_ISFIXEDLENGTH |
                            DBCONVERTFLAGS_FROMVARIANT))) !=
                            DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG )
    {
        DBTYPE wType;

        wType = wFromType & (~(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR));

        // wType has to be variable-length DBTYPE
        if( (wType != DBTYPE_STR) && (wType != DBTYPE_WSTR) &&
            (wType != DBTYPE_BYTES) && (wType != DBTYPE_VARNUMERIC) )
            RRETURN( DB_E_BADCONVERTFLAG );
    }

    // CreateAccessor returns error for ARRAY and VECTOR types. So we cannot
    // convert to these types.
    if( (wToType & DBTYPE_ARRAY) || (wToType & DBTYPE_VECTOR) )
        RRETURN( S_FALSE );

    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT )
    {
        DBTYPE dbTmpType, wVtType;

        wVtType = wFromType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );

        dbTmpType = wToType & (~DBTYPE_BYREF);
        if( DBTYPE_VARIANT == dbTmpType )
        // GetData will do the right thing, so return TRUE.
            RRETURN( S_OK );
    }

    // GetData handles VARIANT to VARIANT conversions, so special check here
    if( (DBTYPE_VARIANT == (wFromType & (~DBTYPE_BYREF))) &&
        (DBTYPE_VARIANT == (wToType & (~DBTYPE_BYREF))) )
        RRETURN( S_OK );

    ADsAssert( m_pIDataConvert != NULL );

    hr = m_pIDataConvert->CanConvert(wFromType, wToType);

    RRETURN( (E_INVALIDARG == hr)? S_FALSE : hr );
}

//-----------------------------------------------------------------------------
// IGetRow methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetRowFromHROW(
    IUnknown  *pUnkOuter,
    HROW      hRow,
    REFIID    riid,
    IUnknown  **ppUnk
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetRowFromHROW(
                     pUnkOuter,
                     hRow,
                     riid,
                     ppUnk,
                     TRUE, // this ia tear-off row
                     m_fAllAttrs)
                     );
}

STDMETHODIMP
CRowset::GetURLFromHROW(
    HROW     hRow,
    LPOLESTR *ppwszURL
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetURLFromHROW(hRow, ppwszURL) );
}

//-----------------------------------------------------------------------------
// IRowsetIdentity methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::IsSameRow(
    HROW hRow1,
    HROW hRow2
    )
{
    LONG      lIndex1, lIndex2;
    ROWBUFFER *pRowBuffer1, *pRowBuffer2;

    lIndex1 = HROWToIndex(hRow1);
    lIndex2 = HROWToIndex(hRow2);

    if( (lIndex1 < 0) || (lIndex1 >= m_cNumRowsCached) ||
        (lIndex2 < 0) || (lIndex2 >= m_cNumRowsCached) )
        RRETURN( DB_E_BADROWHANDLE );

    // Get pointer to the specified row
    pRowBuffer1 = m_pRowsPtr[lIndex1];
    pRowBuffer2 = m_pRowsPtr[lIndex2];
    ADsAssert( (pRowBuffer1 != NULL) && (pRowBuffer2 != NULL) );
    if( (RefCount(pRowBuffer1) <= 0) || (RefCount(pRowBuffer2) <= 0) )
        RRETURN( DB_E_BADROWHANDLE );

    if( lIndex1 == lIndex2 )
        RRETURN( S_OK );
    else
        RRETURN( S_FALSE );
}

//-----------------------------------------------------------------------------
// IRowsetInfo methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetProperties(
    const ULONG       cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG             *pcPropertySets,
    DBPROPSET         **pprgPropertySets
    )
{
    ADsAssert( m_pCUtilProp );

    // Check arguments for error
    HRESULT hr = m_pCUtilProp->GetPropertiesArgChk(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertySets,
                            pprgPropertySets,
                            PROPSET_COMMAND);

    if( FAILED(hr) )
        RRETURN( hr );

    RRETURN( m_pCUtilProp->GetProperties(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertySets,
                            pprgPropertySets,
                            PROPSET_COMMAND) );
}

STDMETHODIMP
CRowset::GetReferencedRowset(
    DBORDINAL   iOrdinal,
    REFIID      riid,
    IUnknown    **ppReferencedRowset
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetReferencedRowset(
                iOrdinal,
                riid,
                ppReferencedRowset)
                );
}

STDMETHODIMP
CRowset::GetSpecification(
    REFIID      riid,
    IUnknown    **ppSpecification
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetSpecification(
                riid,
                ppSpecification)
                );
}

//----------------------------------------------------------------------------- // IRowsetLocate methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::Compare(
    HCHAPTER   hChapter,
    DBBKMARK   cbBookmark1,
    const BYTE *pBookmark1,
    DBBKMARK   cbBookmark2,
    const BYTE *pBookmark2,
    DBCOMPARE  *pComparison
    )
{
    if( (0 == cbBookmark1) || (0 == cbBookmark2) || (NULL == pComparison) ||
        (NULL == pBookmark1) || (NULL == pBookmark2) )
        RRETURN( E_INVALIDARG );

    if( STD_BMK_SIZE == cbBookmark1 )
    {
        if( (*pBookmark1 != DBBMK_FIRST) && (*pBookmark1 != DBBMK_LAST) )
            RRETURN( DB_E_BADBOOKMARK );
    }
    else
        if( ADSI_BMK_SIZE != cbBookmark1 )
            RRETURN( DB_E_BADBOOKMARK );

    if( STD_BMK_SIZE == cbBookmark2 )
    {
        if( (*pBookmark2 != DBBMK_FIRST) && (*pBookmark2 != DBBMK_LAST) )
            RRETURN( DB_E_BADBOOKMARK );
    }
    else
        if( ADSI_BMK_SIZE != cbBookmark2 )
            RRETURN( DB_E_BADBOOKMARK );

    if( (STD_BMK_SIZE == cbBookmark1) || (STD_BMK_SIZE == cbBookmark2) )
    // standard bookmarks can only be compared for equality (not for <, >)
    {
        if( cbBookmark1 != cbBookmark2 )
            *pComparison = DBCOMPARE_NE;
        else if( *pBookmark1 == *pBookmark2 )
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
    }
    else
    {
        if( (*((RBOOKMARK *)pBookmark1)) <  (*((RBOOKMARK *)pBookmark2)) )
            *pComparison = DBCOMPARE_LT;
        else if( (*((RBOOKMARK *)pBookmark1)) >  (*((RBOOKMARK *)pBookmark2)) )
            *pComparison = DBCOMPARE_GT;
        else
            *pComparison = DBCOMPARE_EQ;
    }

    RRETURN( S_OK );
}

STDMETHODIMP
CRowset::Hash(
    HCHAPTER        hChapter,
    DBBKMARK        cBookmarks,
    const DBBKMARK  rgcbBookmarks[],
    const BYTE      *rgpBookmarks[],
    DBHASHVALUE     rgHashedValues[],
    DBROWSTATUS     rgBookmarkStatus[]
    )
{
    int  i;
    HRESULT hr;
    DBBKMARK cErrors = 0;

    if( (NULL == rgHashedValues) || ((cBookmarks != 0) &&
                  ((NULL == rgpBookmarks) || (NULL == rgcbBookmarks))) )
        RRETURN( E_INVALIDARG );

    if( 0 == cBookmarks )
        RRETURN( S_OK );

    for(i = 0; (DBBKMARK)i < cBookmarks; i++)
    {
        if( (rgcbBookmarks[i] != ADSI_BMK_SIZE) || (NULL == rgpBookmarks[i]) )
        {
            cErrors++;
            if( rgBookmarkStatus )
                rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;
        }
        else
        {
            LONG lRow;

            hr = BmkToRow(rgcbBookmarks[i], rgpBookmarks[i], &lRow);
            if( FAILED(hr) )
            {
                cErrors++;
                if( rgBookmarkStatus )
                    rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;

                continue;
            }

            rgHashedValues[i] = (DWORD) lRow;
            if( rgBookmarkStatus )
                rgBookmarkStatus[i] = DBROWSTATUS_S_OK;
        }
    }

    if( cErrors )
    {
        if( cErrors == cBookmarks )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );
    }
    else
        RRETURN( S_OK );
}

STDMETHODIMP
CRowset::GetRowsByBookmark(
    HCHAPTER       hChapter,
    DBCOUNTITEM    cRows,
    const DBBKMARK rgcbBookmarks[],
    const BYTE     *rgpBookmarks[],
    HROW           rghRows[],
    DBROWSTATUS    rgRowStatus[]
    )
{
    int           i;
    HRESULT       hr;
    DBCOUNTITEM   cRowsObtained = 0, cErrors = 0;

    if( (NULL == rghRows) || (NULL == rgcbBookmarks) || (NULL== rgpBookmarks) )
        RRETURN( E_INVALIDARG );

    if( 0 == cRows )
        RRETURN( S_OK );

    for(i = 0; (DBCOUNTITEM)i < cRows; i++)
    {
        if( (rgcbBookmarks[i] != ADSI_BMK_SIZE) || (NULL == rgpBookmarks[i]) )
        {
            cErrors++;
            if( rgRowStatus )
                rgRowStatus[i] = DBROWSTATUS_E_INVALID;
            rghRows[i] = DB_NULL_HROW;
        }
        else
        {
            HROW *phRow;

            phRow = &rghRows[i];
            hr = GetRowsAt(NULL, hChapter, rgcbBookmarks[i],
                           (BYTE *) rgpBookmarks[i], 0, 1, &cRowsObtained,
                           &phRow
                          );
            if( 1 == cRowsObtained )
            {
                if( rgRowStatus )
                    rgRowStatus[i] = DBROWSTATUS_S_OK;
            }
            else
            {
                cErrors++;
                rghRows[i] = DB_NULL_HROW;
                if( rgRowStatus )
                {
                    if( DB_S_ROWLIMITEXCEEDED == hr )
                        rgRowStatus[i] = DBROWSTATUS_E_LIMITREACHED;
                    else if ( E_OUTOFMEMORY == hr )
                        rgRowStatus[i] = DBROWSTATUS_E_OUTOFMEMORY;
                    else
                       rgRowStatus[i] = DBROWSTATUS_E_INVALID;
                 }
             } // else
        } // else
    } // for

    if( cErrors )
    {
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );
    }
    else
        RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// IRowsetScroll methods
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetApproximatePosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE    *pBookmark,
    DBCOUNTITEM   *pulPosition,
    DBCOUNTITEM   *pcRows
    )
{
    LONG    cRows = 0;
    HRESULT hr;

    if( (cbBookmark != 0) && ( NULL == pBookmark) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    if( pcRows )
    // get the total number of rows in the rowset
    {
        hr = SeekToEnd();
        if( FAILED(hr) )
            RRETURN( E_FAIL );

        cRows = m_lCurrentRow - 1;
    }

    if( 0 == cbBookmark )
    {
        if( pcRows )
            *pcRows = cRows;
        RRETURN( S_OK );
    }
    else if( (cbBookmark != ADSI_BMK_SIZE) && (cbBookmark != STD_BMK_SIZE) )
        RRETURN( DB_E_BADBOOKMARK );
    else
    {
        LONG lRow;

        hr = BmkToRow(cbBookmark, pBookmark, &lRow);
        if( FAILED(hr) )
        {
            if( DB_E_BADBOOKMARK == hr )
                RRETURN( DB_E_BADBOOKMARK );
            else
                RRETURN( E_FAIL );
        }

        if( pulPosition )
        {
            *pulPosition = lRow + 1;   // this number is 1-based
            if( pcRows && (*pulPosition > (DBCOUNTITEM)cRows) ) // bookmark was bad
                *pulPosition = cRows;  // make sure *pulPosition <= *pcRows
        }

        if( pcRows )
            *pcRows = cRows;
    }

    RRETURN( S_OK );
}

STDMETHODIMP
CRowset::GetRowsAtRatio(
    HWATCHREGION hReserved1,
    HCHAPTER     hChapter,
    DBCOUNTITEM  ulNumerator,
    DBCOUNTITEM  ulDenominator,
    DBROWCOUNT   cRows,
    DBCOUNTITEM  *pcRowsObtained,
    HROW         **prghRows
    )
{
    HRESULT   hr;
    LONG      lStartRow, cTotalRows;
    RBOOKMARK StartRowBmk;

    if( (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;
        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( (ulNumerator > ulDenominator) || (0 == ulDenominator) )
        RRETURN( DB_E_BADRATIO );

    if( ((ulNumerator == ulDenominator) && (cRows > 0)) ||
        ((0 == ulNumerator) && (cRows < 0)) )
        RRETURN( DB_S_ENDOFROWSET );

    if( 0 == cRows )
        RRETURN( S_OK );

    CAutoBlock cab(&m_RowsetCritSection);

    // get total number of rows
    hr = SeekToEnd();
    if( FAILED(hr) )
        RRETURN( E_FAIL );

    cTotalRows = m_lCurrentRow - 1;

    // Make sure ratio of 1 sets lStartRow to cTotalRows -1 (last row)
    lStartRow = (long)((((double) ulNumerator)/ulDenominator) *
                                                        (cTotalRows - 1));
    StartRowBmk = RowToBmk(lStartRow);

    hr = GetRowsAt(NULL, hChapter, ADSI_BMK_SIZE, (BYTE *) &StartRowBmk,
                         0, cRows, pcRowsObtained, prghRows);

    RRETURN( hr );
}

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\crsembed.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CRSEmbed.cxx
//
//  Contents:   IUnknown embedder for temptable.
//
//  Functions:
//
//  Notes:
//
//
//  History:    08/30/96  | RenatoB   | Created
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// @class CRowsetInfo | embedding of Rowset,
//  to give our IrowsetInfo interface
//
//
//-----------------------------------------------------------------------------
// Includes
#include "oleds.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::QueryInterface
//
//  Synopsis:  @mfunc QueryInterface.
//             IUknown implementation.
//             IID_IUnknown and IID_IRowsetInfo are not delegated
//             All other IID's are delegated to _pRowset
//
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;
    if (ppv == NULL)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    if (riid == IID_IUnknown) {
        *ppv = (IRowsetInfo FAR *) this;
        AddRef();
    }

    if (riid == IID_IRowsetInfo) {
        *ppv = (IRowsetInfo FAR *) this;
        AddRef();
    }

    //delegate all the rest to the TempTable Rowset
    if (_pRowset == NULL)
        RRETURN(E_UNEXPECTED);
    hr=((LPUNKNOWN)_pRowset)->QueryInterface(riid, ppv);

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::CRowsetInfo
//
//  Synopsis:  @mfunc Ctor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
CRowsetInfo::CRowsetInfo(
   IUnknown           *pUnkOuter,      // controlling unknown)
   IUnknown  *pParentObject,           // RowProvider
   CSessionObject    *pCSession,       // Session that created rowset
   CCommandObject    *pCCommand        // Command object that created rowset
   )

{
    _pUnkOuter= (pUnkOuter == NULL) ? this : pUnkOuter;
    _pRowset = NULL;
    _pParentObject = pParentObject;
    _pCSession= pCSession;
    _pCCommand = pCCommand;

    _pMalloc = NULL;
    _dwStatus = 0;
    _cPropertySets = 0;
    _pPropertySets = NULL;

    if (_pCCommand !=NULL)
        _pCCommand->IncrementOpenRowsets();

    //this section is for IRowsetInfo and IUnknown methods.

    InitializeCriticalSection(&_csRowsetInfo);
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::~CRowsetInfo
//
//  Synopsis:  @mfunc Dtor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------

CRowsetInfo::~CRowsetInfo()
{
    // release _pPropertySets
    FreePropertySets(_cPropertySets, _pPropertySets);
    if (_pMalloc!= NULL) _pMalloc->Release();

    if (_pCCommand !=NULL) {
        _pCCommand->DecrementOpenRowsets();
        _pCCommand->Release();
        _pCCommand = NULL;
    }

    if (_pCSession != NULL) {
        _pCSession->Release();
        _pCSession = NULL;
    }

    if (_pParentObject != NULL){
        _pParentObject->Release();
        _pParentObject=NULL;
    }

    if (_pRowset != NULL){
        ((LPUNKNOWN)_pRowset)->Release();
        _pRowset=NULL;
    }

    if ( _pCRowsetInfo!= NULL) {
        delete _pCRowsetInfo;
        _pCRowsetInfo = NULL;
    }

    DeleteCriticalSection(&_csRowsetInfo);

}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::FInit
//
//  Synopsis:  @mfunc Initializer
//
//             Called by: CreateTempTable
//             Called when: After calling pIServiceProvider->ProvideService
//  Synopsis:  @mfunc Initializer
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//    @flag S_OK                   | Interface is supported
//        @flag E_OUTOFMEMORY | Interface is not supported by the TempTable
//        @flag E_INVALIDARG     | One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::FInit(
    IUnknown *pRowset)          // TmpTable interface
{
    HRESULT hr;
    hr = S_OK;
    _pRowset = pRowset;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetReferencedRowset
//
//  Synopsis:  @mfunc Returns an interface pointer to the rowset to which a bookmark applies
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     iOrdinal          [in]  Bookmark column for which to get related rowset. Must be 0 in this impl.
//     riid              [in] IID of the interface pointer to return in *ppReferencedRowset.
//     ppReferencedRowset[out] pointer to  Rowset object referenced by Bookmark
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppReferencedRowset was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Rowset does not support interface
//        DB_E_NOTAREFENCEDCOLUMN | iOrdinal was not 0
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetReferencedRowset(
    DBORDINAL iOrdinal,
    REFIID riid,
    IUnknown** ppReferencedRowset
    )
{
    CAutoBlock(&(_csRowsetInfo));

    if (ppReferencedRowset == NULL)
        RRETURN(E_INVALIDARG);

    if (iOrdinal != 0)
        RRETURN(DB_E_BADORDINAL);

    RRETURN(QueryInterface(
                 riid,
                 (void**)ppReferencedRowset)
           );

};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetSpecificaton
//
//  Synopsis:  @mfunc Returns an interface pointer to the command that created the rowset
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     riid              [in] IID of the interface pointer to return in *ppSpecification.
//     ppSpecification [out] pointer to  command
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppSpecification was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Command does not support interface
//      S_FALSE                   | Rowset does not have command that created it
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetSpecification(
    REFIID riid,
    IUnknown** ppSpecification
    )
{
    CAutoBlock(&(_csRowsetInfo));

    if (ppSpecification == NULL)
        RRETURN(E_INVALIDARG);

    if ( _pParentObject == NULL)
        RRETURN(S_FALSE);

    RRETURN(_pParentObject->QueryInterface(riid, (void**)ppSpecification));
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetProperties
//
//  Synopsis:  @mfunc GetProperties
//             Overloads the TempTable's IRowsetInfo::GetProperties.
//             The first time this function is called, it calls the
//             TmpTable IRowsetInfo::GetProperties with cPropertyIdSets == 0
//
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//    cPropertyIDSets[in]    The number of DBPROPIDSET structures in rgProperttySets
//    rgPropertyIDSets[in]   Array of cPropertyIDSets of DBPROIDSET structs.
//    pcPropertySets[out]    number of DBPROPSET returned in *prgPropertySets
//    prgPropertySets[out]   pointer to array of DBPROPSET structures, having the
//                           value and status of requested properties
//
//  Returns:   @rdesc HRESULT
//  S_OK                Success
//  DB_S_ERRORSOCCURRED Values were not supported for some properties
//  E_FAIL              A provider-specific error occurred
//  E_INVALIDARG        cPropertyIDSets > 0 and rgPropertyIdSEts = NULL
//                      pcPropertySets or prgPropertySets was NULL pointer
//                      In al element of rgPropertyIDSets, cPropertyIDs was not zero
//                      and rgPropertyIDs was a Null pointer
//  E_OUTOFMEMORY       Provider could not allocate memory
//  DB_E_ERRORSOCCURRED Values were not returned for any properties
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::GetProperties(
    const ULONG       cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG*            pcPropertySets,
    DBPROPSET**       prgPropertySets
    )
{
    CAutoBlock(&(_csRowsetInfo));

    // mplPropertyIDsets maps the position of a property set in rgPropertyIDSets[]
    // within _pPropertySets. It has (-1) if not mappable
    LONG mplPropertyIDSets[50];
    // mplPropertySets maps the position of a property within its corresponding
    // rgProperties in _pPropertySets. It has (-1) if not mappable.
    LONG position;

    HRESULT hr = S_OK;
    ULONG i;
    ULONG j;
    ULONG ibPropertyIDsets;
    ULONG ibPropertySets;
    BOOL bPartialSuccess = FALSE;
    BOOL bErrorsOccurred = FALSE;
    //validate arguments
    if ( ((cPropertyIDSets > 0) && ( rgPropertyIDSets == NULL)) ||
         (pcPropertySets == NULL) ||
         (prgPropertySets == NULL) )
        RRETURN(E_INVALIDARG);

    for (i = 0; i< cPropertyIDSets; i++) {
        if ((rgPropertyIDSets[i].cPropertyIDs > 0) &&
            (rgPropertyIDSets[i].rgPropertyIDs ==NULL))
            RRETURN(E_INVALIDARG);
    }

    //Initializate, if needed
    if (_dwStatus == 0) InitProperties();

    if (_dwStatus & STAT_INITERROR) //initialization was unsuccessful
        RRETURN(E_FAIL);

    // If CPropertyIDSets == 0, just copy
    *pcPropertySets = 0;
    *prgPropertySets = NULL;
    //case when cPropertyIDSets == 0
    if (cPropertyIDSets == 0) {
        //allocate memory for the property sets
        *prgPropertySets = (DBPROPSET*) _pMalloc->Alloc(
                                            _cPropertySets*sizeof(DBPROPSET)
                                            );
        if (*prgPropertySets == NULL) {
            hr = E_OUTOFMEMORY;
            goto error;
        };

        *pcPropertySets = _cPropertySets;

        // copy the array of property sets and make rgProperties equal to NULL
        memcpy(
            (void*) *prgPropertySets,
            (void*) _pPropertySets,
            _cPropertySets*sizeof(DBPROPSET)
            );

        for (i = 0; i< _cPropertySets; i++)
            (*prgPropertySets)[i].rgProperties = NULL;

        // make copies of each of the rgProperties contained in _pPropertySets
        for (i = 0; i< _cPropertySets ; i++) {
            (*prgPropertySets)[i].rgProperties=
            (DBPROP*)_pMalloc->Alloc(
                _pPropertySets[i].cProperties*sizeof(DBPROP)
                );

            if ((*prgPropertySets)[i].rgProperties == NULL) {
                hr = E_OUTOFMEMORY;
                goto error;
            };

            memcpy(
                (void*)((*prgPropertySets)[i].rgProperties),
                (void*) (_pPropertySets[i].rgProperties),
                _pPropertySets[i].cProperties*sizeof(DBPROP)
                );

        };

        RRETURN(S_OK);
    };
    // This is the case when cPropertyIDSets != 0
    // First, allocate memory
    *prgPropertySets = (DBPROPSET*) _pMalloc->Alloc(
                           cPropertyIDSets*sizeof(DBPROPSET)
                           );

    if (*prgPropertySets == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    };
    memset((void*)*prgPropertySets, 0, sizeof(DBPROPSET)*cPropertyIDSets );
    *pcPropertySets= cPropertyIDSets;
    memset(mplPropertyIDSets, 0, sizeof(LONG)*cPropertyIDSets );

    for (i=0; i<cPropertyIDSets; i++) {
        (*prgPropertySets)[i].guidPropertySet =
            rgPropertyIDSets[i].guidPropertySet;
        mplPropertyIDSets[i] = SearchGuid(
                                   rgPropertyIDSets[i].guidPropertySet
                                   );

        if (mplPropertyIDSets[i] < 0) {
            bErrorsOccurred = TRUE;
            (*prgPropertySets)[i].cProperties = 0;
            (*prgPropertySets)[i].rgProperties = NULL;

            (*prgPropertySets)[i].guidPropertySet =
                rgPropertyIDSets[i].guidPropertySet;
        }

        else {
            //The PropertySet is supported. Remember its position in ibPropertyIDsets
            ibPropertyIDsets = mplPropertyIDSets[i];
            //We write the property-set's GUID
            (*prgPropertySets)[i].guidPropertySet =
                rgPropertyIDSets[i].guidPropertySet;

            if (rgPropertyIDSets[i].cPropertyIDs == 0) {
                //the client is asking for all properties
                bPartialSuccess = TRUE;
                (*prgPropertySets)[i].rgProperties=
                (DBPROP*)_pMalloc->Alloc(
                    _pPropertySets[ibPropertyIDsets].cProperties*sizeof(DBPROP)
                    );

                if ((*prgPropertySets)[i].rgProperties == NULL) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                };

                (*prgPropertySets)[i].cProperties=
                _pPropertySets[ibPropertyIDsets].cProperties;

                memcpy(
                    (void*) ((*prgPropertySets)[i].rgProperties),
                    (void*) _pPropertySets[ibPropertyIDsets].rgProperties,
                    _pPropertySets[ibPropertyIDsets].cProperties*sizeof(DBPROP)
                    );

            }
            else {
                //the client asks for some properties only. Alloc and clear memory
                (*prgPropertySets)[i].rgProperties=
                (DBPROP*)_pMalloc->Alloc(rgPropertyIDSets[i].cPropertyIDs
                                          *sizeof(DBPROP));

                if ((*prgPropertySets)[i].rgProperties == NULL) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                };

                (*prgPropertySets)[i].cProperties =
                    rgPropertyIDSets[i].cPropertyIDs;

                memset(
                    ((*prgPropertySets)[i].rgProperties),
                    0,
                    rgPropertyIDSets[i].cPropertyIDs*sizeof(DBPROP)
                    );

                //iterate and set values
                for (j=0; j <rgPropertyIDSets[i].cPropertyIDs; j++) {
                    position =
                        SearchPropid(
                            ibPropertyIDsets,
                            rgPropertyIDSets[i].rgPropertyIDs[j]
                            );

                    if (position < 0) {
                        //could not find a property
                        bErrorsOccurred = TRUE;
                        (*prgPropertySets)[i].rgProperties[j].dwPropertyID =
                            rgPropertyIDSets[i].rgPropertyIDs[j];

                        (*prgPropertySets)[i].rgProperties[j].dwStatus =
                            DBPROPSTATUS_NOTSUPPORTED;
                    }

                    else {
                        bPartialSuccess= TRUE;
                        ibPropertySets = position;
                        memcpy(
                            (void*)&((*prgPropertySets)[i].rgProperties[j] ),
                            (void*)&(_pPropertySets[ibPropertyIDsets].
                                     rgProperties[ibPropertySets]),
                            sizeof(DBPROP));
                    }
                }
            }
        }
    }

    if ((bPartialSuccess == TRUE) && (bErrorsOccurred == FALSE))
        RRETURN(S_OK);

    if (bPartialSuccess == TRUE)
        RRETURN(DB_S_ERRORSOCCURRED);

    hr = DB_E_ERRORSOCCURRED;
    goto error;

error:

    FreePropertySets( *pcPropertySets, *prgPropertySets);
    *pcPropertySets = NULL;
    *prgPropertySets = NULL;
    RRETURN(hr);

};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::FreePropertySets
//
//  Synopsis:  @mfunc releases the memory of property sets
//
//  Arguments:
//       cPropertySets    [in]     number of property sets to be freed
//       rgPropertySets   [in/out] array with the property sets to be released
//             Called by:   Provider
//             Called when: By the destructor, or for method that needs cleanup
//                          of property sets
//----------------------------------------------------------------------------
void
CRowsetInfo::FreePropertySets(
    ULONG cPropertySets,
    DBPROPSET *rgPropertySets
    )
{
    ULONG i;
    if ((cPropertySets > 0) && (rgPropertySets == NULL)) {
        return;
    }
    if (cPropertySets == 0) return;
    if (_pMalloc == NULL) {
        return;
    }
    //Free the individual arrays of properties
    for (i=0; i< cPropertySets; i++) {
        if ((rgPropertySets[i].cProperties > 0) &&
            (rgPropertySets[i].rgProperties != NULL))
            _pMalloc->Free(rgPropertySets[i].rgProperties);
    };
    //Free the array of propertysets
    _pMalloc->Free(rgPropertySets);
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::InitProperties
//
//  Synopsis:  @mfunc initilizes _cPropertySets and _pPropertySets from
//             _pRowset
//
//----------------------------------------------------------------------------
HRESULT CRowsetInfo::InitProperties(void)
{
    HRESULT hr;
    IRowsetInfo* pRowsetInfo = NULL;
    hr = CoGetMalloc(MEMCTX_TASK, &_pMalloc);
    if (FAILED(hr)) {
        goto error;
    }

    if (_pRowset == NULL) {
        hr = E_FAIL;
        goto error;
    };
    hr = _pRowset->QueryInterface(IID_IRowsetInfo, (void**) &pRowsetInfo);
    if (FAILED (hr)) {
        goto error;
    };
    hr= pRowsetInfo->GetProperties(0, NULL, &_cPropertySets, &_pPropertySets);
    if (FAILED(hr)) {
        goto error;
    }
    _dwStatus =STAT_DIDINIT;
    pRowsetInfo->Release();
    RRETURN(S_OK);
    error:

    _dwStatus = STAT_INITERROR;
    if (_pMalloc != NULL) {
        _pMalloc->Release();
        _pMalloc = NULL;
    }
    if (pRowsetInfo != NULL)
        pRowsetInfo->Release();
    ;
    RRETURN(hr);
};
//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::SearchGuid
//
//  Synopsis:  @mfunc
//
//  Arguments: riid   [in]    GUID to be searched for
//
//  Returns:
//              The position of the GUID withing _pPropertySets. Returns -1
//                 if not found
//
//----------------------------------------------------------------------------
LONG  CRowsetInfo::SearchGuid(GUID riid)
{
    ULONG i;
    for (i = 0; i < _cPropertySets; i++) {
        if (_pPropertySets[i].guidPropertySet == riid) return (i);
    };
    return -1;
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::SearchPropid
//
//  Synopsis:  @mfunc Searchs for a Propid within _PropertySets
//
//  Arguments:
//        ibPropertySet   [in]    The index, within _pPropertySets,
//                                of the DBPROPSET to be searched
//        dwPropertyID    [in]    The propid to be searched
//  Returns:
//              The position of the DBPROP with propid=dwPropertyID
//               within  _pPropertySets[ibPropertySet]. Returns -1
//                 if not found
//
//----------------------------------------------------------------------------
LONG  CRowsetInfo::SearchPropid(
                                    ULONG ibPropertySet,
                                    DWORD dwPropertyID)

{
    ULONG i;
    for (i = 0; i < _pPropertySets[ibPropertySet].cProperties; i++) {
        if (_pPropertySets[ibPropertySet].rgProperties[i].dwPropertyID ==dwPropertyID )
            return (i);
    };
    return -1;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\csed.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cSecurityDescriptor.cxx
//
//  Contents:  SecurityDescriptor object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CSecurityDescriptor

DEFINE_IDispatch_Implementation(CSecurityDescriptor)

CSecurityDescriptor::CSecurityDescriptor():
        _pDispMgr(NULL),
        _lpOwner(NULL),
        _fOwnerDefaulted(FALSE),
        _lpGroup(NULL),
        _fGroupDefaulted(FALSE),
        _dwRevision(0),
        _dwControl(0),
        _pDAcl(NULL),
        _fDaclDefaulted(FALSE),
        _pSAcl(NULL),
        _fSaclDefaulted(FALSE)
{
    ENLIST_TRACKING(CSecurityDescriptor);
}


HRESULT
CSecurityDescriptor::CreateSecurityDescriptor(
    REFIID riid,
    void **ppvObj
    )
{
    CSecurityDescriptor FAR * pSecurityDescriptor = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSecurityDescriptorObject(&pSecurityDescriptor);
    BAIL_ON_FAILURE(hr);

    hr = pSecurityDescriptor->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->Release();

    RRETURN(hr);

error:
    delete pSecurityDescriptor;

    RRETURN_EXP_IF_ERR(hr);

}


CSecurityDescriptor::~CSecurityDescriptor( )
{
    delete _pDispMgr;

    if (_pDAcl) {
        _pDAcl->Release();
    }

    if (_pSAcl) {
        _pSAcl->Release();
    }

    if (_lpOwner) {
        FreeADsStr(_lpOwner);
    }

    if (_lpGroup) {
        FreeADsStr(_lpGroup);
    }
}

STDMETHODIMP
CSecurityDescriptor::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSecurityDescriptor))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CSecurityDescriptor::AllocateSecurityDescriptorObject(
    CSecurityDescriptor ** ppSecurityDescriptor
    )
{
    CSecurityDescriptor FAR * pSecurityDescriptor = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSecurityDescriptor = new CSecurityDescriptor();
    if (pSecurityDescriptor == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsSecurityDescriptor,
                (IADsSecurityDescriptor *)pSecurityDescriptor,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->_pDispMgr = pDispMgr;
    *ppSecurityDescriptor = pSecurityDescriptor;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CSecurityDescriptor::InterfaceSupportsErrorInfo(THIS_ REFIID riid) 
{
    if (IsEqualIID(riid, IID_IADsSecurityDescriptor)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CSecurityDescriptor::get_DiscretionaryAcl(
    IDispatch FAR * FAR * retval
    )
{

    if (_pDAcl) {

        //
        // Need to AddRef this pointer


        _pDAcl->AddRef();

        *retval = _pDAcl;



    }else {
        *retval = NULL;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_DiscretionaryAcl(
    IDispatch FAR * pDiscretionaryAcl
    )
{
    HRESULT hr = S_OK;

    if (_pDAcl) {

        _pDAcl->Release();
    }

    if (pDiscretionaryAcl) {

        hr = pDiscretionaryAcl->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&_pDAcl
                    );

    }else {
        _pDAcl = NULL;

    }


    RRETURN_EXP_IF_ERR(hr);



}


STDMETHODIMP
CSecurityDescriptor::get_SystemAcl(
    IDispatch FAR * FAR * retval
    )
{
    if (_pSAcl) {

        //
        //  Need to AddRef this pointer
        //

        _pSAcl->AddRef();

        *retval = _pSAcl;

    }else {
        *retval = NULL;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_SystemAcl(
    IDispatch FAR * pSystemAcl
    )
{
    HRESULT hr = S_OK;


    if (_pSAcl) {


        _pSAcl->Release();
    }

    if (pSystemAcl) {

        hr = pSystemAcl->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&_pSAcl
                    );
    }else {

        _pSAcl = NULL;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CSecurityDescriptor::get_Revision(THIS_ long FAR * retval)
{

    *retval = _dwRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_Revision(THIS_ long lnRevision)
{

    _dwRevision = lnRevision;
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_Control(THIS_ long FAR * retval)
{
    *retval = _dwControl;
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_Control(THIS_ long lnControl)
{

    _dwControl = lnControl;
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_Owner(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpOwner, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CSecurityDescriptor::put_Owner(THIS_ BSTR bstrOwner)
{


    if (_lpOwner) {
        FreeADsStr(_lpOwner);
    }

    if (!bstrOwner) {
        _lpOwner = NULL;
    }
    else {
        _lpOwner = AllocADsStr(bstrOwner);

        if (!_lpOwner) {
            RRETURN(E_OUTOFMEMORY);
        }
        
    }


    RRETURN(S_OK);

}

STDMETHODIMP
CSecurityDescriptor::get_Group(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpGroup, retval);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CSecurityDescriptor::put_Group(THIS_ BSTR bstrGroup)
{

    if (_lpGroup) {
        FreeADsStr(_lpGroup);
    }

    if (!bstrGroup) {
        _lpGroup = NULL;
    }
    else {
        _lpGroup = AllocADsStr(bstrGroup);

        if (!_lpGroup) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }
    }
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::CopySecurityDescriptor(THIS_ IDispatch FAR * FAR * ppSecurityDescriptor)
{

    HRESULT hr = S_OK;
    IADsSecurityDescriptor * pSecDes = NULL;

    IDispatch *pTargetDACL = NULL;
    IDispatch *pTargetSACL = NULL;
    IDispatch * pDisp = NULL;

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    if (_lpOwner) {
       hr = pSecDes->put_Owner(_lpOwner);
       BAIL_ON_FAILURE(hr);
    }

    if (_lpGroup) {
        hr = pSecDes->put_Group(_lpGroup);
        BAIL_ON_FAILURE(hr);
    }

    hr = pSecDes->put_Revision(_dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)_dwControl);
    BAIL_ON_FAILURE(hr);

    if (_pDAcl) {
        hr = _pDAcl->CopyAccessList(&pTargetDACL);
        BAIL_ON_FAILURE(hr);

        hr = pSecDes->put_DiscretionaryAcl(pTargetDACL);
        BAIL_ON_FAILURE(hr);
    }


    if (_pSAcl) {

        hr = _pSAcl->CopyAccessList(&pTargetSACL);
        BAIL_ON_FAILURE(hr);

        hr = pSecDes->put_SystemAcl(pTargetSACL);
        BAIL_ON_FAILURE(hr);

    }
    hr = pSecDes->QueryInterface(
                        IID_IDispatch,
                        (void**)&pDisp
                        );
    BAIL_ON_FAILURE(hr);


    *ppSecurityDescriptor = pDisp;

cleanup:
    if (pTargetSACL) {
        pTargetSACL->Release();
    }

    if (pTargetDACL) {
        pTargetDACL->Release();
    }

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN_EXP_IF_ERR(hr);

error:

    *ppSecurityDescriptor = NULL;

    if (pTargetDACL) {
        pTargetDACL->Release();
    }

    if (pTargetSACL) {
        pTargetSACL->Release();
    }

    goto cleanup;
}


STDMETHODIMP
CSecurityDescriptor::get_OwnerDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fOwnerDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_OwnerDefaulted(THIS_ VARIANT_BOOL fOwnerDefaulted)
{
    if (fOwnerDefaulted == VARIANT_TRUE) {
        _fOwnerDefaulted = TRUE;
    }else {
        _fOwnerDefaulted = FALSE;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::get_GroupDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fGroupDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_GroupDefaulted(THIS_ VARIANT_BOOL fGroupDefaulted)
{
    if (fGroupDefaulted == VARIANT_TRUE) {
        _fGroupDefaulted = TRUE;
    }else {
        _fGroupDefaulted = FALSE;
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_DaclDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fDaclDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_DaclDefaulted(THIS_ VARIANT_BOOL fDaclDefaulted)
{
    if (fDaclDefaulted == VARIANT_TRUE) {
        _fDaclDefaulted = TRUE;
    }else {
        _fDaclDefaulted = FALSE;
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_SaclDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fSaclDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_SaclDefaulted(THIS_ VARIANT_BOOL fSaclDefaulted)
{
    if (fSaclDefaulted == VARIANT_TRUE) {
        _fSaclDefaulted = TRUE;
    }else {
        _fSaclDefaulted = FALSE;
    }

    RRETURN(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\csession.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  csession.cxx
//
//  Contents:  Microsoft OleDB/OleDS Session object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop
#include "atl.h"
#include "row.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDataSource
//
//  Synopsis: Retrieve an interface pointer on the session object
//
//  Arguments:
//              riid,               IID desired
//              ppDSO               ptr to interface
//
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            ppDSO was NULL
//              E_NOINTERFACE           IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetDataSource (
        REFIID      riid,
    IUnknown ** ppDSO
    )
{
    //
    // Asserts
    //
    ADsAssert(_pDSO);

    if( ppDSO == NULL )
        RRETURN( E_INVALIDARG );

    RRETURN( _pDSO->QueryInterface(riid, (LPVOID*)ppDSO) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDataSource
//
//  Synopsis: Retrieve an interface pointer on the session object
//
//  Arguments:
//              riid,               IID desired
//              ppDSO               ptr to interface
//
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            ppDSO was NULL
//              E_NOINTERFACE           IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::OpenRowset(
        IUnknown *  pUnkOuter,
        DBID *      pTableID,
        DBID *      pIndexID,
        REFIID      riid,
        ULONG       cPropertySets,
        DBPROPSET   rgPropertySets[],
        IUnknown ** ppRowset
        )
{
    // Don't pass any credentials (NULL)
    RRETURN( OpenRowsetWithCredentials(
                    pUnkOuter,
                    pTableID,
                    pIndexID,
                    riid,
                    cPropertySets,
                    rgPropertySets,
                    NULL,
                    ppRowset) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::OpenRowsetWithCredentials
//
//  Synopsis: Opens a rowset. Similar to OpenRowset but takes extra argument
//            CCredentials. This function is used when consumer calls
//            IBindResource::Bind requesting a rowset.
//
//  Returns : HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::OpenRowsetWithCredentials (
        IUnknown *     pUnkOuter,
        DBID *         pTableID,
        DBID *         pIndexID,
        REFIID         riid,
        ULONG          cPropertySets,
        DBPROPSET      rgPropertySets[],
        CCredentials * pCredentials,
        IUnknown **    ppRowset
        )
{
    BOOL         fWarning = FALSE;
    CRowProvider *pRowProvider = NULL;
    DWORD        cAttrs = 1;
    BOOL         *pbMultiValue = NULL; 
    LPWSTR       *pAttrs = NULL;

    //
    // Check in-params and NULL out-params in case of error
    //
    if( ppRowset )
        *ppRowset = NULL;

    if( !pTableID && !pIndexID )
        RRETURN( E_INVALIDARG );

    if( pIndexID )
        RRETURN( DB_E_NOINDEX );

    //
    // Check the PropertySets
    //
    if( cPropertySets > 0 && !rgPropertySets )
        RRETURN ( E_INVALIDARG );

    for(ULONG i=0; i<cPropertySets; i++) {
        if( rgPropertySets[i].cProperties && !rgPropertySets[i].rgProperties )
            RRETURN ( E_INVALIDARG );
    }

    //
    // pwszName field represents the ADsPath of the Directory we have to open;
    // Make sure pwszName is meaningful
    //
    if( !pTableID ||  pTableID->eKind != DBKIND_NAME ||
        !pTableID->uName.pwszName || !(*(pTableID->uName.pwszName)) )
        RRETURN( DB_E_NOTABLE );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    if( riid == IID_NULL )
        RRETURN( E_NOINTERFACE );

    //
    // By default, we use credentials stored in member variable _Credentials
    // for binding. Buf if caller passed any credentials through pCredentials,
    // these take precedence. This also means that we need to store these
    // credentials in the CRowProvider object for future use -
    // e.g. GetRowFromHRow will use these credentials.
    //
    CCredentials * pCreds = &_Credentials;
    if( pCredentials )
        pCreds = pCredentials;

    //
    // If integrated security is being used, impersonate the caller
    //
    BOOL fImpersonating;

    fImpersonating = FALSE;
    if(_pDSO->IsIntegratedSecurity())
    {
        HANDLE ThreadToken = _pDSO->GetThreadToken();

        ASSERT(ThreadToken != NULL);
        if (ThreadToken)
        {
            if (!ImpersonateLoggedOnUser(ThreadToken))
                RRETURN(E_FAIL);
            fImpersonating = TRUE;
        }
        else
            RRETURN(E_FAIL);
    }

    HRESULT hr = GetDSInterface(
                    pTableID->uName.pwszName,
                    *pCreds,
                    IID_IDirectorySearch,
                    (void **)&_pDSSearch);

    if (fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Get ColumnsInfo based on the list of attributes that we want to be
    // returned.  GetDefaultColumnInfo cleansup memory on failure.
    //
    ULONG          cColumns      = 0;
    DBCOLUMNINFO * prgInfo       = NULL;
    WCHAR *        pStringBuffer = NULL;

    hr = GetDefaultColumnInfo(&cColumns, &prgInfo, &pStringBuffer);
    if( FAILED(hr) )
        RRETURN( hr );

    // Store the properties (which must be in the rowset property group) in
    // the property object. OpenRowset is different from methods like
    // ICOmmand::SetProperties and ISessionProperties::SetProperties in that
    // it returns DB_E_ERROSOCCURRED if any property which is REQUIRED could
    // not be set and DB_S_ERROROCCURRED if any property that is OPTIONAL
    // could not be set. ICommand::SetProperties returns DB_E_ERROSOCCURRED
    // if all properties could not be set and DB_S_ERROSOCCURRED if some
    // property could not be set i.e, DBPROPOPTIONS (REQUIRED or OPTIONAL) is
    // ignored.

    // Use PROPSET_COMMAND as the bitmask below since the properties that are
    // going to be set are in the rowset property group. These properties that
    // are stored in the property object cannot be retrieved by the client
    // since GetProperties on a session object will only return properties in
    // the session property group.

    hr = _pUtilProp->SetProperties(
            cPropertySets,
            rgPropertySets,
            PROPSET_COMMAND
            );
    if( (DB_E_ERRORSOCCURRED == hr) || (DB_S_ERRORSOCCURRED == hr) )
    // check if a required property could not be set
    {
        ULONG i, j;

        for(i = 0; i < cPropertySets; i++)
            for(j = 0; j < rgPropertySets[i].cProperties; j++)
                if( rgPropertySets[i].rgProperties[j].dwStatus != 
                               DBPROPSTATUS_OK ) 
                    if( rgPropertySets[i].rgProperties[j].dwOptions != 
                               DBPROPOPTIONS_OPTIONAL ) 
                    {
                        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
                    }
                    else
                        fWarning = TRUE;

        // if we get here, then there was all required properties were set 
        // successfully. However, hr could still be DB_ERRORSOCCURRED if all
        // properties were optional and all of them could not be set. This
        // condition is not an error for OpenRowset as noted in the comment 
        // above. Hence reset hr to S_OK.

        hr = S_OK;
    }

    // we still need to catch other errors like E_INAVLIDARG
    BAIL_ON_FAILURE(hr);

    hr = SetSearchPrefs();
    BAIL_ON_FAILURE( hr );

    //
    // Create RowProvider object to pass to rowset code
    //
    pbMultiValue = (BOOL *)AllocADsMem(sizeof(BOOL));
    pAttrs = (LPWSTR *)AllocADsMem(cAttrs * sizeof(LPWSTR));
    if( pAttrs )
        pAttrs[0] = AllocADsStr(L"ADsPath");

    if( !pAttrs || !pAttrs[0] || !pbMultiValue )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    *pbMultiValue = FALSE;
    _pDSSearch->AddRef();

    // Is this an NDS path? If so, set filter appropriately. Fix for #286560.
    WCHAR lpszProgId[MAX_PATH];
    BOOL fIsNds;

    hr = CopyADsProgId(pTableID->uName.pwszName, lpszProgId);
    BAIL_ON_FAILURE( hr );
    if( !wcscmp(L"NDS", lpszProgId) )
        fIsNds = TRUE;
    else
        fIsNds = FALSE;

    hr = CRowProvider::CreateRowProvider(
                            _pDSSearch,
                            NULL,
                            pAttrs,
                            cAttrs,
                            cColumns,
                            prgInfo,
                            pStringBuffer,
                            IID_IRowProvider,
                            pbMultiValue,
                            TRUE,
                            pCreds,
                            (void **) &pRowProvider
                            );

    BAIL_ON_FAILURE( hr );

    //
    // RowProvider responsible for deallocation
    //
    pbMultiValue = NULL;

    hr= CRowset::CreateRowset(
            pRowProvider,
            (LPUNKNOWN)(IAccessor FAR *)this ,
            this,
            NULL,
            cPropertySets,
            rgPropertySets,
            0,
            NULL,
            TRUE,  // ADsPath is requested
            FALSE, // not all attributes are requested 
            riid,
            ppRowset
            );

    BAIL_ON_FAILURE( hr );

error:

    if( _pDSSearch ) {
        _pDSSearch->Release();
        _pDSSearch = NULL;
    }

    if( pRowProvider )
        pRowProvider->Release();

    if( prgInfo )
        _pIMalloc->Free(prgInfo);

    if( pStringBuffer )
        _pIMalloc->Free(pStringBuffer);

    if( pbMultiValue )
        FreeADsMem(pbMultiValue);

    if (pAttrs)
    {
        for (i = 0; i < cAttrs; i++)
        {
            if (pAttrs[i])
                FreeADsStr(pAttrs[0]);
        }
        FreeADsMem(pAttrs);
    }

    if( FAILED(hr) )
        RRETURN( hr );
    else if( fWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetProperties
//
//  Synopsis: Returns current settings of all properties in the DBPROPFLAGS_SESSION property
//            group
//
//  Arguments:
//              cPropertySets         count of restiction guids
//              rgPropertySets        restriction guids
//              pcProperties          count of properties returned
//              prgProperties         property information returned
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            pcProperties or prgPropertyInfo was NULL
//              E_OUTOFMEMORY           Out of memory
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetProperties(
        ULONG        cPropIDSets,
        const        DBPROPIDSET rgPropIDSets[],
        ULONG *      pcPropSets,
        DBPROPSET ** pprgPropSets
        )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Check in-params and NULL out-params in case of error
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                                cPropIDSets,
                                rgPropIDSets,
                                pcPropSets,
                                pprgPropSets,
                                PROPSET_SESSION);
    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_SESSION) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::SetProperties
//
//  Synopsis: Set properties in the DBPROPFLAGS_SESSION property group
//
//  Arguments:
//              cProperties
//              rgProperties
//
//  Returns:
//              S_OK             Session Object Interface returned
//              E_INVALIDARG     pcProperties or prgPropertyInfo was NULL
//              E_OUTOFMEMORY    Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::SetProperties(
        ULONG     cPropertySets,
        DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            PROPSET_SESSION) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CreateCommand
//
//  Synopsis: Creates a brand new command and returns requested interface
//
//  Arguments:
//              pUnkOuter           outer Unknown
//              riid,               IID desired
//              ppCommand           ptr to interface
//
//
//  Returns:
//              S_OK                Command Object Interface returned
//              E_INVALIDARG        ppCommand was NULL
//              E_NOINTERFACE       IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::CreateCommand(
        IUnknown *  pUnkOuter,
        REFIID      riid,
        IUnknown ** ppCommand
    )
{
    CCommandObject* pCommand = NULL;
    HRESULT                     hr;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppCommand )
        *ppCommand = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // open a CCommand object
    //
    pCommand = new CCommandObject(pUnkOuter);
    if( !pCommand )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( !pCommand->FInit(this, _Credentials) ) {
        delete pCommand;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DBSession
    //
    hr = pCommand->QueryInterface(riid, (void **)ppCommand);
    if( FAILED( hr ) ) {
        delete pCommand;
        RRETURN( hr );
    }

    pCommand->Release();

    //
    // all went well
    //
    RRETURN( S_OK );
}



//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDefaultColumnInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetDefaultColumnInfo(
        ULONG *         pcColumns,
        DBCOLUMNINFO ** prgInfo,
        OLECHAR **      ppStringBuffer
    )
{
    //
    // Asserts
    //
    ADsAssert(_pIMalloc);
    ADsAssert(pcColumns);
    ADsAssert(prgInfo);
    ADsAssert(ppStringBuffer);

    //
    // Allcoate memory for the Bookmark and ADsPath column
    //
    *prgInfo = (DBCOLUMNINFO*)_pIMalloc->Alloc(2 * sizeof(DBCOLUMNINFO));
    *ppStringBuffer = (WCHAR*)_pIMalloc->Alloc((wcslen(L"ADsPath") + 1) * sizeof(WCHAR));

    //
    // Free memory on a failure
    //
    if( !(*prgInfo) )
        RRETURN( E_OUTOFMEMORY );

    if( !(*ppStringBuffer) ) {
        _pIMalloc->Free(*prgInfo);
        *prgInfo = NULL;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // Initialize the memory
    //
    ZeroMemory(*prgInfo, 2 * sizeof(DBCOLUMNINFO));
    ZeroMemory(*ppStringBuffer, (wcslen(L"ADsPath") + 1) * sizeof(WCHAR));
    wcscpy(*ppStringBuffer, OLESTR("ADsPath"));

    //
    // Fill up the Bookmark column
    //
    *pcColumns = 2;

    (*prgInfo)[0].pwszName                = NULL;
    (*prgInfo)[0].pTypeInfo               = NULL;
    (*prgInfo)[0].iOrdinal                = 0;
    (*prgInfo)[0].ulColumnSize            = sizeof(ULONG);
    (*prgInfo)[0].wType                   = DBTYPE_UI4;
    (*prgInfo)[0].bPrecision              = 10;
    (*prgInfo)[0].bScale                  = (BYTE) ~ 0;
    (*prgInfo)[0].columnid.eKind          = DBKIND_GUID_PROPID;
    (*prgInfo)[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
    (*prgInfo)[0].columnid.uName.ulPropid = 2;
    (*prgInfo)[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK |
                                            DBCOLUMNFLAGS_ISFIXEDLENGTH;
    //
    // Fill up the ADsPath column
    //
    (*prgInfo)[1].pwszName                = *ppStringBuffer;
    (*prgInfo)[1].pTypeInfo               = NULL;
    (*prgInfo)[1].iOrdinal                = 1;
    (*prgInfo)[1].ulColumnSize            = (ULONG)256;
    (*prgInfo)[1].wType                   = DBTYPE_WSTR|DBTYPE_BYREF;
    (*prgInfo)[1].bPrecision              = (BYTE) ~ 0;
    (*prgInfo)[1].bScale                  = (BYTE) ~ 0;
    (*prgInfo)[1].columnid.eKind          = DBKIND_NAME;
    (*prgInfo)[1].columnid.uName.pwszName = *ppStringBuffer;
    (*prgInfo)[1].columnid.uGuid.guid     = GUID_NULL;
    (*prgInfo)[1].dwFlags                 = DBCOLUMNFLAGS_ISNULLABLE;

    RRETURN( S_OK );
}

#if (!defined(BUILD_FOR_NT40))
//IBindResource::Bind
//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CSessionObject
//
//  Synopsis: Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    09-17-1998   mgorti     Created.
//
//----------------------------------------------------------------------------
HRESULT CSessionObject::Bind(
    IUnknown *              punkOuter,
    LPCOLESTR               pwszURL,
    DBBINDURLFLAG           dwBindFlags,
    REFGUID                 rguid,
    REFIID                  riid,
    IAuthenticate *         pAuthenticate,
    DBIMPLICITSESSION *     pImplSession,
    DWORD *                 pdwBindStatus,
    IUnknown **             ppUnk
    )
{
    HRESULT         hr = S_OK;
    CComBSTR        bstrNewURL;

	TRYBLOCK
    
		//Initialize return arguments
        if (pdwBindStatus)
            *pdwBindStatus = 0;

        if (ppUnk)
            *ppUnk = NULL;

        if (pImplSession)
            pImplSession->pSession = NULL;

        //if caller passed a null value for dwBindFlags,
        //get them from initialization properties.
        if (dwBindFlags == 0)
            dwBindFlags = BindFlagsFromDbProps();

        //Generic argument validation
        hr = ValidateBindArgs(punkOuter,
                pwszURL,
                dwBindFlags,
                rguid,
                riid,
                pAuthenticate,
                pImplSession,
                pdwBindStatus,
                ppUnk);

        BAIL_ON_FAILURE(hr);

        //Fill in the pImplSession struct.
        if (pImplSession)
        {
            // Our session doesn't support aggregation.
            if (pImplSession->pUnkOuter != NULL)
                BAIL_ON_FAILURE(hr = DB_E_NOAGGREGATION);

            hr = QueryInterface(*pImplSession->piid,
                                (void**)&(pImplSession->pSession));
            if (FAILED(hr))
                BAIL_ON_FAILURE(hr = E_NOINTERFACE );
        }

        //Specific validation checks
        //We are currently a read-only provider
        if (dwBindFlags & DBBINDURLFLAG_WRITE)
            BAIL_ON_FAILURE(hr = DB_E_READONLY);

        //We currently don't support aggregation
        if (punkOuter != NULL)
            BAIL_ON_FAILURE (hr = DB_E_NOAGGREGATION);

        //We don't support the following flags
        if (dwBindFlags & DBBINDURLFLAG_ASYNCHRONOUS)
            BAIL_ON_FAILURE(hr = DB_E_ASYNCNOTSUPPORTED);

        if (dwBindFlags & DBBINDURLFLAG_OUTPUT              ||
            dwBindFlags & DBBINDURLFLAG_RECURSIVE           ||
            dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM    ||
            dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS)
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        //Now Try to Bind.
        if (InlineIsEqualGUID(rguid, DBGUID_ROW) ||
            InlineIsEqualGUID(rguid, DBGUID_ROWSET))
        {
            //If the URL is not absolute, build the absolute URL
            //using the DBPROP_INIT_PROVIDERSTRING.
            if (! bIsAbsoluteURL(pwszURL))
            {
                hr = BuildAbsoluteURL (pwszURL, bstrNewURL);
                if (FAILED(hr))
                    BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            else
                bstrNewURL = pwszURL;

            if ( InlineIsEqualGUID(rguid, DBGUID_ROW) )
            {
                hr = BindToRow(punkOuter,
                               (PWCHAR)bstrNewURL,
                               pAuthenticate,
                               dwBindFlags,
                               riid,
                               ppUnk);
            }
            else
            {
                hr = BindToRowset(punkOuter,
                                  (PWCHAR)bstrNewURL,
                                  pAuthenticate,
                                  dwBindFlags,
                                  riid,
                                  ppUnk);
            }

            BAIL_ON_FAILURE(hr);
        }
        else if (InlineIsEqualGUID(rguid, DBGUID_DSO))
        {
            ADsAssert(_pDSO);
            hr = BindToDataSource(
                            punkOuter,
                            pwszURL,
                            pAuthenticate,
                            dwBindFlags,
                            riid,
                            ppUnk
                    );
            BAIL_ON_FAILURE (hr);
        }
        else if (InlineIsEqualGUID(rguid, DBGUID_SESSION))
        {
            hr = QueryInterface(riid, (void**)ppUnk);
            BAIL_ON_FAILURE (hr);
        }
        else
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        //Fix for bug Raid-X5#83386 - spec change
        //If caller specified any DENY semantics,
        //set warning status and return value, since
        //we don't support these.
        if (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_READ ||
            dwBindFlags & DBBINDURLFLAG_SHARE_DENY_WRITE ||
            dwBindFlags & DBBINDURLFLAG_SHARE_EXCLUSIVE)
        {
            if (pdwBindStatus)
                *pdwBindStatus = DBBINDURLSTATUS_S_DENYNOTSUPPORTED;
            BAIL_ON_FAILURE (hr = DB_S_ERRORSOCCURRED);
        }
	
	CATCHBLOCKBAIL(hr)

error:

    RRETURN(hr);
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CSessionObject
//
//  Synopsis: Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CSessionObject::CSessionObject(
        LPUNKNOWN pUnkOuter
    )
{
    //
    // Initialize simple member vars
    //
    _pUnkOuter     = pUnkOuter ? pUnkOuter : (IGetDataSource FAR *)this;
    _cCommandsOpen = 0;
    _pUtilProp     = NULL;
    _pDSSearch     = NULL;
    _pIMalloc      = NULL;
    _pDSO          = NULL;

    ENLIST_TRACKING(CSessionObject);
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::~CSessionObject
//
//  Synopsis: Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CSessionObject::~CSessionObject( )
{
    //
    // Free properties management object
    //
    delete _pUtilProp;

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pDSO ) {
        _pDSO->DecrementOpenSessions();
        _pDSO->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::FInit
//
//  Synopsis:  Initialize the session Object
//
//  Arguments:
//
//  Returns:
//             TRUE              Initialization succeeded
//             FALSE             Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL CSessionObject::FInit(
        CDSOObject *   pDSO,
        CCredentials & Credentials
        )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(pDSO);
    ADsAssert(&Credentials);

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();
    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&Credentials);
    BAIL_ON_FAILURE(hr);

    //
    // IMalloc->Alloc is the way we have to allocate memory for out parameters
    //
    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    BAIL_ON_FAILURE(hr);

    //
    // Establish parent object pointer
    //
    _pDSO = pDSO;
    _Credentials = Credentials;
    _pDSO->AddRef();
    _pDSO->IncrementOpenSessions();

    return( TRUE );

error:

    RRETURN( FALSE );
}

STDMETHODIMP
CSessionObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IGetDataSource FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IGetDataSource) ) {
        *ppv = (IGetDataSource FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IOpenRowset) ) {
        *ppv = (IOpenRowset FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ISessionProperties) ) {
        *ppv = (ISessionProperties FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBCreateCommand) ) {
        *ppv = (IDBCreateCommand FAR *) this;
    }
#if (!defined(BUILD_FOR_NT40))
    else if( IsEqualIID(iid, IID_IBindResource) ) {
        *ppv = (IBindResource FAR *) this;
    }
#endif
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

#if (!defined(BUILD_FOR_NT40))
//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::ValidateBindArgs
//
//  Synopsis: Validates IBindResource::Bind function arguments.
//
//----------------------------------------------------------------------------
HRESULT CSessionObject::ValidateBindArgs(
    IUnknown *              punkOuter,
    LPCOLESTR               pwszURL,
    DBBINDURLFLAG           dwBindFlags,
    REFGUID                 rguid,
    REFIID                  riid,
    IAuthenticate *         pAuthenticate,
    DBIMPLICITSESSION *     pImplSession,
    DWORD *                 pdwBindStatus,
    IUnknown **             ppUnk
    )
{
    //General validation checks.
    if (pwszURL == NULL || InlineIsEqualGUID(rguid,GUID_NULL) ||
        InlineIsEqualGUID(riid, GUID_NULL) || ppUnk == NULL )
        RRETURN(E_INVALIDARG);

    if (pImplSession &&
        (pImplSession->pUnkOuter == NULL || pImplSession->piid == NULL))
        RRETURN(E_INVALIDARG);

    if (punkOuter && !InlineIsEqualGUID(riid, IID_IUnknown))
        RRETURN(DB_E_NOAGGREGATION);

    if (pImplSession && pImplSession->pUnkOuter &&
        pImplSession->piid &&
        !InlineIsEqualGUID(*pImplSession->piid, IID_IUnknown))
        RRETURN(DB_E_NOAGGREGATION);

    if (dwBindFlags & DBBINDURLFLAG_RECURSIVE)
    {
        //if DBBINDURLFLAG_RECURSIVE is set, at least one of the SHARE_DENY
        //flags must have been set.
        if (! ( (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_READ) ||
                (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_WRITE) ||
                (dwBindFlags & DBBINDURLFLAG_SHARE_EXCLUSIVE)
                )
                )
            RRETURN(E_INVALIDARG);
    }

    if (!(dwBindFlags & DBBINDURLFLAG_READ) &&
        !(dwBindFlags & DBBINDURLFLAG_WRITE) ) {
        // Must have either read or write access:
        RRETURN(E_INVALIDARG);
    }

    if (InlineIsEqualGUID(rguid, DBGUID_DSO) &&
        !((dwBindFlags & DBBINDURLFLAG_READ) ||
          (dwBindFlags & DBBINDURLFLAG_ASYNCHRONOUS) ||
          (dwBindFlags & DBBINDURLFLAG_WAITFORINIT)
         )
       )
       //if object type is DataSource, only the above flags are allowed
       RRETURN(E_INVALIDARG);

    if (InlineIsEqualGUID(rguid, DBGUID_SESSION) &&
        ! (dwBindFlags == DBBINDURLFLAG_READ))
        //if object type is Session, only DBBINDURLFLAG_READ is allowed
        RRETURN(E_INVALIDARG);

    if (InlineIsEqualGUID(rguid, DBGUID_ROWSET) &&
        ((dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||
         (dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)
        )
       )
       //if object type is Rowset, DELAYFETCHCOLUMNS and DELAYFETCHSTREAM
       //flags are disallowed.
       RRETURN ( E_INVALIDARG );

    if (InlineIsEqualGUID(rguid, DBGUID_STREAM) &&
        ((dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||
         (dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)
        )
       )
       //if object type is Stream, DELAYFETCHCOLUMNS and
       //DELAYFETCHSTREAM flags are disallowed.
       RRETURN(E_INVALIDARG);

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToRow
//
//  Synopsis: Given a URL, binds to that row object and returns the requested
//            interface.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToRow(
    IUnknown *punkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    CComObject<CRow>        *pRow = NULL;
    auto_rel<IUnknown>      pSession;
    auto_rel<IRow> pRowDelete;
    HRESULT hr = S_OK;

    hr = CComObject<CRow>::CreateInstance(&pRow);
    if (FAILED(hr))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    //To make sure we delete the row object in
    //case we encounter errors after this point.
    //Note: this version of auto_rel doesn't addref on assignment.
    pRowDelete = pRow;
    pRowDelete->AddRef();

    hr = QueryInterface(__uuidof(IUnknown), (void **)&pSession);
    if (FAILED(hr))
        BAIL_ON_FAILURE(hr = E_FAIL);

    //Initialize row and bind it to a Directory Object.
    hr = pRow->Initialize((PWSTR)pwszURL,
                    (IUnknown *)pSession,
                    pAuthenticate,
                    dwBindFlags,
                    FALSE, // not a tearoff 
                    FALSE, // don't get column info. from rowset 
                    &_Credentials,
                    true);

    if (FAILED(hr))
    {
        if (INVALID_CREDENTIALS_ERROR(hr))
        {
            BAIL_ON_FAILURE(hr = DB_SEC_E_PERMISSIONDENIED);
        }
        else
        {
            BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
        }
    }

    hr = pRow->QueryInterface(riid, (void**)ppUnk);
    if (FAILED(hr))
        BAIL_ON_FAILURE (hr = E_NOINTERFACE);

error:

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToRowset
//
//  Synopsis: Given a URL, binds to a rowset object that has all its child
//            nodes as rows and returns the requested interface on the rowset.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToRowset(
    IUnknown *pUnkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    HRESULT hr;
    DWORD fAuthFlags;

    DBID tableID;
    tableID.eKind = DBKIND_NAME;
    tableID.uName.pwszName = (LPWSTR) pwszURL;

    //Create the rowset.

    // Fix for 351040. First try explicit credentials, then session object's
    // credentials, then default credentials. 

    if(pAuthenticate)
    {
        CCredentials creds;

        hr = GetCredentialsFromIAuthenticate(pAuthenticate, creds);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        fAuthFlags = creds.GetAuthFlags();
        creds.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

        hr = OpenRowsetWithCredentials(pUnkOuter, &tableID, NULL, riid, 
                                       0, NULL, &creds, ppUnk); 
    }

    if( (!pAuthenticate) || (INVALID_CREDENTIALS_ERROR(hr)) )
    // try credentials in session object
        hr = OpenRowset(pUnkOuter, &tableID, NULL, riid, 0, NULL, ppUnk);

    if(INVALID_CREDENTIALS_ERROR(hr))
    // try default credentials
    {
        CCredentials creds; // default credentials

        fAuthFlags = creds.GetAuthFlags();
        creds.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

        hr = OpenRowsetWithCredentials(pUnkOuter, &tableID, NULL, riid,
                                       0, NULL, &creds, ppUnk); 
    }

    BAIL_ON_FAILURE(hr);

    RRETURN ( S_OK );

error:
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindFlagsFromDbProps
//
//  Synopsis: Synthesizes bind flags from initialization properties
//            DBPROP_INIT_MODE and DBPROP_INIT_BINDFLAGS
//
//----------------------------------------------------------------------------
DWORD CSessionObject::BindFlagsFromDbProps()
{
    HRESULT hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    ULONG   i, j, cPropertySets = 0;
    DWORD dwMode = 0, dwBindFlags = 0, dwBindFlagProp = 0;
    DWORD dwResult = 0;

    hr = GetDataSource(__uuidof(IDBProperties), (IUnknown **)&pDBProp);
    BAIL_ON_FAILURE(hr);

    DBPROPID  propids[2];
    propids[0] = DBPROP_INIT_MODE;
    propids[1] = DBPROP_INIT_BINDFLAGS;

    DBPROPIDSET rgPropertyIDSets[1];
    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 2;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    DBPROPSET *prgPropertySets;
    hr = pDBProp->GetProperties(
                            1,
                            rgPropertyIDSets,
                            &cPropertySets,
                            &prgPropertySets);

    if (hr == DB_E_ERRORSOCCURRED)
        BAIL_ON_FAILURE(hr);

    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &prgPropertySets[i].rgProperties[j];
            ADsAssert(pProp);
            if (pProp->dwStatus == S_OK &&
                pProp->dwPropertyID == DBPROP_INIT_MODE)
                dwMode = V_I4(&pProp->vValue);
            else if (pProp->dwStatus == S_OK &&
                    pProp->dwPropertyID == DBPROP_INIT_BINDFLAGS)
                dwBindFlagProp = V_I4(&pProp->vValue);
            else
                continue;
        }
    }

    //Now extract bind flags from dwMode and dwBindFlagProp
    {
        DWORD dwModeMask      =
                DB_MODE_READ |
                DB_MODE_WRITE |
                DB_MODE_READWRITE |
                DB_MODE_SHARE_DENY_READ |
                DB_MODE_SHARE_DENY_WRITE |
                DB_MODE_SHARE_EXCLUSIVE |
                DB_MODE_SHARE_DENY_NONE;

        dwResult |= dwMode & dwModeMask;

        if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHCOLUMNS ) {
            dwBindFlags |= DBBINDURLFLAG_DELAYFETCHCOLUMNS;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHSTREAM ) {
            dwBindFlags |= DBBINDURLFLAG_DELAYFETCHSTREAM;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_RECURSIVE ) {
            dwBindFlags |= DBBINDURLFLAG_RECURSIVE;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_OUTPUT ) {
            dwBindFlags |= DBBINDURLFLAG_OUTPUT;
        }

        dwResult |= dwBindFlagProp | dwBindFlags;
    }

error:
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);
            FreeDBID(&pProp->colid);
            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN ( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToDataSource
//
//  Synopsis: Initializes the DataSource object if necessary, Sets
//            DBPROP_INIT_PROVIDERSTRING property and returns the requested
//            interface on the datasource.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToDataSource(
    IUnknown *pUnkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    HRESULT                 hr = S_OK;
    auto_rel<IDBProperties> pDBProperties;
    DBPROP                  props[1];
    DBPROPSET               rgPropertySets[1];
    CComBSTR                bstrURL(pwszURL);

    //Initialize DBPROP_INIT_PROVIDERSTRING only if the
    //URL is absolute.
    if (bIsAbsoluteURL (pwszURL))
    {
        // Check if the datasource has already been initialized.
        if (_pDSO->IsInitialized())
            BAIL_ON_FAILURE(hr = DB_E_ALREADYINITIALIZED);
            
        props[0].dwPropertyID = DBPROP_INIT_PROVIDERSTRING;
        props[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
        props[0].vValue.vt = VT_BSTR;
        props[0].vValue.bstrVal = (PWCHAR)bstrURL;

        rgPropertySets[0].rgProperties = props;
        rgPropertySets[0].cProperties = 1;
        rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

        hr = GetDataSource(
                __uuidof(IDBProperties),
                (IUnknown **)&pDBProperties
        );
        BAIL_ON_FAILURE(hr);

        hr = pDBProperties->SetProperties(1, rgPropertySets);
        BAIL_ON_FAILURE(hr);
    }
    //  If consumer doesn't specify DBBINDURLFLAG_WAITFORINIT, it
    //  means consumer wants an initialized DSO
    //
    if (! (dwBindFlags & DBBINDURLFLAG_WAITFORINIT))
    {
        auto_rel<IDBInitialize> pDBInitialize;

        hr = GetDataSource(__uuidof(IDBInitialize), (IUnknown **)&pDBInitialize);
        BAIL_ON_FAILURE(hr);

        hr = pDBInitialize->Initialize();
        BAIL_ON_FAILURE(hr);
    }

    //Return the requested interface on the DSO.
    hr = GetDataSource(riid, ppUnk);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BuildAbsoluteURL
//
//  Synopsis: Given a relative URL, builds absolute URL using the relative URL
//            and the property DBPROP_INIT_PROVIDERSTRING.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BuildAbsoluteURL(
    CComBSTR       bstrLeaf,
    CComBSTR&      bstrAbsoluteURL
    )
{
    HRESULT                 hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    auto_rel<IADsPathname>  pPathParent;
    auto_rel<IADsPathname>  pPathLeaf;
    ULONG                   cPropertySets = 0;
    long                    i, j, cElements = 0;
    CComBSTR                bstrParent;
    DBPROPSET*              prgPropertySets = NULL;
    DBPROPID                propids[1];
    DBPROPIDSET             rgPropertyIDSets[1];

    hr = GetDataSource(__uuidof(IDBProperties), (IUnknown **)&pDBProp);
    BAIL_ON_FAILURE(hr);

    propids[0] = DBPROP_INIT_PROVIDERSTRING;

    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 1;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    hr = pDBProp->GetProperties(
                            1,
                            rgPropertyIDSets,
                            &cPropertySets,
                            &prgPropertySets);

    if (SUCCEEDED(hr) && cPropertySets == 1)
    {
        ADsAssert(prgPropertySets != NULL);
        ADsAssert(prgPropertySets[0].rgProperties != NULL);

        DBPROP* pProp = & (prgPropertySets[0].rgProperties[0]);

        bstrParent = pProp->vValue.bstrVal;
    }

    // Build Absolute Path from Parent and leaf.

    hr = CPathname::CreatePathname(
            __uuidof(IADsPathname),
            (void **)&pPathParent
            );
    BAIL_ON_FAILURE(hr);

    hr = pPathParent->Set(bstrParent, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    if (bstrLeaf.Length() > 0)
    {
        hr = CPathname::CreatePathname(
                __uuidof(IADsPathname),
                (void **)&pPathLeaf
                );
        BAIL_ON_FAILURE(hr);

        hr = pPathLeaf->Set(bstrLeaf, ADS_SETTYPE_DN);
        BAIL_ON_FAILURE(hr);

        hr = pPathLeaf->GetNumElements(&cElements);
        BAIL_ON_FAILURE(hr);

        //Add leaf elements in reverse order.
        //Ex: if bstrLeaf = "CN=Administrator,CN=Users",
        //we add CN=Users first.
        for (i = cElements-1; i >= 0; i--)
        {
            CComBSTR bstrElement;
            hr = pPathLeaf->GetElement(i, &bstrElement);
            BAIL_ON_FAILURE(hr);

            hr = pPathParent->AddLeafElement(bstrElement);
            BAIL_ON_FAILURE(hr);
        }
    }
    //Read back the fully built path name
    hr = pPathParent->Retrieve(ADS_FORMAT_X500, &bstrAbsoluteURL);
    BAIL_ON_FAILURE(hr);

error:
    // Free memory allocated by GetProperties
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN(hr);
}

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::bIsAbsoluteURL
//
//  Synopsis: If the given URL starts with any of the ADS provider prefixes,
//            returns true. Returns false otherwise.
//
//----------------------------------------------------------------------------
bool
CSessionObject::bIsAbsoluteURL( LPCOLESTR pwszURL)
{
    if (pwszURL == NULL)
        return false;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    for (PROUTER_ENTRY pProvider = g_pRouterHead;
         pProvider != NULL;
         pProvider = pProvider->pNext)
    {
        if (pProvider->szProviderProgId == NULL)
            continue;

        size_t strSize = wcslen(pProvider->szProviderProgId);
        
        if ( _wcsnicmp(pwszURL, pProvider->szProviderProgId, strSize) == 0 )
            return true;
    }

    // Given URL doesn't start with any of the ADSI provider prefixes.
    return false;
}

#endif

//-----------------------------------------------------------------------------
// SetSearchPrefs
//
// Sets ADSI search preferences on the property object.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::SetSearchPrefs(
        void
        )
{
    PROPSET              *pPropSet;
    PADS_SEARCHPREF_INFO  pSearchPref = NULL;
    HRESULT               hr = S_OK;
    ULONG                 i;

    //
    // Asserts
    //
    ADsAssert(_pUtilProp);
    ADsAssert(_pDSSearch);

    pPropSet = _pUtilProp->GetPropSetFromGuid(DBPROPSET_ADSISEARCH);

    if( !pPropSet || !pPropSet->cProperties )
        RRETURN( S_OK );

    pSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem(
                                                 pPropSet->cProperties *
                                                 sizeof(ADS_SEARCHPREF_INFO)
                                                 );
    if( !pSearchPref )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    for (i=0; i<pPropSet->cProperties; i++) {
        hr = _pUtilProp->GetSearchPrefInfo(
                             pPropSet->pUPropInfo[i].dwPropertyID,
                             &pSearchPref[i]
                                                         );
        BAIL_ON_FAILURE( hr );
    }

    hr = _pDSSearch->SetSearchPreference(
                                pSearchPref,
                                pPropSet->cProperties
                                );

    _pUtilProp->FreeSearchPrefInfo(pSearchPref, pPropSet->cProperties);

    BAIL_ON_FAILURE( hr );

error:

    if( pSearchPref )
        FreeADsMem(pSearchPref);

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cseccf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:  cseccf.cxx
//
//  Contents:  ADs Security Object class factory
//
//             CADsSecurityCF::CreateInstance
//
//  History:   11-04-2000     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsSecurityUtilityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtilityCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid, LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    if (!ppv) {
        RRETURN(E_INVALIDARG);
    }

    hr = CADsSecurityUtility::CreateADsSecurityUtility(
             iid,
             ppv
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\crsinfo.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CRSInfo.cxx
//
//  Contents:   IRowsetInfo and IGetRow methods 
//
//  Functions:
//
//  Notes:
//
//
//  History:    08/30/96  | RenatoB   | Created
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// @class CRowsetInfo | embedding of Rowset,
//  to give our IrowsetInfo interface
//
//
//-----------------------------------------------------------------------------
// Includes
#include "oleds.hxx"
#include "atl.h"
#include "row.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::QueryInterface
//
//  Synopsis:  @mfunc QueryInterface.
//
//  Update: This function should never be called as RowsetInfo is now contained
//  in CRowset.
//
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::QueryInterface(
        REFIID   riid,
        LPVOID * ppv
        )
{
    ADsAssert(FALSE);

    RRETURN( E_INVALIDARG );
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::CRowsetInfo
//
//  Synopsis:  @mfunc Ctor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
CRowsetInfo::CRowsetInfo(
        IUnknown *       pUnkOuter,      // controlling unknown)
        IUnknown *       pParentObject,  // RowProvider
        CSessionObject * pCSession,      // Session that created rowset
        CCommandObject * pCCommand,      // Command object that created rowset
        CRowProvider *   pRowProvider    // Row provider pointer
   )
{
    //
    // Asserts
    //
    ADsAssert(pRowProvider);

    _pUnkOuter     = (pUnkOuter == NULL) ? (IRowsetInfo FAR *)this : pUnkOuter;
    _pRowset       = NULL;
    _pParentObject = pParentObject;
    _pCSession     = pCSession;
    _pCCommand     = pCCommand;

    // AddRef twice - once for command/session object, once for parent object
    if( NULL == _pCCommand )
    {
        _pCSession->AddRef();
        _pCSession->AddRef();
    }
    else if( NULL == _pCSession )
    {
        _pCCommand->AddRef();
        _pCCommand->AddRef();
    }
    else // shouldn't get here
        ADsAssert(FALSE);

    _pRowProvider  = pRowProvider;
    _pRowProvider->AddRef();

    _pMalloc       = NULL;

    if( _pCCommand != NULL )
        _pCCommand->IncrementOpenRowsets();

    //this section is for IRowsetInfo and IUnknown methods.

    InitializeCriticalSection(&_csRowsetInfo);
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::~CRowsetInfo
//
//  Synopsis:  @mfunc Dtor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
CRowsetInfo::~CRowsetInfo()
{
    if( _pMalloc != NULL )
        _pMalloc->Release();

    if( _pCCommand != NULL ) {
        _pCCommand->DecrementOpenRowsets();
        _pCCommand->Release();
    }

    if( _pCSession != NULL ) {
        _pCSession->Release();
        }

    if( _pParentObject != NULL ) {
        _pParentObject->Release();
        }

    if( _pRowProvider != NULL ) {
        _pRowProvider->Release();
        }

    DeleteCriticalSection(&_csRowsetInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::FInit
//
//  Synopsis:  @mfunc Initializer
//
//  Synopsis:  @mfunc Initializer
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//    @flag S_OK              | Interface is supported
//        @flag E_OUTOFMEMORY | Not enough memory 
//        @flag E_INVALIDARG  | One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::FInit(
        IUnknown * pRowset)          // rowset interface
{
    HRESULT hr;
    hr = S_OK;

    if( FAILED(CoGetMalloc(MEMCTX_TASK, &_pMalloc)) )
        RRETURN( E_OUTOFMEMORY );

    // Should not AddRef here because RowsetInfo is contained in CRowset
    _pRowset = pRowset;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetReferencedRowset
//
//  Synopsis:  @mfunc Returns an interface pointer to the rowset to which a bookmark applies
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     iOrdinal          [in]  Bookmark column for which to get related rowset. Must be 0 in this impl.
//     riid              [in] IID of the interface pointer to return in *ppReferencedRowset.
//     ppReferencedRowset[out] pointer to  Rowset object referenced by Bookmark
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppReferencedRowset was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Rowset does not support interface
//        DB_E_NOTAREFENCEDCOLUMN | iOrdinal was not 0
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetReferencedRowset(
    DBORDINAL   iOrdinal,
    REFIID      riid,
    IUnknown ** ppReferencedRowset
    )
{
    CAutoBlock cab (&_csRowsetInfo);

    //
    // Asserts
    //
    ADsAssert(_pRowProvider);
    ADsAssert(_pRowset);

    if( ppReferencedRowset == NULL )
        RRETURN( E_INVALIDARG );

    *ppReferencedRowset = NULL;

    if( iOrdinal >= _pRowProvider->GetColumnCount() )
        RRETURN( DB_E_BADORDINAL );

    if( iOrdinal != 0 )
        RRETURN( DB_E_NOTAREFERENCECOLUMN );

    RRETURN(_pRowset->QueryInterface(
                 riid,
                 (void**)ppReferencedRowset)
           );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetSpecificaton
//
//  Synopsis:  @mfunc Returns an interface pointer to the command that created the rowset
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     riid              [in] IID of the interface pointer to return in *ppSpecification.
//     ppSpecification [out] pointer to  command
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppSpecification was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Command does not support interface
//      S_FALSE                   | Rowset does not have command that created it
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetSpecification(
    REFIID      riid,
    IUnknown ** ppSpecification
    )
{
    CAutoBlock cab(&_csRowsetInfo);

    if( ppSpecification == NULL )
        RRETURN( E_INVALIDARG );

    *ppSpecification = NULL;

    if( _pParentObject == NULL )
        RRETURN( S_FALSE );

    RRETURN( _pParentObject->QueryInterface(riid, (void**)ppSpecification) );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetProperties
//
//  Synopsis:  @mfunc GetProperties
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//    cPropertyIDSets[in]    The number of DBPROPIDSET structures in rgProperttySets
//    rgPropertyIDSets[in]   Array of cPropertyIDSets of DBPROIDSET structs.
//    pcPropertySets[out]    number of DBPROPSET returned in *prgPropertySets
//    prgPropertySets[out]   pointer to array of DBPROPSET structures, having the
//                           value and status of requested properties
//
//  Returns:   @rdesc HRESULT
//  S_OK                Success
//  DB_S_ERRORSOCCURRED Values were not supported for some properties
//  E_FAIL              A provider-specific error occurred
//  E_INVALIDARG        cPropertyIDSets > 0 and rgPropertyIdSEts = NULL
//                      pcPropertySets or prgPropertySets was NULL pointer
//                      In al element of rgPropertyIDSets, cPropertyIDs was not zero
//                      and rgPropertyIDs was a Null pointer
//  E_OUTOFMEMORY       Provider could not allocate memory
//  DB_E_ERRORSOCCURRED Values were not returned for any properties
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::GetProperties(
    const ULONG       cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG *           pcPropertySets,
    DBPROPSET **      prgPropertySets
    )
{
    // should never get here because this call is handled by CRowset
    ADsAssert(FALSE);

    RRETURN( E_FAIL );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetRowFromHROW
//
//  Synopsis:  @mfunc Returns an interface pointer to a row in the rowset.
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     IUnknown             *pUnkOuter              Outer unknown.
//     HROW                 hRow                    Handle to row.
//     REFIID               riid,                   Interface requested.
//     [out]IUnknown        **ppUnk                 returned interface
//
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetRowFromHROW(
    IUnknown  *pUnkOuter,
    HROW hRow,
    REFIID riid,
    IUnknown  * *ppUnk,
    BOOL fIsTearOff,
    BOOL fAllAttrs
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    CAutoBlock cab(&_csRowsetInfo);
    auto_tm<WCHAR> lpwszURL;
    auto_rel<IGetDataSource>   pGetDataSource;
    auto_rel<ICommand> pCommand;
    auto_rel<IRowset> pRowset;
    auto_rel<IRowset> pRealRowset;
    CComObject<CRow>  *pRow = NULL;
    auto_rel<IRow>    pRowDelete;
    CCredentials      creds;
    CCredentials      *pCreds;
    PWSTR pwszUserID = NULL, pwszPassword = NULL;

    //Initialize return arguments
    if (ppUnk)
        *ppUnk = NULL;

    //We currently don't support aggregation.
    if (pUnkOuter != NULL)
        RRETURN(DB_E_NOAGGREGATION);

    if (ppUnk == NULL)
        RRETURN(E_INVALIDARG);

    if ( _pParentObject == NULL)
        RRETURN(S_FALSE);

    TRYBLOCK
        PWSTR pURL;
        ADsAssert(_pRowset != NULL);
        hr = _pRowset->QueryInterface(__uuidof(IRowset), (void **)&pRealRowset);
        BAIL_ON_FAILURE(hr);
        hr =  _pRowProvider->GetURLFromHROW( hRow,&pURL, pRealRowset);
        BAIL_ON_FAILURE(hr);

        //assign returned ptr to auto_tm class for auto deletion.
        lpwszURL = pURL;

        *ppUnk = NULL;

        //
        // Get the session and QI for any mandatory interface -
        // we query for IGetDataSource.
        //
        hr = _pParentObject->QueryInterface(
                IID_IGetDataSource,
                (void**)&pGetDataSource);

        if (FAILED(hr))
        {
            hr = _pParentObject->QueryInterface(
                    IID_ICommand,
                    (void**)&pCommand);
            BAIL_ON_FAILURE(hr);

            hr = pCommand->GetDBSession (
                    IID_IGetDataSource,
                    (LPUNKNOWN *)&pGetDataSource);
            BAIL_ON_FAILURE(hr);
        }

        //Get user id and password properties for authentication
        //If the RowProvider has cached special credentials, we use them,
        //Otherwise we use the DBPROP_AUTH_USERID and DBPROP_AUTH_PASSWORD
        //properties in the originating DataSource object.
        if ((pCreds = _pRowProvider->GetCredentials()) == NULL)
        {
            hr = GetCredentials(pGetDataSource, creds);
            BAIL_ON_FAILURE(hr);
            pCreds = &creds;
        }

        hr = pCreds->GetUserName(&pwszUserID);
        BAIL_ON_FAILURE(hr);
        hr = pCreds->GetPassword(&pwszPassword);
        BAIL_ON_FAILURE(hr);

        //Instantiate a row object.
        hr = CComObject<CRow>::CreateInstance(&pRow);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //To make sure we delete the row object in case
        //we encounter errors after this point.
        pRow->AddRef();
        pRowDelete = pRow;

        //Initialize the row object.
        hr = pRow->Initialize(  lpwszURL,
                (IUnknown *)pGetDataSource,
                (IUnknown *)_pRowset,
                hRow,
                pwszUserID,
                pwszPassword,
                DBBINDURLFLAG_READ, //we are currently a read-only provider.
                fIsTearOff, // see comment at beginning of row.cxx
                !fAllAttrs, // see comment at beginning of row.cxx
                _pRowProvider
                );

        if (FAILED(hr))
        {
            if (INVALID_CREDENTIALS_ERROR(hr))
            {
                BAIL_ON_FAILURE(hr = DB_SEC_E_PERMISSIONDENIED);
            }
            else if (hr == E_NOINTERFACE)
            {
                BAIL_ON_FAILURE(hr);
            }
            else
            {
                BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
            }
        }

        //Get the requested interface on the Row.
        hr = pRow->QueryInterface(riid, (void**)ppUnk);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_NOINTERFACE);

    CATCHBLOCKBAIL(hr)

    if (pwszUserID)
        FreeADsStr(pwszUserID);
    if (pwszPassword)
        FreeADsStr(pwszPassword);

    RRETURN(S_OK);

error:
    if (pwszUserID)
        FreeADsStr(pwszUserID);
    if (pwszPassword)
        FreeADsStr(pwszPassword);

    RRETURN(hr);

#else
    RRETURN(E_FAIL);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetURLFromHROW
//
//  Synopsis:  @mfunc Returns an interface pointer to a row in the rowset.
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//         HROW                 hRow                    Handle to row.
//         LPOLESTR             ppwszURL,               URL name for the row.
//
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetURLFromHROW(
    HROW hRow,
    LPOLESTR  *ppwszURL
    )
{
#if (!defined(BUILD_FOR_NT40))
    CAutoBlock         cab(&_csRowsetInfo);
    LPWSTR             lpwszURL = NULL;
    auto_rel<IRowset>  pRealRowset;
    HRESULT            hr = S_OK;

    if (ppwszURL == NULL)
        RRETURN(E_INVALIDARG);

    ADsAssert(_pRowset != NULL);
    hr = _pRowset->QueryInterface(__uuidof(IRowset), (void **)&pRealRowset);
    BAIL_ON_FAILURE(hr);

    // Call row provider to get the URL.
    hr = _pRowProvider->GetURLFromHROW( hRow,ppwszURL, pRealRowset);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif
};



//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetCredentials
//
//  Synopsis:  @mfunc Gets credentials stored in INIT properties.
//
//  Arguments:
//        pSession              [in] IGetDataSource interface ptr on Session.
//        refCredentials        [in] CCredentials containing user id and password.
//
//  Returns: HRESULT
//
//----------------------------------------------------------------------------
HRESULT CRowsetInfo::GetCredentials(
    IGetDataSource *pSession,
    CCredentials &refCredentials
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    ULONG   i, j, cPropertySets = 0;

    Assert(pSession);

    hr = pSession->GetDataSource(
            __uuidof(IDBProperties),
            (IUnknown **)&pDBProp);

    BAIL_ON_FAILURE(hr);

    DBPROPID        propids[2];
    propids[0] = DBPROP_AUTH_USERID;
    propids[1] = DBPROP_AUTH_PASSWORD;

    DBPROPIDSET rgPropertyIDSets[1];
    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 2;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    DBPROPSET *prgPropertySets;

    hr = pDBProp->GetProperties(
            1,
            rgPropertyIDSets,
            &cPropertySets,
            &prgPropertySets);

    if (hr == DB_E_ERRORSOCCURRED)
            BAIL_ON_FAILURE(hr);

    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &prgPropertySets[i].rgProperties[j];
            Assert(pProp);
            if (pProp->dwStatus == S_OK &&
                pProp->dwPropertyID == DBPROP_AUTH_USERID)
                refCredentials.SetUserName(V_BSTR(&pProp->vValue));
            else if (pProp->dwStatus == S_OK &&
                     pProp->dwPropertyID == DBPROP_AUTH_PASSWORD)
                refCredentials.SetPassword(V_BSTR(&pProp->vValue));
            else
                continue;
        }
    }

error:
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            Assert(pProp);
            FreeDBID(&pProp->colid);
            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN ( hr );
#else
    RRETURN(E_FAIL);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\csedcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsSecurityDescriptorCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityDescriptorCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CSecurityDescriptor::CreateSecurityDescriptor(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cstream.h ===
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Memory stream implementations for DS OLE DB PROVIDER
//
// copied from cdopt\src\cdo\mystream.* and modified.

class ATL_NO_VTABLE CStreamMem :
	INHERIT_TRACKING,
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStream,
	public IGetSourceRow
{
public: 

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CStreamMem)
	COM_INTERFACE_ENTRY(IStream)
	COM_INTERFACE_ENTRY(ISequentialStream)
	COM_INTERFACE_ENTRY(IGetSourceRow)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		RRETURN( CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p));
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

private:
    	auto_cs m_cs;		// critical section
        ULONG   m_cbSeek;
        STATSTG m_statstg;

		CComVariant		m_pVar;
		auto_rel<IRow>	m_pSourceRow;
		HROW			m_hRow;
        PVOID			m_pvData;
        DWORD			m_cbBufferSize;
		bool			m_fExternalData;

    public:
        CStreamMem(void);
        ~CStreamMem(void);

		//internal methods
		HRESULT Initialize(VARIANT *pVar, IRow* pSourceRow, HROW hRow);

        // IStream
        STDMETHODIMP Read(
            void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);
        
        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);
        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
        
        STDMETHODIMP Revert( void);
        
        STDMETHODIMP LockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP UnlockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP Stat( 
            STATSTG __RPC_FAR *pstatstg,
            DWORD grfStatFlag);
        
        STDMETHODIMP Clone( 
            IStream __RPC_FAR *__RPC_FAR *ppstm);

		//IGetSourceRow
		STDMETHODIMP GetSourceRow(REFIID riid, IUnknown **ppRow);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cstream.cxx ===
#include "oleds.hxx"
#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#include "cstream.h"

/* -------------------------------------------------------------------------
CStreamMem
------------------------------------------------------------------------- */
//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::CStreamMem (constructor)
//
//  Synopsis: constructs a CStreamMem object
//  
//----------------------------------------------------------------------------
CStreamMem::CStreamMem(void)
{
	m_pvData = NULL;
	m_cbBufferSize= 0;
	m_cbSeek = 0;
	memset(&m_statstg,0,sizeof(STATSTG));

	m_statstg.type = STGTY_STREAM;

    GetSystemTimeAsFileTime(&m_statstg.ctime);

	m_hRow = DB_NULL_HROW;
	m_fExternalData = true;
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::~CStreamMem (destructor)
//
//  Synopsis: destructs a CStreamMem object
//  
//----------------------------------------------------------------------------
CStreamMem::~CStreamMem(void)
{
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Initialize
//
//  Synopsis: Initializes a CStreamMem object
//
//  Parameters: pVar	Variant of type VT_UI1 | VT_ARRAY containing the bytes
//              IRow *  pointer to IRow interface
//              HROW	handle to the row that is creating this stream
//
//  Returns:    HRESULT
//  
//----------------------------------------------------------------------------
HRESULT CStreamMem::Initialize(VARIANT *pVar, IRow* pSourceRow, HROW hRow)
{
	ADsAssert (pVar && pSourceRow);

	//ADSI uses VT_ARRAY|VT_UI1 for binary data. Make sure we have proper type.
	ADsAssert(V_VT(pVar) == (VT_ARRAY | VT_UI1)); 
	
	HRESULT hr = NOERROR;
	auto_leave al(m_cs);

    SAFEARRAY *psa;
    UINT cDim;

	TRYBLOCK
		al.EnterCriticalSection();

		hr = m_pVar.Attach(pVar);
		BAIL_ON_FAILURE(hr);
	
		psa = V_ARRAY(pVar);
		cDim = SafeArrayGetDim(psa);
		if (cDim != 1)
			RRETURN(E_INVALIDARG);

		//Get bounds of safearray and determine size
		long lLBound, lUBound;
		hr = SafeArrayGetLBound(psa, cDim, &lLBound);
		BAIL_ON_FAILURE(hr);
		hr = SafeArrayGetUBound(psa, cDim, &lUBound);
		BAIL_ON_FAILURE(hr);
		
		m_cbBufferSize = lUBound - lLBound + 1;

		//Get a pointer to the actual byte data
		hr = SafeArrayAccessData(V_ARRAY(pVar), &m_pvData);
		BAIL_ON_FAILURE(hr);

		hr = SafeArrayUnaccessData(psa);
		BAIL_ON_FAILURE(hr);

		m_pSourceRow = pSourceRow;
		m_pSourceRow->AddRef();
		m_hRow = hRow;

		//Update stat structure
		m_statstg.cbSize.LowPart = m_cbBufferSize;
		GetSystemTimeAsFileTime(&m_statstg.mtime);
    CATCHBLOCKBAIL(hr)
	
	RRETURN(S_OK);

error:
	RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////////
// IStream
//

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Read
//
//  Synopsis: Reads specified number of bytes from stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Read(
	void __RPC_FAR *pv,
	ULONG cb,
	ULONG __RPC_FAR *pcbRead)
{
	if (pv == NULL)
		RRETURN(STG_E_INVALIDPOINTER);

	auto_leave al(m_cs);
	ULONG cbRead = 0;

	if( pcbRead != NULL )
		*pcbRead = 0;

	al.EnterCriticalSection();

	// anything to do?
	if( cb == 0 || 
		m_statstg.cbSize.LowPart == 0 || 
		m_cbSeek == m_statstg.cbSize.LowPart )
		RRETURN(NOERROR);

	// determine amount to copy
	cbRead = min(cb,m_statstg.cbSize.LowPart - m_cbSeek);

	if( cbRead > 0 )
	{
		// copy it
		CopyMemory(pv,(PBYTE)m_pvData + m_cbSeek,cbRead);

		// adjust seek pointer
		m_cbSeek += cbRead;
	}

	// update access time
    GetSystemTimeAsFileTime(&m_statstg.atime);

	if( pcbRead != NULL )
		*pcbRead = cbRead;

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Write
//
//  Synopsis: Writes specified number of bytes to stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Write( 
	const void __RPC_FAR *pv,
	ULONG cb,
	ULONG __RPC_FAR *pcbWritten)
{
	//DS OLE DB provider is currently read-only. 
	//It doesn't support writes on its streams.
	RRETURN(STG_E_ACCESSDENIED);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Seek
//
//  Synopsis: Sets the current read/write pointer to the given position.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Seek( 
	LARGE_INTEGER dlibMove,
	DWORD dwOrigin,
	ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	auto_leave al(m_cs);
	
	// can we handle the seek?
	if( dlibMove.HighPart != 0 )
		RRETURN(STG_E_WRITEFAULT);

	al.EnterCriticalSection();
	
	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			if( dlibMove.LowPart > m_statstg.cbSize.LowPart )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			if( dlibMove.LowPart + m_cbSeek > m_statstg.cbSize.LowPart )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			//We are read-only provider. Seeking past the end of stream
			//or prior to beginning of stream is not supported
			if ( int(dlibMove.LowPart) > 0 || 
				 (int(dlibMove.LowPart) + int(m_statstg.cbSize.LowPart)) < 0
			   )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::SetSize
//
//  Synopsis: Sets the size of the stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::SetSize( 
	ULARGE_INTEGER libNewSize)
{
	//DS OLE DB provider is currently read-only. 
	//It doesn't support writes on its streams.
	RRETURN(STG_E_ACCESSDENIED);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::CopyTo
//
//  Synopsis: Copies specified number of bytes from this stream to another.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::CopyTo( 
	IStream __RPC_FAR *pstm,
	ULARGE_INTEGER cb,
	ULARGE_INTEGER __RPC_FAR *pcbRead,
	ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	auto_leave al(m_cs);
	HRESULT hr = NOERROR;
	ULONG cbBytes = 0;
	ULONG cbWritten = 0;

	if( pstm == NULL )
		RRETURN(STG_E_INVALIDPOINTER);

	al.EnterCriticalSection();
	
	cbBytes = min(m_statstg.cbSize.LowPart - m_cbSeek,cb.LowPart);

	if( pcbRead )
		pcbRead->QuadPart = cbBytes;

	if( cbBytes == 0 )
		RRETURN(NOERROR);

	hr = pstm->Write((PBYTE)m_pvData + m_cbSeek,cbBytes,&cbWritten);
	if( pcbWritten )
		pcbWritten->QuadPart = cbWritten;
	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Commit
//
//  Synopsis: Makes changes to this stream permanent.
//            Note: This is a no-op since this stream is currently read-only.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Commit( 
	DWORD grfCommitFlags)
{
	RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Revert
//
//  Synopsis: Reverts changes to this stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Revert( void)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::LockRegion
//
//  Synopsis: Locks a specified number of bytes in the stream
//            starting from a given offset.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::LockRegion( 
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::UnlockRegion
//
//  Synopsis: Unlocks a specified number of bytes in the stream
//            starting from a given offset.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::UnlockRegion( 
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Stat
//
//  Synopsis: Gets information about the stream: size, modification time etc.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Stat( 
	STATSTG __RPC_FAR *pstatstg,
	DWORD grfStatFlag)
{
	auto_leave al(m_cs);

	if( !pstatstg )
		RRETURN(STG_E_INVALIDPOINTER);

	al.EnterCriticalSection();
	memcpy(pstatstg,&m_statstg,sizeof(STATSTG));
	al.LeaveCriticalSection();

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Clone
//
//  Synopsis: Creates a new stream object which references the same bytes
//            but with its own seek pointer.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Clone( 
	IStream __RPC_FAR *__RPC_FAR *ppstm)
{
	RRETURN(E_NOTIMPL);
}

///////////////////////////////////////////////////////////////////////////////
//IGetSourceRow
//

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::GetSourceRow
//
//  Synopsis: Gets the requested interface on the row object that originaly
//            created this stream. 
//
//  For more info see IGetSourceRow in OLE DB 2.5 documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::GetSourceRow(REFIID riid, IUnknown **ppRow)
{
	auto_leave al(m_cs);

	al.EnterCriticalSection();

	if (m_pSourceRow.get() == NULL)
	{
		*ppRow = NULL;
		RRETURN(DB_E_NOSOURCEOBJECT);
	}

	HRESULT hr = m_pSourceRow->QueryInterface(riid, (void **)ppRow);
	if (FAILED(hr))
		RRETURN(E_NOINTERFACE);

	RRETURN(S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cvalue.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPropertyValue.cxx
//
//  Contents:  PropertyValue object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CPropertyValue)


CPropertyValue::CPropertyValue():
        _pDispMgr(NULL),
        _dwDataType(0),
        _pDispatch(NULL)
{
    memset(&_ADsValue, 0, sizeof(ADSVALUE));

    ENLIST_TRACKING(CPropertyValue);
}

HRESULT
CPropertyValue::CreatePropertyValue(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyValue FAR * pPropertyValue = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyValueObject(&pPropertyValue);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyValue->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyValue->Release();

    RRETURN(hr);

error:
    delete pPropertyValue;

    RRETURN_EXP_IF_ERR(hr);

}



CPropertyValue::~CPropertyValue( )
{
    ClearData();

    delete _pDispMgr;
}

STDMETHODIMP
CPropertyValue::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyValue))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyValue2))
    {
        *ppv = (IADsPropertyValue2 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsValue))
    {
        *ppv = (IADsValue FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPropertyValue::AllocatePropertyValueObject(
    CPropertyValue ** ppPropertyValue
    )
{
    CPropertyValue FAR * pPropertyValue = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyValue = new CPropertyValue();
    if (pPropertyValue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyValue,
                (IADsPropertyValue *)pPropertyValue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyValue2,
                (IADsPropertyValue2 *)pPropertyValue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyValue->_pDispMgr = pDispMgr;
    *ppPropertyValue = pPropertyValue;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CPropertyValue::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsPropertyValue) ||
        IsEqualIID(riid, IID_IADsPropertyValue) ||
        IsEqualIID(riid, IID_IADsValue)) {
        return S_OK;
    } else {
        return S_FALSE;
    }

}


STDMETHODIMP
CPropertyValue::Clear(THIS_ )
{
    ClearData();
    RRETURN(S_OK);
}



STDMETHODIMP
CPropertyValue::get_ADsType(THIS_ long FAR * retval)
{
    *retval = _ADsValue.dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyValue::put_ADsType(THIS_ long lnADsType)
{
    _ADsValue.dwType  = (ADSTYPE)lnADsType;
    RRETURN(S_OK);
}



STDMETHODIMP
CPropertyValue::get_DNString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_DN_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.DNString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_DNString(THIS_ BSTR bstrDNString)
{
    ClearData();

    _ADsValue.DNString = AllocADsStr(bstrDNString);
    _ADsValue.dwType = ADSTYPE_DN_STRING;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_CaseExactString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_CASE_EXACT_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.CaseExactString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseExactString(THIS_ BSTR bstrCaseExactString)
{
    ClearData();

    _ADsValue.DNString = AllocADsStr(bstrCaseExactString);
    _ADsValue.dwType = ADSTYPE_CASE_EXACT_STRING;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_CaseIgnoreString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_CASE_IGNORE_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.CaseIgnoreString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseIgnoreString(THIS_ BSTR bstrCaseIgnoreString)
{
    ClearData();

    _ADsValue.DNString = AllocADsStr(bstrCaseIgnoreString);
    _ADsValue.dwType = ADSTYPE_CASE_IGNORE_STRING;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_PrintableString(THIS_ BSTR FAR * retval)
{

    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_PRINTABLE_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.PrintableString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_PrintableString(THIS_ BSTR bstrPrintableString)
{
    ClearData();

    _ADsValue.PrintableString = AllocADsStr(bstrPrintableString);
    _ADsValue.dwType = ADSTYPE_PRINTABLE_STRING;

    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyValue::get_NumericString(THIS_ BSTR FAR * retval)
{

    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_NUMERIC_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.NumericString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_NumericString(THIS_ BSTR bstrNumericString)
{
    ClearData();

    _ADsValue.DNString = AllocADsStr(bstrNumericString);
    _ADsValue.dwType = ADSTYPE_NUMERIC_STRING;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_OctetString(THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    if (_ADsValue.dwType != ADSTYPE_OCTET_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.OctetString.dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _ADsValue.OctetString.lpValue,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(retval) = VT_ARRAY | VT_UI1;
    V_ARRAY(retval) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_OctetString(THIS_ VARIANT VarOctetString)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT * pvVar = &VarOctetString;
    HRESULT hr = S_OK;

    ClearData();

    _ADsValue.dwType = ADSTYPE_OCTET_STRING;

    if ( VarOctetString.vt == (VT_ARRAY | VT_BYREF)) {
        pvVar = V_VARIANTREF(&VarOctetString);
    }
      
    if( pvVar->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pvVar),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pvVar),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _ADsValue.OctetString.lpValue = (LPBYTE)AllocADsMem(dwSUBound - dwSLBound + 1);

    if ( _ADsValue.OctetString.lpValue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.OctetString.dwLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pvVar),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _ADsValue.OctetString.lpValue,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pvVar) );

error:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::get_Integer(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_INTEGER) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *retval = _ADsValue.Boolean;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_Integer(THIS_ LONG lnInteger)
{
    ClearData();

    _ADsValue.Integer = lnInteger;
    _ADsValue.dwType = ADSTYPE_INTEGER;



    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_Boolean(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_BOOLEAN) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }


    *retval = _ADsValue.Boolean;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_Boolean(THIS_ LONG lnBoolean)
{
    ClearData();

    _ADsValue.Boolean = lnBoolean;
    _ADsValue.dwType = ADSTYPE_BOOLEAN;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_SecurityDescriptor(THIS_ IDispatch FAR * FAR * ppDispatch)
{

    HRESULT hr = E_ADS_CANT_CONVERT_DATATYPE;

    //
    // Check if we have a valid IDispatch at this point
    //

    if (_pDispatch) {
        switch (_dwDataType) {

        case VAL_IDISPATCH_SECDESC_ONLY :
        case VAL_IDISPATCH_SECDESC_ALL :

            hr = _pDispatch->QueryInterface(
                                IID_IDispatch,
                                (void **) ppDispatch
                                );
            break;

        default:

            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }
    }


    RRETURN(hr);

}



STDMETHODIMP
CPropertyValue::put_SecurityDescriptor(THIS_ IDispatch * pSecurityDescriptor)
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor *pIADsSecDes;
    IDispatch* pIDispatch;

    ClearData();

    _ADsValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    //
    // This qi ensures that this is a security descriptor
    //
    hr = pSecurityDescriptor->QueryInterface(
                                IID_IADsSecurityDescriptor,
                                (void **) &pIADsSecDes
                                );

    BAIL_ON_FAILURE(hr);

    pIADsSecDes->Release();
    pIADsSecDes = NULL;

    hr = pSecurityDescriptor->QueryInterface(
                                  IID_IDispatch,
                                  (void **) &pIDispatch
                                  );

    BAIL_ON_FAILURE(hr);

    _dwDataType = VAL_IDISPATCH_SECDESC_ONLY;

    _pDispatch = pIDispatch;

    RRETURN(hr);

error:

    if (pIADsSecDes) {
        pIADsSecDes->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::get_LargeInteger(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_LARGE_INTEGER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_LowPart(_ADsValue.LargeInteger.LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(_ADsValue.LargeInteger.HighPart);
   BAIL_ON_FAILURE(hr);

   pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_LargeInteger(THIS_ IDispatch FAR* lnLargeInteger)
{
   IADsLargeInteger *pLargeInteger = NULL;
   HRESULT hr = S_OK;
   LONG lnDataHigh = 0;
   LONG lnDataLow = 0;

    ClearData();
   hr = lnLargeInteger->QueryInterface(
                                     IID_IADsLargeInteger,
                                     (void **)&pLargeInteger
                                     );
   BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_HighPart(&lnDataHigh);
   BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_LowPart(&lnDataLow);
   BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_LARGE_INTEGER;
   _ADsValue.LargeInteger.HighPart = lnDataHigh;
   _ADsValue.LargeInteger.LowPart = lnDataLow;

error:
   if (pLargeInteger) {
        pLargeInteger->Release();
    }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::get_UTCTime(THIS_ DATE *retval)
{
   HRESULT hr = S_OK;
   int result = FALSE;

   if (_ADsValue.dwType != ADSTYPE_UTC_TIME) {
       RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }

   result = SystemTimeToVariantTime(&_ADsValue.UTCTime, retval);
   if (result != TRUE) {
        hr = E_FAIL;
   }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_UTCTime(THIS_ DATE DateInDate)
{
   HRESULT hr = S_OK;
   int result = FALSE;

   ClearData();

   _ADsValue.dwType = ADSTYPE_UTC_TIME;
   result = VariantTimeToSystemTime(DateInDate, &_ADsValue.UTCTime);
   if (result != TRUE) {
        hr = E_FAIL;
   }

   RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::ConvertADsValueToPropertyValue(THIS_ PADSVALUE pADsValue)
{
    HRESULT hr = S_OK;

    hr = ConvertADsValueToPropertyValue2(
             pADsValue,
             NULL,
             NULL,
             TRUE
             );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::ConvertADsValueToPropertyValue2(
            THIS_ PADSVALUE pADsValue,
            LPWSTR pszServerName,
            CCredentials* pCredentials,
            BOOL fNTDSType
            )
{
    HRESULT hr = S_OK;

    ClearData();

    hr = AdsCopyADsValueToPropObj(
             pADsValue,
             this,
             pszServerName,
             pCredentials,
             fNTDSType
             );

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPropertyValue::ConvertPropertyValueToADsValue(THIS_ PADSVALUE  pADsValue)
{

    return( ConvertPropertyValueToADsValue2(
                 pADsValue,
                 NULL,      // serverName
                 NULL,      // userName
                 NULL,      // userPassword
                 0,         // default flags.
                 TRUE       // flag NTDS
                 )
             );

}


//
// Handles all the parameters
//
STDMETHODIMP
CPropertyValue::ConvertPropertyValueToADsValue2(
                    THIS_ PADSVALUE  pADsValue,
                    LPWSTR pszServerName,
                    LPWSTR pszUserName,
                    LPWSTR pszPassWord,
                    LONG dwFlags,
                    BOOL fNTDSType
                    )
{

    HRESULT hr = S_OK;
    CCredentials Credentials( pszUserName, pszPassWord, dwFlags);

    hr = AdsCopyPropObjToADsValue(
             this,
             pADsValue,
             pszServerName,
             &Credentials,
             fNTDSType
             );

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPropertyValue::get_CaseIgnoreList(THIS_ IDispatch FAR * FAR *retval)
{
    HRESULT hr = S_OK;
    IADsCaseIgnoreList * pCaseIgnoreList = NULL;
    IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    DWORD cElements = 0;
    VARIANT VarDestObject;

    VariantInit( &VarDestObject );

    if (_ADsValue.dwType != ADSTYPE_CASEIGNORE_LIST) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pCaseIgnoreList) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
            CLSID_CaseIgnoreList,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsCaseIgnoreList,
            (void **) &pCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    pCurrent = _ADsValue.pCaseIgnoreList;
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_BSTR, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pCaseIgnoreList;
    for ( i = 0; i < (long)cElements; i++ ) {
        hr = ADsAllocString(
                pCurrent->String,
                &bstrAddress
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, bstrAddress );
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pCaseIgnoreList->put_CaseIgnoreList(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear( &VarDestObject );

    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseIgnoreList(THIS_ IDispatch FAR* pdCaseIgnoreList)
{
    IADsCaseIgnoreList *pCaseIgnoreList = NULL;
    HRESULT hr = S_OK;
    LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varCaseIgnoreList;
    VARIANT varBstrElement;

    ClearData();
    VariantInit(&varCaseIgnoreList);

    hr = pdCaseIgnoreList->QueryInterface(
                             IID_IADsCaseIgnoreList,
                             (void **)&pCaseIgnoreList
                             );
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_CASEIGNORE_LIST;

    hr = pCaseIgnoreList->get_CaseIgnoreList(&varCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varCaseIgnoreList) &  VT_VARIANT) &&  V_ISARRAY(&varCaseIgnoreList))) {
        return(E_FAIL);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    _ADsValue.pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!_ADsValue.pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pCaseIgnoreList;

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {

        VariantInit(&varBstrElement);
        hr = SafeArrayGetElement(V_ARRAY(&varCaseIgnoreList),
                                (long FAR *)&i,
                                &varBstrElement
                                );
        BAIL_ON_FAILURE(hr);

        pCurrent->String = AllocADsStr(V_BSTR(&varBstrElement));
        VariantClear(&varBstrElement);
        if (!pCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (i != (long)dwSUBound) {
            pCurrent->Next = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
    }
    pCurrent->Next = NULL;
    RRETURN(S_OK);

error:
    VariantClear(&varCaseIgnoreList);
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_FaxNumber(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsFaxNumber * pFaxNumber = NULL;
   IDispatch * pDispatch = NULL;
   VARIANT Var;

   if (_ADsValue.dwType != ADSTYPE_FAXNUMBER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pFaxNumber) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_FaxNumber,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsFaxNumber,
            (void **) &pFaxNumber);
   BAIL_ON_FAILURE(hr);

    VariantInit(&Var);
    hr = BinaryToVariant(
                _ADsValue.pFaxNumber->NumberOfBits,
                _ADsValue.pFaxNumber->Parameters,
                &Var);
    BAIL_ON_FAILURE(hr);
    hr = pFaxNumber->put_Parameters(Var);
    BAIL_ON_FAILURE(hr);
    VariantClear(&Var);

    hr = pFaxNumber->put_TelephoneNumber(_ADsValue.pFaxNumber->TelephoneNumber);
    BAIL_ON_FAILURE(hr);

   pFaxNumber->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pFaxNumber) {
      pFaxNumber->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_FaxNumber(THIS_ IDispatch FAR* pdFaxNumber)
{
    IADsFaxNumber *pFaxNumber = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTelephoneNumber;
    VARIANT varAddress;

    VariantInit(&varAddress);
    ClearData();
    hr = pdFaxNumber->QueryInterface(
                             IID_IADsFaxNumber,
                             (void **)&pFaxNumber
                             );
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->get_TelephoneNumber(&bstrTelephoneNumber);
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_FAXNUMBER;

    _ADsValue.pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!_ADsValue.pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.pFaxNumber->TelephoneNumber = AllocADsStr(bstrTelephoneNumber);
    if (!_ADsValue.pFaxNumber->TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = pFaxNumber->get_Parameters(&varAddress);
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pFaxNumber->NumberOfBits,
                    &_ADsValue.pFaxNumber->Parameters
                    );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varAddress);
   if (pFaxNumber) {
        pFaxNumber->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_NetAddress(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsNetAddress * pNetAddress = NULL;
   IDispatch * pDispatch = NULL;
   VARIANT VarAddress;

   VariantInit(&VarAddress);
   if (_ADsValue.dwType != ADSTYPE_NETADDRESS) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pNetAddress) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_NetAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsNetAddress,
            (void **) &pNetAddress);
   BAIL_ON_FAILURE(hr);

    hr = pNetAddress->put_AddressType(_ADsValue.pNetAddress->AddressType);
    BAIL_ON_FAILURE(hr);

    hr = BinaryToVariant(
                _ADsValue.pNetAddress->AddressLength,
                _ADsValue.pNetAddress->Address,
                &VarAddress);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarAddress);
    BAIL_ON_FAILURE(hr);

   pNetAddress->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear(&VarAddress);
   if (pNetAddress) {
      pNetAddress->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_NetAddress(THIS_ IDispatch FAR* pdNetAddress)
{
   IADsNetAddress *pNetAddress = NULL;
   HRESULT hr = S_OK;
   LONG lnAddressType = 0;
   VARIANT varAddress;

    ClearData();
    VariantInit(&varAddress);

    _ADsValue.pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!_ADsValue.pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   hr = pdNetAddress->QueryInterface(
                             IID_IADsNetAddress,
                             (void **)&pNetAddress
                             );
   BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_AddressType(
                    &lnAddressType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_Address(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pNetAddress->AddressLength,
                    &_ADsValue.pNetAddress->Address
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_NETADDRESS;
   _ADsValue.pNetAddress->AddressType = lnAddressType;

error:
    VariantClear(&varAddress);
   if (pNetAddress) {
        pNetAddress->Release();
    }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_OctetList(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsOctetList* pOctetList = NULL;
   IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    PADS_OCTET_LIST pCurrent = NULL;
    DWORD cElements = 0;
    VARIANT VarDestObject;
    VARIANT varElement;

    VariantInit( &VarDestObject );

    if (_ADsValue.dwType != ADSTYPE_OCTET_LIST) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pOctetList) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_OctetList,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsOctetList,
            (void **) &pOctetList);
   BAIL_ON_FAILURE(hr);

    pCurrent = _ADsValue.pOctetList;
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pOctetList;
    for ( i = 0; i < (long)cElements; i++ ) {
        hr = BinaryToVariant(
                        pCurrent->Length,
                        pCurrent->Data,
                        &varElement);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pOctetList->put_OctetList(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pOctetList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

    VariantClear( &VarDestObject );

    if (pOctetList) {
        pOctetList->Release();
    }

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_OctetList(THIS_ IDispatch FAR* pdOctetList)
{
   IADsOctetList *pOctetList = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    PADS_OCTET_LIST pCurrent = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varOctetList;
    VARIANT varElement;

    VariantInit(&varOctetList);
    ClearData();
   hr = pdOctetList->QueryInterface(
                             IID_IADsOctetList,
                             (void **)&pOctetList
                             );
   BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_OCTET_LIST;

    hr = pOctetList->get_OctetList(&varOctetList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varOctetList) &  VT_VARIANT) &&  V_ISARRAY(&varOctetList))) {
        return(E_FAIL);
    }

    if ((V_ARRAY(&varOctetList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    _ADsValue.pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!_ADsValue.pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pOctetList;
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varOctetList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                        &varElement,
                        &pCurrent->Length,
                        &pCurrent->Data
                        );
        BAIL_ON_FAILURE(hr);
        if (i != (long)dwSUBound) {
            pCurrent->Next = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;

error:
    VariantClear(&varOctetList);
   if (pOctetList) {
        pOctetList->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Email(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsEmail* pEmail = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_EMAIL) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Email,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsEmail,
            (void **) &pEmail);
   BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Type(_ADsValue.Email.Type);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Address(_ADsValue.Email.Address);
    BAIL_ON_FAILURE(hr);

   pEmail->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pEmail) {
      pEmail->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Email(THIS_ IDispatch FAR* pdEmail)
{
   IADsEmail *pEmail = NULL;
   HRESULT hr = S_OK;
   LONG lnType= 0;
   BSTR bstrAddress;

    ClearData();
   hr = pdEmail->QueryInterface(
                             IID_IADsEmail,
                             (void **)&pEmail
                             );
   BAIL_ON_FAILURE(hr);

    hr = pEmail->get_Type(
                    &lnType
                    );
    BAIL_ON_FAILURE(hr);
    hr = pEmail->get_Address(&bstrAddress);
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_EMAIL;
   _ADsValue.Email.Type = lnType;
   _ADsValue.Email.Address = AllocADsStr(bstrAddress);
    if (!_ADsValue.Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pEmail) {
        pEmail->Release();
    }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_Path(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsPath* pPath = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_PATH) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pPath) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_Path,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPath,
            (void **) &pPath);
   BAIL_ON_FAILURE(hr);

    hr = pPath->put_Type(_ADsValue.pPath->Type);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_VolumeName(_ADsValue.pPath->VolumeName);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Path(_ADsValue.pPath->Path);
    BAIL_ON_FAILURE(hr);

   pPath->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pPath) {
      pPath->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Path(THIS_ IDispatch FAR* pdPath)
{
   IADsPath *pPath = NULL;
   HRESULT hr = S_OK;
   LONG lnType = 0;
   BSTR bstrVolumeName;
   BSTR bstrPath;

    ClearData();

   hr = pdPath->QueryInterface(
                             IID_IADsPath,
                             (void **)&pPath
                             );
   BAIL_ON_FAILURE(hr);

    hr = pPath->get_Type(
                    &lnType
                    );
    BAIL_ON_FAILURE(hr);
    hr = pPath->get_VolumeName(
                    &bstrVolumeName
                    );
    BAIL_ON_FAILURE(hr);
    hr = pPath->get_Path(
                    &bstrPath
                    );
    BAIL_ON_FAILURE(hr);


   _ADsValue.dwType = ADSTYPE_PATH;
    _ADsValue.pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!_ADsValue.pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   _ADsValue.pPath->Type = lnType;
   _ADsValue.pPath->VolumeName = AllocADsStr(bstrVolumeName);
   if (!_ADsValue.pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }
   _ADsValue.pPath->Path = AllocADsStr(bstrPath);
   if (!_ADsValue.pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }

error:
   if (pPath) {
        pPath->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_ReplicaPointer(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsReplicaPointer* pReplicaPointer = NULL;
   IDispatch * pDispatch = NULL;
   IADsNetAddress* pNetAddress = NULL;
   VARIANT VarNetAddress;
   VARIANT VarDest;

   VariantInit(&VarNetAddress);
   VariantInit(&VarDest);

   if (_ADsValue.dwType != ADSTYPE_REPLICAPOINTER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pReplicaPointer) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_ReplicaPointer,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsReplicaPointer,
            (void **) &pReplicaPointer);
   BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaType(_ADsValue.pReplicaPointer->ReplicaType);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaNumber(_ADsValue.pReplicaPointer->ReplicaNumber);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_Count(_ADsValue.pReplicaPointer->Count);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ServerName(_ADsValue.pReplicaPointer->ServerName);
    BAIL_ON_FAILURE(hr);

    ////

   hr = CoCreateInstance(
            CLSID_NetAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsNetAddress,
            (void **) &pNetAddress);
   BAIL_ON_FAILURE(hr);


    hr = pNetAddress->put_AddressType(_ADsValue.pReplicaPointer->ReplicaAddressHints->AddressType);
    BAIL_ON_FAILURE(hr);

    hr = BinaryToVariant(
                _ADsValue.pReplicaPointer->ReplicaAddressHints->AddressLength,
                _ADsValue.pReplicaPointer->ReplicaAddressHints->Address,
                &VarNetAddress);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarNetAddress);
    BAIL_ON_FAILURE(hr);

   pNetAddress->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

    V_VT(&VarDest) = VT_DISPATCH;
    V_DISPATCH(&VarDest) =  pDispatch;

    hr = pReplicaPointer->put_ReplicaAddressHints(VarDest);
    BAIL_ON_FAILURE(hr);

   pReplicaPointer->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear(&VarNetAddress);
    VariantClear(&VarDest);
   if (pReplicaPointer) {
      pReplicaPointer->Release();
   }

   if (pNetAddress) {
       pNetAddress->Release();
   }
   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_ReplicaPointer(THIS_ IDispatch FAR* pdReplicaPointer)
{
   IADsReplicaPointer *pReplicaPointer = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
   IADsNetAddress *pNetAddress = NULL;
   LONG lnAddressType = 0;
   VARIANT varAddress;
   IDispatch *pdNetAddress = NULL;
    long lnReplicaType;
    long lnReplicaNumber;
    long lnCount;
    BSTR bstrServerName;

    VariantInit(&varAddress);
    ClearData();

    _ADsValue.pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!_ADsValue.pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.pReplicaPointer->ReplicaAddressHints =
                        (PADS_NETADDRESS)
                        AllocADsMem(
                            sizeof(ADS_NETADDRESS)
                            );
    if (!(_ADsValue.pReplicaPointer->ReplicaAddressHints)) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
    }

   hr = pdReplicaPointer->QueryInterface(
                             IID_IADsReplicaPointer,
                             (void **)&pReplicaPointer
                             );
   BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaType(
                    &lnReplicaType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaNumber(
                    &lnReplicaNumber
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_Count(
                    &lnCount
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ServerName(
                    &bstrServerName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaAddressHints(&varAddress);
    BAIL_ON_FAILURE(hr);

    if (V_VT(&varAddress) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pdNetAddress = V_DISPATCH(&varAddress);

    hr = pdNetAddress->QueryInterface(
                             IID_IADsNetAddress,
                             (void **)&pNetAddress
                             );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_AddressType(
                    &lnAddressType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_Address(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pReplicaPointer->ReplicaAddressHints->AddressLength,
                    &_ADsValue.pReplicaPointer->ReplicaAddressHints->Address
                    );

    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_REPLICAPOINTER;
   _ADsValue.pReplicaPointer->ReplicaAddressHints->AddressType = lnAddressType;
   _ADsValue.pReplicaPointer->ReplicaType = lnReplicaType;
   _ADsValue.pReplicaPointer->ReplicaNumber = lnReplicaNumber;
   _ADsValue.pReplicaPointer->Count = lnCount;
   _ADsValue.pReplicaPointer->ServerName = AllocADsStr(bstrServerName);
   if (!_ADsValue.pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }

error:
    VariantClear(&varAddress);
   if (pNetAddress) {
        pNetAddress->Release();
    }
   if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Timestamp(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsTimestamp* pTimestamp = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_TIMESTAMP) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Timestamp,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsTimestamp,
            (void **) &pTimestamp);
   BAIL_ON_FAILURE(hr);

    hr = pTimestamp->put_WholeSeconds(_ADsValue.Timestamp.WholeSeconds);
    BAIL_ON_FAILURE(hr);

    hr = pTimestamp->put_EventID(_ADsValue.Timestamp.EventID);
    BAIL_ON_FAILURE(hr);

   pTimestamp->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pTimestamp) {
      pTimestamp->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Timestamp(THIS_ IDispatch FAR* lnTimestamp)
{
   IADsTimestamp *pTimestamp = NULL;
   HRESULT hr = S_OK;
   LONG lnWholeSeconds = 0;
   LONG lnEventID = 0;

    ClearData();
   hr = lnTimestamp->QueryInterface(
                             IID_IADsTimestamp,
                             (void **)&pTimestamp
                             );
   BAIL_ON_FAILURE(hr);

    hr = pTimestamp->get_WholeSeconds(
                    &lnWholeSeconds
                    );
    BAIL_ON_FAILURE(hr);
    hr = pTimestamp->get_EventID(
                    &lnEventID
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_TIMESTAMP;
   _ADsValue.Timestamp.WholeSeconds = lnWholeSeconds;
   _ADsValue.Timestamp.EventID = lnEventID;

error:
   if (pTimestamp) {
        pTimestamp->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_PostalAddress(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsPostalAddress * pPostalAddress = NULL;
   IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;
    DWORD cElements = 0;
    VARIANT VarDestObject;

    VariantInit( &VarDestObject );

    if (_ADsValue.dwType != ADSTYPE_POSTALADDRESS) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pPostalAddress) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_PostalAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPostalAddress,
            (void **) &pPostalAddress);
   BAIL_ON_FAILURE(hr);

    aBound.lLbound = 0;
    aBound.cElements = 6;
    aList = SafeArrayCreate( VT_BSTR, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) 6; i++ )
    {
        hr = ADsAllocString(
                _ADsValue.pPostalAddress->PostalAddress[i],
                &bstrAddress
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, bstrAddress );
        BAIL_ON_FAILURE(hr);
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pPostalAddress->put_PostalAddress(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

    RRETURN(hr);

error:

    VariantClear( &VarDestObject );

    if (pPostalAddress) {
        pPostalAddress->Release();
    }
    if (aList) {
        SafeArrayDestroy( aList );
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_PostalAddress(THIS_ IDispatch FAR* pdPostalAddress)
{
   IADsPostalAddress *pPostalAddress = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varAddress;
    VARIANT varBstrElement;

    VariantInit(&varAddress);
    ClearData();
   hr = pdPostalAddress->QueryInterface(
                             IID_IADsPostalAddress,
                             (void **)&pPostalAddress
                             );
   BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_POSTALADDRESS;

    _ADsValue.pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!_ADsValue.pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pPostalAddress->get_PostalAddress(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);
    if(!((V_VT(&varAddress) &  VT_VARIANT) &&  V_ISARRAY(&varAddress))) {
        return(E_FAIL);
    }

    if ((V_ARRAY(&varAddress))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ( ((V_ARRAY(&varAddress))->rgsabound[0].cElements <= 0) ||
         ((V_ARRAY(&varAddress))->rgsabound[0].cElements >6) ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varAddress),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varAddress),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {

        VariantInit(&varBstrElement);
        hr = SafeArrayGetElement(V_ARRAY(&varAddress),
                                (long FAR *)&i,
                                &varBstrElement
                                );
        BAIL_ON_FAILURE(hr);

        _ADsValue.pPostalAddress->PostalAddress[i-dwSLBound] = AllocADsStr(V_BSTR(&varBstrElement));
        VariantClear(&varBstrElement);
        if (!_ADsValue.pPostalAddress->PostalAddress[i-dwSLBound]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    RRETURN(S_OK);

error:
    VariantClear(&varAddress);
   if (pPostalAddress) {
        pPostalAddress->Release();
    }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_BackLink(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsBackLink* pBackLink = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_BACKLINK) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_BackLink,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsBackLink,
            (void **) &pBackLink);
   BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_RemoteID(_ADsValue.BackLink.RemoteID);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_ObjectName(_ADsValue.BackLink.ObjectName);
    BAIL_ON_FAILURE(hr);

   pBackLink->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pBackLink) {
      pBackLink->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_BackLink(THIS_ IDispatch FAR* pdBackLink)
{
   IADsBackLink *pBackLink = NULL;
   HRESULT hr = S_OK;
   LONG lnRemoteID = 0;
   BSTR bstrObjectName;

    ClearData();
   hr = pdBackLink->QueryInterface(
                             IID_IADsBackLink,
                             (void **)&pBackLink
                             );
   BAIL_ON_FAILURE(hr);

    hr = pBackLink->get_RemoteID(
                    &lnRemoteID
                    );
    BAIL_ON_FAILURE(hr);
    hr = pBackLink->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_BACKLINK;
   _ADsValue.BackLink.RemoteID = lnRemoteID;
   _ADsValue.BackLink.ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.BackLink.ObjectName ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pBackLink) {
        pBackLink->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_TypedName(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsTypedName* pTypedName = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_TYPEDNAME) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pTypedName) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_TypedName,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsTypedName,
            (void **) &pTypedName);
   BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Level(_ADsValue.pTypedName->Level);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Interval(_ADsValue.pTypedName->Interval);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_ObjectName(_ADsValue.pTypedName->ObjectName);
    BAIL_ON_FAILURE(hr);

   pTypedName->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pTypedName) {
      pTypedName->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_TypedName(THIS_ IDispatch FAR* pdTypedName)
{
   IADsTypedName* pTypedName = NULL;
   HRESULT hr = S_OK;
   LONG lnLevel= 0;
   LONG lnInterval= 0;
   BSTR bstrObjectName;

    ClearData();
   hr = pdTypedName->QueryInterface(
                             IID_IADsTypedName,
                             (void **)&pTypedName
                             );
   BAIL_ON_FAILURE(hr);

    hr = pTypedName->get_Level(
                    &lnLevel
                    );
    BAIL_ON_FAILURE(hr);
    hr = pTypedName->get_Interval(
                    &lnInterval
                    );
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_TYPEDNAME;

    _ADsValue.pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!_ADsValue.pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   _ADsValue.pTypedName->Level= lnLevel;
   _ADsValue.pTypedName->Interval= lnInterval;
   _ADsValue.pTypedName->ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.pTypedName->ObjectName ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pTypedName) {
        pTypedName->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Hold(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsHold* pHold = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_HOLD) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Hold,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsHold,
            (void **) &pHold);
   BAIL_ON_FAILURE(hr);

    hr = pHold->put_Amount(_ADsValue.Hold.Amount);
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_ObjectName(_ADsValue.Hold.ObjectName);
    BAIL_ON_FAILURE(hr);

   pHold->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pHold) {
      pHold->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Hold(THIS_ IDispatch FAR* pdHold)
{
   IADsHold *pHold = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
   BSTR bstrObjectName;

   ClearData();
   hr = pdHold->QueryInterface(
                             IID_IADsHold,
                             (void **)&pHold
                             );
   BAIL_ON_FAILURE(hr);

    hr = pHold->get_Amount(
                    &lnAmount
                    );
    BAIL_ON_FAILURE(hr);
    hr = pHold->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_HOLD;
   _ADsValue.Hold.Amount= lnAmount;
   _ADsValue.Hold.ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.Hold.ObjectName ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pHold) {
        pHold->Release();
    }

   RRETURN(hr);
}


//
// Helper to get octetString in variant if we have a
// secDesc stored underneath.
//
STDMETHODIMP
CPropertyValue::getOctetStringFromSecDesc(VARIANT FAR *retval)
{
   HRESULT hr = S_OK;
   SAFEARRAY *aList = NULL;
   SAFEARRAYBOUND aBound;
   CHAR HUGEP *pArray = NULL;
   ADSVALUE ADsDestValue;

   memset(&ADsDestValue, 0, sizeof(ADSVALUE));

   hr = AdsCopyPropObjToADsValue(
            this,
            &ADsDestValue,
            NULL, // pszServerName,
            NULL, // pCredentials - use default credentials
            TRUE  // fNTDSType
            );

   BAIL_ON_FAILURE(hr);

   if (ADsDestValue.dwType != ADSTYPE_OCTET_STRING) {
       BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }

   aBound.lLbound = 0;
   aBound.cElements = ADsDestValue.OctetString.dwLength;

   aList = SafeArrayCreate( VT_UI1, 1, &aBound );

   if ( aList == NULL ) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray);
   BAIL_ON_FAILURE(hr);

   memcpy(pArray, ADsDestValue.OctetString.lpValue, aBound.cElements);

   SafeArrayUnaccessData( aList );

   V_VT(retval) = VT_ARRAY | VT_UI1;
   V_ARRAY(retval) = aList;

error:

    if (FAILED(hr) && aList) {
        SafeArrayDestroy(aList);
    }

    AdsClear(&ADsDestValue);

    RRETURN(hr);
}



//
// Helper to get SecDesc in variant if we have a
// octetString stored underneath.
//
STDMETHODIMP
CPropertyValue::getSecurityDescriptorFromOctStr(VARIANT FAR *retval)
{
   HRESULT hr = S_OK;
   CCredentials dummyCredentials(NULL, NULL, 0);


   hr = ConvertSecDescriptorToVariant(
            NULL, // pszServerName
            dummyCredentials,
            _ADsValue.OctetString.lpValue,
            retval,
            TRUE // NTDS Type
            );

    RRETURN(hr);
}


//
// There has to be a better way to do this. Ideally this code
// should live in one plae and we should be able to use that
// everywhere. Currently it lives here as well as in the ldap
// provider - slight differences though.
// This comment holds true for DNWithString also - AjayR 4-30-99
//
STDMETHODIMP
CPropertyValue::getDNWithBinary(THIS_ IDispatch FAR * FAR * ppDispatch)
{
   HRESULT hr = S_OK;
   IADsDNWithBinary *pDNWithBinary = NULL;
   SAFEARRAY *aList = NULL;
   SAFEARRAYBOUND aBound;
   CHAR HUGEP *pArray = NULL;
   BSTR bstrTemp = NULL;
   VARIANT vVar;

   VariantInit(&vVar);

   if (_ADsValue.dwType != ADSTYPE_DN_WITH_BINARY) {
       BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }


   hr = CoCreateInstance(
            CLSID_DNWithBinary,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsDNWithBinary,
            (void **) &pDNWithBinary
            );
   BAIL_ON_FAILURE(hr);

   if (_ADsValue.pDNWithBinary->pszDNString) {
       hr = ADsAllocString(_ADsValue.pDNWithBinary->pszDNString, &bstrTemp);
       BAIL_ON_FAILURE(hr);

       //
        // Put the value in the object - we can only set BSTR's
       //
       hr = pDNWithBinary->put_DNString(bstrTemp);
       BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, _ADsValue.pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(&vVar) = VT_ARRAY | VT_UI1;
    V_ARRAY(&vVar) = aList;

    hr = pDNWithBinary->put_BinaryValue(vVar);
    VariantClear(&vVar);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pDNWithBinary) {
        pDNWithBinary->Release();
    }

    if (bstrTemp) {
        ADsFreeString(bstrTemp);
    }

    RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::putDNWithBinary(THIS_ IDispatch * pDNWithBinary)
{
    HRESULT hr = S_OK;
    IADsDNWithBinary * pDNBinary = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    VARIANT vBinary;
    DWORD dwSUBound = 0;
    DWORD dwSLBound = 0;
    DWORD dwLength  = 0;
    BSTR bstrDN = NULL;
    LPBYTE lpByte = NULL;
    CHAR HUGEP *pArray = NULL;

    VariantInit(&vBinary);

    ClearData();

    //
    // This qi ensures that this is a security descriptor
    //
    hr = pDNWithBinary->QueryInterface(
                            IID_IADsDNWithBinary,
                            (void **) &pDNBinary
                            );

    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNBinary->get_BinaryValue(&vBinary);
    BAIL_ON_FAILURE(hr);

    if ((vBinary.vt != (VT_ARRAY | VT_UI1))
        && vBinary.vt != VT_EMPTY) {

        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDNBinary->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    //
    // Get the byte array in a usable format.
    //
    hr = SafeArrayGetLBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    dwLength = dwSUBound - dwSLBound + 1;

    lpByte = (LPBYTE) AllocADsMem(dwLength);

    if (dwLength && !lpByte) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vBinary),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(lpByte, pArray, dwLength);

    SafeArrayUnaccessData( V_ARRAY(&vBinary) );

    pDNBin = (PADS_DN_WITH_BINARY) AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (bstrDN) {

        pDNBin->pszDNString = AllocADsStr(bstrDN);

        if (!pDNBin->pszDNString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    _ADsValue.dwType = ADSTYPE_DN_WITH_BINARY;
    _ADsValue.pDNWithBinary = pDNBin;
    _ADsValue.pDNWithBinary->lpBinaryValue = lpByte;
    _ADsValue.pDNWithBinary->dwLength = dwLength;


error:

    if (pDNBinary) {
        pDNBinary->Release();
    }

    if (FAILED(hr)) {

        if (lpByte) {
            FreeADsMem(lpByte);
        }

        if (pDNBin) {
            if (pDNBin->pszDNString) {
                FreeADsStr(pDNBin->pszDNString);
            }

            FreeADsMem(pDNBin);
        }

    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    VariantClear(&vBinary);

    RRETURN(hr);


}

STDMETHODIMP
CPropertyValue::putDNWithString(THIS_ IDispatch * pDNWithString)
{
    HRESULT hr = S_OK;
    IADsDNWithString *pDNString = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;
    BSTR bstrStringValue = NULL;
    BSTR bstrDN = NULL;

    ClearData();

    hr = pDNWithString->QueryInterface(
                            IID_IADsDNWithString,
                            (void **)&pDNString
                            );
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_StringValue(&bstrStringValue);
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_DN_WITH_STRING;
    pDNStr = (PADS_DN_WITH_STRING) AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Put String value in the DNString struct.
    //
    pDNStr->pszStringValue = AllocADsStr(bstrStringValue);

    if (bstrStringValue && !pDNStr->pszStringValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDNStr->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pDNStr->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    _ADsValue.dwType = ADSTYPE_DN_WITH_STRING;
    _ADsValue.pDNWithString = pDNStr;

error:

    if (pDNString) {
        pDNString->Release();
    }

    if (bstrStringValue) {
        ADsFreeString(bstrStringValue);
    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    if (pDNStr && FAILED(hr)) {

        if (pDNStr->pszDNString) {
            FreeADsStr(pDNStr->pszDNString);
        }

        if (pDNStr->pszStringValue) {
            FreeADsMem(pDNStr->pszStringValue);
        }
        FreeADsMem(pDNStr);
    }

    RRETURN(hr);

}


STDMETHODIMP
CPropertyValue::getDNWithString(THIS_ IDispatch FAR * FAR * ppDispatch)
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithString *pDNWithString = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrStrVal = NULL;
    BSTR bstrDNVal = NULL;

    if (_ADsValue.dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pDNWithString
             );
    BAIL_ON_FAILURE(hr);



    if (_ADsValue.pDNWithString->pszDNString) {
        hr = ADsAllocString(_ADsValue.pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (_ADsValue.pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 _ADsValue.pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pDNWithString) {
        pDNWithString->Release();
    }

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::getProvSpecific(THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    if (_ADsValue.dwType != ADSTYPE_PROV_SPECIFIC) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.ProviderSpecific.dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _ADsValue.ProviderSpecific.lpValue,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(retval) = VT_ARRAY | VT_UI1;
    V_ARRAY(retval) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::putProvSpecific(THIS_ VARIANT VarProvSpecific)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    HRESULT hr = S_OK;

    ClearData();

    _ADsValue.dwType = ADSTYPE_PROV_SPECIFIC;

    if( VarProvSpecific.vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&VarProvSpecific),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&VarProvSpecific),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _ADsValue.ProviderSpecific.lpValue = (LPBYTE)AllocADsMem(dwSUBound - dwSLBound + 1);

    if ( _ADsValue.ProviderSpecific.lpValue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.ProviderSpecific.dwLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(&VarProvSpecific),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _ADsValue.ProviderSpecific.lpValue,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(&VarProvSpecific) );

error:
    RRETURN_EXP_IF_ERR(hr);
}

void
CPropertyValue::ClearData()
{
    //
    // For all the types - this works even if the adsvalue is null
    // as adsvalue.dwType = 0 ---> invalid_type does nothing !!!
    //
    AdsClear(&_ADsValue);

    if (_pDispatch) {

        switch (_dwDataType) {

        case VAL_IDISPATCH_SECDESC_ONLY:
        case VAL_IDISPATCH_SECDESC_ALL:

           _pDispatch->Release();
           _pDispatch = NULL;
           _dwDataType = VAL_IDISPATCH_UNKNOWN;
           break;

        default:

            ADsAssert(!"Internal incosistency secdesc ptr but bad type.");
            _pDispatch = NULL;
            _dwDataType = VAL_IDISPATCH_UNKNOWN;
            break;

        } // end switch
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyValue::GetObjectProperty
//
//  Synopsis: Gets the values stored in this PropertyValue object. The
// value returned is determined by the value requested in lnContorlCode.
// For now though we will only support ADSTYPE_UNKNOWN in which case we
// get the info from the object itself. Alternatively the type should match
// that which is in the object.
//
//
//  Arguments: lnControlCode - ADSTYPE_INVALID implies whatever we have
//                           - anything else implies we return the type.
//             pvProp        - the output value goes into this.
//
//
//-------------------------------------------------------------------------
STDMETHODIMP
CPropertyValue::GetObjectProperty(
    THIS_ long *lnControlCode,
    VARIANT *pvProp
    )
{
    HRESULT hr = S_OK;
    ADSTYPE dwTypeAsked = ADSTYPE_INVALID;

    ADsAssert(pvProp);
    ADsAssert(lnControlCode);


    if (*lnControlCode == ADSTYPE_UNKNOWN) {
        dwTypeAsked = _ADsValue.dwType;
    } else {
        dwTypeAsked = (ADSTYPE)*lnControlCode;
    }

    *lnControlCode = dwTypeAsked;

    switch (dwTypeAsked) {

    case ADSTYPE_INVALID:
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        break;

    case ADSTYPE_DN_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_DNString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_CASE_EXACT_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_CaseExactString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_CASE_IGNORE_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_CaseIgnoreString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_PRINTABLE_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_PrintableString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_NUMERIC_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_NumericString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_BOOLEAN :
        {
            LONG lnVal = 0;

            pvProp->vt = VT_BOOL;
            hr = get_Boolean(&(lnVal));
            if (SUCCEEDED(hr)) {
                pvProp->boolVal = lnVal ? VARIANT_TRUE : VARIANT_FALSE;
            }
        }
            break;


    case ADSTYPE_INTEGER :
        pvProp->vt = VT_I4;
        hr = get_Integer(&(pvProp->lVal));
        break;

    case ADSTYPE_OCTET_STRING :
        hr = get_OctetString(pvProp);

        if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
            //
            // Try and see if it is a SD and convert
            //
            if (_ADsValue.dwType == ADSTYPE_NT_SECURITY_DESCRIPTOR) {
                hr = getOctetStringFromSecDesc(pvProp);
            }
        }
        break;

    case ADSTYPE_PROV_SPECIFIC :
        hr = getProvSpecific(pvProp);
        break;

    case ADSTYPE_UTC_TIME :
        pvProp->vt = VT_DATE;
        hr = get_UTCTime(&(pvProp->date));
        break;

    case ADSTYPE_LARGE_INTEGER :
        pvProp->vt = VT_DISPATCH;
        hr = get_LargeInteger(&(pvProp->pdispVal));
        break;

    case ADSTYPE_OBJECT_CLASS :
        pvProp->vt = VT_DISPATCH;
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    case ADSTYPE_CASEIGNORE_LIST :
        pvProp->vt = VT_DISPATCH;
        hr = get_CaseIgnoreList(&(pvProp->pdispVal));
        break;

    case ADSTYPE_OCTET_LIST :
        pvProp->vt = VT_DISPATCH;
        hr = get_OctetList(&(pvProp->pdispVal));
        break;

    case ADSTYPE_PATH :
        pvProp->vt = VT_DISPATCH;
        hr = get_Path(&(pvProp->pdispVal));
        break;

    case ADSTYPE_POSTALADDRESS :
        pvProp->vt = VT_DISPATCH;
        hr = get_PostalAddress(&(pvProp->pdispVal));
        break;

    case ADSTYPE_TIMESTAMP :
        pvProp->vt = VT_DISPATCH;
        hr = get_Timestamp(&(pvProp->pdispVal));
        break;

    case ADSTYPE_BACKLINK :
        pvProp->vt = VT_DISPATCH;
        hr = get_BackLink(&(pvProp->pdispVal));
        break;

    case ADSTYPE_TYPEDNAME :
        pvProp->vt = VT_DISPATCH;
        hr = get_TypedName(&(pvProp->pdispVal));
        break;

    case ADSTYPE_HOLD :
        pvProp->vt = VT_DISPATCH;
        hr = get_Hold(&(pvProp->pdispVal));
        break;

    case ADSTYPE_NETADDRESS :
        pvProp->vt = VT_DISPATCH;
        hr = get_NetAddress(&(pvProp->pdispVal));
        break;

    case ADSTYPE_REPLICAPOINTER :
        pvProp->vt = VT_DISPATCH;
        hr = get_ReplicaPointer(&(pvProp->pdispVal));
        break;

    case ADSTYPE_FAXNUMBER :
        pvProp->vt = VT_DISPATCH;
        hr = get_FaxNumber(&(pvProp->pdispVal));
        break;

    case ADSTYPE_EMAIL :
        pvProp->vt = VT_DISPATCH;
        hr = get_Email(&(pvProp->pdispVal));
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :
        pvProp->vt = VT_DISPATCH;
        hr = get_SecurityDescriptor(&(pvProp->pdispVal));

        if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
            //
            // Try and see if it is an OctetString needed as SecDesc
            //
            if (_ADsValue.dwType == ADSTYPE_OCTET_STRING) {
                hr = getSecurityDescriptorFromOctStr(pvProp);
            }
        }
        break;

    case ADSTYPE_DN_WITH_BINARY:
        pvProp->vt = VT_DISPATCH;
        hr = getDNWithBinary(&(pvProp->pdispVal));
        break;

    case ADSTYPE_DN_WITH_STRING:
        pvProp->vt = VT_DISPATCH;
        hr = getDNWithString(&(pvProp->pdispVal));
        break;

    case ADSTYPE_UNKNOWN :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    default:
        // We should never be here
        hr = E_ADS_BAD_PARAMETER;
        break;

    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::PutObjectProperty(
    THIS_ long lnControlCode,
    VARIANT varObj
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvVar = &varObj;

    if (lnControlCode == ADSTYPE_UNKNOWN
        || lnControlCode == ADSTYPE_INVALID) {

        BAIL_ON_FAILURE(hr=E_ADS_BAD_PARAMETER);
    }

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varObj);
    }

    switch (lnControlCode) {

    case ADSTYPE_INVALID:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        break;

    case ADSTYPE_DN_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_DNString(pvVar->bstrVal);
        break;

    case ADSTYPE_CASE_EXACT_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
        hr = put_CaseExactString(pvVar->bstrVal);
        break;

    case ADSTYPE_CASE_IGNORE_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_CaseIgnoreString(pvVar->bstrVal);
        break;

    case ADSTYPE_PRINTABLE_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_PrintableString(pvVar->bstrVal);
        break;

    case ADSTYPE_NUMERIC_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_NumericString(pvVar->bstrVal);
        break;

    case ADSTYPE_BOOLEAN :

        if (pvVar->vt != VT_BOOL) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Boolean((pvVar->boolVal == VARIANT_TRUE) ? TRUE : FALSE);
        break;

    case ADSTYPE_INTEGER :
        if (pvVar->vt != VT_I4) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Integer(pvVar->lVal);
        break;

    case ADSTYPE_OCTET_STRING :
        hr = put_OctetString(*pvVar);
        break;

    case ADSTYPE_PROV_SPECIFIC :
        hr = putProvSpecific(varObj);
        break;

    case ADSTYPE_UTC_TIME :
        if (pvVar->vt != VT_DATE) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_UTCTime(pvVar->date);
        break;

    case ADSTYPE_LARGE_INTEGER :
        if (pvVar->vt != VT_DISPATCH) {
           BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_LargeInteger(pvVar->pdispVal);
        break;

    case ADSTYPE_OBJECT_CLASS :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    case ADSTYPE_CASEIGNORE_LIST :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_CaseIgnoreList(pvVar->pdispVal);
        break;

    case ADSTYPE_OCTET_LIST :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_OctetList(pvVar->pdispVal);
        break;

    case ADSTYPE_PATH :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Path(pvVar->pdispVal);
        break;

    case ADSTYPE_POSTALADDRESS :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_PostalAddress(pvVar->pdispVal);
        break;

    case ADSTYPE_TIMESTAMP :
        if (pvVar->vt != VT_DISPATCH){
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Timestamp(pvVar->pdispVal);
        break;

    case ADSTYPE_BACKLINK :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_BackLink(pvVar->pdispVal);
        break;

    case ADSTYPE_TYPEDNAME :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_TypedName(pvVar->pdispVal);
        break;

    case ADSTYPE_HOLD :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Hold(pvVar->pdispVal);
        break;

    case ADSTYPE_NETADDRESS :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_NetAddress(pvVar->pdispVal);
        break;

    case ADSTYPE_REPLICAPOINTER :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_ReplicaPointer(pvVar->pdispVal);
        break;

    case ADSTYPE_FAXNUMBER :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_FaxNumber(pvVar->pdispVal);
        break;

    case ADSTYPE_EMAIL :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Email(pvVar->pdispVal);
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_SecurityDescriptor(pvVar->pdispVal);
        break;

    case ADSTYPE_DN_WITH_BINARY :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = putDNWithBinary(pvVar->pdispVal);
        break;

    case ADSTYPE_DN_WITH_STRING :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = putDNWithString(pvVar->pdispVal);
        break;

    case ADSTYPE_UNKNOWN :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
        break;
    }

error:

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\cvaluecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsPropertyValueCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsPropertyValueCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyValue::CreatePropertyValue(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\dbid.cxx ===
//------------------------------------------------------------------------------
//
//  Microsoft Sidewalk
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       oledbhelp.cpp
//
//  Contents:   OLE DB helper methods
//
//  Owner:      BassamT
//														 
//  History:    11/30/97   BassamT	Created.
//
//------------------------------------------------------------------------------

#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

#define dimensionof(x) sizeof(x)/sizeof(x[0])

HRESULT IsValidDBID
//------------------------------------------------------------------------------
// checks if we have a valid DBID
(
	const DBID * pdbid1
	// [in] the DBID to check
)
{
	Assert(pdbid1 != NULL);

	if (pdbid1 &&
		((pdbid1->eKind == DBKIND_GUID_NAME) ||
		(pdbid1->eKind == DBKIND_GUID_PROPID) ||
		(pdbid1->eKind == DBKIND_NAME) ||
		(pdbid1->eKind == DBKIND_PGUID_NAME) ||
		(pdbid1->eKind == DBKIND_PGUID_PROPID) ||
		(pdbid1->eKind == DBKIND_PROPID) ||
		(pdbid1->eKind == DBKIND_GUID)))
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

BOOL CompareDBIDs
//------------------------------------------------------------------------------
// Compares two DBIDs. Given two DBIDS to determine if they are the same.
// Returns TRUE if they are the same DBIDs or FALSE if different
(
	const DBID * pdbid1,
	// [in] pointer to DBID 1; can be badly formed eKind
	const DBID * pdbid2
	// [in] pointer to DBID 2; assumed valid eKind
)
{
	// Array of valid eKind matches, in addition to matching exactly.
	static BYTE abKind[] =
	{
		DBKIND_PGUID_NAME,		// DBKIND_GUID_NAME
		DBKIND_PGUID_PROPID,	// DBKIND_GUID_PROPID
		DBKIND_NAME,			// DBKIND_NAME
		DBKIND_GUID_NAME,		// DBKIND_PGUID_NAME
		DBKIND_GUID_PROPID,		// DBKIND_PGUID_PROPID
		DBKIND_PROPID,			// DBKIND_PROPID
		DBKIND_GUID				// DBKIND_GUID
	};

	// Verify that offsets are correct (header file might change).
	Assert(	0 == DBKIND_GUID_NAME && 
			1 == DBKIND_GUID_PROPID && 
			2 == DBKIND_NAME && 
			3 == DBKIND_PGUID_NAME && 
			4 == DBKIND_PGUID_PROPID && 
			5 == DBKIND_PROPID && 
			6 == DBKIND_GUID);

	if (pdbid1 == NULL || pdbid2 == NULL)
	{
		return FALSE;
	}

	// Assume a match, and discard early if we can.

	// Don't assert for 1, since might be badly-formed.
	// 2 is assumed to be well-formed.
	Assert(inrange(((SHORT)pdbid2->eKind), 0, dimensionof(abKind)));

	if (pdbid1->eKind != pdbid2->eKind && 
		pdbid1->eKind != abKind[pdbid2->eKind])
	{
		return FALSE;
	}

	if (DBID_USE_GUID_OR_PGUID(pdbid1->eKind))
	{
		if (!DBID_USE_GUID_OR_PGUID(pdbid2->eKind))
		{
			return FALSE;
		}

		// Compare GUIDs.
		// Note that _GUID_ is equivalent to _PGUID_.
		if (!IsEqualGUID(
			DBID_USE_PGUID(pdbid1->eKind) ? *(pdbid1->uGuid.pguid) : pdbid1->uGuid.guid,
			DBID_USE_PGUID(pdbid2->eKind) ? *(pdbid2->uGuid.pguid) : pdbid2->uGuid.guid))
		{
			return FALSE;
		}
	}

	if (DBID_USE_NAME(pdbid1->eKind))
	{
		if (!DBID_USE_NAME(pdbid2->eKind))
		{
			return FALSE;
		}

		// Compare names.
		// Need to check if 1 is null and the other is not.
		if (((pdbid1->uName.pwszName == NULL) && (pdbid2->uName.pwszName != NULL)) || 
			((pdbid1->uName.pwszName != NULL) && (pdbid2->uName.pwszName == NULL)))
		{
			 return FALSE;
		}

		// Since the above check does not rule out both being null, which is
		// a valid comparison, and wcscmp will GPF if they were, we need
		// to check for valid pointers
		if(pdbid1->uName.pwszName != NULL && pdbid2->uName.pwszName != NULL)
		{
			// Assume null-terminated.
			if (_wcsicmp(pdbid1->uName.pwszName, pdbid2->uName.pwszName) != 0)
			{
				return FALSE;
			}
		}
	}

	if (DBID_USE_PROPID(pdbid1->eKind))
	{
		if (!DBID_USE_PROPID(pdbid2->eKind))
		{
			return FALSE;
		}
		// Compare PROPID.

		if (pdbid1->uName.ulPropid != pdbid2->uName.ulPropid)
		{
			return FALSE;
		}
	}

	// a match
	return TRUE;
}


void FreeDBID
//------------------------------------------------------------------------------
// FreeDBID
// Given a DBID free an allocated buffers
(
	DBID *pdbidSrc
	//[in] Pointer to DBID
)
{
	Assert(pdbidSrc);

	switch (pdbidSrc->eKind)
	{
	case DBKIND_GUID_NAME:
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_NAME:
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_PGUID_NAME:
		CLIENT_FREE(pdbidSrc->uGuid.pguid); 
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_PGUID_PROPID:
		CLIENT_FREE(pdbidSrc->uGuid.pguid); 
		break;
	case DBKIND_GUID_PROPID:
	case DBKIND_PROPID:
	case DBKIND_GUID:
		break;
	default:
		Assert(NULL && L"Unhandled dbid1.ekind");
		break;
	}
}


HRESULT CopyDBIDs
//------------------------------------------------------------------------------
// Given a DBID to copy, put it in the new buffer
//
// Need to use IMalloc->Alloc and IMalloc->Free since this routine
// is used to copy the DBIDs from storage back into the memory handed to 
// the consumer.
//
// HRESULT indicating the status of the copy
//		S_OK = Copied
//		S_FALSE = Problems copying
//		E_OUTOFMEMORY = Could not allocate resources
//
(
	DBID * pdbidDest,	
	// [in,out] Pointer to Destination DBID
	const DBID *pdbidSrc
	// [in] Pointer to Source DBID
)
{
	Assert(pdbidDest);
	Assert(pdbidSrc);

	size_t	cwchBuffer;
	HRESULT hr;


	memset(pdbidDest, 0, sizeof(*pdbidDest));

	// Save eKind
	pdbidDest->eKind = pdbidSrc->eKind;

	switch (pdbidSrc->eKind)
	{
		case DBKIND_GUID_NAME:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;

			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_GUID_PROPID:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_NAME:
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;
			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_PGUID_NAME:
			// convert the pguid into a guid so that we don't have to do an extra malloc
			pdbidDest->eKind = DBKIND_GUID_NAME;
			pdbidDest->uGuid.guid = *pdbidSrc->uGuid.pguid;
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;

			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_PGUID_PROPID:
			// convert the pguid into a guid so that we don't have to do an extra malloc
			pdbidDest->eKind = DBKIND_GUID_PROPID;
			pdbidDest->uGuid.guid = *pdbidSrc->uGuid.pguid; 
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_PROPID:
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_GUID:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			break;

		default:
			Assert(NULL && L"Unhandled dbid ekind");
			hr = E_FAIL;
			//ErrorTrace(hr);
			goto Error;
	}

	return NOERROR;

Error:
	Assert(FAILED(hr));
	return hr;
}


INT CompareOLEDBTypes
//------------------------------------------------------------------------------
// Compares two value of the same DBTYPE.
//
// Returns :
//
//		0	if both values are equal
//		>0	if pvValue1 is greater than pvValue2
//		<0	if pvValue1 is less than pvValue2
//
(
	DBTYPE wType, 
	// [in] the OLE DB type of both values
	void * pvValue1, 
	// [in] a pointer to Value1
	void * pvValue2
	// [in] a pointer to Value2
)
{
	Assert (pvValue1 != NULL);
	Assert (pvValue2 != NULL);

	// TODO : Is this right ?
	INT comp = -1;

/*
	// TODO : how do we handle these ?
	case DBTYPE_ARRAY:
	case DBTYPE_BYREF:
	case DBTYPE_VECTOR:
*/

	// TODO : support the other DB_TYPES and check that all types work
	// TODO : What about NULL values ?
	// TODO : WE could generalize this function and let it handle values
	// of different types.

	switch (wType)
	{
	case DBTYPE_I2:
		comp = (*(SHORT*)pvValue1) - (*(SHORT*)pvValue2);
		break;
	case DBTYPE_I4:
		comp = (*(LONG*)pvValue1) - (*(LONG*)pvValue2);
		break;
	case DBTYPE_UI1:
		comp = (*(UCHAR*)pvValue1) - (*(UCHAR*)pvValue2);
		break;
	case DBTYPE_I1:
		comp = (*(CHAR*)pvValue1) - (*(CHAR*)pvValue2);
		break;
	case DBTYPE_UI2:
		comp = (*(USHORT*)pvValue1) - (*(USHORT*)pvValue2);
		break;
	case DBTYPE_UI4:
		comp = (*(ULONG*)pvValue1) - (*(ULONG*)pvValue2);
		break;
	case DBTYPE_STR:
		comp = strcmp((CHAR*)(pvValue1), (CHAR*)pvValue2);
		break;
	case DBTYPE_WSTR:
		comp = wcscmp((WCHAR*)(pvValue1), (WCHAR*)pvValue2);
		break;
	case DBTYPE_GUID:
	case DBTYPE_I8:
	case DBTYPE_UI8:
	case DBTYPE_R4:
	case DBTYPE_R8:
	case DBTYPE_CY:
	case DBTYPE_DATE:
	case DBTYPE_BSTR:
	case DBTYPE_IDISPATCH:
	case DBTYPE_ERROR:
	case DBTYPE_BOOL:
	case DBTYPE_VARIANT:
	case DBTYPE_IUNKNOWN:
	case DBTYPE_DECIMAL:
	case DBTYPE_RESERVED:
	case DBTYPE_BYTES:
	case DBTYPE_NUMERIC:
	case DBTYPE_UDT:
	case DBTYPE_DBDATE:
	case DBTYPE_DBTIME:
	case DBTYPE_DBTIMESTAMP:
	default:
		Assert(FALSE && "CIndex : Data type not supported");
		return -1;
	}

	return comp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\encode.cxx ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    encode.cxx

Abstract:

    This module provides encoing functions to convert a binary blob of data so
    that it can be embedded in a search filter. 
    
Author:

    Shankara Shastry (ShankSh) 12-Mar-1997

Revision History:

--*/

#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


WCHAR HexToWCharTable[17] = L"0123456789ABCDEF";

//
//  Helper function to support allowing opaque blobs of data in search filters.
//  This API takes any filter element and adds necessary escape characters
//  such that when the element hits the wire in the search request, it will
//  be equal to the opaque blob past in here as source.
//

//
// The destination string ppszDestData needs to be freed using FreeAdsMem after
// using it. 
//

HRESULT
ADsEncodeBinaryData (
   PBYTE   pbSrcData,
   DWORD   dwSrcLen,
   LPWSTR  * ppszDestData
   )
{
    LPWSTR pszDest = NULL, pszDestPtr = NULL;
    DWORD lengthRequired = 0;
    DWORD dwSrcCount = 0;
    WCHAR wch;

    if (!ppszDestData || (!pbSrcData && dwSrcLen))
        RRETURN(E_ADS_BAD_PARAMETER);

    *ppszDestData = NULL;

    //
    //  figure out how long of a buffer we need.
    //
    lengthRequired = ((dwSrcLen * 2) + 1) * sizeof(WCHAR);

    pszDest = (LPWSTR) AllocADsMem( lengthRequired );
    if (pszDest == NULL) 
        RRETURN (E_OUTOFMEMORY );

    pszDestPtr = pszDest;

    //
    //  For each byte in source string, copy it to dest string but we first
    //  expand it out such that each nibble is it's own character (UNICODE)
    //

    while (++dwSrcCount <= dwSrcLen) {

        wch = ( (*pbSrcData) & 0xF0 ) >> 4;

        *(pszDestPtr++) = HexToWCharTable[wch];

        wch = (*(pbSrcData++)) & 0x0F;

        *(pszDestPtr++) = HexToWCharTable[wch];
    }

    *pszDestPtr = '\0';

    *ppszDestData = pszDest; 

    RRETURN (S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  getobj.cxx
//
//  Contents:  ADs Wrapper Function to mimic Visual Basic's GetObject
//
//
//  History:   11-15-95     krishnag    Created.
//             07-12-96     t-danal     Added path validation.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

BOOL
IsPathOfProgId(
    LPWSTR ProgId,
    LPWSTR Path
    );

BOOL
IsADsProgId(
    LPWSTR Path
    );

//+---------------------------------------------------------------------------
//  Function:  ADsGetObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    07-12-95   t-danal      Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsGetObject(
    LPCWSTR lpszPathName,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    HRESULT hr;

    hr = GetObject((LPWSTR)lpszPathName,
                   riid,
                   ppObject,
                   FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//              [BOOL Generic]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-03-95   krishnag     Created.
//              07-12-95   t-danal      Added router verification and
//                                      renamed from ADsGetObject
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR lpszPathName,
    REFIID riid,
    void FAR * FAR * ppObject,
    BOOL bRelative
    )
{
    HRESULT hr;
    ULONG chEaten = 0L;
    IMoniker * pMoniker = NULL;
    IBindCtx *pbc = NULL;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);
    
    
    PROUTER_ENTRY lpRouter = g_pRouterHead;

    if (bRelative || !IsADsProgId(lpszPathName)) {

        //
        // Check if the Path matches with ProviderProgId or the Aliases
        //

        while (lpRouter &&
               (!IsPathOfProgId(lpRouter->szProviderProgId, lpszPathName) &&
               !IsPathOfProgId(lpRouter->szAliases, lpszPathName)))
            lpRouter = lpRouter->pNext;

        if (!lpRouter)
            RRETURN(E_FAIL);
    }

    hr = CreateBindCtx(0, &pbc);
    BAIL_IF_ERROR(hr);

    hr = MkParseDisplayName(pbc,
                            lpszPathName,
                            &chEaten,
                            &pMoniker);
    BAIL_IF_ERROR(hr);

    hr = pMoniker->BindToObject(pbc,  NULL, riid, ppObject);
    BAIL_IF_ERROR(hr);

cleanup:
    if (pbc) {
        pbc->Release();
    }

    if (pMoniker) {
        pMoniker->Release();
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:   IsPathOfProgId
//
//  Synopsis:   Checks if an OLE Path corresponds to given ProgId.
//              Path must be @Foo! or Foo: style.
//
//  Arguments:  [LPWSTR ProgId]
//              [LPWSTR Path]
//
//  Returns:    BOOL
//
//  Modifies:    -
//
//  History:    07-12-95  t-danal     Created
//
//----------------------------------------------------------------------------
BOOL
IsPathOfProgId(
    LPWSTR ProgId,
    LPWSTR Path
    )
{
    if (!ProgId || !Path)  // Just in case...
        return FALSE;

    if (*Path == L'@')
        Path++;

    if(wcsncmp(ProgId, Path, wcslen(ProgId)))
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//  Function:   IsADsProgId
//
//  Synopsis:   Checks if the ProgIds of paths is ADs progid.
//              Paths must be @Foo! or Foo: style.
//
//  Arguments:  [LPWSTR Path]
//
//  Returns:    BOOL
//
//  Modifies:    -
//
//  History:    07-12-95  t-danal     Created
//
//----------------------------------------------------------------------------
BOOL
IsADsProgId(
    LPWSTR Path
    )
{
    int cch = 0;
    LPWSTR pEnd;

    if (!Path)
        return FALSE;

    if (*Path == L'@')
        Path++;

    pEnd = Path;
    while (*pEnd &&
           *pEnd != L'!' &&
           *pEnd != L':') {
        pEnd++;
    }

    if (_wcsnicmp(L"ADS", Path, (int)(pEnd-Path)))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\dbid.h ===
//------------------------------------------------------------------------------
//
//  Microsoft Sidewalk
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       oledbhelp.h
//
//  Contents:   OLE DB helper methods
//
//  Owner:      BassamT
//														 
//  History:    11/30/97   BassamT	Created.
//
//------------------------------------------------------------------------------
#if (!defined(BUILD_FOR_NT40))
#pragma once

//
// typedefs
//


// Column Number (cn). This number starts at 1.
typedef ULONG CNUM;

// Row number (rn). These numbers start at 0.
typedef ULONG RNUM;

// Offset (in bytes) into a structure or buffer (ob)
typedef DWORD OFFSET;

// Bookmark data type (bmk)
typedef ULONG BOOKMARK;


//
// constants that can be tuned for performance
//

// The maximum number of bytes to store inline for variable size data types.
const UINT k_cbInlineMax = 100;

// the number of rows to fetch at once.
const ULONG k_RowFetchCount = 20;

// Column alignment within a row.
// TODO : Should this be sizeof(DWORD) instead ?
const DWORD k_ColumnAlign = 8;



//
// constants
//

// invalid row number
const CNUM CNUM_INVALID = 0xFFFFFFFF;

// invalid row number
const RNUM RNUM_INVALID = 0xFFFFFFFF;

//
// conversion helpers
//
const UINT k_cchUCHARAsDecimalString = sizeof("255") - 1;
const UINT k_cchUSHORTAsDecimalString = sizeof("32767") - 1;
const UINT k_cchUINTAsDecimalString = sizeof("4294967294") - 1;
const UINT k_cchUINTAsHexString = sizeof("FFFFFFFF") - 1;
const UINT k_cchINTAsDecimalString = sizeof("-2147483648") - 1;
const UINT k_cchBOOLAsDecimalString = sizeof("1") - 1;
const UINT k_cchDOUBLEAsDecimalString = sizeof("2.2250738585072014 E + 308") - 1;

//
// macros
//
#define static_wcslen(pwsz) ((sizeof(pwsz) / sizeof(WCHAR)) - 1)

#define inrange(z,zmin,zmax) ( (zmin) <= (z) && (z) <= (zmax) )


#define DBID_USE_GUID_OR_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_GUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID ))

#define DBID_USE_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_NAME(e) \
	((1<<(e)) & \
	( 1<<DBKIND_NAME \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_PGUID_NAME ))

#define DBID_USE_PROPID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PROPID \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_IS_BOOKMARK(dbid) \
	(  DBID_USE_GUID(dbid.eKind)  &&  dbid.uGuid.guid  == DBCOL_SPECIALCOL \
	|| DBID_USE_PGUID(dbid.eKind) && *dbid.uGuid.pguid == DBCOL_SPECIALCOL )

#define SET_DBID_FROM_NAME(dbid, pwsz) \
	dbid.eKind = DBKIND_NAME;\
	dbid.uName.pwszName = pwsz;

#define IsBadPointer(v) (IsBadReadPtr((void*)hAccessor, sizeof(void*)))

//
// functions
//

inline DWORD RoundDown(DWORD dwSize, DWORD dwAmount)
{
	return dwSize & ~(dwAmount - 1);
}

inline DWORD RoundUp(DWORD dwSize, DWORD dwAmount)
{
	return (dwSize +  (dwAmount - 1)) & ~(dwAmount - 1);
}

#define CLIENT_MALLOC(cb) (CoTaskMemAlloc(cb))
#define CLIENT_FREE(x) (CoTaskMemFree(x), x = NULL)

HRESULT CopyDBIDs(DBID * pdbidDest,	const DBID *pdbidSrc);
BOOL CompareDBIDs(const DBID *pdbid1, const DBID *pdbid2);
HRESULT IsValidDBID(const DBID *pdbid);
void FreeDBID(DBID *pdbid);

INT CompareOLEDBTypes(DBTYPE wType, void * pvValue1, void * pvValue2);


inline BOOL IsColumnVarLength
//------------------------------------------------------------------------------
// return TRUE if the column is of a variable length type
(
	DBTYPE wType
)
{
	if (wType == DBTYPE_BSTR ||
		wType == DBTYPE_STR ||
		wType == DBTYPE_WSTR ||
		wType == DBTYPE_BYTES)
	{
		return TRUE;
	}

	return FALSE;
}


inline DWORD AdjustVariableTypesLength
//------------------------------------------------------------------------------
// adjusts the length of variable length data types
(
	DBTYPE wType,
	DWORD cb
)
{

	if (wType == DBTYPE_STR)
	{
		return cb + 1;
	}
	
	if (wType == DBTYPE_WSTR)
	{
		return cb + sizeof(WCHAR);
	}
	
	return cb;
}

inline USHORT GetColumnMaxPrecision
//------------------------------------------------------------------------------
// returns the maximium possible precision of a column, given its type.
// Do not pass a byref, array, or vector column type.
(
	DBTYPE wType
	// [in] the OLE DB data type
)
{
	if ((wType & DBTYPE_BYREF) ||
		(wType & DBTYPE_ARRAY) ||
		(wType & DBTYPE_VECTOR))
	{
        Assert (FALSE);
		return 0;
	}

	switch( wType )
	{
    case DBTYPE_I1:
    case DBTYPE_UI1:
        return 3;

	case DBTYPE_I2:
	case DBTYPE_UI2:
		return 5;

	case DBTYPE_I4:
	case DBTYPE_UI4:
		return 10;

	case DBTYPE_R4:
        return 7;

	case DBTYPE_I8:
        return 19;

	case DBTYPE_UI8:
        return 20;

	case DBTYPE_R8:
        return 16;

	case DBTYPE_DATE:
		return 8;

	case DBTYPE_CY:
		return 19;

	case DBTYPE_DECIMAL:
        return 28;

	case DBTYPE_NUMERIC:
		return 38;

	case DBTYPE_EMPTY:
	case DBTYPE_NULL:
	case DBTYPE_ERROR:
	case DBTYPE_BOOL:
	case DBTYPE_BSTR:
	case DBTYPE_IDISPATCH:
	case DBTYPE_IUNKNOWN:
	case DBTYPE_VARIANT:
	case DBTYPE_GUID:
	case DBTYPE_BYTES:
	case DBTYPE_STR:
	case DBTYPE_WSTR:
	case DBTYPE_DBDATE:
	case DBTYPE_DBTIME:
	case DBTYPE_DBTIMESTAMP:
	case DBTYPE_HCHAPTER:
        return 0;

	default:
		Assert (FALSE && "Unsupported data type");
		return 0;
	}
}

inline ULONG GetColumnSize
//------------------------------------------------------------------------------
// returns the size of the column in bytes
(
	DBTYPE wType,
	// [in] the OLE DB data type
	DWORD cchMaxLength
	// [in] if this is a variable size field then this is the max length
	//		if there is one defined. Otherwise this is 0xFFFFFFFF
)
{
	// Handle BYREF destination separately
	if ((wType & DBTYPE_BYREF) ||
		(wType & DBTYPE_ARRAY) ||
		(wType & DBTYPE_VECTOR))
	{
		return sizeof(void*);
	}

	switch( wType )
	{
	case DBTYPE_EMPTY:
	case DBTYPE_NULL:
		return 0;

	case DBTYPE_I2:
	case DBTYPE_UI2:
		return 2;

	case DBTYPE_I4:
	case DBTYPE_R4:
	case DBTYPE_UI4:
		return 4;

	case DBTYPE_I8:
	case DBTYPE_R8:
	case DBTYPE_DATE:
	case DBTYPE_UI8:
		return 8;

	case DBTYPE_ERROR:
		return sizeof(SCODE);

	case DBTYPE_BOOL:
		return sizeof(VARIANT_BOOL);

	case DBTYPE_CY:
		return sizeof(CY);

	case DBTYPE_BSTR:
		return sizeof(BSTR);

	case DBTYPE_IDISPATCH:
		return sizeof(IDispatch*);

	case DBTYPE_IUNKNOWN:
		return sizeof(IUnknown*);

	case DBTYPE_VARIANT:
		return sizeof(VARIANT);

	case DBTYPE_DECIMAL:
		return sizeof(DECIMAL);

	case DBTYPE_I1:
	case DBTYPE_UI1:
		return 1;

	case DBTYPE_GUID:
		return sizeof(GUID);

	case DBTYPE_BYTES:
		return cchMaxLength;

	case DBTYPE_STR:
		return cchMaxLength * sizeof(char);

	case DBTYPE_WSTR:
		return cchMaxLength * sizeof(WCHAR);

	case DBTYPE_NUMERIC:
		return sizeof(DB_NUMERIC);

	case DBTYPE_DBDATE:
		return sizeof(DBDATE);

	case DBTYPE_DBTIME:
		return sizeof(DBTIME);

	case DBTYPE_DBTIMESTAMP:
		return sizeof(DBTIMESTAMP);

	case DBTYPE_HCHAPTER:
		return sizeof(HCHAPTER);

	default:
		Assert (FALSE && "Unsupported data type");
		return 0;
	}
}

//
// IUnknown Macros
//

// put this macros in your class definition. Make sure that 
// you inherit from IUnknown and that you use the 
// INIT_IUNKNOWN macro in your class constructor
#define DEFINE_IUNKNOWN \
private:\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return InternalQueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}

#define INIT_IUNKNOWN	_cRefs = 1;

#define DEFINE_IUNKNOWN_WITH_CALLBACK(x) \
private:\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return InternalQueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			x();\
			return 0;\
		}\
		return _cRefs;\
	}


// put this macros in your class definition. Make sure that 
// you inherit from IUnknown and that you use the 
// INIT_AGGREGATE_IUNKNOWN macro in your class constructor.
// Also make sure that you use SET_OUTER_IUNKNOWN in wherever
// you get a pointer to the Outer IUnknown
interface INonDelegatingUnknown
{
    virtual HRESULT STDMETHODCALLTYPE NonDelegatingQueryInterface
	( 
        REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject
	) = 0;
    virtual ULONG STDMETHODCALLTYPE NonDelegatingAddRef(void) = 0;
    virtual ULONG STDMETHODCALLTYPE NonDelegatingRelease(void) = 0;
};

#define DEFINE_AGGREGATE_IUNKNOWN \
private:\
	IUnknown * _punkOuter;\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv)\
	{\
		if (ppv == NULL) return E_INVALIDARG;\
		if (riid != IID_IUnknown)\
		{\
			return InternalQueryInterface(riid, ppv);\
		}\
		else\
		{\
			*ppv = static_cast<INonDelegatingUnknown*>(this);\
			NonDelegatingAddRef();\
			return NOERROR;\
		}\
	}\
	STDMETHOD_(ULONG,NonDelegatingAddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,NonDelegatingRelease)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return _punkOuter->QueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return _punkOuter->AddRef();\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		return _punkOuter->Release();\
	}

#define INIT_AGGREGATE_IUNKNOWN	\
	_punkOuter = reinterpret_cast<IUnknown*>(static_cast<INonDelegatingUnknown*>(this)); \
	_cRefs = 1;

#define SET_OUTER_IUNKNOWN(punk)	if (punk != NULL) _punkOuter = punk;


#define DEFINE_AGGREGATE_IUNKNOWN_WITH_CALLBACKS(_AddRef, _Release) \
private:\
	IUnknown * _punkOuter;\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv)\
	{\
		if (ppv == NULL) return E_INVALIDARG;\
		if (riid != IID_IUnknown)\
		{\
			return InternalQueryInterface(riid, ppv);\
		}\
		else\
		{\
			*ppv = static_cast<INonDelegatingUnknown*>(this);\
			NonDelegatingAddRef();\
			return NOERROR;\
		}\
	}\
	STDMETHOD_(ULONG,NonDelegatingAddRef)() \
	{\
		_AddRef();\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,NonDelegatingRelease)()\
	{\
		_Release();\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return _punkOuter->QueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return _punkOuter->AddRef();\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		return _punkOuter->Release();\
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\guid.c ===
#define INITGUID

#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADS CLSIDs
//
//--------------------------------------------------------------------------


DEFINE_GUID(CLSID_ADsNamespaces,0x233664B0L,0x0367,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_ADsProvider,0x4753DA60L,0x5B71,0x11CF,0xB0,0x35,0x00,0xAA,0x00,0x6E,0x09,0x75);

// {E0FA581D-2188-11d2-A739-00C04FA377A1}
DEFINE_GUID(CLSID_ADSI_BINDER,0xe0fa581d, 0x2188, 0x11d2, 0xa7, 0x39, 0x0, 0xc0, 0x4f, 0xa3, 0x77, 0xa1);

// {04EE4CBB-21B6-11d2-A739-00C04FA377A1}
DEFINE_GUID(CLSID_Row, 0x4ee4cbb, 0x21b6, 0x11d2, 0xa7, 0x39, 0x0, 0xc0, 0x4f, 0xa3, 0x77, 0xa1);

//------------------------------------------------------------------------
//  GUIDS that come out of oleds.tlb.
//------------------------------------------------------------------------

DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

DEFINE_GUID( IID_IRowProvider, 0x36576d80, 0xe5bc, 0x11cf, 0xa4, 0x8, 0x0, 0xc0, 0x4f, 0xd6, 0x11, 0xd0);

DEFINE_GUID( DBPROPSET_TEMPTABLE, 0x4e4c0950L,0xe5a8,0x11cf,0xa4,0x08,0x00,0xc0,0x4f,0xd6,0x11,0xd0);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\guid25.cxx ===
#include "oleds.hxx"

//--------------------------------------------------------------------------
//  OLE DB 2.5 interface constants
//--------------------------------------------------------------------------
//EXTERN_C const IID IID_IBindResource            = __uuidof(IBindResource);
//EXTERN_C const IID IID_ICreateRow               = __uuidof(ICreateRow);
//EXTERN_C const IID IID_IRow                     = __uuidof(IRow);
//EXTERN_C const IID IID_IRowChange               = __uuidof(IRowChange);
//EXTERN_C const IID IID_IRowSchemaChange         = __uuidof(IRowSchemaChange);
//EXTERN_C const IID IID_IColumnsInfo2            = __uuidof(IColumnsInfo2);
//EXTERN_C const IID IID_IGetRow                  = __uuidof(IGetRow);
//EXTERN_C const IID IID_IScopedOperations        = __uuidof(IScopedOperations);
//EXTERN_C const IID IID_IDBBinderProperties      = __uuidof(IDBBinderProperties);
//EXTERN_C const IID IID_IGetSourceRow            = __uuidof(IGetSourceRow);
//EXTERN_C const IID IID_IGetSession              = __uuidof(IGetSession);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\


#define INVALID_CREDENTIALS_ERROR(hr) \
                (   hr == HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE)         ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)         ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_AUTH) ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN)       ||    \
                    hr == DB_SEC_E_PERMISSIONDENIED)

#define LIMIT_EXCEEDED_ERROR(hr) \
                (   hr == HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED) ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED))

#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}




#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                                   \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for ADs guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// ADs CLSIDs
//
//-------------------------------------------

extern const CLSID CLSID_ADsNamespaces;

extern const CLSID CLSID_ADsProvider;

extern const CLSID CLSID_ADSI_BINDER;

extern const CLSID CLSID_Row;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\libmain.cxx ===
#include "oleds.hxx"
#include "bindercf.hxx"
#include "atlbase.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

HINSTANCE g_hInst = NULL;
PROUTER_ENTRY g_pRouterHead = NULL;
CRITICAL_SECTION g_csRouterHeadCritSect;
//
// Dll's we load dynamically.
//
extern HANDLE g_hDllAdvapi32;

extern const GUID DBGUID_ROOTBINDER  =
{0xFF151822, 0xB0BF, 0x11D1, {0xA8, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"ADs",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"ADs",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"ADs",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

// Globals


ULONG g_ulObjCount = 0; // Number of objects alivein ADs.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from formsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))


//+------------------------------------------------------------------------
//
//  ADs class factories
//
//-------------------------------------------------------------------------

CADsNamespacesCF             g_cfNamespaces;
CADsProviderCF               g_cfProvider;
CDSOCF                       g_cfDSO;
CADsSecurityDescriptorCF     g_cfSed;
CADsAccessControlListCF      g_cfAcl;
CADsAccessControlEntryCF     g_cfAce;
CADsPropertyEntryCF          g_cfPropEntry;
CADsPropertyValueCF          g_cfPropertyValue;
CADsLargeIntegerCF           g_cfLargeInteger;
CADsBinderCF                 g_cfBinder;
CPathnameCF                  g_cfPathname;
CADsDNWithBinaryCF           g_cfDNWithBinary;
CADsDNWithStringCF           g_cfDNWithString;
CADsSecurityUtilityCF        g_cfADsSecurityUtility;

extern CRITICAL_SECTION g_DispTypeInfoCritSect;
extern CRITICAL_SECTION g_StringsCriticalSection;

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_ADsNamespaces,                        &g_cfNamespaces,
    &CLSID_ADsProvider,                          &g_cfProvider,
    &CLSID_ADsDSOObject,                         &g_cfDSO,
    &CLSID_SecurityDescriptor,                   &g_cfSed,
    &CLSID_AccessControlList,                    &g_cfAcl,
    &CLSID_AccessControlEntry,                   &g_cfAce,
    &CLSID_PropertyEntry,                        &g_cfPropEntry,
    &CLSID_PropertyValue,                        &g_cfPropertyValue,
    &CLSID_LargeInteger,                         &g_cfLargeInteger,
    &CLSID_ADSI_BINDER,                          &g_cfBinder,
    &CLSID_Pathname,                             &g_cfPathname,
    &CLSID_DNWithBinary,                         &g_cfDNWithBinary,
    &CLSID_DNWithString,                         &g_cfDNWithString,
    &CLSID_ADsSecurityUtility,                   &g_cfADsSecurityUtility
};

//------------------------------------------------------------------------
// ATL Module definition
//------------------------------------------------------------------------
CComModule _Module;

//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    *ppv = NULL;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the ADs.DllGetClassObject
    // has been called with an unknown CLSID.
    //

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (DllReadyToUnload())
        hr = S_OK;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to put in try catch block as init crit sects can fail.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT); // Used by Object Tracker
            InitializeCriticalSection(&g_csMem); // Used by Object Tracker
#endif
            InitializeCriticalSection(&g_csDP); // Used by ADsDebug
#endif

            InitializeCriticalSection(&g_DispTypeInfoCritSect);

            InitializeCriticalSection(&g_StringsCriticalSection);

            InitializeCriticalSection(&g_csRouterHeadCritSect); // router initialization

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:
        if (g_pRouterHead) {
            CleanupRouter(g_pRouterHead);
        }
        FreeTypeInfoTable();

        //
        // Delete the cs we inited.
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT); // Used by Object Tracker
        DeleteCriticalSection(&g_csMem); // Used by Object Tracker
#endif
        DeleteCriticalSection(&g_csDP); // Used by ADsDebug
#endif

        DeleteCriticalSection(&g_DispTypeInfoCritSect);
        DeleteCriticalSection(&g_StringsCriticalSection);
        DeleteCriticalSection(&g_csRouterHeadCritSect);
                //
        // Free any libs we loaded using loadlibrary
        //
        if (g_hDllAdvapi32) {
            FreeLibrary((HMODULE) g_hDllAdvapi32);
            g_hDllAdvapi32 = NULL;
        }

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}

STDAPI DllRegisterServer()
{
    PWCHAR pwszClsid = NULL;
    WCHAR  pwszSubKey[256];
    HRESULT hr = S_OK;
#if (!defined(BUILD_FOR_NT40))
    auto_rel<IRegisterProvider> pRegisterProvider;
    wcscpy(pwszSubKey, L"SOFTWARE\\Classes\\CLSID\\");
    hr = StringFromCLSID(CLSID_ADSI_BINDER, &pwszClsid);
    if (FAILED(hr))
        return hr;
    wcscat(pwszSubKey, pwszClsid);

    HKEY hKeyClsid = NULL, hKeyDll = NULL;
    DWORD dwDisposition;
    LONG lRetVal;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    //Create CLSID entry
    lRetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             pwszSubKey,
                             0,
                             L"",
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKeyClsid,
                             &dwDisposition);

    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //set the value
    lRetVal = RegSetValueEx(hKeyClsid,
                            NULL,
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"Provider Binder for DS OLE DB Provider",
                            78);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Create InprocServer32 entry
    lRetVal = RegCreateKeyEx(hKeyClsid,
                             L"InprocServer32",
                             0,
                             L"activeds.dll",
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKeyDll,
                             &dwDisposition);

    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //set the value
    lRetVal = RegSetValueEx(hKeyDll,
                            NULL,
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"activeds.dll",
                            26);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now set the threadingModel value for the dll key
    lRetVal = RegSetValueEx(hKeyDll,
                            L"ThreadingModel",
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"Both",
                            10);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now register the provider with the root binder.
    //Cocreate Root Binder and get IRegisterProvider interface.
    hr = CoCreateInstance ( DBGUID_ROOTBINDER,
                            NULL,
                            CLSCTX_ALL,
                            __uuidof(IRegisterProvider),
                            (void **) &pRegisterProvider
                            );

    if (SUCCEEDED(hr))
    {
        // Go through list of ADS providers and register each of them
        // with the root binder.
        for ( PROUTER_ENTRY pProvider = g_pRouterHead;
              pProvider != NULL;
              pProvider=pProvider->pNext)
        {
            // Invalid provider ProgID? If so, continue with next provider
            if (NULL == pProvider->szProviderProgId)
                continue;

            hr = pRegisterProvider->SetURLMapping(
                pProvider->szProviderProgId,
                0,
                CLSID_ADSI_BINDER);
            if (FAILED(hr))
                AtlTrace(_T("Failed to register %s mapping hr = %x\n"),
                         pProvider->szProviderProgId, hr);

            // Ignore error and continue with next provider
            hr = S_OK;
        }
    }
    else
    {
        AtlTrace(_T("Creation of Root Binder failed! hr = %x\n"), hr);
    }

error:
    CoTaskMemFree(pwszClsid);
    if (hKeyClsid) {
        RegCloseKey(hKeyClsid);
    }

    if (hKeyDll) {
        RegCloseKey(hKeyDll);
    }

#endif

    return hr;
}

STDAPI DllUnregisterServer()
{
    PWCHAR   pwszClsid = NULL;
    WCHAR    pwszClsidKey[256];
    WCHAR    pwszDllKey[256];
    HRESULT  hr = S_OK;
    LONG     lRetVal;
#if (!defined(BUILD_FOR_NT40))
    auto_rel<IRegisterProvider> pRegisterProvider;
    wcscpy(pwszClsidKey, L"SOFTWARE\\Classes\\CLSID\\");
    hr = StringFromCLSID(CLSID_ADSI_BINDER, &pwszClsid);
    if (FAILED(hr))
        return hr;
    wcscat(pwszClsidKey, pwszClsid);

    wcscpy(pwszDllKey, pwszClsidKey);
    wcscat(pwszDllKey, L"\\InprocServer32");

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    //Delete InprocServer32 key
    lRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, pwszDllKey);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Delete key and all its subkeys.
    lRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, pwszClsidKey);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now unregister provider binder from Root Binder.
    //Cocreate Root Binder and get IRegisterProvider interface.
    hr = CoCreateInstance ( DBGUID_ROOTBINDER,
                            NULL,
                            CLSCTX_ALL,
                            __uuidof(IRegisterProvider),
                            (void **) &pRegisterProvider
                            );

    if (SUCCEEDED(hr))
    {
        // Unregister each provider with the root binder
        for ( PROUTER_ENTRY pProvider = g_pRouterHead;
              pProvider != NULL;
              pProvider=pProvider->pNext)
        {
            // Invalid provider ProgID? If so, continue with next provider
            if (NULL == pProvider->szProviderProgId)
                continue;

            pRegisterProvider->UnregisterProvider(
                    pProvider->szProviderProgId,
                    0,
                    CLSID_ADSI_BINDER);
        }
    }

error:
    CoTaskMemFree(pwszClsid);

#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\oledbutl.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  oledbutl.cpp
//
//  Contents:
//
//
//  History:   07/10/96   RenatoB    Created, lifted  from EricJ code
//
//-----------------------------------------------------------------------------


// Includes
#include "oleds.hxx"

// All the '256's below should be 4 (the length of a pointer to a string). Because
// of a bug in the TempTable, this has been temporarily done.
//
// Note: Provider-specific types are returned as octet strings
//
MAPTYPE_STRUCT g_MapADsTypeToDBType[] = {
    {DBTYPE_NULL,                 0},         /* ADSTYPE_INVALID = 0,        */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_DN_STRING,          */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_EXACT_STRING,  */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_IGNORE_STRING, */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_PRINTABLE_STRING,   */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_NUMERIC_STRING,     */
    {DBTYPE_BOOL,                 2},         /* ADSTYPE_BOOLEAN,            */
    {DBTYPE_I4,                   4},         /* ADSTYPE_INTEGER,            */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_OCTET_STRING,       */
    {DBTYPE_DATE,                 8},         /* ADSTYPE_UTC_TIME,           */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16},        /* ADSTYPE_LARGE_INTEGER,      */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_PROV_SPECIFIC       */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_OBJECT_CLASS,       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_CASEIGNORE_LIST     */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_OCTET_LIST          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_PATH                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_POSTALADDRESS       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TIMESTAMP           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_BACKLINK            */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TYPEDNAME           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_HOLD                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_NETADDRESS          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_REPLICAPOINTER      */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_FAXNUMBER           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_EMAIL               */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_NT_SECURITY_DESC    */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_UNKNOWN             */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16},        /* ADSTYPE_DN_WITH_BINARY      */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16}         /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToDBType = (sizeof(g_MapADsTypeToDBType) /
                                sizeof(g_MapADsTypeToDBType[0]));

// The row object does not use IDirectorySearch when a direct bind or SELECT
// * happens. In this case, it uses IADs::Get. It is possible that a variant
// with VT_DISPATCH may be returned in this case - for ADSTYPE_NT_SECURITY_DESC
// DNWithBin or DNWithStr. In this case, they cannot be converted to any other
// DBTYPE. So, they will be returned as DBTYPE_VARIANT. 
MAPTYPE_STRUCT g_MapADsTypeToDBType2[] = {
    {DBTYPE_NULL,                 0},         /* ADSTYPE_INVALID = 0,        */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_DN_STRING,          */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_EXACT_STRING,  */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_IGNORE_STRING, */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_PRINTABLE_STRING,   */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_NUMERIC_STRING,     */
    {DBTYPE_BOOL,                 2},         /* ADSTYPE_BOOLEAN,            */
    {DBTYPE_I4,                   4},         /* ADSTYPE_INTEGER,            */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_OCTET_STRING,       */
    {DBTYPE_DATE,                 8},         /* ADSTYPE_UTC_TIME,           */
    {DBTYPE_VARIANT,              16},        /* ADSTYPE_LARGE_INTEGER,      */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_PROV_SPECIFIC       */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_OBJECT_CLASS,       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_CASEIGNORE_LIST     */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_OCTET_LIST          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_PATH                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_POSTALADDRESS       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TIMESTAMP           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_BACKLINK            */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TYPEDNAME           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_HOLD                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_NETADDRESS          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_REPLICAPOINTER      */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_FAXNUMBER           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_EMAIL               */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_NT_SECURITY_DESC    */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_UNKNOWN             */
    {DBTYPE_VARIANT,              16},        /* ADSTYPE_DN_WITH_BINARY      */
    {DBTYPE_VARIANT,              16}         /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToDBType2 = (sizeof(g_MapADsTypeToDBType2) /
                                sizeof(g_MapADsTypeToDBType2[0]));

VARTYPE g_MapADsTypeToVarType[] = {
    VT_NULL,           /* ADSTYPE_INVALID = 0,        */
    VT_BSTR,           /* ADSTYPE_DN_STRING,          */
    VT_BSTR,           /* ADSTYPE_CASE_EXACT_STRING,  */
    VT_BSTR,           /* ADSTYPE_CASE_IGNORE_STRING, */
    VT_BSTR,           /* ADSTYPE_PRINTABLE_STRING,   */
    VT_BSTR,           /* ADSTYPE_NUMERIC_STRING,     */
    VT_BOOL,           /* ADSTYPE_BOOLEAN,            */
    VT_I4,             /* ADSTYPE_INTEGER,            */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_OCTET_STRING,       */
    VT_DATE,           /* ADSTYPE_UTC_TIME,           */
    VT_DISPATCH,       /* ADSTYPE_LARGE_INTEGER,      */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_PROV_SPECIFIC       */
    VT_BSTR,           /* ADSTYPE_OBJECT_CLASS        */
    VT_NULL,           /* ADSTYPE_CASEIGNORE_LIST     */
    VT_NULL,           /* ADSTYPE_OCTET_LIST          */
    VT_NULL,           /* ADSTYPE_PATH                */
    VT_NULL,           /* ADSTYPE_POSTALADDRESS       */
    VT_NULL,           /* ADSTYPE_TIMESTAMP           */
    VT_NULL,           /* ADSTYPE_BACKLINK            */
    VT_NULL,           /* ADSTYPE_TYPEDNAME           */
    VT_NULL,           /* ADSTYPE_HOLD                */
    VT_NULL,           /* ADSTYPE_NETADDRESS          */
    VT_NULL,           /* ADSTYPE_REPLICAPOINTER      */
    VT_NULL,           /* ADSTYPE_FAXNUMBER           */
    VT_NULL,           /* ADSTYPE_EMAIL               */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_NT_SECURITY_DESC    */
    VT_NULL,           /* ADSTYPE_UNKNOWN             */
    VT_DISPATCH,       /* ADSTYPE_DN_WITH_BINARY      */
    VT_DISPATCH        /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToVarType = (sizeof(g_MapADsTypeToVarType) /
                                sizeof(g_MapADsTypeToVarType[0]));


ADS_SEARCHPREF g_MapDBPropIdToSearchPref[] = {
    ADS_SEARCHPREF_ASYNCHRONOUS,
    ADS_SEARCHPREF_DEREF_ALIASES,
    ADS_SEARCHPREF_SIZE_LIMIT,
    ADS_SEARCHPREF_TIME_LIMIT,
    ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
    ADS_SEARCHPREF_SEARCH_SCOPE,
    ADS_SEARCHPREF_TIMEOUT,
    ADS_SEARCHPREF_PAGESIZE,
    ADS_SEARCHPREF_PAGED_TIME_LIMIT,
    ADS_SEARCHPREF_CHASE_REFERRALS,
    ADS_SEARCHPREF_SORT_ON,
    ADS_SEARCHPREF_CACHE_RESULTS
};

DWORD g_cMapDBPropToSearchPref = (sizeof(g_MapDBPropIdToSearchPref) /
                                  sizeof(g_MapDBPropIdToSearchPref[0]));

//+---------------------------------------------------------------------------
//
//  Function:  CpAccessors2Rowset
//
//  Synopsis:  @ffunc Implements inheritance of Accessors. Copies to
//             a Rowset the accessors existing on the command
//
//             Called by:    CRowset::Finit
//             Called when:    At runtime.
//             Overridden:    No.  (Private)
//  Arguments:
//
//
//  Returns:    @rdesc HRESULT
//              @flag S_OK  | OK
//              @flag E_OUTOFMEMORY |could not get IMalloc
//              @flag E_FAIL| An accessor could not be created
//
//----------------------------------------------------------------------------

HRESULT
CpAccessors2Rowset(
    IAccessor     *pAccessorCommand, //@parm IN |Command's IAccessor
    IAccessor     *pAccessorRowset,  //@parm IN |Rowset's IAccessor
    ULONG          cAccessors,       //@parm IN |Count,Commnands accessors
    HACCESSOR      rgAccessors[],    //@parm IN |Array,Command's accessors
    CImpIAccessor  *pCAccessor       //accessor object of rowset
    )
{
    HRESULT         hr;
    IMalloc *       pMalloc = NULL;
    DBCOUNTITEM     cBindings;
    DBBINDING *     pBindings = NULL;
    DBBINDSTATUS *  prgBindStatus = NULL;
    ULONG           i,j;
    DBACCESSORFLAGS AccessorFlags;
    HACCESSOR       hAccessor;

    hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
    BAIL_ON_FAILURE(hr);

    //for each of the command's accessors,
    // we create a Rowset accessor.
    // if anyone fails, return E_FAIL

    for (i=0; i<cAccessors; i++) {
        AccessorFlags = 0;
        hr=pAccessorCommand->GetBindings(
            rgAccessors[i],
            &AccessorFlags,
            &cBindings,
            &pBindings
            );

        // Not a valid accessor handle
        if (hr == DB_E_BADACCESSORHANDLE) {
            // Rowset will also inherit the bad accessor
            hr = pCAccessor->CreateBadAccessor();
            BAIL_ON_FAILURE( hr );

            continue;
        }
        BAIL_ON_FAILURE( hr );

        // Allocate memory for the Status values
        prgBindStatus = (DBBINDSTATUS*) pMalloc->Alloc((ULONG)(cBindings *
                                                       sizeof(DBBINDSTATUS)));

        hr=pAccessorRowset->CreateAccessor(
            AccessorFlags,
            cBindings,
            pBindings,
            0,
            &hAccessor,
            prgBindStatus
            );

        //
        // If CreateAccessor fails fixup DB_E_ERRORSOCCURRED
        //
        if (hr == DB_E_ERRORSOCCURRED ) {
            // Fixup the HResult
            for(j=0; j < cBindings; j++) {
                switch (prgBindStatus[j])
                {
                    case DBBINDSTATUS_NOINTERFACE:
                        BAIL_ON_FAILURE( hr=E_NOINTERFACE );

                    case DBBINDSTATUS_BADBINDINFO:
                        BAIL_ON_FAILURE( hr=DB_E_BADBINDINFO );

                    case DBBINDSTATUS_BADORDINAL:
                        BAIL_ON_FAILURE( hr=DB_E_BADORDINAL );

                    case DBBINDSTATUS_BADSTORAGEFLAGS:
                        BAIL_ON_FAILURE( hr=DB_E_BADSTORAGEFLAGS );

                    case DBBINDSTATUS_UNSUPPORTEDCONVERSION:
                        BAIL_ON_FAILURE( hr=DB_E_UNSUPPORTEDCONVERSION );

                    case DBBINDSTATUS_MULTIPLESTORAGE:
                        BAIL_ON_FAILURE( hr=DB_E_MULTIPLESTORAGE );

                    case DBBINDSTATUS_OK:
                    default:
                        hr=E_FAIL;
                        break;
                }
            }
            // Should never be E_FAIL
            ADsAssert(hr != E_FAIL);
        }
        BAIL_ON_FAILURE( hr );

        if( pBindings )
            pMalloc->Free(pBindings);
        pBindings = NULL;

        if( prgBindStatus )
            pMalloc->Free(prgBindStatus);
        prgBindStatus = NULL;
    };

error:

    if( pBindings )
        pMalloc->Free(pBindings);
    if( prgBindStatus )
        pMalloc->Free(prgBindStatus);
    pMalloc->Release();

    RRETURN( hr );
}


HRESULT
GetDSInterface(
    LPWSTR lpszPath,
    CCredentials& Credentials,
    REFIID iid,
    void FAR * FAR * ppObject
    )
{
    HRESULT hr = E_FAIL;
    LPWSTR      lpszUserName=NULL, lpszPassword=NULL;
    DWORD       dwAuthFlags = 0;

    hr = Credentials.GetUserName(&lpszUserName);
    BAIL_ON_FAILURE( hr );

    hr = Credentials.GetPassword(&lpszPassword);
    BAIL_ON_FAILURE( hr );

    dwAuthFlags = Credentials.GetAuthFlags();

    hr = ADsOpenObject(
                        lpszPath,
                        lpszUserName,
                        lpszPassword,
                        dwAuthFlags,
                        iid,
                        ppObject
                        );

    if( INVALID_CREDENTIALS_ERROR(hr) )
        BAIL_ON_FAILURE( hr=DB_SEC_E_PERMISSIONDENIED );

    if( FAILED(hr) )
        BAIL_ON_FAILURE( hr=DB_E_NOTABLE );

error:

    if( lpszUserName )
        FreeADsMem(lpszUserName);

    if( lpszPassword )
        FreeADsMem(lpszPassword);

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: GetCredentialsFromIAuthenticate
//
//  Synopsis: Gets credentials (user name, password) from IAuthenticate
//            interface pointer.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT GetCredentialsFromIAuthenticate(
        IAuthenticate *pAuthenticate,
        CCredentials& refCredentials
        )
{
    Assert(pAuthenticate);

    HRESULT hr = S_OK;
    HWND  hwnd;
    PWSTR pszUsername;
    PWSTR pszPassword;

    if (pAuthenticate->Authenticate(&hwnd, &pszUsername, &pszPassword) != S_OK)
        RRETURN(E_INVALIDARG);

    if (hwnd != INVALID_HANDLE_VALUE) //don't know if and how to handle this case
    {
        RRETURN(S_OK);
    }
    else
    {
        hr = refCredentials.SetUserName(pszUsername);
        if (FAILED(hr))
            RRETURN(hr);
        hr = refCredentials.SetPassword(pszPassword);
        if (FAILED(hr))
            RRETURN(hr);
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  RemoveWhiteSpaces
//
//  Synopsis:  Removes the leading and trailing white spaces
//
//  Arguments: pszText                  Text strings from which the leading
//                                      and trailing white spaces are to be
//                                      removed
//
//  Returns:    LPWSTR                  Pointer to the modified string
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
LPWSTR
RemoveWhiteSpaces(LPWSTR pszText)
{
    LPWSTR pChar;

    if( !pszText )
        return( pszText );

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if( !iswspace(*pChar) )
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}

//+---------------------------------------------------------------------------
//
//  Function:  CanConvertHelper
//
//  Synopsis:  Helper that tells the consumer if the conversion is supported.
//
//  Arguments: DBTYPE wSrcType
//             DBTYPE wDstType
//
//  Returns:   HRESULT
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
//
// Bitmask of supported conversions --
//      - src type is index into array,
//      - dst type is bit in that ULONG
//
static ULONG s_rgConvertBitmap[] =
{
                //       3 2 2 2 2 2 1 1 1 1 1 0 0 0 0 0.
                //               0 8 6 4 2 0 8 6 4 2 0 8 6 4 2 0.
                //      3 2 2 2 2 2 1 1 1 1 1 0 0 0 0 0.
                //              1 9 7 5 3 1 9 7 5 3 1 9 7 5 3 1.
                // DBTYPE_EMPTY
                0xe3bfd9ff,     //              11100011101111111101100111111111
                // DBTYPE_NULL
                0x60001002,     //              01100000000000000001000000000010
                // DBTYPE_I2
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_I4
                0xdfdfd9ff,     //              11011111110111111101100111111111
                // DBTYPE_R4
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_R8
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_CY
                0xc39fd97f,     //              11000011100111111101100101111111
                // DBTYPE_DATE
                0x7d9f99bf,     //              01111101100111111001100110111111
                // DBTYPE_BSTR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_IDISPATCH
                0x4087fbff,     //              01000000100001111111101111111111
                // DBTYPE_ERROR
                0x01001500,     //              00000001000000000001010100000000
                // DBTYPE_BOOL
                0xc39fd9ff,     //              11000011100111111101100111111111
                // DBTYPE_VARIANT
                0xffffffff,     //              11111111111111111111111111111111
                // DBTYPE_IUNKNOWN
                0x00003203,     //              00000000000000000011001000000011
                // DBTYPE_DECIMAL
                0x9f9fd97f,     //              10011111100111111101100101111111
                // DBTYPE_I1
                0x9f9fd9ff,     //              10011111100111111101100111111111
                // DBTYPE_UI1
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_UI2
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_UI4
                0xdfdfd9ff,     //              11011111110111111101100111111111
                // DBTYPE_I8
                0x619fd13f,     //              01100001100111111101000100111111
                // DBTYPE_UI8
                0x619fd13f,     //              01100001100111111101000100111111
                // DBTYPE_GUID
                0x41a01103,     //              01000001101000000001000100000011
                // DBTYPE_BYTES
                0x41c4110b,     //              01000001110001000001000100001011
                // DBTYPE_STR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_WSTR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_NUMERIC
                0xc39fd97f,     //              11000011100111111101100101111111
                // DBTYPE_DBDATE
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_DBTIME
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_DBTIMESTAMP
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_FILETIME
                0x7d981183,     //              01111101100110000001000110000011
                // DBTYPE_PROPVARIANT
                0xffffffff,     //              11111111111111111111111111111111
                // DBTYPE_VARNUMERIC
                0x839fd97f,     //              10000011100111111101100101111111
};

static HRESULT IsLegalDBtype(DBTYPE);
static LONG    IndexDBTYPE(DBTYPE wType);

STDMETHODIMP
CanConvertHelper(
        DBTYPE          wSrcType,
        DBTYPE          wDstType,
        DBCONVERTFLAGS  dwConvertFlags
        )
{
    //
    // Check in-params and NULL out-params in case of error
    //
    if( (dwConvertFlags &
         ~(DBCONVERTFLAGS_ISLONG |
           DBCONVERTFLAGS_ISFIXEDLENGTH |
           DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    //
    // Make sure that we check that the type is a variant if they say so
    //
    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT ) {
        DBTYPE  wVtType = wSrcType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );
    }

    //
    // Don't allow _ISLONG on fixed-length types
    //
    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG ) {
        switch ( wSrcType & ~(DBTYPE_RESERVED|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_BYREF) )
        {
        case DBTYPE_BYTES:
        case DBTYPE_STR:
        case DBTYPE_WSTR:
        case DBTYPE_VARNUMERIC:
            break;

        default:
            RRETURN( DB_E_BADCONVERTFLAG );
        }
    }

    // Check for valid types
    if( wSrcType > DBTYPE_DECIMAL )
    {
        if( FAILED(IsLegalDBtype(wSrcType)) )
            RRETURN( S_FALSE );
    }
    if( wDstType > DBTYPE_DECIMAL )
    {
        if( FAILED(IsLegalDBtype(wDstType)) )
            RRETURN( S_FALSE );
    }

    // Check for unsupported type modifiers
    if( (wSrcType & (DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED)) ||
        (wDstType & (DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED)) )
        RRETURN( S_FALSE );

    // Handle BYREF destination separately
    if( wDstType & DBTYPE_BYREF ) {
        // Turn off BYREF bit
        wDstType &= ~DBTYPE_BYREF;

        // We only allow BYREF destination for variable length types
        switch ( wDstType ) {
        case DBTYPE_BYTES:
        case DBTYPE_STR:
        case DBTYPE_WSTR:
        case DBTYPE_VARNUMERIC:
            break;

        default:
            // Fixed-length BYREFs are not supported
            RRETURN( S_FALSE );
        }
    }

    // Turn off BYREF bit
    wSrcType &= ~DBTYPE_BYREF;

    // Get the indices for the src and dst types
    LONG iSrc = IndexDBTYPE(wSrcType);
    ADsAssert(iSrc < NUMELEM(s_rgConvertBitmap)); // better not be larger than our array

    LONG iDst = IndexDBTYPE(wDstType);
    ADsAssert(iDst < (sizeof(ULONG) * 8) );       // or the number of bits in a ULONG

    // Make sure we have two supported types -- we don't support UDT
    if( iSrc < 0 || iDst < 0 )
        RRETURN( S_FALSE );

    // And do the lookup -- bit will be set if conversion supported
    if( s_rgConvertBitmap[iSrc] & (1 << iDst) )
        RRETURN( S_OK );

    // No bit, no support
    RRETURN( S_FALSE );
}


HRESULT IsLegalDBtype(DBTYPE dbtype)
{
    // NOTE: optimized for speed, rather than for maintainablity
    if( dbtype & (DBTYPE_VECTOR|DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_RESERVED) )
        dbtype &= ~(DBTYPE_VECTOR|DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_RESERVED);

    if( (dbtype >= DBTYPE_EMPTY && dbtype <= DBTYPE_DECIMAL) ||
        (dbtype >= DBTYPE_I1 && dbtype <= DBTYPE_UI8) ||
        dbtype == DBTYPE_GUID ||
        (dbtype >= DBTYPE_BYTES && dbtype <= DBTYPE_DBTIMESTAMP) ||
        (dbtype >= DBTYPE_FILETIME && dbtype <= DBTYPE_VARNUMERIC) )
        RRETURN( S_OK );

    RRETURN( DB_E_BADBINDINFO );
}


LONG IndexDBTYPE(DBTYPE wType)
{
    switch ( wType ) {
        case DBTYPE_EMPTY:      // 0
        case DBTYPE_NULL:       // 1
        case DBTYPE_I2:         // 2
        case DBTYPE_I4:         // 3
        case DBTYPE_R4:         // 4
        case DBTYPE_R8:         // 5
        case DBTYPE_CY:         // 6
        case DBTYPE_DATE:       // 7
        case DBTYPE_BSTR:       // 8
        case DBTYPE_IDISPATCH:  // 9
        case DBTYPE_ERROR:      // 10
        case DBTYPE_BOOL:       // 11
        case DBTYPE_VARIANT:    // 12
        case DBTYPE_IUNKNOWN:   // 13
        case DBTYPE_DECIMAL:    // 14
            // 0 - 14
            return (ULONG)wType;

        case DBTYPE_I1:         // 16
        case DBTYPE_UI1:        // 17
        case DBTYPE_UI2:        // 18
        case DBTYPE_UI4:        // 19
        case DBTYPE_I8:         // 20
        case DBTYPE_UI8:        // 21
            // 15 - 20
            return (ULONG)(wType - 1);

        case DBTYPE_GUID:       // 72
            // 21
            return 21;

        case DBTYPE_BYTES:      // 128
        case DBTYPE_STR:        // 129
        case DBTYPE_WSTR:       // 130
        case DBTYPE_NUMERIC:    // 131
            // 22 - 25
            return (ULONG)(wType - 106);

        case DBTYPE_DBDATE:     // 133
        case DBTYPE_DBTIME:     // 134
        case DBTYPE_DBTIMESTAMP:// 135
            // 26 - 28
            return (ULONG)(wType - 107);

        case DBTYPE_FILETIME:   // 64
             // 29
             return wType - 35;
        case DBTYPE_PROPVARIANT:// 138
        case DBTYPE_VARNUMERIC: // 139
             // 30 - 31
             return (ULONG)(wType - 108);
    }

    // No match
    return -1;
}

BYTE SetPrecision(DBTYPE dbType)
{
    switch(dbType)
    {
        case DBTYPE_I1:
        case DBTYPE_UI1:
            return 3;
        case DBTYPE_I2:
        case DBTYPE_UI2:
            return 5;
        case DBTYPE_I4:
        case DBTYPE_UI4:
            return 10;
        case DBTYPE_I8:
            return 19;
        case DBTYPE_UI8:
            return 20;
        case DBTYPE_R4:
            return 7;
        case DBTYPE_R8:
            return 15;
        case DBTYPE_CY:
            return 19;
        case DBTYPE_DECIMAL:
            return 29;
        case DBTYPE_NUMERIC:
            return 39;
        case DBTYPE_VARNUMERIC:
            return 255;
        default:
            return ((BYTE) (~0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\helpers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:  helpers.cxx
//
//  Contents:   ADs C Wrappers (Helper functions)
//
//                ADsBuildEnumerator
//                ADsFreeEnumerator
//                ADsEnumerateNext
//                ADsBuildVarArrayStr
//                ADsBuildVarArrayInt
//
//  History:
//        1-March-1995  KrishnaG  -- Created
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildEnumerator
//
//  Synopsis:   C wrapper code to create an Enumerator object.
//
//  Arguments:  [pNetOleCollection] -- The input Collection object.
//
//              [ppEnumVariant] -- The created Enumerator object.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildEnumerator(
    IADsContainer *pADsContainer,
    IEnumVARIANT * * ppEnumVariant
    )
{

    HRESULT hr;
    IUnknown *pUnk = NULL;

    //
    // Get a new enumerator object.
    //

    hr = pADsContainer->get__NewEnum( &pUnk );
    if (FAILED(hr)) {

        goto Fail;
    }

    //
    // QueryInterface the IUnknown pointer for an IEnumVARIANT interface,
    //

    hr = pUnk->QueryInterface(
                    IID_IEnumVARIANT,
                    (void FAR* FAR*)ppEnumVariant
                    );
    if (FAILED(hr)) {

        goto Fail;
    }

    //
    // Release the IUnknown pointer.
    //

    pUnk->Release();

    return(hr);


Fail:

    if (pUnk) {
        pUnk->Release();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ADsFreeEnumerator
//
//  Synopsis:   Frees an Enumerator object.
//
//  Arguments:  [pEnumerator] -- The Enumerator object to be freed.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
ADsFreeEnumerator(
    IEnumVARIANT *pEnumVariant
    )
{

    HRESULT hr = E_ADS_BAD_PARAMETER;

    ULONG uRefCount = 0;

    if (pEnumVariant) {
        uRefCount = pEnumVariant->Release();

        return(S_OK);
    }

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsEnumerateNext
//
//  Synopsis:   C wrapper code for IEnumVARIANT::Next
//
//  Arguments:  [pEnumVariant] -- Input enumerator object.
//
//              [cElements] --  Number  of elements to retrieve.
//
//              [pvar] -- VARIANT array.
//
//              [pcElementFetched] -- Number of elements fetched.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsEnumerateNext(
    IEnumVARIANT *pEnumVariant,
    ULONG cElements,
    VARIANT * pvar,
    ULONG * pcElementsFetched
    )
{

    return(pEnumVariant->Next(cElements, pvar, pcElementsFetched));
}

//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildVarArrayStr
//
//  Synopsis:   Build a variant array of strings
//
//  Arguments:  [lppPathNames] -- List of pathnames to be put in the array.
//
//              [dwPathNames] -- Number of pathnames in the list.
//
//              [ppvar] -- Pointer to a pointer of a Variant array.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildVarArrayStr(
    LPWSTR * lppPathNames,
    DWORD  dwPathNames,
    VARIANT * pVar
    )
{

    VARIANT v;
    SAFEARRAYBOUND sabNewArray;
    DWORD i;
    SAFEARRAY *psa = NULL;
    HRESULT hr = E_FAIL;


    if (!pVar) {
        hr = E_ADS_BAD_PARAMETER;
        goto Fail;
    }
    VariantInit(pVar);

    sabNewArray.cElements = dwPathNames;
    sabNewArray.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabNewArray);

    if (!psa) {
        goto Fail;
    }

    for (i = 0; i < dwPathNames; i++) {

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = SysAllocString(*(lppPathNames + i));
        hr = SafeArrayPutElement(psa,
                                 (long FAR *)&i,
                                 &v
                                 );
        VariantClear( &v );
        if (FAILED(hr)) {
            goto Fail;
        }
    }



    V_VT(pVar) = VT_ARRAY | VT_VARIANT;

    V_ARRAY(pVar) = psa;

    return(ResultFromScode(S_OK));


Fail:

    if (psa) {
        SafeArrayDestroy(psa);
    }



    return(E_FAIL);

}

//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildVarArrayInt
//
//  Synopsis:   Build a variant array of integers
//
//  Arguments:  [lppObjectTypes] -- List of object types to be put in the array.
//
//              [dwObjectTypes] -- Number of object types in the list.
//
//              [ppvar] -- Pointer to a pointer of a Variant array.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildVarArrayInt(
    LPDWORD    lpdwObjectTypes,
    DWORD      dwObjectTypes,
    VARIANT * pVar
    )
{

    VARIANT v;
    SAFEARRAYBOUND sabNewArray;
    DWORD i;
    SAFEARRAY *psa = NULL;
    HRESULT hr = E_FAIL;

    if (!pVar) {
        hr = E_ADS_BAD_PARAMETER;
        goto Fail;
    }
    VariantInit(pVar);

    sabNewArray.cElements = dwObjectTypes;
    sabNewArray.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabNewArray);

    if (!psa) {
        goto Fail;
    }

    for (i = 0; i < dwObjectTypes; i++) {

        VariantInit(&v);
        V_VT(&v) = VT_I4;
        V_I4(&v) = *(lpdwObjectTypes + i);
        hr = SafeArrayPutElement(psa,
                                 (long FAR *)&i,
                                 &v
                                 );
        VariantClear( &v );
        if (FAILED(hr))  {
            goto Fail;
        }
    }


    V_VT(pVar) = VT_VARIANT | VT_ARRAY;

    V_ARRAY(pVar) = psa;

    return(ResultFromScode(S_OK));


Fail:

    if (psa) {
        SafeArrayDestroy(psa);
    }

    return(E_FAIL);
}


//+---------------------------------------------------------------------------
// Function:  BinarySDToSecurityDescriptor. 
//
// Synopsis:  Convert the given binary blob to an equivalent object 
//          implementing the IADsSecurityDescriptor interface.
//
// Arguments:  pSecurityDescriptor  - the binary SD to convert.
//             pVarsec              - return value.
//             pszServerName        - serverName the SD was 
//                                     retrieved from (optional).
//             userName             - not used, optional.
//             passWord             - not used, optional.
//             dwFlags              - not used, optional.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   pVarsec to contain a VT_DISPATCH if successful.
//
//----------------------------------------------------------------------------
HRESULT 
BinarySDToSecurityDescriptor(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    VARIANT *pVarsec,
    LPCWSTR pszServerName, // defaulted to NULL
    LPCWSTR userName,      // defaulted to NULL
    LPCWSTR passWord,      // defaulted to NULL
    DWORD dwFlags          // defaulted to 0
    )
{
    CCredentials creds((LPWSTR)userName, (LPWSTR)passWord, dwFlags);

    //
    // Call internal routine in sec2var.cxx that does all the work.
    //
    RRETURN(ConvertSecDescriptorToVariant(
                (LPWSTR)pszServerName,
                creds,
                pSecurityDescriptor,
                pVarsec,
                TRUE // we will always expect NT format.
                )
            );
                
}


//+---------------------------------------------------------------------------
// Function:  SecurityDescriptorToBinarySD.
//
// Synopsis:  Convert the given IADsSecurityDescriptor to (in the variant
//          to a binary security descriptor blob.
//
// Arguments:  vVarSecDes           - the binary SD to convert.
//             ppSecurityDescriptor - ptr to output binary blob.
//             pszServerName        - serverName the SD
//                                    is being put on, optional.
//             userName            - not used, optional.
//             passWord            - not used, optional.
//             dwFlags             - not used, optional.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   pVarsec to contain a VT_DISPATCH if successful.
//
//----------------------------------------------------------------------------
HRESULT
SecurityDescriptorToBinarySD(
    VARIANT vVarSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength,
    LPCWSTR pszServerName, // defaulted to NULL
    LPCWSTR userName,      // defaulted to NULL
    LPCWSTR passWord,      // defaulted to NULL
    DWORD dwFlags         // defaulted to 0
    )
{
    HRESULT hr = E_FAIL;
    IADsSecurityDescriptor *pIADsSecDesc = NULL;
    CCredentials creds((LPWSTR)userName, (LPWSTR)passWord, dwFlags);

    //
    // Verify it is a VT_DISPATCH and also that ptr is valid.
    //
    if ((vVarSecDes.vt != VT_DISPATCH)
        || (!V_DISPATCH(&vVarSecDes))
        ) {
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // Get the interface ptr from the variant (it has to be IDispatch)
    //
    hr = vVarSecDes.pdispVal->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pIADsSecDesc
             );
    BAIL_ON_FAILURE(hr);

    //
    // Call the helper routine in sec2var.cxx
    //
    hr = ConvertSecurityDescriptorToSecDes(
             (LPWSTR)pszServerName,
             creds,
             pIADsSecDesc,
             ppSecurityDescriptor,
             pdwSDLength,
             TRUE // always NT Sec desc mode
             );

error:

    if (pIADsSecDesc) {
        pIADsSecDesc->Release();
    }

    RRETURN(hr);
}



// end of helpers.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\oledsapi.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oledsapi.h
//
//  Contents:  Active Directory C API header
//
//----------------------------------------------------------------------------

#ifndef __ADS_API__
#define __ADS_API__

//////////
//
// Defines
//
//////////

#define DS_NOTHING    NULL          // ???
#define DS_EVERYTHING 0xFFFFFFFF    // ???

// missing a whole bunch...


//////////
//
// typedefs
//
//////////

// (syntax definitions need to be created in another file)

typedef DWORD OID;                  // To Be Determined (should not be DWORD)

typedef struct _ds_string_list {
    DWORD dwItems;
    LPWSTR Item[];
} DS_STRING_LIST, *PDS_STRING_LIST;

//
// Note: The struct below is returned when getting the last 
//       accessed/modified/etc times for some DS or Schema entity.
//       The members of this structure are pointers in case the particular
//       time information is not available or is not supported by the DS.
//
// Note2: A pointer to this struct is typically present in DS_*_INFO 
//        structures, in case no such info needs to be specified.
//        A user should pass in NULL for PDS_ACCESS_TIMES if it is
//        a member of some DS_*_INFO which is used as an IN parameter.
//

typedef struct _ds_access_times {
    PSYSTEMTIME pCreated;
    PSYSTEMTIME pLastAccess;
    PSYSTEMTIME pLastModified;
} DS_ACCESS_TIMES, *PDS_ACCESS_TIMES;

typedef struct _ds_object_info {
    OID Oid;
    LPWSTR lpszPath;
    LPWSTR lpszParent;
    LPWSTR lpszName;
    LPWSTR lpszClass;
    LPWSTR lpszSchema;
    PDS_ATTRIBUTE_ENTRY pAttributes;  // Usually NULL, but can be used on enum
    PDS_ACCESS_TIMES pAccessTimes;
} DS_OBJECT_INFO, *PDS_OBJECT_INFO;

typedef struct _ds_class_info {
    OID Oid;
    LPWSTR lpszName;
    PDS_STRING_LIST DerivedFrom;
    PDS_STRING_LIST CanContain;
    PDS_STRING_LIST NamingAttributes;    // What's the deal with this?
    PDS_STRING_LIST RequiredAttributes;
    PDS_STRING_LIST OptionalAttributes;
    BOOL fAbstract;
    PDS_ACCESS_TIMES pAccessTimes;
} DS_CLASS_INFO, *PDS_CLASS_INFO;

typedef struct _ds_attr_info {
    OID Oid;
    LPWSTR lpszName;
    DWORD  dwSyntaxId;
    BOOL   fMultivalued;
    //
    // Bug: Min/Max?  What else?
    //
    PDS_ACCESS_TIMES pAccessTimes;
} PDS_ATTR_INFO, *PDS_ATTR_INFO;

typedef struct _ds_attribute_value {
    DWORD   cbData;
    LPBYTE  lpData;
} DS_ATTRIBUTE_VALUE, *PDS_ATTRIBUTE_VALUE;

//
// NOTE: The dwOperation field is used only when writing attributes.
//       It describes how to write or if clearing the attribute is desired.
//       If clearing is specified, dwSyntaxId, lpValue, and dwNumValues are 
//       ignored.
//

typedef struct _ds_attribute_entry {
    LPWSTR lpszName;
    DWORD  dwSyntaxId;
    DWORD  dwNumValues;
    DWORD  dwOperation;                     // ADD, MODIFY, CLEAR ???
    PDS_ATTRIBUTE_VALUE lpValue;            // Array of values
    PDS_ACCESS_TIMES pAccessTimes;
} DS_ATTRIBUTE_ENTRY, *PDS_ATTRIBUTE_ENTRY;


//////////
//
// functions
//
//////////


//
// Memory functions
//

DWORD
WINAPI
DsBufferAlloc(
    OUT LPVOID *ppBuffer
    );

DWORD
WINAPI
DsBufferFree(
    IN  LPVOID pBuffer
    );

//
// The function below could go out and get kerberos tickets or whatever.
//
// dwType is just a hint in case the user prefers that the underlying 
// DS use a particular type of authentication...
//

DWORD
WINAPI
DsCredentialsOpen(
    IN  LPWSTR lpszUsername,
    IN  LPWSTR lpszPassword,
    IN  DWORD dwType,           // Like DS_CREDENTIALS_DEFAULT
                            // DS_CREDENTIALS_KRBV5, etc.???
    IN  DWORD dwFlags,          // What is this???
    OUT PHANDLE hCredentials
    );

DWORD
WINAPI
DsCredentialsClose(
    IN  HANDLE hCredentials
    );

//
// Good old open
//

// Note: if hRoot is NULL, lpszPath is full object path
//       otherwise, lpszPath is relative name from object w/hRoot handle 

DWORD
WINAPI
DsObjectOpen(
    IN  HANDLE hRoot,
    IN  LPWSTR lpszPath,
    IN  HANDLE hCredentials,  // NULL for process credentials
    IN  DWORD dwAccess,
    IN  DWORD dwFlags,
    OUT PHANDLE phDs
    );

//
// Note: Should we use single close (Object/Enum/Schema)???
//

DWORD
WINAPI
DsObjectClose(
    IN  HANDLE hDs
    );

//
// We need some stuff to operate on handles to get back binding info
// (this stuff comes in only when you do an open or when you refresh)
//


DWORD
WINAPI
DsObjectInfo(
    IN  HANDLE hDs,
    OUT PDS_OBJECT_INFO *ppObjectInfo
    );

//
// Read/Write Attributes
//

DWORD
WINAPI
DsObjectRead(
    IN  HANDLE hDs,
    IN  DWORD dwFlags,                  // ???
    IN  PDS_STRING_LIST pAttributeNames,
    OUT PDS_ATTRIBUTE_ENTRY *ppAttributeEntries,
    OUT LPDWORD lpdwNumAttributesReturned
    );

DWORD
WINAPI
DsObjectWrite(
    IN  HANDLE hDs,
    IN  DWORD dwNumAttributesToWrite,
    IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries,
    OUT LPDWORD lpdwNumAttributesWritten
    );

//
// Create/Delete Objects
//

DWORD
WINAPI
DsObjectCreate(
    IN  HANDLE hDs,                            // Container
    IN  LPWSTR lpszRelativeName,
    IN  LPWSTR lpszClass,
    IN  DWORD dwNumAttributes,
    IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries
    );

DWORD
WINAPI
DsObjectDelete(
    IN  HANDLE hDs,
    IN  LPWSTR lpszRelativeName,
    IN  LPWSTR lpszClass                     // Could be NULL if name unique??
    );

//
// Enumeration
//


DWORD
WINAPI
DsObjectEnumOpen(
    IN  HANDLE hDs,
    IN  DWORD dwFlags,                 // What is this? 
    IN  PDS_STRING_LIST pFilters,      // Classes wanted
    IN  PDS_STRING_LIST pDesiredAttrs, // Attrs wanted or NULL just for info
    OUT PHANDLE phEnum
    );

DWORD
WINAPI
DsObjectEnumNext(
    IN  HANDLE hEnum,
    IN  DWORD dwRequested,          // 0xFFFFFFFF for just counting
    OUT PDS_OBJECT_INFO *ppObjInfo, // NULL for no info (just counting)
    OUT LPDWORD lpdwReturned        // Actual number returned/counted
    );

DWORD
WINAPI
DsObjectEnumClose(
    IN  HANDLE hEnum
    );

//
// Schema stuff
//

//
// Note: The word "schema" below refers to the schema db and not to
//       a class definition.
//

DWORD
WINAPI
DsSchemaOpen(
    IN  HANDLE hSchema,    // NULL if opening schema db, 
                           // must be schema db handle otherwise
    IN  LPWSTR lpszPath,   // One of: path to schema,
                           //         class name,
                           //         attribute name
    IN  HANDLE hCredentials,
    IN  DWORD dwAccess,
    IN  DWORD dwFlags,     // DS_OPEN_SCHEMA = 0, DS_OPEN_CLASS, DS_OPEN_ATTR
    OUT PHANDLE ph         // handle to schema/class/attr depending on dwFlags
    );

DWORD
WINAPI
DsSchemaClose(
    IN  HANDLE hSchema
    );

//
// Can also create/delete schema databases (if DS allows it)???
//

DWORD
WINAPI
DsSchemaCreate(
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaDelete(
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

//
// Schema Enumeration
//

//
// enum class/attribute names
//

DWORD
WINAPI
DsSchemaEnumOpen(
    IN  HANDLE hSchema,
    IN  DWORD dwFlags,          // DS_SCHEMA_ENUM_CLASS xor DS_SCHEMA_ENUM_ATTR
    OUT PHANDLE phEnum
    );

DWORD
WINAPI
DsSchemaEnumNext(
    IN  HANDLE hEnum,
    IN  DWORD dwRequested,        // Pass in 0xFFFFFFFF for just counting
    IN  LPWSTR *ppObjInfo,        // Pass in NULL for just counting
    OUT LPDWORD lpdwReturned      // This would return the count
    );

DWORD
WINAPI
DsSchemaEnumClose(
    IN  HANDLE hEnum
    );

//
// Class/Attribute Stuff
//

DWORD
WINAPI
DsSchemaClassCreate(
    IN  HANDLE hSchema,
    IN  PDS_CLASS_INFO pClassInfo // What do we do about naming attributes?
    );

DWORD
WINAPI
DsSchemaAttrCreate(
    IN  HANDLE hSchema,
    IN  PDS_ATTR_INFO pAttrInfo
    );

DWORD
WINAPI
DsSchemaClassDelete(
    IN  HANDLE hSchema,
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaAttrDelete(
    IN  HANDLE hSchema,
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaClassInfo(
    IN  HANDLE hClass,
    OUT PDS_CLASS_INFO *ppClassInfo
    );

DWORD
WINAPI
DsSchemaAttrInfo(
    IN  HANDLE hAttr,
    OUT PDS_ATTR_INFO *ppAttrInfo
    );

DWORD
WINAPI
DsSchemaClassModify(
    IN  HANDLE hSchema,
    IN  PDS_CLASS_INFO pClassInfo // What do we do about naming attributes?
    );

DWORD
WINAPI
DsSchemaAttrModify(
    IN  HANDLE hSchema,
    IN  PDS_ATTR_INFO pAttrInfo
    );

#endif // __ADS_API__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\oledscom.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oledscom.h
//
//  Contents:   Active Directory COM Interfaces
//              - IDsOpen
//              - IDsObject
//              - IDsContainer
//              - IDsEnum
//              - IDsSchema
//              - IDsClass
//              - IDsAttribute
//              - (IDsSecurity needs to be defined)
//
// Note: Objects are:
//       DsObject: IDsOpen, IDsSecurity, IDsObject,
//                 and IDsContainer if object is a container (even if empty)
//       DsSchema: IDsOpen, IDsSecurity, IDsSchema
//       DsClass:  IDsOpen, IDsSecurity, IDsClass
//       DsAttribute: IDsOpen, IDsSecurity, IDsAttribute
//       DsEnum: IDsOpen
//
// So, every object supports IDsEnum and all but DsEnum supports IDsSecurity
//
// Note2: I thought about having DsObject support IDsClass for easy class
//        access, but I trashed that because of complexity.*
//        Similarlry, I thought about IDsSchema support for DsClass and
//        DsAttribute.  Same problem here.*
//        *SubNote: The object model would become a bit weird.  However,
//                  adding a function to the main interface to get the
//                  Class/Schema object might be useful.
//
//----------------------------------------------------------------------------

#ifndef __ADS_COM__
#define __ADS_COM__

#include <oledsapi.h>

/* Definition of interface: IDsOpen */

/*
  This interface should be used when you need to open some object or
  schema path.

  You can QI for it on any DS COM object
*/

#undef INTERFACE
#define INTERFACE IDsOpen

DECLARE_INTERFACE_(IDsOpen, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsOpen */

    STDMETHOD(OpenObject)(
        THIS_
        IN  LPWSTR lpszObjectPath,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        IN  REFIID riid,
        OUT void **ppADsObj
        ) PURE;

    STDMETHOD(OpenSchemaDatabase)(
        THIS_ 
        IN  LPWSTR lpszSchemaPath,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsSchema **ppDsSchema
        ) PURE;
};


/* Definition of interface: IDsObject */

/*
  This interface is only supported by actual DS object.  It should not be
  supported by schema entities.

  NOTE: The names for the methods below should be shortened some for 
        ease of use.

*/

#undef INTERFACE
#define INTERFACE IDsObject

DECLARE_INTERFACE_(IDsObject, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsObject*/

    STDMETHOD(GetObjectInformation)(
        THIS_
        OUT PDS_OBJECT_INFO pObjInfo
        ) PURE;

    STDMETHOD(GetObjectAttributes)(
        THIS_ 
        IN  PDS_STRING_LIST  pAttributeNames,
        OUT PDS_ATTRIBUTE_ENTRY *ppAttributeEntries,
        OUT PDWORD pdwNumAttributesReturned
        ) PURE;

    STDMETHOD(SetObjectAttributes)(
        THIS_
        IN  DWORD dwFlags,
        IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries,
        IN  DWORD   dwNumAttributes,
        OUT PDWORD  pdwNumAttributesModified
        ) PURE;

    STDMETHOD(OpenSchemaDefinition)(
        THIS_
        OUT IDsSchema **ppDsSchema
        ) PURE;

};


/* Definition of interface: IDsContainer */

/*
  This interface should be supported by any container object.  Therefore,
  all objects should support this interface except for objects whose class 
  definitions prohibit them from containing anything.

  NOTE: Open, Create, and Delete accept any relative name, not just
        objects immediately under the container (i.e. from object
        "foo://bar", I can open "baz/foobar", which is really
        "foo://bar/baz/foobar").

        This funtionality allows me to open "@ADs!" and do all
        sorts of operations without having to browse!
        ("All the power comes to me." -- a guy in some movie,
         unfortunately, I don't know which guy or what movie.)
*/

#undef INTERFACE
#define INTERFACE IDsContainer

DECLARE_INTERFACE_(IDsContainer, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsContainer*/

    STDMETHOD(OpenEnum)(
        THIS_
        IN  DWORD dwFlags,
        IN  PDS_STRING_LIST pFilters,
        IN  PDS_STRING_LIST pDesiredAttrs,
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(OpenObject)(
        THIS_
        IN  LPWSTR lpszRelativeName,
        IN  IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        IN  REFIID riid,
        OUT void **ppADsObj
        ) PURE;

    STDMETHOD(Create)(
        THIS_
        IN  LPWSTR lpszRelativeName,
        IN  LPWSTR lpszClass,
        IN  DWORD dwNumAttributes,
        IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries
        ) PURE;

    STDMETHOD(Delete)(
        THIS_
        IN  LPWSTR lpszRDName,
        IN  LPWSTR lpszClassName
        ) PURE;

};


/* Definition of interface: IDsEnum */

/*
  $$$$ The notes below are very important!!! $$$$

  Note: *ppEnumInfo should be cast to PDS_OBJECT_INFO or LPWSTR depending
        on whether the enum was on objects or class/attributes
        (If this enum interface is used for other stuff, can use other
         castings as appropriate.)

  Note2: IDsEnum is only supported by enumeration objects that are created
         when an enumeration takes place.  These enumeration objects only
         support IUnknown, IDsOpen, and IDsEnum.  They cannot support any
         other IDs* interfaces.
*/

#undef INTERFACE
#define INTERFACE IDsEnum

DECLARE_INTERFACE_(IDsEnum, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsEnum */

    STDMETHOD(Next)(
        THIS_
        IN  DWORD dwRequested,         // 0xFFFFFFFF for just counting
        OUT PVOID *ppEnumInfo,         // NULL for no info (just counting)
        OUT LPDWORD lpdwReturned       // This would return the count
        ) PURE;

};


/* Definition of interface: IDsSchema */
#undef INTERFACE
#define INTERFACE IDsSchema

DECLARE_INTERFACE_(IDsSchema, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsSchema */

    STDMETHOD(OpenClass)(
        THIS_ 
        IN  LPWSTR lpszClass,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsClass **ppDsClass
        ) PURE;

    STDMETHOD(OpenAttribute)(
        THIS_ 
        IN  LPWSTR lpszAttribute,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsAttribute **ppDsAttribute
        ) PURE;

    STDMETHOD(OpenClassEnum)(
        THIS_
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(OpenAttributeEnum)(
        THIS_
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(CreateClass)(
        THIS_
        IN  PDS_CLASS_INFO pClassInfo
        ) PURE;

    STDMETHOD(CreateAttribute)(
        THIS_
        IN  PDS_ATTR_INFO pAttrInfo
        ) PURE;

    STDMETHOD(DeleteClass)(
        THIS_
        IN  LPWSTR lpszName,
        IN  DWORD dwFlags
        ) PURE;

    STDMETHOD(DeleteAttribute)(
        THIS_
        IN  LPWSTR lpszName,
        IN  DWORD dwFlags
        ) PURE;
};


/* Definition of interface: IDsClass */
#undef INTERFACE
#define INTERFACE IDsClass

DECLARE_INTERFACE_(IDsClass, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsClass */

    STDMETHOD(GetClassInfo)(
        THIS_
        OUT PDS_CLASS_INFO *ppClassInfo
        );

    STDMETHOD(ModifyClassInfo)(
        THIS_
        IN  PDS_CLASS_INFO pClassInfo
        ) PURE;

};


/* Definition of interface: IDsAttribute */
#undef INTERFACE
#define INTERFACE IDsAttribute

DECLARE_INTERFACE_(IDsAttribute, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsAttribute */

    STDMETHOD(GetAttributeInfo)(
        THIS_
        OUT PDS_ATTR_INFO *ppAttrInfo
        );

    STDMETHOD(ModifyAttributeInfo)(
        THIS_
        IN  PDS_ATTR_INFO pAttrInfo
        ) PURE;
};

#endif // __ADS_COM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\pathcf.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CPathnameCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPathnameCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPathname::CreatePathname(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\openobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  openobj.cxx
//
//  Contents:  ADs Wrapper Function to open an Active Directory object
//
//
//  History:   11-15-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

//+---------------------------------------------------------------------------
//  Function:  ADsOpenObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [LPWSTR lpszUserName]
//              [LPWSTR lpszPassword]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    07-12-96  krishnag Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsOpenObject(
    LPCWSTR lpszPathName,
    LPCWSTR lpszUserName,
    LPCWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    IADsOpenDSObject FAR * pNamespace = NULL;
    IDispatch FAR *        pDispatch  = NULL;
    HRESULT hr = S_OK;
    GUID  NamespaceClsid;
    WCHAR lpszProgId[MAX_PATH];

    hr = CopyADsProgId(
               (LPWSTR)lpszPathName,
               lpszProgId
               );
    BAIL_ON_FAILURE( hr );

    hr = ADsGetCLSIDFromProgID(
            lpszProgId,
            &NamespaceClsid
            );
    BAIL_ON_FAILURE( hr );

    hr = CoCreateInstance(
                NamespaceClsid,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsOpenDSObject,
                (void **)&pNamespace
                );
    BAIL_ON_FAILURE( hr );

    hr = pNamespace->OpenDSObject(
                (LPWSTR)lpszPathName,
                (LPWSTR)lpszUserName,
                (LPWSTR)lpszPassword,
                (long)dwReserved,
                &pDispatch
                );
    BAIL_ON_FAILURE( hr );


    hr = pDispatch->QueryInterface(
                        riid,
                        ppObject
                        );

error:

    if( pDispatch )	{
        pDispatch->Release();
	}

    if( pNamespace ) {
        pNamespace->Release();
	}

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  Function:   CopyADsProgId
//
//  Synopsis:
//
//
//  Arguments:  [LPWSTR Path]
//              [LPWSTR szProgId]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    09-16-96  krishnag Created
//
//----------------------------------------------------------------------------
HRESULT
CopyADsProgId(
    LPWSTR Path,
    LPWSTR szProgId
    )
{
    LPWSTR pChar = NULL;

	if( !Path )
        return E_FAIL;

    pChar = szProgId;

    if( *Path == L'@' ) {
        while (*Path != L'!' &&  *Path != L'\0') {
            *pChar = *Path;
            pChar++;
            Path++;
        }

		if( *Path == L'\0' ) {
			//
			// couldn't find the terminating ! for the ProgID
			//
            return( E_FAIL );
		}
    }else {
        while (*Path != L':' && *Path != L'\0') {
            *pChar = *Path;
            pChar++;
            Path++;
        }

        if( *Path == L'\0' ) {
			//
			// couldn't find the terminating : for the ProgID
			//
            return( E_FAIL );
		}
    }

	*pChar = L'\0';
    return S_OK;
}


HRESULT
ADsGetCLSIDFromProgID(
    LPWSTR pszProgId,
    GUID * pClsid
    )
{

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    PROUTER_ENTRY lpRouter = g_pRouterHead;

    while (lpRouter){

        if (!wcscmp(lpRouter->szProviderProgId, pszProgId)) {
            memcpy(pClsid, lpRouter->pNamespaceClsid, sizeof(CLSID));
            RRETURN(S_OK);

        }
        else if (!wcscmp(lpRouter->szAliases, pszProgId)) {

            //
            // Check Aliases
            //

            memcpy(pClsid, lpRouter->pNamespaceClsid, sizeof(CLSID));
            RRETURN(S_OK);
        }

        lpRouter = lpRouter->pNext;

    }

    RRETURN( E_ADS_BAD_PATHNAME );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\path.cxx ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    path.cxx

Abstract:

    This file contains the PathCracker Functionality

Environment:

    User mode

Revision History:

    12/07/98 -felixw-
        Created it

--*/
#include "oleds.hxx"
#pragma hdrstop

DEFINE_IDispatch_Implementation(CPathname)

CPathname::CPathname():
    _pDispMgr(NULL),
    m_pPathnameProvider(NULL),
    _fNamingAttribute(TRUE),
    _dwEscaped(ADS_ESCAPEDMODE_DEFAULT)

/*++

Routine Description:

    Constructor for CPathname

Arguments:

Return Value:

    None

--*/

{
    ENLIST_TRACKING(CPathname);
    memset(&_PathObjectInfo,
           0x0,
           sizeof(PATH_OBJECTINFO));
    _PathObjectInfo.dwPathType = ADS_PATHTYPE_ROOTFIRST;
}


HRESULT
CPathname::CreatePathname(
    REFIID riid,
    void **ppvObj
    )

/*++

Routine Description:

    Create the pathname object

Arguments:

    riid - IID to query for
    ppvObj - object to be returned

Return Value:

    S_OK on success, error code otherwise

--*/

{
    CPathname * pPathname = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePathnameObject(&pPathname);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPathname->Release();

    RRETURN(hr);

error:
    delete pPathname;

    RRETURN(hr);
}


CPathname::~CPathname( )

/*++

Routine Description:

    Destructor for Pathname object

Arguments:

Return Value:

    None

--*/

{
    FreePathInfo(&_PathObjectInfo);
    delete _pDispMgr;
    if (m_pPathnameProvider) {
        m_pPathnameProvider->Release();
    }
}

STDMETHODIMP
CPathname::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathname))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CPathname::AllocatePathnameObject(
    CPathname ** ppPathname
    )

/*++

Routine Description:

    Allocate a pathname object

Arguments:

    ppPathname - constructed object

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    CPathname * pPathname = NULL;
    CDispatchMgr * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPathname = new CPathname();
    if (pPathname == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPathname,
                (IADsPathname *)pPathname,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPathname->_pDispMgr = pDispMgr;

    //
    // By default, the pathname is set to the LDAP provider
    //
    hr = ADsGetObject(L"LDAP:",
                      IID_IADsPathnameProvider,
                      (void**)&(pPathname->m_pPathnameProvider));
    BAIL_ON_FAILURE(hr);

    pPathname->_PathObjectInfo.ProviderName = AllocADsStr(L"LDAP");
    if (pPathname->_PathObjectInfo.ProviderName == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppPathname = pPathname;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CPathname::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsPathname)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CPathname::SetAll(
        BSTR bstrADsPath
        )

/*++

Routine Description:

    Set the internal variables using the full ADSPath

Arguments:

    bstrADsPath - the passed in Full ADSPath

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    //
    // Freeing existing info
    //
    FreePathInfo(&_PathObjectInfo);

    //
    // Collecting new info
    //
    hr = m_pPathnameProvider->ParsePath(
                                bstrADsPath, 
                                ADS_PARSE_FULL,
                                &_PathObjectInfo);
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);
error:
    FreePathInfo(&_PathObjectInfo);
    RRETURN(hr);
}

HRESULT
CPathname::GetNamespace(
        BSTR bstrADsPath, 
        PWSTR *ppszName
        )

/*++

Routine Description:

    Get a namespace from a full ADsPath

Arguments:

    bstrADsPath - passed in ADsPath
    ppszName - returned namespace, must be freed by caller

Return Value:

    S_OK on success, E_ADS_BAD_PATHNAME if the path is bad, error code 
    otherwise.

--*/

{
    DWORD dwPath = 0;               // Length of namespace
    BOOLEAN fFound = FALSE;
    PWSTR szPath = bstrADsPath;
    HRESULT hr = S_OK;

    while (*szPath) {
        if (*szPath == ':') {
            dwPath++;
            fFound = TRUE;
            break;
        }
        szPath++;
        dwPath++;
    }

    if (fFound) {
        *ppszName = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwPath + 1));
        if (*ppszName == NULL) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    
        memcpy(*ppszName, bstrADsPath, (dwPath * sizeof(WCHAR)));
        (*ppszName)[dwPath] = '\0';
    }
    else {
        hr = E_ADS_BAD_PATHNAME;
    }

error:
    return hr;
}

 
STDMETHODIMP
CPathname::Set(
        BSTR bstrADsPath, 
        long dwSetType
        )

/*++

Routine Description:

    Set the path with the type specified

Arguments:
    bstrADsPath - the path to be set
    dwSetType - the type :
                       ADS_SETTYPE_FULL
                       ADS_SETTYPE_PROVIDER
                       ADS_SETTYPE_SERVER
                       ADS_SETTYPE_DN

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    LPWSTR szPath = NULL;
    WCHAR szNamespace[MAX_PATH];
    LPWSTR pszName = NULL;
    IADsPathnameProvider    *pPathnameProvider = NULL;

    switch (dwSetType) {

        case ADS_SETTYPE_FULL:
            if ((bstrADsPath == NULL) || ((*bstrADsPath) == NULL)) {
                hr = E_INVALIDARG;
                goto error;
            }
            hr = GetNamespace(bstrADsPath, &pszName);
            BAIL_ON_FAILURE(hr);

            if ((_PathObjectInfo.ProviderName == NULL) || 
                (wcscmp(_PathObjectInfo.ProviderName, bstrADsPath) != 0)) {
                //
                // If provider not set, or if the provider is different
                // we reset the provider
                //
                pPathnameProvider = NULL;
                hr = ADsGetObject(pszName,
                                  IID_IADsPathnameProvider,
                                  (void**)&(pPathnameProvider));
                BAIL_ON_FAILURE(hr);

                if (pPathnameProvider) {
                    if (m_pPathnameProvider) {
                        m_pPathnameProvider->Release();
                    }
                    m_pPathnameProvider = pPathnameProvider;
                }
            }

            hr = SetAll(bstrADsPath);
            break;

        case ADS_SETTYPE_PROVIDER:

            if ((bstrADsPath == NULL) || ((*bstrADsPath) == NULL)) {
                hr = E_INVALIDARG;
                goto error;
            }
            //
            // If it is the same as the namespace that is stored inside already,
            // ignore it
            //
            if (_PathObjectInfo.ProviderName && 
                (wcscmp(_PathObjectInfo.ProviderName, bstrADsPath) == 0)) {
                hr = S_OK;
                break;
            }

            wcscpy(szNamespace,bstrADsPath);
            wcscat(szNamespace,L":");

            pPathnameProvider = NULL;
            hr = ADsGetObject(szNamespace,
                              IID_IADsPathnameProvider,
                              (void**)&(pPathnameProvider));
            BAIL_ON_FAILURE(hr);

            if (pPathnameProvider) {
                if (m_pPathnameProvider) {
                    m_pPathnameProvider->Release();
                }
                m_pPathnameProvider = pPathnameProvider;
            }


            FreePathInfo(&_PathObjectInfo);
            _PathObjectInfo.ProviderName = AllocADsStr(bstrADsPath);
            if (_PathObjectInfo.ProviderName == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = S_OK;
            break;

        case ADS_SETTYPE_SERVER:
            if (m_pPathnameProvider == NULL) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            if (_PathObjectInfo.ServerName) {
                FreeADsStr( _PathObjectInfo.ServerName);
                _PathObjectInfo.ServerName = NULL;
            }
            if (_PathObjectInfo.DisplayServerName) {
                FreeADsStr( _PathObjectInfo.DisplayServerName);
                _PathObjectInfo.DisplayServerName = NULL;
            }
            
            //
            // If the input path is not NULL, we'll set it to the new one. Or
            // else we will just ignore it 'cause it has been set to 0 earlier
            //
            if (bstrADsPath && (*bstrADsPath)) {
                _PathObjectInfo.ServerName = AllocADsStr(bstrADsPath);
                if (_PathObjectInfo.ServerName == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                _PathObjectInfo.DisplayServerName = AllocADsStr(bstrADsPath);
                if (_PathObjectInfo.DisplayServerName == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            hr = S_OK;
            break;

        case ADS_SETTYPE_DN:
            {
                if (m_pPathnameProvider == NULL) {
                    hr = E_ADS_BAD_PATHNAME;
                    goto error;
                }

                //
                // Free the existing ones first
                //
                FreeObjInfoComponents(&_PathObjectInfo);
                _PathObjectInfo.dwPathType = 0;

                //
                // If the input path is not NULL, we'll set it to the new one. 
                // Or else we will just ignore it 'cause it has been set to 0 
                // earlier
                //
                if (bstrADsPath && (*bstrADsPath)) {
                    hr = m_pPathnameProvider->ParsePath(
                                                    bstrADsPath,
                                                    ADS_PARSE_DN, 
                                                    &_PathObjectInfo);
                    BAIL_ON_FAILURE(hr);
                }

                break;
            }

        default:
            hr = E_INVALIDARG;
            break;
    }

error:
    if (pszName) {
        FreeADsStr(pszName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::SetDisplayType(
                    long lnSetType
                    )

/*++

Routine Description:

    Set the Display type of the Pathname object. It can either display the whole 
    string cn=xxx or just the value xxx.

Arguments:

    lnSetType - the passed in set type
            ADS_DISPLAY_FULL=1,
            ADS_DISPLAY_VALUE_ONLY=2

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    if (lnSetType == ADS_DISPLAY_FULL) {
        _fNamingAttribute = TRUE;
        RRETURN (S_OK);
    }
    else if (lnSetType == ADS_DISPLAY_VALUE_ONLY) {
        _fNamingAttribute = FALSE;
        RRETURN (S_OK);
    }
    RRETURN(E_INVALIDARG);
}


HRESULT CPathname::SetComponent(
                    DWORD cComponents,
                    BSTR *pbstrElement
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    cComponents - the component number to be set
    pbstrElement - the return value

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    PATH_COMPONENT* pComponent = NULL;
    DWORD dwLength = 2; // for null termination and the equal sign

    if (_dwEscaped == ADS_ESCAPEDMODE_OFF_EX) {
        pComponent = _PathObjectInfo.ProvSpecComponentArray;
        if (pComponent[cComponents].szValue == NULL) {
            pComponent = _PathObjectInfo.ComponentArray;
        }
    }
    else if (_dwEscaped == ADS_ESCAPEDMODE_ON) {
        pComponent = _PathObjectInfo.DisplayComponentArray;
    }
    //
    // Either default or OFF, we do not turn on escaping
    //
    else {
        pComponent = _PathObjectInfo.ComponentArray;
    }

    //
    // allocate space for szReturn
    //
    if (pComponent[cComponents].szValue) {
        dwLength += wcslen(pComponent[cComponents].szValue);
    }
    if (pComponent[cComponents].szComponent) {
        dwLength += wcslen(pComponent[cComponents].szComponent);
    }
    szReturn = (PWSTR)AllocADsMem(sizeof(WCHAR) * dwLength);
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    szReturn[0] = NULL;

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
    hr = ADsAllocString(szReturn, pbstrElement);

error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    return hr;
}


STDMETHODIMP
CPathname::Retrieve(
            THIS_ long dwFormatType, 
            BSTR *pbstrADsPath
            )

/*++

Routine Description:

    Retrive the pathname as different formats

Arguments:

    dwFormatType - the input format type
    pbstrADsPath - the returned path

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    switch (dwFormatType) {
        case ADS_FORMAT_SERVER:
            if (!_PathObjectInfo.DisplayServerName) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            hr = ADsAllocString(_PathObjectInfo.DisplayServerName, pbstrADsPath);
            break;

        case ADS_FORMAT_PROVIDER:
            if (!_PathObjectInfo.ProviderName) {
                hr = E_ADS_BAD_PATHNAME;    
                goto error;
            }
            hr = ADsAllocString(_PathObjectInfo.ProviderName, pbstrADsPath);
            break;
        default:
            //
            DWORD dwFlag = 0;
            if (_fNamingAttribute)
                dwFlag |= ADS_CONSTRUCT_NAMINGATTRIBUTE;
            hr = m_pPathnameProvider->ConstructPath(&_PathObjectInfo,
                                                    dwFormatType,
                                                    dwFlag,
                                                    _dwEscaped,
                                                    pbstrADsPath);
            BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPathname::GetNumElements(
                    THIS_ long *pdwNumPathElements
                    )

/*++

Routine Description:

    Get the number of elements in the DN

Arguments:

    pdwNumPathElements - the number of elements

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!pdwNumPathElements) {
        hr = E_INVALIDARG;
        goto error;
    }

    *pdwNumPathElements = _PathObjectInfo.NumComponents;
error:
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPathname::GetElement(
                THIS_ long dwElementIndex, 
                BSTR *pbstrElement
                )

/*++

Routine Description:

    Get a particular element using an index

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!pbstrElement) {
        hr = E_INVALIDARG;
        goto error;
    }

    if ((DWORD)dwElementIndex >= _PathObjectInfo.NumComponents) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
        goto error;
    }
    if (_PathObjectInfo.dwPathType != ADS_PATHTYPE_LEAFFIRST) {
        dwElementIndex = _PathObjectInfo.NumComponents - 1 - dwElementIndex;
    }
    hr = SetComponent(dwElementIndex,
                      pbstrElement);
error:
    RRETURN_EXP_IF_ERR(hr);
}




VOID MoveLastComponentToFront(
                    PPATH_OBJECTINFO pObjectInfo
                    )

/*++

Routine Description:

    Move the last component to the front. Used after adding leaf

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD cComponent;

    ADsAssert(pObjectInfo->NumComponents > 1);

    LPTSTR szComponentLast =
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szValueLast =
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents-1].szValue;
    LPTSTR szDisplayComponentLast =
        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szDisplayValueLast =
        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents-1].szValue;
    LPTSTR szProvSpecComponentLast =
        pObjectInfo->ProvSpecComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szProvSpecValueLast =
        pObjectInfo->ProvSpecComponentArray[pObjectInfo->NumComponents-1].szValue;

    for (cComponent=pObjectInfo->NumComponents-1;cComponent>=1;cComponent--) {
        pObjectInfo->ComponentArray[cComponent].szComponent =
                        pObjectInfo->ComponentArray[cComponent-1].szComponent;
        pObjectInfo->ComponentArray[cComponent].szValue =
                        pObjectInfo->ComponentArray[cComponent-1].szValue;
        pObjectInfo->DisplayComponentArray[cComponent].szComponent =
                        pObjectInfo->DisplayComponentArray[cComponent-1].szComponent;
        pObjectInfo->DisplayComponentArray[cComponent].szValue =
                        pObjectInfo->DisplayComponentArray[cComponent-1].szValue;
        pObjectInfo->ProvSpecComponentArray[cComponent].szComponent =
                        pObjectInfo->ProvSpecComponentArray[cComponent-1].szComponent;
        pObjectInfo->ProvSpecComponentArray[cComponent].szValue =
                        pObjectInfo->ProvSpecComponentArray[cComponent-1].szValue;
    }
    pObjectInfo->ComponentArray[0].szComponent = szComponentLast;
    pObjectInfo->ComponentArray[0].szValue = szValueLast;
    pObjectInfo->DisplayComponentArray[0].szComponent = szDisplayComponentLast;
    pObjectInfo->DisplayComponentArray[0].szValue = szDisplayValueLast;
    pObjectInfo->ProvSpecComponentArray[0].szComponent = szProvSpecComponentLast;
    pObjectInfo->ProvSpecComponentArray[0].szValue = szProvSpecValueLast;

    return;
}



HRESULT
RemoveFirstElement(
            PPATH_OBJECTINFO pObjectInfo
            )

/*++

Routine Description:

    Remove first element from the list

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD cComponent;

    if (pObjectInfo->NumComponents <= 0) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    FreeADsStr(pObjectInfo->ComponentArray[0].szComponent);
    FreeADsStr(pObjectInfo->ComponentArray[0].szValue);
    FreeADsStr(pObjectInfo->DisplayComponentArray[0].szComponent);
    FreeADsStr(pObjectInfo->DisplayComponentArray[0].szValue);
    if (pObjectInfo->ProvSpecComponentArray[0].szComponent)
        FreeADsStr(pObjectInfo->ProvSpecComponentArray[0].szComponent);
    if (pObjectInfo->ProvSpecComponentArray[0].szValue)
        FreeADsStr(pObjectInfo->ProvSpecComponentArray[0].szValue);

    for (cComponent = 0;cComponent < pObjectInfo->NumComponents - 1;cComponent++) {
        pObjectInfo->ComponentArray[cComponent].szComponent =
            pObjectInfo->ComponentArray[cComponent+1].szComponent;
        pObjectInfo->ComponentArray[cComponent].szValue =
            pObjectInfo->ComponentArray[cComponent+1].szValue;
        pObjectInfo->DisplayComponentArray[cComponent].szComponent =
            pObjectInfo->DisplayComponentArray[cComponent+1].szComponent;
        pObjectInfo->DisplayComponentArray[cComponent].szValue =
            pObjectInfo->DisplayComponentArray[cComponent+1].szValue;
        pObjectInfo->ProvSpecComponentArray[cComponent].szComponent =
            pObjectInfo->ProvSpecComponentArray[cComponent+1].szComponent;
        pObjectInfo->ProvSpecComponentArray[cComponent].szValue =
            pObjectInfo->ProvSpecComponentArray[cComponent+1].szValue;
    }
    pObjectInfo->ComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->ComponentArray[cComponent].szValue = NULL;
    pObjectInfo->DisplayComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->DisplayComponentArray[cComponent].szValue = NULL;
    pObjectInfo->ProvSpecComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->ProvSpecComponentArray[cComponent].szValue = NULL;
    pObjectInfo->NumComponents--;

    RRETURN(S_OK);
}


STDMETHODIMP
CPathname::AddLeafElement(
                    THIS_ BSTR bstrLeafElement
                    )

/*++

Routine Description:

    Add a leaf element to the DN

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    DWORD NumComponents;
    BOOL fStartAllocation = FALSE;

    PATH_OBJECTINFO ObjectInfoLocal;

    memset(&ObjectInfoLocal, 0, sizeof(PATH_OBJECTINFO));
    if ((bstrLeafElement == NULL) || ((*bstrLeafElement) == NULL)) {
        hr = E_INVALIDARG;
        goto error;
    }

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    //
    // MAX size limitation exist in parser.cxx, so, it's not
    // worth to implement the inc in size dynamically
    //
    if ((_PathObjectInfo.NumComponents+1) > MAXCOMPONENTS ) {
        hr = E_NOTIMPL;
        goto error;
    }

    hr = m_pPathnameProvider->ParsePath(
                                bstrLeafElement,
                                ADS_PARSE_COMPONENT, 
                                (PPATH_OBJECTINFO)&ObjectInfoLocal
                                );
    BAIL_ON_FAILURE(hr);


    NumComponents = _PathObjectInfo.NumComponents;
    fStartAllocation = TRUE;

    if (ObjectInfoLocal.ComponentArray[0].szComponent) {
        _PathObjectInfo.ComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.ComponentArray[0].szComponent);
        if (_PathObjectInfo.ComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.ComponentArray[0].szValue) {
        _PathObjectInfo.ComponentArray[NumComponents].szValue =
            AllocADsStr(ObjectInfoLocal.ComponentArray[0].szValue);
        if (_PathObjectInfo.ComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.DisplayComponentArray[0].szComponent) {
        _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.DisplayComponentArray[0].szComponent);
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.DisplayComponentArray[0].szValue) {
        _PathObjectInfo.DisplayComponentArray[NumComponents].szValue=
            AllocADsStr(ObjectInfoLocal.DisplayComponentArray[0].szValue);
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    if (ObjectInfoLocal.ProvSpecComponentArray[0].szComponent) {
        _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.ProvSpecComponentArray[0].szComponent);
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.ProvSpecComponentArray[0].szValue) {
        _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue =
            AllocADsStr(ObjectInfoLocal.ProvSpecComponentArray[0].szValue);
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }


    _PathObjectInfo.NumComponents++;

    if (_PathObjectInfo.dwPathType == ADS_PATHTYPE_LEAFFIRST) {
        MoveLastComponentToFront(&_PathObjectInfo);
    }

    FreePathInfo(&ObjectInfoLocal);
    RRETURN(hr);
error:
    FreePathInfo(&ObjectInfoLocal);
    if (fStartAllocation) {
        if (_PathObjectInfo.ComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szComponent);
            _PathObjectInfo.ComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.ComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szValue);
            _PathObjectInfo.ComponentArray[NumComponents].szValue = NULL;
        }
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent);
            _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szValue);
            _PathObjectInfo.DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent);
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue);
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::RemoveLeafElement(void)

/*++

Routine Description:

    Remove the leaf element from the DN

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    DWORD NumComponents;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (_PathObjectInfo.dwPathType == ADS_PATHTYPE_LEAFFIRST) {
        hr = RemoveFirstElement(&_PathObjectInfo);
    }
    else {
        if (_PathObjectInfo.NumComponents > 0) {
            _PathObjectInfo.NumComponents--;
            NumComponents = _PathObjectInfo.NumComponents;

            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szComponent);
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szValue);
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent);
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szValue);
            if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent)
                FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent);
            if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue)
                FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue);

            _PathObjectInfo.ComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.ComponentArray[NumComponents].szValue = NULL;
            _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.DisplayComponentArray[NumComponents].szValue = NULL;
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue = NULL;
            hr = S_OK;
        }
    }
error:
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::CopyPath(THIS_ IDispatch **ppAdsPath)

/*++

Routine Description:

    Copy the pathname object and return a pointer to the new one

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    IADsPathname *pPathname = NULL;
    BSTR bstrResult = NULL;
    DWORD dwLength;

    long lNameType;                 // Storage for old values
    DWORD dwEscaped;
    BOOL fValueChanged = FALSE;     // indicate whether value has been changed
    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!ppAdsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    //
    // Storing the old values
    //
    dwEscaped = _dwEscaped;
    if (_fNamingAttribute) {
        lNameType = ADS_DISPLAY_FULL;
    }
    else {
        lNameType = ADS_DISPLAY_VALUE_ONLY;
    }

    //
    // Setting the type to 'show all' for retrieval
    //
    fValueChanged = TRUE;
    hr = SetDisplayType(ADS_DISPLAY_FULL);
    BAIL_ON_FAILURE(hr);

    hr = put_EscapedMode(ADS_ESCAPEDMODE_DEFAULT);
    BAIL_ON_FAILURE(hr);

    //
    // Retrieve path
    //
    hr = Retrieve(ADS_FORMAT_WINDOWS, &bstrResult);
    BAIL_ON_FAILURE(hr);

    //
    // This is a workaround for the namespace path that we return. We are 
    // currently getting 'LDAP://' back instead of 'LDAP:'. There are users who 
    // are dependent on this and thus we cannot change it to return 'LDAP://'.
    // The code below takes out the '//' if the path trails with '://' so that
    // the path is settable.
    //
    dwLength = wcslen(bstrResult);
    if (wcscmp((PWSTR)(&bstrResult[dwLength-3]),L"://") == 0) {
        bstrResult[dwLength-2] = NULL;
    }

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(bstrResult, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->SetDisplayType(lNameType);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->put_EscapedMode(dwEscaped);
    BAIL_ON_FAILURE(hr);

    *ppAdsPath = (IDispatch*)pPathname;
    pPathname = NULL;

error:
    if (fValueChanged) {
        SetDisplayType(lNameType);
        put_EscapedMode(dwEscaped);
    }
    if (pPathname) {
        pPathname->Release();
    }
    if (bstrResult) {
        SysFreeString(bstrResult);     
    }
    RRETURN_EXP_IF_ERR(hr);
}


void
CPathname::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
                pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szValue);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void
CPathname::FreePathInfo(
                PPATH_OBJECTINFO pPathObjectInfo                
                )
{
    if (pPathObjectInfo->ProviderName) {
        FreeADsStr(pPathObjectInfo->ProviderName);
        pPathObjectInfo->ProviderName = NULL;
    }
    if (pPathObjectInfo->ServerName) {
        FreeADsStr(pPathObjectInfo->ServerName);
        pPathObjectInfo->ServerName = NULL;
    }
    if (pPathObjectInfo->DisplayServerName) {
        FreeADsStr(pPathObjectInfo->DisplayServerName);
        pPathObjectInfo->DisplayServerName = NULL;
    }
    FreeObjInfoComponents(pPathObjectInfo);
    pPathObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;
}

HRESULT
CPathname::put_EscapedMode(
    long lEscaped
    )
{
    _dwEscaped = lEscaped;
    return S_OK;
}

HRESULT
CPathname::get_EscapedMode(
    long *plEscaped
    )
{
    *plEscaped = _dwEscaped;
    return S_OK;
}

//+---------------------------------------------------------------------------
// Function:    CPathname::GetEscapedElement
//
// Synopsis:    Takes the input string, escapes it assuming it is an RDN
//            and returns the output.
//              The first cut will be empty as in input string = output
//            string. Once the code to do this is added please change this
//            comment appropriately.
//
// Arguments: lnReserved (= 0 for now),
//
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-10-98   AjayR         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPathname::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    HRESULT hr = S_OK;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    hr = m_pPathnameProvider->GetEscapedElement(lnReserved,
                                                bstrInStr,
                                                pbstrOutStr);
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\setobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      openobj.cxx
//
//  Contents:  ADs Wrapper Function to open a DS object
//
//
//  History:   8-26-96     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//  Function:  ADsOpenObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
                [LPWSTR lpszUserName]
                [LPWSTR lpszPassword]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    08-26-96  krishnag  Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsOpenObject(
    LPWSTR lpszPathName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    HRESULT hr = S_OK;
    IDSNamespace lpNamespace = NULL;
    CLSID NamespaceClsid;

    hr = CoCreateInstance(
             NamespaceClsid,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IDSNamespace,
             (void **)&lpNamespace
             );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->OpenDSObject(
                lpszPathName,
                lpszUserName,
                lpszPassword,
                dwAccess,
                riid,
                ppObject
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNamespace) {
        pNamespace->Release();
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\router.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs";
LPCWSTR lpszProviders = L"Providers";

PROUTER_ENTRY
InitializeRouter()
{
    HKEY hTopLevelKey = NULL;
    HKEY hMapKey = NULL;
    HKEY hProviderKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszProvider[MAX_PATH];
    DWORD dwchProvider = 0;
    WCHAR lpszNamespace[MAX_PATH];
    WCHAR lpszAliases[MAX_PATH];
    DWORD dwchNamespace = 0;
    DWORD dwchAliases = 0;
    PROUTER_ENTRY pRouterHead = NULL, pRouterEntry = NULL;
    LPCLSID pclsid = NULL;
    HRESULT hr;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        // must succeed
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszProviders,
                     0,
                     KEY_READ,
                     &hMapKey
                     ) != ERROR_SUCCESS)

    {
        // must succeed; at least one provider from ADSI
        goto CleanupAndExit;

    }

    memset(lpszProvider, 0, sizeof(lpszProvider));
    
    //
    // Size has to be in number of TCHARS not in bytes.
    //
    dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);

    while(RegEnumKeyEx(hMapKey,
                     dwIndex++,  // + index even if last 1 bail out in mid loop
                     lpszProvider,
                     &dwchProvider,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hMapKey,
                         lpszProvider,
                         0,
                         KEY_READ,
                         &hProviderKey
                         ) != ERROR_SUCCESS)
        {
            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //

            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }

        memset(lpszNamespace, 0, sizeof(lpszNamespace));
        dwchNamespace = sizeof(lpszNamespace);

        if (RegQueryValueEx(hProviderKey,
                            NULL,
                            NULL,
                            NULL,
                            (LPBYTE) lpszNamespace,
                            &dwchNamespace
                            ) != ERROR_SUCCESS)
        {
            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //

            RegCloseKey(hProviderKey);
            hProviderKey = NULL;
            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }


        //
        // If Aliases value name is defined, get the values
        //

        memset(lpszAliases, 0, sizeof(lpszAliases));
        dwchAliases = sizeof(lpszAliases);

        RegQueryValueEx(hProviderKey,
                            L"Aliases",
                            NULL,
                            NULL,
                            (LPBYTE) lpszAliases,
                            &dwchAliases
                            );

        RegCloseKey(hProviderKey);
        hProviderKey = NULL;

        //
        // Generate CLSID from the ProgID
        //

        pclsid = (LPCLSID)LocalAlloc(LPTR,
                                     sizeof(CLSID));
        if (!pclsid) {

            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //
            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }

        hr = CLSIDFromProgID(lpszNamespace, pclsid);

        if (FAILED(hr)) {
            LocalFree(pclsid);
        } else {
            if (pRouterEntry = (PROUTER_ENTRY)LocalAlloc(LPTR,
                                                       sizeof(ROUTER_ENTRY))){
                wcscpy(pRouterEntry->szProviderProgId, lpszProvider);
                wcscpy(pRouterEntry->szNamespaceProgId, lpszNamespace);
                wcscpy(pRouterEntry->szAliases, lpszAliases);
                pRouterEntry->pNamespaceClsid = pclsid;
                pRouterEntry->pNext = pRouterHead;
                pRouterHead = pRouterEntry;
            }
        }

        memset(lpszProvider, 0, sizeof(lpszProvider));
        dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
    }

CleanupAndExit:
    if (hProviderKey) {
        RegCloseKey(hProviderKey);
    }
    if (hMapKey) {
        RegCloseKey(hMapKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pRouterHead);
}

void 
CleanupRouter(
    PROUTER_ENTRY pRouterHead
    )
{

    PROUTER_ENTRY pRouter = pRouterHead, pRouterNext = NULL;

    while (pRouter) {
        pRouterNext = pRouter->pNext;
        if (pRouter->pNamespaceClsid) {
            LocalFree(pRouter->pNamespaceClsid);
        }
        LocalFree(pRouter);

        pRouter = pRouterNext;
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\row.cxx ===
// Row.cxx : Implementation of CRow
#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#include "row.hxx"
#include "cstream.h"

HRESULT PackLargeInteger(LARGE_INTEGER *plargeint, PVARIANT pVarDestObject);
#define ARRAYSIZE(x)    sizeof((x))/sizeof((x)[0])

extern const WCHAR g_cwszSpecialColumnURL[] = L"RESOURCE_ABSOLUTE_PARSENAME";
extern const WCHAR g_cwszAdsPath[]                      = L"ADsPath";

//----------------------------------------------------------------------------
// Note on m_fIsTearOff and m_fGetColInfoFromRowset
//
// m_fIsTearOff is set to TRUE when the row is a tear-off from a rowset from 
// the client's point of view i.e, the client created a rowset and got a row
// off the rowset. Thus, a call to GetSourceRowset returns a rowset interface
// pointer only if m_fIsTearOff is TRUE. 
// m_fGetColInfoFromRowset is set to TRUE if the row should get the column
// info and the column values from the rowset. If FALSE, this information is 
// obtained through ADSI calls.
//
// There are 4 cases of interest.
//
// 1) The row is obtained directly from a command object using a query which
// doesn't specify "SELECT *" i.e, not all attributes are requested OR the row
// is obtained directly from a session object (defaults to no "SELECT *"). This 
// is implemented by actually creating a rowset and getting its first row.
// In this case m_fIsTearOff is FALSE, m_fGetColInfoFromRowset is
// TRUE and m_pSourceRowset is non-NULL. Thus, if the client called 
// GetSourceRowset on the row, no interface pointer is returned. However, there
// is a rowset backing up this row and this is used for getting column info and
// column values. 
//
// 2) The row is obtained directly from a command object using SELECT *
// as the query. In this case, m_fIsTearOff is FALSE, m_fGetColInfoFromRowset 
// is FALSE and m_pSourceRowset is non-NULL. Though m_pSourceRowset is 
// non-NULL, it is not used.
// 
// An alternative scheme would be to to call CSession::Bind directly in this 
// case which would obviate the need for keeping a rowset around.
//
// 3) The row is obtained from a rowset using GetRowFromHROW. In this case,
// m_fIsTearOff is TRUE. However, if the rowset was created from a command 
// object using a SELECT * query, then m_fGetColInfoFromRowset is FALSE.
// Otherwise, fGetColInfoFromRowset is TRUE. m_pSourceRowset is non-NULL.
//
// 4) The row is created using IBindResource::Bind. In this case, m_fIsTearOff 
// is FALSE, m_fGetColInfoFromRowset is FALSE and m_pSourceRowset is NULL.
//
// The following table summarizes the above 4 cases.
//
// m_fIsTearOff m_fGetColInfoFromRowset             Description
// ------------ -----------------------             ------------
//     T                T                   GetRowFromHROW, not SELECT *
//     F                F                   Row obtained from command object
//                                          using SELECT * OR 
//                                          Row got using IBindResource::Bind
//     T                F                   GetRowFromHROW, SELECT *
//     F                T                   Row obtained from command object
//                                          without a SELECT * query OR
//                                          Row obtained from session object 
//
// Every row object has a special URL column. The URL column (and any row
// columns that are not in the source rowset) should appear after all the
// source rowset columns.
//
// ADsPath needs to be treated as a special case. If m_fGetColInfoFromRowset
// is TRUE, then we will get the ADsPath just by using the rowset's copy
// of the column. However, if m_fGetColInfoFromRowset is FALSE, then
// the row should return ADsPath if it is a tear-off AND ADsPath is one of the 
// columns of the source rowset. This is required by the OLEDB spec
// since the row's columns should be a superset of the rowset's columns. 
// Currently, the only case where this would happen is a SELECT * query that
// requests a rowset and then a row is obtained from that rowset. In this case,
// the row adds ADsPath to the columns it returns. To be consistent, if a row  
// is obtained from a command object using a SELECT * query OR the row is
// obtained using IBindResource::Bind(), then ADsPath is added to the columns
// returned by the row.
//
//----------------------------------------------------------------------------
// 

//////////////////////////////////////////////////////////////////////////////
//helper functions
//
//+---------------------------------------------------------------------------
//
//  Function:  GetIDataConvert
//
//  Synopsis: Create OLE DB conversion library and store it in static.
//
//  Arguments:
//              [out] pointer to pointer to IDataConvert
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT GetIDataConvert(IDataConvert** ppDataConvert)
{
    HRESULT                                                 hr = S_OK;
    auto_rel<IDataConvert> pIDataConvert;
    auto_rel<IDCInfo>                               pIDCInfo;
    DCINFO          rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0200}}};
    
    ADsAssert(ppDataConvert);
    
    hr = CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDataConvert,
            (void **) &pIDataConvert);
    if (FAILED(hr))
        goto exit;
        
    // Tell data convert our OLE DB version
    hr = pIDataConvert->QueryInterface(IID_IDCInfo,
            (void **)&pIDCInfo);
    if( SUCCEEDED(hr) )
        hr = pIDCInfo->SetInfo(ARRAYSIZE(rgInfo), rgInfo);
        
    // auto_rel operator = does the release
    if( FAILED(hr) )
            pIDataConvert = NULL;
    
    if (pIDataConvert)
        pIDataConvert->AddRef();
    *ppDataConvert = pIDataConvert;

exit:
    RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////
//Internal methods
//

//+---------------------------------------------------------------------------
//
//  Function: CRow::Initialize
//
//  Synopsis: Initializes a directly bound CRow object as opposed to a row
//            created from a rowset. See the other overloaded Initialize below.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Initialize(PWSTR                     pwszURL,
                              IUnknown              *pSession,
                              IAuthenticate *pAuthenticate,
                              DWORD                 dwBindFlags,
                              BOOL                  fIsTearOff,
                              BOOL                  fGetColInfoFromRowset,
                              CCredentials          *pSessCreds,
                              bool                  fBind)
{
    HRESULT                 hr = S_OK;
    auto_leave              cs_auto_leave(m_autocs);
    DWORD                   fAuthFlags;
 
    //Make sure we have a valid session.
    ADsAssert(pSession);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        m_dwBindFlags = dwBindFlags;
        m_objURL = pwszURL;
        m_pSession = pSession;
        m_pSession->AddRef();
        
        if (!fBind) //no need to bind. Just return.
            RRETURN(S_OK);

        m_fIsTearOff = fIsTearOff;
        m_fGetColInfoFromRowset = fGetColInfoFromRowset;
   
        // Any changes made below should also be made in the overloaded
        // Initialize() below for consistency.

        // Fix for 351040. Use explicit credentials first, then credentials in
        // session object, then default credentials. Credential in session
        // object will be the default credentials if we come in through the
        // binder. But, if IBindResource is obtained from the session object,
        // then the credentials may not be the default credentials. From ADO,
        // using Open without specifying an active connection causes the 
        // binder to be invoked. If an active connection is specified, then 
        // IBindResource is obtained from the session object.
       
        if(pAuthenticate)
        {
            hr = GetCredentialsFromIAuthenticate(pAuthenticate, 
                     m_objCredentials);
            if(FAILED(hr))
               BAIL_ON_FAILURE(E_INVALIDARG);

            fAuthFlags = m_objCredentials.GetAuthFlags();
            m_objCredentials.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        if( (!pAuthenticate) || (INVALID_CREDENTIALS_ERROR(hr)) )
        // try credentials in session object
        {
            m_objCredentials = *pSessCreds;

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        if(INVALID_CREDENTIALS_ERROR(hr))
        // try default credentials
        {
            CCredentials TmpCreds; // default credentials

            m_objCredentials = TmpCreds;
            fAuthFlags = m_objCredentials.GetAuthFlags();
            m_objCredentials.SetAuthFlags(fAuthFlags | 
                        ADS_SECURE_AUTHENTICATION);                        

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        BAIL_ON_FAILURE(hr);
        
        //Get the Schema Root and store it in m_bstrSchemaRoot
        hr = GetSchemaRoot();
        BAIL_ON_FAILURE(hr);
        
        // Get the data. without the GetRestrictedColunInfo will no return column information.
        hr = m_pADsObj->GetInfo();
        BAIL_ON_FAILURE(hr);
        
	CATCHBLOCKBAIL(hr)    

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::Initialize
//
//  Synopsis: Initializes a row object that represents a row in a rowset as
//                        as opposed to a directly bound row object.
//            See the other overloaded Initialize above.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Initialize(
                              PWSTR                   pwszURL,
                              IUnknown                *pSession,
                              IUnknown                *pSourceRowset,
                              HROW                    hRow,
                              PWSTR                   pwszUser,
                              PWSTR                   pwszPassword,
                              DWORD                   dwBindFlags,
                              BOOL                    fIsTearOff,
                              BOOL                    fGetColInfoFromRowset,
                              CRowProvider            *pRowProvider
                              )
{
    HRESULT                                 hr = S_OK;
    auto_leave                              cs_auto_leave(m_autocs);
    DWORD                                   fAuthFlags;
    auto_rel<IRowset>               pRowset;
    auto_rel<IColumnsInfo>  pRowsetColumnsInfo;
    
    //Make sure we have valid arguments
    ADsAssert(pSession);
    ADsAssert(pSourceRowset);
    ADsAssert(hRow != DB_NULL_HROW);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        if (pRowProvider == NULL)
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        
        m_pRowProvider = pRowProvider;
        m_dwBindFlags = dwBindFlags;
        m_pSession = pSession;
        m_pSession->AddRef();
        m_pSourceRowset = pSourceRowset;
        m_hRow = hRow;
        m_fIsTearOff = fIsTearOff;
        m_fGetColInfoFromRowset = fGetColInfoFromRowset; 
        pSourceRowset->AddRef();
        
        //Get IRowset pointer
        hr = pSourceRowset->QueryInterface(__uuidof(IRowset),
            (void **)&pRowset);
        BAIL_ON_FAILURE(hr);
        
        //Get Rowset columns info and store it. Spec says a row's columns
        //are always a superset of those of the source rowset. To make
        //sure we return proper columns info from row object,
        //we need the rowset's column info.
        hr = pSourceRowset->QueryInterface(
            __uuidof(IColumnsInfo),
            (void **)&pRowsetColumnsInfo);
        BAIL_ON_FAILURE(hr);
        hr = pRowsetColumnsInfo->GetColumnInfo(
            &m_cSourceRowsetColumns,
            &m_pSourceRowsetColumnInfo,
            &m_pSourceRowsetStringsBuffer);
        BAIL_ON_FAILURE(hr);
        
        //Get username, password and authFlags from Credentials.
        hr = m_objCredentials.SetUserName(pwszUser);
        BAIL_ON_FAILURE(hr);
        hr = m_objCredentials.SetPassword(pwszPassword);
        BAIL_ON_FAILURE(hr);
        
        //Store the URL and AddRef row handle.
        m_objURL = pwszURL;
        hr = pRowset->AddRefRows(1, &m_hRow, NULL, NULL);
        BAIL_ON_FAILURE(hr);

        //check  if the column info is to be obtained thruogh ADSI
        if( !fGetColInfoFromRowset )
        {
             // code below should be consistent with the Initialize() call
             // (overloaded function above) used for direct binding

             DWORD fAuthFlags = m_objCredentials.GetAuthFlags();
             m_objCredentials.SetAuthFlags(fAuthFlags | 
                                           ADS_SECURE_AUTHENTICATION);

             hr = GetDSInterface(
                  pwszURL,
                  m_objCredentials,
                  IID_IADs,
                  (void **)&m_pADsObj
                  );

             BAIL_ON_FAILURE(hr);

            //Get the Schema Root and store it in m_bstrSchemaRoot
            hr = GetSchemaRoot();
            BAIL_ON_FAILURE(hr);

            // Get the data. without it GetRestrictedColunInfo will not return 
            // column info.
            hr = m_pADsObj->GetInfo();
            BAIL_ON_FAILURE(hr);            
        } 
	
	CATCHBLOCKBAIL(hr)

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::fMatchesMaskCriteria
//
//  Synopsis: Tells if the given column name matches any mask criteria
//            for column ids.
//
//  Returns:  true if matches, false otherwise
//----------------------------------------------------------------------------
bool CRow::fMatchesMaskCriteria(PWCHAR pwszColumnName,
                                ULONG cColumnIDMasks,
                                const DBID rgColumnIDMasks[  ])
{
    //if there are no masks, the name is a match.
    if (cColumnIDMasks == 0)
        return true;
    
    ULONG ulStrLen = 0;
    for (int j = 0; j < cColumnIDMasks; j++)
    {
        if( (rgColumnIDMasks[j].eKind != DBKIND_NAME) ||
            (NULL == rgColumnIDMasks[j].uName.pwszName) )
            continue;

        ulStrLen = wcslen(rgColumnIDMasks[j].uName.pwszName);
        if (_wcsnicmp(  rgColumnIDMasks[j].uName.pwszName,
            pwszColumnName,
            ulStrLen ) == 0)
        {
            // Matches criterion
            return true;
        }
    }
    //doesn't match.
    return false;
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::fMatchesMaskCriteria (OVERLOADED)
//
//  Synopsis: Tells if the given column id matches any mask criteria
//            for column ids.
//
//  Returns:  true if matches, false otherwise
//----------------------------------------------------------------------------
bool CRow::fMatchesMaskCriteria(DBID columnid,
                                ULONG cColumnIDMasks,
                                const DBID rgColumnIDMasks[  ])
{
    //if there are no masks, the name is a match.
    if (cColumnIDMasks == 0)
        return true;
    
    ULONG ulStrLen = 0;
    for (int j = 0; j < cColumnIDMasks; j++)
    {
        if (TRUE == CompareDBIDs(&columnid, &rgColumnIDMasks[j]))
        {
            // Matches criterion
            return true;
        }
    }
    //doesn't match.
    return false;
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSchemaAttributes
//
//  Synopsis: Gets MultiValued and MaxRange Attributes of an ADS Property.
//                        Any of these can be NULL indicating the caller is not interested
//            in getting the attribute.
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSchemaAttributes(
                                  PWCHAR                  pwszColumnName,
                                  VARIANT_BOOL    *pfMultiValued,
                                  long                    *plMaxRange
                                  )
{
    HRESULT                                         hr = S_OK;
    auto_rel<IADsProperty>          pProperty;
    CComBSTR                                        bstrSchemaName;
    
    ADsAssert(m_bstrSchemaRoot.Length());
    ADsAssert(pwszColumnName != NULL);
    
    //Does the caller want at least one attribute?
    if (!pfMultiValued && !plMaxRange)
        return S_OK;
    
    //Append a '/' and property name to root schema name
    //to make the Schema ADsPath for this property.
    bstrSchemaName = m_bstrSchemaRoot;
    bstrSchemaName.Append(L"/");
    bstrSchemaName.Append(pwszColumnName);
    
    //Bind to the schema entry and get IADsProperty interface.
    hr = GetDSInterface(
        bstrSchemaName,
        m_objCredentials,
        __uuidof(IADsProperty),
        (void **)&pProperty
        );
    BAIL_ON_FAILURE(hr);
    
    if (pfMultiValued != NULL)
    {
        //Get multivalued attribute.
        hr = pProperty->get_MultiValued(pfMultiValued);
        BAIL_ON_FAILURE(hr);
    }
    
    // The following call get_MaxRange seems to create perf problems
    // because it apparently requires a round-trip to the server.
    // This is not critical and we cn live without asking
    // for max range here.
    
    //if (plMaxRange != NULL)
    //{
    //        //Get MaxSize attribute. Ignore error
    //        //since some properties may not have
    //        //this attribute set.
    //        pProperty->get_MaxRange(plMaxRange);
    //}
    
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetTypeAndSize
//
//  Synopsis: Gets the type and size of a property
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetTypeAndSize(
                             ADSTYPE                      dwADsType,
                             CComBSTR&                    bstrPropName,
                             DBTYPE                               *pdbType,
                             ULONG                                *pulSize
                             )
{
    ADsAssert(pdbType != NULL);
    ADsAssert(pulSize != NULL);
    
    long                                    lAdsType = dwADsType;
    VARIANT_BOOL                    fMultiValued = VARIANT_FALSE;
    HRESULT                                 hr = S_OK;
    
    //Initialize out params
    *pdbType = DBTYPE_ERROR;
    *pulSize = ~0;
    
    hr = GetSchemaAttributes(bstrPropName, &fMultiValued, (long *)pulSize);
    BAIL_ON_FAILURE(hr);
    
    //Give our best shot at determining type and size.
    if (fMultiValued == VARIANT_TRUE)
        *pdbType = DBTYPE_BYREF | DBTYPE_VARIANT;
    else if  (lAdsType < g_cMapADsTypeToDBType2)
        *pdbType = g_MapADsTypeToDBType2[lAdsType].wType;
    else
        *pdbType = DBTYPE_ERROR;
    
    // If we could not determine the size from schema information,
    // set the size from the mapping table.
    if (*pulSize == ~0)
        *pulSize = g_MapADsTypeToDBType2[lAdsType].ulSize;
    
error:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSchemaRoot
//
//  Synopsis: Gets the root schema path and stores it in m_bstrSchemaRoot
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSchemaRoot()
{
    HRESULT                 hr = S_OK;
    CComBSTR                bstrSchema;
    auto_rel<IADs>  pADsSchema;
    
    Assert(m_pADsObj.get());
    
    hr = m_pADsObj->get_Schema(&bstrSchema);
    BAIL_ON_FAILURE(hr);
    
    hr = GetDSInterface(
        bstrSchema,
        m_objCredentials,
        __uuidof(IADs),
        (void **)&pADsSchema
        );
    BAIL_ON_FAILURE(hr);
    
    hr = pADsSchema->get_Parent(&m_bstrSchemaRoot);
    BAIL_ON_FAILURE(hr);
    
error:
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSourceRowsetColumns
//
//  Synopsis: Gets the requested column data from the source rowset.
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSourceRowsetColumns(
                                     ULONG cColumns,
                                     DBCOLUMNACCESS rgColumns[],
                                     ULONG *pcErrors )
{
    // Make sure there is a rowset backing this row (this doesn't imply that
    // the row is a tear-off (see comment at the beginning).
    ADsAssert(m_pSourceRowset.get() != NULL);
    ADsAssert(m_pRowProvider != NULL);
    ADsAssert(m_fGetColInfoFromRowset == TRUE);
    
    HRESULT                             hr = S_OK;
    auto_rel<IAccessor>         pAccessor;
    auto_rel<IRowset>       pRowset;
    auto_rel<IColumnsInfo>  pColumnsInfo;
    HACCESSOR                           hAccessor;
    ULONG                               iCol;
    ULONG                               ulRefCount = 0;
    DBBINDING               binding = {0};
    DBBINDSTATUS            bindStatus = {0};
    int                     iRowsetIndex;
    DBID                    dbidRowUrl = DBROWCOL_ROWURL;
    
    ADsAssert(pcErrors != NULL);
    
    *pcErrors = 0;
    hr = m_pSourceRowset->QueryInterface(&pRowset);
    BAIL_ON_FAILURE(hr);
    
    hr = m_pSourceRowset->QueryInterface(&pAccessor);
    BAIL_ON_FAILURE(hr);
    
    hr = m_pSourceRowset->QueryInterface(&pColumnsInfo);
    BAIL_ON_FAILURE(hr);
    
    for (iCol = 0; iCol < cColumns; iCol++)
    {
        rgColumns[iCol].dwStatus = DBSTATUS_S_OK;
        if( (rgColumns[iCol].pData != NULL) &&
                (!IgnorecbMaxLen(rgColumns[iCol].wType)) )
            ZeroMemory(rgColumns[iCol].pData, rgColumns[iCol].cbMaxLen);

        //Is this the special URL column.
        if(TRUE == CompareDBIDs(&dbidRowUrl, &rgColumns[iCol].columnid))
        {
            CComVariant varTemp;

            varTemp.Clear();
            varTemp = m_objURL;
            //Set max length of column. 256 is consistent with 2.0 code.
            rgColumns[iCol].cbDataLen = 256;
            rgColumns[iCol].dwStatus = DBSTATUS_S_OK;

            //Does the caller want pData?
            if (rgColumns[iCol].pData != NULL)
            {
                //Get IDataConvert interface pointer.
                auto_rel<IDataConvert> pDataConvert;
                hr = GetIDataConvert(&pDataConvert);

                if(SUCCEEDED(hr))
                    hr = pDataConvert->DataConvert(
                            DBTYPE_VARIANT,
                            rgColumns[iCol].wType,
                            sizeof(VARIANT),
                            &rgColumns[iCol].cbDataLen,
                            &varTemp,
                            rgColumns[iCol].pData,
                            rgColumns[iCol].cbMaxLen,
                            DBSTATUS_S_OK,
                            &rgColumns[iCol].dwStatus,
                            rgColumns[iCol].bPrecision,
                            rgColumns[iCol].bScale,
                            DBDATACONVERT_DEFAULT
                            );

                if(FAILED(hr)) 
                {
                    hr = S_OK;

                    // rgColumns[iCol].dwStatus already set above by 
                    // DataConvert().

                    (*pcErrors)++;
                    continue;
                }
            }
            continue; // on to next column
        }
        
        //Is this the bookmark column?
        if (rgColumns[iCol].columnid.eKind == DBKIND_GUID_PROPID &&
            rgColumns[iCol].columnid.uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumns[iCol].columnid.uName.ulPropid == 2 )
        {
            iRowsetIndex = 0;  // bookmark is first column

        }
        else
        {
        
            // Is column id of DBKIND_NAME?
            if (rgColumns[iCol].columnid.eKind != DBKIND_NAME)
            {
                rgColumns[iCol].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                (*pcErrors)++;
                continue;
            }
        
            iRowsetIndex = 0;
            hr = m_pRowProvider->GetIndex(
                pColumnsInfo,
                rgColumns[iCol].columnid.uName.pwszName,
                iRowsetIndex
            );
            if (FAILED(hr) || 0 == iRowsetIndex) // failure or name not found
            {
                hr = S_OK;
                if(FAILED(hr))
                    rgColumns[iCol].dwStatus = DBSTATUS_E_UNAVAILABLE;
                else
                    rgColumns[iCol].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                (*pcErrors)++;
                continue;
            }
        } // else
        
        binding.dwPart = DBPART_VALUE;
        binding.obLength = 0;
        binding.bPrecision = rgColumns[iCol].bPrecision;
        binding.bScale = rgColumns[iCol].bScale;
        binding.pTypeInfo = 0;
        binding.pObject = NULL;
        binding.iOrdinal = iRowsetIndex;
        binding.cbMaxLen = rgColumns[iCol].cbMaxLen;
        binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        binding.wType =  rgColumns[iCol].wType;
        
        hr = pAccessor->CreateAccessor(
            DBACCESSOR_ROWDATA,
            1,
            &binding,
            0,
            &hAccessor,
            &bindStatus
            );
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            (*pcErrors)++;
            hr = S_OK;
            continue;
        }
       
        if(rgColumns[iCol].pData != NULL)
        { 
            hr = pRowset->GetData(m_hRow, hAccessor, rgColumns[iCol].pData);
            if (FAILED(hr))
            {
                rgColumns[iCol].dwStatus = StatusFromHRESULT(hr);
                (*pcErrors)++;
                hr = S_OK;
                pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);
                continue;
            }
        }

        hr = pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);

        // now get the status and length
        binding.dwPart = DBPART_LENGTH | DBPART_STATUS;
        binding.obStatus = FIELD_OFFSET(DBCOLUMNACCESS, dwStatus);
        binding.obLength = FIELD_OFFSET(DBCOLUMNACCESS, cbDataLen);

        hr = pAccessor->CreateAccessor(
                DBACCESSOR_ROWDATA,
                1,
                &binding,
                0,
                &hAccessor,
                &bindStatus
                );
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            (*pcErrors)++;
            hr = S_OK;
            continue;
        }

        hr = pRowset->GetData(m_hRow, hAccessor, &(rgColumns[iCol]));
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = StatusFromHRESULT(hr);
            (*pcErrors)++;
        }

        hr = pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);
        // We have set the dwStatus to reflect any problems, so clear error.
        hr = S_OK;
    }
    
error:
    if (FAILED(hr))
    {
        for (iCol = 0; iCol < cColumns; iCol++)
            rgColumns[iCol].dwStatus = DBSTATUS_E_UNAVAILABLE;
        
        *pcErrors = cColumns;
    }
    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::StatusFromHRESULT
//
//  Synopsis: Gets DBSTATUS from a given HRESULT.
//
//  Returns:  DBSTATUS
//----------------------------------------------------------------------------
DBSTATUS CRow::StatusFromHRESULT(HRESULT hr)
{
    if (SUCCEEDED(hr))
        RRETURN(DBSTATUS_S_OK);

    switch(hr)
    {
        case (E_INVALIDARG):
            RRETURN(DBSTATUS_E_CANTCREATE);
            
        case (DB_E_BADACCESSORHANDLE):
        case (DB_E_BADACCESSORTYPE):
        case (DB_E_BADBINDINFO):
        case (DB_E_BADORDINAL):
        case (DB_E_BADSTORAGEFLAGS):
            RRETURN(DBSTATUS_E_CANTCONVERTVALUE);

        case (DB_E_UNSUPPORTEDCONVERSION):
            RRETURN(DBSTATUS_E_CANTCONVERTVALUE);

        case (DB_E_BADROWHANDLE):
        case (DB_E_DELETEDROW):
            RRETURN(DBSTATUS_E_UNAVAILABLE);

        default:
            RRETURN(DBSTATUS_E_BADSTATUS);
     }
}

//////////////////////////////////////////////////////////////////////////////
//ISupportErrorInfo
//
//+---------------------------------------------------------------------------
//
//  Function:  CRow::InterfaceSupportsErrorInfo
//
//  Synopsis: Given an interface ID, tells if that interface supports
//            the interface ISupportErrorInfo
//
//  Arguments:
//              REFIID riid
//
//  Returns:    HRESULT
//              S_OK             yes, the interface supports ISupportErrorInfo
//              S_FALSE                  no, the interface doesn't support it.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IRow,
            &IID_IColumnsInfo,
            &IID_IColumnsInfo2,
            &IID_IConvertType,
            &IID_IGetSession
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            RRETURN(S_OK);
    }
    RRETURN(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//IRow methods
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetColumns
//
//  Synopsis:   Gets Columns from a Row.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetColumns(
                              /* [in] */ DBORDINAL cColumns,
                              /* [size_is][out][in] */ DBCOLUMNACCESS rgColumns[ ])
{
    HRESULT                                         hr;
    DWORD                                           cErrors = 0;
    auto_leave                                      cs_auto_leave(m_autocs);
    int                                             i;
    DBID                                            dbidRowUrl = DBROWCOL_ROWURL;
    
    if ( cColumns == 0 )
    {
        // Nothing to do:
        RRETURN(S_OK);
    }
    
    if (!rgColumns)
        RRETURN(E_INVALIDARG);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        // We must have a valid ADs object or a valid Source Rowset
        ADsAssert(m_pADsObj.get() || m_pSourceRowset.get());
    
        if( m_fGetColInfoFromRowset )    
        {
            ADsAssert(m_pSourceRowset.get() != NULL);
            hr = GetSourceRowsetColumns(cColumns, rgColumns, &cErrors);
        }
        else
        {
            //Get IDataConvert interface pointer.
            auto_rel<IDataConvert> pDataConvert;
            hr = GetIDataConvert(&pDataConvert);
            if (FAILED(hr))
                BAIL_ON_FAILURE(hr = DB_E_ERRORSOCCURRED);
            
            for (i = 0; i < cColumns; i++)
            {
                // DBKIND is DBKIND_NAME and null or zero length column name
                if ( rgColumns[i].columnid.eKind == DBKIND_NAME &&
                     (rgColumns[i].columnid.uName.pwszName == NULL ||
                      wcslen(rgColumns[i].columnid.uName.pwszName) == 0))
                {
                    rgColumns[i].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                    cErrors++;
                    continue;
                }
                
                CComVariant varTemp;
                DBTYPE      propType = DBTYPE_VARIANT;
                
                varTemp.Clear();
                
                hr = S_OK;
                //Check if this is the special URL column or the ADsPath 
                //column. If so, assign the URL to varTemp and proceed to data 
                //conversion.
                if (  (rgColumns[i].columnid.eKind == DBKIND_NAME && 
                       _wcsicmp(rgColumns[i].columnid.uName.pwszName, g_cwszAdsPath) == 0) ||
                      (TRUE == CompareDBIDs(&dbidRowUrl, &rgColumns[i].columnid))
                   )
                     
                {
                    varTemp = m_objURL;
                    //Set max length of column.
                    //MaxLen=256 is consistent with 2.0 provider code.
                    rgColumns[i].cbDataLen = 256;
                }
                // check if this is the bookmark column
                else if (rgColumns[i].columnid.eKind == DBKIND_GUID_PROPID &&
                         rgColumns[i].columnid.uGuid.guid == DBCOL_SPECIALCOL &&
                         rgColumns[i].columnid.uName.ulPropid == 2 )
                {
                    UINT uBmk;

                    if( m_hRow != DB_NULL_HROW )
                    // get the bookmark associated with this row handle
                    {
                        auto_rel<IRowset> pRowset;
                        CRowset *pCRowset;
                        LONG lRow;
                        RBOOKMARK bmk;

                        hr = m_pSourceRowset->QueryInterface(__uuidof(IRowset),
                                   (void **)&pRowset);
                        if( SUCCEEDED(hr) )
                        {    
                            pCRowset = (CRowset *) ((IRowset *) pRowset);
                            lRow = pCRowset->HROWToRow(m_hRow);
                            bmk = pCRowset->RowToBmk(lRow);
           
                            uBmk = (UINT) bmk;
                        }
                    }
                    else // use any value for bookmark
                        uBmk = 0;
    
                    if( SUCCEEDED(hr) )
                    {
                        VARIANT vTmpVariant;

                        V_VT(&vTmpVariant) = VT_UI4;
                        V_UI4(&vTmpVariant) = uBmk;

                        varTemp = vTmpVariant;
                    }
                    // else we will fail below and continue to next iteration 
                }
                else if (rgColumns[i].columnid.eKind == DBKIND_NAME)
                {
                    //Find out if property is multivalued and its size.
                    VARIANT_BOOL    fMultiValued;
                    long                    lSize = ~0;
                    hr = GetSchemaAttributes(
                        rgColumns[i].columnid.uName.pwszName,
                        &fMultiValued,
                        &lSize
                        );
                    if (SUCCEEDED(hr))
                    {
                        // if security descriptor is requested as a variant,
                        // then we return a variant with an octet string
                        // inside. This would always be the case with ADO as
                        // it requests all columns as variants. If it is 
                        // requested as an octet string, we return an octet
                        // string. If it is  requested as some other 
                        // type from C++ (say DBTYPE_IDISPATCH), then we will
                        // call Get/GetEx and try to convert the resulting 
                        // variant to the appropriate type. Returning security
                        // descriptor as an octet string is much cheaper as
                        // there is no network traffic for ACE conversion.
                        if( (!_wcsicmp(rgColumns[i].columnid.uName.pwszName,
                                               NT_SEC_DESC_ATTR)) &&
                                      ((rgColumns[i].wType & DBTYPE_VARIANT) ||
                                        (rgColumns[i].wType & DBTYPE_BYTES)) )
                        {
                            hr = GetSecurityDescriptor(&rgColumns[i],
                                                       fMultiValued);
                            if(FAILED(hr)) 
                            {
                                // Clear error. Status has already been set
                                // in rgColumns[i]
                                hr = S_OK;
                                cErrors++;
                            }
                            
                            //Nothing more to do, continue with next column.
                            continue;
                        }
                            
                        if (fMultiValued)
                        {
                            //multi-valued column. Use GetEx.
                            hr = m_pADsObj->GetEx(
                                rgColumns[i].columnid.uName.pwszName,
                                &varTemp
                                );
                            
                            propType = DBTYPE_BYREF | DBTYPE_VARIANT;
                        }
                        else
                        {
                            //single-valued. Use Get.
                            hr = m_pADsObj->Get(
                                rgColumns[i].columnid.uName.pwszName,
                                &varTemp
                                );
                        }
                    }
                    
                    rgColumns[i].cbDataLen = lSize;
                }
                else
                {
                    rgColumns[i].dwStatus = DBSTATUS_E_UNAVAILABLE;
                    cErrors++;
                    continue;
                }
                
                if (FAILED(hr))
                {
                    //Clear error. dwStatus below will reflect
                    //the error for this column.
                    hr = S_OK;
                    
                    rgColumns[i].dwStatus = DBSTATUS_E_UNAVAILABLE;
                    
                    cErrors++; //Increment error count.
                    
                    //Nothing more to do, continue with next column.
                    continue;
                }
                
                //Does the caller want pData?
                if (rgColumns[i].pData != NULL)
                {
                    rgColumns[i].dwStatus = DBSTATUS_S_OK;
                    
                    //Convert data into requested type
                    if (propType == (DBTYPE_VARIANT | DBTYPE_BYREF)) //multi-valued
                    {
                        if( !(rgColumns[i].wType & DBTYPE_VARIANT) )
                        // can't convert a multi-valued attr. to anything else
                        {
                            rgColumns[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                            cErrors++;
                            continue;
                        }
                        else
                        {
                            DWORD dwRequiredLen;
                            PVARIANT pVar;

                            if((rgColumns[i].wType & (~DBTYPE_BYREF)) != 
                                                         DBTYPE_VARIANT)
                            {
                                // bad type
                                rgColumns[i].dwStatus =
                                        DBSTATUS_E_CANTCONVERTVALUE;
                                cErrors++;
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                                dwRequiredLen = sizeof(VARIANT *);
                            else
                                dwRequiredLen = sizeof(VARIANT);

                            if(rgColumns[i].cbMaxLen < dwRequiredLen)
                            {
                                rgColumns[i].dwStatus =
                                    DBSTATUS_E_CANTCONVERTVALUE;
                                cErrors++;
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                            { 
                                pVar = (PVARIANT)
                                          CoTaskMemAlloc(sizeof(VARIANT));
                                if (pVar == NULL)
                                {
                                    rgColumns[i].dwStatus = 
                                          DBSTATUS_E_CANTCREATE;
                                    cErrors++;
                                    continue;
                                }
                            }
                            else
                                pVar = (PVARIANT) rgColumns[i].pData;

                            VariantInit(pVar);
                            hr = VariantCopy(pVar, &varTemp);
                            if(FAILED(hr))
                            {
                                hr = S_OK;
                                rgColumns[i].dwStatus = DBSTATUS_E_CANTCREATE;
                                cErrors++;
                                if(rgColumns[i].wType & DBTYPE_BYREF)
                                    CoTaskMemFree(pVar); 
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                            {
                                *(PVARIANT *)rgColumns[i].pData = pVar;
                                rgColumns[i].cbDataLen = sizeof(PVARIANT);
                            }
                            else
                                rgColumns[i].cbDataLen = sizeof(VARIANT);
                        }
                    }
                    else //single valued
                    {
                        hr = pDataConvert->DataConvert(
                            propType,
                            rgColumns[i].wType,
                            sizeof(VARIANT),
                            &rgColumns[i].cbDataLen,
                            &varTemp,
                            rgColumns[i].pData,
                            rgColumns[i].cbMaxLen,
                            DBSTATUS_S_OK,
                            &rgColumns[i].dwStatus,
                            rgColumns[i].bPrecision,
                            rgColumns[i].bScale,
                            DBDATACONVERT_DEFAULT
                            );
                    }
                    if (FAILED(hr))
                    {
                        hr = S_OK;
                        rgColumns[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                        cErrors++;
                    }
                }
            }
        }
	
	    CATCHBLOCKBAIL(hr)        
        
		if (cErrors == 0)
            RRETURN(S_OK);
        else if (cErrors < cColumns)
            RRETURN(DB_S_ERRORSOCCURRED);
        else
            RRETURN(DB_E_ERRORSOCCURRED);
        
error:
        RRETURN(hr);
        
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetSourceRowset
//
//  Synopsis:   Returns interface pointer on the Source Rowset from which this
//              Row was created.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetSourceRowset(
                                   /* [in] */ REFIID riid,
                                   /* [iid_is][out] */ IUnknown **ppRowset,
                                   /* [out] */ HROW *phRow)
                                   
{
    if (ppRowset == NULL && phRow == NULL)
        RRETURN(E_INVALIDARG);
    
    HRESULT         hr;
    auto_leave      cs_auto_leave(m_autocs);
    
    if (ppRowset)
        *ppRowset = NULL;
    if (phRow)
        *phRow = DB_NULL_HROW;
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        if( m_fIsTearOff )
        {
            ADsAssert(m_pSourceRowset.get());
            if (ppRowset)
            {
                hr = m_pSourceRowset->QueryInterface(riid, (void**)ppRowset);
                if (FAILED(hr))
                    BAIL_ON_FAILURE(hr = E_NOINTERFACE);
            }
            
            if (phRow)
            {
                // increment reference count of row handle

                auto_rel<IRowset> pRowset;

                hr = m_pSourceRowset->QueryInterface(__uuidof(IRowset),
                          (void **)&pRowset);
                BAIL_ON_FAILURE(hr);

                hr = pRowset->AddRefRows(1, &m_hRow, NULL, NULL);
                BAIL_ON_FAILURE(hr);

                *phRow = m_hRow;
            }
        }
        else
        {
            BAIL_ON_FAILURE(hr = DB_E_NOSOURCEOBJECT);
        }
	
	CATCHBLOCKBAIL(hr)    
    
	RRETURN(S_OK);
    
error:
    if(ppRowset && (*ppRowset != NULL))
    {
        (*ppRowset)->Release();
        *ppRowset = NULL;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::Open
//
//  Synopsis:   Opens a column of a row and returns the requested
//              interface on it.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Open(
                        /* [unique][in] */ IUnknown *pUnkOuter,
                        /* [in] */ DBID *pColumnID,
                        /* [in] */ REFGUID rguidColumnType,
                        /* [in] */ DWORD dwBindFlags,
                        /* [in] */ REFIID riid,
                        /* [iid_is][out] */ IUnknown **ppUnk)
{
    HRESULT                                 hr = S_OK;
    CComVariant                             varData;
    CComObject<CStreamMem>* pMemoryStream = NULL;
    auto_rel<IStream>               pStreamDelete;
    DBCOLUMNACCESS                  rgColumns[1];
    DBID                    dbidRowUrl = DBROWCOL_ROWURL;
    
	TRYBLOCK
    
		//General validation checks. dwBindFlags is reserved and must be 0.
        if (ppUnk == NULL || pColumnID == NULL || dwBindFlags != 0)
            RRETURN(E_INVALIDARG);

        *ppUnk = NULL;
       
        // columnID has to be URL, bookmark or DBKIND_NAME  
        if ((pColumnID->eKind != DBKIND_NAME) &&
            (FALSE == CompareDBIDs(&dbidRowUrl, pColumnID)) &&
            (!((pColumnID->eKind == DBKIND_GUID_PROPID) &&
               (pColumnID->uGuid.guid == DBCOL_SPECIALCOL) &&
               (pColumnID->uName.ulPropid == 2))
            )
           )
            RRETURN(DB_E_BADCOLUMNID);
        
        if ((pColumnID->eKind == DBKIND_NAME) &&
                (pColumnID->uName.pwszName == NULL))
            RRETURN(DB_E_BADCOLUMNID);
        
        if (pUnkOuter != NULL && !InlineIsEqualGUID(riid, IID_IUnknown))
            RRETURN(DB_E_NOAGGREGATION);
        
        //we don't support aggregation
        if (pUnkOuter != NULL)
            RRETURN(DB_E_NOAGGREGATION);
       
        // riid has to be one of the interfaces that can be QIed from
        // IStream, need not necessarily be IID_IStream 

        hr = CopyDBIDs(&rgColumns[0].columnid, pColumnID);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_BADCOLUMNID);
        
        //fill relevant fields of rgColumns[0]
        rgColumns[0].wType = DBTYPE_VARIANT;
        rgColumns[0].pData = (VARIANT *)&varData;
        rgColumns[0].cbMaxLen = sizeof(VARIANT);
        
        //get column data
        hr = GetColumns(1, rgColumns);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_BADCOLUMNID);

        if (rguidColumnType != DBGUID_STREAM)
            //we currently support only streams
            RRETURN(DB_E_OBJECTMISMATCH);
        
        //Check if the returned data is of type binary -
        //Note: ADSI returns binary data as type VT_ARRAY | VT_UI1.
        if (V_VT(&varData) != (VT_ARRAY | VT_UI1))
            BAIL_ON_FAILURE(hr = DB_E_OBJECTMISMATCH);
        
        hr = CComObject<CStreamMem>::CreateInstance(&pMemoryStream);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        
        //To make sure we delete the CStreamMem object in case we ecounter
        //errors after this point.
        pMemoryStream->AddRef();
        pStreamDelete = pMemoryStream;
        
        hr = pMemoryStream->Initialize(&varData, (IRow *)this, m_hRow);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_OBJECTMISMATCH);
        
        hr = pMemoryStream->QueryInterface(riid, (void **)ppUnk);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_NOINTERFACE);
	
	CATCHBLOCKBAIL(hr);    

error:
    
    FreeDBID(&rgColumns[0].columnid);
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////////
//IColumnsInfo2 : IColumnsInfo
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetColumnInfo
//
//  Synopsis:   returns column information on a row. Column 0 is the URL column.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetColumnInfo(
                                 /* [out][in] */ DBORDINAL *pcColumns,
                                 /* [size_is][size_is][out] */ DBCOLUMNINFO **prgInfo,
                                 /* [out] */ OLECHAR **ppStringsBuffer)
{
    if( pcColumns )
        *pcColumns = 0;
    
    if( prgInfo )
        *prgInfo = NULL;
    
    if( ppStringsBuffer )
        *ppStringsBuffer = NULL;
    
    if( !pcColumns || !prgInfo || !ppStringsBuffer )
        RRETURN( E_INVALIDARG );
    
    RRETURN(GetRestrictedColumnInfo (
        0,
        NULL,
        0,
        pcColumns,
        NULL,
        prgInfo,
        ppStringsBuffer
        ));
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::MapColumnIDs
//
//  Synopsis:   Maps column IDs
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::MapColumnIDs(
                                /* [in] */ DBORDINAL cColumnIDs,
                                /* [size_is][in] */ const DBID rgColumnIDs[  ],
                                /* [size_is][out] */ DBORDINAL rgColumns[  ])
{
	HRESULT hr;
	ULONG cValidCols = 0;
    
    //
    // check in-params and NULL out-params in case of error
    //
	if( cColumnIDs == 0 )
        RRETURN( S_OK );

    if( !rgColumnIDs || !rgColumns )
        RRETURN( E_INVALIDARG );

    //
	// Get the ColumnsInfo
	//
    DBORDINAL      ulColumns;
	DBCOLUMNINFO * rgColumnInfo = NULL;
	OLECHAR *	   pStringBuffer = NULL;

	hr=GetColumnInfo((DBORDINAL *)&ulColumns, &rgColumnInfo, &pStringBuffer);
	if( FAILED(hr) )
		RRETURN( hr );

    for(ULONG iCol=0; iCol < cColumnIDs; iCol++)
    {
        // Initialize the column ordinal to invalid column
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        for (ULONG iOrdinal = 0; iOrdinal < ulColumns; iOrdinal++)
        {
            if (TRUE == CompareDBIDs( 
                                    &rgColumnIDs[iCol],
                                    &rgColumnInfo[iOrdinal].columnid))
            {
				rgColumns[iCol] = rgColumnInfo[iOrdinal].iOrdinal;
				cValidCols++;
				break;
			}
		}
	}

	//
	// Free the ColumnsInfo
	//
	if( rgColumnInfo )
		CoTaskMemFree(rgColumnInfo);

	if( pStringBuffer )
		CoTaskMemFree(pStringBuffer);

	//
	// Return the HRESULT
	//
	if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetRestrictedColumnInfo
//
//  Synopsis:   returns column information for those columns which match given
//                              mask criteria.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetRestrictedColumnInfo(
                                           /* [in] */ DBORDINAL cColumnIDMasks,
                                           /* [in] */ const DBID rgColumnIDMasks[  ],
                                           /* [in] */ DWORD dwFlags,
                                           /* [out][in] */ DBORDINAL *pcColumns,
                                           /* [size_is][size_is][out] */ DBID **prgColumnIDs,
                                           /* [size_is][size_is][out] */ DBCOLUMNINFO **prgColumnInfo,
                                           /* [out] */ OLECHAR **ppStringsBuffer)
{
    HRESULT                     hr = S_OK;
    ULONG                       ulNumColumns = 0, ulStartColumn;
    int                         iColumn = 0;
    int                         i = 0, j=0, iMask = 0;
    auto_leave                  cs_auto_leave(m_autocs);
    DWORD                       cMaxColumns ;
    auto_rel<IDirectoryObject>  pIDirObj;
    DBID                        bookMarkColid;
    bool                        bAddBookMark = false;

    
    //
    //      Zero the out params:
    //
    
    if (pcColumns)
        *pcColumns  = 0;
    
    if (prgColumnIDs)
        *prgColumnIDs   = NULL;
    
    if (prgColumnInfo)
        *prgColumnInfo  = NULL;
    
    if (ppStringsBuffer)
        *ppStringsBuffer = NULL;
    
    // Validate arguments.
    if ((dwFlags) || (pcColumns == NULL) || (ppStringsBuffer == NULL) )
        RRETURN( E_INVALIDARG);
    
    // Either column info or column ids should be available.
    if ((NULL == prgColumnIDs) && (NULL == prgColumnInfo))
        RRETURN( E_INVALIDARG);
    
    //Validate the mask
    if (cColumnIDMasks && !rgColumnIDMasks)
        RRETURN( E_INVALIDARG);
    
    for (iMask = 0; iMask < cColumnIDMasks; iMask++)
        if (S_FALSE == IsValidDBID(&rgColumnIDMasks[iMask]))
            RRETURN( DB_E_BADCOLUMNID );
        
	TRYBLOCK
    { 
		cs_auto_leave.EnterCriticalSection();
            
        // We must have a valid ADs object or a valid Source Rowset
        ADsAssert(m_pADsObj.get() || m_pSourceRowset.get());
            
        // Calculate maximum number of columns that we will return,
        // excluding the bookmark column. We will add bookmark later.
        if (m_fGetColInfoFromRowset)
        {
            ADsAssert(m_pSourceRowset.get() != NULL);

            // m_cSourceRowsetColumns includes the bookmark column.
            cMaxColumns = m_cSourceRowsetColumns - 1;
        }
        else
        {
            if(m_cMaxColumns != -1)
                cMaxColumns = m_cMaxColumns;
            else
            {
                hr = m_pADsObj->QueryInterface(__uuidof(IDirectoryObject),
                    (void**)&pIDirObj);
                BAIL_ON_FAILURE(hr);
                
                hr = pIDirObj->GetObjectAttributes(NULL, -1, &m_pAttrInfo,
                      &cMaxColumns);
                BAIL_ON_FAILURE(hr);
                
                // Add one for ADsPath. ADsPath is returned if the query was a 
                // SELECT * query (irrespective of whether the row was obtained
                // from a rowset or directly from a command object) OR if 
                // IBindResource::Bind was used to get the row.
                cMaxColumns += 1;
             
                m_cMaxColumns = cMaxColumns;
            }
        }

        // Add one for URL (for all rows)
        cMaxColumns++;
            
        BSTR                    bstrName;
        auto_prg<CComBSTR>      propStrings;
        auto_prg<DBTYPE>        propTypes;
        auto_prg<ULONG>         propSizes;
            
        propStrings = new CComBSTR[cMaxColumns];
          
        if (!propStrings)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
            
        // If client asked for columns info. allocate DBTYPE array
        if (prgColumnInfo)
        {
            propTypes = new DBTYPE[cMaxColumns];
            propSizes = new ULONG[cMaxColumns];
            if (!propTypes || !propSizes)
                BAIL_ON_FAILURE(E_OUTOFMEMORY);
        }
        
        int totalLen = 0;
        ulNumColumns = 0;
        BOOL fURLMatchesMask = FALSE; 

        if (m_fGetColInfoFromRowset)
        {
            ADsAssert(m_pSourceRowset.get() != NULL);

            // start with 1 because column # 0 in source rowset
            // is always a bookmark column.
            
            for (i = 1; i < m_cSourceRowsetColumns; i++)
            {
                //We need to check if this column matches mask criteria. Use
                // the column name for comparison since we should have a match
                // even if a substring of the column name is specified by the
                // client. Comparing column ID won't work in this case.
                // We know that all columns other than the bookmark (column 0)
                // are of type DBKIND_NAME. So we can access pwszName safely.
                if (fMatchesMaskCriteria(
                    m_pSourceRowsetColumnInfo[i].columnid.uName.pwszName,
                    cColumnIDMasks,
                    rgColumnIDMasks) == false)
                    continue;
                
                //matches the criteria, add to list and
                //update totalLen for strings buffer.
                propStrings[(int)ulNumColumns] =
                    m_pSourceRowsetColumnInfo[i].pwszName;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;
                
                //add type and size to list if columninfo is requested.
                if (prgColumnInfo)
                {
                    propTypes[(int)ulNumColumns] =
                        m_pSourceRowsetColumnInfo[i].wType;
                    
                    propSizes[(int)ulNumColumns] =
                        m_pSourceRowsetColumnInfo[i].ulColumnSize;
                }
                
                ulNumColumns++;
            }

            // Finally, check if URL column is requested
            if (fMatchesMaskCriteria(DBROWCOL_ROWURL, cColumnIDMasks,
                       rgColumnIDMasks) == true)
            {
                //matches the criteria, add to list and
                //update totalLen for strings buffer.
                bstrName = SysAllocString(g_cwszAdsPath);
                propStrings[(int)ulNumColumns].Attach(bstrName);
                bstrName = NULL;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;

                // we know the type and size of the URL column

                ulNumColumns++;
                fURLMatchesMask = TRUE;
            }
        }
        else
        {
            for (i = 0; i < cMaxColumns; i++)
            {
                if ((cMaxColumns-1) == i)  // special URL column
                {
                    if (fMatchesMaskCriteria(DBROWCOL_ROWURL, cColumnIDMasks,
                                   rgColumnIDMasks) == true)
                    {
                        bstrName = SysAllocString(g_cwszAdsPath);
                        fURLMatchesMask = TRUE;
                    }
                    else
                        continue;
                }
                else 
                {
                    if (0 == i)  //ADsPath
                        bstrName = SysAllocString(g_cwszAdsPath);
                    else
                    {
                        bstrName =SysAllocString(m_pAttrInfo[i-1].pszAttrName); 
                    }
                
                    // If property doesn't match
                    // mask criteria, continue with next property.
                
                    if (
                        (fMatchesMaskCriteria(bstrName,
                        cColumnIDMasks,
                        rgColumnIDMasks) == false)
                        )
                    {
                        SysFreeString(bstrName);
                        bstrName = NULL;
                        continue;
                    }
                } // else
                
                // OK Matches the criterion add to the list and
                // update toalLen for strings buffer.
                propStrings[(int)ulNumColumns].Attach(bstrName);
                bstrName = NULL;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;
                
                //Get Type and size of column if ColumnInfo is requested.
                //For the special URL column and the ADsPath column, we already 
                //know the type.
                if ((i > 0) && (i < (cMaxColumns-1)) && (prgColumnInfo != NULL))
                {
                    hr = GetTypeAndSize(
                        m_pAttrInfo[i-1].dwADsType,
                        propStrings[(int)ulNumColumns],
                        &propTypes[(int)ulNumColumns],
                        &propSizes[(int)ulNumColumns]
                        );
                    BAIL_ON_FAILURE(hr);
                }
                
                // Increment number of columns count
                ulNumColumns++;
            }
        }
        
        if (ulNumColumns == 0)
            BAIL_ON_FAILURE(hr = DB_E_NOCOLUMN);
        
        //We will add a bookmark column to the list that we are going to return.
        bookMarkColid.eKind = DBKIND_GUID_PROPID;
        bookMarkColid.uGuid.guid = DBCOL_SPECIALCOL;
        bookMarkColid.uName.ulPropid = 2;
        
        if (fMatchesMaskCriteria(bookMarkColid, cColumnIDMasks, rgColumnIDMasks))
        {
            bAddBookMark = true;
            ulNumColumns += 1;
        }
        
        *pcColumns = ulNumColumns;
        
        // Does the caller want column IDS?
        if ( prgColumnIDs )
        {
            *prgColumnIDs =
                (DBID *) CoTaskMemAlloc( (ulNumColumns) * sizeof (DBID) );
            if (NULL == *prgColumnIDs)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            
            ZeroMemory ( *prgColumnIDs, (ulNumColumns) * sizeof (DBID));
        }
        
        // Does the caller want COLUMNINFO?
        if ( prgColumnInfo )
        {
            *prgColumnInfo  = (DBCOLUMNINFO *)
                CoTaskMemAlloc( (ulNumColumns) *  sizeof (DBCOLUMNINFO) );
            if (NULL == *prgColumnInfo)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            
            ZeroMemory ( *prgColumnInfo,
                (ulNumColumns)  * sizeof (DBCOLUMNINFO) );
        }
        
        // get the string buffer allocated.
        *ppStringsBuffer = (OLECHAR *)CoTaskMemAlloc(sizeof(OLECHAR)*totalLen);
        if (NULL ==*ppStringsBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        
        OLECHAR *pwChar = *ppStringsBuffer;
        
        //First fill bookmark column information.
        if (prgColumnIDs && bAddBookMark) 
        {
            (*prgColumnIDs)[0] = bookMarkColid;
        }
        
        if (prgColumnInfo && bAddBookMark)
        {
            (*prgColumnInfo)[0].pwszName                = NULL;
            (*prgColumnInfo)[0].pTypeInfo               = NULL;
            (*prgColumnInfo)[0].iOrdinal                = 0;
            (*prgColumnInfo)[0].ulColumnSize            = sizeof(ULONG);
            (*prgColumnInfo)[0].wType                   = DBTYPE_UI4;
            (*prgColumnInfo)[0].bPrecision              = 10;
            (*prgColumnInfo)[0].bScale                  = (BYTE) ~ 0;
            (*prgColumnInfo)[0].columnid.eKind          = DBKIND_GUID_PROPID;
            (*prgColumnInfo)[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
            (*prgColumnInfo)[0].columnid.uName.ulPropid = 2;
            (*prgColumnInfo)[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK |
                DBCOLUMNFLAGS_ISFIXEDLENGTH;
        }
        
        // Fill the rest of the columns.
        if (bAddBookMark)
            ulStartColumn = 1;
        else
            ulStartColumn = 0;
        
        for (iColumn= ulStartColumn, i = 0; iColumn < ulNumColumns; iColumn++, i++)
        {
            wcscpy(pwChar, propStrings[i]);
            
            //Is this the special URL column (has to be last column) 
            if( fURLMatchesMask && (iColumn == (ulNumColumns -1)) &&
                 (_wcsicmp(pwChar, g_cwszAdsPath)) == 0 )
            {
                if ( prgColumnIDs )
                {
                    // Add a new DBID for this column:
                    //
                    (*prgColumnIDs)[iColumn]    = DBROWCOL_ROWURL;
                }
                if ( prgColumnInfo )
                {
                    (*prgColumnInfo)[iColumn].pwszName     = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo    = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal     = iColumn;
                    (*prgColumnInfo)[iColumn].dwFlags      = DBCOLUMNFLAGS_ISROWURL;
                    //Rowset code sets ulColumnSize for Adspath to 256.
                    //We do the same thing for consistency.
                    (*prgColumnInfo)[iColumn].ulColumnSize = 256;
                    (*prgColumnInfo)[iColumn].wType        = DBTYPE_WSTR;
                    (*prgColumnInfo)[iColumn].bPrecision   = ~0;
                    (*prgColumnInfo)[iColumn].bScale       = ~0;
                    
                    (*prgColumnInfo)[iColumn].columnid     = DBROWCOL_ROWURL;
                }
            }
            // Is this the ADsPath column (if it has the name ADsPath and it
            // is not URL, it has to be the ADsPath column)
            else if(_wcsicmp(pwChar, g_cwszAdsPath) == 0)
            {
                if ( prgColumnIDs )
                {
                    // Add DBID for ADsPath
                    (*prgColumnIDs)[iColumn].eKind = DBKIND_NAME;
                    (*prgColumnIDs)[iColumn].uGuid.guid = GUID_NULL;
                    (*prgColumnIDs)[iColumn].uName.pwszName    = pwChar;
                }
                if ( prgColumnInfo )
                {
                    // Add a DBCOLUMNINFO for ADsPath

                    DBTYPE  wType = DBTYPE_WSTR | DBTYPE_BYREF;

                    (*prgColumnInfo)[iColumn].pwszName              = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo             = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal              = iColumn;

                    // OLEDB 2.0 code sets ulColumnsSize to 256 for ADsPath
                    (*prgColumnInfo)[iColumn].ulColumnSize          = 256; 
                    (*prgColumnInfo)[iColumn].wType                 = wType; 

                    // the code below has to be identical to the code in
                    // GetColumnsInfo2 in ccommand.cxx
                    wType = wType & (~DBTYPE_BYREF);
                    if( (wType == DBTYPE_STR)  ||
                        (wType == DBTYPE_WSTR) ||
                        (wType == DBTYPE_BYTES) )
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE;
                    else
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_ISFIXEDLENGTH;


                    (*prgColumnInfo)[iColumn].bPrecision = SetPrecision(wType);

                    (*prgColumnInfo)[iColumn].bScale                = ~0;
                    (*prgColumnInfo)[iColumn].columnid.eKind    = DBKIND_NAME;
                    (*prgColumnInfo)[iColumn].columnid.uGuid.guid   = GUID_NULL;
                    (*prgColumnInfo)[iColumn].columnid.uName.pwszName= pwChar;
                }
            }
            else
            {
                if ( prgColumnIDs )
                {
                    // Add a new DBID for this column:
                    //
                    (*prgColumnIDs)[iColumn].eKind    = DBKIND_NAME;
                    (*prgColumnIDs)[iColumn].uGuid.guid = GUID_NULL;
                    (*prgColumnIDs)[iColumn].uName.pwszName    = pwChar;
                   
                }
                if ( prgColumnInfo )
                {
                    //      Add a new DBCOLUMNINFO for this column:
                    //
                    
                    DBTYPE  wType = propTypes[i];
                    
                    (*prgColumnInfo)[iColumn].pwszName              = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo             = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal              = iColumn;
                    (*prgColumnInfo)[iColumn].ulColumnSize          = propSizes[i];                                           ;
                    (*prgColumnInfo)[iColumn].wType                 = wType;
                    
                    // the code below has to be identical to the code in
                    // GetColumnsInfo2 in ccommand.cxx
                    wType = wType & (~DBTYPE_BYREF);
                    if( (wType == DBTYPE_STR)  ||
                        (wType == DBTYPE_WSTR) ||
                        (wType == DBTYPE_BYTES) )
                        (*prgColumnInfo)[iColumn].dwFlags = 
                         DBCOLUMNFLAGS_ISNULLABLE;
                    else
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_ISFIXEDLENGTH; 

                    (*prgColumnInfo)[iColumn].bPrecision = SetPrecision(wType);
                    
                    (*prgColumnInfo)[iColumn].bScale                = ~0;
                    (*prgColumnInfo)[iColumn].columnid.eKind        = DBKIND_NAME;
                    (*prgColumnInfo)[iColumn].columnid.uGuid.guid   = GUID_NULL;
                    (*prgColumnInfo)[iColumn].columnid.uName.pwszName= pwChar;
                }
            }
            
            //Position the pointer in strings buffer
            //for writing next column name.
            pwChar += SysStringLen(propStrings[i]) + 1;
        }
	
    }		
	CATCHBLOCKBAIL(hr)    

	RRETURN(S_OK);
    
error:
    if ((prgColumnIDs) && (*prgColumnIDs))
    {
        CoTaskMemFree(*prgColumnIDs);
        *prgColumnIDs = NULL;
    }
    if ((prgColumnInfo) && (*prgColumnInfo))
    {
        CoTaskMemFree(*prgColumnInfo);
        *prgColumnInfo = NULL;
    }
    if ((ppStringsBuffer) && (*ppStringsBuffer))
    {
        CoTaskMemFree(*ppStringsBuffer);
        *ppStringsBuffer = NULL;
    }

    if (pcColumns)
        *pcColumns  = 0;

    RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////
//IConvertType
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::ConvertType
//
//  Synopsis:   Converts one DBTYPE to another using data conversion library.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.0 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::CanConvert(
                              /* [in] */ DBTYPE wFromType,
                              /* [in] */ DBTYPE wToType,
                              /* [in] */ DBCONVERTFLAGS dwConvertFlags)
{
    auto_rel<IDataConvert> pDataConvert;
    
    HRESULT hr = GetIDataConvert(&pDataConvert);
    BAIL_ON_FAILURE(hr);
    
    ADsAssert(pDataConvert.get());

    if( dwConvertFlags & DBCONVERTFLAGS_PARAMETER ) // not allowed on row
        RRETURN( DB_E_BADCONVERTFLAG );

    if( (dwConvertFlags & (~(DBCONVERTFLAGS_ISLONG |
                            DBCONVERTFLAGS_ISFIXEDLENGTH |
                            DBCONVERTFLAGS_FROMVARIANT))) !=
                            DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG )
    {
        DBTYPE wType;

        wType = wFromType & (~(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR));

        // wType has to be variable-length DBTYPE
        if( (wType != DBTYPE_STR) && (wType != DBTYPE_WSTR) &&
            (wType != DBTYPE_BYTES) && (wType != DBTYPE_VARNUMERIC) )
            RRETURN( DB_E_BADCONVERTFLAG );
    }

    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT )
    {
        DBTYPE dbTmpType, wVtType;

        wVtType = wFromType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );
    }

    RRETURN(pDataConvert->CanConvert(wFromType, wToType));
    
error:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////////
//IGetSession
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetSession
//
//  Synopsis:   Gets the Session interface through which this row has been
//              created.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetSession(
                              REFIID riid,
                              IUnknown **ppunkSession)
{
    if (ppunkSession == NULL)
        RRETURN(E_INVALIDARG);
    
    *ppunkSession = NULL;
    
    if (!m_pSession.get())
        RRETURN(DB_E_NOSOURCEOBJECT);
    
    HRESULT hr = m_pSession->QueryInterface(riid, (void**)ppunkSession);
    if (FAILED(hr))
        RRETURN(E_NOINTERFACE);
    
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// GetSecurityDescriptor
//
// Returns the security descriptor as an octet string.
//
//----------------------------------------------------------------------------
HRESULT CRow::GetSecurityDescriptor(
    DBCOLUMNACCESS *pColumn,
    BOOL fMultiValued
    )
{
    HRESULT hr;
    auto_rel<IDirectoryObject>  pIDirObj;
    PVARIANT pVariant = NULL, pVarArray = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    VARTYPE vType;
    DWORD dwRequiredLen;
    int iAttr, j;

    // multivalued attributes are always returned as variants. Single-valued
    // security descriptor has to be returned as either variant or octet 
    // string.
    if( ((pColumn->wType != (DBTYPE_VARIANT | DBTYPE_BYREF)) &&
        (pColumn->wType != DBTYPE_VARIANT)) && 
        (fMultiValued || ((fMultiValued == FALSE) && 
         (pColumn->wType != DBTYPE_BYTES) &&
         (pColumn->wType != (DBTYPE_BYTES | DBTYPE_BYREF)))) )
    {
        pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;    
        BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
    }

    pColumn->dwStatus = DBSTATUS_S_OK;
    pColumn->cbDataLen = 0;

    if(pColumn->pData == NULL) // client doesn't want any data returned
        RRETURN(S_OK);

    if(m_cMaxColumns == -1) // GetObjectAttributes has not been called
    {
        hr = m_pADsObj->QueryInterface(__uuidof(IDirectoryObject),
             (void**)&pIDirObj);
        BAIL_ON_FAILURE(hr);

        hr = pIDirObj->GetObjectAttributes(NULL, -1, &m_pAttrInfo,
            (DWORD *) &m_cMaxColumns);
        BAIL_ON_FAILURE(hr);

        m_cMaxColumns++; // include ADsPath
    }

    // get the index of security descriptor in the attribute array
    for(iAttr = 0; iAttr < (m_cMaxColumns-1); iAttr++)
        if(!_wcsicmp(m_pAttrInfo[iAttr].pszAttrName, NT_SEC_DESC_ATTR))
            break;

    if(iAttr == (m_cMaxColumns-1))
    {
        pColumn->dwStatus = DBSTATUS_E_UNAVAILABLE; 
        BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
    }

    ADsAssert(m_pAttrInfo[iAttr].dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR);
 
    if(fMultiValued)
    {
        // check if the client has enough space to copy over the variant
        if(pColumn->wType & DBTYPE_BYREF)
            dwRequiredLen = sizeof(VARIANT *);
        else
            dwRequiredLen = sizeof(VARIANT);

        if(pColumn->cbMaxLen < dwRequiredLen)
        {
            pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
        }

        aBound.lLbound = 0;
        aBound.cElements = m_pAttrInfo[iAttr].dwNumValues;

        if(pColumn->wType & DBTYPE_BYREF)
        {
            pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
            if(NULL == pVariant)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        else
            pVariant = (PVARIANT) pColumn->pData;

        VariantInit(pVariant);

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
        if (aList == NULL)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);        

        hr = SafeArrayAccessData( aList, (void **) &pVarArray );
        BAIL_ON_FAILURE(hr);

        vType = g_MapADsTypeToVarType[m_pAttrInfo[iAttr].dwADsType];

        for (j=0; j<aBound.cElements; j++)
        {
            VariantInit(pVarArray+j);
            V_VT(pVarArray+j) = vType;

            hr = BinaryToVariant(
               m_pAttrInfo[iAttr].pADsValues[j].SecurityDescriptor.dwLength,
               m_pAttrInfo[iAttr].pADsValues[j].SecurityDescriptor.lpValue,
               pVarArray+j);

            if(FAILED(hr))
            {
                int k;

                for(k = 0; k < j; k++)
                    VariantClear(pVarArray+k);
            }

            BAIL_ON_FAILURE(hr);
        }

        SafeArrayUnaccessData( aList );

        V_VT((PVARIANT)pVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY((PVARIANT)pVariant) = aList;

        if(pColumn->wType & DBTYPE_BYREF)
            *(PVARIANT *)pColumn->pData = pVariant;

        pColumn->cbDataLen = sizeof(VARIANT); 
    }
    else // single valued
    {
        // check if the client has enough space to copy over the octet string 
        if(pColumn->wType & DBTYPE_VARIANT)
        {
            if(pColumn->wType & DBTYPE_BYREF)       
                dwRequiredLen = sizeof(VARIANT *);
            else
                dwRequiredLen = sizeof(VARIANT);
        }
        else if(pColumn->wType & DBTYPE_BYTES)
        {
            if(pColumn->wType & DBTYPE_BYREF)
                dwRequiredLen = sizeof(BYTE *);
            else
                dwRequiredLen =
                  m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength;
        }

        if(pColumn->cbMaxLen < dwRequiredLen)
        {
            pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
        }

        if(pColumn->wType & DBTYPE_VARIANT)
        {
            if(pColumn->wType & DBTYPE_BYREF)
            {
                pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
                if(NULL == pVariant)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            else
                pVariant = (PVARIANT) pColumn->pData;

            VariantInit(pVariant);

            vType = g_MapADsTypeToVarType[m_pAttrInfo[iAttr].dwADsType];
            V_VT(pVariant) = vType;

            hr = BinaryToVariant(
               m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength,
               m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue,
               pVariant);
            BAIL_ON_FAILURE(hr);

            if(pColumn->wType & DBTYPE_BYREF)
                *(PVARIANT *)pColumn->pData = pVariant;

            pColumn->cbDataLen = sizeof(VARIANT);
        }
        else if(pColumn->wType & DBTYPE_BYTES)
        {
            if(pColumn->wType & DBTYPE_BYREF)
                *(BYTE **)pColumn->pData =
                   m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue;
            else
                memcpy(pColumn->pData,
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue,
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength); 

            pColumn->cbDataLen =
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength;
        }
    }

    RRETURN(S_OK);

error:

    if(aList)
        SafeArrayDestroy(aList);
    if((pVariant) && (pColumn->wType & DBTYPE_BYREF))
        FreeADsMem(pVariant);

    RRETURN(hr);
}

//---------------------------------------------------------------------------
// IgnorecbMaxLen
//
// This function returns 1 if the cbMaxLen field of DBCOLUMNACCESS structure
// should be ignored and 0 otherwise. cbMaxLen should be ignored for fixed
// length data types and data types combined with DBTYPE_BYREF, DBTYPE_VECTOR
// and DBTYPE_ARRAY (page 107, OLEDB 2.0 spec)
//
//---------------------------------------------------------------------------
int CRow::IgnorecbMaxLen(DBTYPE wType)
{
    if( (wType & DBTYPE_BYREF) ||
        (wType & DBTYPE_VECTOR) ||
        (wType & DBTYPE_ARRAY) )
        return 1;

    wType &= ( (~DBTYPE_BYREF) & (~DBTYPE_VECTOR) & (~DBTYPE_ARRAY) );

    // check if it is a variable length data type
    if( (DBTYPE_STR == wType) ||
        (DBTYPE_BYTES == wType) ||
        (DBTYPE_WSTR == wType) ||
        (DBTYPE_VARNUMERIC == wType) )
        return 0;

    // must be fixed length data type
    return 1;
} 
 
//-----------------------------------------------------------------------------           

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\utilprop.cxx ===
//-- == 0-------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  utilprop.cxx
//
//  Contents:
//
//
//  History:   08-28-96     shanksh    Created.
//
//----------------------------------------------------------------------------
// Notes - there are two main methods in this module:
//     - CUtilProps::GetPropertyInfo, a helper function for
//       GetProperty method on Data Source
//     - CUtilProps::GetProperties, a helper function for
//       GetProperties method on Data Source, Session and Command objects
//     - CUtilProps::SetProperties, a helper function for
//       SetProperties method on Data Source, Session and Command objects
//
//
// The implementation is very simple - we keep a global table of the
// properties we support in s_rgprop. We search this table sequentially.
// 

#include "oleds.hxx"
#pragma hdrstop

PROPSTRUCT s_rgDBInitProp[] =
{
    {DBPROP_AUTH_PASSWORD,         F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Password"},
    {DBPROP_AUTH_USERID,           F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"User ID"},
    {DBPROP_AUTH_ENCRYPT_PASSWORD, F_DBINITRW, VT_BOOL, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Encrypt Password"},
    {DBPROP_AUTH_INTEGRATED,       F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Integrated Security"},
    {DBPROP_INIT_DATASOURCE,       F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Data Source"},
    {DBPROP_INIT_LOCATION,         F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Location"},
    {DBPROP_INIT_PROVIDERSTRING,   F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Extended Properties"},
    {DBPROP_INIT_TIMEOUT,          F_DBINITRW, VT_I4,   VARIANT_FALSE, 90,           OPT_REQ, NULL, L"Connect Timeout"},
    {DBPROP_INIT_PROMPT,           F_DBINITRW, VT_I2,   VARIANT_FALSE, DBPROMPT_NOPROMPT, OPT_REQ, NULL,  L"Prompt"},
    {DBPROP_INIT_HWND,             F_DBINITRW, VT_I4,   VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Window Handle"},
    {DBPROP_INIT_MODE,             F_DBINITRW, VT_I4,   VARIANT_FALSE, DB_MODE_READ,      OPT_REQ, NULL, L"Mode"}
#if (!defined(BUILD_FOR_NT40)) 
    ,
    {DBPROP_INIT_BINDFLAGS,        F_DBINITRW, VT_I4,   VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Bind Flags"}
#endif
};

PROPSTRUCT s_rgADSIBindProp[] =
{
    // initialize this property to a reserved value. The client is not supposed
    // to set this property to the reserved value. This reserved value prevents
    // ADSIFLAG from overriding ENCRYPT_PASSWORD when VB initializes this
    // property to its default value. See IsValidValue().

    {ADSIPROP_ADSIFLAG,            F_DBINITRW, VT_I4,   VARIANT_FALSE, 
     ADS_AUTH_RESERVED, OPT_REQ, NULL, L"ADSI Flag"} 
};

PROPSTRUCT s_rgDSInfoProp[] =
{
    {DBPROP_ACTIVESESSIONS,             F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Active Sessions"},
    {DBPROP_BYREFACCESSORS,             F_DSRO,    VT_BOOL, VARIANT_FALSE, 1, OPT_REQ, NULL,                                              L"Pass By Ref Accessors"},
    {DBPROP_CATALOGLOCATION,            F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_CL_START, OPT_REQ, NULL,                             L"Catalog Location"},
    {DBPROP_CATALOGTERM,                F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Catalog Term"},
    {DBPROP_CATALOGUSAGE,               F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Catalog Usage"},
    {DBPROP_DATASOURCENAME,             F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"Active Directory Service Interfaces",            L"Data Source Name"},
    {DBPROP_DATASOURCEREADONLY,         F_DSRO,    VT_BOOL, VARIANT_TRUE,  0, OPT_REQ, NULL,                                              L"Read-Only Data Source"},
//  {DBPROP_DBMSNAME,                   F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"DBMS Name"},
//  {DBPROP_DBMSVER,                    F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"DBMS Version"},
    {DBPROP_DSOTHREADMODEL,             F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_RT_FREETHREAD, OPT_REQ, NULL,                        L"Data Source Object Threading Model"},
    {DBPROP_MAXROWSIZE,                 F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_SIC, NULL,                                              L"Maximum Row Size"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_OLEOBJECTS,                 F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_OO_ROWOBJECT | DBPROPVAL_OO_DIRECTBIND | DBPROPVAL_OO_SINGLETON, OPT_REQ, NULL, L"OLE Object Support"},
#endif
    {DBPROP_PERSISTENTIDTYPE,           F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_PT_NAME, OPT_SIC, NULL,                              L"Persistent ID Type"},
    {DBPROP_PROVIDERFRIENDLYNAME,       F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"Microsoft OLE DB Provider for ADSI",             L"Provider Friendly Name"},
    {DBPROP_PROVIDERNAME,               F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"ACTIVEDS.DLL",                                   L"Provider Name"},
    {DBPROP_PROVIDEROLEDBVER,           F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"02.50",                                          L"OLE DB Version"},
    {DBPROP_PROVIDERVER,                F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"02.50.0000",                                     L"Provider Version"},
    {DBPROP_SQLSUPPORT,                 F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_SQL_ODBC_MINIMUM, OPT_REQ, NULL,                     L"SQL Support"},
    {DBPROP_ROWSETCONVERSIONSONCOMMAND, F_DSRO,    VT_BOOL, VARIANT_TRUE,  0, OPT_REQ, NULL,                                              L"Rowset Conversions on Command"},
    {DBPROP_USERNAME,                   F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"User Name"}
};

PROPSTRUCT s_rgRowsetProp[] =
{
    {DBPROP_IAccessor,                       F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IAccessor"},
    {DBPROP_IColumnsInfo,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IColumnsInfo"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_IColumnsInfo2,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IColumnsInfo2"},
#endif
    {DBPROP_IConvertType,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IConvertType"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_IGetSession,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IGetSession"},
    {DBPROP_IRow,                            F_ROWSETRW,     VT_BOOL, VARIANT_FALSE,    0, OPT_REQ, NULL, L"IRow"},
    {DBPROP_IGetRow,                         F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IGetRow"},
#endif
    {DBPROP_IRowset,                         F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowset"},
    {DBPROP_IRowsetIdentity,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"IRowsetIdentity"},
    {DBPROP_IRowsetInfo,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetInfo"},
    {DBPROP_IRowsetLocate,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetLocate"},
    {DBPROP_IRowsetScroll,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetScroll"},
    {DBPROP_ABORTPRESERVE,                   F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Preserve on Abort"},
    {DBPROP_BLOCKINGSTORAGEOBJECTS,          F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Blocking Storage Objects"},
    {DBPROP_BOOKMARKS,                       F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Use Bookmarks"},
    {DBPROP_BOOKMARKSKIPPED,                 F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Skip Deleted Bookmarks"},
    {DBPROP_BOOKMARKTYPE,                    F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   DBPROPVAL_BMK_NUMERIC, OPT_REQ, NULL, L"Bookmark Type"},
    {DBPROP_CANFETCHBACKWARDS,               F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Fetch Backwards"},
    {DBPROP_CANHOLDROWS,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Hold Rows"},
    {DBPROP_CANSCROLLBACKWARDS,              F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Scroll Backwards"},
    {DBPROP_COLUMNRESTRICT,                  F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Column Privileges"},
    {DBPROP_COMMITPRESERVE,                  F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Preserve on Commit"},
    {DBPROP_IMMOBILEROWS,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Immobile Rows"},
    {DBPROP_LITERALBOOKMARKS,                F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Literal Bookmarks"},
    {DBPROP_LITERALIDENTITY,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_REQ, NULL, L"Literal Row Identity"},
    {DBPROP_MAXOPENROWS,                     F_ROWSETRW,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Open Rows"},
    {DBPROP_MAXPENDINGROWS,                  F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Pending Rows"},
    {DBPROP_MAXROWS,                         F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Rows"},
    {DBPROP_NOTIFICATIONPHASES,              F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Notification Phases"},
//  {DBPROP_NOTIFYCOLUMNRECALCULATED,        F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyColumnRecalculated"},
    {DBPROP_NOTIFYCOLUMNSET,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Column Set Notification"},
//  {DBPROP_NOTIFYROWACTIVATE,               F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyRowActivate"},
    {DBPROP_NOTIFYROWDELETE,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Delete Notification"},
    {DBPROP_NOTIFYROWFIRSTCHANGE,            F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row First Change Notification"},
    {DBPROP_NOTIFYROWINSERT,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Insert Notification"},
//  {DBPROP_NOTIFYROWRELEASE,                F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyRowRelease"},
    {DBPROP_NOTIFYROWRESYNCH,                F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Resynchronization Notification"},
    {DBPROP_NOTIFYROWSETRELEASE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Rowset Release Notification"},
    {DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE, F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Rowset Fetch Position Change Notification"},
    {DBPROP_NOTIFYROWUNDOCHANGE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Change Notification"},
    {DBPROP_NOTIFYROWUNDODELETE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Delete Notification"},
    {DBPROP_NOTIFYROWUNDOINSERT,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Insert Notification"},
    {DBPROP_NOTIFYROWUPDATE,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Update Notification"},
    {DBPROP_ORDEREDBOOKMARKS,                F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Bookmarks Ordered"},
    {DBPROP_OWNINSERT,                       F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Own Inserts Visible"},
    {DBPROP_OWNUPDATEDELETE,                 F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Own Changes Visible"},
    {DBPROP_QUICKRESTART,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Quick Restart"},
    {DBPROP_REENTRANTEVENTS,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Reentrant Events"},
    {DBPROP_REMOVEDELETED,                   F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Remove Deleted Rows"},
    {DBPROP_REPORTMULTIPLECHANGES,           F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Report Multiple Changes"},
    {DBPROP_ROWRESTRICT,                     F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Privileges"},
    {DBPROP_ROWTHREADMODEL,                  F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   DBPROPVAL_RT_FREETHREAD, OPT_REQ, NULL, L"Row Threading Model"},
    {DBPROP_STRONGIDENTITY,                  F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Strong Row Identity"},

};

PROPSTRUCT s_rgDBSessProp[] =
{
    {DBPROP_SESS_AUTOCOMMITISOLEVELS, F_SESSRO, VT_I4, VARIANT_FALSE, 0, OPT_REQ, NULL, L"Autocommit Isolation Levels"},
};


PROPSTRUCT s_rgADSISearchProp[12] =
{
    {ADSIPROP_ASYNCHRONOUS,     F_ADSIRW,    VT_BOOL,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Asynchronous"},
    {ADSIPROP_DEREF_ALIASES,    F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_DEREF_NEVER,           OPT_REQ, NULL, L"Deref Aliases"},
    {ADSIPROP_SIZE_LIMIT,       F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Size Limit"},
    {ADSIPROP_TIME_LIMIT,       F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Server Time Limit"},
    {ADSIPROP_ATTRIBTYPES_ONLY, F_ADSIRW,    VT_BOOL,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Column Names only"},
    {ADSIPROP_SEARCH_SCOPE,     F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_SCOPE_SUBTREE,         OPT_REQ, NULL, L"SearchScope"},
    {ADSIPROP_TIMEOUT,          F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Timeout"},
    {ADSIPROP_PAGESIZE,         F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Page size"},
    {ADSIPROP_PAGED_TIME_LIMIT, F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Time limit"},
    {ADSIPROP_CHASE_REFERRALS,  F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_CHASE_REFERRALS_NEVER, OPT_REQ, NULL, L"Chase referrals"},
    {ADSIPROP_SORT_ON,          F_ADSIRW,    VT_BSTR,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Sort On"},
    {ADSIPROP_CACHE_RESULTS,    F_ADSIRW,    VT_BOOL,    VARIANT_TRUE,   0,                         OPT_REQ, NULL, L"Cache Results"}

};

// Number of supported properties per property set
#define    NUMBER_OF_SUPPORTED_PROPERTY_SETS   6

static PROPSET s_rgPropertySets[NUMBER_OF_SUPPORTED_PROPERTY_SETS] =
{
    {&DBPROPSET_DBINIT,         NUMELEM(s_rgDBInitProp),    s_rgDBInitProp},
    {&DBPROPSET_ADSIBIND,       NUMELEM(s_rgADSIBindProp),  s_rgADSIBindProp},
    {&DBPROPSET_DATASOURCEINFO, NUMELEM(s_rgDSInfoProp),    s_rgDSInfoProp},
    {&DBPROPSET_SESSION,        NUMELEM(s_rgDBSessProp),    s_rgDBSessProp},
    {&DBPROPSET_ROWSET,         NUMELEM(s_rgRowsetProp),    s_rgRowsetProp},
    {&DBPROPSET_ADSISEARCH,     NUMELEM(s_rgADSISearchProp),s_rgADSISearchProp}
};

//
// WARNING: Don't change the order. Add new property sets at the end
//
// Update: New property sets should not always be added at the end.
// Property sets which have properties in the Initialization  property group
// have to be added before DATASOURCEINFO and prop. sets with properties
// in the  data source information property groups have to be added
// before INDEX_SESSION and so on. This is for GetProperties to work correctly.
//

#define INDEX_INIT              0
#define INDEX_ADSIBIND          1
#define INDEX_DATASOURCEINFO    2
#define INDEX_SESSION           3
#define INDEX_ROWSET            4
#define INDEX_ADSISEARCH        5

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::CUtilProp
//
//  Synopsis:  Constructor for this class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CUtilProp::CUtilProp(
    void
    )
{
    _pIMalloc      = NULL;
    _pCredentials  = NULL;
    _prgProperties = NULL;
    _dwDescBufferLen = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::FInit
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    09-20-96   ShankSh     Created.
//
//  Update: pCredentials may be NULL if called from CRowset.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CUtilProp::FInit(
    CCredentials *pCredentials
    )
{
    HRESULT hr=S_OK;
    ULONG i, j;
    ULONG c = 0;

    //
    // Get the IMalloc interface pointer
    //
    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    BAIL_ON_FAILURE( hr );

    _pCredentials = pCredentials;
    _prgProperties = (PROPSTRUCT*) AllocADsMem(sizeof(PROPSTRUCT) *
                                               (NUMELEM(s_rgDBInitProp) +
                                                NUMELEM(s_rgADSIBindProp) +
                                                NUMELEM(s_rgDSInfoProp) +
                                                NUMELEM(s_rgDBSessProp) +
                                                NUMELEM(s_rgRowsetProp) +
                                                NUMELEM(s_rgADSISearchProp)) );
    if( !_prgProperties )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    for (i=c=0; i< NUMBER_OF_SUPPORTED_PROPERTY_SETS; i++) {
        for (j=0; j < s_rgPropertySets[i].cProperties; j++) {
            // Copy static structure
            memcpy( &_prgProperties[c],
                    &s_rgPropertySets[i].pUPropInfo[j], sizeof(PROPSTRUCT) );

            // Allocate new BSTR value
            _prgProperties[c].pwstrVal =
                    AllocADsStr(s_rgPropertySets[i].pUPropInfo[j].pwstrVal);

            // Add description length
            if( s_rgPropertySets[i].pUPropInfo[j].pwszDescription ) {
                _dwDescBufferLen += wcslen(s_rgPropertySets[i].pUPropInfo[j].pwszDescription) + 1;
            }

            c++;
        }
    }
    _dwDescBufferLen *= sizeof(WCHAR);

    ADsAssert( c == NUMELEM(s_rgDBInitProp) +
                    NUMELEM(s_rgADSIBindProp) +
                    NUMELEM(s_rgDSInfoProp) +
                    NUMELEM(s_rgDBSessProp) +
                    NUMELEM(s_rgRowsetProp) +
                    NUMELEM(s_rgADSISearchProp) );

error:

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::~CUtilProp
//
//  Synopsis:  Destructor for this class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

CUtilProp:: ~CUtilProp
(
void
)
{
    ULONG c = 0;

    if( _prgProperties )
    {
        // Clear all of the String values
        for (ULONG i=c=0; i< NUMBER_OF_SUPPORTED_PROPERTY_SETS; i++) {
            for (ULONG j=0; j < s_rgPropertySets[i].cProperties; j++) {
                if( _prgProperties[c].pwstrVal )
                    FreeADsStr(_prgProperties[c].pwstrVal);
                c++;
            }
        }

        FreeADsMem(_prgProperties);
    }

    if( _pIMalloc )
        _pIMalloc->Release();

    return;
}


PROPSET *
CUtilProp::GetPropSetFromGuid (
    GUID guidPropSet
    )
{

    for (int j=0; j< NUMELEM(s_rgPropertySets); j++) {
        if (IsEqualGUID(guidPropSet,
                        *(s_rgPropertySets[j].guidPropertySet)))
            return &(s_rgPropertySets[j]);
    }
    return NULL;
}

HRESULT
CUtilProp::GetSearchPrefInfo(
    DBPROPID dwPropId,
    PADS_SEARCHPREF_INFO pSearchPrefInfo
    )
{
    PADS_SORTKEY pSortKey = NULL;
    LPWSTR pszAttrs = NULL;
    LPWSTR pszFirstAttr = NULL;
    LPWSTR pszCurrentAttr = NULL, pszNextAttr = NULL, pszOrder = NULL;
    DWORD cAttrs = 0;
    HRESULT hr = S_OK;
    DWORD index;

    if (!pSearchPrefInfo) {
        RRETURN (E_INVALIDARG);
    }

    if (dwPropId >= g_cMapDBPropToSearchPref)
        RRETURN(E_FAIL);

    pSearchPrefInfo->dwSearchPref = g_MapDBPropIdToSearchPref[dwPropId];

    //
    // Get index of where ADSI search properties begin
    //

    index = NUMELEM(s_rgDBInitProp) +
            NUMELEM(s_rgADSIBindProp) +
            NUMELEM(s_rgDSInfoProp) +
            NUMELEM(s_rgDBSessProp) +
            NUMELEM(s_rgRowsetProp);

    switch (_prgProperties[index + dwPropId].vtType) {
    case VT_BOOL:
        pSearchPrefInfo->vValue.dwType = ADSTYPE_BOOLEAN;
        pSearchPrefInfo->vValue.Boolean =
            _prgProperties[index + dwPropId].boolVal == VARIANT_TRUE ? TRUE : FALSE;
        break;

    case VT_I4:
    case VT_I2:
        pSearchPrefInfo->vValue.dwType = ADSTYPE_INTEGER;
        pSearchPrefInfo->vValue.Integer = _prgProperties[index + dwPropId].longVal;
        break;

    case VT_BSTR: {
        if (pSearchPrefInfo->dwSearchPref != ADS_SEARCHPREF_SORT_ON) {
            //
            // right now, this is the only string preference supported
            //
            RRETURN (E_FAIL);
        }
        //
        // The preference is a list of atributes to be sorted on (in that order
        // and an optional indication of whether it has to be sorted ascending
        // or not.
        // eg., "name ASC, usnchanged DESC, cn"
        //
        pSearchPrefInfo->vValue.dwType = ADSTYPE_PROV_SPECIFIC;

        if (!_prgProperties[index + dwPropId].pwstrVal ||
            !_wcsicmp(_prgProperties[index + dwPropId].pwstrVal, L"")) {

            pSearchPrefInfo->vValue.ProviderSpecific.dwLength = 0;
            pSearchPrefInfo->vValue.ProviderSpecific.lpValue = NULL;

            break;
        }

        // make a copy
        pszAttrs = AllocADsStr(_prgProperties[index + dwPropId].pwstrVal);

        pszCurrentAttr = pszFirstAttr = wcstok(pszAttrs, L",");

        for(cAttrs=0; pszCurrentAttr != NULL; cAttrs++ ) {
            pszCurrentAttr = wcstok(NULL, L",");
        }

        if(cAttrs == 0) {
           BAIL_ON_FAILURE ( hr = E_ADS_BAD_PARAMETER );
        }

        pSortKey = (PADS_SORTKEY) AllocADsMem(sizeof(ADS_SORTKEY) * cAttrs);

        if (!pSortKey) {
            BAIL_ON_FAILURE ( E_OUTOFMEMORY );
        }

        pszCurrentAttr = pszFirstAttr;

        for (DWORD i=0 ; i < cAttrs; i++) {

            pszNextAttr = pszCurrentAttr + wcslen(pszCurrentAttr) + 1;
            pszCurrentAttr = RemoveWhiteSpaces(pszCurrentAttr);

            pszOrder = wcstok(pszCurrentAttr, L" ");
            pszOrder = pszOrder ? wcstok(NULL, L" ") : NULL;

            if (pszOrder && !_wcsicmp(pszOrder, L"DESC"))
                pSortKey[i].fReverseorder = 1;
            else
                pSortKey[i].fReverseorder = 0;  // This is the default

            pSortKey[i].pszAttrType = AllocADsStr(pszCurrentAttr);
            pSortKey[i].pszReserved = NULL;

            pszCurrentAttr = pszNextAttr;

        }

        pSearchPrefInfo->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * cAttrs;
        pSearchPrefInfo->vValue.ProviderSpecific.lpValue = (LPBYTE) pSortKey;

        break;

    }

    default:

        RRETURN (E_FAIL);
    }

error:

    if (pszAttrs) {
        FreeADsStr(pszAttrs);
    }

    RRETURN(hr);

}


HRESULT
CUtilProp::FreeSearchPrefInfo(
    PADS_SEARCHPREF_INFO pSearchPrefInfo,
    DWORD dwNumSearchPrefs
    )
{

    PADS_SORTKEY pSortKey = NULL;
    DWORD nSortKeys = 0;

    if (!pSearchPrefInfo || !dwNumSearchPrefs) {
        RRETURN (S_OK);
    }

    for (DWORD i=0; i<dwNumSearchPrefs; i++) {

        switch(pSearchPrefInfo[i].vValue.dwType) {

        case ADSTYPE_BOOLEAN:
        case ADSTYPE_INTEGER:
            // do nothing
            break;

        case ADSTYPE_PROV_SPECIFIC:

            if (pSearchPrefInfo[i].dwSearchPref == ADS_SEARCHPREF_SORT_ON) {
                //
                // delete the strings allocated for each of the attributes
                // to be sorted

                nSortKeys = pSearchPrefInfo[i].vValue.ProviderSpecific.dwLength / sizeof(ADS_SORTKEY);
                pSortKey = (PADS_SORTKEY) pSearchPrefInfo[i].vValue.ProviderSpecific.lpValue;

                for (DWORD j=0; pSortKey && j<nSortKeys; j++) {
                    FreeADsStr(pSortKey[j].pszAttrType);
                }

                if (pSortKey) {
                    FreeADsMem(pSortKey);
                }

            }

            break;
        }

    }

    RRETURN (S_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::LoadDBPROPINFO
//
//  Synopsis:  Helper for GetPropertyInfo. Loads field of DBPROPINFO
//             structure.
//
//  Arguments:
//
//  Returns:        TRUE    :  Method succeeded
//                  FALSE   :  Method failed (couldn't allocate memory)
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::LoadDBPROPINFO (
    PROPSTRUCT* pPropStruct,
    ULONG       cProperties,
    DBPROPINFO* pPropInfo
    )
{
    ULONG cCount;
    PROPSTRUCT* pProp=NULL;

    // asserts
    ADsAssert( pPropInfo );
    if( cProperties ) {
        ADsAssert( pPropStruct );
    }

    //
    // init the variant
    //
    VariantInit( &pPropInfo->vValues );

    for (cCount=0; cCount < cProperties; cCount++) {
        if(pPropInfo->dwPropertyID == pPropStruct[cCount].dwPropertyID)
            break;
    }

    if(cCount == cProperties) {
        pPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
        pPropInfo->pwszDescription = NULL;
        RRETURN (DB_S_ERRORSOCCURRED);
    }

    pProp = &(pPropStruct[cCount]);
    //
    // set the easy fields..
    //
    pPropInfo->dwPropertyID    = pProp->dwPropertyID;
    pPropInfo->dwFlags        = pProp->dwFlags;
    pPropInfo->vtType        = pProp->vtType;


    // fill in the description
    if (pPropInfo->pwszDescription)
        wcscpy(pPropInfo->pwszDescription, pProp->pwszDescription);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::LoadDBPROP
//
//  Synopsis:  Helper for GetProperties. Loads field of DBPROP structure.
//
//  Arguments:
//
//  Returns:        TRUE    :  Method succeeded
//                  FALSE   :  Method failed (couldn't allocate memory)
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::LoadDBPROP (
    PROPSTRUCT* pPropStruct,
    ULONG       cProperties,
    DBPROP*     pPropSupport,
    BOOL        IsDBInitPropSet
    )
{
    ULONG cCount;
    PROPSTRUCT* pProp=NULL;
    LPWSTR szUserName=NULL, szPassword=NULL;
    BOOL fAuthFlags=0;

    // asserts
    ADsAssert( pPropSupport );
    if( cProperties ) {
        ADsAssert( pPropStruct );
    }

    //
    // init the variant
    //
    VariantInit( &pPropSupport->vValue );

    for (cCount=0; cCount < cProperties; cCount++) {
        if( pPropSupport->dwPropertyID == pPropStruct[cCount].dwPropertyID )
            break;
    }

    if( cCount == cProperties ) {
        pPropSupport->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        RRETURN ( DB_S_ERRORSOCCURRED );
    }

    pProp = &(pPropStruct[cCount]);

    pPropSupport->colid = DB_NULLID;
    pPropSupport->dwOptions = pProp->dwOptions;

    //
    // set pPropSupport->vValue based on Variant type
    //
    switch (pProp->vtType) {
        case VT_BOOL:
            V_VT( &pPropSupport->vValue ) = VT_BOOL;
            V_BOOL( &pPropSupport->vValue ) = (SHORT)pProp->boolVal;
            break;

        case VT_I4:
            V_VT( &pPropSupport->vValue ) = VT_I4;
            V_I4( &pPropSupport->vValue ) = pProp->longVal;
            break;

        case VT_I2:
            V_VT( &pPropSupport->vValue ) = VT_I2;
            V_I2( &pPropSupport->vValue ) = (short)pProp->longVal;
            break;

        case VT_BSTR:
            //
            // If requesting password, get it from the credentials structure
            // as it is not stored anywhere else
            //
            if (IsDBInitPropSet &&
                pPropSupport->dwPropertyID == DBPROP_AUTH_PASSWORD)
            {
                PWSTR pszPassword = NULL;

                if (FAILED(_pCredentials->GetPassword(&pszPassword)))
                {
                    VariantClear( &pPropSupport->vValue );
                    return DB_S_ERRORSOCCURRED;
                }

                if (pszPassword)
                {
                    V_VT(&pPropSupport->vValue)  = VT_BSTR;
                    V_BSTR(&pPropSupport->vValue)= SysAllocString(pszPassword);

                    FreeADsMem(pszPassword);

                    if( V_BSTR(&pPropSupport->vValue) == NULL ) {
                        VariantClear( &pPropSupport->vValue );
                        return DB_S_ERRORSOCCURRED;
                    }
                }
            }
            else if( pProp->pwstrVal ) {
                V_VT(&pPropSupport->vValue)  = VT_BSTR;

                V_BSTR(&pPropSupport->vValue)= SysAllocString(pProp->pwstrVal);

                if( V_BSTR(&pPropSupport->vValue) == NULL ) {
                    VariantClear( &pPropSupport->vValue );
                    return DB_S_ERRORSOCCURRED;
                }
            }
            break;

        default:
            ADsAssert( !"LoadDBPROP unknown variant type!\n\r" );
            pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
            RRETURN (DB_S_ERRORSOCCURRED);
            break;
    }
    //
    // all went well
    //
    pPropSupport->dwStatus = DBPROPSTATUS_OK;
    RRETURN(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::StoreDBProp
//
//  Synopsis:  Helper for SetProperties. Loads field of DBPROP structure.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    09-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::StoreDBPROP (
    PROPSTRUCT* pPropStruct,
    PROPSTRUCT* pStaticPropStruct,
    ULONG       cProperties,
    DBPROP*     pPropSupport,
    DWORD       dwPropIndex
)
{
    // asserts
    ADsAssert( pPropStruct );
    ADsAssert( pPropSupport );

    ULONG i;
    HRESULT hr=S_OK;

    // Initialize the status to DBPROPSTATUS_OK
    pPropSupport->dwStatus = DBPROPSTATUS_OK;

    for (i=0; i < cProperties; i++) {
        if(pPropStruct[i].dwPropertyID == pPropSupport->dwPropertyID) {

            // arg checking for the prop
            if( pPropSupport->dwOptions != DBPROPOPTIONS_OPTIONAL &&
                pPropSupport->dwOptions != DBPROPOPTIONS_REQUIRED ) {
                pPropSupport->dwStatus = DBPROPSTATUS_BADOPTION;
                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            if( (pPropStruct[i].vtType != V_VT(&pPropSupport->vValue) &&
                 V_VT(&pPropSupport->vValue) != VT_EMPTY) ||
                (IsValidValue(pPropSupport, dwPropIndex) == S_FALSE) ) {

                pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            //
            // If property being set is password, we get out here.
            // Reason is we have already stored it in the Credentials structure
            // in encrypted form in the function IsVaidValue above.
            // We should not store it in plain text in pPropStruct[i].
            //
            if (dwPropIndex == INDEX_INIT &&
                pPropSupport->dwPropertyID == DBPROP_AUTH_PASSWORD)
            {
                pPropSupport->dwStatus = DBPROPSTATUS_OK;
                pPropStruct[i].dwOptions = pPropSupport->dwOptions;
                goto error;
            }

            if( !(pPropStruct[i].dwFlags & DBPROPFLAGS_WRITE) ) {
                // Check the value - if they are the same, do nothing
                if ( (V_VT(&pPropSupport->vValue) == VT_EMPTY) ||
                     ((V_VT(&pPropSupport->vValue) == VT_BOOL) &&
                      (pPropStruct[i].boolVal == V_BOOL(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_I4) &&
                      (pPropStruct[i].longVal == V_I4(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_I2) &&
                      ((short)pPropStruct[i].longVal == V_I2(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_BSTR) && pPropStruct[i].pwstrVal &&
                      (wcscmp(pPropStruct[i].pwstrVal,V_BSTR(&pPropSupport->vValue)) == 0)) )

                    goto error;

                if( pPropSupport->dwOptions != DBPROPOPTIONS_OPTIONAL )
                    pPropSupport->dwStatus = DBPROPSTATUS_NOTSETTABLE;
                else
                    pPropSupport->dwStatus = DBPROPSTATUS_NOTSET;

                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            switch (pPropStruct[i].vtType) {
                case VT_BOOL:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].boolVal = V_BOOL( &pPropSupport->vValue );
                    else
                        pPropStruct[i].boolVal = pStaticPropStruct[i].boolVal;
                    break;

                case VT_I4:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].longVal = V_I4( &pPropSupport->vValue );
                    else
                        pPropStruct[i].longVal = pStaticPropStruct[i].longVal;
                    break;

                case VT_I2:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].longVal = V_I2( &pPropSupport->vValue );
                    else
                        pPropStruct[i].longVal = pStaticPropStruct[i].longVal;
                    break;

                case VT_BSTR:
                    if(pPropStruct[i].pwstrVal) {
                        FreeADsStr(pPropStruct[i].pwstrVal);
                        pPropStruct[i].pwstrVal = NULL;
                    }

                    if( V_VT(&pPropSupport->vValue) == VT_EMPTY )
                        pPropStruct[i].pwstrVal = AllocADsStr(( pStaticPropStruct[i].pwstrVal ));
                    else
                    {
                        if (V_BSTR( &pPropSupport->vValue) == NULL &&
                            pPropSupport->dwPropertyID == DBPROP_AUTH_INTEGRATED)
                        {
                            //
                            // For integrated security, NULL bstrVal implies 'use default
                            // provider', which is "SSPI" for us. The reason we don't set
                            // the defult value to SSPI in the static structure is
                            // because this property is special. Unless set, it should
                            // not be used.
                            //
                            pPropStruct[i].pwstrVal = AllocADsStr(L"SSPI");
                        }
                        else
                            pPropStruct[i].pwstrVal = AllocADsStr(V_BSTR( &pPropSupport->vValue ));
                    }

                    if( !pPropStruct[i].pwstrVal &&
                        V_VT(&pPropSupport->vValue) == VT_BSTR ) {

                        hr = E_FAIL;
                        goto error;
                    }
                    break;

                default:
                    pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
                    hr = DB_S_ERRORSOCCURRED;
                    goto error;
            }
            pPropSupport->dwStatus = DBPROPSTATUS_OK;
            pPropStruct[i].dwOptions = pPropSupport->dwOptions;
            break;
        }

    }

    if (i == cProperties) {
        pPropSupport->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        hr = DB_E_ERRORSOCCURRED;
        goto error;
    }

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::IsValidValue
//
//  Synopsis:  Helper for SetProperties. Check the valid values for the Property.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    09-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidValue
        (
        DBPROP*         pDBProp,
        DWORD           dwPropIndex
        )
{
    // Check BOOLEAN values
    if( (pDBProp->vValue.vt == VT_BOOL) &&
        !((V_BOOL(&(pDBProp->vValue)) == VARIANT_TRUE) ||
          (V_BOOL(&(pDBProp->vValue)) == VARIANT_FALSE)) )
        return S_FALSE;

    if( pDBProp->vValue.vt != VT_EMPTY &&
        dwPropIndex == INDEX_INIT )
    {
        switch( pDBProp->dwPropertyID )
        {
        case DBPROP_INIT_PROMPT:
            // These are the only values we support (from spec).
            if (!(V_I2(&pDBProp->vValue) == DBPROMPT_PROMPT ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETE ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETEREQUIRED ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_NOPROMPT))
                return S_FALSE;
                break;

        case DBPROP_INIT_TIMEOUT:
            if( (pDBProp->vValue.vt == VT_I4) &&
                (V_I4(&pDBProp->vValue) < 0) )
                return S_FALSE;

            break;

        case DBPROP_AUTH_USERID:
            if( (!_pCredentials) ||
                (S_OK != _pCredentials->SetUserName(V_BSTR(&pDBProp->vValue))) )
                return S_FALSE;

                break;

        case DBPROP_AUTH_PASSWORD:
            if( (!_pCredentials) ||
                (S_OK != _pCredentials->SetPassword(V_BSTR(&pDBProp->vValue))) )
                return S_FALSE;

                break;

        case DBPROP_AUTH_INTEGRATED:
            //
            // For integrated security, NULL bstrVal implies 'use default
            // provider', which is "SSPI" for us.
            //
            if( ((pDBProp->vValue.vt != VT_BSTR) &&
                 (pDBProp->vValue.vt != VT_NULL))    ||
                ((V_BSTR(&pDBProp->vValue) != NULL) &&
                 (wcscmp(V_BSTR(&pDBProp->vValue), L"SSPI") != 0)))
                return S_FALSE;

            break;

        case DBPROP_INIT_MODE:
            if( (pDBProp->vValue.vt != VT_I4) ||
                    (S_FALSE == IsValidInitMode(V_I4(&pDBProp->vValue))) )
                return S_FALSE;

            break;

#if (!defined(BUILD_FOR_NT40))

        case DBPROP_INIT_BINDFLAGS:
            if( (pDBProp->vValue.vt != VT_I4) ||
                    (S_FALSE == IsValidBindFlag(V_I4(&pDBProp->vValue))) )
                return S_FALSE;

            break;
#endif

        case DBPROP_AUTH_ENCRYPT_PASSWORD:
            if( !_pCredentials )
                return S_FALSE;

            if( IsADSIFlagSet() )
                // override this property if the user set the authentication
                break;

            BOOL fAuthFlags = _pCredentials->GetAuthFlags();

            if( V_BOOL(&pDBProp->vValue) )
                _pCredentials->SetAuthFlags(fAuthFlags | ADS_SECURE_AUTHENTICATION);
            else
                _pCredentials->SetAuthFlags(fAuthFlags & ~ADS_SECURE_AUTHENTICATION);

            break;

        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_ADSIBIND )
    {
        switch( pDBProp->dwPropertyID )
        {
            case ADSIPROP_ADSIFLAG:
                if( !_pCredentials )
                    // don't think this will ever happen
                    return S_FALSE;

                // prevent default initialization by VB from setting the
                // AUTH flags. The client should not specify ADS_AUTH_RESERVED
                // for this property (this might happen if the client behaves
                // like VB i.e, does GetProperties and then SetProperties 
                // without ORing in any flags. In this case, ENCRYPT_PASSWORD
                // will not be overwritten by this property due to this check).
                if( ADS_AUTH_RESERVED == (V_I4(&pDBProp->vValue)) )
                    break;

                // the following call might overwrite ENCRYPT_PASSWORD
                _pCredentials->SetAuthFlags((V_I4(&pDBProp->vValue)) & 
                                                     (~ADS_AUTH_RESERVED) );

                break;

        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_SESSION )
    {
        switch( pDBProp->dwPropertyID )
        {
            case DBPROP_SESS_AUTOCOMMITISOLEVELS:
                // These are the only values we support (from spec).
                if( (pDBProp->vValue.vt == VT_I4) &&
                     (V_I4(&pDBProp->vValue) != 0                            &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_CHAOS           &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_READUNCOMMITTED &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_READCOMMITTED   &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_REPEATABLEREAD  &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_SERIALIZABLE) )
                    return S_FALSE;

                break;
        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_ROWSET )
    {
        switch( pDBProp->dwPropertyID )
        {
            case DBPROP_MAXOPENROWS:
                if( (pDBProp->vValue.vt != VT_I4) || 
                    (V_I4(&pDBProp->vValue) < 0) )
                    return S_FALSE;

                    break;
        }
    }

    return S_OK;    // Is valid
}

//----------------------------------------------------------------------------
// IsValidInitMode
//
// Checks if a given value is a valid value for DBPROP_INIT_MODE
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidInitMode(
    long lVal
    )
{
    // check if any bit that shouldn't be set is actually set
    if( lVal & (~(DB_MODE_READWRITE | 
                  DB_MODE_SHARE_EXCLUSIVE | DB_MODE_SHARE_DENY_NONE)) )
        return S_FALSE;
 
    return S_OK;

}

//---------------------------------------------------------------------------
// IsValidInitBindFlag
//
// Checks if a given value is a valid value for DBPROP_INIT_BINDFLAGS
//
//---------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidBindFlag(
    long lVal
    )
{
#if (!defined(BUILD_FOR_NT40))
    // check if any bit that shouldn't be set is actually set
    if( lVal & (~(DB_BINDFLAGS_DELAYFETCHCOLUMNS | 
                  DB_BINDFLAGS_DELAYFETCHSTREAM | DB_BINDFLAGS_RECURSIVE |
                  DB_BINDFLAGS_OUTPUT | DB_BINDFLAGS_COLLECTION |
                  DB_BINDFLAGS_OPENIFEXISTS | DB_BINDFLAGS_OVERWRITE |
                  DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT)) )
        return S_FALSE;

    // check for mutually exclusive flags
    if( (lVal & DB_BINDFLAGS_OPENIFEXISTS) &&
            (lVal & DB_BINDFLAGS_OVERWRITE) )
        return S_FALSE;

    return S_OK;
#else
    return E_FAIL;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetPropertiesArgChk
//
//  Synopsis:  Initialize the buffers and check for E_INVALIDARG
//
//  Arguments:
//             cPropertyIDSets       # of restiction property IDs
//             rgPropertyIDSets[]    restriction guids
//             pcPropertySets        count of properties returned
//             prgPropertySets       property information returned
//             dwBitMask             which property group
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::GetPropertiesArgChk(
        ULONG                           cPropertySets,
        const DBPROPIDSET               rgPropertySets[],
        ULONG*                          pcProperties,
        DBPROPSET**                     prgProperties,
        DWORD                           dwBitMask
    )
{
    // Initialize values
    if( pcProperties )
        *pcProperties = 0;
    if( prgProperties )
        *prgProperties = NULL;

    // Check Arguments
    if( ((cPropertySets > 0) && !rgPropertySets) ||
         !pcProperties || !prgProperties )
        RRETURN ( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ULONG ul=0; ul<cPropertySets; ul++)
    {
        if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
            RRETURN ( E_INVALIDARG );

        // Check for propper formation of DBPROPSET_PROPERTIESINERROR
        if( ((dwBitMask & PROPSET_DSO) || (dwBitMask & PROPSET_COMMAND)) &&
            (rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
        {
            if( (cPropertySets > 1) ||
                (rgPropertySets[ul].cPropertyIDs != 0) ||
                (rgPropertySets[ul].rgPropertyIDs != NULL) )
                 RRETURN ( E_INVALIDARG );
        }
    }

    RRETURN ( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetPropertyInfo
//
//  Synopsis:  Returns information about rowset and data source properties
//            supported by the provider
//
//  Arguments:
//              cPropertyIDSets             # properties
//              rgPropertyIDSets[]          Array of property sets
//              pcPropertyInfoSets          # DBPROPSET structures
//              prgPropertyInfoSets         DBPROPSET structures property
//                                          information returned
//              ppDescBuffer                Property descriptions
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CUtilProp::GetPropertyInfo
(
    ULONG                cPropertyIDSets,
    const DBPROPIDSET    rgPropertyIDSets[],
    ULONG*               pcPropertyInfoSets,
    DBPROPINFOSET**      pprgPropertyInfoSets,
    WCHAR**              ppDescBuffer,
    BOOL                 fDSOInitialized
    )
{
    DBPROPINFO*      pPropInfo = NULL;
    DBPROPINFOSET*   pPropInfoSet = NULL;
    BOOL             fNoPropInfoGot = TRUE;
    BOOL             fWarning=FALSE;
    HRESULT          hr;
    LPWSTR           pwszDescBuffer=NULL;
    ULONG            cPropertySets=0, cProperties=0;
    ULONG            cCount, j, i;
    ULONG            cNewPropIDSets    = 0;
    BOOL             fIsSpecialGUID    = FALSE;
    BOOL             fIsNotSpecialGUID = FALSE;
    ULONG            ul;
    BOOL             fNewDescription = TRUE;

    // asserts
    ADsAssert( _pIMalloc );

    // init out params
    if( pcPropertyInfoSets )
        *pcPropertyInfoSets = 0;
    if( pprgPropertyInfoSets )
        *pprgPropertyInfoSets = NULL;
    if( ppDescBuffer )
        *ppDescBuffer = NULL;

    // Check Arguments, on failure post HRESULT to error queue
    if( (cPropertyIDSets > 0 && !rgPropertyIDSets) ||
        !pcPropertyInfoSets || !pprgPropertyInfoSets )
        RRETURN( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ul=0; ul<cPropertyIDSets; ul++)
    {
        if( rgPropertyIDSets[ul].cPropertyIDs &&
            !rgPropertyIDSets[ul].rgPropertyIDs )
            RRETURN( E_INVALIDARG );

        // Add 1 for the Provider Specific Rowset Properties
        if( (rgPropertyIDSets[ul].guidPropertySet == DBPROPSET_DBINITALL) ||
            (fDSOInitialized &&
            rgPropertyIDSets[ul].guidPropertySet == DBPROPSET_ROWSETALL) )
            cNewPropIDSets++;

        //
        // Special Guids for Property Sets can not be mixed with ordinary
        // Property Set Guids. Either one or the other, not both
        //
        if (IsSpecialGuid(rgPropertyIDSets[ul].guidPropertySet))
            fIsSpecialGUID = TRUE;
        else
            fIsNotSpecialGUID = TRUE;

        if( fIsSpecialGUID && fIsNotSpecialGUID )
            RRETURN( E_INVALIDARG );
    }

    // save the count of PropertyIDSets
    cNewPropIDSets += cPropertyIDSets;

    // If the consumer does not restrict the property sets
    // by specify an array of property sets and a cPropertySets
    // greater than 0, then we need to make sure we
    // have some to return
    if( cPropertyIDSets == 0 )
    {
        if( fDSOInitialized )
            cNewPropIDSets = NUMBER_OF_SUPPORTED_PROPERTY_SETS;
        else
            // we have 2 property sets in the DBINIT property group
            cNewPropIDSets = 2;
    }

    // use task memory allocater to alloc a DBPROPINFOSET struct
    pPropInfoSet = (DBPROPINFOSET*) _pIMalloc->Alloc(cNewPropIDSets *
                                                                                                sizeof( DBPROPINFOSET ));
    if( !pPropInfoSet )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    memset( pPropInfoSet, 0, (cNewPropIDSets * sizeof( DBPROPINFOSET )));

    if( ppDescBuffer )
    {
        // Allocating more memory than actually required, since 
        // _dwDescBufferLen is th etotal for all property sets together, not
        // just for one property set 
        pwszDescBuffer = (LPWSTR) _pIMalloc->Alloc(_dwDescBufferLen * cNewPropIDSets);
        if( !pwszDescBuffer )
            BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

        memset( pwszDescBuffer, 0, _dwDescBufferLen * cNewPropIDSets);
        *ppDescBuffer = pwszDescBuffer;
    }

    // If no restrictions return all properties from the three supported property sets
    if( cPropertyIDSets == 0 )
    {
        // Fill in all of the Providers Properties
        for (j=0; j< cNewPropIDSets; j++)
            pPropInfoSet[j].guidPropertySet = *s_rgPropertySets[j].guidPropertySet;
    }
    else
    {
        cCount = 0;

        //
        // Deal with the Special GUID's
        //
        for (j=0; j< cPropertyIDSets; j++)
        {
            if( rgPropertyIDSets[j].guidPropertySet == DBPROPSET_DBINITALL )
            {
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_DBINIT;
                // Adjust for ADSI_BIND (provider specific) property set
                cCount++;
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ADSIBIND;
            }
            else if( fDSOInitialized &&
                     rgPropertyIDSets[j].guidPropertySet == DBPROPSET_DATASOURCEINFOALL )
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_DATASOURCEINFO;
            else if( fDSOInitialized &&
                     rgPropertyIDSets[j].guidPropertySet == DBPROPSET_SESSIONALL )
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_SESSION;
            else if( fDSOInitialized &&
                    rgPropertyIDSets[j].guidPropertySet == DBPROPSET_ROWSETALL )
            {
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ROWSET;
                // Adjust for the Provider Specific
                cCount++;
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ADSISEARCH;
            }
            else
            {
                pPropInfoSet[cCount].guidPropertySet = rgPropertyIDSets[j].guidPropertySet;
                pPropInfoSet[cCount].cPropertyInfos  = rgPropertyIDSets[j].cPropertyIDs;
            }

            cCount++;
        }
    }

    //
    // For each supported Property Set
    //
    for (cPropertySets=0;
        cPropertySets < cNewPropIDSets;
        cPropertySets++)
    {
        // Set cProperties to the numerber passed in
        cProperties = pPropInfoSet[cPropertySets].cPropertyInfos;
        pPropInfo = NULL;

        // Get the correct Static data. We have 2 property sets in the
        // INIT property group. Note that we assume that both these property
        // sets occur successively in s_rgPropertySets.
        for (j=0; j< (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2); j++) {
            if( IsEqualGUID(pPropInfoSet[cPropertySets].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet)) ) {
                if( pPropInfoSet[cPropertySets].cPropertyInfos == 0 )
                    cProperties = s_rgPropertySets[j].cProperties;
                break;
            }
        }

        if( cProperties )
        {
            //
            // use task memory allocater to alloc array of DBPROPINFO structs
            //
            pPropInfo = (DBPROPINFO*) _pIMalloc->Alloc(cProperties * sizeof( DBPROPINFO ));
            if( !pPropInfo ) {
                for (i=0; i<cNewPropIDSets; i++)
                    _pIMalloc->Free(pPropInfoSet[i].rgPropertyInfos);
                BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
            }

            memset(pPropInfo, 0, cProperties * sizeof(DBPROPINFO));

            for (cCount=0; cCount < cProperties; cCount++)
            {
                if( pPropInfoSet[cPropertySets].cPropertyInfos == 0 )
                    pPropInfo[cCount].dwPropertyID =
                               s_rgPropertySets[j].pUPropInfo[cCount].dwPropertyID;
                else
                    pPropInfo[cCount].dwPropertyID =
                                  rgPropertyIDSets[cPropertySets].rgPropertyIDs[cCount];

                // set the description pointer. If this property was already 
                // requested in this call, then we reuse the same description
                // pointer. 
                DWORD dwTmp;
                for(dwTmp = 0; dwTmp < cCount; dwTmp++)
                    if(pPropInfo[dwTmp].dwPropertyID == 
                                   pPropInfo[cCount].dwPropertyID) 
                    // same property requested more than once
                        break;

                if(dwTmp == cCount)
                {
                    fNewDescription = TRUE;
                    pPropInfo[cCount].pwszDescription = pwszDescBuffer;
                }
                else
                {
                    fNewDescription = FALSE;
                    pPropInfo[cCount].pwszDescription = 
                                      pPropInfo[dwTmp].pwszDescription;
                }

                hr = LoadDBPROPINFO(
                        ((j < (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2)) ?
                                        s_rgPropertySets[j].pUPropInfo  : NULL),
                        ((j < (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2)) ?
                                        s_rgPropertySets[j].cProperties : 0),
                         &pPropInfo[cCount]
                         );

                if( FAILED(hr) ) {
                    ULONG ulFor;
                    //
                    // something went wrong
                    // clear all variants used so far..
                    //
                    for (ulFor = 0; ulFor < cCount; ulFor++)
                        VariantClear( &pPropInfo[ulFor].vValues );

                    //
                    // .. delete the pPropInfo array, return failure
                    //
                    for (i=0; i<cNewPropIDSets; i++)
                        _pIMalloc->Free(pPropInfoSet[i].rgPropertyInfos);

                    _pIMalloc->Free(pPropInfo);
                    BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
                }

                if( hr != S_OK )
                    fWarning = TRUE;
                else
                    fNoPropInfoGot = FALSE;

                // move the description pointer to the next, if required
                if( pPropInfo[cCount].pwszDescription && fNewDescription)
                    pwszDescBuffer += (wcslen(pPropInfo[cCount].pwszDescription) + 1);
            }
        }
        else
            fWarning = TRUE;

        pPropInfoSet[cPropertySets].rgPropertyInfos = pPropInfo;
        pPropInfoSet[cPropertySets].cPropertyInfos = cProperties;
    }    // for each property set

    //
    // set count of properties and property information
    //
    *pcPropertyInfoSets= cNewPropIDSets;
    *pprgPropertyInfoSets = pPropInfoSet;

    if( fNoPropInfoGot ) {
        if( ppDescBuffer )
            *ppDescBuffer = NULL;
        if( pwszDescBuffer )
            _pIMalloc->Free(pwszDescBuffer);
        RRETURN ( DB_E_ERRORSOCCURRED );
    }
    else if( fWarning )
       RRETURN ( DB_S_ERRORSOCCURRED );
    else
       RRETURN ( S_OK );

error:

    if( pPropInfoSet )
        _pIMalloc->Free(pPropInfoSet);
    if( pwszDescBuffer )
        _pIMalloc->Free(pwszDescBuffer);

        RRETURN ( hr );
}

//----------------------------------------------------------------------------
// IsSpecialGuid
//
// Check if the the property set GUID is one of the special GUIDs
//
//----------------------------------------------------------------------------
BOOL CUtilProp::IsSpecialGuid(
    GUID guidPropSet
    )
{
    if( (DBPROPSET_ROWSETALL == guidPropSet) || 
        (DBPROPSET_DATASOURCEALL == guidPropSet) ||
        (DBPROPSET_DATASOURCEINFOALL == guidPropSet) ||
        (DBPROPSET_SESSIONALL == guidPropSet) ||
        (DBPROPSET_DBINITALL == guidPropSet) 

#if (!defined(BUILD_FOR_NT40)) 
                                             ||
        (DBPROPSET_COLUMNALL == guidPropSet) ||
        (DBPROPSET_CONSTRAINTALL == guidPropSet) ||
        (DBPROPSET_INDEXALL == guidPropSet) ||
        (DBPROPSET_TABLEALL == guidPropSet) ||
        (DBPROPSET_TRUSTEEALL == guidPropSet) ||
        (DBPROPSET_VIEWALL == guidPropSet) 
#endif
                                         )
        
        return TRUE;
    else
        return FALSE;
} 

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetProperties
//
//  Synopsis:  Returns current settings of all properties supported
//             by the DSO/rowset
//
//  Arguments:
//
//             cPropertyIDSets       # of restiction property IDs
//             rgPropertyIDSets[]    restriction guids
//             pcPropertySets        count of properties returned
//             prgPropertySets       property information returned
//
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUtilProp::GetProperties
(
    ULONG               cPropertyIDSets,
    const DBPROPIDSET   rgPropertyIDSets[],
    ULONG*              pcPropertySets,
    DBPROPSET**         pprgPropertySets,
    DWORD               dwBitMask
    )
{
    ULONG       cPropertySets, cProperties;
    ULONG       cNewPropIDSets = 0;
    ULONG       cCount, j, i;
    DBPROP*     pProp = NULL;
    DBPROPSET*  pPropSet = NULL;
    HRESULT     hr = E_FAIL;
    BOOL        fNoPropertyGot = TRUE;
    BOOL        fWarning = FALSE;
    BOOL        fFound = FALSE;
    ULONG       cOffset = 0;

    // asserts
    ADsAssert(_pIMalloc);

    // Assign in the count
    cNewPropIDSets = cPropertyIDSets;

    // If the consumer does not restrict the property sets
    // by specify an array of property sets and a cPropertySets
    // greater than 0, then we need to make sure we
    // have some to return
    if( cPropertyIDSets == 0 )
    {
        // Set the count of properties
        cNewPropIDSets = 1;

        if(dwBitMask & PROPSET_DSO)
        {
            if(dwBitMask & PROPSET_INIT)
                // if the data src object has been initialized, return
                // properties in the DBInit, DSInfo and ADSIBind property sets.
                cNewPropIDSets = 3;
            else
                // Return DBInit and ADSIBind property sets only. Note that we
                // are counting on ADSIBind being the second property set in
                // s_rgPropertySets, since we are leaving cOffset as 0
                cNewPropIDSets = 2;
        }

         if(dwBitMask & PROPSET_COMMAND)
            cNewPropIDSets = 2;
    }

    // Figure out the Offset
    if( dwBitMask & PROPSET_SESSION )
        cOffset = INDEX_SESSION;
    else if( dwBitMask & PROPSET_COMMAND )
        cOffset = INDEX_ROWSET;

    //
    // use task memory allocater to alloc a DBPROPSET struct
    //
    pPropSet = (DBPROPSET*) _pIMalloc->Alloc(cNewPropIDSets * sizeof( DBPROPSET ));

    if( !pPropSet )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    memset( pPropSet, 0, (cNewPropIDSets * sizeof( DBPROPSET )));

    //
    // For each supported Property Set
    //
    for (cPropertySets=0; cPropertySets < cNewPropIDSets; cPropertySets++) {

        // Initialize variable
        ULONG cPropOffset = 0;
        int cNumDSOProps = 0;
        cProperties = 0;
        pProp = NULL;
        fFound = FALSE;

        // Setup the PropSet GUID
        if( cPropertyIDSets == 0 ) {
            pPropSet[cPropertySets].guidPropertySet =
                       *s_rgPropertySets[cPropertySets+cOffset].guidPropertySet;
        }
        else {
            cProperties = rgPropertyIDSets[cPropertySets].cPropertyIDs;
            pPropSet[cPropertySets].guidPropertySet =
                    rgPropertyIDSets[cPropertySets].guidPropertySet;
        }

        if(dwBitMask & PROPSET_DSO)
             // we have 2 property sets whose properties can be set before
             // initialization and one whose properties can be set only after
             // init. Set the count of properties accordingly.
             cNumDSOProps = 1 + !!(dwBitMask & PROPSET_INIT);

        // Setup the count of Properties for that PropSet
        for (j=0;
             j <= cOffset+ cNumDSOProps + !!(dwBitMask & PROPSET_COMMAND);
             j++) {
            if( j >= cOffset &&
                IsEqualGUID(pPropSet[cPropertySets].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet)) ) {
                if (rgPropertyIDSets == NULL ||
                    rgPropertyIDSets[cPropertySets].cPropertyIDs == 0)
                    cProperties = s_rgPropertySets[j].cProperties;

                fFound = TRUE;
                break;
            }

            // Move to the next PropSet
            cPropOffset += s_rgPropertySets[j].cProperties;
        }

        if( cProperties != 0 ) {
            // use task memory allocator to alloc array of DBPROP struct
            pProp = (DBPROP*) _pIMalloc->Alloc(cProperties * sizeof( DBPROP ));

            if( pProp == NULL ) {
                for (i=0; i < cPropertySets; i++)
                    _pIMalloc->Free(pPropSet[i].rgProperties);

                BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
            }

            memset( pProp, 0, (cProperties * sizeof( DBPROP )));

            if( rgPropertyIDSets == NULL ||
                rgPropertyIDSets[cPropertySets].cPropertyIDs == 0 ) {
                for (cCount=0; cCount < cProperties; cCount++)
                    pProp[cCount].dwPropertyID =
                        s_rgPropertySets[j-!fFound].pUPropInfo[cCount].dwPropertyID;
            }
            else {
                for (cCount=0; cCount < cProperties; cCount++)
                    pProp[cCount].dwPropertyID =
                        rgPropertyIDSets[cPropertySets].rgPropertyIDs[cCount];
            }
        }
        else
            fWarning = TRUE;

        //
        // for each prop in our table..
        //
        for (cCount = 0; cCount < cProperties; cCount++) {
            hr = LoadDBPROP((fFound ? &(_prgProperties[cPropOffset]) :  NULL),
                            (fFound ? s_rgPropertySets[j-!fFound].cProperties : 0),
                            &pProp[cCount],
                            pPropSet[cPropertySets].guidPropertySet == DBPROPSET_DBINIT
                            );

            if( FAILED(hr) ) {
                // something went wrong
                // clear all variants used so far..
                for (i=0; i < cCount; i++)
                    VariantClear( &pProp[i].vValue );

                for (i=0; i < cPropertySets; i++)
                    _pIMalloc->Free(pPropSet[i].rgProperties);

                                _pIMalloc->Free(pProp);

                BAIL_ON_FAILURE( hr );
            }

            if( hr != S_OK )
                fWarning = TRUE;
            else
                fNoPropertyGot = FALSE;

        }    // for each property

        pPropSet[cPropertySets].rgProperties = pProp;
        pPropSet[cPropertySets].cProperties = cProperties;
    }    // for each property set

    // set count of properties and property informatio
    *pcPropertySets   = cNewPropIDSets;
    *pprgPropertySets = pPropSet;

    if( fNoPropertyGot )
       RRETURN( DB_E_ERRORSOCCURRED );
    else if( fWarning )
       RRETURN( DB_S_ERRORSOCCURRED );
    else
       RRETURN( S_OK );

error:
    if( pPropSet )
        _pIMalloc->Free(pPropSet);
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::SetProperties
//
//  Synopsis:  Set current settings of properties supported by the DSO/rowset
//
//  Arguments:
//
//             cPropertyIDSets,      # of DBPROPSET
//             rgPropertyIDSets[]    Array of property sets
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::SetProperties(
    ULONG cPropertySets,
    DBPROPSET rgPropertySets[],
    DWORD dwBitMask
    )
{
    ULONG cCount, j, k;
    HRESULT hr;
    BOOL fNoPropertySet = TRUE;
    BOOL fWarning = FALSE;

    // check params
    if( cPropertySets > 0 && !rgPropertySets )
        RRETURN ( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ULONG ul=0; ul<cPropertySets; ul++)
    {
        if( rgPropertySets[ul].cProperties &&
            !(rgPropertySets[ul].rgProperties) )
            RRETURN ( E_INVALIDARG );
    }

    for (cCount=0; cCount < cPropertySets; cCount++) {
        // Not legal to Set INIT or DATASOURCE properties after Initializing
        if( (dwBitMask & PROPSET_INIT) &&
            (rgPropertySets[cCount].guidPropertySet == DBPROPSET_DBINIT) ) {
            //
            // Wrong time to set these Properties
            //
            for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                rgPropertySets[cCount].rgProperties[k].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                fWarning = TRUE;
            }
            continue;
        }

        // Trying to set the wrong Property Set
        if( ((dwBitMask & PROPSET_DSO) && !(dwBitMask & PROPSET_INIT) &&
             (rgPropertySets[cCount].guidPropertySet != DBPROPSET_DBINIT &&
              rgPropertySets[cCount].guidPropertySet != DBPROPSET_ADSIBIND)) ||
            ((dwBitMask & PROPSET_DSO) && (dwBitMask & PROPSET_INIT) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_DATASOURCEINFO) ||
            ((dwBitMask & PROPSET_SESSION) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_SESSION) ||
            ((dwBitMask & PROPSET_COMMAND) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_ROWSET &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_ADSISEARCH) ) {

            //
            // Wrong Property Set
            //
            for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                rgPropertySets[cCount].rgProperties[k].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                fWarning = TRUE;
            }
            continue;
        }

        ULONG cPropOffset = 0;

        for (j=0; j< NUMELEM(s_rgPropertySets); j++) {
            if (IsEqualGUID(rgPropertySets[cCount].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet))) {
                for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                    hr = StoreDBPROP(&(_prgProperties[cPropOffset]),
                                     s_rgPropertySets[j].pUPropInfo,
                                     s_rgPropertySets[j].cProperties,
                                     &(rgPropertySets[cCount].rgProperties[k]),
                                     j );

                    if( hr != S_OK )
                        fWarning = TRUE;
                    else
                        fNoPropertySet = FALSE;
                }
                break;
            }
            // Move to the next PropSet
            cPropOffset += s_rgPropertySets[j].cProperties;
        }
    }

    if ( fNoPropertySet && fWarning )
       RRETURN ( DB_E_ERRORSOCCURRED );
    else if (fWarning)
       RRETURN ( DB_S_ERRORSOCCURRED );
    else
       RRETURN ( S_OK );
}


BOOL
CUtilProp::IsIntegratedSecurity(
    void
    )
{
    // Check to see if SSPI is set
    for (ULONG i=0; i< s_rgPropertySets[INDEX_INIT].cProperties; i++) {
        if( _prgProperties[i].dwPropertyID == DBPROP_AUTH_INTEGRATED)
        {
            if (_prgProperties[i].pwstrVal )
                return( wcscmp(_prgProperties[i].pwstrVal, L"SSPI") == 0 );
            break;
        }
    }

    return FALSE;
}

BOOL
CUtilProp::IsADSIFlagSet()
{
    ULONG PropSetOffset = 0, i;

    for(i = 0; i < INDEX_ADSIBIND; i++)
          PropSetOffset += s_rgPropertySets[i].cProperties;

    // Check if "ADSI Flag" is set to something other than ADS_AUTH_RESERVED 
    for (i=0; i < s_rgPropertySets[INDEX_ADSIBIND].cProperties; i++)
        if(_prgProperties[i+PropSetOffset].dwPropertyID == ADSIPROP_ADSIFLAG)
             return (_prgProperties[i+PropSetOffset].longVal != 
                                                           ADS_AUTH_RESERVED);

    // we should never get here
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


#define GetAce          ADSIGetAce

#define DeleteAce       ADSIDeleteAce

#define GetAclInformation       ADSIGetAclInformation

#define SetAclInformation       ADSISetAclInformation

#define IsValidAcl              ADSIIsValidAcl

#define InitializeAcl           ADSIInitializeAcl


extern HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    );

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    );

//
// Helper routine.
//
PSID
ComputeSidFromAceAddress(
    LPBYTE pAce
    );

//+---------------------------------------------------------------------------
// Function:   GetLsaPolicyHandle - helper routine.
//
// Synopsis:   Returns the lsa policy handle to the server in question.
//          If a serverName is present we will first try that. If no servername
//          is present we will try and connect up to the default server for the
//          currently logged on user. If everything else fails, we will
//          connnect to the local machine (NULL server).
//
// Arguments:  pszServerName    - Name of targtet server/domain or NULL.
//             Credentials      - Credentials to use for the connection.
//                                Currently this is not used.
//             phLsaPolicy      -  Return ptr for lsa policy handle.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   phLsaPolicy.
//
//----------------------------------------------------------------------------
HRESULT
GetLsaPolicyHandle(
    LPWSTR pszServerName,
    CCredentials &Credentials,
    PLSA_HANDLE phLsaPolicy
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD dwErr;
    DWORD dwLen = 0;
    LPWSTR pszServer = NULL;
    BOOL fNullServer = FALSE;
    LSA_OBJECT_ATTRIBUTES lsaObjectAttributes;
    LSA_UNICODE_STRING lsaSystemName;
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];

    memset(&lsaObjectAttributes, 0, sizeof(LSA_OBJECT_ATTRIBUTES));

    //
    // First most common case of serverless paths.
    //
    if (!pszServerName) {
        dwStatus = GetDomainDNSNameForDomain(
                 NULL,
                 FALSE, // do not force verify
                 FALSE, // does not need to be writable
                 szServerName,
                 szDomainName
                 );

        //
        // If we succeeded we will use the name returned,
        // otherwise we will go with NULL.
        //
        if (dwStatus == NO_ERROR) {
            pszServer = szServerName;
        } 
        else {
            fNullServer = TRUE;
        }
    } 
    else {
        pszServer = pszServerName;
    }

    if (pszServer) {
        dwLen = wcslen(pszServer);
    } 

    lsaSystemName.Buffer = pszServer;
    lsaSystemName.Length = dwLen * sizeof(WCHAR);
    lsaSystemName.MaximumLength = lsaSystemName.Length;

    //
    // First attempt at opening policy handle.
    //
    ntStatus = LsaOpenPolicy(
                   &lsaSystemName,
                   &lsaObjectAttributes,
                   POLICY_LOOKUP_NAMES,
                   phLsaPolicy
                   );

    if (ntStatus != STATUS_SUCCESS) {
        //
        // Irrespective of failure should retry if we have not already
        // tried with a NULL serverName.
        //
        if (!fNullServer) {
            fNullServer = TRUE;

            lsaSystemName.Buffer = NULL;
            lsaSystemName.Length = 0;
            lsaSystemName.MaximumLength = 0;
            ntStatus = LsaOpenPolicy(
                           &lsaSystemName,
                           &lsaObjectAttributes,
                           POLICY_LOOKUP_NAMES,
                           phLsaPolicy
                           );
        }

        hr = HRESULT_FROM_WIN32(
                 LsaNtStatusToWinError(ntStatus)
                 );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamesFromSids - helper routine.
//
// Synopsis:   Simple helper routine that calls LsaLookupSids and if the
//          the error returned is ERROR_SOME_NOT_MAPPED, then the hr is
//          set S_OK.
//
// Arguments:  hLsaPolicy       -   LSA_HANDLE to do the lookup on.
//             pSidArray        -   Array of sid's top lookup.
//             dwSidCount       -   Number of sids to translate.
//             ppLsaRefDomList  -   Ret value for domain list.
//             ppLsaNames       -   Ret value for name list.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   n/a.
//
//----------------------------------------------------------------------------
HRESULT
GetNamesFromSids(
    LSA_HANDLE hLsaPolicy,
    PSID *pSidArray,
    DWORD dwSidCount,
    PLSA_REFERENCED_DOMAIN_LIST *ppLsaRefDomList,
    PLSA_TRANSLATED_NAME  *ppLsaNames
    )
{
    HRESULT hr;
    NTSTATUS ntStatus;

    ntStatus = LsaLookupSids(
                   hLsaPolicy,
                   dwSidCount,
                   pSidArray,
                   ppLsaRefDomList,
                   ppLsaNames
                   );
    
    hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntStatus));

    if (hr == HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED)) {
        hr = S_OK;
    }
               
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamesForSidFromArray - helper routine.
//
// Synopsis:   Given the position of the ace and the retrun value from
//          LsaLookupSids, constructs the actual name of the trustee.
//
// Arguments:  dwAceNumber      -   Position of the ace in the array.
//             pLsaRefDoms      -   List of reference domains.
//             pLsaNames        -   List of LSA names.
//             ppszFriendlyName -   Return string pointer.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   n/a.
//
//----------------------------------------------------------------------------
HRESULT 
GetNameForSidFromArray(
    DWORD dwAceNumber,
    LSA_REFERENCED_DOMAIN_LIST *pLsaRefDoms,
    LSA_TRANSLATED_NAME *pLsaNames,
    LPWSTR * ppszFriendlyName
    )
{
    HRESULT hr = S_OK;
    DWORD dwLengthDomain;
    DWORD dwLengthName = 0;
    BOOL fDomainInvalid = FALSE;
    BOOL fNameInvalid = FALSE;
    LPWSTR pszName = NULL;

    *ppszFriendlyName = NULL;

    if (!pLsaNames) {
        RRETURN(hr = E_FAIL);
    }

    switch (pLsaNames[dwAceNumber].Use) {
    
    case SidTypeDomain:
        fNameInvalid = TRUE;
        break;
    
    case SidTypeInvalid:
        fNameInvalid = TRUE;
        fDomainInvalid = TRUE;
        break;
    
    case SidTypeUnknown:
        fNameInvalid = TRUE;
        fDomainInvalid = TRUE;
        break;

    case SidTypeWellKnownGroup:
        if (pLsaNames[dwAceNumber].DomainIndex < 0 ) {
            fDomainInvalid = TRUE;
        }
        break;

    default:
        //
        // Name and domain are valid.
        //
        fDomainInvalid = FALSE;
        fNameInvalid = FALSE;
    }

    if (!fNameInvalid) {
        dwLengthName = ((pLsaNames[dwAceNumber]).Name).Length + sizeof(WCHAR);
    }

    //
    // Process domain if valid.
    //
    if (!fDomainInvalid) {
        DWORD domainIndex = pLsaNames[dwAceNumber].DomainIndex;
        LSA_UNICODE_STRING lsaString;
        //
        // Need to make sure that the index is valid.
        //
        if (domainIndex > pLsaRefDoms->Entries) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        lsaString = ((pLsaRefDoms->Domains)[domainIndex]).Name;

        //
        // Add sizeof(WCHAR) for the trailing \0.
        //
        dwLengthDomain = lsaString.Length + sizeof(WCHAR); 

        if (lsaString.Length > 0) {
            pszName = (LPWSTR) AllocADsMem( dwLengthDomain + dwLengthName);

            if (!pszName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pszName,
                lsaString.Buffer,
                lsaString.Length
            );


        }
        
    }

    if (!fNameInvalid) {
        LSA_UNICODE_STRING lsaNameString = (pLsaNames[dwAceNumber]).Name;
        //
        // Length of pszName is zero if the group name is Everyone but
        // there is still a domain name component.
        //
        if (!fDomainInvalid 
            && pszName 
            && wcslen(pszName)
            ) {
            wcscat(pszName, L"\\");
        } else {
            pszName = (LPWSTR) AllocADsMem(dwLengthName);
            if (!pszName) {
                BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);
            }
        }

        memcpy(
            fDomainInvalid ? pszName : (pszName + wcslen(pszName)),
            lsaNameString.Buffer,
            lsaNameString.Length
            );
    }

    *ppszFriendlyName = pszName;

    RRETURN(hr);

error:

    if (pszName) {
        FreeADsMem(pszName);
    }

    RRETURN(hr);
}

HRESULT
ConvertSecDescriptorToVariant(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    VARIANT * pVarSec,
    BOOL fNTDS
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    VariantInit(pVarSec);
    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        RRETURN(E_FAIL);
    }


    //
    // Control & Revision
    //
    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    //
    // Owner
    //
    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pOwnerSidAddress) {
    	//
    	// For Owner and Group, we will convert the sid in old way without optimization
    	//
        hr = ConvertSidToFriendlyName2(        	
                    pszServerName,
                    Credentials,
                    pOwnerSidAddress,
                    &pszOwner,
                    fNTDS
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // Group
    //
    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pGroupSidAddress) {
    	//
    	// For Owner and Group, we will convert the sid in old way without optimization
    	//
        hr = ConvertSidToFriendlyName2(
                    pszServerName,
                    Credentials,
                    pGroupSidAddress,
                    &pszGroup,
                    fNTDS
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // DACL
    //
    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pDACLAddress) {

        hr = ConvertACLToVariant(
                pszServerName,
                Credentials,
                (PACL)pDACLAddress,
                &varDACL,
                fNTDS
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // SACL
    //
    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pSACLAddress) {

        hr = ConvertACLToVariant(
                pszServerName,
                Credentials,
                (PACL)pSACLAddress,
                &varSACL,
                fNTDS
                );
        BAIL_ON_FAILURE(hr);
    }


    //
    // Construct an IADsSecurityDescriptor with the data
    // retrieved from the raw SD
    //
    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Owner(pszOwner);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Group(pszGroup);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Revision(dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)wControl);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    //
    // Construct a VARIANT with the IADsSecurityDescriptor
    //
    V_VT(pVarSec) = VT_DISPATCH;
    V_DISPATCH(pVarSec) =  pDispatch;

error:
    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        FreeADsStr(pszOwner);
    }

    if (pszGroup) {
        FreeADsStr(pszGroup);
    }


    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToFriendlyName(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR * ppszAccountName,
    BOOL fNTDS
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;

#if 0
/**************************************************************

    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDS) {

        dwAcctLen = sizeof(szAccountName);
        dwDomainLen = sizeof(szDomainName);

        dwRet = LookupAccountSid(
                    pszServerName,
                    pSid,
                    szAccountName,
                    &dwAcctLen,
                    szDomainName,
                    &dwDomainLen,
                    (PSID_NAME_USE)&eUse
                    );

        //
        // Try with NULL server name if we have not already
        // done that for error cases.
        //
        if (!dwRet && pszServerName) {
            dwRet = LookupAccountSid(
                        NULL,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
        }

        //
        // If using serverless paths, try it on the DC if it
        // failed (which will happen if we're trying to resolve
        // something like "BUILTIN\Print Operators" on a member
        // computer)
        //
        if (!dwRet && !pszServerName) {

            dwAcctLen = sizeof(szAccountName);
            dwDomainLen = sizeof(szDomainName);
            

            DWORD dwStatus = GetDomainDNSNameForDomain(
                                        NULL,
                                        FALSE, // don't force verify
                                        FALSE, // not writable
                                        szServerName,
                                        szDomainName
                                        );

            if (dwStatus == NO_ERROR) {

                dwRet = LookupAccountSid(
                            szServerName,
                            pSid,
                            szAccountName,
                            &dwAcctLen,
                            szDomainName,
                            &dwDomainLen,
                            (PSID_NAME_USE)&eUse
                            );

                //
                // If the lookup failed because the server was unavailable, try to get
                // the server again, this time forcing DsGetDcName to do rediscovery
                //
                if (!dwRet && (GetLastError() == RPC_S_SERVER_UNAVAILABLE)) {
                    
                    dwStatus = GetDomainDNSNameForDomain(
                                            NULL,
                                            TRUE, // force verify
                                            FALSE,// not writable
                                            szServerName,
                                            szDomainName
                                            );

                    if (dwStatus == NO_ERROR) {

                        dwRet = LookupAccountSid(
                                    szServerName,
                                    pSid,
                                    szAccountName,
                                    &dwAcctLen,
                                    szDomainName,
                                    &dwDomainLen,
                                    (PSID_NAME_USE)&eUse
                                    );
                    }
                }
            }
        }

        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }else {

            dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

            pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            if (szDomainName[0] && szAccountName[0]) {
                wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
            }else if (szAccountName[0]) {
                wsprintf(pszAccountName,L"%s", szAccountName);
            }

            *ppszAccountName = pszAccountName;

        }

    }else {
*****************************************************************/    
#endif
        
    if (!fNTDS) {

        hr = ConvertSidToU2Trustee(
                    pszServerName,
                    Credentials,
                    pSid,
                    szAccountName
                    );

        if (SUCCEEDED(hr)) {

            pszAccountName = AllocADsStr(szAccountName);
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            *ppszAccountName = pszAccountName;

        }

    } 
    else {
        //
        // This is NTDS case where we need to stringize SID.
        //
        hr = E_FAIL;
    }


    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);
        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;
    }


error:

    RRETURN(hr);
}

HRESULT
ConvertSidToFriendlyName2(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR * ppszAccountName,
    BOOL fNTDS
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;


    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDS) {

        dwAcctLen = sizeof(szAccountName);
        dwDomainLen = sizeof(szDomainName);

        //
        // Servername is specified
        //
        if (pszServerName) {

            dwRet = LookupAccountSid(
                        pszServerName,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
            
        }
        //
        // Servername not specified
        //
        else {

            //
            // If using serverless paths, try it first on the DC
            //                   

            DWORD dwStatus = GetDomainDNSNameForDomain(
                                        NULL,
                                        FALSE, // don't force verify
                                        FALSE, // not writable
                                        szServerName,
                                        szDomainName
                                        );

            if (dwStatus == NO_ERROR) {

                dwRet = LookupAccountSid(
                            szServerName,
                            pSid,
                            szAccountName,
                            &dwAcctLen,
                            szDomainName,
                            &dwDomainLen,
                            (PSID_NAME_USE)&eUse
                            );

                //
                // If the lookup failed because the server was unavailable, try to get
                // the server again, this time forcing DsGetDcName to do rediscovery
                //
                if (!dwRet && (GetLastError() == RPC_S_SERVER_UNAVAILABLE)) {
                    
                    dwStatus = GetDomainDNSNameForDomain(
                                            NULL,
                                            TRUE, // force verify
                                            FALSE,// not writable
                                            szServerName,
                                            szDomainName
                                        );

                    if (dwStatus == NO_ERROR) {
 
                        dwRet = LookupAccountSid(
                                    szServerName,
                                    pSid,
                                    szAccountName,
                                    &dwAcctLen,
                                    szDomainName,
                                    &dwDomainLen,
                                    (PSID_NAME_USE)&eUse
                                    );
                    }
                }
            }
        }

        //
        // At last try with NULL server name 
        //
        if (!dwRet) {
            
            dwAcctLen = sizeof(szAccountName);
            dwDomainLen = sizeof(szDomainName);
            
            dwRet = LookupAccountSid(
                        NULL,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
        }

        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }else {

            dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

            pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            if (szDomainName[0] && szAccountName[0]) {
                wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
            }else if (szAccountName[0]) {
                wsprintf(pszAccountName,L"%s", szAccountName);
            }

            *ppszAccountName = pszAccountName;

        }

    }

    else {

        hr = ConvertSidToU2Trustee(
                    pszServerName,
                    Credentials,
                    pSid,
                    szAccountName
                    );

        if (SUCCEEDED(hr)) {

            pszAccountName = AllocADsStr(szAccountName);
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            *ppszAccountName = pszAccountName;

        }

    } 
    

    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);
        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;
    }


error:

    RRETURN(hr);
}



HRESULT
ConvertACLToVariant(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PACL pACL,
    PVARIANT pvarACL,
    BOOL fNTDS
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszFriendlyName = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;
    LSA_HANDLE hLsaPolicy = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pLsaRefDomList = NULL;
    PLSA_TRANSLATED_NAME pLsaNames = NULL;

    PSID *pSidArray = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );
    //
    // Status should be nonzero for success
    //
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);


    // 
    // Do this only when we actually have ACE
    //
    if(dwAceCount > 0) {
    	

        //
        // Sid lookup can be optimized only for NT style SD's.
        // SiteServer style SD's will continue to be processed as before.
        //
        if (fNTDS) {
            //
            // To speed up the conversion of SID's to trustees, an array of
            // SID's to lookup is built and the whole array processed in one
            // shot. Then the result of the Lookup is used in contstructing
            // the individual ACE's.
            //
              	
            pSidArray = (PSID*) AllocADsMem(sizeof(PSID) * dwAceCount);
            if (!pSidArray) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        
            for (i = 0; i < dwAceCount; i++) {
                dwStatus = GetAce(pACL, i , (void **) &pAceAddress);
                if (!dwStatus) {
                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
    
                pSidArray[i] = ComputeSidFromAceAddress(pAceAddress);
    
                //
                // Sanity check we should always have valid data.
                //
                if (!pSidArray[i]) {
                    BAIL_ON_FAILURE(hr = E_FAIL);
                }
            }
    
            hr = GetLsaPolicyHandle(
                     pszServerName,
                     Credentials,
                     &hLsaPolicy
                 );
    
            //
            // Should we just convert to string SID's ?
            //
            BAIL_ON_FAILURE(hr);

            hr = GetNamesFromSids(
                     hLsaPolicy,
                     pSidArray,
                     dwAceCount,
                     &pLsaRefDomList,
                     &pLsaNames
                     );
            BAIL_ON_FAILURE(hr);

    	
        }

        for (i = 0; i < dwAceCount; i++) {

            if (pszFriendlyName) {
                FreeADsStr(pszFriendlyName);
                pszFriendlyName = NULL;
            }

            dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

            //
            // Need to verify we got back the ace correctly.
            //
            if (!dwStatus) {
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
            }

            if(fNTDS) {
            	hr = GetNameForSidFromArray(
                         i,
                         pLsaRefDomList,
                         pLsaNames,
                         &pszFriendlyName
                         );
            }
        
            //
            // We can ignore the failure.
            // On failure pszFriendlyName is set to NULL in which case
            // we will convert to stringised sid format (for NTDS of course).
            //
            hr = ConvertAceToVariant(
                     pszServerName,
                     pszFriendlyName,
                     Credentials,
                     pAceAddress,
                     (PVARIANT)&varAce,
                     fNTDS
                     );
            //
            // If we cannot convert an ACE we should error out.
            //
            BAIL_ON_FAILURE(hr);
 
            hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));

            BAIL_ON_FAILURE(hr);

            dwNewAceCount++;

            VariantClear(&varAce);
        }

    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    if (pszFriendlyName) {
        FreeADsStr(pszFriendlyName);
    }

    if (pLsaNames) {
        LsaFreeMemory(pLsaNames);
    }
    if (pLsaRefDomList) {
        LsaFreeMemory(pLsaRefDomList);
    }
    if (hLsaPolicy) {
        LsaClose(hLsaPolicy);
    }

    if(pSidArray) {
        FreeADsMem(pSidArray);
    }


    RRETURN(hr);
}



HRESULT
ConvertAceToVariant(
    LPWSTR pszServerName,
    LPWSTR pszTrusteeName,
    CCredentials& Credentials,
    PBYTE pAce,
    PVARIANT pvarAce,
    BOOL fNTDS
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;
    IADsAcePrivate *pPrivAce = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwLenSid = 0;
    DWORD dwErr = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    BSTR bstrObjectGUID = NULL;
    BSTR bstrInheritedObjectGUID = NULL;

    HRESULT hr = S_OK;

    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            hr = BuildADsGuid(ObjectGUID, &bstrObjectGUID);
            BAIL_ON_FAILURE(hr);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            hr = BuildADsGuid(InheritedObjectGUID, &bstrInheritedObjectGUID);
            BAIL_ON_FAILURE(hr);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        break;

    }

    if (pSidAddress) {
        //
        // Nt4 does not reset the last error correctly.
        //
        SetLastError(NO_ERROR);

        dwLenSid = GetLengthSid(pSidAddress);

        if ((dwErr = GetLastError()) != NO_ERROR) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }
    } 
    else {
        //
        // We should always have a valid sid address here.
        // Should we be bailing here ? Or for that matter,
        // should be bail on the default cluase of the switch ?
        //
        dwLenSid = 0;
    }

    //
    // Call the old function only if we could not resolve the name
    //
    if (!pszTrusteeName) {
        hr = ConvertSidToFriendlyName(
                pszServerName,
                Credentials,
                pSidAddress,
                &pszAccountName,
                fNTDS
                );
    } 

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(bstrObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(
                 bstrInheritedObjectGUID
                 );
    }

    //
    // This is a string, so need to check the ecode. We use the
    // friendlyName if that was set and if not the pszAccountName.
    //
    hr = pAccessControlEntry->put_Trustee(
                                  pszTrusteeName ?
                                      pszTrusteeName :
                                      pszAccountName
                                  );
    BAIL_ON_FAILURE(hr);

    if (pSidAddress) {
        //
        // We should now put the SID on this ACE for quick reverse lookup.
        //
        hr = pAccessControlEntry->QueryInterface(
                 IID_IADsAcePrivate,
                 (void **)&pPrivAce
                 );
        
        if SUCCEEDED(hr) {


            hr = pPrivAce->putSid(
                     pSidAddress,
                     dwLenSid
                     );
        }
        //
        // No bail on failure here as it is not a critical failure
        //
    }

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {
        FreeADsStr(pszAccountName);
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }

    if (pPrivAce) {
        pPrivAce->Release();
    }

    if (bstrObjectGUID) {
        ADsFreeString(bstrObjectGUID);
    }

    if (bstrInheritedObjectGUID) {
        ADsFreeString(bstrInheritedObjectGUID);
    }

    RRETURN(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


//+---------------------------------------------------------------------------
// Function:   ComputeSidFromAceAddress - helper routine.
//
// Synopsis:   Returns the pointer to the SID, given a ptr to an ACE.
//
// Arguments:  pAce              -  ptr to the ACE.
//
// Returns:    NULL on error or valid PSID.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
PSID
ComputeSidFromAceAddress(
    LPBYTE pAce
    )
{
    PSID pSidRetVal = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwAceType, dwAceFlags, dwAccessMask;
    DWORD dwFlags;

    pAceHeader = (ACE_HEADER *)pAce;

    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidRetVal =  (LPBYTE)pAceHeader 
                      + sizeof(ACE_HEADER)
                      + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader 
                           + sizeof(ACE_HEADER) 
                           + sizeof(ACCESS_MASK)
                           );
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            pOffset += sizeof (GUID);

        }

        pSidRetVal = pOffset;
        break;

    default:
        break;

    } // end of switch case.

    return pSidRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\sql\macro.h ===
#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }





















































=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\sql\lexer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lexer.cxx

Abstract:

    This module implements functions to recognize the tokens in the string
    repressentation of the search filter. The format of the search filter
    according to Minimal SQL grammar which is a subset of ANSI SQL 92. 

Author:

    Shankara Shastry [ShankSh]    13-Dec-1996

++*/

#include "lexer.hxx"
#include "macro.h"

DFA_STATE  CLexer::_pStateTable[MAX_DFA_STATES][MAX_CHAR_CLASSES] = gStateTable;

WCHAR CLexer::_pKeywordTable[][MAX_KEYWORD_LEN] = gKWTable;
DWORD CLexer::_pKW2Token[] = gKW2Token;

DWORD CLexer::_pCharClassTable[] = gCharClassTable;

//+---------------------------------------------------------------------------
// Function: CLexer
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments: szBuffer: pattern
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(
    LPWSTR szBuffer
    ):
                _ptr(NULL),
                _Buffer(NULL),
                _dwEndofString(0),
                _dwState(START_STATE),
                _lexeme()
{
    _bInitialized = FALSE;
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = (LPWSTR) AllocADsMem(
                            (wcslen(szBuffer)+1) * sizeof(WCHAR)
                            );
    if(_Buffer)
        wcscpy(_Buffer,
               szBuffer
               );
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function: GetNextToken
//
// Synopsis: Give the next valid token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
        HRESULT hr = S_OK;
    WCHAR wcNextChar;
    DWORD dwActionId;
    DFA_STATE dfaState;
    DWORD dwStartState = _dwState;
    // If there is no pattern
    if(!_ptr) {
        *pdwToken = TOKEN_END;
        RRETURN (S_OK);
    }

    // Start forming the lexeme.

    _lexeme.ResetLexeme();

    *ppszToken = NULL;
    *pdwToken = TOKEN_ERROR;

    while (_dwState != STATE_ERROR && _dwState < FINAL_STATES_BEGIN) {
        // Get the character class from the character and then index the
        // state table
        wcNextChar = NextChar();
        dwActionId = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwActionId;

        _dwState = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwNextState;

        if(_dwState == STATE_ERROR) {
            BAIL_ON_FAILURE (E_FAIL);
        }

        hr = PerformAction(_dwState,
                           wcNextChar,
                           dwActionId);
        BAIL_ON_FAILURE (hr);
    }

    _bInitialized = TRUE;
    
    if(*pdwToken == TOKEN_END)
        RRETURN (S_OK);

    *ppszToken = _lexeme.GetLexeme();
    *pdwToken = GetTokenFromState(_dwState);

    _dwStateSave = _dwState;
    
    _dwState = START_STATE;

    RRETURN (S_OK);

error:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
// Function: NextChar
//
// Synopsis: Returns the next chaarcter in the pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function: GetCurrentToken
//
// Synopsis: Give the current valid token, and do not advance unless
//           it is the first token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetCurrentToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    if (!_bInitialized) {
        HRESULT hr;
        hr = GetNextToken(
                    ppszToken,
                    pdwToken
                    );
        return hr;
    } else {
        *ppszToken = _lexeme.GetLexeme();
        *pdwToken = GetTokenFromState(_dwStateSave);
        return (S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function: PushbackChar
//
// Synopsis: Puts back a character to the unrecognised pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

HRESULT
CLexer::PerformAction(
            DWORD dwCurrState,
            WCHAR wcCurrChar,
            DWORD dwActionId
            )
{
   HRESULT hr = S_OK;

   switch(dwActionId) {
       case ACTION_PUSHBACK_CHAR:
           PushbackChar();
           break;
       case ACTION_IGNORE_ESCAPECHAR:
           break;
       case ACTION_DEFAULT:
           hr = _lexeme.PushNextChar(wcCurrChar);
           BAIL_ON_FAILURE(hr);
           break;
   }

   if(_dwState >= FINAL_STATES_BEGIN)
       _lexeme.PushNextChar(L'\0');

error:
   RRETURN (hr);
}

//+---------------------------------------------------------------------------
// Function: CLexer::GetTokenFromState
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
inline DWORD
CLexer::GetTokenFromState(
            DWORD dwCurrState
            )
{
    DWORD dwToken = dwCurrState - FINAL_STATES_BEGIN;
    LPWSTR pszToken = _lexeme.GetLexeme();

    if(dwToken != TOKEN_USER_DEFINED_NAME) 
       return dwToken;

    for (int i=0; _pKeywordTable[i][0] != '\0'; i++) {
        if(!_wcsicmp(pszToken, _pKeywordTable[i]))
           return (_pKW2Token[i]);
    }

    return (TOKEN_USER_DEFINED_NAME);
}

//+---------------------------------------------------------------------------
// Function: ~CLexer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if( _Buffer )
        FreeADsMem (_Buffer);

}

//+---------------------------------------------------------------------------
// Function: CLexeme
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexeme::CLexeme(
    ):
        _dwMaxLength(0),
        _dwIndex(0)
{
    _pszLexeme = (LPWSTR) AllocADsMem(LEXEME_UNIT_LENGTH * sizeof(WCHAR));
    if(_pszLexeme)
        _dwMaxLength = LEXEME_UNIT_LENGTH;
}

//+---------------------------------------------------------------------------
// Function: ~CLexeme
//
// Synopsis: Destructor
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

CLexeme::~CLexeme(
    )
{
    if(_pszLexeme)
        FreeADsMem(_pszLexeme);
}

//+---------------------------------------------------------------------------
// Function: PushNextChar
//
// Synopsis: Add the next character after making sure there is enough memory
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexeme::PushNextChar(
    WCHAR wcNextChar
    )
{
    HRESULT hr = S_OK;
    if(_dwIndex >= _dwMaxLength)
    {
        _pszLexeme = (LPWSTR) ReallocADsMem(
                                _pszLexeme,
                                _dwMaxLength * sizeof(WCHAR),
                                (_dwMaxLength + LEXEME_UNIT_LENGTH)* sizeof(WCHAR) 
                                );
        if (!_pszLexeme) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        _dwMaxLength += LEXEME_UNIT_LENGTH;
    }

    _pszLexeme[_dwIndex++] = wcNextChar;

error:
    RRETURN (hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

CRITICAL_SECTION g_StringsCriticalSection;
WCHAR g_szBuiltin[100];
WCHAR g_szNT_Authority[100];
WCHAR g_szAccountOperators[100];
WCHAR g_szPrintOperators[100];
WCHAR g_szBackupOperators[100];
WCHAR g_szServerOperators[100];
WCHAR g_szPreWindows2000[100];

BOOL g_fStringsLoaded = FALSE;

//
// Global variables for dynamically loaded fn's.
//
HANDLE g_hDllAdvapi32 = NULL;
BOOL g_fDllsLoaded = FALSE;

extern "C" {

    HRESULT
        ConvertSidToString(
            PSID pSid,
            LPWSTR   String
            );
}

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    );

#define GetAce          ADSIGetAce

#define AddAce          ADSIAddAce

#define DeleteAce       ADSIDeleteAce

#define GetAclInformation       ADSIGetAclInformation

#define SetAclInformation       ADSISetAclInformation

#define IsValidAcl              ADSIIsValidAcl

#define InitializeAcl           ADSIInitializeAcl

#define SetSecurityDescriptorControl    ADSISetControlSecurityDescriptor


#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    );

HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    );

HRESULT
AddFilteredACEs(
    PACL         pAcl,
    DWORD        dwAclRevision,
    PACE_HEADER *ppAceHdr,
    DWORD        dwCountACEs,
    DWORD       *pdwAclPosition,
    BOOL         fInheritedACEs,
    BOOL         fDenyACEs,
    BOOL         fDenyObjectACEs,
    BOOL         fGrantACEs,
    BOOL         fGrantObjectACEs,
    BOOL         fAuditACEs
    );

//
// These wrapper functions are needed as some fn's need to
// be loaded dynamically as they are not available on NT4
//
#define SET_SD_CONTROL_API  "SetSecurityDescriptorControl"

//
// Helper that loads functions in advapi32.
//
PVOID LoadAdvapi32Function(CHAR *function)
{
    //
    // Since the strings critical section is only used in this file,
    // be fine just re-using it here.
    //
    if (!g_fDllsLoaded) {
        EnterCriticalSection(&g_StringsCriticalSection);
        if (!g_fDllsLoaded) {
            g_hDllAdvapi32 = LoadLibrary(L"ADVAPI32.DLL");
            //
            // Even if this fails, there is nothing we can do.
            //
            g_fDllsLoaded = TRUE;
        }
        LeaveCriticalSection(&g_StringsCriticalSection);
    }

    if (g_hDllAdvapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllAdvapi32, function));
    }

    return NULL;
}


typedef DWORD (*PF_SetSecurityDescriptorControl) (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );

//
// Wrapper function for the same.
//
DWORD SetSecurityDescriptorControlWrapper(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
{
    static PF_SetSecurityDescriptorControl pfSetSecDescControl = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfSetSecDescControl == NULL) {
        pfSetSecDescControl = (PF_SetSecurityDescriptorControl)
                                    LoadAdvapi32Function(SET_SD_CONTROL_API);
        f_LoadAttempted = TRUE;
    }

    if (pfSetSecDescControl != NULL) {
        return ((*pfSetSecDescControl)(
                      pSecurityDescriptor,
                      ControlBitsOfInterest,
                      ControlBitsToSet
                      )
                );
    }
    else {
        //
        // This will call the routine in acledit.cxx.
        // We should be in this codepath only in pre win2k
        // machines.
        //
        return SetSecurityDescriptorControl(
                   pSecurityDescriptor,
                   ControlBitsOfInterest,
                   ControlBitsToSet
                   );
    }

}

HRESULT
ConvertSecurityDescriptorToSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    BOOL dwStatus = 0;

    DWORD dwControl = 0;
    DWORD dwRevision = 0;

    hr = pSecDes->get_Revision((long *)&dwRevision);
    BAIL_ON_FAILURE(hr);

    dwStatus = InitializeSecurityDescriptor (
                &AbsoluteSD,
                dwRevision
                );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = pSecDes->get_Control((long *)&dwControl);
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorControlWrapper(
                    &AbsoluteSD,
                    SE_VALID_CONTROL_BITS,
                    (SECURITY_DESCRIPTOR_CONTROL) (dwControl & SE_VALID_CONTROL_BITS)
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetOwnerSecurityIdentifier(
                pszServerName,
                Credentials,
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pszServerName,
                Credentials,
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = GetDacl(
            pszServerName,
            Credentials,
            pSecDes,
            &pDacl,
            &fDaclDefaulted,
            fNTDSType
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    //
    // This is a special case, basically the DACL is defaulted
    // and pDacl is NULL. In order for this to work correctly,
    // pDacl should be an empty ACL not null.
    //
    if (DaclPresent && !pDacl) {
        pDacl = (PACL) AllocADsMem(sizeof(ACL));
        if (!pDacl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        dwStatus = InitializeAcl(
                       pDacl,
                       sizeof(ACL),
                       ACL_REVISION // this revision will work for NT4 and Win2k
                       );
        if (!dwStatus) {
            hr  = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetSacl(
            pszServerName,
            Credentials,
            pSecDes,
            &pSacl,
            &fSaclDefaulted,
            fNTDSType
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = AllocADsMem(dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        FreeADsMem(pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        FreeADsMem(pDacl);
    }

    if (pSacl) {
        FreeADsMem(pSacl);
    }

    if (pOwnerSid) {
        FreeADsMem(pOwnerSid);
    }

    if (pGroupSid) {
        FreeADsMem(pGroupSid);
    }

    RRETURN(hr);

error:
    if (pRelative) {
        FreeADsMem(pRelative);
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
GetOwnerSecurityIdentifier(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted,
    BOOL fNTDSType
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrOwner,
                    ppSid,
                    &dwSidSize,
                    fNTDSType
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        ADsFreeString(bstrOwner);
    }

    RRETURN(hr);
}

HRESULT
GetGroupSecurityIdentifier(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted,
    BOOL fNTDSType
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrGroup,
                    ppSid,
                    &dwSidSize,
                    fNTDSType
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        ADsFreeString(bstrGroup);
    }

    RRETURN(hr);

}

HRESULT
GetDacl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted,
    BOOL fNTDSType
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pszServerName,
                Credentials,
                pDiscAcl,
                ppDacl,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
GetSacl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted,
    BOOL fNTDSType
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pszServerName,
                Credentials,
                pSystemAcl,
                ppSacl,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    RRETURN(hr);
}

HRESULT
ConvertAccessControlListToAcl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl,
    BOOL fNTDSType
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD iAclPosition = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;

    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    DWORD dwAclRevision = 0;
    DWORD dwError = 0;

    //
    // Defines the canonical ordering of the ACEs.
    //
    struct AceOrderElement
        { 
        BOOL fInheritedACEs;
        BOOL fDenyACEs;
        BOOL fDenyObjectACEs;
        BOOL fGrantACEs;
        BOOL fGrantObjectACEs;
        BOOL fAuditACEs;
        } AceOrderSequence [] =
            {
              {FALSE, FALSE, FALSE, FALSE, FALSE, TRUE},
              {FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE},
              {FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE},
              {FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE},
              {FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE},

              {TRUE, FALSE, FALSE, FALSE, FALSE, TRUE},
              {TRUE, TRUE,  FALSE, FALSE, FALSE, FALSE},
              {TRUE, FALSE, TRUE,  FALSE, FALSE, FALSE},
              {TRUE, FALSE, FALSE, TRUE,  FALSE, FALSE},
              {TRUE, FALSE, FALSE, FALSE, TRUE,  FALSE}
            };

    DWORD dwAceOrderSequenceLen = sizeof(AceOrderSequence) / sizeof (AceOrderElement);


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = (PACE_HEADER *)AllocADsMem(sizeof(PACE_HEADER)*dwAceCount);
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        //
        // Need to BAIL here as we could not convert an ACL.
        //
        BAIL_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        BAIL_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAce(
                    pszServerName,
                    Credentials,
                    pAccessControlEntry,
                    &(pTempAce),
                    fNTDSType
                    );
        BAIL_ON_FAILURE(hr);



        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)AllocADsMem(dwAclSize);
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);


    dwRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );
    if (!dwRet) {
        hr  = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    //
    // Add the ACEs in canonical ordering:
    //   All Explitic Audit
    //   All Explicit Deny
    //   All Explicit Object Deny
    //   All Explicit Allow
    //   All Explicit Object Allow
    //
    //   All Inherited Audit
    //   All Inherited Deny
    //   All Inherited Object Deny
    //   All Inherited Allow
    //   All Inherited Object Allow
    //

    for (i=0; i < dwAceOrderSequenceLen; i++) {

        hr = AddFilteredACEs(
                         pAcl,
                         dwAclRevision,
                         ppAceHdr,
                         dwCount,
                         &iAclPosition,
                         AceOrderSequence[i].fInheritedACEs,
                         AceOrderSequence[i].fDenyACEs,
                         AceOrderSequence[i].fDenyObjectACEs,
                         AceOrderSequence[i].fGrantACEs,
                         AceOrderSequence[i].fGrantObjectACEs,
                         AceOrderSequence[i].fAuditACEs
                         );
        BAIL_ON_FAILURE(hr);
    }

  
    *ppAcl = pAcl;



error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                FreeADsMem(*(ppAceHdr + i));
            }
        }

        FreeADsMem(ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

/*
 * AddFilteredACEs
 *
 * Adds ACEs from ppAceHdr (of size dwCountACEs) to the ACL pAcl
 * (of revision dwAclRevision), starting at position *pdwAclPosition in
 * the ACL, based on the filter settings fInheritedACEs, fDenyACEs,
 * fGrantACEs, fDenyObjectACEs, fGrantObjectACEs, and fAuditACEs.
 *
 * On return, *pdwAclPosition is the position to continue adding
 * ACEs at.
 *
 */
HRESULT
AddFilteredACEs(
    PACL         pAcl,              // the ACL to add the ACEs to
    DWORD        dwAclRevision,     // the revision of the ACL
    PACE_HEADER *ppAceHdr,          // the ACEs to add
    DWORD        dwCountACEs,       // number of ACEs in ppAceHdr
    DWORD       *pdwAclPosition,    // starting(in)/ending(out) position
    BOOL         fInheritedACEs,    // include explicit or inherited ACEs?
    BOOL         fDenyACEs,         // include access-deny ACEs?
    BOOL         fDenyObjectACEs,   // include access-deny-object ACEs?
    BOOL         fGrantACEs,        // include access-grant ACEs?
    BOOL         fGrantObjectACEs,  // include access-grant-object ACEs?
    BOOL         fAuditACEs         // include audit ACEs?
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;

    DWORD i;
    DWORD iAclPosition = *pdwAclPosition;
    BOOL  fAddIt;

    BOOL  fIsAceInherited;

    for (i = 0; i < dwCountACEs; i++) {

        //
        // Filter based on whether we're adding explicit or inherited ACEs
        //
        fIsAceInherited = (((*(ppAceHdr + i))->AceFlags) & INHERITED_ACE) ? TRUE : FALSE;

        if ( fIsAceInherited == fInheritedACEs) {

            fAddIt = FALSE;

            //
            // Filter based on ACE type
            //
            switch ((*(ppAceHdr + i))->AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    if (fGrantACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    if (fGrantObjectACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                case ACCESS_DENIED_ACE_TYPE:
                    if (fDenyACEs) {
                        fAddIt = TRUE;
                    }
                    break;
                
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if (fDenyObjectACEs) {
                        fAddIt = TRUE;
                    }
                    break;
                
                case SYSTEM_AUDIT_ACE_TYPE:
                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                    if (fAuditACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                default:
                    BAIL_ON_FAILURE(hr = E_INVALIDARG);
                    break;
            }

            //
            // If the ACE met the criteria, add it to the ACL
            //
            if (fAddIt) {
                dwStatus = AddAce(
                                pAcl,
                                dwAclRevision,
                                iAclPosition++,
                                (LPBYTE)*(ppAceHdr + i),
                                (*(ppAceHdr + i))->AceSize
                                );
                                
                if (!dwStatus) {

                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
            }
        }
    }

error:

    *pdwAclPosition = iAclPosition;
    RRETURN(hr);
}
    

HRESULT
ConvertAccessControlEntryToAce(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce,
    BOOL fNTDSType
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;
    BOOL fLookupTrustee = TRUE;
    BOOL fSidValid = FALSE;
    IADsAcePrivate *pPrivAce = NULL;

    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    //
    // We need to see if we can use a cached SID here.
    //
    hr = pAccessControlEntry->QueryInterface(
             IID_IADsAcePrivate,
             (void **)&pPrivAce
             );
    
    if (SUCCEEDED(hr)) {
        //
        // See if the SID is valid and if so try and retrieve it.
        //
        hr = pPrivAce->isSidValid(&fSidValid);
        if (SUCCEEDED(hr) && fSidValid) {
            
            hr = pPrivAce->getSid(
                     &pSid,
                     &dwSidSize
                     );

            if (SUCCEEDED(hr)) {
                fLookupTrustee = FALSE;
            }
        }

    }


    if (fLookupTrustee) {

        hr = ConvertTrusteeToSid(
                 pszServerName,
                 Credentials,
                 bstrTrustee,
                 &pSid,
                 &dwSidSize,
                 fNTDSType
                 );
    }

    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);


    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    default:
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
        BAIL_ON_FAILURE(hr);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    if (bstrObjectTypeClsid) {
        SysFreeString(bstrObjectTypeClsid);
    }

    if (bstrInheritedObjectTypeClsid) {
        SysFreeString(bstrInheritedObjectTypeClsid);
    }

    if (pPrivAce) {
        pPrivAce->Release();
    }

    RRETURN(hr);
}

HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    RRETURN(S_OK);

}

HRESULT
ParseAccountName(LPWSTR szFullAccountName,
                 LPWSTR *pszUserDomainName,
                 LPWSTR *pszUserAccountName)
{
    HRESULT hr = S_OK;
    DWORD dwDomain = 0;
    BOOLEAN bFound = FALSE;
    LPWSTR szUserDomainName = NULL;
    LPWSTR szUserAccountName = NULL;
    LPWSTR szCount = szFullAccountName;

    if (!szFullAccountName) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    while (*szCount) {
        if (*szCount == '\\') {
            bFound = TRUE;
            break;
        }
        dwDomain++;
        szCount++;
    }

    if (bFound) {
        DWORD dwRest = 0;
        szUserDomainName = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwDomain+1));
        if (!szUserDomainName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        wcsncpy(szUserDomainName,
                szFullAccountName,
                dwDomain);
        wcscat(szUserDomainName, L"\0");

        szUserAccountName = AllocADsStr(szCount+1);
        if (!szUserAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        szUserAccountName = AllocADsStr(szFullAccountName);
        if (!szUserAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        szUserDomainName = NULL;
    }
    *pszUserAccountName = szUserAccountName;
    *pszUserDomainName = szUserDomainName;
    return hr;

error:
    if (szUserAccountName) {
        FreeADsMem(szUserAccountName);
    }
    if (szUserDomainName) {
        FreeADsMem(szUserDomainName);
    }
    return hr;
}


HRESULT
ConvertTrusteeToSid(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    DWORD dwErr = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;
    LPWSTR pszEnd = NULL;

    LPWSTR szUserDomainName = NULL;
    LPWSTR szUserAccountName = NULL;
    LPWSTR szAccountName = NULL;
    BOOL fForceVerify = FALSE;

    //
    // Load the strings into table if necessary
    //
    if (!g_fStringsLoaded) {

        EnterCriticalSection(&g_StringsCriticalSection);

        //
        // Verify flag again.
        //
        if (!g_fStringsLoaded) {

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_BUILTIN,
                        g_szBuiltin,
                        sizeof( g_szBuiltin ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szBuiltin, L"BUILTIN");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_NT_AUTHORITY,
                        g_szNT_Authority,
                        sizeof( g_szNT_Authority ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szNT_Authority, L"NT AUTHORITY");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_ACCOUNT_OPERATORS,
                        g_szAccountOperators,
                        sizeof( g_szAccountOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szAccountOperators, L"Account Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_PRINT_OPERATORS,
                        g_szPrintOperators,
                        sizeof( g_szPrintOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szPrintOperators, L"Print Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_BACKUP_OPERATORS,
                        g_szBackupOperators,
                        sizeof( g_szBackupOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szBackupOperators, L"Backup Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_SERVER_OPERATORS,
                        g_szServerOperators,
                        sizeof( g_szServerOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szServerOperators, L"Server Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_PRE_WIN2000,
                        g_szPreWindows2000,
                        sizeof( g_szPreWindows2000 ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(
                    g_szPreWindows2000,
                    L"Pre-Windows 2000 Compatible Access"
                    );
            }

        }

        g_fStringsLoaded = TRUE;

        LeaveCriticalSection(&g_StringsCriticalSection);

    }

    //
    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDSType) {
        WCHAR szDomainName[MAX_PATH];
        WCHAR szServerName[MAX_PATH];
        LPWSTR szLookupServer = NULL;
        BOOL fSpecialLookup = FALSE;
        BOOL fLookupOnServer = FALSE;
        DWORD dwTmpSidLen = 0;

        dwSidSize = sizeof(Sid);
        szAccountName = bstrTrustee;

        hr = ParseAccountName(bstrTrustee,
                              &szUserDomainName,
                              &szUserAccountName);
        BAIL_ON_FAILURE(hr);

        //
        // Need to look these up on the server only.
        //
        if (szUserAccountName
            && ((_wcsicmp(szUserAccountName, g_szAccountOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szPrintOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szBackupOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szServerOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szPreWindows2000) == 0)
                )
            ) {
            if (szUserDomainName
                && (_wcsicmp(szUserDomainName, g_szBuiltin)) == 0) {
                fSpecialLookup = TRUE;
            } else {
                fSpecialLookup = FALSE;
            }
        } // special users

        if (fSpecialLookup ||
            (szUserDomainName &&
            (_wcsicmp(szUserDomainName, g_szBuiltin) != 0) &&
            (_wcsicmp(szUserDomainName, g_szNT_Authority) != 0))
            ) {

            //
            // We will come back here and do a force retry
            // if the server is down.
            //
retryForce:
            //
            // Force hr to S_OK. This will be needed especially
            // when we jump to the retryForce label.
            //
            hr = S_OK;

            //
            // Set Lookup on server to true so that later
            // on we do not do the lookup on the server again.
            // In some cases just like we fall back to local machine,
            // we need to look at the server if the local machine fails.
            // this will be the case for mixed locale domains.
            //
            DWORD dwStatus = GetDomainDNSNameForDomain(
                                fSpecialLookup ?
                                    NULL :
                                    szUserDomainName,
                                fForceVerify, // forceVerify
                                FALSE,
                                szServerName,
                                szDomainName
                                );

            fLookupOnServer = TRUE;

            if (dwStatus) {
                szLookupServer = NULL;
            }
            else {
                szLookupServer = szServerName;
            }
            szAccountName = szUserAccountName;
        }

        dwRet = LookupAccountName(
                    szLookupServer,
                    bstrTrustee,
                    Sid,
                    &dwSidSize,
                    szDomainName,
                    &dwDomainSize,
                    (PSID_NAME_USE)&eUse
                    );
        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        } 
        else {
            //
            // Update the length of the SID.
            //
            
            //
            // Call needed on NT4 where GetLenghtSid  does not
            // reset the error correctly leading to false errors.
            //
            SetLastError(NO_ERROR);
            
            dwTmpSidLen = GetLengthSid(Sid);
            
            if ((dwRet = GetLastError()) == NO_ERROR) {
                //
                //  Got the correct length so update dwSidSize
                //
                dwSidSize = dwTmpSidLen;
            }
        }

        if (FAILED(hr)
            && hr != HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)) {

            //
            // This code path should not be hit often but it can
            // happen on multi locale domains. The server when might
            // have returned say Builtin instead of german for the same.
            // If the client is german we will be looking for germanbuiltin
            // and that wont work. The lookup will fail locally but
            // will succeed on the server. This is especially true for
            // Builtin\Print Operators as that can only be resolved on the DC.
            //
            if (pszServerName) {
                //
                // Before we do a dsgetdc, we should try with
                // the serverName passed in.
                //
                hr = S_OK;
                dwRet = LookupAccountName(
                            pszServerName,
                            bstrTrustee,
                            Sid,
                            &dwSidSize,
                            szDomainName,
                            &dwDomainSize,
                            (PSID_NAME_USE)&eUse
                            );
                if (!dwRet) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    //
                    // force server name to NULL so we wont
                    // try this again.
                    //
                    pszServerName = NULL;
                }
                else {
                    //
                    // Update the length of the SID.
                    //
            
                    //
                    // Call needed on NT4 where GetLenghtSid  does not
                    // reset the error correctly leading to false errors.
                    //
                    SetLastError(NO_ERROR);
            
                    dwTmpSidLen = GetLengthSid(Sid);
            
                    if ((dwRet = GetLastError()) == NO_ERROR) {
                        //
                        //  Got the correct length so update dwSidSize
                        //
                        dwSidSize = dwTmpSidLen;
                    }
                }
            }


            if (FAILED(hr)) {
                //
                // We could be here if either pszServerName was always
                // NULL or if the call to the server failed.
                // The only thing we can do is to retry if we know
                // that the szLookupServer was NULL (that is local machine)
                // or if szLookupServer was something other than the default
                // server for the machine (that is we called DsGetDC with
                // the name of a domain rather than NULL).
                // In all other cases we should not retry and just return
                // the error.
                //


                if (fSpecialLookup) {
                    //
                    // We should not retry in this case as we will not
                    // get anything useful. Setting fLookupOnServer
                    // to true will force this (if you look above this
                    // is not really needed but it helps clear things)
                    //
                    fLookupOnServer = TRUE;
                }
                else {
                    //
                    // This was not a special lookup, so we
                    // need to retry irrespective of what
                    // szLookupServer was.
                    //
                    fLookupOnServer = FALSE;
                    szLookupServer = NULL;
                }

            }

            //
            // This will do the correct thing even if the above
            // LookUpCall failed. If not we should go down this
            // as we can get stuck in an infinite loop.
            //
            if (FAILED(hr)
                && !pszServerName
                && !szLookupServer
                && !fLookupOnServer
                ) {
                //
                // In this case we want to try and call
                // DsGetDCName and hopefully we will get the right
                // DC. fSpecialLookup will be true so that we go to
                // the default DC for the machine/user.
                //
                fSpecialLookup = TRUE;
                goto retryForce;
            }
        }

        //
        // If failure was due to an expected error then retry
        //
        if (FAILED(hr)
            && hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)
            ) {
            if (!fForceVerify) {
                fForceVerify = TRUE;
                goto retryForce;
            }
        }

    }else {

        //
        // We know that LookupAccountName failed,
        // so now try the U2 DS
        //
        dwSidSize = 0;

        hr = ConvertU2TrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrTrustee,
                    Sid,
                    &dwSidSize
                    );
    }

    //
    // If neither the NTDS nor the U2 conversion
    // worked, then try a textual translation
    //

    if (FAILED(hr)) {

        hr = ConvertStringToSid(
                   bstrTrustee,
                    &pSid,
                    &dwSidSize,
                    &pszEnd
                    );
        BAIL_ON_FAILURE(hr);

        memcpy(Sid,pSid, dwSidSize);

        if (pSid) {
            FreeADsMem(pSid);
        }

    }

    //
    // On NT4 for some reason GetLengthSID does not set lasterror to 0
    //
    SetLastError(NO_ERROR);

    dwSidSize = GetLengthSid((PSID) Sid);

    dwErr = GetLastError();

    //
    // This is an extra check to make sure that we have the
    // correct length.
    //
    if (dwErr != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);   ;
    
    pSid = AllocADsMem(dwSidSize);
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    if (szUserDomainName) {
        FreeADsStr(szUserDomainName);
    };
    if (szUserAccountName) {
        FreeADsStr(szUserAccountName);
    }

    RRETURN(hr);
}


/*
+--------------------------------------------------------------------------------+

    NAME:       get_sid_out_of_string

    FUNCTION:   Convert a string representation of a SID back into
                a sid.  The expected format of the string is:
                L"S-1-5-32-549"

                If a string in a different format or an incorrect or
                incomplete string is given, the operation is failed.

                The returned sid must be free via a call to SEC_FREE.

    Arguments:

                string - The wide string to be converted

                sid - Where the created SID is to be returned

                end - Where in the string we stopped processing

    RETURN:

                NTSTATUS error codes or success.

+--------------------------------------------------------------------------------+
*/
HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    )
{
    HRESULT                     hr = S_OK;
    UCHAR                       revision;
    UCHAR                       sub_authority_count;
    SID_IDENTIFIER_AUTHORITY    authority;
    ULONG                       sub_authority[SID_MAX_SUB_AUTHORITIES];
    PWSTR                       end_list;
    PWSTR                       current;
    PWSTR                       next;
    ULONG                       x;

    *sid = NULL;

    if (((*string != L'S') && (*string != L's')) || (*(string + 1) != L'-'))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

    current = string + 2;

    revision = (UCHAR)wcstol(current, &end_list, 10);

    current = end_list + 1;

    //
    // Count the number of characters in the indentifer authority...
    //

    next = wcschr(current, L'-');
    if (!next) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);    
        BAIL_ON_FAILURE(hr);
    }

    if(next - current == 6)
    {
        for(x = 0; x < 6; x++)
        {
            authority.Value[x] = (UCHAR)next[x];
        }

        current +=6;
    }
    else
    {
         ULONG Auto = wcstoul(current, &end_list, 10);
         authority.Value[0] = authority.Value[1] = 0;
         authority.Value[5] = (UCHAR)Auto & 0xF;
         authority.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         authority.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         authority.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         current = end_list;
    }

    //
    // Now, count the number of sub auths
    //
    sub_authority_count = 0;
    next = current;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while(next)
    {
        next++;

        if(*next == L'-')
        {
            //
            // We've found one!
            //
            sub_authority_count++;
        }
        else if(*next == L';' || *next  == L'\0')
        {
            *end = next;
            sub_authority_count++;
            break;
        }
    }

    if(sub_authority_count != 0)
    {
        current++;

        for(x = 0; x < sub_authority_count; x++)
        {
            sub_authority[x] = wcstoul(current, &end_list, 10);
            current = end_list + 1;
        }
    }

    //
    // Now, create the SID
    //

    hr = SecCreateSidFromArray(
                    sid,
                    &authority,
                    sub_authority_count,
                    sub_authority,
                    pdwSidSize
                    );

    if (SUCCEEDED(hr))
    {
        /* Set the revision to what was specified in the string, in case, our
           system creates one with newer revision */

        ((SID *)(*sid))->Revision = revision;
    }

error:

    RRETURN(hr);
}


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    )
/*++

Routine Description:

    Creates a SID with desired authority and sub authorities.

    NOTE:  This routine allocates memory for the SID.  When finished
           the caller should free memory using SEC_FREE (PSid).

Arguments:

    PPSid -- addr of ptr to SID to be created
        Note: if SID creation fails ptr set to NULL

    PSidAuthority -- desired value for SID authority

    SubAuthorityCount -- number of sub authorities desired

    SubAuthorities -- sub-authority values, MUST SPECIFY contain
        at least SubAuthorityCount number of values

Return Value:

    STATUS_SUCCESS if SID created.
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    USHORT  iSub;           /*  sub-authority index */
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;

    /*  allocate memory for SID */

    dwSidSize = RtlLengthRequiredSid(SubAuthorityCount);
    *PPSid = (PSID) AllocADsMem( dwSidSize );
    if (! *PPSid){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    *pdwSidSize = dwSidSize;


    /*  initialize SID with top level SID identifier authority */
    RtlInitializeSid( *PPSid, PSidAuthority, SubAuthorityCount);

    /*  fill in sub authorities */
    for (iSub=0; iSub < SubAuthorityCount; iSub++)
        * RtlSubAuthoritySid( *PPSid, iSub) = SubAuthorities[iSub];

    /*  sanity check */

    if ( ! RtlValidSid( *PPSid) ) {
        FreeADsMem( *PPSid);
        *PPSid = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

error:


    RRETURN(hr);
}



BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {

#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
            ) == CSTR_EQUAL ) {
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\sql\sqlparse.cxx ===
/*

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sqlparse.cxx

Abstract:

Author:

    Felix Wong [t-FelixW]    16-Dec-1996

++*/
#include "lexer.hxx"
#include "sqltree.hxx"
#include "sqlparse.hxx"

//#define DEBUG_DUMPSTACK
//#define DEBUG_DUMPRULE

#if (defined(DEBUG_DUMPSTACK) || defined (DEBUG_DUMPRULE))
#include "stdio.h"
#endif

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

// Action Table
typedef struct _action{
    DWORD type;
    DWORD dwState;
}action;

// Rule Table
typedef struct _rule{
    DWORD dwNumber;
    DWORD dwA;
}rule;

enum types {
    N,
    S,
    R,
    A
    };

#define X 99

action g_action[59][28] = {
//       ERROR  ,EQ,    STAR,  LPARAN,RPARAN,INT,   REAL,  STR,   UDN,   COMMA, LT,    GT,    LE,    GE,    NE,    SELECT,ALL,   FROM,  WHERE, BOOL,  AND,   OR,    NOT,   ORDER  BY     ASC    DESC    END
/*00*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,3 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*01*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,49},{N,X },{N,X },{N,X },{A,X } },
/*02*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*03*/  { {N,X },{N,X },{S,4 },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,11},{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*04*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,6 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*05*/  { {N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,10},{R,10},{R,10},{R,10},{R,10},{R,10},{N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*06*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,4 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*07*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,7 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*08*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,8 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*09*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*10*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*11*/  { {N,X },{N,X },{S,4 },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*12*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*13*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*14*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{R,11} },
/*15*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,16},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,2 } },
/*16*/  { {N,X },{N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*17*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,3 },{N,X },{N,X },{N,X },{R,3 } },
/*18*/  { {N,X },{N,X },{N,X },{N,X },{R,12},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,26},{N,X },{R,12},{N,X },{N,X },{N,X },{R,12} },
/*19*/  { {N,X },{N,X },{N,X },{N,X },{R,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,28},{R,14},{N,X },{R,14},{N,X },{N,X },{N,X },{R,14} },
/*20*/  { {N,X },{N,X },{N,X },{N,X },{R,16},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,16},{R,16},{S,21},{R,16},{N,X },{N,X },{N,X },{R,16} },
/*21*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*22*/  { {N,X },{N,X },{N,X },{N,X },{R,18},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,18},{R,18},{N,X },{R,18},{N,X },{N,X },{N,X },{R,18} },
/*23*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*24*/  { {N,X },{S,38},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,34},{S,35},{S,37},{S,36},{S,39},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*25*/  { {N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,10},{R,10},{R,10},{R,10},{R,10},{R,10},{N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*26*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*27*/  { {N,X },{N,X },{N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{R,13} },
/*28*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*29*/  { {N,X },{N,X },{N,X },{N,X },{R,15},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,15},{N,X },{R,15},{N,X },{N,X },{N,X },{R,15} },
/*30*/  { {N,X },{N,X },{N,X },{N,X },{R,17},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,17},{R,17},{N,X },{R,17},{N,X },{N,X },{N,X },{R,17} },
/*31*/  { {N,X },{N,X },{N,X },{N,X },{S,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*32*/  { {N,X },{N,X },{N,X },{N,X },{R,19},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,19},{R,19},{N,X },{R,19},{N,X },{N,X },{N,X },{R,19} },
/*33*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{S,44},{S,45},{S,41},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,43},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*34*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,21},{R,21},{R,21},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,21},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*35*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,22},{R,22},{R,22},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,22},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*36*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,23},{R,23},{R,23},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,23},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*37*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,24},{R,24},{R,24},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,24},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*38*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,25},{R,25},{R,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*39*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,26},{R,26},{R,26},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,26},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*40*/  { {N,X },{N,X },{N,X },{N,X },{R,20},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,20},{R,20},{N,X },{R,20},{N,X },{N,X },{N,X },{R,20} },
/*41*/  { {N,X },{N,X },{N,X },{N,X },{R,27},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,27},{R,27},{N,X },{R,27},{N,X },{N,X },{N,X },{R,27} },
/*42*/  { {N,X },{N,X },{N,X },{N,X },{R,28},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,28},{R,28},{N,X },{R,28},{N,X },{N,X },{N,X },{R,28} },
/*43*/  { {N,X },{N,X },{N,X },{N,X },{R,29},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,29},{R,29},{N,X },{R,29},{N,X },{N,X },{N,X },{R,29} },
/*44*/  { {N,X },{N,X },{N,X },{N,X },{R,30},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,30},{R,30},{N,X },{R,30},{N,X },{N,X },{N,X },{R,30} },
/*45*/  { {N,X },{N,X },{N,X },{N,X },{R,31},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,31},{R,31},{N,X },{R,31},{N,X },{N,X },{N,X },{R,31} },
/*46*/  { {N,X },{N,X },{N,X },{N,X },{N,X}, {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X}  },
/*47*/  { {N,X },{R,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,32},{R,32},{R,32},{R,32},{R,32},{R,32},{N,X },{N,X },{R,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,32} },
/*48*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{A,X } },
/*49*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,50},{N,X },{N,X },{N,X } },
/*50*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,55},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*51*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,34} },
/*52*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,53},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,35} },
/*53*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,55},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*54*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,36} },
/*55*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,37},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,57},{S,58},{R,37} },
/*56*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,38},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,38} },
/*57*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,39},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,39} },
/*58*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,40},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,40} },
};

enum non_terminals {
    NONTERM_SEL_STMT,
    NONTERM_SEL_LIST_ALL,
    NONTERM_SEL_LIST,
    NONTERM_SEL_SUBLIST,
    NONTERM_COL_ID,
    NONTERM_TBL_ID,
    NONTERM_SRCH_COND,
    NONTERM_BOOL_TERM,
    NONTERM_BOOL_FACT,
    NONTERM_BOOL_PRIM,
    NONTERM_COMP,
    NONTERM_COMP_OP,
    NONTERM_LITERAL,
    NONTERM_NUM,
    NONTERM_STMT,
    NONTERM_ORDER_BY,
    NONTERM_SORT_SPEC_LIST,
    NONTERM_SORT_COL_ID,
    NONTERM_ORDER_SPEC
};


rule g_rule[] = {
//        1)No. of non-terminals and terminals on the right hand side
//        2)The Parent
/*00*/    {0, 0,                },
/*01*/    {1, NONTERM_STMT      },
/*02*/    {4, NONTERM_SEL_STMT  },
/*03*/    {6, NONTERM_SEL_STMT  },
/*04*/    {1, NONTERM_SEL_LIST_ALL    },
/*05*/    {2, NONTERM_SEL_LIST_ALL    },
/*06*/    {1, NONTERM_SEL_LIST   },
/*07*/    {1, NONTERM_SEL_LIST   },
/*08*/    {1, NONTERM_SEL_SUBLIST   },
/*09*/    {3, NONTERM_SEL_SUBLIST   },
/*10*/    {1, NONTERM_COL_ID    },
/*11*/    {1, NONTERM_TBL_ID   },
/*12*/    {1, NONTERM_SRCH_COND   },
/*13*/    {3, NONTERM_SRCH_COND   },
/*14*/    {1, NONTERM_BOOL_TERM,   },
/*15*/    {3, NONTERM_BOOL_TERM    },
/*16*/    {1, NONTERM_BOOL_FACT    },
/*17*/    {2, NONTERM_BOOL_FACT    },
/*18*/    {1, NONTERM_BOOL_PRIM   },
/*19*/    {3, NONTERM_BOOL_PRIM   },
/*20*/    {3, NONTERM_COMP },
/*21*/    {1, NONTERM_COMP_OP },
/*22*/    {1, NONTERM_COMP_OP },
/*23*/    {1, NONTERM_COMP_OP },
/*24*/    {1, NONTERM_COMP_OP },
/*25*/    {1, NONTERM_COMP_OP },
/*26*/    {1, NONTERM_COMP_OP },
/*27*/    {1, NONTERM_LITERAL  },
/*28*/    {1, NONTERM_LITERAL   },
/*29*/    {1, NONTERM_LITERAL   },
/*30*/    {1, NONTERM_NUM   },
/*31*/    {1, NONTERM_NUM   },
/*32*/    {1, NONTERM_COL_ID    },
/*33*/    {2, NONTERM_STMT    },
/*34*/    {3, NONTERM_ORDER_BY    },
/*35*/    {1, NONTERM_SORT_SPEC_LIST    },
/*36*/    {3, NONTERM_SORT_SPEC_LIST    },
/*37*/    {1, NONTERM_SORT_COL_ID    },
/*38*/    {2, NONTERM_SORT_COL_ID    },
/*39*/    {1, NONTERM_ORDER_SPEC    },
/*40*/    {1, NONTERM_ORDER_SPEC    },
};

#ifdef DEBUG_DUMPRULE
LPWSTR g_rgszRule[] = {
/*00*/      L"",
/*01*/      L"stmt -> sel_stmt",
/*02*/      L"sel_stmt -> T_SELECT sel_list_all T_FROM tbl_id",
/*03*/      L"sel_stmt -> T_SELECT sel_list_all T_FROM tbl_id T_WHERE srch_cond",
/*04*/      L"sel_list_all -> sel_list",
/*05*/      L"sel_list_all -> T_ALL sel_list",
/*06*/      L"sel_list -> T_STAR",
/*07*/      L" sel_list -> sel_sublist",
/*08*/      L" sel_sublist -> col_id",
/*09*/      L" sel_sublist -> col_id T_COMMA sel_sublist",
/*10*/      L" col_id -> T_UD_NAME",
/*11*/      L" tbl_id -> T_STRING",
/*12*/      L" srch_cond -> bool_term",
/*13*/      L" srch_cond -> bool_term T_OR srch_cond",
/*14*/      L" bool_term -> bool_fact",
/*15*/      L" bool_term -> bool_fact T_AND bool_term",
/*16*/      L" bool_fact -> bool_prim",
/*17*/      L" bool_fact -> T_NOT bool_prim",
/*18*/      L" bool_prim -> comp",
/*19*/      L" bool_prim -> T_LPARAN srch_cond T_RPARAN",
/*20*/      L" comp -> col_id comp_op literal",
/*21*/      L" comp_op -> T_LT",
/*22*/      L" comp_op -> T_GT",
/*23*/      L" comp_op -> T_GE",
/*24*/      L" comp_op -> T_LE",
/*25*/      L" comp_op -> T_EQ",
/*26*/      L" comp_op -> T_NE",
/*27*/      L" literal -> T_STRING",
/*28*/      L" literal -> num",
/*29*/      L" literal -> T_BOOL",
/*30*/      L" num -> T_INT",
/*31*/      L" num -> T_REAL",
/*32*/      L" col_id -> T_STRING",
/*33*/      L" stmt -> sel_stmt order_by_clause",
/*34*/      L" order_by_clause ::= T_ORDER T_BY sort_spec_list",
/*35*/      L" sort_spec_list ::= sort_col_id",
/*36*/      L" sort_spec_list ::= sort_col_id T_COMMA sort_spec_list",
/*37*/      L" sort_col_id ::= T_UD_NAME",
/*38*/      L" sort_col_id ::= T_UD_NAME order_spec",
/*39*/      L" order_spec ::= T_ASC",
/*40*/      L" order_spec ::= T_DESC"
};
#endif

DWORD g_goto[59][19] = {
//         Sel  sel  sel  sel  col  tbl  srch bool bool bool comp comp lit  num stmt  order sort  sort  order
//         stmt,lsta,lst, sub, id,  id,  cond,trm, fact,prim,    ,op,     ,    ,      by,   spec, col , spec ,
/*00*/    {1,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   2,    X,    X,    X,    X,   },
/*01*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    48,   X,    X,    X,   },
/*02*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*03*/    {X,   12,  6,   7,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*04*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*05*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*06*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*07*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*08*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*09*/    {X,   X,   X,  10,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*10*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*11*/    {X,   X,  46,   7,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*12*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*13*/    {X,   X,   X,   X,   X,  15,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*14*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*15*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*16*/    {X,   X,   X,   X,  24,   X,  17,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*17*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*18*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*19*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*20*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*21*/    {X,   X,   X,   X,  24,   X,   X,   X,   X,  30,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*22*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*23*/    {X,   X,   X,   X,  24,   X,  31,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*24*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,  33,   X,   X,   X,    X,    X,    X,    X,   },
/*25*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*26*/    {X,   X,   X,   X,  24,   X,  27,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*27*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*28*/    {X,   X,   X,   X,  24,   X,   X,  29,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*29*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*30*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*31*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*32*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*33*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,  40,  42,   X,    X,    X,    X,    X,   },
/*34*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*35*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*36*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*37*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*38*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*39*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*40*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*41*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*42*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*43*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*44*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*45*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*46*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*47*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*48*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*49*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*50*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    51,   52,   X,   },
/*51*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*52*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*53*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    54,   52,   X,   },
/*54*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*55*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    56,  },
/*56*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*57*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*58*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
};

HRESULT SQLParse(
          LPWSTR szQuery,
          LPWSTR *ppszLocation,
          LPWSTR *ppszLDAPQuery,
          LPWSTR *ppszSelect,
          LPWSTR *ppszOrderList
          )
{
    //
    // check input parameters
    //
    if (!ppszLocation || !ppszLDAPQuery || !ppszSelect || !ppszOrderList) {
        return (E_INVALIDARG);
    }
    *ppszLocation = *ppszLDAPQuery = *ppszSelect = *ppszOrderList = NULL;

    CStack Stack;
    CLexer Query(szQuery);
    LPWSTR lexeme;
    DWORD dwToken;
    DWORD dwState;
    HRESULT hr = E_ADS_INVALID_FILTER;

    CSyntaxNode *pSynNode;
    CSQLNode *pNode1 = NULL;
    CSQLNode *pNode2 = NULL;
    CSQLNode *pNode3 = NULL;
    CSQLString *pString = NULL, *pOrderString = NULL;

    // Push in State 0
    pSynNode = new CSyntaxNode;
    if (!pSynNode) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    Stack.Push(pSynNode);
    pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
    Stack.Dump();
#endif

    while (1) {
        // Getting information for this iteration, dwToken and dwState
        hr = Query.GetCurrentToken(
                                &lexeme,
                                &dwToken
                                );
        BAIL_ON_FAILURE(hr);

        hr = Stack.Current(&pSynNode);
        BAIL_ON_FAILURE(hr);

        dwState = pSynNode->_dwState;
        pSynNode = NULL;

        // Analysing and processing the data
        if (g_action[dwState][dwToken].type == S) {
            pSynNode = new CSyntaxNode;
            if (!pSynNode) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            pSynNode->_dwState = g_action[dwState][dwToken].dwState;
            pSynNode->_dwToken = dwToken;
            switch (dwToken) {
                case TOKEN_STRING_LITERAL:
                case TOKEN_USER_DEFINED_NAME:
                case TOKEN_INTEGER_LITERAL:
                case TOKEN_REAL_LITERAL:
                case TOKEN_BOOLEAN_LITERAL:
                case TOKEN_ASC:
                case TOKEN_DESC:
                {
                    LPWSTR szValue = AllocADsStr(lexeme);
                    if (!szValue) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    pSynNode->SetNode(szValue);
                    break;
                }
            }
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

            hr = Query.GetNextToken(
                               &lexeme,
                               &dwToken
                               );
            BAIL_ON_FAILURE(hr);
#ifdef DUMP
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == R) {
            DWORD dwRule = g_action[dwState][dwToken].dwState;
            DWORD dwNumber = g_rule[dwRule].dwNumber;
#ifdef DEBUG_DUMPRULE
            wprintf(L"%s\n",g_rgszRule[dwRule]);
#endif
            pSynNode = new CSyntaxNode;
            CSyntaxNode *pSynNodeRed, *pSynNodeRed2;
            switch (dwRule) {
                case 20:
                {
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = MakeLeaf(
                               pSynNodeRed->_szValue,
                               &pNode2
                               );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwFilterType;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = MakeLeaf(
                               pSynNodeRed->_szValue,
                               &pNode1
                               );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                        // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;
                    break;
                }
                case 13:
                case 15:
                    // Reduction of AND OR
                {
                    CSQLNode *pNode1;
                    CSQLNode *pNode2;
                    CSQLNode *pNode3;
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode2 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwToken;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                        // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;
                    break;
                }

                case 17:    // Reduction of NOT
                {
                    CSQLNode *pNode1;
                    CSQLNode *pNode2;
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwToken;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    break;
                }
                case 3:
                    // save entry
                {
                    CSQLNode* pNode;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    for (DWORD i = 0;i<dwNumber-1;i++)
                        Stack.Pop();

                    CSQLString *pString = new CSQLString;
                    if (!pString) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    hr = pNode->GenerateLDAPString(
                                          pString
                                          );
                    BAIL_ON_FAILURE(hr);
                    delete pNode;

                    *ppszLDAPQuery = AllocADsStr(pString->_szString);
                    delete pString;
                    if (!*ppszLDAPQuery) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    break;
                }
                case 11:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    *ppszLocation = AllocADsStr(pSynNodeRed->_szValue);
                    delete pSynNodeRed;
                    break;
                }
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_dwToken
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 12:
                case 14:
                case 16:
                case 18:
                {
                    // we propogate the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pSQLNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 10:
                case 27:
                case 29:
                case 30:
                case 31:
                case 28:
                                    case 32:
                case 37:
                case 39:
                case 40:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_szValue
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 19:
                {
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pSQLNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    break;
                }
                case 8:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pString = new CSQLString;
                    BAIL_ON_FAILURE(
                        hr = pString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 9:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    BAIL_ON_FAILURE(
                        hr = pString->Append(L","));
                    BAIL_ON_FAILURE(
                        hr = pString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 35:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pOrderString = new CSQLString;
                    BAIL_ON_FAILURE(
                        hr = pOrderString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 36:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pOrderString->AppendAtBegin(L",");
                    pOrderString->AppendAtBegin(pSynNodeRed->_szValue);
                    delete pSynNodeRed;
                    break;
                }
                case 38:
                {
                    CSQLNode *pNode;
                    LPWSTR pTemp = NULL;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed2);
                    BAIL_ON_FAILURE(hr);
                    pTemp = (LPWSTR) AllocADsMem((wcslen(pSynNodeRed2->_szValue) +
                                        wcslen(pSynNodeRed->_szValue) +
                                        wcslen(L" ") + 1) * sizeof(WCHAR));
                    if (!pTemp) {
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    }

                    wsprintf(pTemp, L"%s %s",
                             pSynNodeRed2->_szValue,
                             pSynNodeRed->_szValue);

                    pSynNode->SetNode( pTemp );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    pSynNodeRed2->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    delete pSynNodeRed2;
                    break;
                }
                default:
                {
                    for (DWORD i = 0;i<dwNumber;i++)
                        Stack.Pop();
                    break;
                }
            }
            hr = Stack.Current(&pSynNodeRed);
            BAIL_ON_FAILURE(hr);

            dwState = pSynNodeRed->_dwState;

            DWORD A = g_rule[dwRule].dwA;
            pSynNode->_dwState = g_goto[dwState][A];
            pSynNode->_dwToken = A;
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == A){
            if (pString == NULL) {
                *ppszSelect = AllocADsStr(L"*");
            }
            else {
                *ppszSelect = AllocADsStr(pString->_szString);
            }
            if (!*ppszSelect) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            delete pString;

            if (pOrderString) {

                *ppszOrderList = AllocADsStr(pOrderString->_szString);
                if (!*ppszOrderList) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                delete pOrderString;
            }
            return S_OK;
        }
        else {
            hr = E_ADS_INVALID_FILTER;
            goto error;
        }
    }
error:
    if (pSynNode)
        delete pSynNode;
    if (pNode1)
        delete pNode1;
    if (pNode2)
        delete pNode2;
    if (pNode3)
        delete pNode3;
    if (pString)
        delete pString;
    if (pOrderString)
        delete pOrderString;
    if (*ppszSelect)
    {
        FreeADsMem(*ppszSelect);
        *ppszSelect = NULL;
    }
    if (*ppszLocation)
    {
        FreeADsMem(*ppszLocation);
        *ppszLocation = NULL;
    }
    if (*ppszLDAPQuery)
    {
        FreeADsMem(*ppszLDAPQuery);
        *ppszLDAPQuery = NULL;
    }
    if (*ppszOrderList)
    {
        FreeADsMem(*ppszOrderList);
        *ppszOrderList = NULL;
    }
    return hr;
}


CStack::CStack()
{
    _dwStackIndex = 0;
}

CStack::~CStack()
{
    DWORD dwIndex = _dwStackIndex;
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        delete pNode;
    }
}

#ifdef DEBUG_DUMPSTACK
void CStack::Dump()
{
    DWORD dwIndex = _dwStackIndex;
    printf("Stack:\n");
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        printf(
           "State=%5.0d, Token=%5.0d\n",
           pNode->_dwState,
           pNode->_dwToken
           );
    }
}
#endif

HRESULT CStack::Push(CSyntaxNode* pNode)
{
    if (_dwStackIndex < MAXVAL) {
        _Stack[_dwStackIndex++] = pNode;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CStack::Pop(CSyntaxNode** ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[--_dwStackIndex];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Pop()
{
    if (_dwStackIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--_dwStackIndex];
        delete pNode;
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Current(CSyntaxNode **ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[_dwStackIndex-1];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}


CSyntaxNode::CSyntaxNode()
{
    _dwType = SNODE_NULL;
    _dwToken = 0;
    _dwState = 0;
    _pSQLNode = 0;
}

CSyntaxNode::~CSyntaxNode()
{
    switch (_dwType) {
        case SNODE_SZ:
            FreeADsStr(_szValue);
            break;
        case SNODE_SQLNODE:
            delete _pSQLNode;
            break;
        default:
            break;
    }
}


void CSyntaxNode::SetNode(
                    CSQLNode *pSQLNode
                    )
{
    _pSQLNode = pSQLNode;
    _dwType = SNODE_SQLNODE;
}

void CSyntaxNode::SetNode(
                     LPWSTR szValue
                     )
{
    _szValue = szValue;
    _dwType = SNODE_SZ;
}

void CSyntaxNode::SetNode(
                    DWORD dwFilterType
                    )
{
    _dwFilterType = dwFilterType;
    _dwType = SNODE_FILTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\router\sql\sqltree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       SqlTree.cxx
//
//  Contents:   Implementation of the SQL Query Tree to convert SQL queries
//              to LDAP queries
//
//  Functions:
//
//  History:    12-Dec-96   Felix Wong  Created.
//
//----------------------------------------------------------------------------
#include "lexer.hxx"
#include "sqltree.hxx"
#include "sqlparse.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::CSQLNode
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::CSQLNode()
{
    _dwType = 0;
    _szValue = NULL;
    _pLQueryNode = NULL;
    _pRQueryNode = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::CSQLNode
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments:  dwType          type of node
//              pLQueryNode     pointer to left node
//              pRQueryNode     pointer to right node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::CSQLNode(
    DWORD dwType,
    CSQLNode *pLQueryNode,
    CSQLNode *pRQueryNode
    )
{
    _dwType = dwType;
    _pLQueryNode = pLQueryNode;
    _pRQueryNode = pRQueryNode;
}

//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::SetToString
//
//  Synopsis:  Set the Node to be a String Node
//
//  Arguments: szValue      value of the string
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CSQLNode::SetToString(
    LPWSTR szValue
    )
{
    _szValue = szValue;
    _dwType = QUERY_STRING;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::~CSQLNode
//
//  Synopsis:  Destructor of the CSQLNode
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::~CSQLNode()
{
    if ((_dwType == QUERY_STRING) && _szValue) {
        FreeADsStr(_szValue);
    }
    
    if (_pLQueryNode) {
        delete _pLQueryNode;
    }
    
    if (_pRQueryNode) {
        delete _pRQueryNode;
    }
}



// Helper Functions for creating nodes using the CSQLNode Class

//+---------------------------------------------------------------------------
//
//  Function:  MakeNode
//
//  Synopsis:  Make a node with the input values
//
//  Arguments:  dwType              type of node
//              pLQueryNode         pointer to left node
//              pRQueryNode         pointer to right node
//              ppQueryNodeReturn   pointer to Return Node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeNode(
    DWORD dwType,
    CSQLNode *pLQueryNode,
    CSQLNode *pRQueryNode,
    CSQLNode **ppQueryNodeReturn
    )
{
    CSQLNode *pQueryNode = new CSQLNode(
                                      dwType,
                                      pLQueryNode,
                                      pRQueryNode
                                      );
    if (!pQueryNode)
        return E_OUTOFMEMORY;
    *ppQueryNodeReturn = pQueryNode;
    return S_OK;
}
    
//+---------------------------------------------------------------------------
//
//  Function:  MakeLeaf
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments: szValue              value of the string
//             ppQueryNodeReturn    the return node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeLeaf(
    LPWSTR szValue,
    CSQLNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CSQLNode *pQueryNode = new CSQLNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;
        
    hr = pQueryNode->SetToString(szValue);
    BAIL_ON_FAILURE(hr);
    
    *ppQueryNodeReturn = pQueryNode;
    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}

typedef struct _TOKEN_TO_STRING {
    DWORD dwToken;
    LPWSTR szToken;
} TOKEN_TO_STRING, *LPTOKEN_TO_STRING;

TOKEN_TO_STRING SqlTokenMap[] = 
{
    { TOKEN_EQ,       L"="},
    { TOKEN_LT,       L"<="},
    { TOKEN_GT,       L">="},
    { TOKEN_LE,       L"<="},
    { TOKEN_GE,       L">="},
    { TOKEN_AND,      L"&"},
    { TOKEN_OR,       L"|"},
    { TOKEN_NOT,      L"!"},
    { 0,                0}
};

HRESULT CSQLNode::MapTokenToChar(DWORD dwToken, LPWSTR *pszToken)
{
    LPTOKEN_TO_STRING pTokenMap ;

    pTokenMap = SqlTokenMap; 

    while (pTokenMap->dwToken)
    {
        if (pTokenMap->dwToken == dwToken) {
            *pszToken = pTokenMap->szToken ;
            return S_OK;
        }
        pTokenMap++ ;
    }
    return E_FAIL;
}

HRESULT CSQLNode::GenerateLDAPString(CSQLString* pString)
{
    HRESULT hr = S_OK;

    switch (_dwType) {
        case QUERY_STRING:
            BAIL_ON_FAILURE(hr = pString->Append(_szValue));
            break;
        case TOKEN_EQ:
        case TOKEN_LE:
        case TOKEN_GE:
            {
            BAIL_ON_FAILURE(hr = pString->Append(L"("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            LPWSTR szToken;
            MapTokenToChar(
                       _dwType,
                       &szToken
                       );
            BAIL_ON_FAILURE(hr = pString->Append(szToken));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")"));
            break;
            }
    case TOKEN_LT:
    case TOKEN_GT:
        {
            BAIL_ON_FAILURE(hr = pString->Append(L"(&("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            LPWSTR szToken;
            MapTokenToChar(
                       _dwType,
                       &szToken
                       );
            BAIL_ON_FAILURE(hr = pString->Append(szToken));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")(!("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"="));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")))"));
        break;
        }
    case TOKEN_NE:
        {
            BAIL_ON_FAILURE(hr = pString->Append(L"(!("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"="));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"))"));
        }
        break;
    case TOKEN_NOT:
    {    
        BAIL_ON_FAILURE(hr = pString->Append(L"(!"));
        BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = pString->Append(L")"));
        break;
        }
    case TOKEN_AND:
    case TOKEN_OR:
        {
        BAIL_ON_FAILURE(hr = pString->Append(L"("));
        LPWSTR szToken;
        MapTokenToChar(
                   _dwType,
                   &szToken
                   );
        BAIL_ON_FAILURE(hr = pString->Append(szToken));
        BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = pString->Append(L")"));
        break;
        }
    default:
        return E_FAIL;
    }
    return S_OK;

error:

    return hr;
}

#define SQLSTR_INC 255

CSQLString::CSQLString()
{
    _dwSizeMax = SQLSTR_INC;
    _szString = (LPWSTR)AllocADsMem(sizeof(WCHAR)*SQLSTR_INC);
    _dwSize = 0;
}

CSQLString::~CSQLString()
{
    FreeADsMem((void*)_szString);
}

HRESULT CSQLString::Append(LPWSTR szAppend)
{
    DWORD dwAppendSize = wcslen(szAppend);
    DWORD dwSizeCurrent = _dwSize + dwAppendSize + 1;

    if (dwSizeCurrent <= _dwSizeMax) {
        wcscat(
            _szString,
            szAppend
            );
        _dwSize +=dwAppendSize;
    }
    else {
        DWORD dwNewSizeMax = _dwSizeMax + SQLSTR_INC;
        while (dwSizeCurrent > dwNewSizeMax) {
            dwNewSizeMax += SQLSTR_INC;
        }
        _szString = (LPWSTR)ReallocADsMem(
                                         (void*)_szString,
                                         _dwSizeMax*sizeof(WCHAR),
                                         dwNewSizeMax*sizeof(WCHAR)
                                         );
        if (!_szString) {
            return E_OUTOFMEMORY;
        }
        wcscat(
            _szString,
            szAppend
            );
        _dwSizeMax = dwNewSizeMax;
        _dwSize +=dwAppendSize;
    }
    return S_OK;
}


HRESULT CSQLString::AppendAtBegin(LPWSTR szAppend)
{

    DWORD dwAppendSize = wcslen(szAppend);
    DWORD dwSizeCurrent = _dwSize + dwAppendSize + 1;
    DWORD i = 0;

    //
    // Explicitly  move the original string and copy the new string to the
    // beginning

    if (dwSizeCurrent <= _dwSizeMax) {

        for (i=dwSizeCurrent - 1; i > dwAppendSize - 1; i--) {
            _szString[i] = _szString[i-dwAppendSize];
        }

        wcsncpy(
            _szString,
            szAppend,
            dwAppendSize
            );
        _dwSize +=dwAppendSize;
    }
    else {
        DWORD dwNewSizeMax = _dwSizeMax + SQLSTR_INC;
        while (dwSizeCurrent > dwNewSizeMax) {
            dwNewSizeMax += SQLSTR_INC;
        }
        _szString = (LPWSTR)ReallocADsMem(
                                         (void*)_szString,
                                         _dwSizeMax*sizeof(WCHAR),
                                         dwNewSizeMax*sizeof(WCHAR)
                                         );
        if (!_szString) {
            return E_OUTOFMEMORY;
        }


        //
        // Explicitly  move the original string and copy the new string to the
        // beginning
    
        for (i=dwSizeCurrent - 1; i > dwAppendSize - 1; i--) {
            _szString[i] = _szString[i-dwAppendSize];
        }

        wcsncpy(
            _szString,
            szAppend,
            dwAppendSize
            );
        _dwSize +=dwAppendSize;

        _dwSizeMax = dwNewSizeMax;
        _dwSize +=dwAppendSize;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\types\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include "adstype.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//              multiple IDispatch-callable interfaces.
//
//  Classes:    CDispatchMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//              07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "procs.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//
#define BAIL_ON_FAILURE(hr) if (FAILED(hr)) { goto cleanup; }

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//              not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[199];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   do {} while(0)
# define DispMgrAssert(x)  do {} while(0)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
        *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
        DispId < 0 || DispId >= 0x10000)
    {
        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else
        *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        if (rgdispid[i] == DISPID_UNKNOWN)
            continue;

        //
        // This is either a stack of DispMgrs >127 high, or
        // a programming error.  More likely the latter.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        //
        // It should never be less than zero, and the only place
        // this is called from guarantees it is not zero.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct defs
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_DispTypeInfoCritSect;

#define ENTER_DISP_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_DispTypeInfoCritSect)
#define LEAVE_DISP_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_DispTypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;
LONG glnOledbObjCnt = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CDispatchMgr::CDispatchMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _pDispatch = NULL;
}

CDispatchMgr::~CDispatchMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_DISP_TYPEINFO_CRITSECT();
    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (_pDispatch)
        _pDispatch->Release();
}

void
CDispatchMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}

void
CDispatchMgr::RegisterBaseDispatchPtr(IDispatch *pDispatch)
{
    _pDispatch = pDispatch;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                    (PDWORD)(rgdispid + dw)))) {
                hr = DISP_E_UNKNOWNNAME;
                rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    //
    // Try our "base class" dispatch pointer.
    //
    if (FAILED(hr) && _pDispatch) {
        hr = _pDispatch->GetIDsOfNames(iid, rgszNames, cNames, lcid, rgdispid);

        if (SUCCEEDED(hr)) {
            IncDispMgrIds(rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CDispatchMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CDispatchMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CDispatchMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CDispatchMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

cleanup:
    return hr;
}

STDMETHODIMP
CDispatchMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
            // One of the special DISPIDs.
            //
            // If we have an interface pointer for it, use that.
            // If we don't, and we have a base IDispatch pointer,
            //   pass it to the base pointer's Invoke() method.
            // If we don't, and we don't have a base IDispatch pointer,
            //   return failure.
            //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
            break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

            if (!pInterfacePtr) {
            if (_pDispatch) {
                    return _pDispatch->Invoke(dispidMember, iid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);
                } else {
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
                }
            }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else if (getDispMgrId(dispidMember)) {

            //
            // A regular DISPID of a "base class" dispatch manager.
            //

            if (!_pDispatch){

                char szMessage[80];
                sprintf(szMessage, "_pDispatch is NULL, dispid = 0x%08x",
                        dispidMember);
                 AssertEx(__FILE__, __LINE__, szMessage);
                return DISP_E_MEMBERNOTFOUND;
            }

            DecDispMgrIds(&dispidMember, 1);

            hr = _pDispatch->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                        pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        return(hr);

    } else {

        //
            // A regular DISPID of ours.
            //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

            if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
                pInterfacePtr = getInterfacePtr(typeinfoid);
                pTypeInfo = getTypeInfo(typeinfoid);
                if (!pTypeInfo)
                        //
                    // Shouldn't happen.
                    //
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
            }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

cleanup:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

cleanup:
    return(hr);

}


HRESULT
CDispatchMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CDispatchMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CDispatchMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CDispatchMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_DISP_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_DISP_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_DISP_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {

                LEAVE_DISP_TYPEINFO_CRITSECT();
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);
    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_DISP_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

cleanup:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CDispatchMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
DllReadyToUnload()
{
    BOOL retVal = FALSE;

    ENTER_DISP_TYPEINFO_CRITSECT();
        retVal = ((glnTypesOfInfo == 0) && (glnOledbObjCnt == 0));
    LEAVE_DISP_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\types\header.h ===
#define OLEDS_LIBIID_ADs                          97d25db0-0363-11cf-abc4-02608c9e7553

#define OLEDS_IID_IADs                            fd8256d0-fd15-11ce-abc4-02608c9e7553
#define OLEDS_IID_IADsContainer                   001677d0-fd16-11ce-abc4-02608c9e7553

#define OLEDS_IID_IADsClass                       c8f93dd0-4ae0-11cf-9e73-00aa004a5691
#define OLEDS_IID_IADsProperty                    c8f93dd3-4ae0-11cf-9e73-00aa004a5691
#define OLEDS_IID_IADsSyntax                      c8f93dd2-4ae0-11cf-9e73-00aa004a5691

#define OLEDS_IID_IADsCollection                  72b945e0-253b-11cf-a988-00aa006bc149
#define OLEDS_IID_IADsMembers                     451a0030-72ec-11cf-b03b-00aa006e0975

#define OLEDS_IID_IADsNamespaces                  28b96ba0-b330-11cf-a9ad-00aa006bc149

#define OLEDS_IID_IADsDomain                      00e4c220-fd16-11ce-abc4-02608c9e7553

#define OLEDS_IID_IADsLocality                    a05e03a2-effe-11cf-8abc-00c04fd8d503
#define OLEDS_IID_IADsO                           a1cd2dc6-effe-11cf-8abc-00c04fd8d503
#define OLEDS_IID_IADsOU                          a2f733b8-effe-11cf-8abc-00c04fd8d503

#define OLEDS_IID_IADsComputer                    efe3cc70-1d9f-11cf-b1f3-02608c9e7553
#define OLEDS_IID_IADsComputerOperations          ef497680-1d9f-11cf-b1f3-02608c9e7553

#define OLEDS_IID_IADsGroup                       27636b00-410f-11cf-b1ff-02608c9e7553
#define OLEDS_IID_IADsGroupOperations             257760a0-410f-11cf-b1ff-02608c9e7553

#define OLEDS_IID_IADsUser                        3e37e320-17e2-11cf-abc4-02608c9e7553

#define OLEDS_IID_IADsPrintQueue                  b15160d0-1226-11cf-a985-00aa006bc149
#define OLEDS_IID_IADsPrintQueueOperations        124be5c0-156e-11cf-a986-00aa006bc149

#define OLEDS_IID_IADsPrintJob                    32fb6780-1ed0-11cf-a988-00aa006bc149
#define OLEDS_IID_IADsPrintJobOperations          9a52db30-1ecf-11cf-a988-00aa006bc149

#define OLEDS_IID_IADsService                     68af66e0-31ca-11cf-a98a-00aa006bc149
#define OLEDS_IID_IADsServiceOperations           5d7b33f0-31ca-11cf-a98a-00aa006bc149

#define OLEDS_IID_IADsFileService                 a89d1900-31ca-11cf-a98a-00aa006bc149
#define OLEDS_IID_IADsFileServiceOperations       a02ded10-31ca-11cf-a98a-00aa006bc149

#define OLEDS_IID_IADsFileShare                   eb6dcaf0-4b83-11cf-a995-00aa006bc149
#define OLEDS_IID_IADsSession                     398b7da0-4aab-11cf-ae2c-00aa006ebfb9
#define OLEDS_IID_IADsResource                    34a05b20-4aab-11cf-ae2c-00aa006ebfb9

#define OLEDS_IID_IADsOpenDSObject                ddf2891e-0f9c-11d0-8ad4-00c04fd8d503

#define OLEDS_IID_IADsSearch                      C69F7780-4008-11D0-B94C-00C04FD8D5A8

#define OLEDS_IID_IDirectoryObject                e798de2c-22e4-11d0-84fe-00c04fd8d503

#define OLEDS_IID_IDirectorySearch                109ba8ec-92f0-11d0-a790-00c04fd8d5a8

#define OLEDS_IID_IDirectorySchemaMgmt            75db3b9c-a4d8-11d0-a79c-00c04fd8d5a8

#define OLEDS_IID_IADsPropertyList                c6f602b6-8f69-11d0-8528-00c04fd8d503

#define OLEDS_IID_IADsAggregatee                  1346ce8c-9039-11d0-8528-00c04fd8d503

#define OLEDS_IID_IADsAggregator                  52db5fb0-941f-11d0-8529-00c04fd8d503

#define OLEDS_IID_IADsPropertyEntry               05792c8e-941f-11d0-8529-00c04fd8d503
#define OLEDS_CLSID_PropertyEntry                 72d3edc2-a4c4-11d0-8533-00c04fd8d503

#define OLEDS_IID_IADsAttrInfo                    af1206f6-aef7-11d0-8537-00c04fd8d503

#define OLEDS_IID_IADsPropertyValue               79fa9ad0-a97c-11d0-8534-00c04fd8d503
#define OLEDS_CLSID_PropertyValue                 7b9e38b0-a97c-11d0-8534-00c04fd8d503

#define OLEDS_IID_IADsPropertyValue2              306e831c-5bc7-11d1-a3b8-00c04fb950dc

#define OLEDS_IID_IADsValue                       1e3ef0aa-aef5-11d0-8537-00c04fd8d503

#define OLEDS_IID_IADsAccessControlEntry          b4f3a14c-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_AccessControlEntry            b75ac000-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsAccessControlList           b7ee91cc-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_AccessControlList             b85ea052-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsSecurityDescriptor          b8c787ca-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_SecurityDescriptor            b958f73c-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsPathname                    d592aed4-f420-11d0-a36e-00c04fb950dc
#define OLEDS_CLSID_Pathname                      080d0d78-f421-11d0-a36e-00c04fb950dc
#define OLEDS_IID_IADsPathnameProvider            aacd1d30-8bd0-11d2-92a9-00c04f79f834
#define OLEDS_IID_IADsNameTranslate               b1b272a3-3625-11d1-a3a4-00c04fb950dc
#define OLEDS_CLSID_NameTranslate                 274fae1f-3626-11d1-a3a4-00c04fb950dc
#define OLEDS_CLSID_CaseIgnoreList                15f88a55-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsCaseIgnoreList              7b66b533-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_FaxNumber                     a5062215-4681-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsFaxNumber                   a910dea9-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_NetAddress                    b0b71247-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsNetAddress                  b21a50a9-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_OctetList                     1241400f-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsOctetList                   7b28b80f-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_Email                         8f92a857-478e-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsEmail                       97af011a-478e-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_Path                          b2538919-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsPath                        b287fcd5-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_ReplicaPointer                f5d1badf-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsReplicaPointer              f60fb803-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsAcl                         8452d3ab-0869-11d1-a377-00c04fb950dc
#define OLEDS_CLSID_Timestamp                     b2bed2eb-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsTimestamp                   b2f5a901-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_PostalAddress                 0a75afcd-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsPostalAddress               7adecf29-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_BackLink                      fcbf906f-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsBackLink                    fd1302bd-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_TypedName                     b33143cb-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsTypedName                   b371a349-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_Hold                          b3ad3e13-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsHold                        b3eb3b37-4080-11d1-a3ac-00c04fb950dc

#define OLEDS_CLSID_ADSystemInfo                  50B6327F-AFD1-11d2-9CB9-0000F87A369E
#define OLEDS_IID_IADsADSystemInfo                5BB11929-AFD1-11d2-9CB9-0000F87A369E

#define OLEDS_CLSID_WinNTSystemInfo               66182EC4-AFD1-11d2-9CB9-0000F87A369E
#define OLEDS_IID_IADsWinNTSystemInfo             6C6D65DC-AFD1-11d2-9CB9-0000F87A369E

#define OLEDS_IID_IADsLargeInteger                9068270b-0939-11d1-8be1-00c04fd8d503
#define OLEDS_CLSID_LargeInteger                  927971f5-0939-11d1-8be1-00c04fd8d503

#define OLEDS_IID_IADsDNWithString                370df02e-f934-11d2-ba96-00c04fb6d0d1
#define OLEDS_CLSID_DNWithString                  334857cc-f934-11d2-ba96-00c04fb6d0d1

#define OLEDS_IID_IADsDNWithBinary                7e99c0a2-f935-11d2-ba96-00c04fb6d0d1
#define OLEDS_CLSID_DNWithBinary                  7e99c0a3-f935-11d2-ba96-00c04fb6d0d1

#define OLEDS_IID_IADsObjectOptions               46f14fda-232b-11d1-a808-00c04fd8d5a8

#define OLEDS_IID_IADsObjOptPrivate               81cbb829-1867-11d2-9220-00c04fb6d0d1

#define OLEDS_IID_IPrivateDispatch                86ab4bbe-65f6-11d1-8c13-00c04fd8d503

#define OLEDS_IID_IPrivateUnknown                 89126bab-6ead-11d1-8c18-00c04fd8d503

#define OLEDS_IID_IADsExtension                   3d35553c-d2b0-11d1-b17b-0000f87593a0

#define OLEDS_IID_IADsDeleteOps                   b2bd0902-8878-11d1-8c21-00c04fd8d503

#define OLEDS_IID_IADsUmiHelperPrivate            4fe243f0-ad89-4cbc-9b14-486126446ae0

#define OLEDS_IID_IUmiADSIPrivate                 8f3bb40b-d4ad-4648-ae4a-6efa197a1656

#define OLEDS_IID_IADsAcePrivate                  fd145df2-fd96-4135-9b22-68ff0f6bf5bb

#define OLEDS_CLSID_ADsSecurityUtility            f270c64a-ffb8-4ae4-85fe-3a75e5347966
#define OLEDS_IID_IADsSecurityUtility             a63251b2-5f21-474b-ab52-4a8efad10895


#define PROPERTY_RW(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] type name);

#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_WO(name, prid)                  \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);


#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);


#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);





#define DISPID_IADs_UPPER_BOUND           14
#define DISPID_IADsService_UPPER_BOUND    DISPID_IADs_UPPER_BOUND + 18
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from ADs directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization perADs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CADsAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CADsAry * paryCopy    = NULL;     // copied array

    ADsAssert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CADsAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = paryCopy->Copy(_cb, *pary, _fAddRef);
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    IUnknown ** ppUnk;
    int         i;

    if (_pary && _fDelete)
    {
        if (_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < _pary->Size();
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CADsAry *     pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef);
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CADsAry *     pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!*ppenum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    ADsAssert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            ADsAssert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            ADsAssert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            ADsAssert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            ADsAssert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
        case VT_DISPATCH:
            ADsAssert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        default:
            ADsAssert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum);
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\date.cxx ===
#include "Procs.hxx"

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\


HRESULT
NTTimeFormattoDateFormat(
    LARGE_INTEGER *NTTimeFormat,
    DATE *DateFormat
    )
{
    *DateFormat = (DATE)0;
    RRETURN(S_OK);
}


HRESULT
ConvertDWORDtoDATE(
    DWORD dwDate,
    DATE * pdaDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    SYSTEMTIME SystemTime, LocalTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;    

    if (pdaDate) {
        memset(pdaDate, 0, sizeof(DATE));
    }

    memset(&fileTime, 0, sizeof(FILETIME));

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        FileTimeToLocalFileTime(&fileTime, &fileTime);

    if (!FileTimeToSystemTime(&fileTime, &SystemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToVariantTime(&SystemTime, pdaDate)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
ConvertDATEtoDWORD(
    DATE daDate,
    DWORD *pdwDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;
    SYSTEMTIME systemTime;

    if (!VariantTimeToSystemTime(daDate, &systemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToFileTime(&systemTime, &fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        LocalFileTimeToFileTime(&fileTime, &fileTime);

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;


    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);

}


HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    RRETURN(S_OK);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;
    SYSTEMTIME LocalTime;

    //
    // Get Time-zone specific local time.
    //

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &Time,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&LocalTime,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}


HRESULT
ConvertDWORDToDATE(
    DWORD    dwTime,
    DATE *     pdaTime
    )

{
    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    FILETIME lft; //local file time
    BOOL fRetval = FALSE;
    SYSTEMTIME LocalTime;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &lft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    //
    // convert local file time to filetime
    //

    fRetval = LocalFileTimeToFileTime(&lft,
                                      &ft );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:  25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {       \
        goto error;         \
    }

#define CONTINUE_ON_FAILURE(hr) \
    if (FAILED(hr)) {           \
        continue;               \
    }

HMODULE g_hActiveDs = NULL; // Module handle of activeds.dll. This should be
                            // initialized when the provider module is loaded
                            // into a process' address space. The handle
                            // is used by FillExcepInfo to retrieve error
                            // description strings from activeds.dll.

static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);




//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = (DWORD)(pvtCur - pvt);
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT *pvProp = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    //
    // It has to be a variant and a safearray. It might
    // also be a variant that is byref and safe array
    //
    //

    pvProp = &varSafeArray;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&varSafeArray);
    }

    if(!(((V_VT(pvProp) & VT_VARIANT)== VT_VARIANT)
         && V_ISARRAY(pvProp))) {
        //
        // We need to make this additional check. This is not really 
        // legal but it could be that just the tag at this level is wrong.
        // This was allowed in older versions of ADSI and therefore needs
        // on future versions (backward compatibility). 
        //
        if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
          RRETURN(E_FAIL);
    }

    if (V_VT(pvProp) == (VT_BYREF | VT_VARIANT | VT_ARRAY)) {
        //
        // in this case we need to use the ARRAY_REF.
        //
        pArray = *(V_ARRAYREF(pvProp));
    }
    else {
        //
        // pvProp will always have the correc info, byref or not.
        //
        pArray = V_ARRAY(pvProp);
    }

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (PVARIANT)AllocADsMem(
                                sizeof(VARIANT)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(pVarArray + i);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        CONTINUE_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}

//
// This method should go away.  ConvertSafeArrayToVariantArray does the job.
//
HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    RRETURN(ConvertSafeArrayToVariantArray(
        varSafeArray,
        ppVarArray,
        pdwNumVariants
        ));
}

//
// An LDAP query needs a NULL-terminated array of strings.
//
HRESULT
ConvertVariantArrayToLDAPStringArray(
    PVARIANT pVarArray,
    PWSTR **pppszStringArray,
    DWORD dwNumStrings
    )
{
    HRESULT hr = S_OK;
    PWSTR *ppszStringArray = NULL;
    DWORD i = 0;

    //
    // Start off with a zero-length array.
    //
    *pppszStringArray = NULL;

    //
    // The LDAP library expects an array terminated with a NULL string.
    // So make space for an extra one.
    //
    dwNumStrings++;

    ppszStringArray = (PWSTR *)AllocADsMem(dwNumStrings * sizeof(PWSTR));
    if (!ppszStringArray)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    for (i = 0; i < dwNumStrings - 1; i++)
    {
        if (!(V_VT(pVarArray + i) == VT_BSTR))
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

        ppszStringArray[i] = AllocADsStr(V_BSTR(pVarArray + i));
        if (!ppszStringArray[i])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // NULL-terminated for LDAP.
    //
    ppszStringArray[i] = NULL;

    *pppszStringArray = ppszStringArray;
    RRETURN(hr);

error:
    if (ppszStringArray)
    {
        for (DWORD j = 0; j < i; j++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);

        FreeADsMem(ppszStringArray);
    }
    RRETURN(hr);
}

HRESULT
VariantToBinary(
    PVARIANT pVarSrcObject,
    DWORD *pdwLength,
    BYTE  **ppByte
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    BYTE  *pByte = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    pByte = (BYTE*)AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( pByte == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pByte,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

    *pdwLength = dwSUBound - dwSLBound + 1;
    *ppByte = pByte;

    RRETURN(hr);
error:
    if (pByte) {
        FreeADsMem(pByte);
    }
    RRETURN(hr);
}

HRESULT
BinaryToVariant(
    DWORD Length,
    BYTE* pByte,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = Length;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pByte, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
CopyOctetString(
    DWORD dwNumBytes,
    BYTE *pData,
    DWORD *pdwNumBytes,
    BYTE **ppByte
    )
{
    LPBYTE lpByteStream = NULL;
    HRESULT hr = S_OK;

    if (dwNumBytes) {
        lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
        if (lpByteStream == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            lpByteStream,
            pData,
            dwNumBytes
            );

        *pdwNumBytes = dwNumBytes;
        *ppByte =  lpByteStream;
    }
    else {
        *pdwNumBytes = 0;
        *ppByte = NULL;
    }
error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   RaiseException, public API
//
//  Synopsis:   Generic function for translating ADS HRESULT codes to an
//              OLE error object.
//
//  Arguments:  [hr] - The HRESULT code to be translated into
//                     an OLE error object.
//
//
//  Returns:    Nothing. This function is called when an error occurred.
//              There isn't much the caller can do if this function fails.
//
//  History:    10-Sep-97   t-rmak      Created.
//
//
//  Notes:      1) Only ADS error codes are properly translated to
//                 corresponding OLE error objects.
//              2) This function will ignore the lcid passed into
//                 ITypeInfo::Invoke and it always passes 0 as the langid
//                 to FormatMessage.
//              3) Only the source field and the description field of the
//                 error object will be filled by this function.
//              4) This function does not support inserts in the description
//                 string.
//
//-------------------------------------------------------------------------
void
RaiseException(HRESULT hr)
{

    DWORD            dwStrLen;
    LPTSTR           lpszMessage = NULL;
    ICreateErrorInfo *pICreateErrorInfo = NULL;
    IErrorInfo       *pIErrorInfo = NULL;
    HRESULT          localhr = S_OK;

    if (g_hActiveDs != NULL) {

        //
        // Clear any previously set error object
        //
        SetErrorInfo(0, NULL);

        //
        // Let FormatMessage allocate the message buffer.
        // In a multi-threaded environment, this is the simplest
        // solution.
        //
        dwStrLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 // Ignore inserts for now.
                                 FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 (LPCVOID) g_hActiveDs,
                                 hr,
                                 0,
                                 (LPTSTR) &lpszMessage,
                                 0,
                                 NULL);

        //
        // We may want to fail with a special error code if the specified
        // lcid is not supported.
        //
        if (dwStrLen == 0) {
            goto error;
        }

        //
        // We may want to add support for help file in the future.
        //
        localhr = CreateErrorInfo(&pICreateErrorInfo);

        BAIL_ON_FAILURE(localhr);

        //
        // Note that we don't care whether the following calls succeed since
        // there is nothing we can if they fail.
        //
        pICreateErrorInfo->SetDescription(lpszMessage);
        pICreateErrorInfo->SetSource(TEXT("Active Directory"));

        //
        // Set the threads error object.
        //
        pICreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pIErrorInfo);
        SetErrorInfo(0, pIErrorInfo);

    }

error:

    if (lpszMessage != NULL) {
        LocalFree(lpszMessage);
    }

    //
    // Release the error object's interface pointers
    //
    if (pIErrorInfo != NULL) {
        pIErrorInfo->Release();
    }

    if (pICreateErrorInfo != NULL) {
        pICreateErrorInfo->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\netolary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   netolary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CADsAry
//
//  History:
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//  CADsAry class





//+------------------------------------------------------------------------
//
//  Member: CADsAry::~CADsAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CADsAry::~CADsAry( )
{
    if (_pv)
        LocalFree(_pv);
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  [cb]    Element size
//              [c]     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::EnsureSize(size_t cb, int c)
{
    void *  pv;

    if (c <= GetAlloced(cb))
        return NOERROR;

    //  CONSIDER should we use a more sophisticated array-growing
    //    algorithm?
    c = ((c - 1) & -8) + 8;
    ADsAssert(c > 0);
    if (!_pv)
    {
        pv = LocalAlloc(LMEM_FIXED, c * cb);
    }
    else
    {
        pv = LocalReAlloc(_pv, c * cb, LMEM_MOVEABLE);
    }

    if (!pv)
        RRETURN(E_OUTOFMEMORY);

    _pv = pv;
    return NOERROR;
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Append
//
//  Synopsis:   Appends the given pointer to the end of the array, incrementing
//      the array's logical size, and growing its allocated size if
//      necessary. This method should only be called for arrays of
//      pointers; AppendIndirect should be used for arrays of
//      non-pointers.
//
//  Arguments:  [pv]        Pointer to append.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Append(void * pv)
{
    HRESULT hr;

    ADsAssert(_cb == 4);

    hr = EnsureSize(_c + 1);
    if (hr)
        RRETURN(hr);

    * (void **) Deref(_c) = pv;
    _c++;

    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array, incrementing
//      the array's logical size, and growing the array's allocated
//      size if necessary.  Note that the element is passed with a
//      pointer, rather than directly.
//
//  Arguments:  [cb]        --  Element size
//              [pv]        --  Pointer to the element to be appended
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::AppendIndirect(size_t cb, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memcpy(Deref(cb, _c), pv, cb);
    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all elements
//      that follow one slot towards the beginning of the array.
//
//  Arguments:  [cb]    Element size
//              [i]     Element to delete
//
//-------------------------------------------------------------------------
void
CADsAry::Delete(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < _c);

    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CADsAry::DeleteAll(void)
{
    if (_pv)
        LocalFree(_pv);

    _pv = NULL;
    _c = 0;
}


#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Insert
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.
//      This method should only be called for arrays of
//      pointers; InsertIndirect should be used for arrays of
//      non-pointers.
//
//
//  Arguments:  [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Insert(int i, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * _cb),
            ((BYTE *) _pv) + (i * _cb),
            (_c - i ) * _cb);

    ((void **) _pv)[i] = pv;
    _c++;
    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  [cb]    Element size
//              [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * cb),
            ((BYTE *) _pv) + (i * cb),
            (_c - i ) * cb);

    memcpy(Deref(cb, i), pv, cb);
    _c++;
    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Member: CADsAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + cb, _pv, i * cb);
    memcpy(_pv, rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) _pv) + ((_c - 1) * cb), rgb, cb);
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Find
//
//  Synopsis:   Returns the index at which the given pointer is found, or -1
//      if it is not found. The pointer values are compared directly;
//      there is no compare function.
//
//  Arguments:  [pv]        Pointer to find
//
//  Returns:    int; index of pointer, or -1 if not found
//
//-------------------------------------------------------------------------
int
CADsAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    Assert(_cb == 4);

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::Copy
//
//  Synopsis:   Creates a copy from another CADsAry object.
//
//  Arguments:  [ary]     -- Object to copy.
//              [fAddRef] -- Addref the elements on copy?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::Copy(size_t cb, const CADsAry& ary, BOOL fAddRef)
{
    int         cbArray;                // size of array
    IUnknown ** ppUnk;                  // elem to addref
    int         i;                      // counter

    // avoid copy of self
    if (this == &ary)
        return S_OK;

    DeleteAll();
    if (ary._pv)
    {
        cbArray = ary._c * cb;
        _pv = LocalAlloc(LMEM_FIXED, cbArray);
        if (!_pv)
            RRETURN(E_OUTOFMEMORY);

        memcpy(_pv, ary._pv, cbArray);
    }

    _c          = ary._c;

    if (fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) _pv; i < _c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    ADsAssert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **)ppv);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    ADsAssert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  [i]
//
//  Returns:    void *
//
//  BUGBUG:     This function should be inline; however, since nothing is
//              inlined in debug builds, it requires an export, which
//              then doesn't apply in retail builds and breaks the retail
//              build.  Near ship time, the def file will be fixed handle
//              inlining.
//
//-------------------------------------------------------------------------

void *
CADsAry::Deref(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < GetAlloced(cb));

    return ((BYTE *) _pv) + i * cb;
};





HRESULT
CADsPtrAry::EnsureSize(int c)
{
    return CADsAry::EnsureSize(sizeof(LPVOID), c);
}



HRESULT
CADsPtrAry::Append(void * pv)
{
    return CADsAry::AppendIndirect(sizeof(void *), &pv);
}


HRESULT
CADsPtrAry::Insert(int i, void * pv)
{
    return CADsAry::InsertIndirect(sizeof(void *), i, &pv);
}


int
CADsPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CADsPtrAry::Delete(int i)
{
    CADsAry::Delete(sizeof(void *), i);
}


void
CADsPtrAry::BringToFront(int i)
{
    CADsAry::BringToFront(sizeof(void *), i);
}


void
CADsPtrAry::SendToBack(int i)
{
    CADsAry::SendToBack(sizeof(void *), i);
}


HRESULT
CADsPtrAry::Copy(const CADsAry& ary, BOOL fAddRef)
{
    return CADsAry::Copy(sizeof(void *), ary, fAddRef);
}


HRESULT
CADsPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}


HRESULT
CADsPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       registry.cxx
//
//  Contents:   Registry utilities
//
//  Classes:
//
//  Functions:
//
//  History:    23-May-1996  RamV (Ram Viswanathan) Created
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   SetKeyAndValue
//
//  Synopsis:   Used for setting a key value
//
//
//  Arguments:  pszRegLocation: where to look for/create key
//              pszKey :   name of the Key
//              pszSubKey: name of the subkey
//              pszValue : Value to set
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    5/21/1996  RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
SetKeyAndValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR pszSubKey,
    LPTSTR pszValue
    )

{

    HKEY        hKey;
    TCHAR       szKey[MAX_PATH];
    LONG        lErrorCode;
    HRESULT     hr = S_OK;

    _tcscpy(szKey, pszRegLocation);

    if (pszSubKey != NULL){
        _tcscpy(szKey, TEXT("\\"));
        _tcscat(szKey, pszSubKey);
    }

    lErrorCode = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

    if (lErrorCode != ERROR_SUCCESS){
        return HRESULT_FROM_WIN32(lErrorCode);
    }

    if (pszValue != NULL){
        lErrorCode = RegSetValueEx(hKey,
                                   pszKey,
                                   0,
                                   REG_SZ,
                                   (BYTE *)pszValue,
                                   (_tcslen(pszValue)+1)*sizeof(TCHAR));

        if(lErrorCode != ERROR_SUCCESS){
            hr = HRESULT_FROM_WIN32(lErrorCode);
            goto cleanup;
        }

    }

cleanup:
    RegCloseKey(hKey);
    return S_OK;
}


HRESULT
QueryKeyValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR * ppszValue
    )

{
    LONG lErrorCode;
    TCHAR szKey[MAX_PATH];
    DWORD dwDataLen;
    DWORD dwType;
    HKEY  hKey = NULL;
    HRESULT hr = S_OK;

    dwDataLen = sizeof(TCHAR)* MAX_PATH;
    
    *ppszValue = (LPTSTR)AllocADsMem( dwDataLen );

    if(!*ppszValue){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(szKey, pszRegLocation);

    lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                              szKey,
                              NULL,
                              KEY_READ,
                              &hKey);

    if( lErrorCode != ERROR_SUCCESS){
        hr = HRESULT_FROM_WIN32(lErrorCode);
        goto cleanup;
    }

    lErrorCode = RegQueryValueEx(hKey,
                                 pszKey,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)*ppszValue,
                                 &dwDataLen);

    if (lErrorCode == ERROR_MORE_DATA){
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
        *ppszValue = (LPTSTR)AllocADsMem (dwDataLen);

        if(!*ppszValue){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lErrorCode = RegQueryValueEx(hKey,
                                     pszKey,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)*ppszValue,
                                     &dwDataLen);


        hr = HRESULT_FROM_WIN32(lErrorCode);
        BAIL_IF_ERROR(hr);

    } else if (lErrorCode != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lErrorCode);
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
    }
cleanup:
    if(hKey){
        RegCloseKey(hKey);
    }
    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    return HRESULT_FROM_WIN32(GetLastError());
}



#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI_(void)
PrintIID(DWORD dwFlags, REFIID riid)
{
    LPWSTR lpstr = NULL;

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPWSTR)L#iid;

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IDispatch)
    CASE_IID(IMarshal)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    if (lpstr == NULL)
    {
        WCHAR chBuf[256];
        StringFromGUID2(riid, chBuf, 256);

        ADsDebugOut((dwFlags | DEB_NOCOMPNAME,
                       "UNKNOWN ITF %ws", chBuf));
    }
    else
        ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "%ws", lpstr));
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  ADsAllocString
//              ADsAllocStringLen
//              ADsReAllocString
//              ADsReAllocStringLen
//              ADsFreeString
//              ADsStringLen
//              ADsStringByteLen
//              ADsAllocStringByteLen
//              ADsStringCmp
//              ADsStringNCmp
//              ADsStringICmp
//              ADsStringNICmp
//
//  History:   25-Oct-94 krishnag
//
//
//----------------------------------------------------------------------------

#include "procs.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocString(const OLECHAR * pch, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);
    if (!pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocString(pch);
    hr = (*pBSTR) ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringLen(const OLECHAR * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;

     }


    *pBSTR = SysAllocStringLen(pch, uc);
    hr =  *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocString(BSTR * pBSTR, const OLECHAR * pch)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocString(pch, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }


    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocStringLen(BSTR * pBSTR, const OLECHAR * pch, UINT uc)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocStringLen(pch, uc, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }

    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringLen(BSTR bstr)
{
    return bstr ? SysStringLen(bstr) : 0;
}



#ifdef WIN32

//+---------------------------------------------------------------------------
//
//  Function:   ADsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringByteLen(BSTR bstr)
{
    return bstr ? SysStringByteLen(bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringByteLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 chars and optionally initializes
//              from a string.  If [uc] = 0, the resulting bstr is NULL.
//
//  Arguments:  [pch]   -- Initializer.
//              [uc]    -- Count of chars.
//              [pBSTR] -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringByteLen(const char * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;
     }


    *pBSTR = SysAllocStringByteLen(pch, uc);

    RRETURN(hr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringCmp
//
//  Synopsis:   As per wcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringCmp(CBSTR bstr1, CBSTR bstr2)
{
    return wcscmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNCmp
//
//  Synopsis:   As per wcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNCmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return wcsncmp(STRVAL(bstr1), STRVAL(bstr2), c);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _wcsicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringICmp(CBSTR bstr1, CBSTR bstr2)
{
    return _wcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _wcsnicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNICmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return _wcsnicmp(STRVAL(bstr1), STRVAL(bstr2), c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\pack.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "macro.h"

HRESULT
PackStringinVariant(
    BSTR bstrString,
    VARIANT * pvarInputData
    )
{
    HRESULT hr = S_OK;

    if ( bstrString == NULL )
        RRETURN(E_FAIL);

    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BSTR;

    if (!bstrString) {
        V_BSTR(pvarInputData) = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(bstrString, &(V_BSTR(pvarInputData)));

    RRETURN(hr);
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_BSTR){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(V_BSTR(&varSrcData), pbstrDestString);

    RRETURN(hr);
}


HRESULT
PackLONGinVariant(
    LONG  lValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackLONGfromVariant(
    VARIANT varSrcData,
    LONG * plValue
    )
{
    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *plValue = V_I4(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackDATEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_DATE;
    V_DATE(pvarInputData) = daValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    if( varSrcData.vt != VT_DATE){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdaValue = V_DATE(&varSrcData);

    RRETURN(S_OK);
}



HRESULT
PackFILETIMEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
    return hr;
}

HRESULT
UnpackFILETIMEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    FILETIME locFiletime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    // 
    // time is "0" actually means that either user never logs on or property not known
    //
    if (filetime.dwLowDateTime == 0 && filetime.dwHighDateTime == 0) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }    	

    if (FileTimeToLocalFileTime(&filetime, &locFiletime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (FileTimeToSystemTime(&locFiletime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    *pdaValue = date;
error:
    return hr;
}

HRESULT
PackVARIANT_BOOLinVariant(
    VARIANT_BOOL  fValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BOOL;
    V_BOOL(pvarInputData) = fValue;

    RRETURN(S_OK);
}

HRESULT
UnpackVARIANT_BOOLfromVariant(
    VARIANT varSrcData,
    VARIANT_BOOL * pfValue
    )
{
    if( varSrcData.vt != VT_BOOL){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfValue = V_BOOL(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    RRETURN( VariantCopy( pvarInputData, &vaValue ));
}

HRESULT
UnpackVARIANTfromVariant(
    VARIANT varSrcData,
    VARIANT * pvaValue
    )
{
    VariantInit( pvaValue );

    RRETURN( VariantCopy( pvaValue, &varSrcData ));
}


HRESULT
PackDATEinLONGVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    LONG lValue;
    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    FILETIME LocalFileTime;
    FILETIME FileTimeCurrent;
    DATE       date ;
    BOOL       fRetval;

    VariantInit(pvarInputData);

    if( hr = ConvertDATEToSYSTEMTIME(daValue,
                                &LocalTime)
      ) {
        RRETURN( hr );
    }

    fRetval = SystemTimeToFileTime(&LocalTime,
                         &LocalFileTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = LocalFileTimeToFileTime(
                  &LocalFileTime,
                  &FileTimeCurrent
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = FileTimeToSystemTime(&FileTimeCurrent,
                         &stSystemTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }
    lValue = stSystemTime.wHour * 60 + stSystemTime.wMinute;

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromLONGVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    LONG lValue;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    lValue = V_I4(&varSrcData);

    GetSystemTime( &stSystemTime);


    stSystemTime.wHour = (WORD)(lValue)/60;
    stSystemTime.wMinute = (WORD)(lValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ConvertSystemTimeToDATE (LocalTime,
                                  pdaValue);

    //lpVarDestObject->date = date - (DWORD)date;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//              CDynamicCF
//
//  History:    6-21-94   adams   added CDynamicCF
//              19-Jul-94 doncl   init StdClassFactory::_ulRefs to 1
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  StdClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    ADsAssert(_ulRefs);

    if (_ulRefs == 1)
        INC_OBJECT_COUNT();

    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    ADsAssert(_ulRefs > 1);

    if (--_ulRefs == 1)
        DEC_OBJECT_COUNT();

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the
//              inheriting class because the base class does not know what
//              class to instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN


//+------------------------------------------------------------------------
//
//  CDynamicCF Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF(void)
{
    _ulRefs = 1;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF(void)
{
    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::LockServer, public
//
//  Synopsis:   Since these class factories are on the heap, we have
//              to implement this properly.  In our case, LockServer is
//              equivalent to AddRef/Release because we don't have a single
//              'application' object that we can put an external lock on.
//              Each time CreateInstance is called, we return a newly created
//              object.  If, instead, we returned a pointer to an existing
//              object, we would need to call CoLockObjectExternal on that
//              global object in the implementation of LockServer to keep it
//              alive.
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulRefs++;
    }
    else
    {
        _ulRefs--;
        Assert(_ulRefs != 0 && "Improper use of IClassFactory::LockServer!");
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ccgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccgi.cxx
//
//  Contents:  This file contains the Computer Object's
//             GeneralInfo Functional Set.
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTComputer

STDMETHODIMP CWinNTComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ComputerID);
}

STDMETHODIMP CWinNTComputer::get_Site(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Site);
}

STDMETHODIMP CWinNTComputer::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CWinNTComputer::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CWinNTComputer::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CWinNTComputer::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CWinNTComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CWinNTComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CWinNTComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CWinNTComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CWinNTComputer::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CWinNTComputer::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CWinNTComputer::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CWinNTComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CWinNTComputer::get_Role(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CWinNTComputer::put_Role(THIS_ BSTR bstrRole)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CWinNTComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CWinNTComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CWinNTComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CWinNTComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CWinNTComputer::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CWinNTComputer::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CWinNTComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CWinNTComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CWinNTComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CWinNTComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CWinNTComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CWinNTComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CWinNTComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CWinNTComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CWinNTComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}

STDMETHODIMP CWinNTComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  oleds.odl
//
//  Contents:  Top level odl file for the ADs project
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTComputer

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTComputer)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTComputer)
DEFINE_IADs_TempImplementation(CWinNTComputer)
DEFINE_IADs_PutGetImplementation(CWinNTComputer, ComputerClass,gdwComputerTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTComputer,ComputerClass,gdwComputerTableSize)



CWinNTComputer::CWinNTComputer():
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL),
                _DomainName(NULL),
                _fCredentialsBound(FALSE),
                _hrBindingResult(S_OK),
                _fNoWKSTA(FALSE)
{
    VariantInit(&_vFilter);
}


HRESULT
CWinNTComputer::CreateComputer(
    BSTR Parent,
    BSTR DomainName,
    BSTR ComputerName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(&pComputer);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pComputer->_pDispMgr);


    hr = pComputer->InitializeCoreObject(
                Parent,
                ComputerName,
                COMPUTER_CLASS_NAME,
                COMPUTER_SCHEMA_NAME,
                CLSID_WinNTComputer,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &pComputer->_DomainName);
    BAIL_ON_FAILURE(hr);

    if (DomainName == NULL) {
        pComputer->_fNoWKSTA = TRUE;
    }

    //
    // The computer is a special case for using credentials.  If it is
    // created from a Domain object, the credentials will have the server
    // name of the Domain's DC.  So when we go to RefServer the computer
    // object, it has a different machine name, which should ordinarily fail.
    // We obviously don't want that, so we tell RefServer to allow a change
    // of server names.
    //
    // We also don't want to try to bind to each computer in a domain, since
    // most computers won't actually be examined in detail.  So we don't
    // RefServer until we perform an operation on this object.
    //
    pComputer->_Credentials = Credentials;


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                COMPUTER_CLASS_NAME,
                (IADsComputer *) pComputer,
                pComputer->_pDispMgr,
                Credentials,
                &pComputer->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pComputer->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(2 == pComputer->_dwNumComponents) {
            pComputer->_CompClasses[0] = L"Domain";
            pComputer->_CompClasses[1] = L"Computer";
        }
        else if(1 == pComputer->_dwNumComponents) {
            pComputer->_CompClasses[0] = L"Computer";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pComputer->InitUmiObject(
                pComputer->_Credentials,
                ComputerClass,
                gdwComputerTableSize,
                pComputer->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pComputer,
                pComputer->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );
        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();

    RRETURN(hr);

error:

    delete pComputer;
    RRETURN_EXP_IF_ERR(hr);
}


CWinNTComputer::~CWinNTComputer( )
{
    VariantClear(&_vFilter);

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTComputer::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTComputer::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTComputer::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTComputer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CWinNTComputer::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsComputer) ||
        IsEqualIID(riid, IID_IADsComputerOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CWinNTComputer::RefCredentials()
{
    if (!_fCredentialsBound)
    {
        //
        // Only try it once, regardless of whether we succeed.
        //
        _fCredentialsBound = TRUE;

        //
        // Also let us rebind to a different server (the TRUE flag).
        //
        _hrBindingResult = _Credentials.RefServer(_Name, TRUE);
    }

    //
    // We also want to return the same value on each call; if we failed to
    //   bind, this object shouldn't be allowed to do anything.
    //
    RRETURN_EXP_IF_ERR(_hrBindingResult);
}


/* IADs methods */

STDMETHODIMP
CWinNTComputer::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];

    // We should ref the credentials only if the computer exists
    // otherwise the call will fail.
    if (GetObjectState() != ADS_OBJECT_UNBOUND) {
        BAIL_ON_FAILURE(hr = RefCredentials());
    }

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTCreateComputer(
                    (szHostServerName + 2),
                    _Name
                    );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        RRETURN_EXP_IF_ERR(E_NOTIMPL);
    }

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(4, TRUE));
}

STDMETHODIMP
CWinNTComputer::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(4, FALSE));
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTComputer::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTComputer::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    //
    // Length of ADsPath, the relative name and
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;
    if ( dwLength > MAX_PATH) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        //
        // See if this will cause a buffer overflow.
        //
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    hr = CWinNTComputerEnum::Create(
                (CWinNTComputerEnum **)&penum,
                _ADsPath,
                _DomainName,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());


    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&ObjectType
                       );
    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );
    BAIL_ON_FAILURE(hr);

    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CWinNTUser::CreateUser(_ADsPath,
                                    WINNT_COMPUTER_ID,
                                    _DomainName,
                                    _Name,
                                    RelativeName,
                                    ADS_OBJECT_UNBOUND,
                                    IID_IDispatch,
                                    _Credentials,
                                    (void **)ppObject
                                    );
        break;


    case WINNT_PRINTER_ID:
        hr = CWinNTPrintQueue::CreatePrintQueue(_ADsPath,
                                      WINNT_COMPUTER_ID,
                                      pObjectInfo->ComponentArray[0],
                                      pObjectInfo->ComponentArray[1],
                                      RelativeName,
                                      ADS_OBJECT_UNBOUND,
                                      IID_IDispatch,
                                      _Credentials,
                                      (void**)ppObject
                                      );
        break;


    //
    // default "group" to local group in computer container for backward
    // compatiblity
    //
    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_COMPUTER_ID,
                            _DomainName,
                            _Name,
                            RelativeName,
                            WINNT_GROUP_LOCAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;



    case WINNT_SERVICE_ID:
        hr = CWinNTService::Create(_ADsPath,
                                   pObjectInfo->ComponentArray[0],
                                   pObjectInfo->ComponentArray[1],
                                   RelativeName,
                                   ADS_OBJECT_UNBOUND,
                                   IID_IDispatch,
                                   _Credentials,
                                   (void**)ppObject
                                   );

        break;


    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];

    // Check if the input parameters are valid
    if (bstrClassName == NULL || bstrSourceName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());


    hr = GetObjectType(gpFilters,
                      gdwMaxFilters,
                      bstrClassName,
                      (PDWORD)&ObjectType );

    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
                _ADsPath,
                bstrSourceName,
                &pObjectInfo
                );

    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

       hr = WinNTDeleteUser(pObjectInfo, _Credentials);

       // This might be the case where the user is on the local
       // machine and there workstation is not available
       if (FAILED(hr) && _fNoWKSTA) {
           // We need to go ahead and whack this user
           hr = WinNTDeleteUser(
                    pObjectInfo->ComponentArray[0],
                    bstrSourceName
                    );
       }

       break;

    case WINNT_GROUP_ID:

       //
       // for backward compatability: allow user to delete by classname "group"
       //

       hr = WinNTDeleteGroup(pObjectInfo, WINNT_GROUP_EITHER, _Credentials);

       if (FAILED(hr) && _fNoWKSTA) {
           //
           // We need to whack this group.
           //
           hr = WinNTDeleteLocalGroup(
                    pObjectInfo->ComponentArray[0],
                    bstrSourceName
                    );
       }
       break;

    //
    // Global Group and LocalGroup ID's will now goto default
    //

    case WINNT_PRINTER_ID:

       hr = WinNTDeletePrinter(pObjectInfo);
       break;

    case WINNT_SERVICE_ID:

       hr = WinNTDeleteService(pObjectInfo);
       break;

    default:

       hr = E_ADS_UNKNOWN_OBJECT;
       break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTComputer::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsComputer methods */

HRESULT
CWinNTComputer::AllocateComputerObject(
    CWinNTComputer ** ppComputer
    )
{
    CWinNTComputer FAR * pComputer = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pComputer = new CWinNTComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsComputer,
                (IADsComputer *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsComputerOperations,
                (IADsComputerOperations *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pComputer,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pComputer,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             ComputerClass,
             gdwComputerTableSize,
             (CCoreADsObject *)pComputer,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pComputer->_pPropertyCache = pPropertyCache;
    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pComputer;

    RRETURN(hr);

}

WCHAR *szCurrentVersion = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
WCHAR *szHardwareInfo =  L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0";

STDMETHODIMP
CWinNTComputer::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    COMP_INFO_4 CompInfo4;
    PCOMP_INFO_4 pCompInfo4 = &CompInfo4;
    DWORD dwRet = 0;
    HKEY hKey = NULL;
    HKEY hCurrentKey = NULL;
    HKEY hHardwareKey = NULL;
    DWORD cbData = 0;
    HRESULT hr = S_OK;
    WCHAR lpszServerName[MAX_PATH];
    NET_API_STATUS nasStatus;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    WCHAR szMajorVersion[20];
    WCHAR szMinorVersion[20];


    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    memset(pCompInfo4, 0, sizeof(COMP_INFO_4));
    switch (dwApiLevel) {
    case 4:

        hr = MakeUncName(_Name, lpszServerName);
        BAIL_ON_FAILURE(hr);

        dwRet = RegConnectRegistry(
                        lpszServerName,
                        HKEY_LOCAL_MACHINE,
                        &hKey
                        );
        if (dwRet !=ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szCurrentVersion,
                        0,
                        KEY_READ,
                        &hCurrentKey
                        );

        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pCompInfo4->szOS, L"Windows NT");

        nasStatus = NetServerGetInfo(lpszServerName,
                                     101,
                                     (LPBYTE *)&lpServerInfo
                                     );

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        _itow(
            lpServerInfo->sv101_version_major,
            szMajorVersion,
            10
            );

        _itow(
            lpServerInfo->sv101_version_minor,
            szMinorVersion,
            10
            );

        wcscpy(
            pCompInfo4->szOSVersion,
            szMajorVersion
            );

        wcscat(
            pCompInfo4->szOSVersion,
            L"."
            );

        wcscat(
            pCompInfo4->szOSVersion,
            szMinorVersion
            );

        cbData = sizeof(pCompInfo4->szOwner);
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOwner",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szOwner,
                    &cbData
                    );


        cbData = sizeof(pCompInfo4->szDivision),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOrganization",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szDivision,
                    &cbData
                    );

        cbData = sizeof(pCompInfo4->szProcessorCount),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"CurrentType",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessorCount,
                    &cbData
                    );

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szHardwareInfo,
                        0,
                        KEY_READ,
                        &hHardwareKey
                        );
        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        cbData = sizeof(pCompInfo4->szProcessor),
        dwRet = RegQueryValueEx(
                    hHardwareKey,
                    L"Identifier",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessor,
                    &cbData
                    );


        hr = UnMarshall_Level4(fExplicit, pCompInfo4);

error:
        if(lpServerInfo) {
            NetApiBufferFree(lpServerInfo);
                }

        if (hCurrentKey) {
            RegCloseKey(hCurrentKey);
        }

        if (hHardwareKey) {
            RegCloseKey(hHardwareKey);
        }

        if (hKey) {
            RegCloseKey(hKey);
        }




        RRETURN_EXP_IF_ERR(hr);

    default:
        RRETURN_EXP_IF_ERR(E_FAIL);
    }


}

HRESULT
CWinNTComputer::UnMarshall_Level4(
    BOOL fExplicit,
    LPCOMP_INFO_4 pCompInfo4
    )
{
    HRESULT hr = S_OK;

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                pCompInfo4->szOS,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystemVersion"),
                pCompInfo4->szOSVersion,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Owner"),
                pCompInfo4->szOwner,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Division"),
                pCompInfo4->szDivision,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("ProcessorCount"),
                pCompInfo4->szProcessorCount,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Processor"),
                pCompInfo4->szProcessor,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN(S_OK);
}


STDMETHODIMP
CWinNTComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
RenameUserObject(
    POBJECTINFO pObjectInfo,
    LPWSTR szNewName,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPUSER_INFO_0 lpUI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    DWORD dwParam = 0;
    USER_INFO_0 userinfo;
    memset(&userinfo, 0, sizeof(USER_INFO_0));

    switch (pObjectInfo->NumComponents) {
    case 2:

        //
        // if 2 components then either it is user in computer
        // or user in domain.

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags()
                        );


        if(SUCCEEDED(hr)){

            nasStatus = NetUserGetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       1,
                                       (LPBYTE *)&lpUI);

            hr = HRESULT_FROM_WIN32(nasStatus);

            userinfo.usri0_name = szNewName;
            nasStatus = NetUserSetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE)&userinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);
        }

        //
        // if we are here with hr != S_OK it could be that we have
        // user in a  computer.
        //

        if(FAILED(hr)){
            hr = ValidateComputerParent(
                     NULL,
                     pObjectInfo->ComponentArray[0],
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);

            MakeUncName(pObjectInfo->ComponentArray[0],
                        lpszUncName);

            nasStatus = NetUserGetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE *)&lpUI);

            hr = HRESULT_FROM_WIN32(nasStatus);

            userinfo.usri0_name = szNewName;
            nasStatus = NetUserSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE)&userinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);

        }

        BAIL_ON_FAILURE(hr);

        break;

    case 3:

        //
        // user in domain\computer or user in workgroup\computer
        //



        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);
        BAIL_ON_FAILURE(hr);

        MakeUncName(pObjectInfo->ComponentArray[1],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   0,
                                   (LPBYTE *)&lpUI);

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        userinfo.usri0_name = szNewName;
        nasStatus = NetUserSetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   0,
                                   (LPBYTE)&userinfo,
                                   &dwParam);
        hr = HRESULT_FROM_WIN32(nasStatus);
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


  error:
    if (lpUI) {
        NetApiBufferFree((LPBYTE)lpUI);
    }


    RRETURN(hr);

}

HRESULT
RenameGroupObject(
    POBJECTINFO pObjectInfo,
    LPWSTR szNewName,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPGROUP_INFO_0 lpGI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    GROUP_INFO_0 groupinfo;
    memset(&groupinfo, 0, sizeof(GROUP_INFO_0));
    groupinfo.grpi0_name = szNewName;
    DWORD dwParam;

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // if 2 components then either it is a group in computer
        // or group in domain.
        //

        hr = WinNTGetCachedDCName(
                    pObjectInfo->ComponentArray[0],
                    szHostServerName,
                    Credentials.GetFlags()
                    );

        if(SUCCEEDED(hr)){
            //
            // must be a group in a domain
            //
            hr = ValidateGlobalGroupObject(
                     szHostServerName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {
                hr = ValidateLocalGroupObject(
                         szHostServerName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                if(SUCCEEDED(hr)){
                    nasStatus = NetLocalGroupSetInfo(szHostServerName,
                                               pObjectInfo->ComponentArray[1],
                                               0,
                                               (LPBYTE)&groupinfo,
                                               &dwParam);
                    hr = HRESULT_FROM_WIN32(nasStatus);
                }

            }else{
                nasStatus = NetGroupSetInfo(szHostServerName,
                                           pObjectInfo->ComponentArray[1],
                                           0,
                                           (LPBYTE)&groupinfo,
                                           &dwParam);
                hr = HRESULT_FROM_WIN32(nasStatus);
            }
        }

        if(FAILED(hr)){
            //
            // potentially a group in a computer
            //

            hr = ValidateComputerParent(NULL,
                                        pObjectInfo->ComponentArray[0],
                                        Credentials);
            BAIL_ON_FAILURE(hr);

            //
            // group in a computer
            //
            MakeUncName(pObjectInfo->ComponentArray[0],
                        lpszUncName);

            hr = ValidateGlobalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {

                hr = ValidateLocalGroupObject(
                         lpszUncName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);
                    nasStatus = NetLocalGroupSetInfo(lpszUncName,
                                               pObjectInfo->ComponentArray[1],
                                               0,
                                               (LPBYTE)&groupinfo,
                                               &dwParam);
                    hr = HRESULT_FROM_WIN32(nasStatus);

            }else{
                nasStatus = NetGroupSetInfo(lpszUncName,
                                           pObjectInfo->ComponentArray[1],
                                           0,
                                           (LPBYTE)&groupinfo,
                                           &dwParam);
                hr = HRESULT_FROM_WIN32(nasStatus);
            }
        }
        break;

        case 3:

        //
        // if there are 3 components then we must have parentid
        // WINNT_COMPUTER_ID
        //
        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        MakeUncName(
                pObjectInfo->ComponentArray[1],
                lpszUncName
                );

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (FAILED(hr)) {

            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            nasStatus = NetLocalGroupSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[2],
                                       0,
                                       (LPBYTE)&groupinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);

        }else{
            nasStatus = NetGroupSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[2],
                                       0,
                                       (LPBYTE)&groupinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);
        }
        break;

    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


error:
    if (lpGI) {
        NetApiBufferFree((LPBYTE)lpGI);
    }

    RRETURN(hr);

}

HRESULT
CompareBasePath(POBJECTINFO pObjectInfo, POBJECTINFO pObjectInfoParent)
{
    HRESULT hr = S_OK;
    DWORD i;

    if (wcscmp(pObjectInfo->ProviderName,
               pObjectInfoParent->ProviderName) != 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pObjectInfo->NumComponents != pObjectInfoParent->NumComponents+1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    for (i=0;i<pObjectInfoParent->NumComponents;i++) {
        if (wcscmp(pObjectInfo->ComponentArray[i],
                   pObjectInfoParent->ComponentArray[i]) != 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

error:
    return hr;
}

HRESULT
MoveUserGroupObject(
    THIS_ BSTR SourceName,
    BSTR NewName,
    BSTR bstrParentADsPath,
    CWinNTCredentials& Credentials,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;
    POBJECTINFO pObjectInfoParent = NULL;

    if ((!SourceName || *SourceName == NULL) ||
        (!NewName || *NewName == NULL)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_IF_ERROR(hr);
    }

    hr = BuildObjectInfo(
                SourceName,
                &pObjectInfo
                );
    BAIL_IF_ERROR(hr);

    hr = BuildObjectInfo(
                bstrParentADsPath,
                &pObjectInfoParent
                );
    BAIL_IF_ERROR(hr);

    hr = CompareBasePath(pObjectInfo,
                         pObjectInfoParent);
    BAIL_IF_ERROR(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_IF_ERROR(hr);

    // check if the call is from UMI. If so, the old path will have a class
    // specified in it. Try to rename the object of that class, as opposed
    // to trying to trying to rename a user first and then rename a group.
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
       if(pObjectInfo->ObjectType == TOKEN_USER) {
           hr = RenameUserObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );
       }
       else if(pObjectInfo->ObjectType == TOKEN_GROUP) {
           hr = RenameGroupObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );
       }
       else
           hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
    else {
        hr = RenameUserObject(
                pObjectInfo,
                NewName,
                Credentials
                );
        if (FAILED(hr)
            && hr != HRESULT_FROM_WIN32(ERROR_BAD_USERNAME)
            && hr != HRESULT_FROM_WIN32(NERR_UserExists)
            && hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)
            ) {

            hr = RenameGroupObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );

            if (hr == HRESULT_FROM_WIN32(NERR_GroupNotFound)) {
                //
                // The object to move wasn't a group or user
                //
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
        }
    } // else

    BAIL_ON_FAILURE(hr);

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    hr = BuildObjectInfo(
                bstrParentADsPath,
                NewName,
                &pObjectInfo
                );
    BAIL_IF_ERROR(hr);

    hr = HeuristicGetObject(
                    pObjectInfo,
                    (void**)ppObject,
                    Credentials);
    BAIL_IF_ERROR(hr);

cleanup:
error:
    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    if (pObjectInfoParent) {
        FreeObjectInfo(pObjectInfoParent);
    }
    return hr;
}

STDMETHODIMP
CWinNTComputer::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    return MoveUserGroupObject(SourceName,
                               NewName,
                               _ADsPath,
                               _Credentials,
                               ppObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\utils\variant.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:    21-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified Set/GetDispProp to take REFIID
//                                  to meet sysmgmt needs
//              25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff


static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);


//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    ADsAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        RRETURN(hr);

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;           // BUGBUG: scode?
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = pvtCur - pvt;
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ccred.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ccred.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Blake Jones (t-blakej) 08-08-1997

Revision History:

--*/

#include "winnt.hxx"
extern "C" {
#include "winnetwk.h"
}
#pragma hdrstop

//
// The resource to bind to on remote machines.
//
static const PWSTR g_pszResourceName = TEXT("IPC$");

//
// The error to return from CCred::ref when a bind to a different server
// is attempted.  The caller (should be CWinNTCredentials::RefServer)
// should catch this and dispense with it appropriately.
//
// This should be an error other than E_OUTOFMEMORY or anything that
// WNetAddConnection2 can return.  This is pretty much a bogus error,
// but I'm appropriating it just for RefServer.
//
static const HRESULT dwRebindErr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

//////////////////////////////////////////////////////////////////////////////

//
// Internal class declarations:
//

//+---------------------------------------------------------------------------
//    ____      _ _   ____            _
//   / ___|_ __(_) |_/ ___|  ___  ___| |_
//  | |   | '__| | __\___ \ / _ \/ __| __|
//  | |___| |  | | |_ ___) |  __/ (__| |_
//   \____|_|  |_|\__|____/ \___|\___|\__|
//
// Class CritSect -- C++ wrapper around an NT critical section object.
//
// Constructors:
//   CritSect()                         - initialize the NT object
//
// Public methods:
//   Lock                               - enter the critical section
//   Locked                             - whether we're in the crit. sect.
//   Unlock                             - leave the critical section
//
//----------------------------------------------------------------------------
class CritSect
{
public:
    CritSect()          { InitializeCriticalSection(&m_cs); m_bLocked = FALSE; }
    void Lock()         { EnterCriticalSection(&m_cs); m_bLocked = TRUE; }
    BOOL Locked()       { return m_bLocked; }
    void Unlock()       { LeaveCriticalSection(&m_cs); m_bLocked = FALSE; }
    ~CritSect()         { DeleteCriticalSection(&m_cs); }

private:
    CRITICAL_SECTION m_cs;
    BOOL m_bLocked;
};

//+---------------------------------------------------------------------------
//    ____ ____              _ _____     _     _
//   / ___/ ___|_ __ ___  __| |_   _|_ _| |__ | | ___
//  | |  | |   | '__/ _ \/ _` | | |/ _` | '_ \| |/ _ \
//  | |__| |___| | |  __/ (_| | | | (_| | |_) | |  __/
//   \____\____|_|  \___|\__,_| |_|\__,_|_.__/|_|\___|
//
// Class CCredTable -- performs the authentication requests for the CCred
//   objects, and keeps a mapping for deregistration of objects.
//
// Constructors:
//   CCredTable()                       - make an empty credential table
//
// Public methods:
//   AddCred                            - try to obtain a credential;
//                                        if successful, add it to the table
//   DelCred                            - remove a credential from the table
//
//----------------------------------------------------------------------------
class CCredTable
{
public:
    CCredTable();
    ~CCredTable();

    HRESULT
    AddCred(PWSTR pszUserName, PWSTR pszPassword, PWSTR pszServer,
        DWORD *dwIndex);

    HRESULT
    DelCred(DWORD dwIndex);

private:
    HRESULT
    GrowTable(void);

    //
    // The type used for storing credential->resource name mappings
    //   for deregistration.
    //
    struct cred { PWSTR m_pResource; BOOL m_bUsed; DWORD m_dwCount; 
                  BOOL m_fAlreadyConnected; // was net use already established
                };

    cred *m_pCredentials;               // the cred->resource name table
    DWORD m_dwAlloc;                    // # table entries allocated
    DWORD m_dwUsed;                     // # table entries used
    CritSect m_cs;                      // to guard table access
};

//+---------------------------------------------------------------------------
//    ____ ____              _
//   / ___/ ___|_ __ ___  __| |
//  | |  | |   | '__/ _ \/ _` |
//  | |__| |___| | |  __/ (_| |
//   \____\____|_|  \___|\__,_|
//
// Class CCred - encapsulates the reference-countable parts of the
//   WinNT authentication object.
//
// Constructors:
//   CCred()                            - create an empty CCred
//   CCred(PWSTR pszUserName,           - create a CCred with a username
//         PWSTR pszPassword)             and password.  This does not bind
//                                        to a server yet.
//
// Public methods:
//   GetUserName                        - get the username of the credentials
//   SetUserName                        - set the username of the credentials
//   GetPassword                        - get the password of the credentials
//   SetPassword                        - set the password of the credentials
//   ref                                - add a reference to this object
//   deref                              - remove a reference from this object
//
//----------------------------------------------------------------------------
class CCred
{
    // so it can call the copy ctor
    friend class CWinNTCredentials;

public:
    CCred();
    CCred(PWSTR pszUserName, PWSTR pszPassword);
    ~CCred();

    HRESULT ref(PWSTR pszServer);
    HRESULT deref();

    HRESULT GetUserName(PWSTR *ppszUserName);
    HRESULT GetPassword(PWSTR *ppszPassword);
    DWORD m_dwUsageCount;               // this object's usage count

private:
    CCred(const CCred& other);          // only called by CWinNTCredentials
    CCred& operator=(const CCred&);     // deliberately not implemented

    //
    // Used for storing the password encrypted.
    //
    enum { NW_ENCODE_SEED3 = 0x83 };

    PWSTR m_pszUserName;                // username
    PWSTR m_pszPassword;                // password
    DWORD m_dwPasswdLen;                // #bytes allocated for password
    PWSTR m_pszServer;                  // server on which we have credentials

    DWORD m_dwIndex;                    // index in the CredTable
    DWORD m_dwRefCount;                 // this object's reference count

    static CCredTable g_CredTable;      // the table
};

//
// The table.
//
CCredTable CCred::g_CredTable;

//////////////////////////////////////////////////////////////////////////////

//
// Class definitions:
//

///---------------------------------------------------------------------------
//    ____ ____              _
//   / ___/ ___|_ __ ___  __| |
//  | |  | |   | '__/ _ \/ _` |
//  | |__| |___| | |  __/ (_| | definitions
//   \____\____|_|  \___|\__,_|
//
///---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create an empty credential object.
//
//----------------------------------------------------------------------------
CCred::CCred() :
    m_pszUserName(NULL), m_pszPassword(NULL), m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1), m_dwPasswdLen(0)
{
}

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create a credential object with a username and a password.
// This doesn't increase the reference count, since it doesn't make any
//   connections to the server.
//
// Arguments:
//   [pszUserName]                      - username
//   [pszPassword]                      - password
//
//----------------------------------------------------------------------------
CCred::CCred(PWSTR pszUserName, PWSTR pszPassword) :
    m_pszUserName(NULL), m_pszPassword(NULL), m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1), m_dwPasswdLen(0)
{
    //
    // NTRAID#NTBUG9-67020-2000-7-26-AjayR. We need a way to fail
    // on the constructor.
    //
    m_pszUserName = pszUserName ? AllocADsStr(pszUserName) : NULL;

    if (pszPassword)
    {
        UNICODE_STRING Password;
        UCHAR Seed = NW_ENCODE_SEED3;

        m_dwPasswdLen =  (wcslen(pszPassword) + 1)*sizeof(WCHAR) + 
                         (DES_BLOCKLEN -1);
        m_pszPassword = (PWSTR) AllocADsMem(m_dwPasswdLen);

        ADsAssert(m_pszPassword != NULL);

        if (m_pszPassword) {
            wcscpy(m_pszPassword, pszPassword);
            RtlInitUnicodeString(&Password, m_pszPassword); 

            if(NULL == g_pRtlEncryptMemory)
                RtlRunEncodeUnicodeString(&Seed, &Password);
            else {
                DWORD extra = 0;
                NTSTATUS ntStatus = 0;

                if(extra = (Password.MaximumLength % DES_BLOCKLEN))
                    Password.MaximumLength += (DES_BLOCKLEN - extra);

                ntStatus = g_pRtlEncryptMemory(
                               Password.Buffer,
                               Password.MaximumLength,
                               0
                               );
                ADsAssert(ntStatus == STATUS_SUCCESS);

                m_dwPasswdLen = Password.MaximumLength;
            }
        }
    }
    else {
        m_dwPasswdLen = 0;
        m_pszPassword = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create a credential object with a username and a password.
// This doesn't copy the reference count of the "other" object, nor the
//   server nor the server connection index.  This is used to create
//   credentials with the same user/pass on a different server.
// This should only be used by CWinNTCredentials::RefServer.
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
CCred::CCred(const CCred& other) : m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1)
{
    m_pszUserName =
        other.m_pszUserName ? AllocADsStr(other.m_pszUserName) : NULL;

    if(other.m_pszPassword != NULL) {
        m_pszPassword = (PWSTR) AllocADsMem(other.m_dwPasswdLen);
        ADsAssert(m_pszPassword != NULL);
        if(m_pszPassword != NULL) {
            memcpy(m_pszPassword, other.m_pszPassword, other.m_dwPasswdLen);
            m_dwPasswdLen = other.m_dwPasswdLen;
        }
        else
            m_dwPasswdLen = 0;
    }
    else {
        m_dwPasswdLen = 0;
        m_pszPassword = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CCred destructor
//
// Doesn't lower the reference count.
// The object is really deleted in deref().
// It will release the underlying info only if the
// there are no outstanding references
// -- AjayR modified on 6-24-98.
//
//----------------------------------------------------------------------------
CCred::~CCred()
{
    //
    // Clean up only if the usageCount and refCount are 0
    // Any other case means someone has a pointer to this
    //
    if (m_dwUsageCount == 0 && m_dwRefCount == 0) {

        if (m_pszUserName)
            FreeADsStr(m_pszUserName);
        if (m_pszPassword)
            FreeADsMem(m_pszPassword);
        if (m_pszServer)
            FreeADsStr(m_pszServer);

    }

}

//+---------------------------------------------------------------------------
//
// CCred::ref
//
// Adds a reference to this credential object, and if necessary, binds
//   to the specified server.  If this is already bound to the given server,
//   the reference count is simply increased.
//
// Arguments:
//   [pszServer]                        - server to bind to
//
// Returns:
//   S_OK               - if we bound to the server, or are already bound to
//                        the given server.
//   E_FAIL             - if this object is bound, and "pszServer" is not the
//                        same server as we are bound to.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCred::ref(PWSTR pszServer)
{
    HRESULT hr = S_OK;
    PWSTR pszPassword = NULL;

    if (!m_pszServer)
    {
        hr = GetPassword(&pszPassword);
        BAIL_ON_FAILURE(hr);

        hr = g_CredTable.AddCred(m_pszUserName, pszPassword, pszServer,
            &m_dwIndex);
        if (SUCCEEDED(hr))
        {
            m_dwRefCount++;
            m_pszServer = AllocADsStr(pszServer);
        }
        else
            // Don't set m_pszServer, since we didn't bind.
            m_dwIndex = (DWORD) -1;
    }
    else
    {
        if (_wcsicmp(m_pszServer, pszServer) == 0)
            m_dwRefCount++;
        else
            //
            // Don't rebind to another server.  Let the caller do it
            //   explicitly, if desired.
            //
            hr = dwRebindErr;
    }

error:
    if (pszPassword)
        FreeADsStr(pszPassword);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCred::deref
//
// Removes a reference from this credential object.  When the reference count
//   drops to zero, it unbinds from the associated server and deletes itself.
// After the caller calls deref(), it shouldn't touch this object ever again.
//
// Returns:
//   S_OK               - deref occurred okay.
//   Other error codes resulting from WNetCancelConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCred::deref(void)
{
    HRESULT hr = S_OK;
    ADsAssert(m_dwRefCount > 0);

    m_dwRefCount--;

    if (m_dwRefCount == 0)
        {
            hr = g_CredTable.DelCred(m_dwIndex);

            // Reset the index and free server to play extra safe
            m_dwIndex = (DWORD) -1;

            if (m_pszServer) {
                FreeADsStr(m_pszServer);
                m_pszServer = NULL;
            }
#if DBG
            if (hr == E_INVALIDARG)
                ADsAssert(FALSE && "Invalid table index in CCred::deref()!");
#endif
        }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCred::GetUserName
//
// Retrieves the username represented by this credentials object.
//
// Arguments:
//   [ppszUserName]                     - address of a PWSTR to receive a
//                                        pointer to the username.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCred::GetUserName(PWSTR *ppszUserName)
{
    if (!m_pszUserName)
        *ppszUserName = NULL;
    else
    {
        *ppszUserName = AllocADsStr(m_pszUserName);
        if (!*ppszUserName)
            RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
// CCred::GetPassword
//
// Retrieves the password represented by this credentials object.
//
// Arguments:
//   [ppszPassword]                     - address of a PWSTR to receive a
//                                        pointer to the password.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCred::GetPassword(PWSTR * ppszPassword)
{
    UNICODE_STRING Password;
    PWSTR pTempPassword = NULL;
    UCHAR Seed = NW_ENCODE_SEED3;


    Password.Length = 0;

    if (!m_pszPassword)
        *ppszPassword = NULL;
    else
    {
        pTempPassword = (PWSTR) AllocADsMem(m_dwPasswdLen);
        if (!pTempPassword)
            RRETURN(E_OUTOFMEMORY);

        memcpy(pTempPassword, m_pszPassword, m_dwPasswdLen);

        if(NULL == g_pRtlDecryptMemory) {
            RtlInitUnicodeString(&Password, pTempPassword);
            RtlRunDecodeUnicodeString(Seed, &Password);
        }
        else {
            NTSTATUS ntStatus = 0;

            ntStatus = g_pRtlDecryptMemory(pTempPassword, m_dwPasswdLen, 0);
            if(ntStatus != STATUS_SUCCESS)
                RRETURN(E_FAIL);
        }    

        *ppszPassword = pTempPassword;
    }

    RRETURN(S_OK);
}

///---------------------------------------------------------------------------
//    ____ ____              _ _____     _     _
//   / ___/ ___|_ __ ___  __| |_   _|_ _| |__ | | ___
//  | |  | |   | '__/ _ \/ _` | | |/ _` | '_ \| |/ _ \
//  | |__| |___| | |  __/ (_| | | | (_| | |_) | |  __/ definitions
//   \____\____|_|  \___|\__,_| |_|\__,_|_.__/|_|\___|
//
///---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
// CCredTable constructor
//
// Creates an empty CCredTable.
//
//----------------------------------------------------------------------------
CCredTable::CCredTable() :
    m_pCredentials(NULL), m_dwAlloc(0), m_dwUsed(0)
{
}

//+---------------------------------------------------------------------------
//
// CCredTable destructor
//
// Destroys the CCredTable.  If there are entries still in use at dtor
// time, it will print a debug message.  (Maybe it should assert?)
//
//----------------------------------------------------------------------------
CCredTable::~CCredTable()
{
    for (DWORD dw = 0; dw < m_dwUsed; ++dw)
    {
        if (m_pCredentials[dw].m_bUsed)
        {
            // the share name could be up to MAX_PATH.
#if 0
            WCHAR pszMessage[64 + MAX_PATH];
            wsprintf(pszMessage, TEXT("Credential %d (\"%s\") not free!"),
                dw, m_pCredentials[dw].m_pResource);
            OutputDebugString(pszMessage);
#endif
        }

        //
        // Try to cancel the connection, so we don't have lots left
        // lying around, but don't complain if we can't disconnect.
        //
        DelCred(dw);
    }
    if (m_pCredentials)
        FreeADsMem(m_pCredentials);
}

//+---------------------------------------------------------------------------
//
// CCredTable::AddCred
//
// Tries to get credentials for a server's "IPC$" resource.  If the
//   credentials are gained, an entry is added to the resource table.
//   The "index" returned allows the caller to delete the resource
//   when it's done with it.
//
// Arguments:
//   [pszUserName]                      - username to use
//   [pszPassword]                      - password to use
//   [pszServer]                        - server to connect to
//   [pdwIndex]                         - address of a DWORD to receive
//                                        the table index of this resource.
// Returns:
//   S_OK               - if we bound to the server.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::AddCred(PWSTR pszUserName, PWSTR pszPassword, PWSTR pszServer,
        DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    BOOL fAlreadyInTable = FALSE;
    DWORD dwCtr = 0;
    NET_API_STATUS nasStatus = 0;
    USE_INFO_1 *pUseInfo = NULL;
    BOOL fConnectionAdded = FALSE;

    *pdwIndex = (DWORD) -1;

    //
    // Open a connection to IPC$ on the server.
    //

    NETRESOURCE NetResource;
    memset(&NetResource, 0, sizeof(NETRESOURCE));
    NetResource.dwType = RESOURCETYPE_ANY;
    NetResource.lpLocalName = NULL;
    NetResource.lpProvider = NULL;

    WCHAR RemoteName[MAX_PATH];

    if( (wcslen(pszServer) + wcslen(g_pszResourceName) + 4) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    wsprintf(RemoteName, TEXT("\\\\%ls\\%ls"), pszServer, g_pszResourceName);
    NetResource.lpRemoteName = RemoteName;

    //
    // WNetAddConnection2 ignores the other members of NETRESOURCE.
    //

    DWORD dwResult;
    dwResult = WNetAddConnection2(&NetResource, pszPassword, pszUserName, 0);
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwResult));
    fConnectionAdded = TRUE;

    m_cs.Lock();

    //
    // At this point, we know that the NetUse call succeeded.
    // We are not going to see if we need to add this to the
    // table or not. If we already have a net use to the same
    // resource then we need not add this to the table and
    // instead we should bump up the refCount and return the
    // index of the already stored resource.
    //
    for (dwCtr = 0; (dwCtr < m_dwUsed) && !fAlreadyInTable; dwCtr++) {

        if (m_pCredentials[dwCtr].m_bUsed
            && m_pCredentials[dwCtr].m_pResource) {

#ifdef WIN95
            if (_wcsicmp(
                    m_pCredentials[dwCtr].m_pResource,
                    RemoteName
                    )
                == 0 ) {
#else
            if (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    m_pCredentials[dwCtr].m_pResource,
                    -1,
                    RemoteName,
                    -1
                ) == CSTR_EQUAL ) {
#endif
                *pdwIndex = dwCtr;
                fAlreadyInTable = TRUE;
                m_pCredentials[dwCtr].m_dwCount++;
            }

        }
    }

    //
    // Index will not be -1 if we found a match in the table.
    //
    if (!fAlreadyInTable) {

        if (m_dwUsed == m_dwAlloc)
            hr = GrowTable();
        BAIL_ON_FAILURE(hr);
        ADsAssert(m_dwUsed < m_dwAlloc);

        m_pCredentials[m_dwUsed].m_pResource = AllocADsStr(RemoteName);
        if (!m_pCredentials[m_dwUsed].m_pResource)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        m_pCredentials[m_dwUsed].m_bUsed = TRUE;

        m_pCredentials[m_dwUsed].m_dwCount = 1;

        //
        // check to see if there was already a net use connection existing at
        // the time WNetAddConnection2 was called.
        //

        nasStatus = NetUseGetInfo(
                           NULL,
                           RemoteName,
                           1, // level
                           (LPBYTE *) &pUseInfo
                           );

        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

        ADsAssert(pUseInfo != NULL);

        if(pUseInfo->ui1_usecount == 1)  {
        // only this process has an open connection

            m_pCredentials[m_dwUsed].m_fAlreadyConnected = FALSE;
        }
        else  {
            m_pCredentials[m_dwUsed].m_fAlreadyConnected = TRUE;
        }

        // do this last thing.
        *pdwIndex = m_dwUsed++;
    }

    m_cs.Unlock();

    if(pUseInfo != NULL)
        NetApiBufferFree(pUseInfo);

    RRETURN(hr);

error:
    if (m_dwUsed != m_dwAlloc && m_pCredentials[m_dwUsed].m_pResource != NULL)
    {
        FreeADsStr(m_pCredentials[m_dwUsed].m_pResource);
        m_pCredentials[m_dwUsed].m_pResource = NULL;
    }

    if (m_cs.Locked())
        m_cs.Unlock();

    if (fConnectionAdded)
        (void) WNetCancelConnection2(RemoteName, 0, FALSE);

    if(pUseInfo != NULL)
        NetApiBufferFree(pUseInfo);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCredTable::DelCred
//
// Disconnects from the "ADMIN$" resource specified by the table entry
//   with index "dwIndex".
//
// Arguments:
//   [DWORD dwIndex]                    - index of table entry to delete
//
// Returns:
//   S_OK               - deref occurred okay.
//   E_INVALIDARG       - the table index is invalid.
//   Other error codes resulting from WNetCancelConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::DelCred(DWORD dwIndex)
{
    HRESULT hr = S_OK;
    DWORD dwResult;

    m_cs.Lock();

    if (((LONG)dwIndex) < 0 || dwIndex >= m_dwUsed)
        hr = E_INVALIDARG;
    else if (m_pCredentials[dwIndex].m_bUsed == FALSE)
        hr = S_OK;
    else
    {
        ADsAssert(m_pCredentials[dwIndex].m_dwCount);

        //
        // Delete only if the refCount is zero.
        //
        if (--m_pCredentials[dwIndex].m_dwCount == 0) {
            //
            // cancel connection only if if it was not already present at the
            // time we did WNetAddConnection2
            //
            if(m_pCredentials[dwIndex].m_fAlreadyConnected == FALSE) {
                dwResult = WNetCancelConnection2(
                        m_pCredentials[dwIndex].m_pResource, 0, FALSE);
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwResult));
            }

            FreeADsStr(m_pCredentials[dwIndex].m_pResource);
            m_pCredentials[dwIndex].m_pResource = NULL;
            m_pCredentials[dwIndex].m_bUsed = FALSE;
            m_pCredentials[dwIndex].m_dwCount = 0;
            m_pCredentials[dwIndex].m_fAlreadyConnected = FALSE;

        }
        else {
            hr = S_OK;
        }
    }

error:
    m_cs.Unlock();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCredTable::GrowTable
//
// Increase the size of the CredTable by a fixed amount.  Private method.
//
// Returns:
//   S_OK               - deref occurred okay.
//   E_OUTOFMEMORY      - we ran out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::GrowTable(void)
{
    ADsAssert(m_cs.Locked());

    cred *pCredentials = (cred *)ReallocADsMem(m_pCredentials,
        m_dwAlloc * sizeof(cred), (m_dwAlloc + 10) * sizeof(cred));

    if (!pCredentials)
        RRETURN(E_OUTOFMEMORY);
    m_pCredentials = pCredentials;
    for (DWORD dw = m_dwAlloc; dw < m_dwAlloc + 10; dw++)
    {
        m_pCredentials[dw].m_bUsed = FALSE;
        m_pCredentials[dw].m_pResource = NULL;
        m_pCredentials[dw].m_dwCount = 0;
        m_pCredentials[dw].m_fAlreadyConnected = FALSE;
    }

    m_dwAlloc += 10;

    RRETURN(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//   _____      ___      _  _ _____ ___            _         _   _      _
//  / __\ \    / (_)_ _ | \| |_   _/ __|_ _ ___ __| |___ _ _| |_(_)__ _| |___
// | (__ \ \/\/ /| | ' \| .` | | || (__| '_/ -_) _` / -_) ' \  _| / _` | (_-<
//  \___| \_/\_/ |_|_||_|_|\_| |_| \___|_| \___\__,_\___|_||_\__|_\__,_|_/__/
//                              definitions
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CWinNTCredentials constructor
//
// Creates an empty CWinNTCredentials object.
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials():
    m_cRefAdded(0), m_pCred(NULL), m_dwFlags(0)
{
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials constructor
//
// Creates a CWinNTCredentials object for a given username/password.
//
// Arguments:
//   [pszUserName]                      - username
//   [pszPassword]                      - password
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials(PWSTR pszUserName, PWSTR pszPassword, DWORD dwFlags) :
    m_cRefAdded(0), m_pCred(NULL), m_dwFlags(dwFlags)
{
    //
    // If both username and password are NULL or "", don't create a cred.
    //

    if ((pszUserName && *pszUserName) || (pszPassword && *pszPassword))
        m_pCred = new CCred(pszUserName, pszPassword);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials copy constructor
//
// Copies a CWinNTCredentials object from another.
// This sets the "referenced" flag to FALSE, and doesn't increase the
//   reference count.  That should be done explicitly with ref().
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials(const CWinNTCredentials& other) :
    m_cRefAdded(0), m_pCred(other.m_pCred), m_dwFlags(other.m_dwFlags)
{
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials destructor
//
// Dereferences the credentials.  If the reference count drops to zero,
//   the internal refcounted credentials object goes away.
//
//----------------------------------------------------------------------------
CWinNTCredentials::~CWinNTCredentials()
{
    Clear_pCredObject();
}



//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Clear_pCredObject
//
// Dereferences the credentials.  If the reference count drops to zero,
//   the internal refcounted credentials object goes away.
// This is a private member function as this needs to be called
// in different places and therefore the destructor is not the
// right place - AjayR 6-25-98.
//
//----------------------------------------------------------------------------
void
CWinNTCredentials::Clear_pCredObject()
{
    if (m_cRefAdded) {

        m_pCred->deref();
        m_cRefAdded--;

    }

    if (m_pCred) {

        m_pCred->m_dwUsageCount--;

        if (m_pCred->m_dwUsageCount == 0) {
            delete m_pCred;
            m_pCred = NULL;
        }
    }

}
//+---------------------------------------------------------------------------
//
// CWinNTCredentials copy operator
//
// Copies a CWinNTCredentials object from another.  This dereferences
//   the old object, and doesn't increase the reference count of the
//   new object.  That should be done explicitly with ref().
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
const CWinNTCredentials&
CWinNTCredentials::operator=(const CWinNTCredentials& other)
{
    if (&other != this)
    {
        // Clean up the current m_pCred
        Clear_pCredObject();

        m_dwFlags = other.m_dwFlags;

        m_pCred = other.m_pCred;
        if (m_pCred) {
            m_pCred->m_dwUsageCount++;
        }
        m_cRefAdded = 0;
        // Don't addref here.
    }

    return *this;
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::RefServer
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// Arguments:
//   [pszServer]                        - server to establish credentials with
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::RefServer(PWSTR pszServer, BOOL fAllowRebinding)
{
    HRESULT hr = S_OK;

    if (m_pCred)
    {
        ADsAssert(pszServer && *pszServer);
        hr = m_pCred->ref(pszServer);
        //
        // We usually don't want to allow rebinding, to catch coding mistakes.
        // The only time we want to is when we open a Computer object from a
        //   Domain, which has been opened via OpenDSObject.
        //
        if (hr == dwRebindErr && fAllowRebinding)
        {
            // Copy the username and password, and try again.
            CCred * pCCred = new CCred(*m_pCred);

            // clear the m_pCred object
            Clear_pCredObject();

            //
            // assign the m_pCred object to the copy and try
            // and rebind if the new CCred object is not null
            //
            m_pCred = pCCred;

            //
            // m_cRefAdded is this CWinNTCredentials object's contribution
            // to the refcount of m_pCred. Since we have a new CCred object, 
            // set m_cRefAdded to 0. 
            //
            m_cRefAdded = 0;

            if (m_pCred) 
                hr = m_pCred->ref(pszServer);
            else
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
            m_cRefAdded++;
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
// CWinNTCredentials::DeRefServer
//
// Call this only in special cases, when you know that the credentials
// object is being passed around will have to RefServer/RefDomain
// more than once as we are in the process of validating/finding
// the object as opposed to actually creating the adsi object.
// AjayR added on 6-24-98.
//
// Arguments:
//   [pszServer]                        - server to deref
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::DeRefServer()
{
    HRESULT hr = S_OK;

    if (m_pCred && m_cRefAdded)
    {
        hr = m_pCred->deref();

        m_cRefAdded--;
    }
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
// CWinNTCredentials::RefDomain
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// Arguments:
//   [pszDomain]                        - domain to establish credentials with
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::RefDomain(PWSTR pszDomain)
{
    HRESULT hr = S_OK;

    // Don't take the hit of WinNTGetCachedDCName if we have null creds.
    if (m_pCred)
    {
        WCHAR szDCName[MAX_PATH];

        ADsAssert(pszDomain && *pszDomain);

        hr = WinNTGetCachedDCName(pszDomain, szDCName, m_dwFlags);

        if (SUCCEEDED(hr))
            // +2 for the initial "\\"
            hr = RefServer(szDCName + 2);
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::DeRefDomain
//
// Call this only in special cases, when you know that the credentials
// object is being passed around will have to RefServer/RefDomain
// more than once as we are in the process of validating/finding
// the object as opposed to actually creating the adsi object.
// AjayR added on 6-24-98.
//
// Arguments:
//   [pszServer]                        - server to deref
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::DeRefDomain()
{
    HRESULT hr = S_OK;

    //
    // Call DeRefServer - since we just want to whack the ref
    //
    hr = DeRefServer();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Ref
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// This takes both a server and a domain; since several objects are created
//   with both server and domain as arguments (which one is used depends on
//   what the object's ADs parent is), this is a commonly used bit of code.
//
// Arguments:
//   [pszServer]                        - server to bind to
//   [pszDomain]                        - domain of the PDC to bind to
//   [dwType]                           - WINNT_DOMAIN_ID or WINNT_COMPUTER_ID
//
// Returns:
//   S_OK               - if we bound to the server, or are already bound to
//                        the given server.
//   E_FAIL             - if this object is bound, and the specified server
//                        is not the same server as we are bound to.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2 and from
//     WinNTGetCachedDCName.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::Ref(PWSTR pszServer, PWSTR pszDomain, DWORD dwType)
{
    HRESULT hr = S_OK;

    ADsAssert(dwType == WINNT_DOMAIN_ID || dwType == WINNT_COMPUTER_ID);

    // Don't take the hit of WinNTGetCachedDCName if we have null creds.
    if (m_pCred)
    {
        if (dwType == WINNT_DOMAIN_ID)
            hr = RefDomain(pszDomain);
        else
            hr = RefServer(pszServer);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::GetUserName
//
// Retrieves the username represented by this credentials object.
//
// Arguments:
//   [ppszUserName]                     - address of a PWSTR to receive a
//                                        pointer to the username.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::GetUserName(PWSTR *ppszUserName)
{
    HRESULT hr;

    if (!ppszUserName)
        RRETURN(E_ADS_BAD_PARAMETER);

    //
    // Based on the rest of the codes, if UserName & Password are both "",
    // no CCred is created & m_pCred = NULL. (See Constructor). Before we
    // can hit CCred::GetUserName and get back *ppszUserName=NULL with hr =
    // S_OK, we will have AV already. So need to check if m_pCred 1st.
    //

    if (m_pCred)
    {
        hr = m_pCred->GetUserName(ppszUserName);
    }
    else
    {
        *ppszUserName = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::GetPassword
//
// Retrieves the password represented by this credentials object.
//
// Arguments:
//   [ppszPassword]                     - address of a PWSTR to receive a
//                                        pointer to the password.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::GetPassword(PWSTR * ppszPassword)
{
    HRESULT hr;

    if (!ppszPassword)
        RRETURN(E_ADS_BAD_PARAMETER);

    //
    // Based on the rest of the codes, if UserName & Password are both "",
    // no CCred is created & m_pCred = NULL. (See Constructor). Before we
    // can hit CCred::GetUserName and get back *ppszPassword=NULL with hr =
    // S_OK, we will have AV already. So need to check if m_pCred 1st.
    //

    if (m_pCred)
    {
        hr = m_pCred->GetPassword(ppszPassword);
    }
    else
    {
        *ppszPassword = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Bound
//
// Returns TRUE iff this object has a reference to a server.
//
//----------------------------------------------------------------------------
BOOL
CWinNTCredentials::Bound()
{
    RRETURN(m_cRefAdded != 0);
}

void
CWinNTCredentials::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

DWORD
CWinNTCredentials::GetFlags() const
{
    RRETURN(m_dwFlags);
}

void
CWinNTCredentials::SetUmiFlag(void)
{
    m_dwFlags |= ADS_AUTH_RESERVED;
}

void
CWinNTCredentials::ResetUmiFlag(void)
{
    m_dwFlags &= (~ADS_AUTH_RESERVED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\ccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ccache.cxx
//
//  Contents:     Class Cache functionality for the NT Provider
//
//
//----------------------------------------------------------------------------
#include "winnt.hxx"

HRESULT
SetOctetPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE *pByte,
    DWORD dwLength,
    BOOL fExplicit
    )
{
    HRESULT hr;
    OctetString octString;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    octString.pByte = pByte;
    octString.dwSize = dwLength;

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&octString,
                    1,
                    NT_SYNTAX_ID_OCTETSTRING,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
SetLPTSTRPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_LPTSTR,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDWORDPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DWORD,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDATE70PropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE_1970,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}



HRESULT
SetDATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetBOOLPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BOOL  fValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&fValue,
                    1,
                    NT_SYNTAX_ID_BOOL,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetSYSTEMTIMEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME stValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&stValue,
                    1,
                    NT_SYNTAX_ID_SYSTEMTIME,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDelimitedStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwNumValues = 0;

    LPWSTR pszString =  AllocADsStr(pszValue);

    if(!pszString){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }


    //
    // Find the size of the delimited String
    //

    if((dwNumValues = DelimitedStrSize(pszString, TEXT(',')))== 0){
        hr = E_FAIL;
        goto error;
    }

    

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszString,
                    dwNumValues,
                    NT_SYNTAX_ID_DelimitedString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if(pszString){
        FreeADsStr(pszString); 
    }

    RRETURN(hr);
}

HRESULT
SetNulledStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{

    HRESULT hr;
    DWORD dwNumValues = 0;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }


    //
    // Find the size of the nulled String
    //

    if((dwNumValues = NulledStrSize(pszValue))== 0){
        hr = E_FAIL;
        goto error;
    }

    
    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    dwNumValues,
                    NT_SYNTAX_ID_NulledString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);


}

HRESULT
GetOctetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    OctetString *pOctet)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                dwSyntaxId,
                pNTObject,
                dwNumValues,
                (LPBYTE)pOctet
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetLPTSTRPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                dwSyntaxId,
                pNTObject,
                dwNumValues,
                (LPBYTE)ppszValue
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetDelimitedStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)ppszValue
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}


HRESULT
GetNulledStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)ppszValue
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetBOOLPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PBOOL pBool
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pBool
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}


HRESULT
GetDWORDPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDWORD
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}


HRESULT
GetDATE70PropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDWORD
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}

HRESULT
GetDATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PDWORD pdwDate
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDate
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}

HRESULT
GetSYSTEMTIMEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME * pstTime
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pstTime
                    );
    }

error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }


    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cdomain.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Windows NT 3.5
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL( Domain );
DECLARE_DEBUG( Domain );
#define DomainDebugOut(x) DomainInlineDebugOut x

//  Class CWinNTDomain

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTDomain)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTDomain)
DEFINE_IADs_TempImplementation(CWinNTDomain)
DEFINE_IADs_PutGetImplementation(CWinNTDomain, DomainClass, gdwDomainTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTDomain, DomainClass, gdwDomainTableSize)

HRESULT
MoveUserGroupObject(
    THIS_ BSTR SourceName,
    BSTR NewName,
    BSTR bstrParentADsPath,
    CWinNTCredentials& Credentials,
    IDispatch * FAR* ppObject
    );

CWinNTDomain::CWinNTDomain() :
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL)
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CWinNTDomain);
}

HRESULT
CWinNTDomain::CreateDomain(
    BSTR Parent,
    BSTR DomainName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTDomain FAR * pDomain = NULL;
    NET_API_STATUS nasStatus;
    HRESULT hr = S_OK;


    hr = AllocateDomainObject(&pDomain);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pDomain->_pDispMgr);


    hr = pDomain->InitializeCoreObject(
                Parent,
                DomainName,
                DOMAIN_CLASS_NAME,
                DOMAIN_SCHEMA_NAME,
                CLSID_WinNTDomain,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    pDomain->_Credentials = Credentials;
    hr = pDomain->_Credentials.RefDomain(DomainName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                DOMAIN_CLASS_NAME,
                (IADsDomain *) pDomain,
                pDomain->_pDispMgr,
                Credentials,
                &pDomain->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pDomain->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(1 == pDomain->_dwNumComponents)
            pDomain->_CompClasses[0] = L"Domain";
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pDomain->InitUmiObject(
                    pDomain->_Credentials,
                    DomainClass, 
                    gdwDomainTableSize,
                    pDomain->_pPropertyCache,
                    (IUnknown *) (INonDelegatingUnknown *) pDomain,
                    pDomain->_pExtMgr,
                    IID_IUnknown,
                    ppvObj
                    );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pDomain->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDomain->Release();

    RRETURN(hr);

error:

    delete pDomain;
    RRETURN_EXP_IF_ERR(hr);
}

CWinNTDomain::~CWinNTDomain( )
{
    VariantClear(&_vFilter);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTDomain::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTDomain::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTDomain::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTDomain::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDomain))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTDomain::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsDomain)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
STDMETHODIMP
CWinNTDomain::SetInfo(THIS)
{
    HRESULT hr;

    hr = SetInfo(0);

    hr = SetInfo(2);

    hr = SetInfo(3);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::GetInfo(THIS)
{
    HRESULT hr;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(0, TRUE);

    hr = GetInfo(2, TRUE);

    hr = GetInfo(3, TRUE);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::ImplicitGetInfo(THIS)
{
    HRESULT hr;

    hr = GetInfo(0, FALSE);

    hr = GetInfo(2, FALSE);

    hr = GetInfo(3, FALSE);

    RRETURN_EXP_IF_ERR(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTDomain::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTDomain::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Verify that the lenght of the string will not cause overflow.
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;
    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        //
        // Check for buffer overflow again.
        //
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTDomainEnum::Create(
                (CWinNTDomainEnum **)&penum,
                _ADsPath,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTDomain::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(
                gpFilters,
                gdwMaxFilters,
                ClassName,
                (PDWORD)&ObjectType
                );
    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CWinNTUser::CreateUser(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            WINNT_GROUP_GLOBAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    case WINNT_COMPUTER_ID:
        hr = CWinNTComputer::CreateComputer(
                            _ADsPath,
                            _Name,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];


    // Make sure input parameters are valid
    if (bstrClassName == NULL || bstrSourceName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       bstrClassName,
                       (PDWORD)&ObjectType
                       );

    BAIL_ON_FAILURE(hr);


    hr = BuildObjectInfo(
                         _ADsPath,
                         bstrSourceName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = WinNTDeleteUser(pObjectInfo, _Credentials);
        break;

    case WINNT_GROUP_ID:

        //
        // for backward compatablity: allow user to delete by classname "group"
        //

        hr = WinNTDeleteGroup(pObjectInfo, WINNT_GROUP_EITHER, _Credentials);
        break;

    //
    // Global Group and LocalGroup ID's will now goto default
    //

    case WINNT_COMPUTER_ID:

        hr = WinNTDeleteComputer(pObjectInfo, _Credentials);
        break;

    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CWinNTDomain::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    return MoveUserGroupObject(SourceName,
                               NewName,
                               _ADsPath,
                               _Credentials,
                               ppObject);
}

/* IADsDomain methods */

STDMETHODIMP
CWinNTDomain::get_IsWorkgroup(THIS_ VARIANT_BOOL FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CWinNTDomain::AllocateDomainObject(
    CWinNTDomain ** ppDomain
    )
{
    CWinNTDomain FAR * pDomain = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pDomain = new CWinNTDomain();
    if (pDomain == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDomain,
                (IADsDomain *)pDomain,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pDomain,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pDomain,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             DomainClass,
             gdwDomainTableSize,
             (CCoreADsObject *)pDomain,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);


    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pDomain->_pPropertyCache = pPropertyCache;
    pDomain->_pDispMgr = pDispMgr;
    *ppDomain = pDomain;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pDomain;

    RRETURN(hr);

}


STDMETHODIMP
CWinNTDomain::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szPDCName[MAX_PATH];

    hr = WinNTGetCachedDCName(
                _Name,
                szPDCName,
                _Credentials.GetFlags()
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(lpBuffer, dwApiLevel, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTDomain::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr;

    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        hr = UnMarshall_Level0(fExplicit, (LPUSER_MODALS_INFO_0)lpBuffer);
        break;

    case 2:
        hr = UnMarshall_Level2(fExplicit, (LPUSER_MODALS_INFO_2)lpBuffer);
        break;


    case 3:
        hr = UnMarshall_Level3(fExplicit, (LPUSER_MODALS_INFO_3)lpBuffer);
        break;

    default:
        hr = E_FAIL;

    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomain::UnMarshall_Level0(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_0 pUserInfo0
    )
{

    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordLength"),
                pUserInfo0->usrmod0_min_passwd_len,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxPasswordAge"),
                pUserInfo0->usrmod0_max_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordAge"),
                pUserInfo0->usrmod0_min_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordHistoryLength"),
                pUserInfo0->usrmod0_password_hist_len,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomain::UnMarshall_Level2(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTDomain::UnMarshall_Level3(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("AutoUnlockInterval"),
                pUserInfo3->usrmod3_lockout_duration,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("LockoutObservationInterval"),
                pUserInfo3->usrmod3_lockout_observation_window,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxBadPasswordsAllowed"),
                pUserInfo3->usrmod3_lockout_threshold,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CWinNTDomain::SetInfo(THIS_ DWORD dwApiLevel)
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    LPBYTE lpBuffer = NULL;
    DWORD dwParamErr = 0;
    WCHAR szPDCName[MAX_PATH];


    hr = WinNTGetCachedDCName(
                    _Name,
                    szPDCName,
                    _Credentials.GetFlags()
                    );
    BAIL_ON_FAILURE(hr);


    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);



     hr = MarshallAndSet(szPDCName, lpBuffer, dwApiLevel);
     BAIL_ON_FAILURE(hr);

error:

     if (lpBuffer) {
         NetApiBufferFree(lpBuffer);
     }

     RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTDomain::MarshallAndSet(
    LPWSTR szServerName,
    LPBYTE lpBuffer,
    DWORD  dwApiLevel
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(Marshall_Set_Level0(
                    szServerName,
                    (LPUSER_MODALS_INFO_0)lpBuffer
                    ));
        break;

    case 2:
        RRETURN(Marshall_Set_Level2(
                    szServerName,
                    (LPUSER_MODALS_INFO_2)lpBuffer
                    ));
        break;


    case 3:
        RRETURN(Marshall_Set_Level3(
                    szServerName,
                    (LPUSER_MODALS_INFO_3)lpBuffer
                    ));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CWinNTDomain::Marshall_Set_Level0(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_0 pUserInfo0)
{
    NET_API_STATUS nasStatus;
    DWORD dwParamErr = 0;
    HRESULT hr = S_OK;

    DWORD dwMinPasswdLen = 0;
    DWORD dwMaxPasswdAge = 0;
    DWORD dwMinPasswdAge = 0;
    DWORD dwPasswdHistLen = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordLength"),
                    &dwMinPasswdLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_min_passwd_len = dwMinPasswdLen;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxPasswordAge"),
                    &dwMaxPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_max_passwd_age = dwMaxPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordAge"),
                    &dwMinPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_min_passwd_age = dwMinPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordHistoryLength"),
                    &dwPasswdHistLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_password_hist_len = dwPasswdHistLen;
    }

    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     0,
                     (LPBYTE)pUserInfo0,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
CWinNTDomain::Marshall_Set_Level2(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTDomain::Marshall_Set_Level3(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    DWORD dwParamErr =  0;

    DWORD dwAutoUnlockIntrvl = 0;
    DWORD dwLockoutObsIntrvl = 0;
    DWORD dwMaxBadPasswdsAllowed = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("AutoUnlockInterval"),
                    &dwAutoUnlockIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_duration = dwAutoUnlockIntrvl;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LockoutObservationInterval"),
                    &dwLockoutObsIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_observation_window  = dwLockoutObsIntrvl;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxBadPasswordsAllowed"),
                    &dwMaxBadPasswdsAllowed
                    );


    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_threshold = dwMaxBadPasswdsAllowed;
    }


    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     3,
                     (LPBYTE)pUserInfo3,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//


#include "winnt.hxx"
#pragma hdrstop


//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[199];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct definition
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                (PDWORD)(rgdispid + dw)))) {
                    hr = DISP_E_UNKNOWNNAME;
                    rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();
    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);

    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnTypesOfInfo == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cdompwd.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdompwd.cxx
//
//  Contents:  Domain Password PropertySet
//
//  History:   11-1-95     krishnag    Created.
//
//             PROPERTY_RW(MinPasswordLength, long, 1)          I
//             PROPERTY_RW(MinPasswordAge, long, 2)             I
//             PROPERTY_RW(MaxPasswordAge, long, 3)             I
//             PROPERTY_RW(MaxBadPasswordsAllowed, long, 4)     I
//             PROPERTY_RW(PasswordHistoryLength, long, 5)      I
//             PROPERTY_RW(PasswordAttributes, long, 6)         NI
//             PROPERTY_RW(AutoUnlockInterval, long, 7)           NI
//             PROPERTY_RW(LockoutObservationInterval, long, 8) NI
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTDomain

/* IADsDomain methods */

STDMETHODIMP
CWinNTDomain::get_MinPasswordLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}
STDMETHODIMP
CWinNTDomain::put_MinPasswordLength(THIS_ long lMinPasswordLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}

STDMETHODIMP
CWinNTDomain::get_MinPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CWinNTDomain::put_MinPasswordAge(THIS_ long lMinPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CWinNTDomain::get_MaxPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CWinNTDomain::put_MaxPasswordAge(THIS_ long lMaxPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CWinNTDomain::get_MaxBadPasswordsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CWinNTDomain::put_MaxBadPasswordsAllowed(THIS_ long lMaxBadPasswordsAllowed)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CWinNTDomain::get_PasswordHistoryLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CWinNTDomain::put_PasswordHistoryLength(THIS_ long lPasswordHistoryLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CWinNTDomain::get_PasswordAttributes(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CWinNTDomain::put_PasswordAttributes(THIS_ long lPasswordAttributes)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CWinNTDomain::get_AutoUnlockInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CWinNTDomain::put_AutoUnlockInterval(THIS_ long lAutoUnlockInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CWinNTDomain::get_LockoutObservationInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}

STDMETHODIMP CWinNTDomain::put_LockoutObservationInterval(THIS_ long lLockoutObservationInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenmfpse.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpse.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CFPNWSessionsCollection object
  as well as the CFPNWSessionsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop


#if DBG
DECLARE_INFOLEVEL(FPNWEnumSession);
DECLARE_DEBUG(FPNWEnumSession);
#define FPNWEnumSessionDebugOut(x) FPNWEnumSessionInlineDebugOut x
#endif



CFPNWSessionsCollection::CFPNWSessionsCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pDispMgr = NULL;
    _pCSessionsEnumVar = NULL;
    ENLIST_TRACKING(CFPNWSessionsCollection);
}

CFPNWSessionsCollection::~CFPNWSessionsCollection()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    delete _pDispMgr;
    if(_pCSessionsEnumVar){
        _pCSessionsEnumVar->Release();
    }

}

HRESULT
CFPNWSessionsCollection::Create(LPTSTR pszServerADsPath,
                                CWinNTCredentials& Credentials,
                                 CFPNWSessionsCollection
                                 ** ppCFPNWSessionsCollection )
{

    BOOL fStatus = FALSE;
    HRESULT hr;
    CFPNWSessionsCollection *pCFPNWSessionsCollection = NULL;
    POBJECTINFO  pServerObjectInfo = NULL;

    //
    // create the Sessions collection object
    //

    pCFPNWSessionsCollection = new CFPNWSessionsCollection();

    if(pCFPNWSessionsCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSessionsCollection->_pszServerADsPath   =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWSessionsCollection->_pszServerADsPath  )){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);



    pCFPNWSessionsCollection->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWSessionsCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSessionsCollection->_Credentials = Credentials;
    hr = pCFPNWSessionsCollection->_Credentials.RefServer(
        pCFPNWSessionsCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    pCFPNWSessionsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWSessionsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCFPNWSessionsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCFPNWSessionsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    hr = CFPNWSessionsEnumVar::Create(pszServerADsPath,
                                      pCFPNWSessionsCollection->_Credentials,
                                      &pCFPNWSessionsCollection->_pCSessionsEnumVar);

    BAIL_IF_ERROR(hr);

    *ppCFPNWSessionsCollection = pCFPNWSessionsCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCFPNWSessionsCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Sessions collection object  */

STDMETHODIMP
CFPNWSessionsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

DEFINE_IDispatch_Implementation(CFPNWSessionsCollection);

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWSessionsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADsCollection methods */


STDMETHODIMP
CFPNWSessionsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;


    ADsAssert(_pCSessionsEnumVar);

    hr = _pCSessionsEnumVar->QueryInterface(IID_IUnknown, (void **)retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSessionsCollection::GetObject(THIS_ BSTR bstrSessionName,
                                   VARIANT *pvar
                                   )

{

    //
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    HRESULT hr;

    hr = _pCSessionsEnumVar->GetObject(bstrSessionName, pvar);

    RRETURN_EXP_IF_ERR(hr);

/*
    LPTSTR  pszSession = NULL;
    IDispatch *pDispatch = NULL;
    HRESULT hr;

    if(!bstrSessionName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = CFPNWSession::Create(_pszServerADsPath,

                              ADS_OBJECT_BOUND,
                              IID_IDispatch,
                              _Credentials,
                              (void **)&pDispatch);


    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);
    */
}

STDMETHODIMP
CFPNWSessionsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWSessionsCollection::Remove(THIS_ BSTR bstrSessionName)
{

    HRESULT hr = S_OK;
    DWORD dwConnectionId;
    DWORD dwErrorCode;

    dwConnectionId  = (DWORD)_wtol(bstrSessionName);

    dwErrorCode = ADsNwConnectionDel(_pszServerName,
                                  dwConnectionId);

    if(dwErrorCode != NERR_Success){
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//
// CFPNWSessionsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::CFPNWSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWSessionsEnumVar::CFPNWSessionsEnumVar()
{

    _pszServerName = NULL;
    _pszServerADsPath = NULL;
    _pbSessions = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::~CFPNWSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWSessionsEnumVar::~CFPNWSessionsEnumVar()
{

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pbSessions){
        NetApiBufferFree(_pbSessions);
    }
}


HRESULT CFPNWSessionsEnumVar::Create(LPTSTR pszServerADsPath,
                                     CWinNTCredentials& Credentials,
                                      CFPNWSessionsEnumVar \
                                      **ppCSessionsEnumVar
                                     )
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CFPNWSessionsEnumVar FAR* pCSessionsEnumVar = NULL;

    *ppCSessionsEnumVar = NULL;

    pCSessionsEnumVar = new CFPNWSessionsEnumVar();

    if (pCSessionsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCSessionsEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCSessionsEnumVar->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCSessionsEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_Credentials = Credentials;
    hr = pCSessionsEnumVar->_Credentials.RefServer(
        pCSessionsEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    *ppCSessionsEnumVar = pCSessionsEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Session objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWSessionsEnumVar::Next(ULONG ulNumElementsRequested,
                            VARIANT FAR* pvar,
                            ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG ulIndex;
    LONG lNewCurrent;
    ULONG lNumFetched;
    PNWCONNECTIONINFO  pConnectionInfo;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Initialize the elements to be returned
    //

    for (ulIndex= 0; ulIndex < ulNumElementsRequested; ulIndex++){
        VariantInit(&pvar[ulIndex]);
    }

    if(!_pbSessions || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbSessions){
            NetApiBufferFree(_pbSessions);
            _pbSessions = NULL;
        }

        hresult = FPNWEnumSessions(_pszServerName,
                                   &_cElements,
                                   &_dwResumeHandle,
                                   &_pbSessions);

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;

    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        pConnectionInfo = (PNWCONNECTIONINFO)(_pbSessions +
                          lNewCurrent*sizeof(NWCONNECTIONINFO));

        hresult = CFPNWSession::Create((LPTSTR)_pszServerADsPath,
                                       pConnectionInfo,
                                       ADS_OBJECT_BOUND,
                                       IID_IDispatch,
                                       _Credentials,
                                       (void **)&pDispatch);

        BAIL_ON_FAILURE(hresult);

        V_VT(&(pvar[lNumFetched])) = VT_DISPATCH;
        V_DISPATCH(&(pvar[lNumFetched])) = pDispatch;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:
#if DBG
    if(FAILED(hresult)){
        FPNWEnumSessionDebugOut((DEB_TRACE,
                                 "hresult Failed with value: %ld \n", hresult ));
    }
#endif

    RRETURN(S_FALSE);
}

//
// helper function
//

HRESULT
CFPNWSessionsEnumVar::GetObject(BSTR bstrSessionName, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    DWORD dwConnectionId;
    PNWCONNECTIONINFO pConnectionInfo = NULL;
    IDispatch *pDispatch = NULL;
    DWORD i;

    if(!_pbSessions){
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    dwConnectionId = (DWORD)_wtol(bstrSessionName);

    for( i=0; i<_cElements; i++){
        pConnectionInfo = (PNWCONNECTIONINFO)(_pbSessions+
                                              i*sizeof(PNWCONNECTIONINFO));

        if(pConnectionInfo->dwConnectionId = dwConnectionId){
            //
            // return this struct in the static create for the object
            //
            hr = CFPNWSession::Create(_pszServerADsPath,
                                     pConnectionInfo,
                                     ADS_OBJECT_BOUND,
                                     IID_IDispatch,
                                     _Credentials,
                                     (void **) &pDispatch );

            BAIL_IF_ERROR(hr);

            break;
        }
    }

    if(i == _cElements){
        //
        // no such element
        //
        hr = E_ADS_UNKNOWN_OBJECT;
        goto cleanup;

    }

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
FPNWEnumSessions(LPTSTR pszServerName,
                 PDWORD pdwEntriesRead,
                 PDWORD pdwResumeHandle,
                 LPBYTE * ppMem
                 )

{
    DWORD dwErrorCode;

    dwErrorCode = ADsNwConnectionEnum(pszServerName,
                                        1,         //info level desired
                                        (PNWCONNECTIONINFO *)ppMem,
                                        pdwEntriesRead,
                                        pdwResumeHandle);

    if(*ppMem == NULL || (dwErrorCode != NERR_Success)){
        //
        //no more entries returned by sessions
        //
        RRETURN(S_FALSE);
    }


    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenmfpsh.cxx ===
/*++


  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpsh.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a 
  server. Has methods for the CFPNWFileSharesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(FPNWEnumFileShare);
DECLARE_DEBUG(FPNWEnumFileShare);
#define FPNWEnumFileShareDebugOut(x) FPNWEnumFileShareInlineDebugOut x
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::CFPNWFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWFileSharesEnumVar::CFPNWFileSharesEnumVar()
{
    _pszADsPath = NULL;
    _pszServerName = NULL;
    _pbFileShares = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;  
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;
    VariantInit(&_vFilter); 
}   

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::~CFPNWFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWFileSharesEnumVar::~CFPNWFileSharesEnumVar()
{
    
    if(_pszADsPath){
        FreeADsStr(_pszADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pbFileShares){
        NetApiBufferFree(_pbFileShares);
    }
    VariantClear(&_vFilter);
}


HRESULT CFPNWFileSharesEnumVar::Create(LPTSTR pszServerName,
                                       LPTSTR pszADsPath,
                                       CFPNWFileSharesEnumVar **ppCFileSharesEnumVar,
                                       VARIANT vFilter,
                                       CWinNTCredentials& Credentials
                                        )
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;

    CFPNWFileSharesEnumVar FAR* pCFileSharesEnumVar = NULL;

    *ppCFileSharesEnumVar = NULL;
    
    pCFileSharesEnumVar = new CFPNWFileSharesEnumVar();
    if (pCFileSharesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }   



    pCFileSharesEnumVar->_pszServerName = 
        AllocADsStr(pszServerName);

    if(!(pCFileSharesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFileSharesEnumVar->_pszADsPath = 
        AllocADsStr(pszADsPath);

    if(!(pCFileSharesEnumVar->_pszADsPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = VariantCopy(&(pCFileSharesEnumVar->_vFilter), &vFilter);
    BAIL_ON_FAILURE(hr);
    
    pCFileSharesEnumVar->_Credentials = Credentials;
    hr = pCFileSharesEnumVar->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);

    *ppCFileSharesEnumVar = pCFileSharesEnumVar;
    RRETURN(hr);   
    
error:

    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Share objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [ulNumFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileSharesEnumVar::Next(ULONG ulNumElementsRequested,
                              VARIANT FAR* pvar,
                              ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    ULONG lNewCurrent;
    ULONG lNumFetched;
    PNWVOLUMEINFO  pVolumeInfo = NULL;
    VARIANT v;
    IDispatch * pDispatch = NULL;
    

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //                       
    // Initialize the elements to be returned
    //
    
    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }
    
    if(!_pbFileShares ||(_lCurrentPosition == _lLBound +(LONG)_cElements)){
        if (_pbFileShares){
            ADsNwApiBufferFree(_pbFileShares);
            _pbFileShares = NULL;
        }
        
        if(!(ValidateFilterValue(_vFilter))){
            RRETURN(S_FALSE);
        }

        hresult = FPNWEnumFileShares(_pszServerName,
                                     &_cElements,
                                     &_dwResumeHandle,
                                     &_pbFileShares);
        if(hresult == S_FALSE){
            goto cleanup;
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }
    
    //
    // Get each element and place it into the return array
    // Don't request more than we have    
    //

    lNumFetched = 0;
    lNewCurrent = _lCurrentPosition;

    while((lNumFetched < ulNumElementsRequested) ||
          (lNewCurrent< _lLBound +_cElements ))
    {

        
        pVolumeInfo = (PNWVOLUMEINFO)(_pbFileShares +
                                      lNewCurrent*sizeof(NWVOLUMEINFO));
        
        if(pVolumeInfo->dwType == FPNWVOL_TYPE_DISKTREE){
            //
            // file share object
            //
            hresult = CFPNWFileShare::Create((LPTSTR)_pszADsPath,
                                             _pszServerName,
                                             FILESHARE_CLASS_NAME,
                                             pVolumeInfo->lpVolumeName,
                                             ADS_OBJECT_BOUND,
                                             IID_IDispatch,
                                             _Credentials,
                                             (void **)&pDispatch);  
            
            
            BAIL_IF_ERROR(hresult);
            
            VariantInit(&v);
            V_VT(&v) = VT_DISPATCH;
            V_DISPATCH(&v) = pDispatch;    
            pvar[lNumFetched] = v;
            
            lNumFetched++;
        }
        
        lNewCurrent++;

        if(lNumFetched == ulNumElementsRequested){
            //
            // we got all elements 
            //
            break;
        }

        if(lNewCurrent==(_lLBound+_cElements)){

            //
            // first free our current buffer
            //

            if(_pbFileShares){
                ADsNwApiBufferFree(_pbFileShares);
                _pbFileShares = NULL;
            }

            hresult = FPNWEnumFileShares(_pszServerName,
                                         &_cElements,
                                         &_dwResumeHandle,
                                         &_pbFileShares);
            if(hresult == S_FALSE){
                break;
            } 
  
            _lLBound = 0;
            _lCurrentPosition = _lLBound;
            lNewCurrent = _lCurrentPosition;
        }

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //
    
    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;
    
    _lCurrentPosition = lNewCurrent;
    
    //    
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //
    
    return (lNumFetched < ulNumElementsRequested) ? 
        S_FALSE 
            : S_OK;

cleanup:
    if(_pbFileShares){
        ADsNwApiBufferFree(_pbFileShares);
    }    
    if(FAILED(hresult)){
       #if DBG
       FPNWEnumFileShareDebugOut((DEB_TRACE,
                         "hresult Failed with value: %ld \n", hresult ));
       #endif
    }
        
    RRETURN(S_FALSE);
}

HRESULT 
FPNWEnumFileShares(LPTSTR pszServerName,
                   PDWORD pdwElements,
                   PDWORD pdwResumeHandle,
                   LPBYTE * ppMem
                   )     
{
    
    NET_API_STATUS nasStatus;
    DWORD dwErrorCode;

    //
    // assumption: *ppMem = NULL when passed here
    //

    dwErrorCode = ADsNwVolumeEnum(pszServerName,
                               1,
                               (PNWVOLUMEINFO *)ppMem,
                               pdwElements,
                               pdwResumeHandle);
    

    if(dwErrorCode != NERR_Success || (*ppMem == NULL )){
                //
                // NwVolumeEnum returns NERR_Success even when there 
                // aren't any more items to enumerate
                //

        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumcom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cenumcom.cxx
//
//  Contents:  Windows NT 4.0 Enumeration code for computer container
//
//              CWinNTComputerEnum::CWinNTComputerEnum()
//              CWinNTComputerEnum::CWinNTComputerEnum
//              CWinNTComputerEnum::EnumObjects
//              CWinNTComputerEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumComp);
DECLARE_DEBUG(EnumComp);
#define EnumCompDebugOut(x) EnumCompInlineDebugOut x
#endif



//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTComputerEnum::Create(
    CWinNTComputerEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ComputerName,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTComputerEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTComputerEnum();

    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ComputerName, &penumvariant->_ComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.RefServer(ComputerName);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}



CWinNTComputerEnum::CWinNTComputerEnum():
                            _ComputerName(NULL),
                            _DomainName(NULL),
                            _ADsPath(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _bNoMore = 0;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;


    _pPrinterBuffer = NULL;
    _dwPrinterObjectReturned = 0;
    _dwPrinterObjectCurrentEntry = 0;
    _dwPrinterObjectTotal = 0;
    _fPrinterNoMore = 0;

    _pServiceBuffer = NULL;
    _dwServiceObjectReturned = 0;
    _dwServiceObjectCurrentEntry = 0;
    _dwServiceObjectTotal = 0;
    _fServiceNoMore = 0;
    _dwIndex = 0;


}



CWinNTComputerEnum::CWinNTComputerEnum(ObjectTypeList ObjList):
                                _ComputerName(NULL),
                                _DomainName(NULL),
                                _ADsPath(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _bNoMore = 0;
    _dwObjectReturned = 0;
    _dwObjectTotal = 0;
    _dwObjectCurrentEntry = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;

    _pPrinterBuffer = NULL;
    _dwPrinterObjectReturned = 0;
    _dwPrinterObjectCurrentEntry = 0;
    _dwPrinterObjectTotal = 0;
    _fPrinterNoMore = FALSE;

    _pServiceBuffer = NULL;
    _dwServiceObjectReturned = 0;
    _dwServiceObjectCurrentEntry = 0;
    _dwServiceObjectTotal = 0;
    _fServiceNoMore = FALSE;
    _dwIndex = 0;

}

CWinNTComputerEnum::~CWinNTComputerEnum()
{
    if (_pServiceBuffer) {
        FreeADsMem(_pServiceBuffer);
    }

    if(_pPrinterBuffer){
        FreeADsMem(_pPrinterBuffer);
    }

    if (_hLGroupComputer) {

        WinNTCloseComputer(_hLGroupComputer);

    }

    if (_hGGroupComputer) {

        WinNTCloseComputer(_hGGroupComputer);
    }

    if (_ComputerName) {
        ADsFreeString(_ComputerName);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_pObjList) {

        delete _pObjList;
    }


}

HRESULT
CWinNTComputerEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{

    HRESULT hr = S_OK ;
    DWORD cElementLocal = 0;
    DWORD cElementGlobal = 0;

    switch (ObjectType) {

    case WINNT_GROUP_ID:

        //
        // for backward compatabillity, "group" includes "local group" and
        // "global group" during enumeration
        //

        //
        // enum local groups first
        //

        hr = EnumGroupObjects(WINNT_GROUP_LOCAL,
							  cElements,
							  pvar,
                              &cElementLocal
							  );

        if (hr == S_FALSE) {

            //
            // enum global groups after all local groups have been enumerated
            //

            hr = EnumGroupObjects(WINNT_GROUP_GLOBAL,
							  cElements-cElementLocal,
							  pvar+cElementLocal,
							  &cElementGlobal
                              );
        }


        //
        // increment instead of assingn: consistent with other switch cases
        //

        (*pcElementFetched) += (cElementGlobal+cElementLocal);

        break;


    case WINNT_LOCALGROUP_ID:
        hr = EnumGroupObjects(WINNT_GROUP_LOCAL,
							  cElements,
							  pvar,
							  pcElementFetched);
        break;


    case WINNT_GLOBALGROUP_ID:
        hr = EnumGroupObjects(WINNT_GROUP_GLOBAL,
							  cElements,
							  pvar,
							  pcElementFetched);
        break;


    case WINNT_USER_ID:
        hr = EnumUsers(cElements, pvar, pcElementFetched);
        break;
    case WINNT_PRINTER_ID:
        hr = EnumPrintQueues(cElements, pvar, pcElementFetched);
        break;
    case WINNT_SERVICE_ID:
        hr = EnumServices(cElements, pvar, pcElementFetched);
        break;
    default:
        hr = S_FALSE;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            return(ResultFromScode(S_FALSE));
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::EnumUsers(ULONG cElements,
                     VARIANT FAR* pvar,
                     ULONG FAR* pcElementFetched)
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

HRESULT
CWinNTComputerEnum::GetUserObject(IDispatch ** ppDispatch)
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_USER pUserInfo1 = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;
    WCHAR szBuffer[MAX_PATH];

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        wcscpy(szBuffer, L"\\\\");
        wcscat(szBuffer, _ComputerName);

        nasStatus = NetQueryDisplayInformation(
                            szBuffer,
                            1,
                            _dwIndex,
                            1024,
                            MAX_PREFERRED_LENGTH,
                            &_dwObjectReturned,
                            (PVOID *)&_pBuffer
                            );
        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pBuffer) {
            RRETURN(S_FALSE);
        }

        _dwIndex  = ((PNET_DISPLAY_USER)_pBuffer + _dwObjectReturned -1)->usri1_next_index;

    }

    //
    // Now send back the current ovbject
    //

    pUserInfo1 = (PNET_DISPLAY_USER)_pBuffer;
    pUserInfo1 += _dwObjectCurrentEntry;

    hr = CWinNTUser::CreateUser(
                        _ADsPath,
                        WINNT_COMPUTER_ID,
                        NULL,
                        _ComputerName,
                        pUserInfo1->usri1_name,
                        ADS_OBJECT_BOUND,
                        &(pUserInfo1->usri1_flags),
                        pUserInfo1->usri1_full_name,
                        pUserInfo1->usri1_comment,
                        NULL,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTComputerEnum::EnumPrintQueues(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )

{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetPrinterObject(&pDispatch);
        if (hr != S_OK) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

HRESULT
CWinNTComputerEnum::GetPrinterObject(IDispatch **ppDispatch)
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    NET_API_STATUS nasStatus = NERR_Success;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufLen       = 0;
    WCHAR szPrintObjectName[MAX_PATH];
    BOOL fStatus;
    DWORD dwLastError;
    LPBYTE pMem = NULL;
    PRINTER_INFO_2 * pPrinterInfo2 = NULL;
    WCHAR   szDomainName[MAX_PATH];

    if(!_pPrinterBuffer || (_dwPrinterObjectCurrentEntry == _dwPrinterObjectReturned)){

       if (_pPrinterBuffer) {

           FreeADsMem(_pPrinterBuffer);
           _pPrinterBuffer = NULL;

       }

       if (_fPrinterNoMore) {
          *ppDispatch = NULL;
          return(S_FALSE);
       }

       _dwPrinterObjectCurrentEntry = 0;
       _dwPrinterObjectReturned = 0;

       wcscpy(szPrintObjectName, TEXT("\\\\"));
       wcscat(szPrintObjectName, _ComputerName);

       fStatus = WinNTEnumPrinters(
                    PRINTER_ENUM_NAME| PRINTER_ENUM_SHARED,
                    szPrintObjectName,
                    2,
                    (LPBYTE *)&_pPrinterBuffer,
                    &_dwPrinterObjectReturned
                    );

        if (!fStatus || !_dwPrinterObjectReturned) {

            _fPrinterNoMore = TRUE;
            RRETURN(S_FALSE);
        }


    }

    pPrinterInfo2 = (PRINTER_INFO_2 *)_pPrinterBuffer;
    pPrinterInfo2 += _dwPrinterObjectCurrentEntry;

    hr = CWinNTPrintQueue::CreatePrintQueue(
                     _ADsPath,
                     WINNT_COMPUTER_ID,
                     szDomainName,
                     _ComputerName,
                     pPrinterInfo2->pShareName,
                     ADS_OBJECT_BOUND,
                     IID_IDispatch,
                     _Credentials,
                     (void **)ppDispatch
                     );

    BAIL_IF_ERROR(hr);

    _dwPrinterObjectCurrentEntry++;

    if(_dwPrinterObjectCurrentEntry == _dwPrinterObjectReturned){
        _fPrinterNoMore = TRUE;
    }


cleanup:
    if(FAILED(hr)){
       *ppDispatch = NULL;
#if DBG


       EnumCompDebugOut((DEB_TRACE,
                         "hr Failed with value: %ld \n", hr ));

#endif
       hr = S_FALSE; // something else may have failed!
    }
    RRETURN_EXP_IF_ERR(hr);
}




HRESULT
CWinNTComputerEnum::EnumServices(
    ULONG cElements,
     VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )

{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetServiceObject(&pDispatch);
        if (hr != S_OK) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);

}

HRESULT
CWinNTComputerEnum::GetServiceObject(IDispatch **ppDispatch)
{

    HRESULT hr = S_OK;
    LPBYTE pMem = NULL;
    DWORD dwBytesNeeded = 0;
    NET_API_STATUS nasStatus = NERR_Success;
    WCHAR szBuffer[MAX_PATH];
    ENUM_SERVICE_STATUS *pqssBuf;
    WCHAR szDomainName[MAX_PATH];

    if(!_pServiceBuffer || (_fServiceNoMore == TRUE )){

       if(_pServiceBuffer){
           FreeADsMem(_pServiceBuffer);
           _pServiceBuffer = NULL;
       }

       if (_fServiceNoMore == TRUE) {
           *ppDispatch = NULL;
           return(S_FALSE);
       }

       _dwServiceObjectCurrentEntry = 0;
       _dwServiceObjectReturned = 0;


       hr = WinNTEnumServices( _ComputerName,
                               &_dwServiceObjectReturned,
                               &_pServiceBuffer
                             );

       BAIL_IF_ERROR(hr);

       if(hr == S_FALSE){
          _fServiceNoMore = TRUE;
          *ppDispatch = NULL;
          goto cleanup;
       }

    }

    hr = GetDomainFromPath(_ADsPath, szDomainName);
    BAIL_IF_ERROR(hr);

    pqssBuf = (ENUM_SERVICE_STATUS *)_pServiceBuffer;
    pqssBuf += _dwServiceObjectCurrentEntry;

    hr = CWinNTService::Create(_ADsPath,
                               szDomainName,
                               _ComputerName,
                               pqssBuf->lpServiceName,
                               ADS_OBJECT_BOUND,
                               IID_IDispatch,
                               _Credentials,
                               (void **)ppDispatch);

    BAIL_IF_ERROR(hr);

    _dwServiceObjectCurrentEntry++;

    if(_dwServiceObjectCurrentEntry == _dwServiceObjectReturned){
       _fServiceNoMore = TRUE;
    }

cleanup:
    if(FAILED(hr)){
#if DBG
        EnumCompDebugOut((DEB_TRACE,
                          "hr Failed with value: %ld \n", hr ));

#endif
        hr = S_FALSE;
    }
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CWinNTComputerEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTComputerEnum::Next(ULONG cElements,
                        VARIANT FAR* pvar,
                        ULONG FAR* pcElementFetched)
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(cElements,
                       pvar,
                       &cElementFetched
                      );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::GetGlobalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hGGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        _ComputerName,
                        WINNT_COMPUTER_ID,
                        &_hGGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumGlobalGroups(
                    _hGGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_COMPUTER_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_GLOBAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;
}

HRESULT
CWinNTComputerEnum::GetLocalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hLGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        _ComputerName,
                        WINNT_COMPUTER_ID,
                        &_hLGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumLocalGroups(
                    _hLGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_COMPUTER_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_LOCAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

   if (pBuffer) {
       FreeADsMem(pBuffer);

   }

   RRETURN(hr);

error:
    *ppDispatch = NULL;

    //
    // We missed a member so return E_FAIL if that was the error
    // as we would still like to get at the other groups
    //
    if (hr != E_FAIL) {
        hr = S_FALSE;
    }

    goto cleanup;
}

HRESULT
CWinNTComputerEnum::EnumGroupObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK ;

    switch (ObjectType) {

    case WINNT_GROUP_GLOBAL:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_LOCAL:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    default:
        hr = S_FALSE;
    }
    RRETURN(hr);
}


extern ULONG GroupTypeArray[];


HRESULT
CWinNTComputerEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while ((GroupTypeArray[_dwGroupArrayIndex] != (ULONG)-1) &&
            ((hr = EnumGroupObjects(
                               GroupTypeArray[_dwGroupArrayIndex],
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (GroupTypeArray[_dwGroupArrayIndex++] == (ULONG)-1){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

HRESULT
CWinNTComputerEnum::EnumGlobalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGlobalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTComputerEnum::EnumLocalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        //
        // Need to set it here in case we are getting multiple elements
        //
        hr = E_FAIL;

        //
        // We use a while loop in case a get of one of the objects fails
        // because it has a long pathname or otherwise
        //
        while (hr == E_FAIL) {
            hr = GetLocalGroupObject(&pDispatch);
        }
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenmfpre.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpre.cxx

  Abstract:

  Contains methods for implementing the Enumeration of resources(open files)
  on a  server. Has methods for the CFPNWResourcesCollection object
  as well as the CFPNWResourcesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 03/12/96

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop


CFPNWResourcesCollection::CFPNWResourcesCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;

    _pDispMgr = NULL;
    _pCResourcesEnumVar = NULL;
    ENLIST_TRACKING(CFPNWResourcesCollection);
}

CFPNWResourcesCollection::~CFPNWResourcesCollection()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pDispMgr;
    if(_pCResourcesEnumVar){
        _pCResourcesEnumVar->Release();
    }

}

HRESULT
CFPNWResourcesCollection::Create(LPTSTR pszServerADsPath,
                                 LPTSTR pszBasePath,
                                 CWinNTCredentials& Credentials,
                                 CFPNWResourcesCollection
                                 ** ppCFPNWResourcesCollection 
                                 )
{

    BOOL fStatus = FALSE, LastError;
    HRESULT hr;
    CFPNWResourcesCollection *pCFPNWResourcesCollection = NULL;
    POBJECTINFO pServerObjectInfo = NULL;
    //
    // create the Resources collection object
    //

    pCFPNWResourcesCollection = new CFPNWResourcesCollection();

    if(pCFPNWResourcesCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCFPNWResourcesCollection->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!pCFPNWResourcesCollection->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );

    BAIL_IF_ERROR(hr);


    pCFPNWResourcesCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCFPNWResourcesCollection->_pszServerName){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWResourcesCollection->_Credentials = Credentials;
    hr = pCFPNWResourcesCollection->_Credentials.RefServer(
        pCFPNWResourcesCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){

        pCFPNWResourcesCollection->_pszBasePath = 
            AllocADsStr(pszBasePath);
        
        if(!pCFPNWResourcesCollection->_pszBasePath){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }


    }

    pCFPNWResourcesCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWResourcesCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCFPNWResourcesCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCFPNWResourcesCollection,
                           DISPID_NEWENUM);

    BAIL_IF_ERROR(hr);

    hr = CFPNWResourcesEnumVar::Create(pszServerADsPath,
                                       pszBasePath,
                                       pCFPNWResourcesCollection->_Credentials,
                                       &pCFPNWResourcesCollection->_pCResourcesEnumVar);

    BAIL_IF_ERROR(hr);

    *ppCFPNWResourcesCollection =pCFPNWResourcesCollection;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCFPNWResourcesCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Resources collection object  */

STDMETHODIMP
CFPNWResourcesCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }
    
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWResourcesCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CFPNWResourcesCollection);

/* IADsCollection methods */

STDMETHODIMP
CFPNWResourcesCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CFPNWResourcesEnumVar *pCResourcesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    ADsAssert(_pCResourcesEnumVar);

    hr = _pCResourcesEnumVar->QueryInterface(IID_IUnknown, (void **)retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResourcesCollection::GetObject(THIS_ BSTR bstrResourceName,
                                     VARIANT *pvar
                                     ) 

{

    // 
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    HRESULT hr;

    hr = _pCResourcesEnumVar->GetObject(bstrResourceName, pvar);

    RRETURN_EXP_IF_ERR(hr);
                                      
/*
    HRESULT hr = S_OK;
    DWORD   dwFileId;
    IDispatch *pDispatch = NULL;
 
    if(!bstrResourceName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a fileid
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    hr = CFPNWResource::Create((LPTSTR)_bstrServerADsPath,
                                ADS_OBJECT_BOUND,
                                dwFileId,
                                IID_IDispatch,
                                _Credentials,
                                (void **)&pDispatch);

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);

*/

}


STDMETHODIMP 
CFPNWResourcesCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP
CFPNWResourcesCollection::Remove(THIS_ BSTR bstrResourceName) 

{
    
    RRETURN_EXP_IF_ERR(E_NOTIMPL);    
}


//
// CFPNWResourcesEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::CFPNWResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWResourcesEnumVar::CFPNWResourcesEnumVar()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;
    _pbResources = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::~CFPNWResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWResourcesEnumVar::~CFPNWResourcesEnumVar()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbResources){
        NetApiBufferFree(_pbResources);
    }
}


HRESULT CFPNWResourcesEnumVar::Create(LPTSTR pszServerADsPath,
                                       LPTSTR pszBasePath,
                                       CWinNTCredentials& Credentials,
                                       CFPNWResourcesEnumVar
                                       **ppCResourcesEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CFPNWResourcesEnumVar FAR* pCResourcesEnumVar = NULL;

    *ppCResourcesEnumVar = NULL;

    pCResourcesEnumVar = new CFPNWResourcesEnumVar();

    if (pCResourcesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!pCResourcesEnumVar->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);


    pCResourcesEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCResourcesEnumVar->_pszServerName){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_Credentials = Credentials;
    hr = pCResourcesEnumVar->_Credentials.RefServer(
        pCResourcesEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

 
    if(pszBasePath){

        pCResourcesEnumVar->_pszBasePath = 
            AllocADsStr(pszBasePath);
        
        if(!pCResourcesEnumVar->_pszBasePath){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    *ppCResourcesEnumVar = pCResourcesEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Resource objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWResourcesEnumVar::Next(ULONG ulNumElementsRequested,
                             VARIANT FAR* pvar,
                             ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched;
    PNWFILEINFO pFileInfo;
    VARIANT v;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbResources || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbResources){
            NetApiBufferFree(_pbResources);
            _pbResources = NULL;
        }

        hresult = FPNWEnumResources(_pszServerName,
                                    _pszBasePath,
                                    &_pbResources,
                                    &_cElements,
                                    &_dwResumeHandle);

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        pFileInfo = (PNWFILEINFO)(_pbResources + \
                                     lNewCurrent*sizeof(NWFILEINFO));


        hresult = CFPNWResource::Create(_pszServerADsPath,
                                        pFileInfo,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);


        BAIL_ON_FAILURE(hresult);

        VariantInit(&v);
        V_VT(&v) = VT_DISPATCH;
        V_DISPATCH(&v) = pDispatch;
        pvar[lNumFetched] = v;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:

    RRETURN(S_FALSE);
}


HRESULT
FPNWEnumResources(LPTSTR pszServerName,
                   LPTSTR pszBasePath,
                   LPBYTE * ppMem,
                   LPDWORD pdwEntriesRead,
                   LPDWORD pdwResumeHandle
                   )

{
    HRESULT hr;
    DWORD dwErrorCode;

    dwErrorCode = ADsNwFileEnum(pszServerName,
                                  1,
                                  pszBasePath,
                                  (PNWFILEINFO *) ppMem,
                                  pdwEntriesRead,
                                  pdwResumeHandle);

    if(*ppMem == NULL|| (dwErrorCode != NERR_Success)){
        //
        // no more entries returned by NwFileEnum
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}

//
// helper function
//

HRESULT 
CFPNWResourcesEnumVar::GetObject(BSTR bstrResourceName, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    DWORD dwFileId;
    PNWFILEINFO pFileInfo = NULL;
    IDispatch *pDispatch = NULL;
    DWORD i;

    if(!_pbResources){
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    // 
    // scan the buffer _pbResources to find one where the ConnectionId
    // matches the one in bstrResourceName and get this object
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    for( i=0; i<_cElements; i++){
        pFileInfo = (PNWFILEINFO)(_pbResources+ i*sizeof(PNWFILEINFO));
        
        if(pFileInfo->dwFileId = dwFileId){
            //
            // return this struct in the static create for the object
            //
            hr = CFPNWResource::Create(_pszServerADsPath,
                                       pFileInfo,
                                       ADS_OBJECT_BOUND,
                                       IID_IDispatch,
                                       _Credentials,
                                       (void **) &pDispatch );
            
            BAIL_IF_ERROR(hr);
                                
            break;
        } 
    }

    if(i == _cElements){
        //
        // no such element
        //
        hr = E_ADS_UNKNOWN_OBJECT;
        goto cleanup;

    }        

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;
        
cleanup:
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenmlgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum()
//              CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum
//              CWinNTLocalGroupCollectionEnum::EnumObjects
//              CWinNTLocalGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTLocalGroupCollectionEnum::Create(
    CWinNTLocalGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTLocalGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTLocalGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_GroupType = GroupType;


    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum():
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)

{
    _pObjList = NULL;
}



CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum(ObjectTypeList ObjList):
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)
{
    _pObjList = NULL;
}

CWinNTLocalGroupCollectionEnum::~CWinNTLocalGroupCollectionEnum()
{

    if (_hGroup) {


        if (_GroupType == WINNT_GROUP_GLOBAL) {


            WinNTGlobalGroupClose(
                            _hGroup
                            );
        }else {

            WinNTLocalGroupClose(
                        _hGroup
                        );
        }

    }


    if (_pObjList) {

        delete _pObjList;
    }

    if (_lpServerName) {

        FreeADsStr(_lpServerName) ;
    }

    if(_Parent) {

    	ADsFreeString(_Parent);
    }

    if(_DomainName) {

    	ADsFreeString(_DomainName);
    }

    if(_ServerName) {

    	ADsFreeString(_ServerName);
    }

    if(_ADsPath) {

    	ADsFreeString(_ADsPath);
    }

    if(_GroupName) {

    	ADsFreeString(_GroupName);
    }
}

HRESULT
CWinNTLocalGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;

    while (i < cElements) {

        hr = GetComputerMemberObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);

                if (SUCCEEDED(hr)
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }


                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTLocalGroupCollectionEnum::GetComputerMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hGroup) {
        dwRet = WinNTLocalGroupOpen(
                        _DomainName,
                        _ServerName,
                        _GroupName,
                        &_hGroup
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTLocalGroupEnum(
                    _hGroup,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPCOMPUTER_GROUP_MEMBER)pBuffer;

    switch (pComputerGrpMember->Type) {
    case WINNT_USER_ID :
        hr = CWinNTUser::CreateUser(
                            pComputerGrpMember->Parent,
                            pComputerGrpMember->ParentType,
                            pComputerGrpMember->Domain,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            NULL,   // UserFlags
                            NULL,   // FullName
                            NULL,   // Description
                            pComputerGrpMember->Sid,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    case WINNT_GROUP_ID:
    case WINNT_LOCALGROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            pComputerGrpMember->Parent,
                            pComputerGrpMember->ParentType,
                            pComputerGrpMember->Domain,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            pComputerGrpMember->Type == WINNT_GROUP_ID ?
                                WINNT_GROUP_GLOBAL :
                                WINNT_GROUP_LOCAL,
                            ADS_OBJECT_BOUND,
                            pComputerGrpMember->Sid,                                                        
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                        );
        break;

    default:
        goto error;
    }

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);


error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTLocalGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTLocalGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumdom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  Windows NT 3.5 Domain Enumeration Code
//
//              CWinNTDomainEnum::CWinNTDomainEnum()
//              CWinNTDomainEnum::CWinNTDomainEnum
//              CWinNTDomainEnum::EnumObjects
//              CWinNTDomainEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTDomainEnum::Create(
    CWinNTDomainEnum FAR* FAR* ppenumvariant,
    LPWSTR ADsPath,
    LPWSTR DomainName,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTDomainEnum FAR* penumvariant = NULL;
    NET_API_STATUS  nasStatus = 0;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTDomainEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_ADsPath = AllocADsStr( ADsPath);
    if (!penumvariant->_ADsPath) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    penumvariant->_DomainName = AllocADsStr( DomainName);
    if (!penumvariant->_DomainName) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    //
    // ramv's change. You don't need to do a WinNTGetCachedDCName
    // to validate a domain here. You might be dealing with a
    // workgroup. If this call succeeds then we keep a BOOL variable
    // which tells us next time when it is necessary whether it is a
    // domain or workgroup
    //

    hr = WinNTGetCachedDCName(
                penumvariant->_DomainName,
                penumvariant->_szDomainPDCName,
                Credentials.GetFlags()
                );

    if(SUCCEEDED(hr)){
        penumvariant->_fIsDomain = TRUE;

    } else {
        penumvariant->_fIsDomain = FALSE;
    }

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.RefDomain(DomainName);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(S_OK);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTDomainEnum::CWinNTDomainEnum():
                    _ADsPath(NULL),
                    _DomainName(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _dwObjectReturned = 0;
    _dwIndex = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _dwNetCount = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;


    _dwCompObjectReturned = 0;
    _dwCompObjectCurrentEntry = 0;
    _dwCompObjectTotal = 0;
    _pCompBuffer = 0;
    _dwCompIndex = 0;
    _pServerInfo = NULL;

    _fSchemaReturned = FALSE;

    memset(_szDomainPDCName, 0, sizeof(WCHAR)*MAX_PATH);

}



CWinNTDomainEnum::CWinNTDomainEnum(ObjectTypeList ObjList):
                            _ADsPath(NULL),
                            _DomainName(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwIndex = 0;
    _dwNetCount = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;

    _dwCompObjectReturned = NULL;
    _dwCompObjectCurrentEntry = NULL;
    _dwCompObjectTotal = NULL;
    _dwCompResumeHandle = 0;
    _pCompBuffer = NULL;
    _fIsDomain  = FALSE;
    _pServerInfo = NULL;

    _fSchemaReturned = FALSE;

    memset(_szDomainPDCName, 0, sizeof(WCHAR)*MAX_PATH);

}

CWinNTDomainEnum::~CWinNTDomainEnum()
{
    if (_hLGroupComputer) {
        WinNTCloseComputer(
            _hLGroupComputer
            );
    }

    if (_hGGroupComputer) {
        WinNTCloseComputer(
            _hGGroupComputer
            );
    }

    if (_pCompBuffer) {

        NetApiBufferFree(_pCompBuffer);
    }

    if (_DomainName) {
        FreeADsStr(_DomainName);
    }

    if (_ADsPath) {
        FreeADsStr(_ADsPath);
    }

    if (_pObjList) {

        delete _pObjList;
    }


}

HRESULT
CWinNTDomainEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;
    ULONG cElementGlobal = 0;
    ULONG cElementLocal = 0;


    switch (ObjectType) {

    case WINNT_COMPUTER_ID:
        hr = EnumComputers(cElements, pvar, pcElementFetched);
        break;
    case WINNT_USER_ID:
        hr = EnumUsers(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_ID:

        //
        // for backward compatabillity, "group" includes "local group" and
        // "global group" during enumeration
        //

        //
        // enum all the global groups first
        //

        hr = EnumGlobalGroups(
                cElements,
                pvar,
                &cElementGlobal
                );

        //
        // enum local groups when there is no more global
        //

        if (hr == S_FALSE) {
            hr = EnumLocalGroups(
                    cElements-cElementGlobal,  // we have reduced buffer size!
                    pvar+cElementGlobal,
                    &cElementLocal
                    );
        }

        //
        // increment instead of just assingment: for consistency with
        // other switch cases
        //
        (*pcElementFetched) += (cElementGlobal+cElementLocal);
        break;

    case WINNT_LOCALGROUP_ID:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GLOBALGROUP_ID:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_SCHEMA_ID:
        hr = EnumSchema(cElements, pvar, pcElementFetched);
        break;
    default:
        RRETURN(S_FALSE);
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomainEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTDomainEnum::EnumSchema(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
)
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;

    if ( _fSchemaReturned )
        RRETURN(S_FALSE);

    if ( cElements > 0 )
    {
        hr = CWinNTSchema::CreateSchema(
                  _ADsPath,
                  TEXT("Schema"),
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  _Credentials,
                  (void **)&pDispatch
                  );

        if ( hr == S_OK )
        {
            VariantInit(&pvar[0]);
            pvar[0].vt = VT_DISPATCH;
            pvar[0].pdispVal = pDispatch;
            (*pcElementFetched)++;
            _fSchemaReturned = TRUE;
        }
    }

    RRETURN(hr);
}

HRESULT
CWinNTDomainEnum::EnumUsers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    if(!_fIsDomain){
        RRETURN(S_FALSE);
    }
    while (i < cElements) {

        hr = GetUserObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::GetUserObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_USER pUserInfo1 = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            1,
                            _dwIndex,
                            1024,
                            MAX_PREFERRED_LENGTH,
                            &_dwObjectReturned,
                            (PVOID *)&_pBuffer
                            );
        _dwNetCount++;

        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pBuffer) {
            RRETURN(S_FALSE);
        }

        _dwIndex  = (_pBuffer + _dwObjectReturned -1)->usri1_next_index;

    }

    //
    // Now send back the current ovbject
    //

    pUserInfo1 = (PNET_DISPLAY_USER)_pBuffer;
    pUserInfo1 += _dwObjectCurrentEntry;

    hr = CWinNTUser::CreateUser(
                        _ADsPath,
                        WINNT_DOMAIN_ID,
                        _DomainName,
                        NULL,
                        pUserInfo1->usri1_name,
                        ADS_OBJECT_BOUND,
                        &(pUserInfo1->usri1_flags),
                        pUserInfo1->usri1_full_name,
                        pUserInfo1->usri1_comment,
                        NULL,                        
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTDomainEnum::EnumComputers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {
        if(_fIsDomain == TRUE){
            hr = GetComputerObject(&pDispatch);
        }
        else {
            hr = GetComputerObjectInWorkGroup(&pDispatch);
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::GetComputerObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_MACHINE pDisplayComp = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;
    DWORD clen = 0;

    if (!_pCompBuffer || (_dwCompObjectCurrentEntry == _dwCompObjectReturned)) {

        if (_pCompBuffer) {
            NetApiBufferFree(_pCompBuffer);
            _pCompBuffer = NULL;
        }

        _dwCompObjectCurrentEntry = 0;
        _dwCompObjectReturned = 0;


        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            2,
                            _dwCompIndex,
                            100,
                            MAX_PREFERRED_LENGTH,
                            &_dwCompObjectReturned,
                            (PVOID *)&_pCompBuffer
                            );

        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pCompBuffer) {
            RRETURN(S_FALSE);
        }

        _dwCompIndex  = (_pCompBuffer + _dwCompObjectReturned -1)->usri2_next_index;

    }

    //
    // Now send back the current object
    //

    pDisplayComp = (PNET_DISPLAY_MACHINE)_pCompBuffer;
    pDisplayComp += _dwCompObjectCurrentEntry;

    //
    // The usri2_name is going to be returned back with a
    // $ character appended. Null set the $ character.
    //

    clen = wcslen(pDisplayComp->usri2_name);
    *(pDisplayComp->usri2_name + clen -1) = L'\0';

    hr = CWinNTComputer::CreateComputer(
                        _ADsPath,
                        _DomainName,
                        pDisplayComp->usri2_name,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwCompObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTDomainEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTDomainEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}

HRESULT
CWinNTDomainEnum::GetComputerObjectInWorkGroup(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PSERVER_INFO_100  pServerInfo = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD clen = 0;

    if (!_pServerInfo || (_dwCompObjectCurrentEntry == _dwCompObjectReturned))
    {

        if (_pServerInfo) {
            NetApiBufferFree(_pServerInfo);
            _pServerInfo = NULL;
        }

        if(_dwCompObjectTotal == _dwCompObjectReturned
           && (_dwCompObjectTotal !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        nasStatus = NetServerEnum(
                        NULL,
                        100,
                        (LPBYTE *)&_pServerInfo,
                        MAX_PREFERRED_LENGTH,
                        &_dwCompObjectReturned,
                        &_dwCompObjectTotal,
                        SV_TYPE_NT,
                        _DomainName,
                        &_dwCompResumeHandle
                        );

/*
        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            2,
                            _dwCompIndex,
                            100,
                            MAX_PREFERRED_LENGTH,
                            &_dwCompObjectReturned,
                            (PVOID *)&_pServerInfo
                            );

*/
        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        _dwCompObjectCurrentEntry = 0;

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pServerInfo = NULL
        //
        
        if (!_dwCompObjectReturned) {
                        _pServerInfo = NULL;
            RRETURN(S_FALSE);
        }

    }

    //
    // Now send back the current object
    //

    pServerInfo = (PSERVER_INFO_100)_pServerInfo;
    pServerInfo += _dwCompObjectCurrentEntry;

    hr = CWinNTComputer::CreateComputer(
                        _ADsPath,
                        _DomainName,
                        pServerInfo->sv100_name,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwCompObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}



HRESULT
CWinNTDomainEnum::GetGlobalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hGGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        (_szDomainPDCName + 2),
                        WINNT_DOMAIN_ID,
                        &_hGGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumGlobalGroups(
                    _hGGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_DOMAIN_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_GLOBAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;


    hr = S_FALSE;

    goto cleanup;
}


HRESULT
CWinNTDomainEnum::GetLocalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hLGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        (_szDomainPDCName + 2),
                        WINNT_DOMAIN_ID,
                        &_hLGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumLocalGroups(
                    _hLGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_DOMAIN_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_LOCAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;


    hr = S_FALSE;

    goto cleanup;

}


HRESULT
CWinNTDomainEnum::EnumGroupObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr;
    switch (ObjectType) {

    case WINNT_GROUP_GLOBAL:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_LOCAL:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    default:
        hr = S_FALSE;
        break;
    }
    RRETURN(hr);
}


ULONG GroupTypeArray[] = {WINNT_GROUP_GLOBAL, WINNT_GROUP_LOCAL, 0xFFFFFFFF};

HRESULT
CWinNTDomainEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    if(!_fIsDomain){
        RRETURN(S_FALSE);
    }

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while ((GroupTypeArray[_dwGroupArrayIndex] != (ULONG)-1) &&
            ((hr = EnumGroupObjects(
                               GroupTypeArray[_dwGroupArrayIndex],
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (GroupTypeArray[_dwGroupArrayIndex++] == (ULONG)-1){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}


HRESULT
CWinNTDomainEnum::EnumGlobalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGlobalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::EnumLocalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetLocalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum()
//              CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum
//              CWinNTGroupCollectionEnum::EnumObjects
//              CWinNTGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTGroupCollectionEnum::Create(
    CWinNTGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_GroupType = GroupType;


    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum():
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)

{
    _pObjList = NULL;
}



CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum(ObjectTypeList ObjList):
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)
{
    _pObjList = NULL;
}

CWinNTGroupCollectionEnum::~CWinNTGroupCollectionEnum()
{

    if (_hGroup) {


        if (_GroupType == WINNT_GROUP_GLOBAL) {


            WinNTGlobalGroupClose(
                            _hGroup
                            );
        }else {

            WinNTLocalGroupClose(
                        _hGroup
                        );
        }

    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_ServerName) {
        ADsFreeString(_ServerName);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_GroupName) {
        ADsFreeString(_GroupName);
    }

    if (_pObjList) {

        delete _pObjList;
    }

    if (_lpServerName) {

        FreeADsStr(_lpServerName) ;
    }
}

HRESULT
CWinNTGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;

   
    while (i < cElements) {


        //
        // This is the global group case
        //
        hr = GetDomainMemberObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);
                
                if (SUCCEEDED(hr)
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTGroupCollectionEnum::GetDomainMemberObject(
    IDispatch ** ppDispatch
    )
{

    HRESULT hr = S_OK;
    LPDOMAIN_GROUP_MEMBER pDomainGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;
    WCHAR szHostServerName[MAX_PATH];

    if (!_lpServerName) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );

        BAIL_ON_FAILURE(hr);

        if (!(_lpServerName = AllocADsStr(szHostServerName))) {

            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ;

            BAIL_ON_FAILURE(hr);
        }
    }


    if (!_hGroup) {
        dwRet = WinNTGlobalGroupOpen(
                        _DomainName,
                        _lpServerName + 2, // skip the 2 leading back slashes
                        _GroupName,
                        &_hGroup
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTGlobalGroupEnum(
                    _hGroup,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pDomainGrpMember = (LPDOMAIN_GROUP_MEMBER)pBuffer;

    switch (pDomainGrpMember->Type) {
    case WINNT_USER_ID :
        hr = CWinNTUser::CreateUser(
                            pDomainGrpMember->Parent,
                            WINNT_DOMAIN_ID,
                            pDomainGrpMember->Domain,
                            NULL,
                            pDomainGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            pDomainGrpMember->Parent,
                            WINNT_DOMAIN_ID,
                            pDomainGrpMember->Domain,
                            NULL,
                            pDomainGrpMember->Name,
                            WINNT_GROUP_GLOBAL,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    default:
        goto error;
    }

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }


    RRETURN(hr);


error:

    *ppDispatch = NULL;

   hr = S_FALSE;

   goto cleanup;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumfsh.cxx ===
/*++


  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumfsh.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CWinNTFileSharesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumFileShare);
DECLARE_DEBUG(EnumFileShare);
#define EnumFileShareDebugOut(x) EnumFileShareInlineDebugOut x
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::CWinNTFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTFileSharesEnumVar::CWinNTFileSharesEnumVar()
{
    _pszADsPath = NULL;
    _pszServerName = NULL;
    _pbFileShares = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;
    VariantInit(&_vFilter);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::~CWinNTFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTFileSharesEnumVar::~CWinNTFileSharesEnumVar()
{

    if(_pszADsPath){
        FreeADsStr(_pszADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pbFileShares){
        NetApiBufferFree(_pbFileShares);
    }
    VariantClear(&_vFilter);
}


HRESULT CWinNTFileSharesEnumVar::Create(LPTSTR pszServerName,
                                        LPTSTR pszADsPath,
                                        CWinNTFileSharesEnumVar **ppCFileSharesEnumVar,
                                        VARIANT vFilter,
                                        CWinNTCredentials& Credentials
                                        )
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;

    CWinNTFileSharesEnumVar FAR* pCFileSharesEnumVar = NULL;
    *ppCFileSharesEnumVar = NULL;

    pCFileSharesEnumVar = new CWinNTFileSharesEnumVar();
    if (pCFileSharesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFileSharesEnumVar->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFileSharesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFileSharesEnumVar->_pszADsPath =
        AllocADsStr(pszADsPath);

    if(!(pCFileSharesEnumVar->_pszADsPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = VariantCopy(&(pCFileSharesEnumVar->_vFilter), &vFilter);
    BAIL_ON_FAILURE(hr);

    pCFileSharesEnumVar->_Credentials = Credentials;
    hr = pCFileSharesEnumVar->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);

    *ppCFileSharesEnumVar = pCFileSharesEnumVar;
    RRETURN(hr);

error:

    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Share objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [ulNumFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileSharesEnumVar::Next(ULONG ulNumElementsRequested,
                              VARIANT FAR* pvar,
                              ULONG FAR* pulNumFetched)
{

    HRESULT hresult = S_OK;
    ULONG l;
    ULONG lNewCurrent;
    ULONG lNumFetched;
    LPSHARE_INFO_1 lpShareInfo = NULL;
    VARIANT v;
    IDispatch * pDispatch = NULL;


    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbFileShares ||(_lCurrentPosition == _lLBound +(LONG)_cElements)){
        if (_pbFileShares){
            NetApiBufferFree(_pbFileShares);
            _pbFileShares = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        if(!(ValidateFilterValue(_vFilter))){
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumFileShares(_pszServerName,
                                      &_cElements,
                                      &_dwTotalEntries,
                                      &_dwResumeHandle,
                                      &_pbFileShares
                                      );
        if(hresult == S_FALSE){
            goto cleanup;
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    lNumFetched = 0;
    lNewCurrent = _lCurrentPosition;

    while((lNumFetched < ulNumElementsRequested) &&
           (lNewCurrent< _lLBound +_cElements))
    {


        lpShareInfo = (LPSHARE_INFO_1)(_pbFileShares +
                                       lNewCurrent*sizeof(SHARE_INFO_1));

        if(lpShareInfo->shi1_type == STYPE_DISKTREE){
            //
            // file share object
            //
            hresult = CWinNTFileShare::Create(_pszADsPath,
                                              _pszServerName,
                                              FILESHARE_CLASS_NAME,
                                              lpShareInfo->shi1_netname,
                                              ADS_OBJECT_BOUND,
                                              IID_IDispatch,
                                              _Credentials,
                                              (void **)&pDispatch);


            BAIL_IF_ERROR(hresult);

            VariantInit(&v);
            V_VT(&v) = VT_DISPATCH;
            V_DISPATCH(&v) = pDispatch;
            pvar[lNumFetched] = v;

            lNumFetched++;
        }

        lNewCurrent++;

        if(lNumFetched == ulNumElementsRequested){
            //
            // we got all elements
            //
            break;
        }

        if(lNewCurrent==(_lLBound+_cElements)){

            //
            // first free our current buffer
            //

            if(_pbFileShares){
                NetApiBufferFree(_pbFileShares);
                _pbFileShares = NULL;
            }
            if(_cElements < _dwTotalEntries){
                hresult = WinNTEnumFileShares(_pszServerName,
                                              &_cElements,
                                              &_dwTotalEntries,
                                              &_dwResumeHandle,
                                              &_pbFileShares);
                if(hresult == S_FALSE){
                    if (pulNumFetched != NULL){
                        *pulNumFetched = lNumFetched;
                    }
                    goto cleanup;
                }
                _lLBound = 0;
                _lCurrentPosition = _lLBound;
                lNewCurrent = _lCurrentPosition;
            }
            else{

                //
                // you have gone through every share object
                // return S_FALSE
                //

                hresult = S_FALSE;
                if (pulNumFetched != NULL){
                    *pulNumFetched = lNumFetched;
                }

                goto cleanup;
            }

            lNewCurrent = _lCurrentPosition;
        }

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

cleanup:
    if(_pbFileShares){
        NetApiBufferFree(_pbFileShares);
    }

    if(FAILED(hresult)){
       #if DBG
       EnumFileShareDebugOut((DEB_TRACE,
                         "hresult Failed with value: %ld \n", hresult ));
       #endif
           RRETURN(S_FALSE);

    } else {

        if(hresult == S_FALSE)
            RRETURN(S_FALSE);
   
        RRETURN(S_OK);
    }

}


HRESULT
WinNTEnumFileShares(LPTSTR pszServerName,
                    PDWORD pdwElements,
                    PDWORD pdwTotalEntries,
                    PDWORD pdwResumeHandle,
                    LPBYTE * ppMem
                    )
{

    NET_API_STATUS nasStatus;

    nasStatus = NetShareEnum(pszServerName,
                             1,
                             ppMem,
                             MAX_PREFERRED_LENGTH,
                             pdwElements,
                             pdwTotalEntries,
                             pdwResumeHandle
                             );

    if(*ppMem == NULL || (nasStatus!= NERR_Success)){
        //
        //no more entries returned by FileShares
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}


BOOL
ValidateFilterValue(VARIANT vFilter)
{
    // this function unpacks vFilter and scans the safearray to investigate
    // whether or not it contains the string "fileshare". If it does,
    // we return true so that enumeration can proceed.

    BOOL fRetval = FALSE;
    HRESULT hr = S_OK;
    LONG lIndices;
    ULONG cElements;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    ULONG i;

    VariantInit(&vElement);

    if(V_VT(&vFilter) == VT_EMPTY){
        //
        // if no filter is set, you can still enumerate
        //
        fRetval = TRUE;
        goto cleanup;

    }else if (!(V_VT(&vFilter) ==  (VT_VARIANT|VT_ARRAY))) {

        fRetval = FALSE;
        goto cleanup;
    }

    psa = V_ARRAY(&vFilter);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        fRetval = FALSE;
        goto cleanup;
    }

    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        fRetval = TRUE;
        //
        // If filter is set and is empty, then
        // we return all objects.
        //
        goto cleanup;
    }

    //
    // We know that this is a valid single dimension array
    //

    for(lIndices=0; lIndices< (LONG)cElements; lIndices++){
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_IF_ERROR(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            hr = E_FAIL;
            goto cleanup;
        }

        if ( _tcsicmp(vElement.bstrVal, TEXT("fileshare")) == 0){
            //
            // found it, you can return TRUE now
            //
            fRetval = TRUE;
            goto cleanup;
        }

        VariantClear(&vElement);
    }


cleanup:
    //
    // In success case as well as error if we tripped after
    // getting the value but not clearing it in the for loop.
    //
    VariantClear(&vElement);

    if(FAILED(hr)){
        return FALSE;
    }

    return fRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CWinNTNamespaceEnum::Create
//             CWinNTNamespaceEnum::CWinNTNamespaceEnum
//             CWinNTNamespaceEnum::~CWinNTNamespaceEnum
//             CWinNTNamespaceEnum::QueryInterface
//             CWinNTNamespaceEnum::AddRef
//             CWinNTNamespaceEnum::Release
//             CWinNTNamespaceEnum::Next
//             CWinNTNamespaceEnum::Skip
//             CWinNTNamespaceEnum::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTNamespaceEnum::Create(
    CWinNTNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CWinNTNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CWinNTNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::CWinNTNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTNamespaceEnum::CWinNTNamespaceEnum()
{
    _pObjList = NULL;
    _pBuffer = 0;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _dwResumeHandle = 0;
    _bNoMore = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::~CWinNTNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTNamespaceEnum::~CWinNTNamespaceEnum()
{
    if (_pBuffer) {
        NetApiBufferFree(_pBuffer);
    }

    if ( _pObjList )
        delete _pObjList;
}


HRESULT
CWinNTNamespaceEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;
    switch (ObjectType) {

    case WINNT_DOMAIN_ID:
        hr = EnumDomains(cElements, pvar, pcElementFetched);
        RRETURN(hr);

    default:
        RRETURN(S_FALSE);
    }
}

HRESULT
CWinNTNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTNamespaceEnum::EnumDomains(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;
    BOOL fRepeat = FALSE;
    DWORD dwFailureCount = 0;
    DWORD dwPermitFailure = 1000;

    while (i < cElements) {

        hr = GetDomainObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }
        else if (FAILED(hr)) {
            //
            // Got an error while retrieving the object, ignore the
            // error and continue with the next object.
            // If continuously getting error more than dwPermitFailure,
            // make the return value S_FALSE, leave the loop.            
            //            
            if (fRepeat) {
            	dwFailureCount++;
            	if(dwFailureCount > dwPermitFailure) {
            		hr = S_FALSE;
            		break;
            	}            	
            }
            else {
            	fRepeat = TRUE;
            	dwFailureCount = 1;
            }

            // we need to move the _dwObjectCurrentEntry
            _dwObjectCurrentEntry++;
            
            hr = S_OK;
            continue;
        }
        

        if (fRepeat) {
        	fRepeat = FALSE;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTNamespaceEnum::GetDomainObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PSERVER_INFO_100 pServerInfo100 = NULL;
    NET_API_STATUS nasStatus = 0;

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        nasStatus = NetServerEnum(
                        NULL,
                        100,
                        (LPBYTE *)&_pBuffer,
                        MAX_PREFERRED_LENGTH,
                        &_dwObjectReturned,
                        &_dwObjectTotal,
                        SV_TYPE_DOMAIN_ENUM,
                        NULL,
                        &_dwResumeHandle
                        );

        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            hr =S_FALSE;
            goto cleanup;
        }

        if (nasStatus == ERROR_SUCCESS) {
            _bNoMore = TRUE;
        }
    }

    //
    // Now send back the current object
    //

    //
    // There is a scenario where NetServerEnum returns ERROR_SUCCESS
    // when there is no data to send back. However the field
    // _dwObjectsReturned will also be 0. We need to check that and
    // bail out if necessary
    //

    if ((nasStatus == ERROR_SUCCESS) && _dwObjectReturned == 0){
        RRETURN(S_FALSE);
    }
    pServerInfo100 = (LPSERVER_INFO_100)_pBuffer;
    pServerInfo100 += _dwObjectCurrentEntry;
    
    //
    // We couldn't have any credentials coming in from a Namespace
    // enumeration, since you can't have credentials coming in from
    // a Namespace.  So we use null credentials.
    //
    hr = CWinNTDomain::CreateDomain(
                    L"WinNT:",
                    pServerInfo100->sv100_name,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    _Credentials,
                    (void **) ppDispatch
                    );    

    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  Windows NT 3.5 Schema Enumeration Code
//
//             CWinNTSchemaEnum::CWinNTSchemaEnum()
//             CWinNTSchemaEnum::CWinNTSchemaEnum
//             CWinNTSchemaEnum::EnumObjects
//             CWinNTSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSchemaEnum::Create(
    CWinNTSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT vFilter,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CWinNTSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN(hr);
}

CWinNTSchemaEnum::CWinNTSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwPropCurrentEntry( 0)
{
}

CWinNTSchemaEnum::~CWinNTSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;

    switch (ObjectType)
    {
        case WINNT_CLASS_ID:
            hr = EnumClasses(cElements, pvar, pcElementFetched);
            break;
        case WINNT_SYNTAX_ID:
            hr = EnumSyntaxObjects(cElements, pvar, pcElementFetched);
            break;
        case WINNT_PROPERTY_ID:
            hr = EnumProperties(cElements, pvar, pcElementFetched);
            break;
        default:
            RRETURN(S_FALSE);
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= g_cWinNTClasses )
        goto error;

    hr = CWinNTClass::CreateClass(
                        _bstrADsPath,
                        &g_aWinNTClasses[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cWinNTSyntax )
        goto error;

    hr = CWinNTSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aWinNTSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CWinNTSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwPropCurrentEntry >= g_cWinNTProperties )
        goto error;

    hr = CWinNTProperty::CreateProperty(
                        _bstrADsPath,
                        &g_aWinNTProperties[_dwPropCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwPropCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

#define BASE_BUFFER_SIZE (4096 * sizeof(WCHAR))

CWinNTUserGroupsCollectionEnum::CWinNTUserGroupsCollectionEnum():
                                _ParentType(0),
                                _ParentADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _UserName(NULL),
                                _pGlobalBuffer(NULL),
                                _pLocalBuffer(NULL),
                                _dwCurrent(0),
                                _dwTotal(0),
                                _dwGlobalTotal(0),
                                _dwLocalTotal(0),
                                _fIsDomainController(FALSE)
{
    VariantInit(&_vFilter);
}

CWinNTUserGroupsCollectionEnum::~CWinNTUserGroupsCollectionEnum()
{
    if (_ParentADsPath)
        ADsFreeString(_ParentADsPath);
    if (_DomainName)
        ADsFreeString(_DomainName);
    if (_ServerName)
        ADsFreeString(_ServerName);
    if (_UserName)
        ADsFreeString(_UserName);
    if (_pGlobalBuffer)
        NetApiBufferFree(_pGlobalBuffer);
    if (_pLocalBuffer)
        NetApiBufferFree(_pLocalBuffer);
    VariantClear(&_vFilter);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTUserGroupsCollectionEnum::Create(
    CWinNTUserGroupsCollectionEnum FAR* FAR* ppenumvariant,
    ULONG ParentType,
    BSTR ParentADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    VARIANT vFilter,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTUserGroupsCollectionEnum FAR* penumvariant = NULL;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    NET_API_STATUS nasStatus;
    WCHAR szServer[MAX_PATH];

    //
    // Should the checks below be assertions?
    //

    if (!ppenumvariant)
        return E_FAIL;

    if (ParentType != WINNT_DOMAIN_ID &&
        ParentType != WINNT_COMPUTER_ID)
        return E_FAIL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTUserGroupsCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ParentADsPath , &penumvariant->_ParentADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString(ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(UserName, &penumvariant->_UserName);
    BAIL_ON_FAILURE(hr);

    //
    // We currently copy the filter but do nothing with it!!!
    //

    hr = VariantCopy(&penumvariant->_vFilter, &vFilter);
    BAIL_ON_FAILURE(hr);

    // check if the server is a DC
    MakeUncName(ServerName, szServer);
    nasStatus = NetServerGetInfo(
            szServer,
            101,
            (LPBYTE *)&lpServerInfo
            );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    if( (lpServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (lpServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {
        penumvariant->_fIsDomainController = TRUE;
    }
    else
        penumvariant->_fIsDomainController = FALSE;

    hr = penumvariant->DoEnumeration();
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;
    RRETURN(hr);

error:
    delete penumvariant;

    if(lpServerInfo)
        NetApiBufferFree(lpServerInfo);

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoEnumeration()
{
    HRESULT hr;

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = DoGlobalEnumeration();
        BAIL_ON_FAILURE(hr);

        hr = DoLocalEnumeration();

    } else if (_ParentType == WINNT_COMPUTER_ID) {

        // We also want to try and get the global groups,
        // as this will be empty if the user does not belong to
        // any global groups.
        // We need to be careful on where we fail as we should
        // continue enumerating local groups for lots of cases.
        hr = DoGlobalEnumeration();

        if ((hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
             || (hr == HRESULT_FROM_WIN32(NERR_InvalidComputer))
             || (hr == HRESULT_FROM_WIN32(NERR_UserNotFound))
             || (hr == E_FAIL)) {
            hr = S_OK;
            _dwGlobalTotal = 0;
        }

        BAIL_ON_FAILURE(hr);

        hr = DoLocalEnumeration();

    } else {
        hr = E_FAIL;
    }
error:
    _dwTotal = _dwGlobalTotal + _dwLocalTotal;
    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoGlobalEnumeration()
{
    HRESULT hr;
    DWORD dwStatus;
    DWORD dwRead = 0;
    WCHAR szServer[MAX_PATH];
    LPGROUP_USERS_INFO_0 pGroupUserInfo = NULL;
    GROUP_INFO_2 *pGroupInfo2 = NULL;
    NET_API_STATUS nasStatus; 

    MakeUncName(_ServerName, szServer);
    dwStatus = NetUserGetGroups(szServer,
                                _UserName,
                                0,
                                (LPBYTE*)&_pGlobalBuffer,
                                MAX_PREFERRED_LENGTH,
                                &dwRead,
                                &_dwGlobalTotal);
    hr = HRESULT_FROM_WIN32(dwStatus);
    BAIL_ON_FAILURE(hr);

    if (dwRead != _dwGlobalTotal)
        hr = E_FAIL;

    if (dwRead == 1) {
    //
    // Check if it is the none group - dont want that
    //
    pGroupUserInfo = (LPGROUP_USERS_INFO_0)_pGlobalBuffer;
    if ( pGroupUserInfo->grui0_name && (FALSE == _fIsDomainController) &&
         (1 == _dwGlobalTotal) ) {
    // check if this the none group. Only non-DCs will return this group.
        
        nasStatus = NetGroupGetInfo(
                 szServer,
                 pGroupUserInfo->grui0_name,
                 2,
                 (LPBYTE *) &pGroupInfo2
                 );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);
                 
        if (pGroupInfo2->grpi2_group_id == DOMAIN_GROUP_RID_USERS) {

            //
            // Set the global total to zero - destructor will dealloc.
            //
            _dwGlobalTotal = 0;
        }
    }
}


error:
    if(pGroupInfo2)
        NetApiBufferFree(pGroupInfo2);

    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoLocalEnumeration()
{
    HRESULT hr;
    DWORD dwStatus;
    DWORD dwRead = 0;
    WCHAR szServer[MAX_PATH];

    MakeUncName(_ServerName, szServer);
    dwStatus = NetUserGetLocalGroups(szServer,
                                     _UserName,
                                     0,
                                     0,
                                     (LPBYTE*)&_pLocalBuffer,
                                     MAX_PREFERRED_LENGTH,
                                     &dwRead,
                                     &_dwLocalTotal);
    hr = HRESULT_FROM_WIN32(dwStatus);
    BAIL_ON_FAILURE(hr);

    if (dwRead != _dwLocalTotal)
        hr = E_FAIL;

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTUserGroupsCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserGroups(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Skip(ULONG cElements)
{
    //
    // Note: we better not wrap around when we add!
    //

    _dwCurrent += cElements;
    _dwCurrent = min(_dwTotal, _dwCurrent);

    if (_dwCurrent < _dwTotal)
        return S_OK;
    return S_FALSE;
}

STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Reset()
{
    _dwCurrent = 0;
    return S_OK;
}

HRESULT
CWinNTUserGroupsCollectionEnum::EnumUserGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetNextUserGroup(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::GetNextUserGroup(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr;
    LPGROUP_USERS_INFO_0 lpInfo;
    LPWSTR GroupName;
    ULONG GroupType;

    if (_dwCurrent >= _dwTotal)
        return S_FALSE;

    if (_dwCurrent < _dwGlobalTotal) {
        lpInfo = (LPGROUP_USERS_INFO_0)_pGlobalBuffer + _dwCurrent;
        GroupType = WINNT_GROUP_GLOBAL;
    } else {
        lpInfo = (LPGROUP_USERS_INFO_0)_pLocalBuffer + _dwCurrent -
            _dwGlobalTotal;
        GroupType = WINNT_GROUP_LOCAL;
    }

    _dwCurrent++;

    GroupName = lpInfo->grui0_name;

    //
    // On an error, should we try to keep going?
    //

	if (GroupType == WINNT_GROUP_GLOBAL) {
		hr = CWinNTGroup::CreateGroup(_ParentADsPath,
									  _ParentType,
									  _DomainName,
									  _ServerName,
									  GroupName,
									  GroupType,
									  ADS_OBJECT_BOUND,
									  IID_IDispatch,
									  _Credentials,
									  (void **)ppDispatch
									 );
	}
	else {
		hr = CWinNTGroup::CreateGroup(_ParentADsPath,
									  _ParentType,
									  _DomainName,
									  _ServerName,
									  GroupName,
									  GroupType,
									  ADS_OBJECT_BOUND,
									  IID_IDispatch,
									  _Credentials,
									  (void **)ppDispatch
									 );
	}
    if (FAILED(hr))
        return S_FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CWinNTEnumVariant::Create
//             CWinNTEnumVariant::CWinNTEnumVariant
//             CWinNTEnumVariant::~CWinNTEnumVariant
//             CWinNTEnumVariant::QueryInterface
//             CWinNTEnumVariant::AddRef
//             CWinNTEnumVariant::Release
//             CWinNTEnumVariant::Next
//             CWinNTEnumVariant::Skip
//             CWinNTEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::CWinNTEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTEnumVariant::CWinNTEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::~CWinNTEnumVariant
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTEnumVariant::~CWinNTEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }


    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CWinNTEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CWinNTEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumres.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumres.cxx

  Abstract:

  Contains methods for implementing the Enumeration of resources(open files)
  on a  server. Has methods for the CWinNTResourcesCollection object
  as well as the CWinNTResourcesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 03/12/96

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumRes);
DECLARE_DEBUG(EnumRes);
#define EnumResDebugOut(x) EnumResInlineDebugOut x
#endif


CWinNTResourcesCollection::CWinNTResourcesCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;

    _pDispMgr = NULL;
    _pCResourcesEnumVar = NULL;
    ENLIST_TRACKING(CWinNTResourcesCollection);
}

CWinNTResourcesCollection::~CWinNTResourcesCollection()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pDispMgr;
    if(_pCResourcesEnumVar){
        _pCResourcesEnumVar->Release();
    }

}

HRESULT
CWinNTResourcesCollection::Create(LPTSTR pszServerADsPath,
                                  LPTSTR pszBasePath,
                                  LPTSTR pszUserName,
                                  CWinNTCredentials& Credentials,
                                  CWinNTResourcesCollection
                                  ** ppCWinNTResourcesCollection )
{

    BOOL fStatus = FALSE, LastError;
    HRESULT hr;
    CWinNTResourcesCollection *pCWinNTResourcesCollection = NULL;
    POBJECTINFO pServerObjectInfo = NULL;
    //
    // create the Resources collection object
    //

    pCWinNTResourcesCollection = new CWinNTResourcesCollection();

    if(pCWinNTResourcesCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTResourcesCollection->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if (!pCWinNTResourcesCollection->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );

    BAIL_IF_ERROR(hr);

    pCWinNTResourcesCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCWinNTResourcesCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTResourcesCollection->_Credentials = Credentials;
    hr = pCWinNTResourcesCollection->_Credentials.RefServer(
        pCWinNTResourcesCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){
        pCWinNTResourcesCollection->_pszBasePath = 
            AllocADsStr(pszBasePath);

        if(!(pCWinNTResourcesCollection->_pszBasePath)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){
        pCWinNTResourcesCollection->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCWinNTResourcesCollection->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    pCWinNTResourcesCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTResourcesCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCWinNTResourcesCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTResourcesCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    *ppCWinNTResourcesCollection =pCWinNTResourcesCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTResourcesCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Resources collection object  */

STDMETHODIMP
CWinNTResourcesCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP 
CWinNTResourcesCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CWinNTResourcesCollection);

/* IADsCollection methods */

STDMETHODIMP
CWinNTResourcesCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTResourcesEnumVar *pCResourcesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTResourcesEnumVar::Create(_pszServerADsPath,
                                        _pszBasePath,
                                        _pszUserName,
                                        _Credentials,
                                        &pCResourcesEnumVar
                                        );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCResourcesEnumVar);

    _pCResourcesEnumVar = pCResourcesEnumVar;

    hr = _pCResourcesEnumVar->QueryInterface(IID_IUnknown,
                                             (void **)retval
                                             );

    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTResourcesCollection::GetObject(THIS_ BSTR bstrResourceName,
                                     VARIANT *pvar
                                     ) 

{

    HRESULT hr = S_OK;
    DWORD   dwFileId;
    IDispatch *pDispatch = NULL;
 
    if(!bstrResourceName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a fileid
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    hr = CWinNTResource::Create(_pszServerADsPath,
                                dwFileId,
                                ADS_OBJECT_BOUND,
                                IID_IDispatch,
                                _Credentials,
                                (void **)&pDispatch
                                );

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP 
CWinNTResourcesCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP
CWinNTResourcesCollection::Remove(THIS_ BSTR bstrResourceName) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);    
}


//
// CWinNTResourcesEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::CWinNTResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTResourcesEnumVar::CWinNTResourcesEnumVar()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;
    _pbResources = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::~CWinNTResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTResourcesEnumVar::~CWinNTResourcesEnumVar()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbResources){
        NetApiBufferFree(_pbResources);
    }
}


HRESULT CWinNTResourcesEnumVar::Create(LPTSTR pszServerADsPath,
                                       LPTSTR pszBasePath,
                                       LPTSTR pszUserName,
                                       CWinNTCredentials& Credentials,
                                       CWinNTResourcesEnumVar
                                       **ppCResourcesEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CWinNTResourcesEnumVar FAR* pCResourcesEnumVar = NULL;

    *ppCResourcesEnumVar = NULL;

    pCResourcesEnumVar = new CWinNTResourcesEnumVar();

    if (pCResourcesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!(pCResourcesEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCResourcesEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCResourcesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_Credentials = Credentials;
    hr = pCResourcesEnumVar->_Credentials.RefServer(
        pCResourcesEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){
        pCResourcesEnumVar->_pszBasePath = 
            AllocADsStr(pszBasePath);

        if(!(pCResourcesEnumVar->_pszBasePath)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){

        pCResourcesEnumVar->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCResourcesEnumVar->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    *ppCResourcesEnumVar = pCResourcesEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Resource objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTResourcesEnumVar::Next(ULONG ulNumElementsRequested,
                             VARIANT FAR* pvar,
                             ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched;
    LPFILE_INFO_3 lpFileInfo;
    VARIANT v;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbResources || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbResources){
            NetApiBufferFree(_pbResources);
            _pbResources = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumResources(_pszServerName,
                                     _pszBasePath,
                                     _pszUserName,
                                     &_pbResources,
                                     &_cElements,
                                     &_dwTotalEntries,
                                     &_dwResumeHandle
                                     );

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        lpFileInfo = (LPFILE_INFO_3)(_pbResources + \
                                     lNewCurrent*sizeof(FILE_INFO_3));


        hresult = CWinNTResource::Create((LPTSTR)_pszServerADsPath,
                                         ADS_OBJECT_BOUND,
                                         lpFileInfo->fi3_id,
                                         IID_IDispatch,
                                         _Credentials,
                                         (void **)&pDispatch);


        BAIL_ON_FAILURE(hresult);

        VariantInit(&v);
        V_VT(&v) = VT_DISPATCH;
        V_DISPATCH(&v) = pDispatch;
        pvar[lNumFetched] = v;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:

    if(FAILED(hresult)){

#if DBG
        EnumResDebugOut((DEB_TRACE,
                          "hresult Failed with value: %ld \n", hresult ));
#endif

    }

    RRETURN(S_FALSE);
}


HRESULT
WinNTEnumResources(LPTSTR pszServerName,
                   LPTSTR pszBasePath,
                   LPTSTR pszUserName,
                   LPBYTE * ppMem,
                   LPDWORD pdwEntriesRead,
                   LPDWORD pdwTotalEntries,
                   PDWORD_PTR pdwResumeHandle
                   )

{

    LPBYTE  pMem    = NULL;
    CWinNTResource *pCWinNTResource = NULL;
    IDispatch *pDispatch = NULL;
    VARIANT v;
    LONG l;
    HRESULT hr;
    NET_API_STATUS nasStatus;

    UNREFERENCED_PARAMETER(pszBasePath);
    UNREFERENCED_PARAMETER(pszUserName);

    //
    // why have these parameters if they are unreferenced? Because we might
    // use them in the future when more complicated enumerations are desired
    //

    nasStatus = NetFileEnum(pszServerName,
                            NULL,
                            pszUserName,
                            3,  //info level desired
                            ppMem,
                            MAX_PREFERRED_LENGTH,
                            pdwEntriesRead,
                            pdwTotalEntries,
                            pdwResumeHandle
                            );

    if(*ppMem == NULL|| (nasStatus != NERR_Success)){
        //
        // no more entries returned by NetFileEnum
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumses.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumses.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CWinNTSessionsCollection object
  as well as the CWinNTSessionsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumSession);
DECLARE_DEBUG(EnumSession);
#define EnumSessionDebugOut(x) EnumSessionInlineDebugOut x
#endif


CWinNTSessionsCollection::CWinNTSessionsCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszClientName = NULL;
    _pszUserName = NULL;
    _pDispMgr = NULL;
    _pCSessionsEnumVar = NULL;
    ENLIST_TRACKING(CWinNTSessionsCollection);
}

CWinNTSessionsCollection::~CWinNTSessionsCollection()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszClientName){
        FreeADsStr(_pszClientName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    delete _pDispMgr;
    if(_pCSessionsEnumVar){
        _pCSessionsEnumVar->Release();
    }

}

HRESULT
CWinNTSessionsCollection::Create(LPTSTR pszServerADsPath,
                                 LPTSTR pszClientName,
                                 LPTSTR pszUserName,
                                 CWinNTCredentials& Credentials,
                                 CWinNTSessionsCollection
                                 ** ppCWinNTSessionsCollection )
{

    BOOL fStatus = FALSE;
    HRESULT hr;
    CWinNTSessionsCollection *pCWinNTSessionsCollection = NULL;
    POBJECTINFO  pServerObjectInfo = NULL;

    //
    // create the Sessions collection object
    //

    pCWinNTSessionsCollection = new CWinNTSessionsCollection();

    if(pCWinNTSessionsCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSessionsCollection->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCWinNTSessionsCollection->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCWinNTSessionsCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCWinNTSessionsCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSessionsCollection->_Credentials = Credentials;
    hr = pCWinNTSessionsCollection->_Credentials.RefServer(
        pCWinNTSessionsCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if (pszUserName){
        pCWinNTSessionsCollection->_pszUserName = 
            AllocADsStr(pszUserName);
        
        if(!(pCWinNTSessionsCollection->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszClientName){
        pCWinNTSessionsCollection->_pszClientName = 
            AllocADsStr(pszClientName);
        
        if(!(pCWinNTSessionsCollection->_pszClientName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    pCWinNTSessionsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTSessionsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCWinNTSessionsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTSessionsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    *ppCWinNTSessionsCollection = pCWinNTSessionsCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTSessionsCollection;
    RRETURN_EXP_IF_ERR (hr);

}

/* IUnknown methods for Sessions collection object  */

STDMETHODIMP
CWinNTSessionsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSessionsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


DEFINE_IDispatch_Implementation(CWinNTSessionsCollection);


/* IADsCollection methods */


STDMETHODIMP
CWinNTSessionsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTSessionsEnumVar *pCSessionsEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTSessionsEnumVar::Create(_pszServerADsPath,
                                       _pszClientName,
                                       _pszUserName,
                                       _Credentials,
                                       &pCSessionsEnumVar);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCSessionsEnumVar);

    _pCSessionsEnumVar = pCSessionsEnumVar;

    hr = _pCSessionsEnumVar->QueryInterface(IID_IUnknown, (void **)retval);
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSessionsCollection::GetObject(THIS_ BSTR bstrSessionName, 
                                    VARIANT *pvar
                                    ) 

{
    LPTSTR  pszSession = NULL;
    LPTSTR pszUserName;
    LPTSTR pszClientName;
    IDispatch *pDispatch = NULL;
    HRESULT hr;

    if(!bstrSessionName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = SplitIntoUserAndClient(pszSession, &pszUserName, &pszClientName);
    BAIL_IF_ERROR(hr);

    hr = CWinNTSession::Create(_pszServerADsPath,
                               pszClientName,
                               pszUserName,
                               ADS_OBJECT_BOUND,
                               IID_IDispatch,
                               _Credentials,
                               (void **)&pDispatch);  
    

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP 
CWinNTSessionsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSessionsCollection::Remove(THIS_ BSTR bstrSessionName) 
{

    LPTSTR pszSession = NULL;
    LPTSTR pszUserName;
    LPTSTR pszClientName;
    TCHAR szUncClientName[MAX_PATH];
    TCHAR szUncServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = SplitIntoUserAndClient(pszSession, &pszUserName, &pszClientName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(pszClientName, szUncClientName);
    BAIL_IF_ERROR(hr);

    nasStatus  = NetSessionDel(szUncServerName,
                               szUncClientName,
                               pszUserName );

    if(nasStatus != NERR_Success){
        hr = HRESULT_FROM_WIN32(nasStatus);
    }


cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);

}


//
// CWinNTSessionsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::CWinNTSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTSessionsEnumVar::CWinNTSessionsEnumVar()
{

    _pszServerName = NULL;
    _pszServerADsPath = NULL;
    _pszClientName = NULL;
    _pszUserName = NULL;
    _pbSessions = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::~CWinNTSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTSessionsEnumVar::~CWinNTSessionsEnumVar()
{

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszClientName){
        FreeADsStr(_pszClientName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbSessions){
        NetApiBufferFree(_pbSessions);
    }
}


HRESULT CWinNTSessionsEnumVar::Create(LPTSTR pszServerADsPath,
                                      LPTSTR pszClientName,
                                      LPTSTR pszUserName,
                                      CWinNTCredentials& Credentials,
                                      CWinNTSessionsEnumVar \
                                      **ppCSessionsEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CWinNTSessionsEnumVar FAR* pCSessionsEnumVar = NULL;

    *ppCSessionsEnumVar = NULL;

    pCSessionsEnumVar = new CWinNTSessionsEnumVar();

    if (pCSessionsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCSessionsEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!(pCSessionsEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCSessionsEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCSessionsEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_Credentials = Credentials;
    hr = pCSessionsEnumVar->_Credentials.RefServer(
        pCSessionsEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszClientName){

        pCSessionsEnumVar->_pszClientName = 
            AllocADsStr(pszClientName);

        if(!(pCSessionsEnumVar->_pszClientName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    if(pszUserName){
        pCSessionsEnumVar->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCSessionsEnumVar->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    *ppCSessionsEnumVar = pCSessionsEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
    
    
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Session objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSessionsEnumVar::Next(ULONG ulNumElementsRequested,
                            VARIANT FAR* pvar,
                            ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG ulIndex;
    LONG lNewCurrent;
    ULONG lNumFetched;
    LPSESSION_INFO_1 lpSessionInfo;
    IDispatch * pDispatch = NULL;
    LPTSTR pszClientName = NULL;
    LPTSTR pszUserName = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Initialize the elements to be returned
    //

    for (ulIndex= 0; ulIndex < ulNumElementsRequested; ulIndex++){
        VariantInit(&pvar[ulIndex]);
    }

    if(!_pbSessions || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbSessions){
            NetApiBufferFree(_pbSessions);
            _pbSessions = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumSessions(_pszServerName,
                                    _pszClientName,
                                    _pszUserName,
                                    &_cElements,
                                    &_dwTotalEntries,
                                    &_dwResumeHandle,
                                    &_pbSessions
                                    );

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;

    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        lpSessionInfo = (LPSESSION_INFO_1)(_pbSessions +
                                           lNewCurrent*sizeof(SESSION_INFO_1));

        pszClientName = lpSessionInfo->sesi1_cname;
        pszUserName = lpSessionInfo->sesi1_username;

        hresult = CWinNTSession::Create(_pszServerADsPath,
                                        pszClientName,
                                        pszUserName,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);


        BAIL_ON_FAILURE(hresult);

        V_VT(&(pvar[lNumFetched])) = VT_DISPATCH;
        V_DISPATCH(&(pvar[lNumFetched])) = pDispatch;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:
#if DBG
    if(FAILED(hresult)){
        EnumSessionDebugOut((DEB_TRACE,
                            "hresult Failed with value: %ld \n", hresult ));
    }
#endif

    RRETURN(S_FALSE);
}

HRESULT
WinNTEnumSessions(LPTSTR pszServerName,
                  LPTSTR pszClientName,
                  LPTSTR pszUserName,
                  PDWORD pdwEntriesRead,
                  PDWORD pdwTotalEntries,
                  PDWORD pdwResumeHandle,
                  LPBYTE * ppMem
                  )

{

    NET_API_STATUS nasStatus;

    UNREFERENCED_PARAMETER(pszClientName);
    UNREFERENCED_PARAMETER(pszUserName);

    //
    // why have these parameters if they are unreferenced? Because we might
    // use them in the future when more complicated enumerations are desired
    //

    nasStatus = NetSessionEnum(pszServerName,
                               NULL,
                               NULL,
                               1,  //info level desired
                               ppMem,
                               MAX_PREFERRED_LENGTH,
                               pdwEntriesRead,
                               pdwTotalEntries,
                               pdwResumeHandle);

    if(*ppMem == NULL || (nasStatus != NERR_Success)){
        //
        //no more entries returned by sessions
        //
        RRETURN(S_FALSE);
    }


    RRETURN(S_OK);

}



//
// helper functions
//

HRESULT
SplitIntoUserAndClient(LPTSTR   pszSession,
                       LPTSTR * ppszUserName,
                       LPTSTR * ppszClientName
                       )

{

    HRESULT hr = S_OK;
    int i=0;

    //
    //  assumption: Valid strings are passed to this function
    //  i.e. bstrSession is valid
    //  we have the format username\clientname
    //  suppose we have no username then it is "\clientname"
    //  suppose we dont have clientname it is username\


    *ppszUserName = pszSession;
    *ppszClientName = pszSession;


    if((*ppszClientName = _tcschr(pszSession, TEXT('\\')))== NULL)
       {
           //
           // invalid name specified
           //

           RRETURN(E_FAIL);
       }
     **ppszClientName = TEXT('\0');
    (*ppszClientName)++;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cenumjob.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cenumjob.cxx

  Abstract:

  Contains methods for implementing the Enumeration of print jobs on a
  printer. Has methods for the CWinNTPrintJobsCollection object
  as well as the CWinNTJobsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

CWinNTPrintJobsCollection::CWinNTPrintJobsCollection()
{
    _pDispMgr = NULL;
    _pCJobsEnumVar = NULL;
    ENLIST_TRACKING(CWinNTPrintJobsCollection);
}

CWinNTPrintJobsCollection::~CWinNTPrintJobsCollection()
{
    DWORD fStatus;

    //
    // close the printer and destroy sub objects
    //
    if(_pszADsPrinterPath){
        FreeADsStr(_pszADsPrinterPath);
    }

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }

    if (_hPrinter){
        fStatus = ClosePrinter(_hPrinter);
    }

    delete _pDispMgr;

}

HRESULT
CWinNTPrintJobsCollection::Create(LPWSTR pszADsPrinterPath,
                                  CWinNTCredentials& Credentials,
                                  CWinNTPrintJobsCollection
                                  ** ppCWinNTPrintJobsCollection )
{

    BOOL fStatus = FALSE, LastError;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE| READ_CONTROL};
    HRESULT hr;
    CWinNTPrintJobsCollection *pCWinNTJobsCollection = NULL;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // create the jobs collection object
    //

    pCWinNTJobsCollection = new CWinNTPrintJobsCollection();
    if(pCWinNTJobsCollection == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = BuildObjectInfo(pszADsPrinterPath,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    pCWinNTJobsCollection->_Credentials = Credentials;
    hr = pCWinNTJobsCollection->_Credentials.RefServer(
        pObjectInfo->ComponentArray[1]);
    BAIL_ON_FAILURE(hr);


    hr = PrinterNameFromObjectInfo(pObjectInfo,
                                   szUncPrinterName
                                   );

    BAIL_ON_FAILURE(hr);



    pCWinNTJobsCollection->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pCWinNTJobsCollection->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCWinNTJobsCollection->_pszADsPrinterPath =
        AllocADsStr(pszADsPrinterPath);

    if(!(pCWinNTJobsCollection->_pszADsPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // open printer and set the handle to the appropriate value
    //

    fStatus = OpenPrinter(szUncPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();

        switch (LastError) {
        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(szUncPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }
        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
    }

    BAIL_ON_FAILURE(hr);

    pCWinNTJobsCollection->_hPrinter = hPrinter;

    pCWinNTJobsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTJobsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = LoadTypeInfoEntry(pCWinNTJobsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTJobsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_ON_FAILURE(hr);

    *ppCWinNTPrintJobsCollection =pCWinNTJobsCollection;

    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);

error:
    delete pCWinNTJobsCollection;

    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for jobs collection object  */

STDMETHODIMP
CWinNTPrintJobsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintJobsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CWinNTPrintJobsCollection);


     /* IADsCollection methods */


STDMETHODIMP
CWinNTPrintJobsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTJobsEnumVar *pCJobsEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTJobsEnumVar::Create(_hPrinter,
                                   _pszADsPrinterPath,
                                   _Credentials,
                                   &pCJobsEnumVar);

    if (FAILED(hr)) {
        goto error;
    }

    ADsAssert(pCJobsEnumVar);

    _pCJobsEnumVar = pCJobsEnumVar;

    hr = _pCJobsEnumVar->QueryInterface(IID_IUnknown,
                                        (void **)retval
                                        );

    BAIL_ON_FAILURE(hr);

    _pCJobsEnumVar->Release();

    RRETURN(S_OK);

error:
    delete pCJobsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJobsCollection::GetObject(THIS_ BSTR bstrJobName,
                                     VARIANT *pvar)
{
    HRESULT hr;
    DWORD dwJobId;
    IDispatch *pDispatch = NULL;


    if(!bstrJobName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    dwJobId = (DWORD)_wtol(bstrJobName);

    hr = CWinNTPrintJob::CreatePrintJob(_pszADsPrinterPath,
                                        dwJobId,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJobsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTPrintJobsCollection::Remove(THIS_ BSTR bstrJobName)
{
    DWORD dwJobId;
    HRESULT hr = S_OK;
    HANDLE hPrinter = NULL;
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};

    if(! bstrJobName){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a jobid
    //

    dwJobId = (DWORD)_wtol(bstrJobName);

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    //
    // use JOB_CONTROL_DELETE instead of JOB_CONTROL_CANCEL as DELETE works
    // even when a print job has been restarted while CANCEL won't
    //

    fStatus = SetJob (hPrinter,
                      dwJobId,
                      0,
                      NULL,
                      JOB_CONTROL_DELETE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:

    if (hPrinter) {
        ClosePrinter(hPrinter);
    }

    RRETURN (hr);
}




//
// CWinNTJobsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::CWinNTJobsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTJobsEnumVar::CWinNTJobsEnumVar()
{
    _pszADsPrinterPath = NULL;
    _pSafeArray = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    ENLIST_TRACKING(CWinNTJobsEnumVar);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::~CWinNTJobsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTJobsEnumVar::~CWinNTJobsEnumVar()
{
    if (_pSafeArray != NULL)
        SafeArrayDestroy(_pSafeArray);

    _pSafeArray = NULL;
    if(_pszADsPrinterPath){
        FreeADsStr(_pszADsPrinterPath);
    }
}


HRESULT CWinNTJobsEnumVar::Create(HANDLE hPrinter,
                                  LPTSTR szADsPrinterPath,
                                  CWinNTCredentials& Credentials,
                                  CWinNTJobsEnumVar ** ppCJobsEnumVar)
{

    //
    //  This function uses the handle to the printer to query for the
    // number of jobs(cJobs) on the printer, It uses the returned value
    // to create a safearray of cJobs number of Job Objects.
    //

    HRESULT hr;
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE| READ_CONTROL};

    OBJECTINFO ObjectInfo;
    CLexer Lexer(szADsPrinterPath);

    CWinNTJobsEnumVar FAR* pCJobsEnumVar = NULL;

    *ppCJobsEnumVar = NULL;

    memset((void*)&ObjectInfo, 0, sizeof(OBJECTINFO));

    pCJobsEnumVar = new CWinNTJobsEnumVar();

    if (pCJobsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCJobsEnumVar->_pszADsPrinterPath = AllocADsStr(szADsPrinterPath);

    if (!(pCJobsEnumVar->_pszADsPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = Object(&Lexer, &ObjectInfo);
    BAIL_ON_FAILURE(hr);

    pCJobsEnumVar->_Credentials = Credentials;
    // We want the next-to-last element in the array.
    ADsAssert(ObjectInfo.NumComponents >= 2);
    hr = pCJobsEnumVar->_Credentials.RefServer(
        ObjectInfo.ComponentArray[(ObjectInfo.NumComponents - 1) - 1]);
    BAIL_ON_FAILURE(hr);

    //
    // Fill in the safearray with relevant information here
    //

    hr = FillSafeArray(hPrinter, szADsPrinterPath, pCJobsEnumVar->_Credentials,
        pCJobsEnumVar);

    BAIL_ON_FAILURE(hr);

    *ppCJobsEnumVar = pCJobsEnumVar;

    //
    // Free the objectInfo data
    //
    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(S_OK);

error:

    //
    // Free the objectInfo data
    //
    FreeObjectInfo( &ObjectInfo, TRUE );
    delete pCJobsEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}



//+------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTJobsEnumVar::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    if(!ppv){
        RRETURN(E_POINTER);
    }
    *ppv = NULL;

    if (iid == IID_IUnknown )
    {
        *ppv = this;
    }
    else if(iid == IID_IEnumVARIANT)
    {
        *ppv = (IEnumVARIANT *)this;
    }

    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Job objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTJobsEnumVar::Next(ULONG ulNumElementsRequested,
                        VARIANT FAR* pvar,
                        ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched;


    if (pulNumFetched != NULL)
        *pulNumFetched = 0;

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++)
        VariantInit(&pvar[l]);

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        hresult = SafeArrayGetElement(_pSafeArray, &lNewCurrent,
                                      &pvar[lNumFetched]);
        //
        // Something went wrong!!!
        //

        if (FAILED(hresult)){
            for (l=0; l<ulNumElementsRequested; l++)
                VariantClear(&pvar[l]);

            ADsAssert(hresult == S_FALSE);
            return(S_FALSE);

        }                               // End of If Failed
    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Skip(ULONG cElements)
{
    //
    // Skip the number of elements requested
    //

    _lCurrentPosition += cElements;

    //
    // if we went outside of the boundaries unskip
    //

    if (_lCurrentPosition > (LONG)(_lLBound +_cElements)){
        _lCurrentPosition =  _lLBound +_cElements;
        return (S_FALSE);
    }
    else
        RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Reset()
{
    //
    //Just move the CurrentPosition to the lower array boundary
    //

    _lCurrentPosition = _lLBound;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


HRESULT FillSafeArray(HANDLE hPrinter,
                      LPTSTR szPrinterPath,
                      CWinNTCredentials& Credentials,
                      CWinNTJobsEnumVar *pJobsEnumVar )
{
    BOOL fStatus = FALSE;
    DWORD   dwPassed =0, dwNeeded = 0;
    DWORD   dwcJobs;            // Number of jobs in print queue
    LPPRINTER_INFO_2 pPrinterInfo2;
    DWORD   dwError = 0, LastError =0;
    LPBYTE  pMem    = NULL;
    LPBYTE  lpbJobs = NULL;
    DWORD   cbBuf =0;
    DWORD   dwReturned =0;
    CWinNTPrintJob *pCWinNTPrintJob = NULL;
    SAFEARRAYBOUND sabound[1];
    IDispatch *pDispatch;
    VARIANT v;
    LONG l;
    HRESULT hr = S_OK;
    LPJOB_INFO_1 lpJobInfo1 = NULL;

    if(hPrinter == NULL){
        RRETURN_EXP_IF_ERR(HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE));
    }

    VariantInit(&v);

    //
    // First Get info from  printer to determine the number of jobs.
    // AjayR: 10-01-99. We always expect this call to fail but tell
    // us how much memory is needed !!!
    //

    fStatus = GetPrinter(hPrinter,
                         2,
                         (LPBYTE)pMem,
                         dwPassed,
                         &dwNeeded
                         );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {
        case ERROR_INSUFFICIENT_BUFFER:
            if (pMem){
                FreeADsMem(pMem);
            }
            dwPassed = dwNeeded;
            pMem = (LPBYTE)AllocADsMem(dwPassed);

            if (!pMem) {

                hr = E_OUTOFMEMORY;
                break;
            }

            fStatus = GetPrinter(hPrinter,
                                 2,
                                 (LPBYTE)pMem,
                                 dwPassed,
                                 &dwNeeded
                                 );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());;
            break;

        }
    }

    if(FAILED(hr))
        goto error;

    pPrinterInfo2 =(LPPRINTER_INFO_2)pMem;
    dwcJobs = pPrinterInfo2->cJobs;

    fStatus = MyEnumJobs(hPrinter,
                         0,                          // First job you want
                         dwcJobs,
                         1,                          //Job Info level
                         &lpbJobs,
                         &cbBuf,
                         &dwReturned
                         );

    if(!fStatus){
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //
    // Use the array bound as the number of jobs returned, not
    // the number of jobs you requested, this may have changed!
    //

    sabound[0].cElements = dwReturned;
    sabound[0].lLbound = 0;

    //
    // Create a one dimensional SafeArray
    //

    pJobsEnumVar->_pSafeArray  = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (pJobsEnumVar->_pSafeArray == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    //
    // for each of the Jobs retrieved create the appropriate structure
    //

    for(l=0; l<(LONG)dwReturned; l++){

        lpJobInfo1 = (LPJOB_INFO_1)(lpbJobs +l*sizeof(JOB_INFO_1));

        hr = CWinNTPrintJob::CreatePrintJob(
                                    szPrinterPath,
                                    lpJobInfo1->JobId,
                                    ADS_OBJECT_BOUND,
                                    IID_IDispatch,
                                    Credentials,
                                    (void **)&pDispatch
                                    );

        if(FAILED(hr)){
            break;
        }

        VariantInit(&v);
        V_VT(&v) = VT_DISPATCH;
        V_DISPATCH(&v) = pDispatch;

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(pJobsEnumVar->_pSafeArray, &l, &v);
        VariantClear(&v);

        if (FAILED(hr)){
            break;
        }
        pJobsEnumVar->_cElements++;

    }

    BAIL_ON_FAILURE(hr);


    if (pMem) {
        FreeADsMem(pMem);
    }

    if(lpbJobs){
        FreeADsMem(lpbJobs);
    }

    RRETURN(S_OK);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    //
    // Free the buffer you just allocated
    //

    if (lpbJobs){
        FreeADsMem(lpbJobs);
    }

    //
    // Destroy the safearray
    //

    if(pJobsEnumVar->_pSafeArray != NULL)
        SafeArrayDestroy(pJobsEnumVar->_pSafeArray);

    VariantClear(&v);
    RRETURN_EXP_IF_ERR(hr);
}



BOOL
MyEnumJobs(HANDLE hPrinter,
           DWORD  dwFirstJob,
           DWORD  dwNoJobs,
           DWORD  dwLevel,
           LPBYTE *lplpbJobs,
           DWORD  *pcbBuf,
           LPDWORD lpdwReturned
           )
{

    BOOL fStatus = FALSE;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;


    fStatus = EnumJobs(hPrinter,
                       dwFirstJob,
                       dwNoJobs,
                       dwLevel,
                       *lplpbJobs,
                       *pcbBuf,
                       &dwNeeded,
                       lpdwReturned
                       );


    if (!fStatus) {
        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;


            fStatus = EnumJobs(hPrinter,
                               dwFirstJob,
                               dwNoJobs,
                               dwLevel,
                               *lplpbJobs,
                               *pcbBuf,
                               &dwNeeded,
                               lpdwReturned
                               );

            if (!fStatus) {
                return(FALSE);

            }else {
                return(TRUE);
            }
        }else {
            return(FALSE);
        }
    }else {
        return(TRUE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr(
        IUnknown FAR * pUnkOuter
        ):
    _pUnkOuter(pUnkOuter),
    _pClassEntry(NULL),
    _pDispMgr(NULL),
    _fExtensionsLoaded(FALSE)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPTSTR pszClassName,
    CWinNTCredentials& Credentials,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr(pUnkOuter);
    if (!pExtMgr)
        RRETURN(E_OUTOFMEMORY);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;


    //
    // Read the list of extension object of the same class from registry
    //

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );
    BAIL_ON_FAILURE(hr);

    pExtMgr->_Credentials = Credentials;

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}


//
// Instantiate extension objects listed in _pClassEntry as aggregates of
// aggregator _pUnkOuter. Initialize extensions with <Credentials>.
//
// Max Load 127 extensions.
// 

HRESULT
CADsExtMgr::LoadExtensions(
    CWinNTCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;          // dummy for winnt
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;


    //
    // Extensions (ext mgr) do(es) not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);


    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    _pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );


        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //
        // no warning to user about failure
        //


        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any.
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarPassword) = VT_BSTR;

                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName,
                        varPassword,
                        varAuthFlags
                        );
                //
                // Free them as they are reused
                //
                VariantClear(pvarUserName);
                VariantClear(pvarPassword);
            }

        } // end if CoCreateInstance() succeeded


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    VariantClear(pvarUserName);
    VariantClear(pvarPassword);
    VariantClear(pvarAuthFlags);

    if (fReturnError) {
        RRETURN(hr);        // fetal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}

HRESULT 
CADsExtMgr::LoadExtensionsIfReqd(void)
{
    HRESULT hr = S_OK;

    if(FALSE == _fExtensionsLoaded) {
        hr = LoadExtensions(_Credentials);
        BAIL_ON_FAILURE(hr);
 
        hr = FinalInitializeExtensions(); // this call never fails
        BAIL_ON_FAILURE(hr);

        _fExtensionsLoaded = TRUE;
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {

                hr = LoadExtensionsIfReqd();
                if(FAILED(hr))
                    RRETURN(E_NOINTERFACE);

                pUnknown = pExtensionEntry->pUnknown;

                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}



HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CWinNTCredentials& Credentials,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            pszClassName,
            Credentials,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        hr = LoadExtensionsIfReqd();
        if(FAILED(hr))
            RRETURN(DISP_E_UNKNOWNNAME);

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    // Shouldn't really be required here, but just being paranoid.
    hr = LoadExtensionsIfReqd();
    if(FAILED(hr))
        RRETURN(DISP_E_MEMBERNOTFOUND);
    
    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ADsAssert(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}



//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-28-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{

    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT vDummy;

    VariantInit(&vDummy);

    //
    // Extensions (ext mgr) does not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);

    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            hr = (pExtEntry->pADsExt)->Operate(
                      ADS_EXT_INITIALIZE_COMPLETE,
                      vDummy,
                      vDummy,
                      vDummy
                      );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // We need to return S_OK here as otherwise just because
    // the final initialization of one extension failed - we
    // will hold up the entire lot.
    //
    RRETURN(S_OK);

}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForIID
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. 
//             If the IID is one of the interfaces implemented by the 
//             extension manager, then the extension's CLSID is returned.
//
// Arguments:
//
// riid        Interface ID for which we want to find the CLSID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    HRESULT hr = S_OK;

    ADsAssert( (0 == lFlags) && (pCLSID != NULL) );

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, riid)) {
                *pCLSID = pExtensionEntry->ExtCLSID;
                RRETURN(S_OK);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = UMI_E_NOT_FOUND);
}

//----------------------------------------------------------------------------
// Function:   GetObjectByCLSID
//
// Synopsis:   Returns a pointer to a requested interface on the object
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown on return. The 
//             interface returned is a non-delegating interface on the object.
//
// Arguments:
//
// clsid       CLSID of object on which interface should be obtained
// pUnkOuter   Aggregating outer unknown
// riid        Interface requested
// ppInterface Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppInterface
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;
    IUnknown *pPrevUnk = NULL, *pUnknown = NULL;

    ADsAssert( (ppInterface != NULL) && (pUnkOuter != NULL) );

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        if (IsEqualCLSID(pExtensionEntry->ExtCLSID, clsid)) {
           pPrevUnk = _pUnkOuter;

           _pUnkOuter = pUnkOuter;

           hr = LoadExtensionsIfReqd();
           if(FAILED(hr)) {
               _pUnkOuter = pPrevUnk;
               BAIL_ON_FAILURE(hr = UMI_E_FAIL);
           }

           pUnknown = pExtensionEntry->pUnknown; 

           if (!pUnknown) {

                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
           }

           *ppInterface = pUnknown;
           pUnknown->AddRef();

           RRETURN(S_OK);
       }

       pExtensionEntry = pExtensionEntry->pNext;
    }

    RRETURN(UMI_E_NOT_FOUND);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForNames
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:
//
// rgszNames   Names to be mapped
// cNames      Number of names to be mapped
// lcid        Locale in which to interpret the names
// rgDispId    Returns DISPID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns CLSID of object which supports this property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;

    ADsAssert( (pCLSID != NULL) && (0 == lFlags) && (rgszNames != NULL) &&
               (rgDispId != NULL) );

    if (!_pClassEntry) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    hr = LoadExtensionsIfReqd();
    if(FAILED(hr))
        RRETURN(DISP_E_UNKNOWNNAME);    

    pExtension = _pClassEntry->pExtensionHead;

    while(pExtension) {
        if (pExtension->fDisp) {
            //
            // fDisp = TRUE indicates
            //  1)  extension supports pADsExt AND
            //  2)  either
            //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
            //      OR
            //      b) we don't know if a) is true or not yet
            //

            ADsAssert(pExtension->pADsExt);

            hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          IID_NULL,
                          rgszNames,
                          cNames,
                          lcid,
                          rgDispId
                          );

            if (SUCCEEDED(hr)) {
                *pCLSID = pExtension->ExtCLSID;
                RRETURN(S_OK);
            }

            else if (hr == E_NOTIMPL) {
            //
            // extension object does not support the optional
            // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
            // -> remember this in cache & try next extension object
            //
                pExtension->fDisp = FALSE;
            }
        } 

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(hr = DISP_E_UNKNOWNNAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfpnwsrv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwsrv.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWFileService and CFPNWFileServiceGeneralInfo.
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------



#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// class CFPNWFileService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CFPNWFileService);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWFileService);
DEFINE_IADs_TempImplementation(CFPNWFileService);

CFPNWFileService::CFPNWFileService()
{
    _pDispMgr = NULL;
    _pExtMgr  = NULL;
    _pService = NULL;
    _pCFileSharesEnumVar = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CFPNWFileService);
    VariantInit(&_vFilter);
    return;

}

CFPNWFileService::~CFPNWFileService()
{
    if(_pService){
        _pService->Release();
    }

    if (_pServiceOps) {
        _pServiceOps->Release();
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    VariantClear(&_vFilter);

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::CreateFileService
//
//  Synopsis:   Static function used to create a FileService object. This
//              will be called by BindToObject
//
//  Arguments:  [ppFPNWFileService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CFPNWFileService::CreateFileService(LPTSTR pszADsParent,
                                    DWORD  dwParentId,
                                    LPTSTR pszDomainName,
                                    LPTSTR pszServerName,
                                    LPTSTR pszFileServiceName,
                                    DWORD  dwObjectState,
                                    REFIID riid,
                                    CWinNTCredentials& Credentials,
                                    LPVOID * ppvoid
                                    )

{
    CFPNWFileService FAR * pCFPNWFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Create the FileService Object
    //

    hr = AllocateFileServiceObject(&pCFPNWFileService);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileService->_pDispMgr);


    hr = pCFPNWFileService->InitializeCoreObject(pszADsParent,
                                                 pszFileServiceName,
                                                 FILESERVICE_CLASS_NAME,
                                                 FPNW_FILESERVICE_SCHEMA_NAME,
                                                 CLSID_FPNWFileService,
                                                 dwObjectState);
    //
    // note that no class fileservice is defined
    //

    BAIL_ON_FAILURE(hr);


    pCFPNWFileService->_Credentials = Credentials;
    hr = pCFPNWFileService->_Credentials.Ref(pszServerName,
        pszDomainName, dwParentId);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTService::Create(pszADsParent,
                               pszDomainName,
                               pszServerName,
                               pszFileServiceName,
                               dwObjectState,
                               IID_IADsService,
                               pCFPNWFileService->_Credentials,
                               (void **)(&(pCFPNWFileService->_pService)));

    BAIL_ON_FAILURE(hr);


    hr = (pCFPNWFileService->_pService)->QueryInterface(
                   IID_IADsServiceOperations,
                   (void **)&(pCFPNWFileService->_pServiceOps));
    BAIL_ON_FAILURE(hr);


    pCFPNWFileService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFPNWFileService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFPNWFileService->_Credentials = Credentials;
    hr = pCFPNWFileService->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *) pCFPNWFileService,
                pCFPNWFileService->_pDispMgr,
                Credentials,
                &pCFPNWFileService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileService->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCFPNWFileService->_dwNumComponents) {
            pCFPNWFileService->_CompClasses[0] = L"Domain";
            pCFPNWFileService->_CompClasses[1] = L"Computer";
            pCFPNWFileService->_CompClasses[2] = L"FileService";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCFPNWFileService->InitUmiObject(
                 pCFPNWFileService->_Credentials,
                 FPNWFileServiceClass,
                 gdwFPNWFileServiceTableSize,
                 pCFPNWFileService->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCFPNWFileService,
                 pCFPNWFileService->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    hr = pCFPNWFileService->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCFPNWFileService->Release();

    RRETURN(hr);

error:

    delete pCFPNWFileService;
    RRETURN (hr);
}

HRESULT
CFPNWFileService::AllocateFileServiceObject(
                    CFPNWFileService  ** ppFileService
                    )
{
    CFPNWFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    pFileService = new CFPNWFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pFileService->_pDispMgr = new CAggregatorDispMgr;
    if (pFileService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pFileService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsFileService,
                           (IADsFileService *)pFileService,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *)pFileService,
                            DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pFileService,
                            DISPID_VALUE);
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             FPNWFileServiceClass,
             gdwFPNWFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pFileService->_pDispMgr)->RegisterPropertyCache(
                                  pFileService->_pPropertyCache
                                  );

    *ppFileService = pFileService;

    RRETURN(hr);


error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pFileService;

    RRETURN_EXP_IF_ERR(hr);

}



/* IUnknown methods for file service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWFileService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsServiceOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::SetInfo(THIS)
{
    HRESULT hr;
    IADsService * pADsService = NULL;

    ADsAssert(_pService);

    hr = _pService->SetInfo();
    BAIL_IF_ERROR(hr);

    hr = SetFPNWServerInfo();
    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::GetInfo(THIS)
{
    HRESULT hr =S_OK;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(1, TRUE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::ImplicitGetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, FALSE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    HRESULT hr =S_OK;
    DWORD dwErrCode;
    switch(dwApiLevel){

    case 1:
        ADsAssert(_pService);
        hr = _pService->GetInfo();
        BAIL_IF_ERROR(hr);
        break;

    case 2:

        hr = GetFPNWServerInfo(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN (hr);
}


HRESULT
CFPNWFileService::SetFPNWServerInfo(THIS)
{
    PNWSERVERINFO pServerInfo = NULL;
    HRESULT hr = S_OK;
    DWORD dwErrorCode;
    LPTSTR pszDescription = NULL;

    //
    // Do a GetInfo to first get all the information in this server.
    //
    //
    // only level 1 is valid
    //

    dwErrorCode = ADsNwServerGetInfo(_pszServerName,
                                     1,
                                     &pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Description"),
                                    &pszDescription );

    if(SUCCEEDED(hr)){
        pServerInfo->lpDescription = pszDescription;
    }

    dwErrorCode = ADsNwServerSetInfo(_pszServerName,
                                     1,
                                     pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

cleanup:
    if(pServerInfo){
        ADsNwApiBufferFree(pServerInfo);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CFPNWFileService::GetFPNWServerInfo(THIS_ BOOL fExplicit)
{
    //
    // here we do a NwServerGetInfo on level1 and then unmarshall the
    // comment field into description
    //

    DWORD dwErrorCode;
    PNWSERVERINFO pServerInfo =NULL;
    HRESULT hr;

    //
    // only level 1 is valid
    //

    dwErrorCode = ADsNwServerGetInfo(_pszServerName,
                                     1,
                                     &pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);


    //
    // unmarshall the info into the Description field
    //

    ADsAssert(pServerInfo);


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  pServerInfo->lpDescription,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  _Parent,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("MaxUserCount"),
                                 (DWORD)-1,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(pServerInfo){
        ADsNwApiBufferFree(pServerInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    hr = GenericGetPropertyManager(
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->Get(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWFileService::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;

    hr = GenericPutPropertyManager(
                _pPropertyCache,
                FPNWFileServiceClass,
                gdwFPNWFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->Put(bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


//
// IADsService Methods
//


/* IADsContainer methods */

STDMETHODIMP
CFPNWFileService::get_Count(long * retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::get_Filter(THIS_ VARIANT * pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CFPNWFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::GetObject(THIS_ BSTR ClassName,
                             BSTR RelativeName,
                             IDispatch * FAR* ppObject
                             )
{
    HRESULT hr;
    DWORD dwObjectType;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials);

    BAIL_ON_FAILURE(hr);

    //
    // The only object that has a file service as a container is
    // a file share object
    //

    hr = CFPNWFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject);

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;

    CFPNWFileSharesEnumVar *pCFileSharesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *retval = NULL;

    hr = CFPNWFileSharesEnumVar::Create(_pszServerName,
                                        _ADsPath,
                                        &pCFileSharesEnumVar,
                                        _vFilter,
                                        _Credentials);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFileSharesEnumVar);

    _pCFileSharesEnumVar = pCFileSharesEnumVar;

    hr = _pCFileSharesEnumVar->QueryInterface(IID_IUnknown,
                                              (void **)retval);

    BAIL_ON_FAILURE(hr);

    _pCFileSharesEnumVar->Release();

    RRETURN(hr);

error:
    delete pCFileSharesEnumVar;

    _pCFileSharesEnumVar = NULL;



    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWFileService::Create(
        THIS_ BSTR ClassName,
        BSTR RelativeName,
        IDispatch * FAR* ppObject
        )
{

    DWORD dwObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);


    if(!(dwObjectType == WINNT_FILESHARE_ID ||
         dwObjectType == WINNT_FPNW_FILESHARE_ID)){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }



    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials);

    if(SUCCEEDED(hr)){
        hr = E_ADS_OBJECT_EXISTS;
        goto error;
    }

    //
    // The only object that has a file service as a container is
    // a file share object



    hr = CFPNWFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject);

    BAIL_ON_FAILURE(hr);



error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::Delete(THIS_ BSTR Type,
                          BSTR SourceName
                          )
{
    HRESULT hr;
    DWORD dwObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;

    // Check to make sure the input parameters are valid
    if (Type == NULL || SourceName == NULL) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       Type,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);


    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to delete an invalid object at this level
        //
        hr = E_FAIL;
        goto cleanup;

    }



    hr = BuildObjectInfo(_ADsPath,
                         SourceName,
                         &pObjectInfo);

    BAIL_IF_ERROR(hr);

    hr = FPNWDeleteFileShare(pObjectInfo);


cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::CopyHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::MoveHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



/* IADsFSFileServiceGeneralInfo methods */


STDMETHODIMP
CFPNWFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CFPNWFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CFPNWFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    //
    // here -1 signifies no limit
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = -1;
    RRETURN(S_OK);
}

STDMETHODIMP CFPNWFileService::put_MaxUserCount(THIS_ long lMaxUserCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}



STDMETHODIMP
CFPNWFileService::Sessions(THIS_ IADsCollection ** ppSessions)
{
    //
    // The session collection object is created and it is passed the server
    // name. It uses this to create the session object
    //

    HRESULT hr = S_OK;

    CFPNWSessionsCollection * pSessionsCollection = NULL;

    if(!ppSessions){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CFPNWSessionsCollection::Create(_ADsPath,
                                         _Credentials,
                                          &pSessionsCollection);

    BAIL_IF_ERROR(hr);

    hr = pSessionsCollection->QueryInterface(IID_IADsCollection,
                                             (void **) ppSessions);

    BAIL_IF_ERROR(hr);

    pSessionsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pSessionsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::Resources(THIS_ IADsCollection FAR* FAR* ppResources)
{
    //
    // The resource collection object is created and it is passed the server
    // name. It uses this to create the resource object
    //

    HRESULT hr = S_OK;

    CFPNWResourcesCollection * pResourcesCollection = NULL;

    if(!ppResources){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CFPNWResourcesCollection::Create(_ADsPath,
                                           NULL,
                                           _Credentials,
                                           &pResourcesCollection);

    BAIL_IF_ERROR(hr);

    hr = pResourcesCollection->QueryInterface(IID_IADsCollection,
                                              (void **) ppResources);

    BAIL_IF_ERROR(hr);

    pResourcesCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pResourcesCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_HostComputer(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    HRESULT hr;
    hr = _pService->put_HostComputer(bstrHostComputer);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_DisplayName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    HRESULT hr;
    hr = _pService->put_DisplayName(bstrDisplayName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Version(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Version(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Version(THIS_ BSTR bstrVersion)
{
    HRESULT hr;
    hr = _pService->put_Version(bstrVersion);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ServiceType(THIS_ long FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceType(THIS_ long lServiceType)
{
    HRESULT hr;
    hr = _pService->put_ServiceType(lServiceType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_StartType(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_StartType(THIS_ LONG lStartType)
{
    HRESULT hr;
    hr = _pService->put_StartType(lStartType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Path(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Path(THIS_ BSTR bstrPath)
{
    HRESULT hr;
    hr = _pService->put_Path(bstrPath);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartupParameters(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    HRESULT hr;
    hr = _pService->put_StartupParameters(bstrStartupParameters);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ErrorControl(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    HRESULT hr;
    hr = _pService->put_ErrorControl(lErrorControl);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_LoadOrderGroup(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    HRESULT hr;
    hr = _pService->put_LoadOrderGroup(bstrLoadOrderGroup);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountName(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountPath(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountPath(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Dependencies(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    HRESULT hr;
    hr = _pService->put_Dependencies(vDependencies);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr;
    hr = _pServiceOps->SetPassword(bstrNewPassword);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::Start(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Start();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Stop(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Stop();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Pause(THIS)

{
    HRESULT hr;
    hr = _pServiceOps->Pause();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Continue(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Continue();
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr;
    hr = _pServiceOps->get_Status(plStatusCode);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericGetExPropertyManager(
                ADS_OBJECT_BOUND,
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->GetEx(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericPutExPropertyManager(
                _pPropertyCache,
                FPNWFileServiceClass,
                gdwFPNWFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->PutEx(lnControlCode, bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfserv.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTFileService and CWinNTFileServiceGeneralInfo.
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------



#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

//
// class CWinNTFileService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTFileService);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTFileService);
DEFINE_IADs_TempImplementation(CWinNTFileService);
DEFINE_IADsPropertyList_Implementation(CWinNTFileService, FileServiceClass, gdwFileServiceTableSize)

CWinNTFileService::CWinNTFileService()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pService = NULL;
    _pServiceOps = NULL;
    _pszServerName = NULL;
    VariantInit(&_vFilter);
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTFileService);
    return;

}

CWinNTFileService::~CWinNTFileService()
{
    if(_pService){
        _pService->Release();
    }

    if (_pServiceOps) {
        _pServiceOps->Release();
    }


    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    VariantClear(&_vFilter);

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::CreateFileService
//
//  Synopsis:   Static function used to create a FileService object. This
//              will be called by BindToObject
//
//  Arguments:  [ppWinNTFileService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CWinNTFileService::CreateFileService(LPTSTR pszADsParent,
                                     DWORD  dwParentId,
                                     LPTSTR pszDomainName,
                                     LPTSTR pszServerName,
                                     LPTSTR pszFileServiceName,
                                     DWORD  dwObjectState,
                                     REFIID riid,
                                     CWinNTCredentials& Credentials,
                                     LPVOID * ppvoid
                                     )

{
    CWinNTFileService FAR * pCWinNTFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Create the FileService Object
    //

    hr = AllocateFileServiceObject(&pCWinNTFileService);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileService->_pDispMgr);


    hr = pCWinNTFileService->InitializeCoreObject(pszADsParent,
                                                  pszFileServiceName,
                                                  FILESERVICE_CLASS_NAME,
                                                  FILESERVICE_SCHEMA_NAME,
                                                  CLSID_WinNTFileService,
                                                  dwObjectState);


    BAIL_ON_FAILURE(hr);

    pCWinNTFileService->_Credentials = Credentials;
    hr = pCWinNTFileService->_Credentials.Ref(pszServerName,
        pszDomainName, dwParentId);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTService::Create(pszADsParent,
                               pszDomainName,
                               pszServerName,
                               pszFileServiceName,
                               dwObjectState,
                               IID_IADsService,
                               pCWinNTFileService->_Credentials,
                               (void **)(&(pCWinNTFileService->_pService)));

    BAIL_ON_FAILURE(hr);


    hr = (pCWinNTFileService->_pService)->QueryInterface(
                    IID_IADsServiceOperations,
                    (void **)&(pCWinNTFileService->_pServiceOps));
    BAIL_ON_FAILURE(hr);



    pCWinNTFileService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCWinNTFileService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *) pCWinNTFileService,
                pCWinNTFileService->_pDispMgr,
                Credentials,
                &pCWinNTFileService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileService->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCWinNTFileService->_dwNumComponents) {
            pCWinNTFileService->_CompClasses[0] = L"Domain";
            pCWinNTFileService->_CompClasses[1] = L"Computer";
            pCWinNTFileService->_CompClasses[2] = L"FileService";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCWinNTFileService->InitUmiObject(
                 pCWinNTFileService->_Credentials,
                 FileServiceClass, 
                 gdwFileServiceTableSize,
                 pCWinNTFileService->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCWinNTFileService,
                 pCWinNTFileService->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }
                 
    hr = pCWinNTFileService->QueryInterface(riid,
                                            (void **)ppvoid);


    BAIL_ON_FAILURE(hr);

    pCWinNTFileService->Release();

    RRETURN(hr);

error:

    delete pCWinNTFileService;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTFileService::AllocateFileServiceObject(
    CWinNTFileService ** ppFileService
    )
{
    CWinNTFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    pFileService = new CWinNTFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pFileService->_pDispMgr = new CAggregatorDispMgr;
    if (pFileService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pFileService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsFileService,
                           (IADsFileService *)pFileService,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *)pFileService,
                            DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(
                pFileService->_pDispMgr,
                LIBID_ADs,
                IID_IADsFileServiceOperations,
                (IADsFileServiceOperations *)pFileService,
                DISPID_REGULAR
                );

    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(
                pFileService->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pFileService,
                DISPID_VALUE
                );

    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             FileServiceClass,
             gdwFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pFileService->_pDispMgr)->RegisterPropertyCache(
                                    pFileService->_pPropertyCache
                                    );


    *ppFileService = pFileService;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pFileService;

    RRETURN(hr);

}



/* IUnknown methods for file service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTFileService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService*)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService *)this;

    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations *)this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::SetInfo(THIS)
{
    HRESULT hr;
    IADsService * pADsService = NULL;

    ADsAssert(_pService);

    hr = _pService->SetInfo();
    BAIL_IF_ERROR(hr);

    hr = SetLevel1005Info();

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::GetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, TRUE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::ImplicitGetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, FALSE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    HRESULT hr =S_OK;

    switch(dwApiLevel){

    case 1:
        ADsAssert(_pService);
        hr = _pService->GetInfo();
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetLevel101Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN (hr);
}


STDMETHODIMP
CWinNTFileService::SetLevel1005Info(THIS)
{
    SERVER_INFO_1005 ServerInfo;
    NET_API_STATUS  nasStatus;
    HRESULT hr = S_OK;
    LPTSTR pszDescription = NULL;

    memset(&ServerInfo, 0, sizeof(ServerInfo));

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)){
        ServerInfo.sv1005_comment = pszDescription;
    }

    nasStatus = NetServerSetInfo(_pszServerName,
                                 1005,
                                 (LPBYTE)(&ServerInfo),
                                 NULL
                                 );

    hr = HRESULT_FROM_WIN32(nasStatus);

    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::GetLevel101Info(THIS_ BOOL fExplicit)
{
    //
    // here we do a NetServerGetInfo on level101 and then unmarshall the
    // comment field into description
    //

    NET_API_STATUS nasStatus;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    HRESULT hr;

    //
    // level 101 is available with user permissions,
    // Level 1005 is preferable but exists only in LanMan 2.0
    //

    nasStatus = NetServerGetInfo(_pszServerName,
                                 101,
                                 (LPBYTE *)&lpServerInfo
                                 );

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_IF_ERROR(hr);


    //
    // unmarshall the info into the Description field
    //

    ADsAssert(lpServerInfo);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpServerInfo->sv101_comment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  _Parent,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                   (DWORD)-1,
                                   fExplicit
                                   );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    hr = S_OK;

cleanup:
    if(lpServerInfo)
        NetApiBufferFree(lpServerInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    hr= _pService->Get(bstrName, pvProp );

    if(FAILED(hr)){
        hr = GenericGetPropertyManager(
                   _pPropertyCache,
                   bstrName,
                   pvProp
                   );
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTFileService::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;

    hr= _pService->Put(bstrName, vProp );

    if(FAILED(hr)){
        hr = GenericPutPropertyManager(_pPropertyCache,
                                       FileServiceClass,
                                       gdwFileServiceTableSize,
                                       bstrName,
                                       vProp);
    }

    RRETURN_EXP_IF_ERR(hr);

}


//
// IADsService Methods
//


/* IADsContainer methods */

STDMETHODIMP
CWinNTFileService::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTFileService::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    RRETURN(VariantCopy(&_vFilter, &Var));
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::GetObject(THIS_ BSTR ClassName,
                             BSTR RelativeName,
                             IDispatch * FAR* ppObject
                             )
{
    HRESULT hr;
    DWORD dwObjectType;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials
                        );

    BAIL_ON_FAILURE(hr);

    //
    // The only object that has a file service as a container is
    // a file share object
    //
    hr = CWinNTFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject
                                 );

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    CWinNTFileSharesEnumVar *pCFileSharesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTFileSharesEnumVar::Create(_pszServerName,
                                         _ADsPath,
                                         &pCFileSharesEnumVar,
                                         _vFilter,
                                         _Credentials);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFileSharesEnumVar);

    hr = pCFileSharesEnumVar->QueryInterface(IID_IUnknown,
                                             (void **)retval);

    BAIL_ON_FAILURE(hr);

    pCFileSharesEnumVar->Release();

    RRETURN(hr);

error:
    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Create(THIS_ BSTR ClassName,
                          BSTR RelativeName,
                          IDispatch * FAR* ppObject
                          )
{

    DWORD dwObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials
                        );

    if(SUCCEEDED(hr)){
        hr = E_ADS_OBJECT_EXISTS;
        goto error;
    }

    //
    // The only object that has a file service as a container is
    // a file share object

    hr = CWinNTFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject
                                 );

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::Delete(THIS_ BSTR Type,
                          BSTR SourceName
                          )
{
    HRESULT hr;
    DWORD dwObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;

    // Make sure the input parameters are valid
    if (Type == NULL || SourceName == NULL) {
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       Type,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to delete an invalid object at this level
        //
        hr = E_FAIL;
        goto cleanup;

    }

    hr = BuildObjectInfo(_ADsPath,
                         SourceName,
                         &pObjectInfo
                         );

    BAIL_IF_ERROR(hr);

    hr = WinNTDeleteFileShare(pObjectInfo);


cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTFileService::CopyHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTFileService::MoveHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CWinNTFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CWinNTFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CWinNTFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    //
    // here -1 signifies no limit
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = -1;
    RRETURN(S_OK);
}

STDMETHODIMP CWinNTFileService::put_MaxUserCount(THIS_ long lnMaxUserCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CWinNTFileService::Sessions(THIS_ IADsCollection FAR* FAR* ppSessions)
{
    //
    // The session collection object is created and it is passed the server
    // name. It uses this to create the session object
    //

    HRESULT hr = S_OK;
    CWinNTSessionsCollection * pSessionsCollection = NULL;

    if(!ppSessions){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CWinNTSessionsCollection::Create(_ADsPath,
                                          NULL,
                                          NULL,
                                          _Credentials,
                                          &pSessionsCollection
                                          );

    BAIL_IF_ERROR(hr);

    hr = pSessionsCollection->QueryInterface(IID_IADsCollection,
                                             (void **) ppSessions);

    BAIL_IF_ERROR(hr);

    pSessionsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pSessionsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Resources(THIS_ IADsCollection FAR* FAR* ppResources)
{
    //
    // The resource collection object is created and it is passed the server
    // name. It uses this to create the resource object
    //

    HRESULT hr = S_OK;
    CWinNTResourcesCollection * pResourcesCollection = NULL;

    if(!ppResources){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CWinNTResourcesCollection::Create(_ADsPath,
                                           NULL,
                                           NULL,
                                           _Credentials,
                                           &pResourcesCollection
                                           );

    BAIL_IF_ERROR(hr);

    hr = pResourcesCollection->QueryInterface(IID_IADsCollection,
                                              (void **) ppResources
                                              );

    BAIL_IF_ERROR(hr);

    pResourcesCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pResourcesCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_HostComputer(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    HRESULT hr;
    hr = _pService->put_HostComputer(bstrHostComputer);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_DisplayName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    HRESULT hr;
    hr = _pService->put_DisplayName(bstrDisplayName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Version(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Version(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Version(THIS_ BSTR bstrVersion)
{
    HRESULT hr;
    hr = _pService->put_Version(bstrVersion);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceType(THIS_ long FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceType(THIS_ long lServiceType)
{
    HRESULT hr;
    hr = _pService->put_ServiceType(lServiceType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_StartType(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_StartType(THIS_ LONG lStartType)
{
    HRESULT hr;
    hr = _pService->put_StartType(lStartType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Path(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Path(THIS_ BSTR bstrPath)
{
    HRESULT hr;
    hr = _pService->put_Path(bstrPath);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartupParameters(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    HRESULT hr;
    hr = _pService->put_StartupParameters(bstrStartupParameters);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ErrorControl(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    HRESULT hr;
    hr = _pService->put_ErrorControl(lErrorControl);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_LoadOrderGroup(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    HRESULT hr;
    hr = _pService->put_LoadOrderGroup(bstrLoadOrderGroup);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountName(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountPath(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountPath(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Dependencies(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    HRESULT hr;
    hr = _pService->put_Dependencies(vDependencies);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr;
    hr = _pServiceOps->SetPassword(bstrNewPassword);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::Start(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Start();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Stop(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Stop();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Pause(THIS)

{
    HRESULT hr;
    hr = _pServiceOps->Pause();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Continue(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Continue();
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr;
    hr = _pServiceOps->get_Status(plStatusCode);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericGetExPropertyManager(
                ADS_OBJECT_BOUND,
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->GetEx(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericPutExPropertyManager(
                _pPropertyCache,
                FileServiceClass,
                gdwFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->PutEx(lnControlCode, bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfpnwfsh.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfpnwfsh.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWFileShare, CFPNWFileShareGeneralInfo
//
//
//  History:   02/15/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(FPNWFileShare );
DECLARE_DEBUG( FPNWFileShare);
#define FPNWFileShareDebugOut(x) FPNWFileShareInlineDebugOut x
#endif

DEFINE_IDispatch_ExtMgr_Implementation(CFPNWFileShare);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWFileShare);
DEFINE_IADs_TempImplementation(CFPNWFileShare);
DEFINE_IADs_PutGetImplementation(CFPNWFileShare,FPNWFileShareClass,gdwFPNWFileShareTableSize);
DEFINE_IADsPropertyList_Implementation(CFPNWFileShare, FPNWFileShareClass,gdwFPNWFileShareTableSize);

CFPNWFileShare::CFPNWFileShare()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    ENLIST_TRACKING(CFPNWFileShare);
    _pszShareName = NULL;
    _pPropertyCache = NULL;
    return;

}

CFPNWFileShare::~CFPNWFileShare()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszShareName){
        FreeADsStr(_pszShareName);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileShare::Create
//
//  Synopsis:   Static function used to create a FileShare object. This
//              will be called by EnumFileShares::Next
//
//  Arguments:  [ppFPNWFileShare] -- Ptr to a ptr to a new FileShare object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWFileShare::Create(LPTSTR pszADsParent,
                        LPTSTR pszServerName,
                        LPTSTR pszServiceName,
                        LPTSTR pszShareName,
                        DWORD  dwObject,
                        REFIID riid,
                        CWinNTCredentials& Credentials,
                        LPVOID * ppvoid
                        )

{

    CFPNWFileShare FAR * pCFPNWFileShare = NULL;
    HRESULT hr;


    //
    // Create the FileShare Object
    //

    hr = AllocateFileShareObject(pszADsParent,
                                 pszServerName,
                                 pszServiceName,
                                 pszShareName,
                                 &pCFPNWFileShare );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileShare->_pDispMgr);


    hr = pCFPNWFileShare->InitializeCoreObject(pszADsParent,
                                                pszShareName,
                                                FILESHARE_CLASS_NAME,
                                                FPNW_FILESHARE_SCHEMA_NAME,
                                                CLSID_FPNWFileShare,
                                                dwObject);

    BAIL_ON_FAILURE(hr);

    pCFPNWFileShare->_Credentials = Credentials;
    hr = pCFPNWFileShare->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pCFPNWFileShare,
                pCFPNWFileShare->_pDispMgr,
                Credentials,
                &pCFPNWFileShare->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileShare->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(4 == pCFPNWFileShare->_dwNumComponents) {
            pCFPNWFileShare->_CompClasses[0] = L"Domain";
            pCFPNWFileShare->_CompClasses[1] = L"Computer";
            pCFPNWFileShare->_CompClasses[2] = L"FileService";
            pCFPNWFileShare->_CompClasses[3] = L"FileShare";
        }
        else if(3 == pCFPNWFileShare->_dwNumComponents) {
            pCFPNWFileShare->_CompClasses[0] = L"Computer";
            pCFPNWFileShare->_CompClasses[1] = L"FileService";
            pCFPNWFileShare->_CompClasses[2] = L"FileShare";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCFPNWFileShare->InitUmiObject(
                pCFPNWFileShare->_Credentials,
                FPNWFileShareClass,
                gdwFPNWFileShareTableSize,
                pCFPNWFileShare->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCFPNWFileShare,
                pCFPNWFileShare->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCFPNWFileShare->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCFPNWFileShare->Release();


    RRETURN(hr);

error:

    delete pCFPNWFileShare;
    RRETURN_EXP_IF_ERR (hr);

}

HRESULT
CFPNWFileShare::AllocateFileShareObject(LPTSTR pszADsParent,
                                         LPTSTR pszServerName,
                                         LPTSTR pszServiceName,
                                         LPTSTR pszShareName,
                                         CFPNWFileShare ** ppFileShare
                                         )
{

    CFPNWFileShare * pCFPNWFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    pCFPNWFileShare = new CFPNWFileShare();
    if (pCFPNWFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFPNWFileShare->_pDispMgr = new CAggregatorDispMgr;

    if(pCFPNWFileShare ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr =  LoadTypeInfoEntry(pCFPNWFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsFileShare,
                            (IADsFileShare *)pCFPNWFileShare,
                            DISPID_REGULAR );


    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(pCFPNWFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCFPNWFileShare,
                            DISPID_VALUE );


    BAIL_ON_FAILURE(hr);



    pCFPNWFileShare->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFPNWFileShare->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFPNWFileShare->_pszShareName =
        AllocADsStr(pszShareName);

    if(!(pCFPNWFileShare->_pszShareName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = CPropertyCache::createpropertycache(
             FPNWFileShareClass,
             gdwFPNWFileShareTableSize,
             (CCoreADsObject *)pCFPNWFileShare,
             &(pCFPNWFileShare ->_pPropertyCache)
             );

    pCFPNWFileShare->_pDispMgr->RegisterPropertyCache(
                                  pCFPNWFileShare->_pPropertyCache
                                  );


    *ppFileShare = pCFPNWFileShare;
    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCFPNWFileShare;

    RRETURN_EXP_IF_ERR(hr);

}


/* IUnknown methods for FileShare object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWFileShare::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileShare::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileShare::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileShare::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Volume
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileShare::SetInfo(THIS)
{

    PNWVOLUMEINFO pVolumeInfo = NULL;
    HRESULT hr = S_OK;
    DWORD dwErrorCode;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = FPNWAddFileShare();
        BAIL_IF_ERROR(hr);
        SetObjectState(ADS_OBJECT_BOUND);
    }


    //
    // First get the information and modify only those fields which
    // have been changed by user
    //


    dwErrorCode = ADsNwVolumeGetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     &pVolumeInfo);

    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(pVolumeInfo);

    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileShare::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr = S_OK;
    DWORD dwErrorCode;
    PNWVOLUMEINFO pVolumeInfo = NULL;
    TCHAR szComputerPath[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;

    //
    // only level 1 is valid. This function is not exported so we
    // assert if not valid
    //

    ADsAssert(dwApiLevel == 1);

    dwErrorCode = ADsNwVolumeGetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     &pVolumeInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    //
    // unmarshall the information
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  pVolumeInfo->lpPath,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("CurrentUserCount"),
                                 pVolumeInfo->dwCurrentUses,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  pVolumeInfo->dwMaxUses,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileShare::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1,TRUE));
}

STDMETHODIMP
CFPNWFileShare::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1,FALSE));
}

HRESULT
CFPNWFileShare::FPNWAddFileShare(void)
{
    DWORD dwErrorCode;
    NWVOLUMEINFO  VolumeInfo;
    DWORD    dwMaxUserCount;
    LPTSTR   pszPath = NULL;
    HRESULT hr;

    //
    // Fill the VolumeInfo structure
    //

    //
    // set the file share count to be a default value (no limit)
    //

    VolumeInfo.dwMaxUses = (DWORD)-1;
    VolumeInfo.lpVolumeName = _pszShareName;
    VolumeInfo.dwType = FPNWVOL_TYPE_DISKTREE;

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Path"),
                                    &pszPath);

    if(SUCCEEDED(hr)){
        VolumeInfo.lpPath = pszPath;
    }

    hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                   TEXT("MaxUserCount"),
                                   &dwMaxUserCount);

    if(SUCCEEDED(hr)){
        VolumeInfo.dwMaxUses = dwMaxUserCount;
    }

    VolumeInfo.dwCurrentUses =  0;


    dwErrorCode = ADsNwVolumeAdd(_pszServerName,
                                 1,
                                 &VolumeInfo);

    RRETURN_EXP_IF_ERR(HRESULT_FROM_WIN32(dwErrorCode));

}


STDMETHODIMP
CFPNWFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CFPNWFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szComputerName[MAX_PATH];

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szComputerName, retval);

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CFPNWFileShare::put_Path(THIS_ BSTR bstrPath)
{
    //
    // note that path can be set only prior to creation
    // of the object. It cannot be changed later.
    //

    if(GetObjectState() == ADS_OBJECT_UNBOUND){
        PUT_PROPERTY_BSTR((IADsFileShare *)this,  Path);
    } else {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    }
}

STDMETHODIMP
CFPNWFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CFPNWFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this,  MaxUserCount);
}

//
// Helper functions
//

HRESULT
CFPNWFileShare::MarshallAndSet(PNWVOLUMEINFO pVolumeInfo)
{
    HRESULT hr = S_OK;
    LPTSTR    pszPath        = NULL;
    DWORD     dwValue;
    DWORD    dwErrorCode;
    DWORD    dwParmErr;

    pVolumeInfo->lpVolumeName = _pszShareName;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );

    if(SUCCEEDED(hr)){
        pVolumeInfo->lpPath = pszPath;
    }


    hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                   TEXT("MaxUserCount"),
                                   &dwValue );
    if(SUCCEEDED(hr)){
        pVolumeInfo->dwMaxUses = dwValue;
    }


    //
    // you ignore earlier errors, why? because these errors were raised
    // due to internal cached values being invalid.
    //

    hr = S_OK;

    //
    // Do the SetInfo now that you have all info
    //

    dwErrorCode = ADsNwVolumeSetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     pVolumeInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

cleanup:
    if(pszPath)
        FreeADsStr(pszPath);
    RRETURN_EXP_IF_ERR(hr);
}


//
// helper functions
//

HRESULT
FPNWDeleteFileShare(POBJECTINFO pObjectInfo)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwErrorCode;

    dwErrorCode = ADsNwVolumeDel(pObjectInfo->ComponentArray[1],
                                   pObjectInfo->ComponentArray[3]);

    RRETURN(HRESULT_FROM_WIN32(dwErrorCode));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfpnwses.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwses.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWSession, CFPNWSessionGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( FPNWSession );
DECLARE_DEBUG( FPNWSession );
#define FPNWSessionDebugOut(x) FPNWSessionInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CFPNWSession);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWSession);
DEFINE_IADs_TempImplementation(CFPNWSession)
DEFINE_IADs_PutGetImplementation(CFPNWSession, FPNWSessionClass, gdwFPNWSessionTableSize)
DEFINE_IADsPropertyList_Implementation(CFPNWSession, FPNWSessionClass, gdwFPNWSessionTableSize)


CFPNWSession::CFPNWSession()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pszComputerName = NULL;
    _pszUserName  = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CFPNWSession);
    return;

}

CFPNWSession::~CFPNWSession()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszComputerName){
        FreeADsStr(_pszComputerName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSession::Create
//
//  Synopsis:   Static function used to create a Session object. This
//              will be called by EnumSessions::Next
//
//  Arguments:  [ppFPNWSession] -- Ptr to a ptr to a new Session object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWSession::Create(LPTSTR pszServerADsPath,
                     PNWCONNECTIONINFO  pConnectionInfo,
                     DWORD  dwObject,
                     REFIID riid,
                     CWinNTCredentials& Credentials,
                     LPVOID * ppvoid
                     )

{

    CFPNWSession FAR * pCFPNWSession = NULL;
    HRESULT hr;
    TCHAR szSessionName[MAX_LONG_LENGTH];

    //
    // Create the Session Object
    //

    hr = AllocateSessionObject(pszServerADsPath,
                               pConnectionInfo,
                               &pCFPNWSession);

    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWSession->_pDispMgr);


    _ltow(pConnectionInfo->dwConnectionId, szSessionName, 10);

    hr = pCFPNWSession->InitializeCoreObject(pszServerADsPath,
                                             szSessionName,
                                             SESSION_CLASS_NAME,
                                             FPNW_SESSION_SCHEMA_NAME,
                                             CLSID_FPNWSession,
                                             dwObject);

    BAIL_IF_ERROR(hr);

    pCFPNWSession->_dwConnectionId = pConnectionInfo->dwConnectionId;

    pCFPNWSession->_Credentials = Credentials;
    hr = pCFPNWSession->_Credentials.RefServer(pCFPNWSession->_pszServerName);
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SESSION_CLASS_NAME,
                (IADs *) pCFPNWSession,
                pCFPNWSession->_pDispMgr,
                Credentials,
                &pCFPNWSession->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWSession->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Session objects have "" as their ADsPath. Just set the class for
        // iddentification purposes.
        pCFPNWSession->_CompClasses[0] = L"Session";

        hr = pCFPNWSession->InitUmiObject(
                pCFPNWSession->_Credentials,
                FPNWSessionClass, 
                gdwFPNWSessionTableSize,
                pCFPNWSession->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCFPNWSession,
                pCFPNWSession->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCFPNWSession->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCFPNWSession->Release();

cleanup:

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCFPNWSession;
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CFPNWSession::AllocateSessionObject(LPTSTR pszServerADsPath,
                                    PNWCONNECTIONINFO pConnectionInfo,
                                    CFPNWSession ** ppSession
                                    )

{
    CFPNWSession FAR * pCFPNWSession = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pServerObjectInfo = NULL;

    pCFPNWSession = new CFPNWSession();
    if (pCFPNWSession == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSession->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWSession->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = LoadTypeInfoEntry(pCFPNWSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsSession,
                           (IADsSession *)pCFPNWSession,
                           DISPID_REGULAR);
    BAIL_IF_ERROR(hr);

    hr = LoadTypeInfoEntry(pCFPNWSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pCFPNWSession,
                           DISPID_VALUE);
    BAIL_IF_ERROR(hr);


    pCFPNWSession->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWSession->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCFPNWSession->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWSession->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // GetInfo is not supported by the underlying API. So we
    // we will set all properties right here.
    //

    pCFPNWSession->_pszUserName =
        AllocADsStr(pConnectionInfo->lpUserName);

    if(!(pCFPNWSession->_pszUserName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = FPNWSERVERADDRtoString(pConnectionInfo->WkstaAddress,
                                &(pCFPNWSession->_pszComputerName));

    BAIL_IF_ERROR(hr);


    pCFPNWSession->_dwConnectTime = pConnectionInfo ->dwLogonTime;


    hr = CPropertyCache::createpropertycache(
             FPNWSessionClass,
             gdwFPNWSessionTableSize,
             (CCoreADsObject *)pCFPNWSession,
             &(pCFPNWSession->_pPropertyCache)
             );

    BAIL_IF_ERROR(hr);

    pCFPNWSession->_pDispMgr->RegisterPropertyCache(
                              pCFPNWSession->_pPropertyCache
                              );

    *ppSession = pCFPNWSession;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCFPNWSession;
    }

    RRETURN(hr);
}




/* IUnknown methods for session object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWSession::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWSession::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWSession::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWSession::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;
    
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsSession))
    {
        *ppvObj = (IADsSession FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWSession::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSession) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual session
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWSession::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWSession::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
   HRESULT hr;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  _pszUserName,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Computer"),
                                  _pszComputerName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("ConnectTime"),
                                  _dwConnectTime,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSession::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1,TRUE));
}

STDMETHODIMP
CFPNWSession::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1,FALSE));
}

STDMETHODIMP
CFPNWSession::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // UserName is set once and never modified,
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWSession::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWSession::get_Computer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszComputerName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSession::get_ComputerPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWSession::get_ConnectTime(THIS_ LONG FAR* retval)
{
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = _dwConnectTime;

    RRETURN(S_OK);

}

STDMETHODIMP
CFPNWSession::get_IdleTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADs *)this, IdleTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfpnwres.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwres.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWResource, CFPNWFSResourceGeneralInfo
//
//
//  History:   05/01/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( FPNWResource );
DECLARE_DEBUG( FPNWResource );
#define FPNWResourceDebugOut(x) FPNWResourceInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CFPNWResource);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWResource);
DEFINE_IADs_TempImplementation(CFPNWResource);
DEFINE_IADs_PutGetImplementation(CFPNWResource,FPNWResourceClass,gdwFPNWResourceTableSize) ;
DEFINE_IADsPropertyList_Implementation(CFPNWResource, FPNWResourceClass,gdwFPNWResourceTableSize)


CFPNWResource::CFPNWResource()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CFPNWResource);
    return;

}

CFPNWResource::~CFPNWResource()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    delete _pPropertyCache;

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResource::Create
//
//  Synopsis:   Static function used to create a Resource object. This
//              will be called by EnumResources::Next
//
//  Arguments:  [ppFPNWResource] -- Ptr to a ptr to a new Resource object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWResource::Create(LPTSTR pszServerADsPath,
                      PNWFILEINFO pFileInfo,
                      DWORD  dwObject,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{

    CFPNWResource FAR * pCFPNWResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];


    hr =CFPNWResource::AllocateResourceObject(pszServerADsPath,
                                              pFileInfo,
                                              &pCFPNWResource );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWResource->_pDispMgr);


    //
    // convert the FileId that we have into a string that we move
    // into the Name field
    //

    _ltow(pFileInfo->dwFileId, szFileName, 10);

    hr = pCFPNWResource->InitializeCoreObject(pszServerADsPath,
                                              szFileName,
                                              RESOURCE_CLASS_NAME,
                                              FPNW_RESOURCE_SCHEMA_NAME,
                                              CLSID_FPNWResource,
                                              dwObject);

    pCFPNWResource->_dwFileId = pFileInfo->dwFileId;

    pCFPNWResource->_Credentials = Credentials;
    hr = pCFPNWResource->_Credentials.RefServer(
        pCFPNWResource->_pszServerName);
    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(
                pCFPNWResource->_pPropertyCache,
                TEXT("Name"),
                pCFPNWResource->_Name,
                TRUE
                );
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                RESOURCE_CLASS_NAME,
                (IADs* ) pCFPNWResource,
                pCFPNWResource->_pDispMgr,
                Credentials,
                &pCFPNWResource->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWResource->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Resource objects have "" as their ADsPath. Just set the class to
        // resource for identification purposes.
        pCFPNWResource->_CompClasses[0] = L"Resource";

        hr = pCFPNWResource->InitUmiObject(
                 pCFPNWResource->_Credentials, 
                 FPNWResourceClass,
                 gdwFPNWResourceTableSize,
                 pCFPNWResource->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCFPNWResource,
                 pCFPNWResource->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    ADsAssert(ppvoid);
    hr = pCFPNWResource->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCFPNWResource->Release();

    RRETURN(hr);

cleanup:
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCFPNWResource;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CFPNWResource::AllocateResourceObject(LPTSTR pszServerADsPath,
                                      PNWFILEINFO pFileInfo,
                                      CFPNWResource ** ppResource)
{

    CFPNWResource FAR * pCFPNWResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];
    POBJECTINFO pServerObjectInfo = NULL;

    //
    // Create the Resource Object
    //

    pCFPNWResource = new CFPNWResource();
    if (pCFPNWResource == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCFPNWResource->_pDispMgr = new CAggregatorDispMgr;

    if(pCFPNWResource ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr =  LoadTypeInfoEntry(pCFPNWResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsResource,
                            (IADsResource *)pCFPNWResource,
                            DISPID_REGULAR);

    BAIL_IF_ERROR(hr);

    hr =  LoadTypeInfoEntry(pCFPNWResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCFPNWResource,
                            DISPID_VALUE);

    BAIL_IF_ERROR(hr);



    pCFPNWResource->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWResource->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);


    pCFPNWResource->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWResource->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = CPropertyCache::createpropertycache(
             FPNWResourceClass,
             gdwFPNWResourceTableSize,
             (CCoreADsObject *)pCFPNWResource,
             &(pCFPNWResource->_pPropertyCache)
             );


    hr = SetLPTSTRPropertyInCache(pCFPNWResource->_pPropertyCache,
                                  TEXT("User"),
                                  pFileInfo->lpUserName,
                                  TRUE
                                  );

    BAIL_IF_ERROR(hr);

    hr = ADsAllocString(pFileInfo->lpUserName,
                          &(pCFPNWResource->_pszUserName));
    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(pCFPNWResource->_pPropertyCache,
                                  TEXT("Path"),
                                  pFileInfo->lpPathName,
                                  TRUE
                                  );

    BAIL_IF_ERROR(hr);


    pCFPNWResource->_pszPath =
        AllocADsStr(pFileInfo->lpPathName);

    if(!(pCFPNWResource->_pszPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = SetDWORDPropertyInCache(pCFPNWResource->_pPropertyCache,
                                 TEXT("LockCount"),
                                 pFileInfo->dwLocks,
                                 TRUE
                                 );

    pCFPNWResource->_dwLockCount = pFileInfo->dwLocks;


    pCFPNWResource->_pDispMgr->RegisterPropertyCache(
                                  pCFPNWResource->_pPropertyCache
                                  );

    *ppResource = pCFPNWResource;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCFPNWResource;
    }

    RRETURN(hr);
}





/* IUnknown methods for Resource object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWResource::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWResource::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWResource::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWResource::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(ppvObj == NULL){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsResource))
    {
        *ppvObj = (IADsResource FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWResource::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsResource) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Resource
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWResource::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}



STDMETHODIMP
CFPNWResource::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(S_OK);
}

STDMETHODIMP
CFPNWResource::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CFPNWResource::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResource::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWResource::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszPath, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResource::get_LockCount(THIS_ LONG FAR* retval)
{
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = _dwLockCount;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//               IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

BOOL
IsStringSID(LPWSTR pszStringSID);

//  Class CWinNTGroup


STDMETHODIMP CWinNTGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this,Description);
}

STDMETHODIMP CWinNTGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this,Description);
}


STDMETHODIMP
CWinNTGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];
    NET_API_STATUS nasStatus = 0;

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        hr = CWinNTGroupCollection::CreateGroupCollection(
                        _Parent,
                        _ParentType,
                        _DomainName,

                        _ParentType == WINNT_DOMAIN_ID ?
                        (szHostServerName + 2) :
                        _ServerName,

                        _Name,
                        _GroupType,
                        IID_IADsMembers,
                        _Credentials,
                        (void **)ppMembers
            );
    } else {

        hr = CWinNTLocalGroupCollection::CreateGroupCollection(
                    _Parent,
                    _ParentType,
                    _DomainName,

                    _ParentType == WINNT_DOMAIN_ID ?
                    (szHostServerName + 2) :
                    _ServerName,

                    _Name,
                    _GroupType,
                    IID_IADsMembers,
                    _Credentials,
                    (void **)ppMembers
            );
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}




STDMETHODIMP
CWinNTGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {

            fContinue = FALSE;
        }

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::Add(THIS_ BSTR bstrNewItem)
{

    HRESULT hr;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_3 Member;
    LPLOCALGROUP_MEMBERS_INFO_3 pMember = &Member;
    POBJECTINFO pObjectInfo = NULL;
    WCHAR szDomName[MAX_PATH];
    WCHAR szHostServerName[MAX_PATH];
    int iLastIndx = 0;
    BOOL fStringSID = FALSE;

    hr = BuildObjectInfo(
                bstrNewItem,
                &pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    iLastIndx = pObjectInfo->NumComponents - 1;

    //
    // If there is only one component, it has to be in the SID form
    // or it has to be a Special SID like everyone.
    //
    if (pObjectInfo->NumComponents == 1) {
        //
        // Check to see if this is S-12-11
        //
        fStringSID = IsStringSID(pObjectInfo->ComponentArray[0]);

    }

    memset(pMember, 0, sizeof(LOCALGROUP_MEMBERS_INFO_3));

    if (_ParentType == WINNT_COMPUTER_ID) {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }else if (_ParentType == WINNT_DOMAIN_ID){

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);
    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

#ifdef WIN95
        if (_wcsicmp(pObjectInfo->ComponentArray[0], _DomainName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pObjectInfo->ComponentArray[0],
                -1,
                _DomainName,
                -1
                ) != CSTR_EQUAL ) {
#endif
            hr = E_ADS_INVALID_USER_OBJECT;
            BAIL_ON_FAILURE(hr);
        }
        nasStatus = NetGroupAddUser(
                            szHostServerName,
                            _Name,
                            pObjectInfo->ComponentArray[(
                                pObjectInfo->NumComponents - 1)]
                            );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else if (_GroupType == WINNT_GROUP_LOCAL){

        if (fStringSID) {
            hr = AddBySID(
                     pObjectInfo->ComponentArray[0],
                     szHostServerName
                     );
            goto error;
        }

        //
        // 0 implies special sid name.
        //
        if (iLastIndx != 0) {

            hr = MakeWinNTAccountName(pObjectInfo, szDomName, FALSE);
            BAIL_ON_FAILURE(hr);
            pMember->lgrmi3_domainandname = szDomName;
        }
        else {
            pMember->lgrmi3_domainandname =
                pObjectInfo->ComponentArray[iLastIndx];
        }

        //
        // For performance reasos we will first assume that the
        // use has domain name
        //

        nasStatus = NetLocalGroupAddMembers(
                            szHostServerName,
                            _Name,
                            3,
                            (LPBYTE)pMember,
                            1
                            );

        if (nasStatus == ERROR_NO_SUCH_MEMBER) {
            //
            // Try with true to see if that makes a difference
            //
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, TRUE);

            if (SUCCEEDED(hr)) {

                //
                // Try again with this value
                //

                pMember->lgrmi3_domainandname = szDomName;

                nasStatus = NetLocalGroupAddMembers(
                                szHostServerName,
                                _Name,
                                3,
                                (LPBYTE)pMember,
                                1
                                );

            }
        }

        //
        // Either way nasStatus will have the correct value
        //
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::Remove(THIS_ BSTR bstrItemToBeRemoved)
{

    HRESULT hr;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_3 Member;
    LPLOCALGROUP_MEMBERS_INFO_3 pMember = &Member;
    POBJECTINFO pObjectInfo = NULL;
    WCHAR szDomName[MAX_PATH];
    WCHAR szHostServerName[MAX_PATH];
    BOOL fSpecialName = FALSE;
    BOOL fStringSID = FALSE;

    hr = BuildObjectInfo(
                bstrItemToBeRemoved,
                &pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    //
    // If there is only one component, it has to be in the SID form
    // or it has to be a Special SID like everyone.
    //
    if (pObjectInfo->NumComponents == 1) {
        //
        // Check to see if this is S-12-11
        //
        fStringSID = IsStringSID(pObjectInfo->ComponentArray[0]);

        if (!fStringSID) {
            fSpecialName = TRUE;
        }
    }

    memset(pMember, 0, sizeof(LOCALGROUP_MEMBERS_INFO_3));

    if (_ParentType == WINNT_COMPUTER_ID) {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }else if (_ParentType == WINNT_DOMAIN_ID){

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

    }


    if (fStringSID) {
        hr = DeleteBySID(
                 pObjectInfo->ComponentArray[0],
                 szHostServerName
                 );
        goto error;
    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

#ifdef WIN95
        if (_wcsicmp(pObjectInfo->ComponentArray[0], _DomainName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pObjectInfo->ComponentArray[0],
                -1,
                _DomainName,
                -1
                ) != CSTR_EQUAL ) {
#endif
            hr = E_ADS_INVALID_USER_OBJECT;
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetGroupDelUser(
                            szHostServerName,
                            _Name,
                            pObjectInfo->ComponentArray[(
                                pObjectInfo->NumComponents) - 1]
                            );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else {

        if (!fSpecialName) {
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, FALSE);
            BAIL_ON_FAILURE(hr);

            pMember->lgrmi3_domainandname = szDomName;
        }
        else {
            pMember->lgrmi3_domainandname =
                pObjectInfo->ComponentArray[0];
        }

        nasStatus = NetLocalGroupDelMembers(
                            szHostServerName,
                            _Name,
                            3,
                            (LPBYTE)pMember,
                            1
                            );

        if (nasStatus == ERROR_NO_SUCH_MEMBER) {
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, TRUE);

            if (SUCCEEDED(hr)) {

                pMember->lgrmi3_domainandname = szDomName;
                nasStatus = NetLocalGroupDelMembers(
                                szHostServerName,
                                _Name,
                                3,
                                (LPBYTE)pMember,
                                1
                                );

            }
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        if (!_wcsicmp(bstrName, bstrMember)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrName,
                -1,
                bstrMember,
                -1
                ) == CSTR_EQUAL ) {
#endif

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


HRESULT
CWinNTGroup::DeleteBySID(
    LPWSTR pszStringSID,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    PSID pSid = NULL;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_0 member;

    //
    // SDDL.H is currently available only for Win2k
    //
#if !defined(WIN95)

    if (!pszStringSID) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    fRet = ConvertStringSidToSidWrapper(
               pszStringSID,
               &pSid
               );
    if (!pSid) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    member.lgrmi0_sid = pSid;

    nasStatus = NetLocalGroupDelMembers(
                    pszServerName,
                    _Name,
                    0,
                    (LPBYTE) &member,
                    1
                    );

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

#else
    BAIL_ON_FAILURE(hr = E_FAIL);
#endif


error:
    if (pSid) {
        LocalFree(pSid);
    }

    RRETURN(hr);
}


//
// Same as delete only this time to add by SID.
//
HRESULT
CWinNTGroup::AddBySID(
    LPWSTR pszStringSID,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    PSID pSid = NULL;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_0 member;

    //
    // SDDL.H is currently available only for Win2k
    //
#if !defined(WIN95)

    if (!pszStringSID) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    fRet = ConvertStringSidToSidWrapper(
               pszStringSID,
               &pSid
               );
    if (!pSid) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    member.lgrmi0_sid = pSid;

    nasStatus = NetLocalGroupAddMembers(
                    pszServerName,
                    _Name,
                    0,
                    (LPBYTE) &member,
                    1
                    );

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

#else
    BAIL_ON_FAILURE(hr = E_FAIL);
#endif


error:
    if (pSid) {
        LocalFree(pSid);
    }

    RRETURN(hr);
}


//
// Helper routine that checks if a string is a sid or not.
//
BOOL
IsStringSID(LPWSTR pszStringSID)
{
    BOOL fRet = FALSE;

    if (!pszStringSID || (wcslen(pszStringSID) < 4)) {
        return FALSE;
    }

    if (((*pszStringSID != L'S') && (*pszStringSID != L's'))
        || (*(pszStringSID + 1) != L'-')
        ) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cfshare.cxx ===
//--------------------------------------------------------------------------/
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfshare.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTFileShare, CWinNTFileShareGeneralInfo
//
//
//  History:   02/15/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(FileShare );
DECLARE_DEBUG( FileShare);
#define FileShareDebugOut(x) FileShareInlineDebugOut x
#endif

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTFileShare);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTFileShare);
DEFINE_IADs_TempImplementation(CWinNTFileShare);
DEFINE_IADs_PutGetImplementation(CWinNTFileShare,FileShareClass, gdwFileShareTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTFileShare, FileShareClass, gdwFileShareTableSize)

CWinNTFileShare::CWinNTFileShare()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszShareName = NULL;
    _pPropertyCache = NULL;
    _pszServerName = NULL;

    ENLIST_TRACKING(CWinNTFileShare);


    return;

}

CWinNTFileShare::~CWinNTFileShare()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszShareName){
        FreeADsStr(_pszShareName);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileShare::Create
//
//  Synopsis:   Static function used to create a FileShare object. This
//              will be called by EnumFileShares::Next
//
//  Arguments:  [ppWinNTFileShare] -- Ptr to a ptr to a new FileShare object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTFileShare::Create(LPTSTR pszADsParent,
                        LPTSTR pszServerName,
                        LPTSTR pszServiceName,
                        LPTSTR pszShareName,
                        DWORD  dwObject,
                        REFIID riid,
                        CWinNTCredentials& Credentials,
                        LPVOID * ppvoid
                        )

{

    CWinNTFileShare FAR * pCWinNTFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    hr = AllocateFileShareObject(pszADsParent,
                                 pszServerName,
                                 pszServiceName,
                                 pszShareName,
                                 &pCWinNTFileShare );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileShare->_pDispMgr);


    hr = pCWinNTFileShare->InitializeCoreObject(pszADsParent,
                                                pszShareName,
                                                FILESHARE_CLASS_NAME,
                                                FILESHARE_SCHEMA_NAME,
                                                CLSID_WinNTFileShare,
                                                dwObject);

    BAIL_ON_FAILURE(hr);

    pCWinNTFileShare->_Credentials = Credentials;
    hr = pCWinNTFileShare->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pCWinNTFileShare,
                pCWinNTFileShare->_pDispMgr,
                Credentials,
                &pCWinNTFileShare->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileShare->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(4 == pCWinNTFileShare->_dwNumComponents) {
            pCWinNTFileShare->_CompClasses[0] = L"Domain";
            pCWinNTFileShare->_CompClasses[1] = L"Computer";
            pCWinNTFileShare->_CompClasses[2] = L"FileService";
            pCWinNTFileShare->_CompClasses[3] = L"FileShare";
        }
        else if(3 == pCWinNTFileShare->_dwNumComponents) {
            pCWinNTFileShare->_CompClasses[0] = L"Computer";
            pCWinNTFileShare->_CompClasses[1] = L"FileService";
            pCWinNTFileShare->_CompClasses[2] = L"FileShare";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCWinNTFileShare->InitUmiObject(
                pCWinNTFileShare->_Credentials,
                FileShareClass, 
                gdwFileShareTableSize,
                pCWinNTFileShare->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCWinNTFileShare,
                pCWinNTFileShare->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTFileShare->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCWinNTFileShare->Release();

    RRETURN(hr);

error:

    delete pCWinNTFileShare;
    RRETURN (hr);

}

HRESULT
CWinNTFileShare::AllocateFileShareObject(LPTSTR pszADsParent,
                                         LPTSTR pszServerName,
                                         LPTSTR pszServiceName,
                                         LPTSTR pszShareName,
                                         CWinNTFileShare ** ppFileShare
                                         )
{

    CWinNTFileShare * pCWinNTFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    pCWinNTFileShare = new CWinNTFileShare();
    if (pCWinNTFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCWinNTFileShare->_pDispMgr = new CAggregatorDispMgr;

    if(pCWinNTFileShare ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr =  LoadTypeInfoEntry(pCWinNTFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsFileShare,
                            (IADsFileShare *)pCWinNTFileShare,
                            DISPID_REGULAR );


    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(pCWinNTFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCWinNTFileShare,
                            DISPID_VALUE );

    BAIL_ON_FAILURE(hr);


    pCWinNTFileShare->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCWinNTFileShare->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCWinNTFileShare->_pszShareName =
        AllocADsStr(pszShareName);

    if(!(pCWinNTFileShare->_pszShareName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = CPropertyCache::createpropertycache(
             FileShareClass,
             gdwFileShareTableSize,
             (CCoreADsObject *)pCWinNTFileShare,
             &(pCWinNTFileShare ->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pCWinNTFileShare->_pDispMgr)->RegisterPropertyCache(
                                        pCWinNTFileShare->_pPropertyCache
                                        );

    *ppFileShare = pCWinNTFileShare;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCWinNTFileShare;

    RRETURN (hr);

}

/* IUnknown methods for FileShare object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTFileShare::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileShare::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileShare::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileShare::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual FileShare
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileShare::SetInfo(THIS)
{

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_2 lpShareInfo2 = NULL;
    HRESULT hr = S_OK;
    TCHAR  szUncServerName[MAX_PATH];
    BOOL fNewFileShare = FALSE;


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddFileShare();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);
        fNewFileShare = TRUE;

    }


    //
    // First get the information and modify only those fields which
    // have been changed by user
    //


    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE *)&lpShareInfo2);

    if (nasStatus != NERR_Success || !lpShareInfo2){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    hr = MarshallAndSet(lpShareInfo2);

    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:

    if (FAILED(hr) && fNewFileShare) {
        //
        // Try and delete the fileshare as the SetInfo as a
        // whole failed but the create part was successful.
        //
        nasStatus = NetShareDel(
                        szUncServerName,
                        _pszShareName,
                        0
                        );

    }

    if(lpShareInfo2)
        NetApiBufferFree(lpShareInfo2);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileShare::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr = S_OK;

    switch(dwApiLevel){

    case 1:
        hr = GetLevel1Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetLevel2Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        //
        // we should not be here
        //
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN_EXP_IF_ERR (hr);
}


STDMETHODIMP
CWinNTFileShare::GetInfo(THIS)
{
    RRETURN(GetInfo(2,TRUE));
}

STDMETHODIMP
CWinNTFileShare::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(2,FALSE));
}

//
// helper functions for GetInfo and SetInfo
//

HRESULT
CWinNTFileShare::GetLevel2Info(THIS_ BOOL fExplicit)
{
    //
    // here we do a NetShareGetInfo on level 2 and unmarshall the relevant
    // fields
    //

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_2 lpShareInfo2 = NULL;
    HRESULT hr;
    TCHAR  szUncServerName[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR  szComputerPath[MAX_PATH];

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE *)&lpShareInfo2);

    if (nasStatus != NERR_Success || !lpShareInfo2){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpShareInfo2->shi2_remark,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpShareInfo2->shi2_path,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("CurrentUserCount"),
                                  lpShareInfo2->shi2_current_uses,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  lpShareInfo2->shi2_max_uses,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

cleanup:
    if(lpShareInfo2){
        NetApiBufferFree(lpShareInfo2);
    }
    FreeObjectInfo(pObjectInfo);
    RRETURN(hr);
}


HRESULT
CWinNTFileShare::GetLevel1Info(THIS_ BOOL fExplicit)
{

    //
    // here we do a NetShareGetInfo on level 1 and unmarshall the relevant
    // fields
    //

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_1 lpShareInfo1 = NULL;
    HRESULT hr;
    TCHAR  szUncServerName[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR  szComputerPath[MAX_PATH];

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                1,
                                (LPBYTE *)&lpShareInfo1);

    if (nasStatus != NERR_Success || !lpShareInfo1){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //


  //
    // unmarshall the info
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

cleanup:
    if(lpShareInfo1)
        NetApiBufferFree(lpShareInfo1);

    FreeObjectInfo(pObjectInfo);
    RRETURN(hr);
}


HRESULT
CWinNTFileShare::WinNTAddFileShare(void)
{
    TCHAR szUncServerName[MAX_ADS_PATH];
    NET_API_STATUS nasStatus;
    SHARE_INFO_2  ShareInfo2;
    DWORD     dwParmErr;
    DWORD    dwMaxUserCount;
    LPTSTR   pszPath = NULL;
    LPTSTR   pszDescription = NULL;
    HRESULT hr = S_OK;

    MakeUncName(_pszServerName, szUncServerName);

    //
    // Fill the ShareInfo2 structure
    //

    ShareInfo2.shi2_netname = _pszShareName;
    ShareInfo2.shi2_type = STYPE_DISKTREE;

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Path"),
                                    &pszPath);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_path = pszPath;
    }

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Description"),
                                    &pszDescription);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_remark = pszDescription;
    } else {
        ShareInfo2.shi2_remark = TEXT("");
    }

   hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  &dwMaxUserCount);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_max_uses = dwMaxUserCount;
    } else {
        ShareInfo2.shi2_max_uses = -1;  // unlimited
    }


    ShareInfo2.shi2_permissions = ACCESS_ALL & ~ ACCESS_PERM;
    ShareInfo2.shi2_current_uses = 0;
    ShareInfo2.shi2_passwd = NULL;

    nasStatus = NetShareAdd(szUncServerName,
                            2,
                            (LPBYTE )&ShareInfo2,
                            &dwParmErr);

    if(nasStatus != NERR_Success){

#if DBG
        FileShareDebugOut((DEB_TRACE,
                           "NetShareAdd : parameter %ld unknown\n",
                           dwParmErr));
#endif
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    } else{
        hr = S_OK;
    }

 cleanup:

    if(pszPath){
        FreeADsStr(pszPath);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN(hr);
}


STDMETHODIMP
CWinNTFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CWinNTFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CWinNTFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CWinNTFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szComputerName[MAX_PATH];

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szComputerName, retval);

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CWinNTFileShare::put_Path(THIS_ BSTR bstrPath)
{
    //
    // note that path can be set only prior to creation
    // of the object. It cannot be changed later.
    //

    if(GetObjectState() == ADS_OBJECT_UNBOUND){
        PUT_PROPERTY_BSTR((IADsFileShare *)this, Path);
    } else {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    }
}

STDMETHODIMP
CWinNTFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CWinNTFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}


HRESULT
CWinNTFileShare::MarshallAndSet(LPSHARE_INFO_2 lpShareInfo2)
{
    HRESULT hr = S_OK;
    LPTSTR   pszDescription = NULL;
    LPTSTR   pszPath        = NULL;
    DWORD    dwValue;
    TCHAR   szUncServerName[MAX_PATH];
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    hr = MakeUncName(_pszServerName,
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if(SUCCEEDED(hr)){
        lpShareInfo2->shi2_remark = pszDescription;
    }

   hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );
   //
   // pszPath should not be NULL - sanity check to catch prefix issue.
   //
   if(SUCCEEDED(hr) && pszPath) {
#ifdef WIN95
        if (_wcsicmp(lpShareInfo2->shi2_path, pszPath) ) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                lpShareInfo2->shi2_path,
                -1,
                pszPath,
                -1
                ) != CSTR_EQUAL ) {
#endif
            // trying to change the path which is not allowed
            hr = (E_ADS_PROPERTY_NOT_SUPPORTED);
            BAIL_IF_ERROR(hr);
        }
        lpShareInfo2->shi2_path = pszPath;
    }

   hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxUserCount"),
                    &dwValue
                    );
    if(SUCCEEDED(hr)){
        lpShareInfo2->shi2_max_uses = dwValue;
    }

    //
    // you ignore earlier errors, why? because these errors were raised
    // due to internal cached values being invalid.
    //

    hr = S_OK;

    //
    // Do the SetInfo now that you have all info
    //

    nasStatus = NetShareSetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE)lpShareInfo2,
                                &dwParmErr);

    if(nasStatus != NERR_Success){

#if DBG
        FileShareDebugOut((DEB_TRACE,
                           "NetShareSetInfo : parameter %ld unknown\n", dwParmErr));
#endif


        hr = HRESULT_FROM_WIN32(nasStatus);
    }

cleanup:
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszPath)
        FreeADsStr(pszPath);
    RRETURN_EXP_IF_ERR(hr);
}


//
// helper functions
//

HRESULT
WinNTDeleteFileShare(POBJECTINFO pObjectInfo)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    TCHAR szUncServerName[MAX_ADS_PATH];

    hr = MakeUncName(pObjectInfo->ComponentArray[1],
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    nasStatus = NetShareDel(szUncServerName,
                            pObjectInfo->ComponentArray[3],
                            0);

cleanup:
    if(FAILED(hr)){
        RRETURN(hr);
    }
    if(nasStatus != NERR_Success){
        RRETURN(HRESULT_FROM_WIN32(nasStatus));
    }
    else{
        RRETURN(S_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTGroup -> GlobalGroup DS class

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTGroup)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTGroup)
DEFINE_IADs_TempImplementation(CWinNTGroup)
DEFINE_IADs_PutGetImplementation(CWinNTGroup,GroupClass,gdwGroupTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTGroup, GroupClass,gdwGroupTableSize)

CWinNTGroup::CWinNTGroup():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL)
{
    ENLIST_TRACKING(CWinNTGroup);
}


HRESULT
CWinNTGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    DWORD dwObjectState,
    PSID pSid,          // OPTIONAL
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    BOOL fAccountSid = TRUE;

    hr = AllocateGroupObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGroup->_pDispMgr);


    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                GROUP_CLASS_NAME,
                GROUP_SCHEMA_NAME,
                CLSID_WinNTGroup,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    hr = SetDWORDPropertyInCache(
         pGroup->_pPropertyCache,
         TEXT("groupType"),
         GroupType,
         TRUE           // fExplicit
         );

    BAIL_ON_FAILURE(hr);



    //
    // Try to determine if object corresponds to a account
    // domain
    //
    if (pSid) {

        //
        // A domain account sid has:
        //   (1) a identifier authority of SECURITY_NT_AUTHORITY
        //   (2) at least one subauth identifier
        //   (3) the first subauth identifier is SECURITY_NT_NON_UNIQUE
        //

        PSID_IDENTIFIER_AUTHORITY pSidIdentAuth = NULL;
        SID_IDENTIFIER_AUTHORITY NtAuthIdentAuth = SECURITY_NT_AUTHORITY;

        PDWORD pdwSidSubAuth = NULL;

        fAccountSid = FALSE;

        pSidIdentAuth = GetSidIdentifierAuthority(pSid);
        ADsAssert(pSidIdentAuth);

        if (memcmp(pSidIdentAuth, &NtAuthIdentAuth, sizeof(SID_IDENTIFIER_AUTHORITY)) == 0) {

            if (GetSidSubAuthorityCount(pSid) > 0) {

                pdwSidSubAuth = GetSidSubAuthority(pSid, 0);
                ADsAssert(pdwSidSubAuth);

                if (*pdwSidSubAuth == SECURITY_NT_NON_UNIQUE) {
                    fAccountSid = TRUE;
                }
            }
        }
    }

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    if (fAccountSid) {
        //
        // We permit this to fail if we can determine it is not a account
        // sid, since we won't be able to ref credentials on a non-existent
        // pseudo-domain like NT AUTHORITY (e.g., the well-known sids)
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                GROUP_CLASS_NAME,
                (IADsGroup *) pGroup,
                pGroup->_pDispMgr,
                Credentials,
                &pGroup->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGroup->_pExtMgr);

    //
    // Prepopulate the object
    //
    hr = pGroup->Prepopulate(TRUE,
                            pSid);
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pGroup->_dwNumComponents) {
            pGroup->_CompClasses[0] = L"Domain";
            pGroup->_CompClasses[1] = L"Computer";
            pGroup->_CompClasses[2] = L"Group";
        }
        else if(2 == pGroup->_dwNumComponents) {
            if(NULL == DomainName) {
            // workstation services not started. See getobj.cxx.
                pGroup->_CompClasses[0] = L"Computer";
                pGroup->_CompClasses[1] = L"Group";
            }
            else if(NULL == ServerName) {
                pGroup->_CompClasses[0] = L"Domain";
                pGroup->_CompClasses[1] = L"Group";
            }
            else
                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pGroup->InitUmiObject(
                pGroup->_Credentials,
                GroupClass,
                gdwGroupTableSize, 
                pGroup->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pGroup,
                pGroup->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;

    hr = CWinNTGroup::CreateGroup(
                              Parent,
                              ParentType,
                              DomainName,
                              ServerName,
                              GroupName,
                              GroupType,
                              dwObjectState,
                              NULL,
                              riid,
                              Credentials,
                              ppvObj
                              );

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTGroup::~CWinNTGroup( )
{
    ADsFreeString(_DomainName);
    ADsFreeString(_ServerName);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTGroup::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTGroup::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTGroup::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTGroup::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTGroup::SetInfo(THIS)
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];
    LPBYTE lpBuffer = NULL;
    DWORD dwGroupType = _GroupType;


    //
    // We need to see if the cache has changed a value for
    // groupType and use that info down the line.
    //

    hr = GetDWORDPropertyFromCache(
         _pPropertyCache,
         TEXT("groupType"),
         &dwGroupType
         );

    if (SUCCEEDED(hr)) {
        //
        // Verify the value
        //
        if ((dwGroupType != WINNT_GROUP_LOCAL)
            && (dwGroupType != WINNT_GROUP_GLOBAL)) {

            //
            // This is bad value so we need to BAIL
            //
            hr = E_ADS_BAD_PARAMETER;
        }
        else {
            if (GetObjectState() == ADS_OBJECT_UNBOUND)
                _GroupType = dwGroupType;
            else
               if (_GroupType != dwGroupType) {
                   hr = E_ADS_BAD_PARAMETER;
               }
        }

    } else {

        dwGroupType = _GroupType;
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                 _DomainName,
                 szHostServerName,
                 _Credentials.GetFlags()
                 );
    } else {

        hr = MakeUncName(
                 _ServerName,
                 szHostServerName
                 );
    }

    BAIL_ON_FAILURE(hr);


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        if (dwGroupType == WINNT_GROUP_GLOBAL) {

            if (_ParentType == WINNT_DOMAIN_ID) {

                hr = WinNTCreateGlobalGroup(
                            szHostServerName + 2,
                            _Name
                            );
                BAIL_ON_FAILURE(hr);


            }else {

                hr = WinNTCreateGlobalGroup(
                            _ServerName,
                            _Name
                            );
                BAIL_ON_FAILURE(hr);

            }

        }
        else {

            //
            // Group type has to be local
            //

            hr = WinNTCreateLocalGroup(
                     szHostServerName + 2,
                     _Name
                     );

            BAIL_ON_FAILURE(hr);

        }

         SetObjectState(ADS_OBJECT_BOUND);

    } // if Object not bound

    if (dwGroupType == WINNT_GROUP_GLOBAL) {

        nasStatus = NetGroupGetInfo(
                        szHostServerName,
                        _Name,
                        1,
                        &lpBuffer
                        );

    } else {

        nasStatus = NetLocalGroupGetInfo(
                        szHostServerName,
                        _Name,
                        1,
                        &lpBuffer
                        );

    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = Marshall_Set_Level1(
             szHostServerName,
             TRUE,
             lpBuffer
             );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

    //
    // objectSid not writable
    //

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::GetInfo(THIS)
{
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

    RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    }


    _pPropertyCache->flushpropcache();

    //
    // Need to add the group type attribute here.
    //
    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("groupType"),
             _GroupType,
             TRUE           // fExplicit
             );
    //
    // GROUP_INFO
    //

    hr = GetInfo(1, TRUE);

    BAIL_ON_FAILURE(hr);
    //
    // objectSid
    //

    hr = GetInfo(20, TRUE);

error :

    RRETURN(hr);

}

STDMETHODIMP
CWinNTGroup::ImplicitGetInfo(THIS)
{
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

    RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    }

    //
    // Need to add the group type attribute here.
    //
    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("groupType"),
             _GroupType,
             FALSE           // fExplicit
             );
    //
    // GROUP_INFO
    //

    hr = GetInfo(1, FALSE);

    BAIL_ON_FAILURE(hr);
    //
    // objectSid
    //

    hr = GetInfo(20, FALSE);

error :

    RRETURN(hr);

}

HRESULT
CWinNTGroup::AllocateGroupObject(
    CWinNTGroup ** ppGroup
    )
{
    CWinNTGroup FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pGroup,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             GroupClass,
             gdwGroupTableSize,
             (CCoreADsObject *)pGroup,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    pGroup->_pPropertyCache = pPropertyCache;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pGroup;

    RRETURN(hr);

}


//
// For current implementation in clocgroup:
// If this function is called as a public function (ie. by another
// modual/class), fExplicit must be FALSE since the cache is NOT
// flushed in this function.
//
// External functions should ONLY call GetInfo(no param) for explicit
// GetInfo. This will flush the cache properly.
//

STDMETHODIMP
CWinNTGroup::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    HRESULT hr=E_FAIL;

    switch (dwApiLevel) {

    case 1:

        hr = GetStandardInfo(
                dwApiLevel,
                fExplicit
                );
        RRETURN_EXP_IF_ERR(hr);

    case 20:

        hr = GetSidInfo(
                fExplicit
                );
        RRETURN_EXP_IF_ERR(hr);

    default:

        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
}


HRESULT
CWinNTGroup::GetStandardInfo(
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];



    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);
    }else {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }

    //
    // Since the object is bound, the groupType has to be
    // _GroupType and cannot change.
    //

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        nasStatus = NetGroupGetInfo(
                        szHostServerName,
                        _Name,
                        dwApiLevel,
                        &lpBuffer
                        );

    } else {

        nasStatus = NetLocalGroupGetInfo(
                        szHostServerName,
                        _Name,
                        dwApiLevel,
                        &lpBuffer
                        );

    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(
            lpBuffer,
            dwApiLevel,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroup::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr;
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 1:
        hr = UnMarshall_Level1(fExplicit, lpBuffer);
        break;

    default:
        hr = E_FAIL;

    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroup::UnMarshall_Level1(BOOL fExplicit, LPBYTE pBuffer)
{
    BSTR bstrData = NULL;
    LPGROUP_INFO_1 pGroupInfo1 = NULL;
    LPLOCALGROUP_INFO_1 pLocalGroupInfo1 = NULL;
    HRESULT hr = S_OK;

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        pGroupInfo1 = (LPGROUP_INFO_1)pBuffer;

        hr = SetLPTSTRPropertyInCache(
                 _pPropertyCache,
                 TEXT("Description"),
                 pGroupInfo1->grpi1_comment,
                 fExplicit
                 );
    }
    else {

        pLocalGroupInfo1 = (LPLOCALGROUP_INFO_1) pBuffer;

        hr = SetLPTSTRPropertyInCache(
                 _pPropertyCache,
                 TEXT("Description"),
                 pLocalGroupInfo1->lgrpi1_comment,
                 fExplicit
                 );
    }


    RRETURN(hr);
}


HRESULT
CWinNTGroup::Prepopulate(
    BOOL fExplicit,
    PSID pSid               // OPTIONAL
    )
{
    HRESULT hr = S_OK;

    DWORD dwErr = 0;
    DWORD dwSidLength = 0;
    
    if (pSid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid((PSID) pSid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        dwErr = GetLastError();
        if (dwErr != NO_ERROR) {
            hr = HRESULT_FROM_WIN32(dwErr);
            BAIL_ON_FAILURE(hr);
        }
    
        hr = SetOctetPropertyInCache(
                    _pPropertyCache,
                    TEXT("objectSid"),
                    (PBYTE) pSid,
                    dwSidLength,
                    TRUE
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CWinNTGroup::Marshall_Set_Level1(
    LPWSTR szHostServerName,
    BOOL fExplicit,
    LPBYTE pBuffer
    )
{
    LPGROUP_INFO_1 pGroupInfo1 = NULL;
    LPLOCALGROUP_INFO_1 pLocalGroupInfo1 = NULL;
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;
    LPWSTR  pszDescription = NULL;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)) {

        if (_GroupType == WINNT_GROUP_GLOBAL) {

            // hr = UM_GET_BSTR_PROPERTY(_pGenInfo,Description, bstrData);

            //
            // This should in reality call a virtual function of a derived
            // class,  beta fix!
            //

            pGroupInfo1 = (LPGROUP_INFO_1)pBuffer;
            pGroupInfo1->grpi1_comment = pszDescription;

            //
            // Now perform the Set call.
            //

            nasStatus = NetGroupSetInfo(
                            szHostServerName,
                            _Name,
                            1,
                            (LPBYTE)pGroupInfo1,
                            &dwParmErr
                            );

        }
        else {

            pLocalGroupInfo1 = (LPLOCALGROUP_INFO_1)pBuffer;
            pLocalGroupInfo1->lgrpi1_comment = pszDescription;

            nasStatus = NetLocalGroupSetInfo(
                            szHostServerName,
                            _Name,
                            1,
                            (LPBYTE)pLocalGroupInfo1,
                            &dwParmErr
                            );

        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else {

        //
        // This is because there is no data to marshall
        //

        hr = S_OK;

    }

error:

    if (pszDescription) {
        FreeADsStr(pszDescription);
    }

    RRETURN(hr);
}

HRESULT
CWinNTGroup::Marshall_Create_Level1(
    LPWSTR szHostServerName,
    LPGROUP_INFO_1 pGroupInfo1
    )
{

    //
    // This routine is not called from anywhere ???
    //
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus = ERROR_INVALID_DATA;
    DWORD dwParmErr;

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        pGroupInfo1->grpi1_name = _Name;
        pGroupInfo1->grpi1_comment = NULL;
        nasStatus = NetGroupAdd(
                        szHostServerName,
                        1,
                        (LPBYTE)pGroupInfo1,
                        &dwParmErr
                        );
    }
    else {

        ADsAssert(!"Group type is bad internally!");

        /*
        pLocalGroupInfo1->lgrp1_name = _Name;
        pLocalGroupInfo1->grp1_comment = NULL;
        nasStatus = NetLocalGroupAdd(
                        szHostServerName,
                        1,
                        (LPBYTE)pLocalGroupInfo1,
                        &dwParmErr
                        );
                        */


    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
CWinNTGroup::GetSidInfo(
    IN BOOL fExplicit
    )
{
    HRESULT hr = E_FAIL;
    WCHAR szHostServerName[MAX_PATH];

    //
    // Get Server Name
    //

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
    }

    //
    // Get Sid of this group and store in cache if fExplicit.
    //

    hr = GetSidIntoCache(
            szHostServerName,
            _Name,
            _pPropertyCache,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object Class Factory Code
//
//             CWinNTNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTNamespaceCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = S_OK;
    CWinNTCredentials Credentials; // default creds

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CWinNTNamespace::CreateNamespace(
                L"ADs:",
                L"WinNT:",
                ADS_OBJECT_BOUND,
                iid,
                Credentials,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTGroupCollection

DEFINE_IDispatch_Implementation(CWinNTGroupCollection)


CWinNTGroupCollection::CWinNTGroupCollection():
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _lpServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTGroupCollection);
}


HRESULT
CWinNTGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                GROUP_CLASS_NAME,
                NULL,
                CLSID_WinNTGroup,
                ADS_OBJECT_UNBOUND
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CWinNTGroupCollection::~CWinNTGroupCollection( )
{
    VariantClear( &_vFilter);

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_ServerName) {
        ADsFreeString(_ServerName);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CWinNTGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTGroupCollectionEnum::Create(
                (CWinNTGroupCollectionEnum **)&penum,
                _Parent,
                _ParentType,
                _ADsPath,
                _DomainName,
                _ServerName,
                _Name,
                _GroupType,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroupCollection::AllocateGroupCollectionObject(
    CWinNTGroupCollection ** ppGroup
    )
{
    CWinNTGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cjob.cxx ===
/*++
Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    cjob.cxx

Abstract:
 Contains methods for Print Job object and its property sets for the
 Windows NT provider. Objects whose methods are supported here are

 CWinNTPrintJob,
 CWinNTPrintJob and
 CWinNTPrintJob.


Author:

    Ram Viswanathan (ramv) 11-18-95

Revision History:

--*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// class CWinNTPrintJob Methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTPrintJob);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTPrintJob);
DEFINE_IADs_TempImplementation(CWinNTPrintJob);
DEFINE_IADs_PutGetImplementation(CWinNTPrintJob, PrintJobClass,gdwJobTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTPrintJob, PrintJobClass,gdwJobTableSize)

CWinNTPrintJob::CWinNTPrintJob()
{
    _pDispMgr = NULL;
    _pExtMgr  = NULL;
    _hprinter = NULL;
    _lJobId   = 0;
    _pszPrinterName = NULL;
    _pszPrinterPath = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTPrintJob);
    return;

}

CWinNTPrintJob::~CWinNTPrintJob()
{

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }

    if(_pszPrinterPath){
        FreeADsStr(_pszPrinterPath);
    }

    _hprinter = NULL;

    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;

    return;
}


HRESULT
CWinNTPrintJob::CreatePrintJob(
    LPTSTR pszPrinterPath,
    LONG   lJobId,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    LPVOID *ppvoid
    )
{
    CWinNTPrintJob       *pCWinNTPrintJob =  NULL;
    HRESULT hr;
    TCHAR szJobName[MAX_LONG_LENGTH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // Create the job object
    //

    hr = AllocatePrintJobObject(pszPrinterPath,
                                &pCWinNTPrintJob
                                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTPrintJob->_pDispMgr);

    //
    // convert the JobId that we have into a string that we move
    // into the Name field
    //

    _ltow(lJobId, szJobName, 10);

    hr = pCWinNTPrintJob->InitializeCoreObject(pszPrinterPath,
                                               szJobName,
                                               PRINTJOB_CLASS_NAME,
                                               PRINTJOB_SCHEMA_NAME,
                                               CLSID_WinNTPrintJob,
                                               dwObjectState);

    BAIL_ON_FAILURE(hr);



    hr = BuildObjectInfo(pszPrinterPath,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = PrinterNameFromObjectInfo(pObjectInfo,
                                   szUncPrinterName);
    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->_Credentials = Credentials;
    hr = pCWinNTPrintJob->_Credentials.RefServer(
        pObjectInfo->ComponentArray[1]);
    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pCWinNTPrintJob->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCWinNTPrintJob->_lJobId = lJobId;

    hr = SetLPTSTRPropertyInCache(pCWinNTPrintJob->_pPropertyCache,
                                  TEXT("HostPrintQueue"),
                                  pszPrinterPath,
                                  TRUE
                                  );


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                PRINTJOB_CLASS_NAME,
                (IADsPrintJob *) pCWinNTPrintJob,
                pCWinNTPrintJob->_pDispMgr,
                Credentials,
                &pCWinNTPrintJob->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTPrintJob->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Printjob objects have "" as their ADsPath. Just set the class for
        // iddentification purposes.
        pCWinNTPrintJob->_CompClasses[0] = L"PrintJob";

        hr = pCWinNTPrintJob->InitUmiObject(
                pCWinNTPrintJob->_Credentials,
                PrintJobClass,
                gdwJobTableSize,
                pCWinNTPrintJob->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTPrintJob,
                pCWinNTPrintJob->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTPrintJob->QueryInterface( riid,(void **)ppvoid);

    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->Release();
    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);
    delete pCWinNTPrintJob;
    RRETURN (hr);
}


HRESULT
CWinNTPrintJob::AllocatePrintJobObject(
    LPTSTR pszPrinterPath,
    CWinNTPrintJob ** ppPrintJob
    )
{
    CWinNTPrintJob FAR * pPrintJob = NULL;
    HRESULT hr = S_OK;

    pPrintJob = new CWinNTPrintJob();
    if (pPrintJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pPrintJob->_pszPrinterPath =
        AllocADsStr(pszPrinterPath);

    if(!(pPrintJob->_pszPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pPrintJob->_pDispMgr = new CAggregatorDispMgr;

    if (pPrintJob->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJob,
                (IADsPrintJob *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJobOperations,
                (IADsPrintJobOperations *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintJob,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             PrintJobClass,
             gdwJobTableSize,
             (CCoreADsObject *)pPrintJob,
             &(pPrintJob->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    (pPrintJob->_pDispMgr)->RegisterPropertyCache(
                                    pPrintJob->_pPropertyCache
                                    );


    *ppPrintJob = pPrintJob;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pPrintJob;

    RRETURN_EXP_IF_ERR(hr);

}



/* IUnknown methods for printer object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTPrintJob::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintJob::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintJob::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintJob::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJob))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJobOperations))
    {
        *ppvObj = (IADsPrintJobOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintJob::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintJob) ||
        IsEqualIID(riid, IID_IADsPrintJobOperations) |\
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to set the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintJob::SetInfo(THIS)
{
    BOOL fStatus = FALSE;
    LPJOB_INFO_2 lpJobInfo2 = NULL;
    HRESULT hr;

    //
    // do a getinfo to refresh those properties that arent being set
    //
    hr = GetJobInfo(2,
                    (LPBYTE*)&lpJobInfo2,
                    _pszPrinterName,
                    _lJobId);

    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(lpJobInfo2,
                        _pszPrinterName,
                        _lJobId);
    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    if(lpJobInfo2){
        FreeADsMem((LPBYTE)lpJobInfo2);
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTPrintJob::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    LPJOB_INFO_1 lpJobInfo1 = NULL;
    LPJOB_INFO_2 lpJobInfo2 = NULL;
    HRESULT hr = S_OK;


    switch (dwApiLevel) {
    case 1:
        hr = GetJobInfo(dwApiLevel,
                        (LPBYTE*)&lpJobInfo1,
                        _pszPrinterName,
                        _lJobId
                        );

        BAIL_IF_ERROR(hr);

        hr = UnMarshallLevel1(lpJobInfo1,
                              fExplicit
                              );
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetJobInfo(dwApiLevel,
                        (LPBYTE *)&lpJobInfo2,
                        _pszPrinterName,
                        _lJobId
                        );

        BAIL_IF_ERROR(hr);

        hr = UnMarshallLevel2(lpJobInfo2,
                              fExplicit
                              );
        BAIL_IF_ERROR(hr);
        break;

    default:
        hr = E_FAIL;
        break;

    }

cleanup:

    if (lpJobInfo1) {
        FreeADsMem(lpJobInfo1);
    }


    if (lpJobInfo2) {
        FreeADsMem(lpJobInfo2);
    }

    RRETURN_EXP_IF_ERR(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to get information from the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintJob::GetInfo(THIS)
{
    RRETURN(GetInfo(2, TRUE));
}

STDMETHODIMP
CWinNTPrintJob::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(2, FALSE));
}

STDMETHODIMP
CWinNTPrintJob::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CWinNTPrintJob::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}


STDMETHODIMP
CWinNTPrintJob::get_HostPrintQueue(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, HostPrintQueue);
}


STDMETHODIMP
CWinNTPrintJob::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, User);
}

STDMETHODIMP
CWinNTPrintJob::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintJob::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CWinNTPrintJob::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}


STDMETHODIMP
CWinNTPrintJob::get_TimeSubmitted(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, TimeSubmitted);
}


STDMETHODIMP
CWinNTPrintJob::get_TotalPages(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TotalPages);
}


STDMETHODIMP
CWinNTPrintJob::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintJob::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintJob::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintJob::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}


STDMETHODIMP
CWinNTPrintJob::get_Size(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Size);
}

STDMETHODIMP
CWinNTPrintJob::put_Notify(THIS_ BSTR bstrNotify)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CWinNTPrintJob::get_Notify(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CWinNTPrintJob::put_NotifyPath(THIS_ BSTR bstrNotify)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintJob::get_NotifyPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CWinNTPrintJob::put_Position(THIS_ LONG lPosition)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CWinNTPrintJob::get_Position(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CWinNTPrintJob::get_PagesPrinted(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, PagesPrinted);
}

STDMETHODIMP
CWinNTPrintJob::get_TimeElapsed(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TimeElapsed);
}



//+------------------------------------------------------------------------
//
//  Function: CWinNTPrintJob::Pause
//
//  Synopsis:   Binds to real printer as specified in _lpszPrinterName and attempts
//              to pause this job.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//
//---------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintJob::Pause(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    //
    // we need to open the printer with the right printer
    // defaults in order to perform the operations that we
    // have here
    //

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_PAUSE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJob::Resume(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;

    //
    // we need to open the printer with the right printer
    // defaults in order to perform the operations that we
    // have here
    //

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_RESUME
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJob::Remove(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    //
    // se JOB_CONTROL_DELETE instead of JOB_CONTROL_CANCEL as DELETE works
    // even when a print job has been restarted while CANCLE won't
    //

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_DELETE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTPrintJob::get_Status(THIS_ long FAR* retval)
{
    HRESULT hr =S_OK;
    LPJOB_INFO_1 lpJobInfo1 = NULL;
    BOOL found;
    DWORD dwStatus;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = GetJobInfo(1,
                    (LPBYTE*)&lpJobInfo1,
                    _pszPrinterName,
                    _lJobId);

    BAIL_IF_ERROR(hr);

    //
    // instead of a conversion routine, just return the WinNT
    // Status code
    //

    *retval = lpJobInfo1->Status;

cleanup:
    if(lpJobInfo1){
        FreeADsMem((LPBYTE)lpJobInfo1);
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


DEFINE_IDispatch_Delegating_Implementation(CWinNTNamespace)
DEFINE_IADsExtension_Implementation(CWinNTNamespace)
DEFINE_IADs_Implementation(CWinNTNamespace)

//  Class CWinNTNamespace

CWinNTNamespace::CWinNTNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CWinNTNamespace);
}

HRESULT
CWinNTNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(&pNamespace);
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                NAMESPACE_CLASS_NAME,
                NO_SCHEMA,
                CLSID_WinNTNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Namespace objects have no components in their ADsPath. Just set the
        // class for identification.
        pNamespace->_CompClasses[0] = L"Namespace";

        hr = pNamespace->InitUmiObject(
                pNamespace->_Credentials,
                NULL,
                0,
                NULL,
                (IUnknown *)(INonDelegatingUnknown *) pNamespace,
                NULL,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CWinNTNamespace::~CWinNTNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTNamespace::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTNamespace::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTNamespace::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTNamespace::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider))
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTNamespace::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::ImplicitGetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTNamespace::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +3 for // and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 3;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"//");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CWinNTNamespaceEnum::Create((CWinNTNamespaceEnum **)&penum, _vFilter,
                                             _Credentials);
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::Delete(
    THIS_ BSTR SourceName,
    BSTR Type
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CWinNTNamespace::AllocateNamespaceObject(
    CWinNTNamespace ** ppNamespace
    )
{
    CWinNTNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CWinNTNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADs,
            (IADs *)pNamespace,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsOpenDSObject,
            (IADsOpenDSObject *)pNamespace,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsContainer,
            (IADsContainer *)pNamespace,
            DISPID_NEWENUM
            );
    BAIL_ON_FAILURE(hr);

    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CWinNTNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch **ppADsObj
    )
{
    HRESULT hr = S_OK;
    DWORD dwResult;
    IUnknown * pObject = NULL;

    *ppADsObj = NULL;

    CWinNTCredentials Credentials(lpszUserName, lpszPassword, lnReserved);

    hr = ::GetObject(lpszDNName, (LPVOID *)&pObject, Credentials);
    BAIL_ON_FAILURE(hr);

    // UMI objects do not implement IDispatch. Hence QI for IUnknown instead
    // of IDispatch. 
    
    if(lnReserved & ADS_AUTH_RESERVED)
    // call is from UMI
        hr = pObject->QueryInterface(IID_IUnknown, (void **)ppADsObj);
    else
        hr = pObject->QueryInterface(IID_IDispatch, (void **)ppADsObj);
    BAIL_ON_FAILURE(hr);

error:
    if (pObject)
        pObject->Release();

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTNamespace::ParsePath(
    BSTR bstrADsPath,
    DWORD dwType,
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);

            hr = Object(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo,TRUE);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CWinNTNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the
    components in the target objinfo is empty. Users of this function can call
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents]) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents]);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents]) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents]);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CWinNTNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void
CWinNTNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only.
    Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (pComponent[cComponents].szValue) {
        //
        // If value exist, only show display value
        //
        wcscat(szReturn,
               pComponent[cComponents].szValue);
    }
    else {
        //
        // else value is only stored in Component
        //
        wcscat(szReturn,
               pComponent[cComponents].szComponent);
    }
}


HRESULT
CWinNTNamespace::SetComponents(
                            LPWSTR szReturn,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            }
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            }
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    dwLimit = _pObjectInfo->NumComponents;
    if (dwType == ADS_COMPONENT_PARENT) {
        dwLimit--;
    }
    if (dwOtherLimit >= dwLimit) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }
    for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
        SetComponent(szReturn,
                     cComponents,
                     fEscaped);
        if (cComponents != dwLimit - 1) {
            wcscat(szReturn,
                   chSeparator);
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2;
    }
    return dwPath;
}


STDMETHODIMP
CWinNTNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_OFF_EX:
        case ADS_ESCAPEDMODE_DEFAULT:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            goto error;
           break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\common.cxx ===
#include "winnt.hxx"
#pragma hdrstop

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    );


HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    );

HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    );


FILTERS Filters[] = {
                    {L"user", WINNT_USER_ID},
                    {L"group", WINNT_GROUP_ID},  // for backward compatibility
                    {L"localgroup", WINNT_LOCALGROUP_ID},
                    {L"globalgroup", WINNT_GLOBALGROUP_ID},
                    {L"printqueue", WINNT_PRINTER_ID},
                    {L"domain", WINNT_DOMAIN_ID},
                    {L"computer", WINNT_COMPUTER_ID},
                    {L"service", WINNT_SERVICE_ID},
                    {L"fileshare", WINNT_FILESHARE_ID},
                    {L"schema", WINNT_SCHEMA_ID},
                    {L"class", WINNT_CLASS_ID},
                    {L"syntax", WINNT_SYNTAX_ID},
                    {L"property", WINNT_PROPERTY_ID},
                    {L"FPNWfileshare", WINNT_FPNW_FILESHARE_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------



HRESULT
BuildADsPath(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR *pADsPath
    )
{
    WCHAR ADsPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);


    if ( (wcslen(Parent) + wcslen(Name)) > MAX_PATH - 1) {
        RRETURN(E_FAIL);
    }

    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    if (!pszDisplayName || !*pszDisplayName) {
        //
        // The display name has to be valid.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        *pADsPath = AllocADsStr(pszDisplayName);
        if (*pADsPath == NULL) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        else {
            hr = S_OK;
            goto cleanup;
        }
    }

    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(ADsPath, Parent);

    if (_wcsicmp(ADsPath, ProviderName)) {
        wcscat(ADsPath, L"/");
    }else {
        wcscat(ADsPath, L"//");
    }
    wcscat(ADsPath, pszDisplayName);

    *pADsPath = AllocADsStr(ADsPath);

    if (*pADsPath == NULL)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);


cleanup:
error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR Schema,
    LPWSTR *pSchemaPath
    )
{
    WCHAR SchemaPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(Parent);


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent);
    ADsAssert(pSchemaPath);

    //
    // If no schema name is passed in, then there is no schema path
    //
    if ( Schema == NULL || *Schema == 0 ){

        *pSchemaPath = AllocADsStr(L"");
        RRETURN(*pSchemaPath ? S_OK: E_OUTOFMEMORY );
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    wsprintf(SchemaPath, L"%s://", szProviderName);

    if (!pObjectInfo->NumComponents) {
        if( (wcslen(Name) + wcslen(szProviderName) + 4) > MAX_PATH ) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
        wcscat(SchemaPath, Name);
    }else{
        if( (wcslen(pObjectInfo->DisplayComponentArray[0]) +
                    wcslen(szProviderName) + 4) > MAX_PATH ) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        } 
        wcscat(SchemaPath, pObjectInfo->DisplayComponentArray[0]);
    }

    if( (wcslen(SchemaPath) + wcslen(SCHEMA_NAME) + wcslen(Schema) + 3) >
               MAX_PATH ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
 
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, SCHEMA_NAME );
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, Schema );


    *pSchemaPath = AllocADsStr(SchemaPath);
    hr = pSchemaPath ? S_OK: E_OUTOFMEMORY ;

error:

    FreeObjectInfo( &ObjectInfo, TRUE );

    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    LPWSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    *pADsClass = AllocADsStr(ADsClass);
    RRETURN (*pADsClass ? S_OK: E_OUTOFMEMORY);

}


HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


HRESULT
BuildObjectInfo(
    LPWSTR ADsParent,
    LPWSTR Name,
    POBJECTINFO * ppObjectInfo
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Both should be set in this call, cannot have a NULL parent.
    //
    if (!ADsParent || !*ADsParent) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    //
    // We need to make sure that the path is not greater
    // than MAX_PATH + 2 = 1 for / and another for \0
    //
    if ((wcslen(ADsParent) + wcslen(Name) + 2) > MAX_PATH) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, ADsParent);
    wcscat(szBuffer, L"/");
    wcscat(szBuffer, Name);

    CLexer Lexer(szBuffer);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}



HRESULT
BuildObjectInfo(
    LPWSTR ADsPath,
    POBJECTINFO * ppObjectInfo
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo =  NULL;

    RRETURN(hr);
}


HRESULT
MakeWinNTAccountName(
    POBJECTINFO pObjectInfo,
    LPWSTR  szUserAccount,
    BOOL fConnectToReg
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumComp = 0;
    DWORD dwProductType = PRODTYPE_INVALID;
    WCHAR szDomain[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    BOOL fReplacedWithDC = FALSE;

    // The credentials are needed to pass into WinNTGetCachedComputerName
    CWinNTCredentials nullCredentials;

    // Need szSAMName as dummy param
    szSAMName[0] = L'\0';

    if (!pObjectInfo || !szUserAccount)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    dwNumComp = pObjectInfo->NumComponents;

    switch (dwNumComp) {

    case 2:
    case 3:

        //
        // Check if machine is a dc
        //

        //
        // Going to try getComputerName first as the NetWkstaGetInfo call
        // times out faster than the RegConnect call we use in
        // GetMachineProductType - AjayR 11-06-98.
        //

        if (fConnectToReg) {

            if (dwNumComp==2) {
               //
               // we don't have domain name in pObjectInfo, let's try
               // to get it from the dc name (comp[0])
               //

               hr = WinNTGetCachedComputerName(
                   pObjectInfo->ComponentArray[0],
                   szUserAccount,
                   szSAMName,
                   nullCredentials
                   );

               if (SUCCEEDED(hr))
               {
                   fReplacedWithDC = TRUE;
               }
            }

            else // dwNumComp==3
            {
               //
               // We have domain name (comp[0]) in our objectInfo, let's use
               // it. Can call ValidateComputerName here, but not needed
               // since error will be caught next.
               //

               wcscpy(szUserAccount, pObjectInfo->ComponentArray[0]);

               fReplacedWithDC = TRUE;
            }

            if (fReplacedWithDC) {
                //
                // Now try connecting to make sure it is a DC
                // otherwise we should not do this replacement
                //
                hr = GetMachineProductType(
                         pObjectInfo->ComponentArray[dwNumComp-2],
                         &dwProductType
                         );
                BAIL_ON_FAILURE(hr);

                if (dwProductType != PRODTYPE_DC) {
                    //
                    // We cannot use szUserAccount as it has
                    // bad info
                    //
                    fReplacedWithDC = FALSE;
                    hr = E_FAIL;
                }

            }

        }// if fConnectToReg

        BAIL_ON_FAILURE(hr);
        //
        // Do not want to replace machine name with domain since not dc or
        // dc but can't replace - best efforts fail
        //

        if (fReplacedWithDC==FALSE)
        {
            wcscpy(szUserAccount, pObjectInfo->ComponentArray[dwNumComp-2]);
        }

        //
        // Add \UserName to account name
        //
        wcscat(szUserAccount, L"\\");
        wcscat(szUserAccount, pObjectInfo->ComponentArray[dwNumComp-1]);
        break;

    default:

        RRETURN(E_ADS_UNKNOWN_OBJECT);

    }


error:
    RRETURN(hr);
}



HRESULT
MakeWinNTDomainAndName(
    POBJECTINFO pObjectInfo,
    LPWSTR szDomName
    )
{
    DWORD dwNumComp = pObjectInfo->NumComponents;

    switch (dwNumComp) {
    case 2:
    case 3:
        wcscpy(szDomName, pObjectInfo->ComponentArray[dwNumComp - 2]);
        wcscat(szDomName, L"\\");
        wcscat(szDomName, pObjectInfo->ComponentArray[dwNumComp - 1]);
        break;

    default:
        RRETURN(E_ADS_UNKNOWN_OBJECT);

    }
    RRETURN(S_OK);
}

HRESULT
ValidateObject(
    DWORD dwObjectType,
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    ULONG uGroupType;
    DWORD dwParentId;

    switch (dwObjectType) {
      case WINNT_USER_ID:
        RRETURN(ValidateUserObject(pObjectInfo, &dwParentId, Credentials));

      case WINNT_GROUP_ID:
        RRETURN(ValidateGroupObject(
                    pObjectInfo,
                    &uGroupType,
                    &dwParentId,
                    Credentials
                    ));

      case WINNT_COMPUTER_ID:
        RRETURN(ValidateComputerObject(pObjectInfo, Credentials));

      case WINNT_PRINTER_ID:
        RRETURN(ValidatePrinterObject(pObjectInfo, Credentials));

      case WINNT_SERVICE_ID:
        RRETURN(ValidateServiceObject(pObjectInfo, Credentials));

      case WINNT_FILESHARE_ID:
        RRETURN(ValidateFileShareObject(pObjectInfo, Credentials));

      default:
        RRETURN(E_FAIL);
    }
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo,
    BOOL fStatic
    )
{
    DWORD i = 0;

    if (!pObjectInfo) {
        return;
    }

    FreeADsStr( pObjectInfo->ProviderName );

    for (i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr(pObjectInfo->ComponentArray[i]);
        FreeADsStr(pObjectInfo->DisplayComponentArray[i]);
    }

    if ( !fStatic )
        FreeADsMem(pObjectInfo);
}

HRESULT
CopyObjectInfo(
    POBJECTINFO pSrcObjectInfo,
    POBJECTINFO *pTargObjectInfo
    )
{
    POBJECTINFO pObjectInfo = NULL;
    HRESULT hr S_OK;
    DWORD i;

    if(!pSrcObjectInfo){
        RRETURN(S_OK);
    }
    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));

    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    pObjectInfo->ObjectType = pSrcObjectInfo->ObjectType;
    pObjectInfo->NumComponents = pSrcObjectInfo->NumComponents;
    pObjectInfo->ProviderName = AllocADsStr(pSrcObjectInfo->ProviderName);

    for(i=0; i<pSrcObjectInfo->NumComponents; i++){
        pObjectInfo->ComponentArray[i] =
          AllocADsStr(pSrcObjectInfo->ComponentArray[i]);
        pObjectInfo->DisplayComponentArray[i] =
          AllocADsStr(pSrcObjectInfo->DisplayComponentArray[i]);
    }
    *pTargObjectInfo = pObjectInfo;
    RRETURN(hr);

error:
    RRETURN(hr);
}

HRESULT
GetObjectType(
    PFILTERS pFilters,
    DWORD dwMaxFilters,
    LPWSTR ClassName,
    PDWORD pdwObjectType
    )
{
    DWORD i = 0;

    ADsAssert(pdwObjectType);

    for (i = 0; i < dwMaxFilters; i++) {
        if (!_wcsicmp(ClassName, (pFilters + i)->szObjectName)) {
            *pdwObjectType = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }
    }
    *pdwObjectType = 0;
    RRETURN(E_INVALIDARG);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
GetDomainFromPath(
    LPTSTR ADsPath,
    LPTSTR szDomainName
    )
{
   OBJECTINFO ObjectInfo;
   POBJECTINFO pObjectInfo = &ObjectInfo;
   CLexer Lexer(ADsPath);
   HRESULT hr = S_OK;


   //assumption: Valid strings are passed to GetDomainFromPath

   ADsAssert(ADsPath);
   ADsAssert(szDomainName);

   memset(pObjectInfo, 0, sizeof(OBJECTINFO));
   hr = Object(&Lexer, pObjectInfo);
   BAIL_ON_FAILURE(hr);


   if (pObjectInfo->NumComponents) {
       wcscpy(szDomainName, pObjectInfo->ComponentArray[0]);
   }else {
       hr = E_FAIL;
   }

error:

   FreeObjectInfo( &ObjectInfo, TRUE );

   RRETURN(hr);
}

HRESULT
GetServerFromPath(
    LPTSTR ADsPath,
    LPTSTR szServerName
    )
{
   OBJECTINFO ObjectInfo;
   POBJECTINFO pObjectInfo = &ObjectInfo;
   CLexer Lexer(ADsPath);
   HRESULT hr = S_OK;


   //assumption: Valid strings are passed to GetDomainFromPath

   ADsAssert(ADsPath);
   ADsAssert(szServerName);

   memset(pObjectInfo, 0, sizeof(OBJECTINFO));
   hr = Object(&Lexer, pObjectInfo);
   BAIL_ON_FAILURE(hr);


   if (pObjectInfo->NumComponents > 1) {
       wcscpy(szServerName, pObjectInfo->ComponentArray[1]);
   }else {
       hr = E_FAIL;
   }

error:

   FreeObjectInfo( &ObjectInfo, TRUE );

   RRETURN(hr);
}



DWORD
TickCountDiff(
    DWORD dwTime1,
    DWORD dwTime2
    )
{
   //
   // does dwTime1 - dwTime2 and takes care of wraparound.
   // The first time must be later than the second
   // Restriction:: The two times must have been taken not more than
   // 49.7 days apart
   //

   DWORD dwRetval;

   if(dwTime1 >= dwTime2){
      dwRetval = dwTime1 - dwTime2;
   }

   else{
      dwRetval = dwTime2 - dwTime1;
      dwRetval =  MAX_DWORD - dwRetval;
   }
   return dwRetval;
}

HRESULT
DelimitedStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar,
    TCHAR Delimiter
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements;
    LPTSTR pszCurrPos = pszString;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a delimited string into a VARIANT of
    // safe arrays.
    //
    // Assumption: a valid string are passed to this function
    // note that the input string gets destroyed in the process
    //

    //
    // scan the delimited string once to find out the dimension
    //

    //
    // in order to filter for NULL input values do a sanity check for
    // length of input string.
    //


    if (!pszString){
        sabound[0].cElements = 0;
        sabound[0].lLbound = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

        if (psa == NULL){
            hr = E_OUTOFMEMORY;
            goto error;
        }

        VariantInit(pvar);
        V_VT(pvar) = VT_ARRAY|VT_VARIANT;
        V_ARRAY(pvar) = psa;
        goto error;
    }

    dwElements = (wcslen(pszString) == 0) ? 0: 1 ;

    while(!(*pszCurrPos == TEXT('\0'))){
        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }
        pszCurrPos++;
    }

    rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);

    if(!rgszStrings){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){
            *(rgszStrings+i) = ++pszCurrPos;
            i++;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));

        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings && dwElements != 0){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}


HRESULT
BuildComputerFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPTSTR pszADsPath
    )
{

    if(!pObjectInfo){
        RRETURN(E_FAIL);
    }

    if(pObjectInfo->NumComponents == 3) {

        wsprintf(
            pszADsPath,
            L"%s://%s/%s",
            pObjectInfo->ProviderName,
            pObjectInfo->ComponentArray[0],
            pObjectInfo->ComponentArray[1]
            );

    } else if (pObjectInfo->NumComponents == 2){

        wsprintf(
            pszADsPath,
            L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->ComponentArray[0]
            );

    } else {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);

}

HRESULT
FPNWSERVERADDRtoString(
    FPNWSERVERADDR WkstaAddress,
    LPWSTR * ppszString
    )
{

    HRESULT hr = S_OK;
    TCHAR  szNibble[2]; //one number and a null termination
    USHORT  usNibble;
    int i;
    TCHAR szWkstaAddr[MAX_PATH];

    //
    // assumption: valid input values are passed to this function.
    //

    //
    // First 4 bytes is network address, then a dot and then bytes 5-10
    // are physical node address. Each byte consumes 2 chars space.
    // Then a byte for TEXT('\0')
    //

    _tcscpy(szWkstaAddr, TEXT(""));

    for( i=0; i < 4; i++){

         usNibble = WkstaAddress[i] & 0xF0;
         usNibble = usNibble >> 4;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
         usNibble = WkstaAddress[i] & 0xF;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);

    }

    _tcscat(szWkstaAddr, TEXT("."));

    for(i=4; i<10 ; i++){

         usNibble = WkstaAddress[i] & 0xF0;
         usNibble = usNibble >> 4;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
         usNibble = WkstaAddress[i] & 0xF;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
    }

    *ppszString = AllocADsStr(szWkstaAddr);

    if(!*ppszString){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, L",");

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, L",");
    }

    pResult->cTokens = cTokens;

    return( pResult );
}

STDMETHODIMP
GenericGetPropertyManager(
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwInfoLevel;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists

    hr = pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );

    BAIL_ON_FAILURE(hr);


    //
    // translate the Nt objects to variants
    //

    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                    pNtSrcObjects,
                    pvProp
                    );

    }else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
GenericPutPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp,
    BOOL fCheckSchemaWriteAccess
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0;


    //
    // check if property in schema and get syntax of property
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );

    if(TRUE == fCheckSchemaWriteAccess) {
    //
    // check if this is a writeable property in the schema
    //

        hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Issue: How do we handle multi-valued support
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if( (0 == dwNumValues) && (NULL == pVarArray) ) {
        // return error if the safearray had no elements. Otherwise, the
        // NT object stored in the property cache is garbage.
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        pvProp = pVarArray;

    }else {

        dwNumValues = 1;
    }


    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}



STDMETHODIMP
GenericGetExPropertyManager(
    DWORD dwObjectState,
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
GenericPutExPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0;


    //
    // check if property in schema and get syntax of property
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );

    //
    // check if this is a writeable property in the schema
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Issue: How do we handle multi-valued support
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if( (0 == dwNumValues) && (NULL == pVarArray) ) {
        // return error if the safearray had no elements. Otherwise, the
        // NT object stored in the property cache is garbage.
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        pvProp = pVarArray;

    }else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }


    RRETURN(hr);
}


DWORD
DelimitedStrSize(
    LPWSTR pszString,
    WCHAR  Delimiter
    )
{

    DWORD dwElements = (wcslen(pszString) == 0) ? 0: 1 ;
    LPTSTR pszCurrPos = pszString;

    if (!pszString || !*pszString) {
        return dwElements;
    }

    while(!(*pszCurrPos == TEXT('\0'))){

        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }

        pszCurrPos++;
    }

    return dwElements;

}




DWORD
NulledStrSize(
    LPWSTR pszString
    )
{


    DWORD dwElements = 0;
    LPTSTR pszCurrPos = pszString;
    BOOL foundNULL = FALSE;

    if (!pszString || !*pszString) {
        return dwElements;
    }

    while(!(*pszCurrPos == TEXT('\0') && foundNULL== TRUE)){

        if(*pszCurrPos == TEXT('\0')){
            dwElements++;
            foundNULL = TRUE;
        } else {
            foundNULL = FALSE;
        }

        pszCurrPos++;
    }

    return dwElements;

}



HRESULT
GenericPropCountPropertyManager(
    CPropertyCache * pPropertyCache,
    PLONG plCount
    )
{
    HRESULT hr = E_FAIL;

    if (pPropertyCache) {
        hr = pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN(hr);
}

HRESULT
GenericNextPropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;

    VariantInit(&varData);

    hr = pPropertyCache->unboundgetproperty(
                pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    hr = ConvertNtValuesToVariant(
                pPropertyCache->get_CurrentPropName(),
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);



error:


    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    pPropertyCache->skip_propindex(
                1
                );

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
                pNtSrcObjects,
                dwNumValues
                );
    }

    RRETURN(hr);
}


HRESULT
GenericSkipPropertyManager(
    CPropertyCache * pPropertyCache,
    ULONG cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}

HRESULT
GenericResetPropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}

HRESULT
GenericDeletePropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT varEntry
    )
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}


HRESULT
GenericPutPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH] = L"";
    LPNTOBJECT pNtDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwControlCode = 0;



    hr = ConvertVariantToNtValues(
                varData,
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName,
                &pNtDestObjects,
                &dwNumValues,
                &dwSyntaxId,
                &dwControlCode
                );
    BAIL_ON_FAILURE(hr);

    if (dwControlCode != ADS_PROPERTY_UPDATE) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // check if this is a writeable property in the schema
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}



HRESULT
GenericGetPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    BSTR bstrName,
    LONG lnADsType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = ConvertNtValuesToVariant(
                bstrName,
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}



HRESULT
GenericItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    VARIANT varIndex,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;
    LPWSTR szPropName = NULL;
    VARIANT *pvVar = &varIndex;

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        if (dwObjectState == ADS_OBJECT_UNBOUND) {

            hr = pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNtValuesToVariant(
                    V_BSTR(pvVar),
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;


    case VT_I4:

        hr = pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I2:

        hr = pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }


error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);

}


HRESULT
GenericPurgePropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}





HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(dwADsType);

    BAIL_ON_FAILURE(hr);

    // no control code

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

HRESULT
ConvertNtValuesToVariant(
    LPWSTR szPropertyName,
    PNTOBJECT pNtSrcObject,
    DWORD dwNumValues,
    PVARIANT pVariant
    )
{
    HRESULT hr = S_OK;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;
    ADSTYPE dwADsType = ADSTYPE_INVALID;

    VariantInit(&varData);
    VariantInit(pVariant);

    if (dwNumValues>0) {

        hr = NTTypeToAdsTypeCopyConstruct(
                pNtSrcObject,
                dwNumValues,
                &pAdsValues
                );

        if (SUCCEEDED(hr)) {

            hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
            BAIL_ON_FAILURE(hr);

            dwADsType = pAdsValues->dwType;
        }

        else if (hr==E_OUTOFMEMORY) {

            BAIL_ON_FAILURE(hr);
        }

        //
        // failed because of NTType is not supported yet (e.g DelimitedString)
        // in NTTypeToAdsTypeCopyConstruct() conversion
        // -> use empty variant now.
        //
        else {

            VariantInit(&varData);
        }
    }

    hr = CreatePropEntry(
            szPropertyName,
            dwADsType,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVariant) = pDispatch;
    V_VT(pVariant) = VT_DISPATCH;


error:

    VariantClear(&varData);

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
       FreeADsMem( pAdsValues );
    }

    RRETURN(hr);

}



HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pVarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(&varData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pVarData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId,
    PDWORD pdwControlCode
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNTOBJECT pNtDestObjects = 0;
    DWORD dwNumNtObjects = 0;
    DWORD dwNtSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    if(wcslen(bstrPropName) < MAX_PATH)
        wcscpy(szPropertyName, bstrPropName);
    else {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNTTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNtDestObjects,
                    &dwNumNtObjects,
                    &dwNtSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwNumValues = dwNumValues;
    *ppNtDestObjects = pNtDestObjects;
    *pdwSyntaxId = dwNtSyntaxId;

error:

    if (pVarArray) {
        FreeVariantArray(
                pVarArray,
                dwNumValues
                );
    }

    if (pPropEntry) {
        pPropEntry->Release();
    }
    VariantClear(&varValues);

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwAdsValues
            );
       FreeADsMem( pAdsValues );
    }

    RRETURN(hr);
}


HRESULT
GetMachineProductType(
    IN  LPTSTR  pszServer,
    OUT PRODUCTTYPE *pdwProductType
    )
{

    HRESULT     hr = S_OK;
    LONG        dwStatus;
    HKEY        hkLocalMachine = NULL;
    HKEY        hkProductOptions = NULL;
    DWORD       dwValueType;
    WCHAR       szData[20];
    DWORD       dwDataSize = sizeof(szData);


    //
    // pszServer can be NULL for local server
    //
    if (!pdwProductType)
        RRETURN(E_ADS_BAD_PARAMETER);

    *pdwProductType = PRODTYPE_INVALID;


    //
    // Connect to remote's machine registry
    //
    dwStatus = RegConnectRegistry(
                    pszServer,
                    HKEY_LOCAL_MACHINE,
                    &hkLocalMachine
                    );

    if (dwStatus != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }


    //
    // Open key ProductOptions
    //
    dwStatus = RegOpenKeyEx(
                    hkLocalMachine,
                    L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                    0,
                    KEY_QUERY_VALUE,
                    &hkProductOptions
                    );

    if (dwStatus != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }


    //
    // Get Value of Product Type
    //
    dwStatus = RegQueryValueEx(
                    hkProductOptions,
                    L"ProductType",
                    NULL,
                    &dwValueType,
                    (LPBYTE) szData,
                    &dwDataSize
                    );


    //
    //  check server type
    //
    if (_wcsicmp(szData, WINNT_A_LANMANNT_W)==0)
    {
        *pdwProductType = PRODTYPE_DC;
    }
    else if (_wcsicmp(szData, WINNT_A_SERVERNT_W)==0)
    {
        *pdwProductType = PRODTYPE_STDALONESVR;
    }
    else if (_wcsicmp(szData, WINNT_A_WINNT_W)==0)
    {
        *pdwProductType = PRODTYPE_WKSTA;
    }
    else
    {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


error:


    if ( hkLocalMachine )
        RegCloseKey(hkLocalMachine);

    if  ( hkProductOptions )
        RegCloseKey(hkProductOptions);

    RRETURN(hr);
}



//
// Get Sid of account name [lpszAccountName] from server [lpszServerName].
// Unmarshall the Sid into cache [pPropertyCache] if [fExplict] is TRUE.
// Use local machine if [lpszServerName] == NULL.
//

HRESULT
GetSidIntoCache(
    IN  LPTSTR lpszServerName,
    IN  LPTSTR lpszAccountName,
    IN  CPropertyCache * pPropertyCache,
    IN  BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    BOOL fGotSid = FALSE;
    DWORD dwErr = 0;
    PSID pSid = NULL;
    DWORD dwSidLength = 0;
    WCHAR szNewAccountName[MAX_PATH+UNLEN+2];
    LPTSTR lpSrvName;

    //
    // default cbSid size :
    //  - 1 (revision), 1 (authid), max sub(auth)
    //  - * 8 (rev, authid, subid all < 8), but use 8 in case of
    //    structure aligment because of compiler/machine (we want
    //    LookUpAccountName() to succeed at first attempt as much
    //    as possible to min this wired call)
    //

    const DWORD maxSid = (1+1+SID_MAX_SUB_AUTHORITIES) * 8;
    DWORD cbSid = maxSid;

    //
    // dummies
    //

    TCHAR szRefDomainName[MAX_PATH];
    DWORD cbRefDomainName = MAX_PATH;
    SID_NAME_USE eNameUse;


    if (!lpszAccountName)
        RRETURN(E_ADS_INVALID_USER_OBJECT);

    if (!pPropertyCache)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // allocate sid and RefDomainName buffer
    //

    pSid = (PSID) AllocADsMem(
                    cbSid
                    );
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // get sid and other unused info from server
    //

    fGotSid = LookupAccountName(
                lpszServerName,
                lpszAccountName,
                pSid,
                &cbSid,
                szRefDomainName,
                &cbRefDomainName,
                &eNameUse
                );

    if (!fGotSid) {

        if (cbSid>maxSid) {

            //
            // Fail becuase buffer size required > what we have allocated
            // for some reasons,  retry with correct buffer size
            //

            FreeADsMem(pSid);

            pSid = (PSID) AllocADsMem(
                        cbSid
                        );
            if (!pSid) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            fGotSid = LookupAccountName(
                        lpszServerName,
                        lpszAccountName,
                        pSid,
                        &cbSid,
                        szRefDomainName,
                        &cbRefDomainName,
                        &eNameUse
                        );

            if (!fGotSid) {

                //
                // Fail on retry with proper buffer size, can do no more
                //

                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }

        } else {

            //
            // Fail becuase of reasons other then buffer size, not need to
            // retry.
            //

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        
    } 
    
    if( fGotSid && (eNameUse == SidTypeDomain) ) {
            lpSrvName = lpszServerName;
            if (lpszServerName && (lpszServerName[0] == L'\\') && (lpszServerName[1] == L'\\')) {
                lpSrvName += 2;
            }

        #ifdef WIN95
                if (!_wcsicmp(lpszAccountName, lpSrvName)) {
        #else
                if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        lpszAccountName,
                        -1,
                        lpSrvName,
                        -1
                        ) == CSTR_EQUAL ) {
        #endif
                    wcscpy(szNewAccountName, lpSrvName);
                    wcscat(szNewAccountName, L"\\");
                    wcscat(szNewAccountName, lpszAccountName);

                    cbSid = maxSid;
                    cbRefDomainName = MAX_PATH;
                
                    fGotSid = LookupAccountName(
                            lpszServerName,
                            szNewAccountName,
                            pSid,
                            &cbSid,
                            szRefDomainName,
                            &cbRefDomainName,
                            &eNameUse
                            );

                    if (!fGotSid) {

                        if (cbSid>maxSid) {

                        //
                        // Fail becuase buffer size required > what we have allocated
                        // for some reasons,  retry with correct buffer size
                        //

                            FreeADsMem(pSid);

                            pSid = (PSID) AllocADsMem(
                                    cbSid
                                    );
                            if (!pSid) {
                                hr = E_OUTOFMEMORY;
                                BAIL_ON_FAILURE(hr);
                            }

                            fGotSid = LookupAccountName(
                                        lpszServerName,
                                        szNewAccountName,
                                        pSid,
                                        &cbSid,
                                        szRefDomainName,
                                        &cbRefDomainName,
                                        &eNameUse
                                        );

                            if (!fGotSid) {

                                //
                                // Fail on retry with proper buffer size, can do no more
                                //

                                dwErr = GetLastError();
                                hr = HRESULT_FROM_WIN32(dwErr);
                            }

                        } else {

                                //
                                // Fail becuase of reasons other then buffer size, not need to
                                // retry.
                                //

                                dwErr = GetLastError();
                                hr = HRESULT_FROM_WIN32(dwErr);
                        }
        
                    }
                }
    }

    BAIL_ON_FAILURE(hr);


    //
    // On NT4 for some reason GetLengthSID does not set lasterror to 0
    //
    SetLastError(NO_ERROR);

    dwSidLength = GetLengthSid((PSID) pSid);

    dwErr = GetLastError();

    //
    // This is an extra check to make sure that we have the
    // correct length.
    //
    if (dwErr != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);
    //
    // store Sid in property cache
    //

    hr = SetOctetPropertyInCache(
                pPropertyCache,
                TEXT("objectSid"),
                (PBYTE) pSid,
                dwSidLength,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\clgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTLocalGroupCollection

DEFINE_IDispatch_Implementation(CWinNTLocalGroupCollection)


CWinNTLocalGroupCollection::CWinNTLocalGroupCollection():
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _lpServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTLocalGroupCollection);
}


HRESULT
CWinNTLocalGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTLocalGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                LOCALGROUP_CLASS_NAME,
                NULL,
                CLSID_WinNTGroup,
                ADS_OBJECT_UNBOUND
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CWinNTLocalGroupCollection::~CWinNTLocalGroupCollection( )
{
    VariantClear( &_vFilter);

    if(_DomainName) {
    	ADsFreeString(_DomainName);
    }

    if(_ServerName) {
    	ADsFreeString(_ServerName);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CWinNTLocalGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTLocalGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTLocalGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTLocalGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTLocalGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTLocalGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTLocalGroupCollectionEnum::Create(
                (CWinNTLocalGroupCollectionEnum **)&penum,
                _Parent,
                _ParentType,
                _ADsPath,
                _DomainName,
                _ServerName,
                _Name,
                _GroupType,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTLocalGroupCollection::AllocateGroupCollectionObject(
    CWinNTLocalGroupCollection ** ppGroup
    )
{
    CWinNTLocalGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTLocalGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cobjcach.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cpdccach.cxx
//
//  Contents:     PDC Names Cache functionality for the WinNT Provider
//
//  Functions:
//                CObjNameCache::addentry
//                CObjNameCache::findentry
//                CObjNameCache::getentry
//                CProperyCache::CObjNameCache
//                CObjNameCache::~CObjNameCache
//                CObjNameCache::CreateClassCache
//
//  History:      25-Apr-96   KrishnaG   Created.
//                30-Aug-96   RamV       Permit cache to store values
//                                       other than PDC names
//
//----------------------------------------------------------------------------
#include "winnt.hxx"

//
// Definition for DsGetDcName on 4.0
//
typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
);

#ifdef UNICODE
#define GETDCNAME_API        "DsGetDcNameW"
#else
#define GETDCNAME_API        "DsGetDcNameA"
#endif



//
// DsGetDc will be called if applicabel if not we will look
// at the flags and decide if we should call NetGetAnyDCName or
// NetGetDCName - AjayR 11-04-98.
// Note the code below is not exactly "elegant" but I cannot think
// of any other way to build on 4.0, 95 and NT. Please play close
// attention to the #ifdefs when reading.
//
HRESULT
DsGetDcNameNTWrapper(
    IN LPCWSTR DomainName,
    OUT LPWSTR *ppszServerName,
    IN ULONG Flags
    )
{
    LPCWSTR ComputerName = NULL;
    GUID *DomainGuid = NULL;
    LPCWSTR SiteName = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = NULL;
    LPWSTR pszNetServerName = NULL;
    HRESULT hr = S_OK;
    ULONG ulDsGetDCFlags = DS_RETURN_FLAT_NAME | DS_WRITABLE_REQUIRED;

    if (Flags & ADS_READONLY_SERVER) {
        ulDsGetDCFlags &= ~DS_WRITABLE_REQUIRED;
    }

    *ppszServerName = NULL;


    static PF_DsGetDcName pfDsGetDcName = NULL ;


    //
    // Load the function if necessary
    //
    if (pfDsGetDcName == NULL) {
        pfDsGetDcName =
            (PF_DsGetDcName) LoadNetApi32Function(GETDCNAME_API) ;
    }

    if (pfDsGetDcName != NULL) {

        dwStatus =  ((*pfDsGetDcName)(
                        ComputerName,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        ulDsGetDCFlags,
                        &pDomainControllerInfo
                        )
                     );

        if (dwStatus == NO_ERROR) {
            *ppszServerName = AllocADsStr(
                                  pDomainControllerInfo->DomainControllerName
                                  );

            if (!*ppszServerName)
                hr = E_OUTOFMEMORY;

        } else {
            hr = HRESULT_FROM_WIN32(dwStatus);
        }

    } else {
        //
        // Could not load library
        //
        if (Flags & ADS_READONLY_SERVER) {

#ifdef WIN95
             dwStatus = NetGetDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
#else
             dwStatus = NetGetAnyDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
#endif

         } else {

             dwStatus = NetGetDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
         }

         if (dwStatus == NO_ERROR) {
             *ppszServerName = AllocADsStr(
                                   pszNetServerName
                                 );

             if (!*ppszServerName)
                 hr = E_OUTOFMEMORY;

         } else {

             hr = HRESULT_FROM_WIN32(dwStatus);

         }

     }


     if (pszNetServerName) {
         (void) NetApiBufferFree( (void*) pszNetServerName);
     }

     if (pDomainControllerInfo) {
         (void) NetApiBufferFree(pDomainControllerInfo);
     }

     RRETURN(hr);
 }







//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::addentry
//
//  Synopsis:
//
//
//
//  Arguments:  [pszDomainName]       --
//              [pszPDCName]      --
//              [pClassEntry]       --
//
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
addentry(
    LPWSTR pszElementName,
    BOOL fCacheHit,
    DWORD dwElementType,
    LPWSTR pszName
    )
{

    //
    // The parameter pszName is either the Domain/Wkgrp Name (if dwElementType
    // = COMPUTER_ENTRY_TYPE)   and  PDC Name (if   dwElementType     is
    // DOMAIN_ENTRY_TYPE). it will be a blank string if dwElementType is
    // WORKGROUP_ENTRY_TYPE
    //
    // we will support adding cache hits/misses.
    //

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwLRUEntry = 0;
    DWORD dwIndex = 0;

    EnterCriticalSection(&_cs);

    //
    // before adding entries, let us clean out all existing old entries
    //

    if (_dwMaxCacheSize == 0){
        hr = E_FAIL;
        goto error;
    }

    hr = InvalidateStaleEntries();
    BAIL_ON_FAILURE(hr);

    hr = findentry(
            pszElementName,
            &dwIndex
            );

    //
    // if you find an entry then you cannot add it to the cache
    //

    if(SUCCEEDED(hr)){
        goto error;
    }

    hr = S_OK;

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (!_ClassEntries[i].bInUse) {

            //
            // Found an available entry; use it
            // fill in the name of the entry and related information
            // for this class entry
            //
            break;

        } else {

            if ((dwLRUEntry == -1) || (i == IsOlderThan(i, dwLRUEntry))){
                dwLRUEntry = i;
            }
        }

    }

    if (i == _dwMaxCacheSize){

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //


        //
        // Free this entry
        //

        _ClassEntries[dwLRUEntry].bInUse = FALSE;

        i = dwLRUEntry;
    }


    //
    // Insert the new entry into the Cache
    //

    _ClassEntries[i].pszElementName = AllocADsStr(pszElementName);

    if(_ClassEntries[i].pszElementName == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    _ClassEntries[i].dwElementType = dwElementType;

    if ( fCacheHit){

        _ClassEntries[i].fCacheHit = TRUE;

        switch(dwElementType) {

        case DOMAIN_ENTRY_TYPE:

            _ClassEntries[i].u.pszPDCName = AllocADsStr(pszName);
            if(_ClassEntries[i].u.pszPDCName == NULL){
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        case DOMAIN_ENTRY_TYPE_RO:
            _ClassEntries[i].u.pszDCName = AllocADsStr(pszName);
            if (_ClassEntries[i].u.pszDCName == NULL) {
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        case COMPUTER_ENTRY_TYPE:

            _ClassEntries[i].u.pszDomainName = AllocADsStr(pszName);
            if(_ClassEntries[i].u.pszDomainName == NULL){
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        default:
            break;

        }
    } else {

        _ClassEntries[i].fCacheHit = FALSE;
    }

    _ClassEntries[i].bInUse = TRUE;

    //
    // update the time stamp so that we know when this entry was made
    //

    GetSystemTime(&_ClassEntries[i].st);

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
findentry(
    LPWSTR pszElementName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;


    EnterCriticalSection(&_cs);

    if (_dwMaxCacheSize == 0 ) {

        LeaveCriticalSection(&_cs);
        RRETURN(E_FAIL);
    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (_ClassEntries[i].bInUse) {

            if(!_ClassEntries[i].pszElementName ){
                continue;
            }

#ifdef WIN95
            if (!_wcsicmp(_ClassEntries[i].pszElementName, pszElementName)){
#else
            if (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    _ClassEntries[i].pszElementName,
                    -1,
                    pszElementName,
                    -1
                    ) == CSTR_EQUAL ) {
#endif

                *pdwIndex = i;


                LeaveCriticalSection(&_cs);

                RRETURN(S_OK);

            }
        }
    }

    LeaveCriticalSection(&_cs);

    RRETURN(E_FAIL);
}

//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::getentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
getentry(
    LPWSTR pszElementName,
    PBOOL  pfHit,
    PDWORD pdwEntryType,
    LPWSTR pszName
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    DWORD i;

    EnterCriticalSection(&_cs);

    //
    // blow away all the entries that have expired
    //

    hr = InvalidateStaleEntries();
    BAIL_ON_FAILURE(hr);

    hr = findentry(
            pszElementName,
            &dwIndex
        );
    BAIL_ON_FAILURE(hr);

    *pfHit = _ClassEntries[dwIndex].fCacheHit;
    *pdwEntryType =  _ClassEntries[dwIndex].dwElementType;


    switch(_ClassEntries[dwIndex].dwElementType) {

    case DOMAIN_ENTRY_TYPE:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszPDCName);
        break;

    case COMPUTER_ENTRY_TYPE:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszDomainName);
        break;


    case DOMAIN_ENTRY_TYPE_RO:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszDCName);
        break;

    default:
        wcscpy(pszName, TEXT(""));
        break;

    }


error:

    LeaveCriticalSection(&_cs);

   RRETURN(hr);

}


HRESULT
CObjNameCache::
InvalidateStaleEntries()
{

    DWORD i=0;
    SYSTEMTIME stCurrentTime;
    BOOL fCacheHit;

    GetSystemTime(&stCurrentTime);

    for ( i=0; i< _dwMaxCacheSize; i++){

        fCacheHit = _ClassEntries[i].fCacheHit;

        if(_ClassEntries[i].bInUse &&
           TimeDifference(stCurrentTime, _ClassEntries[i].st)
           > AGE_LIMIT_VALID_ENTRIES  && fCacheHit == CACHE_HIT) {

            _ClassEntries[i].bInUse = FALSE;
            FreeADsStr(_ClassEntries[i].pszElementName);
            _ClassEntries[i].pszElementName = NULL;

            if(_ClassEntries[i].dwElementType == DOMAIN_ENTRY_TYPE){
                FreeADsStr(_ClassEntries[i].u.pszPDCName);
                _ClassEntries[i].u.pszPDCName = NULL;


            } else if (_ClassEntries[i].dwElementType == COMPUTER_ENTRY_TYPE){
                FreeADsStr(_ClassEntries[i].u.pszDomainName);
                _ClassEntries[i].u.pszPDCName = NULL;

            }
        }else if(_ClassEntries[i].bInUse &&
                 TimeDifference(stCurrentTime, _ClassEntries[i].st)
                 > AGE_LIMIT_INVALID_ENTRIES  && fCacheHit == CACHE_MISS) {

            _ClassEntries[i].bInUse = FALSE;
        }

    }

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CObjNameCache::CObjNameCache()
{
    _dwMaxCacheSize = 10;
    memset(_ClassEntries, 0, sizeof(CLASSENTRY)* MAX_ENTRIES);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CObjNameCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CObjNameCache::
~CObjNameCache()
{
    DWORD i= 0;
    for (i=0; i< MAX_ENTRIES; i++){
        if(_ClassEntries[i].pszElementName){
            FreeADsStr(_ClassEntries[i].pszElementName);
        }

        //
        // All members of the union are strings so it is not
        // necessary to check for each of the members.
        //
        if(_ClassEntries[i].u.pszPDCName){
            FreeADsStr(_ClassEntries[i].u.pszPDCName);
        }
    }

    DeleteCriticalSection(&_cs);

}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CObjNameCache::
CreateClassCache(
    CObjNameCache FAR *FAR * ppClassCache
    )
{
    CObjNameCache FAR * pClassCache = NULL;

    pClassCache = new CObjNameCache();

    if (!pClassCache) {
        RRETURN(E_FAIL);
    }


    InitializeCriticalSection(&(pClassCache->_cs));

    *ppClassCache = pClassCache;

    RRETURN(S_OK);
}


DWORD
CObjNameCache::
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    // DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));

    pi = &(_ClassEntries[i].st);
    pj = &(_ClassEntries[j].st);

    if (pi->wYear < pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


HRESULT
WinNTGetCachedDCName(
    LPWSTR pszDomainName,
    LPWSTR pszPDCName,
    DWORD  dwFlags
    )
{
    WCHAR szSAMName[MAX_PATH];

    // In this case credentials do not help because we do not have
    // any server/domain to connect to. This is because the param
    // pszDomainName is not a domain name for certain.

    CWinNTCredentials nullCredentials;

    // We do want to copy the flags parameter as that will tell
    // us if we need to connect to PDC or not

    nullCredentials.SetFlags(dwFlags);

    RRETURN(WinNTGetCachedObject(pszDomainName,
                                 DOMAIN_ENTRY_TYPE,
                                 pszPDCName,
                                 szSAMName,
                                 dwFlags,
                                 nullCredentials
                                 ));
}



HRESULT
WinNTGetCachedComputerName(
    LPWSTR pszComputerName,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )
{

    RRETURN(WinNTGetCachedObject(pszComputerName,
                                 COMPUTER_ENTRY_TYPE,
                                 pszName,
                                 pszSAMName,
                                 Credentials.GetFlags(), // doesnt matter
                                 Credentials
                                 ));

}




HRESULT
WinNTGetCachedObject(
    LPWSTR pszElementName,
    DWORD dwElementType,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    DWORD dwFlags,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus = 0;
    BOOL fCacheHit;
    DWORD dwEntryType;
    LPWKSTA_INFO_100 lpWI = NULL;
    DWORD dwObjectsReturned;
    DWORD dwObjectsTotal;
    DWORD dwResumeHandle;
    // Freed using NetAPI
    LPWSTR pszServerName = NULL;
    // Freed using FreeADsStr
    LPWSTR pszADsStrServerName = NULL;
    BOOL fRefAdded = FALSE;
    DWORD dwDomainEntryType = DOMAIN_ENTRY_TYPE;
    // This will be the case most often
    DWORD dwUserFlags = Credentials.GetFlags();
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomainInfo = NULL;

    hr = pgPDCNameCache->getentry(
                    pszElementName,
                    &fCacheHit,
                    &dwEntryType,
                    pszName
                    );

    if (SUCCEEDED(hr)) {
        //
        // we found the entry. Now need to verify that it indeed
        // is an object of type desired
        //

        // Note that dwElement type will never be DOMAIN_ENTRY_TYPE_RO
        if(fCacheHit) {
            if (dwEntryType == dwElementType
                || ((dwElementType == DOMAIN_ENTRY_TYPE)
                    && (dwEntryType == DOMAIN_ENTRY_TYPE_RO)
                    && (dwUserFlags & ADS_READONLY_SERVER))
                ) {

                //
                // If the user now needs a writeable connection
                // should we fail or should we actually pretend
                // that the object is not there in the cache.
                //

                hr = S_OK;
                goto error;

            }

        } else if (!fCacheHit && (dwElementType == WORKGROUP_ENTRY_TYPE)) {
            //
            // looks like we either found a cache miss
            // Return  ok
            //
            hr = S_OK;
            goto error;

        } else {

            hr = E_FAIL;
            goto error;

        }

    }
    switch(dwElementType){

    case DOMAIN_ENTRY_TYPE:

            //
            // A read only server is ok, need to also set the
            // domain entry type accordingly
            //
        if (dwFlags & ADS_READONLY_SERVER) {
            dwDomainEntryType = DOMAIN_ENTRY_TYPE_RO;
        }

        //
        // Call the all encompassing Wrapper.
        //
        hr = DsGetDcNameNTWrapper(
                 pszElementName,
                 &pszADsStrServerName,
                 dwFlags
                 );

        BAIL_ON_FAILURE(hr);

        hr = pgPDCNameCache->addentry(
                pszElementName,
                TRUE,
                dwDomainEntryType,
                pszADsStrServerName
                );

        BAIL_ON_FAILURE(hr);
        //
        // in addition we can also add a computer entry for the PDC
        //

        hr = pgPDCNameCache->addentry(
                pszADsStrServerName+2,  // to get rid of the leading backslashes
                TRUE,
                COMPUTER_ENTRY_TYPE,
                pszElementName
                );

        BAIL_ON_FAILURE(hr);

        wcscpy(pszName, pszADsStrServerName);

        break;

    case COMPUTER_ENTRY_TYPE:

        // Ref the computer, note that RefServer will not
        // do anything if the credentials are null. We are also
        // not worried about errors as we want to use default
        // credentials in that case.

        hr = Credentials.RefServer(pszElementName);

        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = NetWkstaGetInfo(
                        pszElementName,
                        100,
                        (LPBYTE*) &lpWI
                        );

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        //
        // No NetpNameCompare for Win9x
        //
        if (lpWI->wki100_computername
            && (_wcsicmp(pszElementName, lpWI->wki100_computername) == 0)
            )
#else
        if (lpWI->wki100_computername
            && ( NetpNameCompare(
                     NULL,
                     pszElementName,
                     lpWI->wki100_computername,
                     NAMETYPE_COMPUTER,
                     0
                     )
                 == 0 )
            )
#endif
         {


            // Want to add the correct capitalized name
            // Not what the user gave
            hr = pgPDCNameCache->addentry(
                     lpWI->wki100_computername,
                     TRUE,
                     COMPUTER_ENTRY_TYPE,
                     lpWI->wki100_langroup
                     );

            wcscpy(pszSAMName, lpWI->wki100_computername);


         } 
         else {

            //
            // user actually passes in ipaddress as the computer name
            //
            if(IsAddressNumeric(pszElementName)) {
            	hr = pgPDCNameCache->addentry(
                         pszElementName,
                         TRUE,
                         COMPUTER_ENTRY_TYPE,
                         lpWI->wki100_langroup
                         );

                wcscpy(pszSAMName, L"");
            }
            //
            // user may pass in the dns name of the computer
            //
            else {
            	hr = HRESULT_FROM_WIN32(DsRoleGetPrimaryDomainInformation(
                                             pszElementName,                      
                                             DsRolePrimaryDomainInfoBasic,   // InfoLevel
                                             (PBYTE*)&pdomainInfo            // pBuffer
                                             ));
            	if(SUCCEEDED(hr)) {
            		if(((pdomainInfo->DomainNameDns) && _wcsicmp(pszElementName, pdomainInfo->DomainNameDns) == 0)
            			               ||
            			               
            	      ((pdomainInfo->DomainNameFlat) && NetpNameCompare(
                                       NULL,
                                       pszElementName,
                                       pdomainInfo->DomainNameFlat,
                                       NAMETYPE_COMPUTER,
                                       0
                                       )
                                       == 0) )            		             
            		 
            		{
            			BAIL_ON_FAILURE(hr=HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));
            		}
            		else {
            			hr = pgPDCNameCache->addentry(
                                 pszElementName,
                                 TRUE,
                                 COMPUTER_ENTRY_TYPE,
                                 lpWI->wki100_langroup
                                 );

                        wcscpy(pszSAMName, L"");
            		}       			
            			
               	} 
            	else {          		           
           	
                    BAIL_ON_FAILURE(hr=HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));
            	}
        
            }
        }    
        
        wcscpy(pszName, lpWI->wki100_langroup);
        break;


    default:
        hr = E_FAIL;
        break;
    }

error:

	if (fRefAdded) {
        Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

            
    if(lpWI){
        NetApiBufferFree(lpWI);
    }

    if(pszServerName){
        NetApiBufferFree(pszServerName);
    }

    if (pszADsStrServerName) {
        FreeADsStr(pszADsStrServerName);
    }

    if ( pdomainInfo )
	{
		DsRoleFreeMemory(pdomainInfo);
	}

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//    This function is called by Heuristic GetObject to identify what
//    kind of object we are dealing with. Here we try to get a cached
//    entry if it is a hit/miss. If it fails, then we try each kind
//    of object in turn. (Domain/Computer/Workgroup). Once we do this,
//    we cache this information internally
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
WinNTGetCachedName(
    LPWSTR pszElementName,
    PDWORD  pdwElementType,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    BOOL fCacheHit;
    DWORD dwEntryType;
    WCHAR szSAMName[MAX_ADS_PATH];
    BOOL fRefAdded = FALSE;
    DWORD dwUserFlags = Credentials.GetFlags();

    szSAMName[0] = L'\0';

    if (!pszElementName || !*pszElementName) {
        RRETURN(E_FAIL);
    }

    hr = pgPDCNameCache->getentry(
                    pszElementName,
                    &fCacheHit,
                    &dwEntryType,
                    pszName
                    );

    if (SUCCEEDED(hr)) {
        //
        // we found the entry.
        //

        if (!fCacheHit){
            //
            // cache miss saved as a workgroup
            //
            *pdwElementType = WORKGROUP_ENTRY_TYPE;
            goto error;

        } else {
            if(dwEntryType == DOMAIN_ENTRY_TYPE_RO) { 
                if(dwUserFlags & ADS_READONLY_SERVER) {
                    // HeuristicGetObj doesn't recognize DOMAIN_ENTRY_TYPE_RO
                    *pdwElementType = DOMAIN_ENTRY_TYPE;
                    goto error;
                }
            }
            else {
                *pdwElementType = dwEntryType;
                goto error;
            }
        }

    } 

    {

        // at this point, we can try and ref the domain as
        // we are looking to bind to the domain

        hr = Credentials.RefDomain(pszElementName);
        // note that even if this fails we want to continue
        // as there is the chance that the current users
        // credentials are good enough for the operation

        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        hr = WinNTGetCachedObject(
                 pszElementName,
                 DOMAIN_ENTRY_TYPE,
                 pszName,
                 szSAMName,
                 Credentials.GetFlags(),
                 Credentials
                 );

        if (fRefAdded) {
            Credentials.DeRefDomain();
            // we cannot really do anything useful with HR
            fRefAdded = FALSE;
        }

        if (SUCCEEDED(hr)){
            *pdwElementType = DOMAIN_ENTRY_TYPE;
            wcscpy(pszSAMName, szSAMName);
            RRETURN(hr);
        }

        hr = WinNTGetCachedObject(
                 pszElementName,
                 COMPUTER_ENTRY_TYPE,
                 pszName,
                 szSAMName,
                 Credentials.GetFlags(),
                 Credentials
                 );


        if (SUCCEEDED(hr)){
            *pdwElementType = COMPUTER_ENTRY_TYPE;
            wcscpy(pszSAMName, szSAMName);
            RRETURN(hr);
        }


        //
        // if you are here, it means that you have to cache a miss as a
        // workgroup.
        // Note that pszSAMName rather than pszElementName is added
        // if it is valid

        // AjayR - to handle the no workstation case,
        // We should not add anything if the error was NOWksta service

        if (hr != HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

            if (szSAMName[0] != L'\0') {

                hr = pgPDCNameCache->addentry(
                         szSAMName,
                         FALSE,
                         WORKGROUP_ENTRY_TYPE,
                         TEXT("")
                         );

            } else {

                hr = pgPDCNameCache->addentry(
                         pszElementName,
                         FALSE,
                         WORKGROUP_ENTRY_TYPE,
                         TEXT("")
                         );

            }
        }  // No Wksta started


        *pdwElementType = WORKGROUP_ENTRY_TYPE;
        wcscpy(pszName, TEXT(""));
        goto error;
    }


error:
    RRETURN(hr);
}

LONG
TimeDifference(
    SYSTEMTIME st1,
    SYSTEMTIME st2
    )

{
   //
   // This function gives the difference between st1 and st2 (st1-st2)in secs.
   // This will be used by our internal cache object so as to find out if
   // a certain entry in the cache is too old.
   // Assumption: st1 is later than st2.


    DWORD dwTime1;
    DWORD dwTime2;
    DWORD dwMonth1;
    DWORD dwMonth2;
    LONG lRetval;
    //
    // Ignore milliseconds because it is immaterial for our purposes
    //


    dwTime1= st1.wSecond + 60 *
        (st1.wMinute + 60* (st1.wHour + 24 * (st1.wDay)));


    dwTime2= st2.wSecond + 60 *
        (st2.wMinute + 60* (st2.wHour + 24 * (st2.wDay)));


    if (dwTime1 == dwTime2) {
        return(0);
    }

    if (dwTime1 > dwTime2 && (st1.wMonth == st2.wMonth) &&
        st1.wYear == st2.wYear) {
        lRetval = (LONG)(dwTime1-dwTime2);
        goto cleanup;
    }


    dwMonth1 = 12*st1.wYear+ st1.wMonth;
    dwMonth2 = 12*st2.wYear+ st2.wMonth;

    if (dwMonth1 < dwMonth2) {
        //
        // looks like we got a bogus value. return -1
        //
        lRetval = -1;
        goto cleanup;
    }

    //
    // if there is a month difference of more than 1 then we return
    // a large positive number (0xFFFFFFF)
    //

    if (dwMonth1 > dwMonth2+1) {
        lRetval = 0xFFFFFFF;
        goto cleanup;
    }


    //
    //  we crossed a month boundary
    //

    dwTime1= st1.wSecond + 60 *
        (st1.wMinute + 60* (st1.wHour));


    dwTime2= st2.wSecond + 60 *
        (st2.wMinute);

    lRetval = ( dwTime2- dwTime1 + 60*60*24);
    goto cleanup;


cleanup:
    return(lRetval);
}

BOOL
IsAddressNumeric(
    LPWSTR HostName
)
{
    BOOLEAN rc = FALSE;

    //
    //  to check to see if it's a TCP address, we check for it to only
    //  contain only numerals and periods.
    //

    while (((*HostName >= L'0') && (*HostName <= L'9')) ||
            (*HostName == L'.')) {
        HostName++;
    }

    //
    //  if we hit the end of the hostname, then it's an address.
    //

    if (*HostName == L'\0' || *HostName == L':') {

        rc = TRUE;
    }
    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        LPWSTR Parent,
        LPWSTR Name,
        LPWSTR ClassName,
        LPWSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);



    if (  ( _tcsicmp( ClassName, PRINTJOB_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, SESSION_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, RESOURCE_CLASS_NAME ) == 0 )
       )
    {
        //
        // This three classes are not really DS objects so they don't
        // really have a parent. Hence, we set the parent string to empty
        // string.
        //

        _ADsPath = AllocADsStr(TEXT(""));
        hr = (_ADsPath ? S_OK: E_OUTOFMEMORY);

        BAIL_ON_FAILURE(hr);

        _Parent = AllocADsStr(TEXT(""));
        hr = (_Parent ? S_OK: E_OUTOFMEMORY);

        _dwNumComponents = 0;

    }
    else
    {
        hr = BuildADsPath(
                 Parent,
                 Name,
                 &_ADsPath
                 );

        BAIL_ON_FAILURE(hr);

        // get the number of components in the ADsPath
        hr = GetNumComponents();
        BAIL_ON_FAILURE(hr);

        _Parent = AllocADsStr(Parent);
        hr = (_Parent ? S_OK: E_OUTOFMEMORY);

    }

    BAIL_ON_FAILURE(hr);

    _Name = AllocADsStr(Name);
    hr = (_Name ? S_OK: E_OUTOFMEMORY);

    BAIL_ON_FAILURE(hr);

    _ADsClass = AllocADsStr(ClassName);
    hr = (_ADsClass ? S_OK: E_OUTOFMEMORY);

    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            Parent,
            Name,
            Schema,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0),
                        _pUnkOuter(NULL),
                        _pObjectInfo(NULL),
                        _pDispatch(NULL)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        FreeADsStr(_Name);
    }

    if (_ADsPath) {
        FreeADsStr(_ADsPath);
    }

    if (_Parent) {
        FreeADsStr(_Parent);
    }

    if (_ADsClass) {
        FreeADsStr(_ADsClass);
    }

    if (_Schema) {
        FreeADsStr(_Schema);
    }

    if (_ADsGuid) {
        FreeADsStr(_ADsGuid);
    }

    if(_pObjectInfo != NULL) {
        FreeObjectInfo(&_ObjectInfo, TRUE);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CCoreADsObject::ImplicitGetInfo(void)
{
    RRETURN(E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   InitUmiObject
//
// Synopsis:   Initializes UMI object.
//
// Arguments:
//
// Credentials  Credentials stored in the underlying WinNT object
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of WinNT object
// pExtMgr      Pointer to extension manager object on WinNT object
// riid         Interface requested
// ppvObj       Returns pointer to interface 
// pClassInfo   Pointer to class information if this object is a class object.
//              NULL otherwise.
//
// Returns:     S_OK if a UMI object is created and the interface is obtained. 
//              Error code otherwise 
//
// Modifies:    *ppvObj to return the UMI interface requested. 
//
//----------------------------------------------------------------------------
HRESULT CCoreADsObject::InitUmiObject(
    CWinNTCredentials& Credentials,
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    CPropertyCache * pPropertyCache,
    IUnknown *pUnkInner,
    CADsExtMgr *pExtMgr,
    REFIID riid,
    LPVOID *ppvObj,
    CLASSINFO *pClassInfo
    )
{
    CUmiObject *pUmiObject = NULL;
    HRESULT hr = S_OK;

    // riid is a UMI interface
    if(NULL == ppvObj)
        RRETURN(E_POINTER);

    pUmiObject = new CUmiObject();
    if(NULL == pUmiObject)
        RRETURN(E_OUTOFMEMORY);

    hr = pUmiObject->FInit(
            Credentials,
            pSchema, 
            dwSchemaSize,
            pPropertyCache,
            pUnkInner,
            pExtMgr,
            this,
            pClassInfo
            );
    BAIL_ON_FAILURE(hr);
 
    //
    // Bump up reference count of pUnkInner. On any error after this point,
    // the UMI object's destructor will call Release() on pUnkInner and we
    // don't want this to delete the WinNT object.
    //
    pUnkInner->AddRef();

    hr = pUmiObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pUmiObject->Release();

    // Restore ref count of inner unknown
    pUnkInner->Release();

    //
    // reset ADS_AUTH_RESERVED flag in credentials. This is so that the
    // underlying WinNT object may be returned through IUmiCustomInterface to
    // the client. Doing this will ensure that the WinNT object should behave  
    // like a ADSI object, not a UMI object.
    //
    Credentials.ResetUmiFlag();

    RRETURN(S_OK);

error:

    if(pUmiObject != NULL)
        delete pUmiObject;

    RRETURN(hr);
}
                           
//----------------------------------------------------------------------------
// Function:   GetNumComponents
//
// Synopsis:   This function returns the number of components in the ADsPath.
//             A component is enclosed by '/' in an ADsPath.
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
HRESULT CCoreADsObject::GetNumComponents(void)
{
    CLexer      Lexer(_ADsPath);
    HRESULT     hr = S_OK;

    _pObjectInfo = &_ObjectInfo;
    memset(_pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, _pObjectInfo);
    if(FAILED(hr)) {
        _pObjectInfo = NULL; // so we don't attempt to free object info later
        goto error;
    }

    _dwNumComponents = _pObjectInfo->NumComponents;

    RRETURN(S_OK);

error:

    if(_pObjectInfo != NULL)
        FreeObjectInfo(&_ObjectInfo, TRUE);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cprinter.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

//
// Class CWinNTPrintQueue Methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTPrintQueue)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTPrintQueue)
DEFINE_IADs_TempImplementation(CWinNTPrintQueue);
DEFINE_IADs_PutGetImplementation(CWinNTPrintQueue,PrintQueueClass,gdwPrinterTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTPrintQueue, PrintQueueClass,gdwPrinterTableSize)


CWinNTPrintQueue::CWinNTPrintQueue()
{
    _pszPrinterName = NULL;
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTPrintQueue);
    return;

}

CWinNTPrintQueue::~CWinNTPrintQueue()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }
    return;
}

HRESULT
CWinNTPrintQueue:: CreatePrintQueue(
    LPTSTR pszADsParent,
    DWORD  dwParentId,
    LPTSTR pszDomainName,
    LPTSTR pszServerName,
    LPTSTR pszPrinterName,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    LPVOID * ppvoid
    )

{

    CWinNTPrintQueue       *pPrintQueue =  NULL;
    HRESULT hr;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(pszServerName,
                                  pszPrinterName,
                                  &pPrintQueue
                                  );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrintQueue->_pDispMgr);


    //
    // initialize the core object
    //

    hr = pPrintQueue->InitializeCoreObject(pszADsParent,
                                           pszPrinterName,
                                           PRINTER_CLASS_NAME,
                                           PRINTER_SCHEMA_NAME,
                                           CLSID_WinNTPrintQueue,
                                           dwObjectState);
    BAIL_ON_FAILURE(hr);


    pPrintQueue->_Credentials = Credentials;
    hr = pPrintQueue->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                PRINTER_CLASS_NAME,
                (IADsPrintQueue *) pPrintQueue,
                pPrintQueue->_pDispMgr,
                Credentials,
                &pPrintQueue->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrintQueue->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pPrintQueue->_dwNumComponents) {
            pPrintQueue->_CompClasses[0] = L"Domain";
            pPrintQueue->_CompClasses[1] = L"Computer";
            pPrintQueue->_CompClasses[2] = L"PrintQueue";
        }
        else if(2 == pPrintQueue->_dwNumComponents) {
        // no workstation services
            pPrintQueue->_CompClasses[0] = L"Computer";
            pPrintQueue->_CompClasses[1] = L"PrintQueue";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pPrintQueue->InitUmiObject(
                pPrintQueue->_Credentials,
                PrintQueueClass,
                gdwPrinterTableSize,
                pPrintQueue->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pPrintQueue,
                pPrintQueue->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pPrintQueue->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pPrintQueue->Release();

    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

/* IUnknown methods for printer object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTPrintQueue::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintQueue::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintQueue::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
      *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to set the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::SetInfo(THIS)
{

    BOOL fStatus = FALSE;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    BOOL fPrinterAdded = FALSE;
    POBJECTINFO pObjectInfo = NULL;

#if (!defined(BUILD_FOR_NT40))

    LPPRINTER_INFO_7 lpPrinterInfo7 = NULL;
#endif

    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddPrinter();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);
        fPrinterAdded = TRUE;
    }

    //
    // first do a getinfo to get properties that werent changed.
    //

    hr = GetPrinterInfo(&lpPrinterInfo2, _pszPrinterName);

    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(lpPrinterInfo2);

    BAIL_IF_ERROR(hr);


#if (!defined(BUILD_FOR_NT40))
    hr = GetPrinterInfo7(&lpPrinterInfo7, _pszPrinterName);

    if (SUCCEEDED(hr)) {
        MarshallAndSet(lpPrinterInfo7);
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL))
    // Level 7 is not supported on NT4. So, ignore this error.
        hr = S_OK;

#endif

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:


    //
    // If we added a printer and hr is set, we should delete it now
    // as the SetInfo failed in subsequent operations.
    //
    if (FAILED(hr) && fPrinterAdded) {

        //
        // Build ObjectInfo first
        //
        BuildObjectInfo(
             _ADsPath,
             &pObjectInfo
             );
        //
        // Call delete printer only if the pObjectInfo is valid
        // We cannot do anything in the other case.
        //
        if (pObjectInfo) {
            WinNTDeletePrinter(pObjectInfo);
            FreeObjectInfo(pObjectInfo);
        }
    }

    if(lpPrinterInfo2){
        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }

#if (!defined(BUILD_FOR_NT40))

    if (lpPrinterInfo7) {
       FreeADsMem((LPBYTE)lpPrinterInfo7);
    }
#endif

    RRETURN_EXP_IF_ERR(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   GetInfo(function overloaded: part of CoreADsObject as well
//              as IADs).This function here is part of IADs
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to get information from the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::GetInfo(THIS)
{

    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    hr = GetInfo(7,TRUE);

#endif

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTPrintQueue::ImplicitGetInfo(THIS)
{

    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    hr = GetInfo(7,FALSE);

#endif

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo (overloaded)
//
//  Synopsis:   Calls the IADs GetInfo, because the printer object has just
//              one info level on which to retrieve info from.
//
//  Arguments:  dwApiLevel and fExplicit (Both Ignored)
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-05-96 RamV Created
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    LPPRINTER_INFO_2 lpPrinterInfo2= NULL;
    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    LPPRINTER_INFO_7 lpPrinterInfo7 = NULL;
    HRESULT hr7 = S_OK;
#endif

    hr = GetPrinterInfo(&lpPrinterInfo2, _pszPrinterName);
    BAIL_IF_ERROR(hr);

    hr = UnMarshall(lpPrinterInfo2,
                    fExplicit);

#if (!defined(BUILD_FOR_NT40))

    hr7 =  GetPrinterInfo7(&lpPrinterInfo7, _pszPrinterName);

    if (SUCCEEDED(hr7)) {

       hr7 = UnMarshall7(lpPrinterInfo7, fExplicit);
    }
#endif

cleanup:
    if(lpPrinterInfo2)
        FreeADsMem((LPBYTE)lpPrinterInfo2);

#if (!defined(BUILD_FOR_NT40))

     if (lpPrinterInfo7) {
        FreeADsMem((LPBYTE)lpPrinterInfo7);
     }

#endif

    RRETURN_EXP_IF_ERR(hr);

}

//
// helper function  WinNTAddPrinter
//

HRESULT
CWinNTPrintQueue::WinNTAddPrinter(void)
{
    HRESULT hr = S_OK;
    TCHAR szUncServerName[MAX_PATH];
    TCHAR szServerName[MAX_PATH];
    PRINTER_INFO_2  PrinterInfo2;
    HANDLE  hPrinter = NULL;
    LPTSTR  pszPrintDevices = NULL;
    LPTSTR  pszModel = NULL;
    LPTSTR  pszDatatype = NULL;
    LPTSTR  pszPrintProcessor = NULL;
    LPTSTR  pszPrinterName =  NULL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    memset(&PrinterInfo2, 0, sizeof(PRINTER_INFO_2));

    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintDevices"),
                    &pszPrintDevices
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPortName = pszPrintDevices;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Model"),
                    &pszModel
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pDriverName = pszModel;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrinterName"),
                    &pszPrinterName
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPrinterName = pszPrinterName;
    }
    else {

        PrinterInfo2.pPrinterName = (LPTSTR) _Name;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintProcessor"),
                    &pszPrintProcessor
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPrintProcessor = pszPrintProcessor;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Datatype"),
                    &pszDatatype
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pDatatype = pszDatatype;
    }


    hr = GetServerFromPath(_ADsPath, szServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(szServerName, szUncServerName);
    BAIL_IF_ERROR(hr);


    PrinterInfo2.pServerName = szServerName;
    PrinterInfo2.pShareName =  (LPTSTR)_Name;
    PrinterInfo2.pComment = NULL;
    PrinterInfo2.pLocation = NULL;
    PrinterInfo2.pDevMode = NULL;
    PrinterInfo2.pSepFile = NULL;
    PrinterInfo2.pParameters = NULL;
    PrinterInfo2.pSecurityDescriptor = NULL;
    PrinterInfo2.Attributes = PRINTER_ATTRIBUTE_SHARED;
    PrinterInfo2.Priority = 0;
    PrinterInfo2.DefaultPriority = 0;
    PrinterInfo2.StartTime = 0;
    PrinterInfo2.UntilTime = 0;
    PrinterInfo2.Status = 0;
    PrinterInfo2.cJobs= 0;
    PrinterInfo2.AveragePPM = 0;

    //
    // set properties on printer
    //

    hPrinter = AddPrinter(szUncServerName,
                          2,
                          (LPBYTE)&PrinterInfo2);

    if(hPrinter == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

 cleanup:
    if(pszPrintDevices){
        FreeADsStr(pszPrintDevices);
    }

    if(pszModel){
        FreeADsStr(pszModel);
    }

    if(pszPrintProcessor){
        FreeADsStr(pszPrintProcessor);
    }

    if(pszDatatype){
        FreeADsStr(pszDatatype);
    }


    RRETURN(hr);
}



HRESULT
CWinNTPrintQueue::AllocatePrintQueueObject(
    LPTSTR pszServerName,
    LPTSTR pszPrinterName,
    CWinNTPrintQueue ** ppPrintQueue
    )
{
    CWinNTPrintQueue FAR * pPrintQueue = NULL;
    HRESULT hr = S_OK;
    TCHAR   szUncServerName[MAX_PATH];
    TCHAR   szUncPrinterName [MAX_PATH];
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;

    pPrintQueue = new CWinNTPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Build the UNC form of printer name from the supplied information
    //

    if( (wcslen(pszServerName) + 3) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    MakeUncName(pszServerName,
                szUncServerName);

    if( (wcslen(szUncServerName) + wcslen(pszPrinterName) + 2) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, TEXT("\\"));
    wcscat(szUncPrinterName, pszPrinterName);


    pPrintQueue->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pPrintQueue->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPrintQueue,
                           (IADsPrintQueue *)pPrintQueue,
                           DISPID_REGULAR);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPrintQueueOperations,
                           (IADsPrintQueueOperations *)pPrintQueue,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pPrintQueue,
                           DISPID_VALUE);

    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             PrintQueueClass,
             gdwPrinterTableSize,
             (CCoreADsObject *)pPrintQueue,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pPrintQueue->_pPropertyCache = pPropertyCache;
    pPrintQueue->_pDispMgr = pDispMgr;
    *ppPrintQueue = pPrintQueue;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pPrintQueue;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cpgi.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

--*/

#include "winnt.hxx"
#pragma hdrstop

//
//  CWinNTPrintQueue
//

STDMETHODIMP
CWinNTPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CWinNTPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CWinNTPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CWinNTPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CWinNTPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CWinNTPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}


STDMETHODIMP CWinNTPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CWinNTPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}


STDMETHODIMP
CWinNTPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CWinNTPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CWinNTPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CWinNTPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CWinNTPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CWinNTPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = ADsAllocString(_pszPrinterName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    //
    // Cannot change this in Windows NT!
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CWinNTPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, PrintDevices);
}

STDMETHODIMP
CWinNTPrintQueue::put_PrintDevices(THIS_ VARIANT vPrintDevices)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, PrintDevices);
}

STDMETHODIMP
CWinNTPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

STDMETHODIMP
CWinNTPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

//
// Class CWinNTPrintQueue
//

/* IADsFSPrintQueueOperation methods */

STDMETHODIMP
CWinNTPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{
    //
    // The job collection object is created and it is passed the printer
    // name. It uses this to create a printer object
    //

    HRESULT hr = S_OK;
    CWinNTPrintJobsCollection * pJobsCollection = NULL;


    hr = CWinNTPrintJobsCollection::Create(_ADsPath,
                                           _Credentials,
                                           &pJobsCollection);

    BAIL_IF_ERROR(hr);

    hr = pJobsCollection->QueryInterface(IID_IADsCollection,
                                         (void **) ppCollection);

    BAIL_IF_ERROR(hr);

    pJobsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pJobsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}




//+------------------------------------------------------------------------
//
//  Function: CWinNTPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::Pause(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PAUSE);
    if (!fStatus) {
        goto error;


    }


    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::Resume(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_RESUME);
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::Purge(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    PRINTER_INFO_2 PrinterInfo2;
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PURGE);
    if (!fStatus) {
        goto error;

    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTPrintQueue::get_Status(THIS_ long FAR* retval)
{
    HRESULT hr =S_OK;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    DWORD dwStatus;
    BOOL found;

    //
    // We return the WinNT Status Code as the ADS status code
    //

    hr = GetPrinterInfo(
                &lpPrinterInfo2,
                _pszPrinterName
                );

    BAIL_IF_ERROR(hr);

    *retval = lpPrinterInfo2->Status;

cleanup:
    if(lpPrinterInfo2){
        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CWinNTProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTProvider

CWinNTProvider::CWinNTProvider()
{

}

HRESULT
CWinNTProvider::Create(
    CWinNTProvider FAR * FAR * ppProvider
    )
{
    CWinNTProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CWinNTProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN_EXP_IF_ERR(hr);
}

CWinNTProvider::~CWinNTProvider( )
{
    ENLIST_TRACKING(CWinNTProvider);
}

STDMETHODIMP
CWinNTProvider::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    //
    // In try block because the Credentials do an InitCritSect
    // down the line on a static variable. This call can fail
    // so we need to catch it.
    //

    if (!pchEaten) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    __try {

        CWinNTCredentials Credentials;

        *pchEaten = 0;
        hr = GetObject(szDisplayName, (LPVOID *)&pUnknown, Credentials);
        BAIL_ON_FAILURE(hr)

        hr = CreatePointerMoniker(pUnknown, ppmk);
        BAIL_ON_FAILURE(hr);

        *pchEaten += wcslen(szDisplayName);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        RRETURN(E_FAIL);
    }

error :
    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CWinNTProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTProviderCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr;
    CWinNTProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CWinNTProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NT
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1996   RamV   Created.
//                cloned off NT property cache code
//
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(NTMarshall);
DECLARE_DEBUG(NTMarshall);
#define NTMarshallDebugOut(x) NTMarshallInlineDebugOut x
#endif



void
ADsECodesToDispECodes(
    HRESULT *pHr
    );


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

    //
    //  extend the property cache by adding a new property entry
    //

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    if (pNewProperty->szPropertyName) {
       FreeADsStr(pNewProperty->szPropertyName);
       pNewProperty->szPropertyName = NULL;
    }

    pNewProperty->szPropertyName = tempString;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);


    //
    // add to dynamic dispatch table now ???
    //  - don't check schema here, is it more efficient at all? inconsistency
    //    ???
    //
    /*
    hr = DispatchAddProperty(
            szPropertyName
            );
    BAIL_ON_FAILURE(hr);
    */


    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}






//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    if (!fExplicit) {
        if (PROPERTY_FLAGS(pThisProperty) & CACHE_PROPERTY_MODIFIED) {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty)  &= ~PROPERTY_MODIFIED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject,
    BOOL    *pfModified
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    // don't do implicit GetInfo if there is no ADSI object backing the
    // property cache. This will be true for UMI interafec properties.
    if ((hr == E_ADS_PROPERTY_NOT_FOUND) && (_pCoreADsObject != NULL)) {

        hr = GetPropertyInfoLevel(
                    szPropertyName,
                    _pSchemaClassProps,
                    _dwNumProperties,
                    &dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    dwInfoLevel,
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);




    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        if(pfModified != NULL) { // caller wants to know if prop. was modified
            if(PROPERTY_FLAGS(pThisProperty) & CACHE_PROPERTY_MODIFIED)
                *pfModified = TRUE;
            else
                *pfModified = FALSE;
        } 

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::marshallgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
marshallgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    //
    // If the data has not changed, then do not
    // return data from the cache
    //
    if (PROPERTY_FLAGS(pThisProperty) == 0) {
        hr = E_ADS_PROPERTY_NOT_MODIFIED;
        BAIL_ON_FAILURE(hr);
    }

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL   fMarkAsClean
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    if(FALSE == fMarkAsClean)
        PROPERTY_FLAGS(pThisProperty) |= CACHE_PROPERTY_MODIFIED;

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchemaClassProps(NULL),
    _dwMaxProperties(0),
    _dwCurrentIndex(0),
    _pProperties(NULL),
    _cb(0),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }


    //
    // Free Dynamic Dispid Table
    //

    if (_pDispProperties) {

        for ( DWORD i = 0; i < _dwDispMaxProperties; i++ ) {

            pThisDispProperty = _pDispProperties + i;

            if (pThisDispProperty->szPropertyName) {
               FreeADsStr(pThisDispProperty->szPropertyName);
               pThisDispProperty->szPropertyName = NULL;
            }

        }

        FreeADsMem(_pDispProperties);
    }


}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pSchemaClassProps = pSchemaClassProps;
    pPropertyCache->_dwNumProperties = dwNumProperties;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNTOBJECT pNTObject = NULL;

    hr = UnMarshallNTToNTSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNTObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNTObject) {
        NTTypeFreeNTObjects(
                pNTObject,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ValidatePropertyinSchemaClass(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {
            *pdwSyntaxId = pThisSchProperty->dwSyntaxId;
            RRETURN (S_OK);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}



HRESULT
ValidateIfWriteableProperty(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             RRETURN((pThisSchProperty->dwFlags & PROPERTY_WRITEABLE)
                        ? S_OK : E_ADS_SCHEMA_VIOLATION);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);

    // for winnt & nw312, return E_ADS_SCHEMA_VIOLATION if not ok even
    // if just try to write to cache only
}



HRESULT
GetPropertyInfoLevel(
    LPWSTR pszPropName,
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    PDWORD pdwInfoLevel
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             *pdwInfoLevel = pThisSchProperty->dwInfoLevel;
             RRETURN(S_OK);
        }
    }

    //
    // Returning E_ADS_PROPERTY_NOT_FOUND so that implicit
    // GetInfo fails gracefully
    //
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}




//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}
//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex)) {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
    }

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (_dwCurrentIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (dwIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if (newIndex>_dwMaxProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!_dwMaxProperties)      // if !_dwMaxProperties, pThisProperty=NULL, AV
        return NULL;            // in PROPERTY_NAME(pThisProperty)

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}


HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NTOBJECT(pThisProperty)) {
          NTTypeFreeNTObjects(
                  PROPERTY_NTOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NTOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NTOBJECT(pThisProperty)) {
       NTTypeFreeNTObjects(
               PROPERTY_NTOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NTOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;

    hr = DispatchLocateProperty(
            szPropertyName,
            pdwDispid
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varValue
    )
{
    HRESULT hr;

    hr = DispatchPutProperty(
            dwDispid,
            varValue
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarValue
    )
{
    HRESULT hr;

    hr = DispatchGetProperty(
            dwDispid,
            pvarValue
            );

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
// Dynamic Dispid Table
//

HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid
    )
{
    DWORD i = 0;
    PDISPPROPERTY pDispProp = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!pdwDispid || !szPropertyName)
        RRETURN(E_ADS_BAD_PARAMETER);

    for (i=0; i<_dwDispMaxProperties; i++) {

        pDispProp = _pDispProperties + i;

        if (!_wcsicmp(DISPATCH_NAME(pDispProp), szPropertyName)) {
            *pdwDispid=i;
            RRETURN(S_OK);
        }
    }

    *pdwDispid = (DWORD) -1;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

HRESULT
CPropertyCache::
DispatchAddProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid    /* optional */
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwDispid = (DWORD) -1;
    PDISPPROPERTY pNewDispProps = NULL;
    LPWSTR pszTempName = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!szPropertyName)
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = DispatchFindProperty(
            szPropertyName,
            &dwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        pszTempName = AllocADsStr(szPropertyName);
        if (!pszTempName)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // increase the size of Dynamic Dispid Table by 1 property
        //
        pNewDispProps = (PDISPPROPERTY) ReallocADsMem(
                                            _pDispProperties,
                                            _cbDisp,
                                            _cbDisp + sizeof(DISPPROPERTY)
                                            );
        if (!pNewDispProps)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // must succeeded at this pt. okay to change table & indexes
        //
        _pDispProperties = pNewDispProps;
        DISPATCH_NAME(_pDispProperties+_dwDispMaxProperties) = pszTempName;
        dwDispid = _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

        hr = S_OK;
    }

    //
    // return valid, or invalid (-1) in case of failure, dispid of
    // szProperty iff asked for
    //
    if (pdwDispid)
        *pdwDispid = dwDispid;

    RRETURN(hr);


error:

    if (pszTempName)
        FreeADsStr(pszTempName);

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchLocateProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;   // (dummy)

    //
    // - pdwDispid not optional here
    // - Use DISP_E_ERROR codes since this function directly called by
    //   the dispatch manager
    //
    if (!pdwDispid || !szPropertyName)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    //
    // return dispid of property if already in table;
    //
    hr = DispatchFindProperty(
            szPropertyName,
            pdwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will
        //        be allowed to be added to cache and will not be given the
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either.
        //
        hr = ValidatePropertyinSchemaClass(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropertyName,
                &dwSyntaxId
                );

        //
        // Add property that is in the schema but not in the cache to
        // the dynamic dispid table. That is, property which is in the
        // schema will always be handled by the cache/server thur ADSI but
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {

            hr = DispatchAddProperty(
                        szPropertyName,
                        pdwDispid
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr);

        }
    }

    RRETURN(hr);

error:

    //
    // translate E_ADS_ error codes to DISP_E if appropriate, see above
    //
    ADsECodesToDispECodes(&hr);

    *pdwDispid = (DWORD) DISPID_UNKNOWN;

    RRETURN(hr);
}


HRESULT
CPropertyCache::
DispatchGetProperty(
    DWORD dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = (DWORD) -1;
    DWORD dwNumValues = 0;
    PNTOBJECT pNtObjs = NULL;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!pvarVal)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!DISPATCH_INDEX_VALID(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = DISPATCH_PROPERTY_NAME(dwDispid);

    //
    // return value in cache for szPropName; retrieve value from server
    // if not already in cache; fail if none on sever
    //
    hr = getproperty(
            szPropName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObjs
            );
    BAIL_ON_FAILURE(hr);

    //
    // translate NT objects into variants
    //
    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                pNtObjs,
                pvarVal
                );

    } else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtObjs,
                dwNumValues,
                pvarVal
                );
    }
    BAIL_ON_FAILURE(hr);

error:

    if (pNtObjs) {

        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);

        V_VT(pvarVal) = VT_ERROR;
    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchPutProperty(
    DWORD dwDispid,
    VARIANT& varVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    VARIANT * pvProp = NULL;            // do not free
    DWORD dwNumValues = 0;
    VARIANT * pTempVarArray = NULL;     // to be freed
    DWORD dwSyntaxId = (DWORD) -1;
    LPNTOBJECT pNtObjs = NULL;
    DWORD dwIndex = (DWORD) -1;


    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!DISPATCH_INDEX_VALID(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    //
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = DISPATCH_PROPERTY_NAME(dwDispid);


    //
    // translate variant to NT Objects
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside. ??
    //
    pvProp = &varVal;

    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(pvProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    varVal,
                    &pTempVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if(NULL == pTempVarArray) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }        

        pvProp = pTempVarArray;

    }else {

        //
        // Single value NOT stored in array MUST BE ALLOWED since clients
        // would expect Put() to behave the same whether the dipatch
        // manager is invoked or not. (This funct'n has to be consitent
        // GenericPutPropertyManager(), but NOT GenericPutExProperty...)

        dwNumValues = 1;
    }

    //
    // Need the syntax of this property on the cache.
    //
    hr = ValidatePropertyinSchemaClass(
            _pSchemaClassProps,
            _dwNumProperties,
            szPropName,
            &dwSyntaxId
            );

    BAIL_ON_FAILURE(hr);

    //
    // check if this is a writeable property in schema
    //

    hr = ValidateIfWriteableProperty(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Variant Array to Nt Objects
    //
    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtObjs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // add the property to cache if not already in since DispatchAddProperty
    // does not addproperty
    //
    hr = findproperty(
                szPropName,
                &dwIndex
                );

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtObjs
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // update property value in cache
    //
    hr = putproperty(
                szPropName,
                dwSyntaxId,
                dwNumValues,
                pNtObjs
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNtObjs) {
        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (pTempVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pTempVarArray + i);
        }
        FreeADsMem(pTempVarArray);
    }


    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPropNames
//
// Synopsis:   Returns the names of all properties in the cache.
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names
//
//----------------------------------------------------------------------------
HRESULT CPropertyCache::GetPropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0;
    PPROPERTY           pNextProperty = NULL;

    ADsAssert(pProps != NULL);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    if(0 == _dwMaxProperties) {
    // no properties in cache
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          _dwMaxProperties * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, _dwMaxProperties * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < _dwMaxProperties; ulIndex++) {
        pNextProperty = _pProperties + ulIndex;

        pUmiProps[ulIndex].pszPropertyName =
            (LPWSTR) AllocADsStr(pNextProperty->szPropertyName);
        if(NULL == pUmiProps[ulIndex].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }

    pUmiPropVals->uCount = _dwMaxProperties;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals;

    RRETURN(UMI_S_NO_ERROR);   

error:

    if(pUmiProps != NULL) {
        for(ulIndex = 0; ulIndex < _dwMaxProperties; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   ClearModifiedFlag 
//
// Synopsis:   Clears the modified flag for all properties in the cache. This
//             is done after a successful SetInfo so that subsequent Get
//             operations return the correct state of the property. 
//
// Arguments:
//
// None
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
void
CPropertyCache::ClearModifiedFlags(void)
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (PROPERTY_NTOBJECT(pThisProperty)) 
            PROPERTY_FLAGS(pThisProperty) &= ~CACHE_PROPERTY_MODIFIED;
    }
}


//
// Move This function out of this file, out of adsnt in fact. LATER
// Moving it out may make the conversion more difficult since each
// provider return error codes in its own way. May be local is better.
//
void
ADsECodesToDispECodes(
    HRESULT *pHr
    )
{
    DWORD dwADsErr = *pHr;

    switch (dwADsErr) {

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_NOT_SUPPORTED:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_PROPERTY_NOT_FOUND:

        *pHr = DISP_E_MEMBERNOTFOUND;
        break;

    case E_ADS_BAD_PARAMETER:

        //*pHr = DISP_E_PARAMNOTOPTIONAL;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:

        *pHr = DISP_E_TYPEMISMATCH;
        //*pHr = DISP_E_BADVARTYPE;
        break;

    case E_ADS_SCHEMA_VIOLATION:

        // depends
        break;

    default:

        break;
        // should make it s.t. E_ADS_xxx -> E_FAIL and no changes on others
        // LATER
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\credel.cxx ===
#include "winnt.hxx"
#pragma hdrstop

HRESULT
WinNTCreateComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    );

HRESULT
WinNTDeleteComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    );

HRESULT
WinNTCreateLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTCreateGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTDeleteLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTDeleteGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTCreateUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    );

HRESULT
WinNTDeleteUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    );


HRESULT
WinNTCreateComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    WCHAR szComputerBuffer[MAX_PATH];
    USER_INFO_1 UserInfo1;
    PUSER_INFO_1 pUserInfo1 = &UserInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    if (!szServerName || !szComputerName ) {
        RRETURN(E_FAIL);
    }

    wcscpy(szComputerBuffer, szComputerName);
    wcscat(szComputerBuffer, L"$");

    memset(pUserInfo1, 0, sizeof(USER_INFO_1));

    pUserInfo1->usri1_name =  szComputerBuffer;
    pUserInfo1->usri1_password = NULL;
    pUserInfo1->usri1_password_age = 0;
    pUserInfo1->usri1_priv = USER_PRIV_USER;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_flags = UF_SCRIPT | UF_WORKSTATION_TRUST_ACCOUNT ;
    pUserInfo1->usri1_script_path = NULL;


    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szComputerBuffer[MAX_PATH];
    WCHAR szTargBuffer[MAX_PATH];

    if (!szServerName || !szComputerName ) {
        RRETURN(E_FAIL);
    }

    wcscpy(szComputerBuffer, szComputerName);
    wcscat(szComputerBuffer, L"$");

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserDel(
                    szTargBuffer,
                    szComputerBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
WinNTCreateGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    GROUP_INFO_1 GroupInfo1;
    PGROUP_INFO_1 pGroupInfo1 = &GroupInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;


    memset(pGroupInfo1, 0, sizeof(GROUP_INFO_1));
    pGroupInfo1->grpi1_name = szGroupName;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetGroupAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pGroupInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
WinNTCreateLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    LOCALGROUP_INFO_1 LocalGroupInfo1;
    PLOCALGROUP_INFO_1 pLocalGroupInfo1 = &LocalGroupInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;


    memset(pLocalGroupInfo1, 0, sizeof(LOCALGROUP_INFO_1));
    pLocalGroupInfo1->lgrpi1_name = szGroupName;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetLocalGroupAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pLocalGroupInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
WinNTDeleteLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    WCHAR szTargBuffer[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetLocalGroupDel(
                    szTargBuffer,
                    szGroupName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szTargBuffer[MAX_PATH];

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetGroupDel(
                    szTargBuffer,
                    szGroupName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);

}

HRESULT
WinNTCreateUser(
    LPWSTR szServerName,
    LPWSTR szUserName,
    LPWSTR szUserPassword
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    USER_INFO_1 UserInfo1;
    PUSER_INFO_1 pUserInfo1 = &UserInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    if (!szServerName || !szUserName ) {
        RRETURN(E_FAIL);
    }

    memset(pUserInfo1, 0, sizeof(USER_INFO_1));

    pUserInfo1->usri1_name =  szUserName;
    pUserInfo1->usri1_password = szUserPassword;
    pUserInfo1->usri1_password_age = DEF_MAX_PWAGE;
    pUserInfo1->usri1_priv = 1;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_script_path = NULL;


    pUserInfo1->usri1_flags =  UF_NORMAL_ACCOUNT | UF_SCRIPT;

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserAdd(
                    szTargBuffer,
                    USER_PRIV_USER,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

    //
    // If we fail without workstation services, check if the
    // machine name matches and if so add with NULL as name
    //
    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
        if (!GetComputerName(szCompName, &dwSize)) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szServerName, szCompName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szServerName,
                -1,
                szCompName,
                -1
            ) != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetUserAdd(
                    NULL,
                    USER_PRIV_USER,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );

        hr = HRESULT_FROM_WIN32(nasStatus);

    }
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    )
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szTargBuffer[MAX_PATH];
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    if (!szServerName || !szUserName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserDel(
                    szTargBuffer,
                    szUserName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

        //
    // If we fail without workstation services, check if the
    // machine name matches and if so add with NULL as name
    //
    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
        if (!GetComputerName(szCompName, &dwSize)) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szServerName, szCompName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szServerName,
                -1,
                szCompName,
                -1
            ) != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetUserDel(
                        NULL,
                        szUserName
                        );

        hr = HRESULT_FROM_WIN32(nasStatus);

    }
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteGroup(
    POBJECTINFO pObjectInfo,
    DWORD dwGroupType,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need writeable dc
                        );
        BAIL_ON_FAILURE(hr);

        if (dwGroupType == WINNT_GROUP_EITHER) {

            //
            // - try both local and global groups if "group" for backward
            //  compatability
            // - confirmed with cliffv (no global and local group under same
            //   container in nt4 or nt5. So ok.

            hr = WinNTDeleteGlobalGroup(
                    (szHostServerName +2),
                    pObjectInfo->ComponentArray[1]
                    );
            if (FAILED(hr)) {
                hr = WinNTDeleteLocalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );
            }

        } else if (dwGroupType == WINNT_GROUP_LOCAL) {

            hr = WinNTDeleteLocalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );

        } else if (dwGroupType == WINNT_GROUP_GLOBAL) {

            hr = WinNTDeleteGlobalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );

        } else {

            //
            // private funct'n -> must be ADSI own coding bug
            //

            ADsAssert(FALSE);
        }

        BAIL_ON_FAILURE(hr);
        break;

    case 3:

        if (dwGroupType == WINNT_GROUP_EITHER) {

            //
            // - try both local and global groups if "group" for backward
            //  compatability
            // - confirmed with cliffv (no global and local group under same
            //   container in nt4 or nt5. So ok.

            hr = WinNTDeleteGlobalGroup(
                    pObjectInfo->ComponentArray[1],
                    pObjectInfo->ComponentArray[2]
                    );
            if (FAILED(hr)) {
                hr = WinNTDeleteLocalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );
            }

        } else if (dwGroupType == WINNT_GROUP_LOCAL) {

                hr = WinNTDeleteLocalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );

        } else if (dwGroupType == WINNT_GROUP_GLOBAL) {

                hr = WinNTDeleteGlobalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );

        } else {

            //
            // private funct'n -> must be ADSI own coding bug
            //

            ADsAssert(FALSE);
            hr = E_FAIL;
        }

        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteUser(
    POBJECTINFO pObjectInfo,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need a writeable dc
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTDeleteUser(
                (szHostServerName +2),
                pObjectInfo->ComponentArray[1]
                );
        BAIL_ON_FAILURE(hr);
        break;

    case 3:
        hr = WinNTDeleteUser(
                pObjectInfo->ComponentArray[1],
                pObjectInfo->ComponentArray[2]
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteComputer(
    POBJECTINFO pObjectInfo,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:
        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need a writeable DC
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTDeleteComputer(
                (szHostServerName +2),
                pObjectInfo->ComponentArray[1]
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cres.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cres.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTResource, CWinNTFSResourceGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( Resource );
DECLARE_DEBUG( Resource );
#define ResourceDebugOut(x) ResourceInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CWinNTResource);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTResource);
DEFINE_IADs_TempImplementation(CWinNTResource);
DEFINE_IADs_PutGetImplementation(CWinNTResource, ResourceClass, gdwResourceTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTResource, ResourceClass, gdwResourceTableSize)


CWinNTResource::CWinNTResource()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;

    ENLIST_TRACKING(CWinNTResource);
    return;

}

CWinNTResource::~CWinNTResource()
{

    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResource::Create
//
//  Synopsis:   Static function used to create a Resource object. This
//              will be called by EnumResources::Next
//
//  Arguments:  [ppWinNTResource] -- Ptr to a ptr to a new Resource object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTResource::Create(LPTSTR pszServerADsPath,
                       DWORD  dwObject,
                       DWORD  dwFileId,
                       REFIID riid,
                       CWinNTCredentials& Credentials,
                       LPVOID * ppvoid
                       )

{

    CWinNTResource FAR * pCWinNTResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];


    hr =CWinNTResource::AllocateResourceObject(pszServerADsPath,
                                               &pCWinNTResource );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTResource->_pDispMgr);


    //
    // convert the FileId that we have into a string that we move
    // into the Name field
    //

    _ltow(dwFileId, szFileName, 10);

    hr = pCWinNTResource->InitializeCoreObject(pszServerADsPath,
                                               szFileName,
                                               RESOURCE_CLASS_NAME,
                                               RESOURCE_SCHEMA_NAME,
                                               CLSID_WinNTResource,
                                               dwObject);


    pCWinNTResource->_dwFileId = dwFileId;

    pCWinNTResource->_Credentials = Credentials;
    hr = pCWinNTResource->_Credentials.RefServer(
        pCWinNTResource->_pszServerName);
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                RESOURCE_CLASS_NAME,
                (IADs *) pCWinNTResource,
                pCWinNTResource->_pDispMgr,
                Credentials,
                &pCWinNTResource->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTResource->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Resource objects have "" as their ADsPath. Just set the class to
        // resource for identification purposes.
        pCWinNTResource->_CompClasses[0] = L"Resource";

        hr = pCWinNTResource->InitUmiObject(
               pCWinNTResource->_Credentials, 
               ResourceClass, 
               gdwResourceTableSize,
               pCWinNTResource->_pPropertyCache,
               (IUnknown *)(INonDelegatingUnknown *) pCWinNTResource,
               pCWinNTResource->_pExtMgr,
               IID_IUnknown,
               ppvoid
               );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    ADsAssert(ppvoid);
    hr = pCWinNTResource->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCWinNTResource->Release();

    RRETURN(hr);

cleanup:
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTResource;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTResource::AllocateResourceObject(LPTSTR pszServerADsPath,
                                       CWinNTResource ** ppResource)
{

    CWinNTResource FAR * pCWinNTResource = NULL;
    HRESULT hr = S_OK;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];
    POBJECTINFO pServerObjectInfo = NULL;

    //
    // Create the Resource Object
    //

    pCWinNTResource = new CWinNTResource();
    if (pCWinNTResource == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCWinNTResource->_pDispMgr = new CAggregatorDispMgr;

    if(pCWinNTResource ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr =  LoadTypeInfoEntry(pCWinNTResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsResource,
                            (IADsResource *)pCWinNTResource,
                            DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(pCWinNTResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCWinNTResource,
                            DISPID_VALUE);
    BAIL_ON_FAILURE(hr);


    pCWinNTResource->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCWinNTResource->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_ON_FAILURE(hr);

    pCWinNTResource->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if (!pCWinNTResource->_pszServerName){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyCache::createpropertycache(
             ResourceClass,
             gdwResourceTableSize,
             (CCoreADsObject *)pCWinNTResource,
             &(pCWinNTResource->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    (pCWinNTResource->_pDispMgr)->RegisterPropertyCache(
                                        pCWinNTResource->_pPropertyCache
                                        );


    *ppResource = pCWinNTResource;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    RRETURN(hr);

error:


    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCWinNTResource;

    goto cleanup;
}



/* IUnknown methods for Resource object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTResource::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTResource::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTResource::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTResource::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(ppvObj == NULL){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsResource))
    {
        *ppvObj = (IADsResource FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTResource::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsResource) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */


//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Resource
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTResource::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTResource::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    //
    // we do a GetInfo at Info Level of 3
    //
    NET_API_STATUS nasStatus = NERR_Success;
    LPFILE_INFO_3  lpFileInfo3  = NULL;
    HRESULT hr = S_OK;
    TCHAR szUncServerName[MAX_PATH];

    hr = MakeUncName(_pszServerName,
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    nasStatus = NetFileGetInfo(szUncServerName, // contains UNC name
                               _dwFileId,
                               3,
                               (LPBYTE*)&lpFileInfo3);

    if(nasStatus != NERR_Success || !lpFileInfo3){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpFileInfo3->fi3_pathname,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpFileInfo3->fi3_username,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("LockCount"),
                                  lpFileInfo3->fi3_num_locks,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    hr = S_OK;

cleanup:
    if(lpFileInfo3)
        NetApiBufferFree(lpFileInfo3);
    RRETURN_EXP_IF_ERR(hr);

}




STDMETHODIMP
CWinNTResource::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(3, TRUE));
}

STDMETHODIMP
CWinNTResource::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(3, FALSE));
}

STDMETHODIMP
CWinNTResource::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsResource *)this, User);
}

STDMETHODIMP
CWinNTResource::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTResource::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsResource *)this, Path);
}

STDMETHODIMP
CWinNTResource::get_LockCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsResource *)this, LockCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\cserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cserv.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTService,
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID





//
// class CWinNTService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTService);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTService);
DEFINE_IADs_TempImplementation(CWinNTService);
DEFINE_IADs_PutGetImplementation(CWinNTService,ServiceClass,gdwServiceTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTService, ServiceClass,gdwServiceTableSize)

CWinNTService::CWinNTService()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pPropertyCache = NULL;

    _pszServiceName   = NULL;
    _pszServerName    = NULL;
    _pszPath          = NULL;

    _schSCManager      = NULL;
    _schService        = NULL;
    _dwWaitHint        = 0;
    _dwCheckPoint      = 0;
    _fValidHandle      = FALSE;

    ENLIST_TRACKING(CWinNTService);
}

CWinNTService::~CWinNTService()
{
    if(_fValidHandle){
        //
        // an open handle exists, blow it away
        //
        WinNTCloseService();
        _fValidHandle = FALSE;
    }

    if(_pszServiceName){
        FreeADsStr(_pszServiceName);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszPath){
        FreeADsStr(_pszPath);
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Create
//
//  Synopsis:   Static function used to create a Service object. This
//              will be called by BindToObject
//
//  Arguments:  [ppWinNTService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CWinNTService::Create(LPTSTR pszADsParent,
                      LPTSTR pszDomainName,
                      LPTSTR pszServerName,
                      LPTSTR pszServiceName,
                      DWORD  dwObjectState,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{
    CWinNTService FAR * pCWinNTService = NULL;
    HRESULT hr;

    //
    // Create the Service Object
    //


    hr = AllocateServiceObject(pszServerName,
                               pszServiceName,
                               &pCWinNTService);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTService->_pDispMgr);


    hr = pCWinNTService->InitializeCoreObject(pszADsParent,
                                              pszServiceName,
                                              SERVICE_CLASS_NAME,
                                              SERVICE_SCHEMA_NAME,
                                              CLSID_WinNTService,
                                              dwObjectState);

    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(pCWinNTService->_pPropertyCache,
                                  TEXT("HostComputer"),
                                  pCWinNTService->_Parent,
                                  TRUE
                                  );

    BAIL_ON_FAILURE(hr);

    pCWinNTService->_Credentials = Credentials;
    hr = pCWinNTService->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SERVICE_CLASS_NAME,
                (IADsService *) pCWinNTService,
                pCWinNTService->_pDispMgr,
                Credentials,
                &pCWinNTService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTService->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCWinNTService->_dwNumComponents) {
            pCWinNTService->_CompClasses[0] = L"Domain";
            pCWinNTService->_CompClasses[1] = L"Computer";
            pCWinNTService->_CompClasses[2] = L"Service";
        }
        else if(2 == pCWinNTService->_dwNumComponents) {
        // no workstation services
            pCWinNTService->_CompClasses[0] = L"Computer";
            pCWinNTService->_CompClasses[1] = L"Service";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);
 
        hr = pCWinNTService->InitUmiObject(
                pCWinNTService->_Credentials,
                ServiceClass,
                gdwServiceTableSize,
                pCWinNTService->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTService,
                pCWinNTService->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTService->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCWinNTService->Release();

    RRETURN(hr);

error:

    delete pCWinNTService;
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTService::AllocateServiceObject(
    LPTSTR pszServerName,
    LPTSTR pszServiceName,
    CWinNTService ** ppService
    )
{
    CWinNTService FAR * pService = NULL;
    HRESULT hr = S_OK;

    pService = new CWinNTService();
    if (pService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pService->_pDispMgr = new CAggregatorDispMgr;
    if (pService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pService->_pszServiceName =
        AllocADsStr(pszServiceName);

    if(!(pService->_pszServiceName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = LoadTypeInfoEntry(pService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsService,
                           (IADsService *)pService,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsServiceOperations,
                           (IADsServiceOperations *)pService,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             ServiceClass,
             gdwServiceTableSize,
             (CCoreADsObject *)pService,
             &(pService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);


    (pService->_pDispMgr)->RegisterPropertyCache(
                            pService->_pPropertyCache
                            );

    *ppService = pService;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pService;

    RRETURN(hr);

}



/* IUnknown methods for service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsService *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsService *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsServiceOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPTSTR  pszPath = NULL;
    LPTSTR  pszLoadOrderGroup = NULL;
    LPTSTR  pszServiceStartName = NULL;
    LPTSTR  pszDependencies = NULL;
    LPTSTR  pszDisplayName  = NULL;
    SC_LOCK sclLock = NULL;
    BOOL fRetval = FALSE;
    LPQUERY_SERVICE_CONFIG lpqServiceConfig = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddService();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);

    }



    hr = WinNTOpenService(SC_MANAGER_ALL_ACCESS,
                          SERVICE_ALL_ACCESS);

    BAIL_IF_ERROR(hr);

    hr = GetServiceConfigInfo(&lpqServiceConfig);

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );
    if(SUCCEEDED(hr)){
        lpqServiceConfig->lpBinaryPathName = pszPath;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoadOrderGroup"),
                    &pszLoadOrderGroup
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpLoadOrderGroup = pszLoadOrderGroup;
    }

    hr = GetNulledStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Dependencies"),
                    &pszDependencies
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpDependencies = pszDependencies;
    }


    //
    // Issue: Service Account Name property has been disabled from being a
    // writeable property because ChangeServiceConfig AVs services.exe
    // on the server machine when this property is changed
    // RamV - Aug-11-96.

    /*

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceAccountName"),
                    &pszServiceStartName
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpServiceStartName = pszServiceStartName;
    }

    */

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DisplayName"),
                    &pszDisplayName
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpDisplayName = pszDisplayName;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceType"),
                    &dwServiceType
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwServiceType = dwServiceType;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartType"),
                    &dwStartType
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwStartType = dwStartType;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ErrorControl"),
                    &dwErrorControl
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwErrorControl = dwErrorControl;
    }


    //
    // set hr to S_OK. why? we dont care about the errors we hit so far
    //

    hr = S_OK;

    //
    // put a lock on the database corresponding to this service
    //

    sclLock = LockServiceDatabase(_schSCManager);

    if(sclLock == NULL){
        //
        // Exit if database cannot be locked
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // change the service configuration. Pass in all the changed parameters.
    // Since there is but one info level for services, use the
    // internal values as parameters.
    //

    fRetval = ChangeServiceConfig(_schService,
                                  lpqServiceConfig->dwServiceType,
                                  lpqServiceConfig->dwStartType,
                                  lpqServiceConfig->dwErrorControl,
                                  lpqServiceConfig->lpBinaryPathName,
                                  lpqServiceConfig->lpLoadOrderGroup,
                                  NULL,
                                  lpqServiceConfig->lpDependencies,
                                  lpqServiceConfig->lpServiceStartName,
                                  NULL,
                                  lpqServiceConfig->lpDisplayName
                                  );

    if (fRetval == FALSE)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:

    if(lpqServiceConfig){
        FreeADsMem(lpqServiceConfig);
    }

    if(sclLock){
        UnlockServiceDatabase(sclLock);
    }

    WinNTCloseService();

    if(pszPath){
        FreeADsStr(pszPath);
    }

    if(pszLoadOrderGroup){
        FreeADsStr(pszLoadOrderGroup);
    }
    if(pszServiceStartName){
        FreeADsStr(pszServiceStartName);
    }
    if(pszDependencies){
        FreeADsStr(pszDependencies);
    }
    if(pszDisplayName){
        FreeADsStr(pszDisplayName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   Currently implemented
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::GetInfo(THIS)
{

    RRETURN (GetInfo(1, TRUE));

}

STDMETHODIMP
CWinNTService::ImplicitGetInfo(THIS)
{

    RRETURN (GetInfo(1, FALSE));

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::GetInfo
//
//  Synopsis:   Binds to real Service as specified in _ServiceName and
//              attempts to refresh the Service object from the real Service.
//
//  Arguments:  dwApiLevel (ignored),  fExplicit (ignored)
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/08/96    RamV  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT                 hr;
    LPQUERY_SERVICE_CONFIG  pMem = NULL;
    BYTE                    FastConfigInfo[256];
    SERVICE_STATUS          ssStatusInfo;
    DWORD                   dwBufAllocated = 256;
    DWORD                   dwBufNeeded;
    DWORD                   dwLastError;
    BOOL                    fRetval;

    //
    // GETTING NT SERVICE INFO
    //
    // Getting information about an NT service requires three calls.
    // One to get configuration information, and one to get current
    // status information, and one to get security information.
    //

    //
    // Open the service
    //


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_READ );

    if (FAILED(hr))  {
        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // Query for Service Status first.
    //
    fRetval = QueryServiceStatus(_schService,
                                 &ssStatusInfo );

    if (fRetval == FALSE)  {
        hr = HRESULT_FROM_WIN32(GetLastError());

        WinNTCloseService();
        goto cleanup;
    }

    fRetval = QueryServiceConfig(_schService,
                                 (LPQUERY_SERVICE_CONFIG)(&FastConfigInfo),
                                 dwBufAllocated,
                                 &dwBufNeeded
                                 );

    if (fRetval == FALSE)  {
        dwLastError = GetLastError();
        switch (dwLastError)  {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Allocate more memory and try again.
            //
            dwBufAllocated = dwBufNeeded;
            pMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);
            if (pMem == NULL)  {
                hr = E_OUTOFMEMORY;
                break;
            }

            fRetval = QueryServiceConfig(_schService,
                                         pMem,
                                         dwBufAllocated,
                                         &dwBufNeeded
                                         );

            if (fRetval == FALSE)  {
                WinNTCloseService();

                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        if(FAILED(hr)){
            WinNTCloseService();
            goto cleanup;
        }
    }

    WinNTCloseService();

    //
    // clear all properties from cache first if explicit GetInfo
    //
    if (fExplicit) {
        _pPropertyCache->flushpropcache();
    }

    if(pMem){
        hr =  UnMarshall(pMem, fExplicit);
        BAIL_IF_ERROR(hr);
    }else{
        hr = UnMarshall((LPQUERY_SERVICE_CONFIG) FastConfigInfo, fExplicit);
        BAIL_IF_ERROR(hr);
    }
cleanup:
    if(pMem)
        FreeADsMem(pMem);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTService::UnMarshall(THIS_ LPQUERY_SERVICE_CONFIG lpConfigInfo,
                          BOOL fExplicit)
{
    DWORD dwADsServiceType;
    DWORD dwADsStartType;
    DWORD dwADsErrorControl;
    HRESULT hr;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpConfigInfo->lpBinaryPathName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("LoadOrderGroup"),
                                  lpConfigInfo->lpLoadOrderGroup,
                                  fExplicit
                                  );



    hr = SetNulledStringPropertyInCache(_pPropertyCache,
                                  TEXT("Dependencies"),
                                  lpConfigInfo->lpDependencies,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("ServiceAccountName"),
                                  lpConfigInfo->lpServiceStartName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("DisplayName"),
                                  lpConfigInfo->lpDisplayName,
                                  fExplicit
                                  );


    //
    // 0x133 is the bit mask for valid values of ADs ServiceTypes
    //

    dwADsServiceType = lpConfigInfo->dwServiceType & 0x133;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ServiceType"),
                                 dwADsServiceType ,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("StartType"),
                                 lpConfigInfo->dwStartType,
                                 fExplicit
                                 );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ErrorControl"),
                                 lpConfigInfo->dwErrorControl,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(hr);
}

//
// helper function  WinNTAddService
//


HRESULT
CWinNTService::WinNTAddService(void)
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    TCHAR szServerName[MAX_PATH];
    BOOL fRetval;
    LPTSTR pszDisplayName = NULL;
    LPTSTR pszPath = NULL;
    LPTSTR pszLoadOrderGroup = NULL;
    DWORD  dwServiceType;
    DWORD  dwStartType;
    DWORD  dwErrorControl;

    hr = GetServerFromPath(_ADsPath,szServerName);

    BAIL_IF_ERROR(hr);

    //
    // open the SCM for this server
    //

    schSCManager = OpenSCManager(szServerName,
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS);

    if(schSCManager == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DisplayName"),
                    &pszDisplayName
                    );


    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceType"),
                    &dwServiceType
                    );

    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartType"),
                    &dwStartType
                    );

    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ErrorControl"),
                    &dwErrorControl
                    );

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );

    BAIL_IF_ERROR(hr);

    schService = CreateService(schSCManager,
                               _pszServiceName,
                               pszDisplayName,
                               SERVICE_ALL_ACCESS,
                               dwServiceType,
                               dwStartType,
                               dwErrorControl,
                               pszPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

    if(schService == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    if(schSCManager){
        fRetval = CloseServiceHandle(schSCManager);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(schService){
        fRetval = CloseServiceHandle(schService);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(pszDisplayName){
        FreeADsStr(pszDisplayName);
    }

    if(pszPath){
        FreeADsStr(pszPath);
    }

    if(pszLoadOrderGroup){
        FreeADsStr(pszLoadOrderGroup);
    }

    RRETURN(hr);
}

STDMETHODIMP
CWinNTService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  DisplayName);
}

STDMETHODIMP
CWinNTService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    PUT_PROPERTY_BSTR((IADsService *)this,  DisplayName);

}

STDMETHODIMP
CWinNTService::get_Version(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  Version);

}

STDMETHODIMP
CWinNTService::put_Version(THIS_ BSTR bstrVersion)
{
    PUT_PROPERTY_BSTR((IADsService *)this,  Version);
}

STDMETHODIMP
CWinNTService::get_ServiceType(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsService *)this, ServiceType);
}

STDMETHODIMP
CWinNTService::put_ServiceType(THIS_ long lServiceType)
{
    PUT_PROPERTY_LONG((IADsService *)this, ServiceType);
}

STDMETHODIMP
CWinNTService::get_StartType(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsService *)this, StartType);
}

STDMETHODIMP
CWinNTService::put_StartType(THIS_ LONG lStartType)
{
    PUT_PROPERTY_LONG((IADsService *)this, StartType);
}

STDMETHODIMP
CWinNTService::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  Path);
}

STDMETHODIMP
CWinNTService::put_Path(THIS_ BSTR bstrPath)
{

    PUT_PROPERTY_BSTR((IADsService *)this,  Path);
}

STDMETHODIMP
CWinNTService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  StartupParameters);

}

STDMETHODIMP
CWinNTService::put_StartupParameters(THIS_ BSTR bstrStartupParameters) {
    PUT_PROPERTY_BSTR((IADsService *)this,  StartupParameters);

}

STDMETHODIMP
CWinNTService::get_ErrorControl(THIS_ LONG FAR* retval)
{

    GET_PROPERTY_LONG((IADsService *)this, ErrorControl);
}

STDMETHODIMP
CWinNTService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    PUT_PROPERTY_LONG((IADsService *)this, ErrorControl);
}

STDMETHODIMP
CWinNTService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  LoadOrderGroup);

}

STDMETHODIMP
CWinNTService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{

    PUT_PROPERTY_BSTR((IADsService *)this,  LoadOrderGroup);

}

STDMETHODIMP
CWinNTService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  ServiceAccountName);

}

STDMETHODIMP
CWinNTService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsService *)this,  Dependencies);
}

STDMETHODIMP
CWinNTService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    PUT_PROPERTY_VARIANT((IADsService *)this,  Dependencies);
}

STDMETHODIMP
CWinNTService::SetPassword(THIS_ BSTR bstrNewPassword)
{


    //
    // This routine should merely change password. Even if any other
    // properties are set in the configuration functional set then they
    // will not be touched.
    // Therefore we do a QueryServiceConfig and get all the configuration
    // related information, merely change the password and send it back.
    // For this reason, it is not possible to reuse GetInfo or SetInfo
    // because they change service config properties.
    //

    BOOL fRetval;
    LPQUERY_SERVICE_CONFIG pMem = NULL;
    HRESULT hr;

    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          SERVICE_ALL_ACCESS);


    BAIL_IF_ERROR(hr);

    hr = GetServiceConfigInfo(&pMem);
    BAIL_IF_ERROR(hr);

    //
    // just change the field corresponding to password.
    //

    fRetval = ChangeServiceConfig(_schService,
                                  pMem->dwServiceType,
                                  pMem->dwStartType,
                                  pMem->dwErrorControl,
                                  pMem->lpBinaryPathName,
                                  pMem->lpLoadOrderGroup,
                                  NULL,
                                  pMem->lpDependencies,
                                  pMem->lpServiceStartName,
                                  (LPTSTR)bstrNewPassword,
                                  pMem->lpDisplayName
                                  );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    if(pMem){
        FreeADsMem(pMem);
    }
    WinNTCloseService();
    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::Start(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_START_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Stop(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_STOP_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Pause(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_PAUSE_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Continue(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_CONTINUE_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}


//
// Helper Functions
//

HRESULT
CWinNTService::GetServiceConfigInfo(LPQUERY_SERVICE_CONFIG *ppMem)
{
    //
    //gets the service configuration information into ppMem
    //

    BOOL    fRetval;
    DWORD   dwBufAllocated = 0;
    DWORD   dwBufNeeded = 0;
    DWORD   dwLastError;
    HRESULT hr = S_OK;

    ADsAssert(ppMem);
    *ppMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);

    if (*ppMem == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    ADsAssert(_schService);

    fRetval = QueryServiceConfig(_schService,
                                 (LPQUERY_SERVICE_CONFIG)(*ppMem),
                                 dwBufAllocated,
                                 &dwBufNeeded);

    if (fRetval == FALSE)  {
        dwLastError = GetLastError();
        switch (dwLastError)  {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Allocate more memory and try again.
            //
            FreeADsMem(*ppMem);
            *ppMem = NULL;

            dwBufAllocated = dwBufNeeded;
            *ppMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);
            if (*ppMem == NULL)  {
                BAIL_IF_ERROR(hr = E_OUTOFMEMORY);
            }

            fRetval = QueryServiceConfig(_schService,
                                         *ppMem,
                                         dwBufAllocated,
                                         &dwBufNeeded);

            if (fRetval == FALSE)  {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        BAIL_IF_ERROR(hr);
    }

    if(*ppMem){
        RRETURN(S_OK);
    }

cleanup:
    RRETURN(hr);

}



HRESULT
CWinNTService::WinNTControlService( DWORD dwControl)
{
    //
    // abstracts out the common code of Start,Stop,Pause and Resume
    //

    HRESULT         hr =S_OK, hrclose=S_OK, hrcontrol=S_OK;
    SERVICE_STATUS  ssStatusInfo;
    BOOL            fRetval;


    if(_fValidHandle){
        //
        // an open handle exists, blow it away
        //
        hrclose = WinNTCloseService();
        BAIL_ON_FAILURE(hrclose);
        _fValidHandle = FALSE;
    }


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_EXECUTE| SERVICE_INTERROGATE
                          );

    BAIL_ON_FAILURE(hr);

    _fValidHandle = TRUE;

    switch(dwControl){

    case WINNT_START_SERVICE:
        fRetval = StartService(_schService,
                               0,
                               NULL );


        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_START;
        break;

    case WINNT_STOP_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_STOP,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_STOP;
        break;

    case WINNT_PAUSE_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_PAUSE,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_PAUSE;
        break;

    case WINNT_CONTINUE_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_CONTINUE,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_CONTINUE;
        break;

    default:
        hrcontrol = E_FAIL;
        goto error;
    }
    _dwTimeStarted = GetTickCount();
    _dwWaitHint = 10000; //10 seconds
    _dwCheckPoint = 0;

    RRETURN(S_OK);

error:
    if(FAILED(hrcontrol)){
        _fValidHandle = FALSE;
        RRETURN(hrcontrol);
    }
    else if(FAILED(hrclose)){
        RRETURN(hrclose);
    }
    else{
        RRETURN(hr);
    }
}





//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::WinNTOpenService
//
//  Synopsis:   Opens the Service Control Manager on the machine specified in
//              _bstrPath, then opens the Service specified in _bstrServiceName.
//              The handle to the SCM is placed in _schSCManager, and the
//              handle to the service is placed in _schService.
//
//  Arguments:  [dwSCMDesiredAccess] -- type of SCM access needed
//              [dwSvrDesiredAccess] -- type of Service access required
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    03-17-95    t-skwan     Created
//              01/04/96    RamV        Modified
//
//----------------------------------------------------------------------------
HRESULT
CWinNTService::WinNTOpenService(
    DWORD   dwSCMDesiredAccess,
    DWORD   dwSvrDesiredAccess
    )
{
    HRESULT hr;
    DWORD   dwLastError;


    //
    // Open the Service Control Manager.
    //

    //
    // OpenSCManager(
    //      LPCTSTR lpszMachineName,
    //      LPCTSTR lpszDatabaseName.
    //      DWORD   fdwDesiredAccess)
    //


    _schSCManager = OpenSCManager(_pszServerName,
                                  NULL,
                                  dwSCMDesiredAccess);

    if (_schSCManager == NULL)  {

        dwLastError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);
        RRETURN(hr);
    }

    //
    // Get a handle to the specified service.
    //


    _schService = OpenService(_schSCManager,
                              _pszServiceName,
                              dwSvrDesiredAccess);

    if(_schService == NULL)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CloseServiceHandle(_schSCManager);
        _schSCManager = NULL;
        RRETURN(hr);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::WinNTCloseService
//
//  Synopsis:   Closes the Service handle and the Service Control Manager
//              handle.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    03-17-95    t-skwan     Created
//              01/04/96    RamV        Modified
//
//----------------------------------------------------------------------------

HRESULT
CWinNTService::WinNTCloseService()
{
    BOOL    fRetval = TRUE;


    //
    // Close the Service handle.
    //
    if(_schService){
        fRetval = CloseServiceHandle(_schService);
        _schService = NULL;
    }

    if (!fRetval)  {
        //
        // Ack.  What do we do if there is an error closing a service?
        //
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Close the Service Control Manager.
    //

    if(_schSCManager){
        fRetval = CloseServiceHandle(_schSCManager);
        _schSCManager = NULL;
    }
    if (!fRetval)  {
        //
        // Ack.  What do we do if there is an error closing an SCM?
        //
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr = S_OK;
    BOOL fRetval = FALSE, found = FALSE;
    SERVICE_STATUS Status;
    DWORD dwStatus = 0;


    if(plStatusCode == NULL){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *plStatusCode = -1; //-1 is an invalid code

    if(!(_fValidHandle)){

        //
        // currently not waiting on any service
        //

        hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                              GENERIC_EXECUTE|SERVICE_INTERROGATE);


        BAIL_IF_ERROR(hr);

        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_INTERROGATE,
                                 &Status);


        if(!fRetval){
            hr = HRESULT_FROM_WIN32(GetLastError());
            if(hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE)){
                dwStatus = SERVICE_STOPPED;
                hr = S_OK;
            }
            goto cleanup;
        }

        dwStatus = Status.dwCurrentState;

        hr = WinNTCloseService();

        goto cleanup;

    }

    //
    // if you are here
    // you are waiting for a service to complete
    //

    //
    // NOTE: QueryServiceStatus queries the SCM rather than
    // the service directly so to get a more upto date answer
    // we need to use control service with interrogate option
    //


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_EXECUTE|SERVICE_INTERROGATE);

    BAIL_IF_ERROR(hr);

    fRetval = ControlService(_schService,
                             SERVICE_CONTROL_INTERROGATE,
                             &Status);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        if(hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE)){
            dwStatus = SERVICE_STOPPED;
            hr = S_OK;
        }
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_START,
                              SERVICE_RUNNING,
                              SERVICE_START_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }
    hr = EvalPendingOperation(PENDING_STOP,
                              SERVICE_STOPPED,
                              SERVICE_STOP_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_PAUSE,
                              SERVICE_PAUSED,
                              SERVICE_PAUSE_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_CONTINUE,
                              SERVICE_RUNNING,
                              SERVICE_CONTINUE_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    ADsAssert(dwStatus != 0); //we must find the appropriate scenario

cleanup:
    if(SUCCEEDED(hr)){
        //
        // instead of a conversion routine, we return WinNT Status Code
        //

        *plStatusCode = dwStatus;

    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTService::EvalPendingOperation(
    THIS_ DWORD dwOpPending,
    DWORD dwStatusDone,
    DWORD dwStatusPending,
    LPSERVICE_STATUS pStatus,
    DWORD *pdwRetval
    )

{

    DWORD dwCurrentStatus;
    BOOL     fRetval;
    HRESULT  hr =S_OK;
    DWORD dwNow;

    dwCurrentStatus = pStatus->dwCurrentState;

    if(_dwOpPending == dwOpPending){

        if(dwCurrentStatus == dwStatusDone){
            //
            //was pending, is now completed
            //

            _dwOpPending = NOTPENDING;
            *pdwRetval = dwStatusDone;
            hr = WinNTCloseService();
            BAIL_ON_FAILURE(hr);
            _fValidHandle = FALSE;
            RRETURN(S_OK);

        }
        else if(dwCurrentStatus = dwStatusPending){
            //
            //see if progress has been made since the last time we checked
            //

            if(pStatus->dwCheckPoint !=_dwCheckPoint){
                //
                // progress was made
                //
                *pdwRetval = dwStatusPending;
                _dwCheckPoint = pStatus->dwCheckPoint;
                _dwWaitHint = pStatus->dwWaitHint;
                _dwTimeStarted = GetTickCount();
                RRETURN(S_OK);
            }

            dwNow = GetTickCount();


            if(2*_dwWaitHint < TickCountDiff(dwNow,_dwTimeStarted)){
                //
                // you can still wait
                //
                *pdwRetval = dwStatusPending;
                RRETURN(S_OK);
            }

            else{

                //
                // took too long without signs of progress
                //

                *pdwRetval = SERVICE_ERROR;
                _dwOpPending = NOTPENDING;
                hr = WinNTCloseService();
                BAIL_ON_FAILURE(hr);
                _fValidHandle = FALSE;
                RRETURN(S_OK);
            }
        }
        else{

            //
            // an operation is pending but we arent going anywhere
            // recover gracefully
            //

            _dwOpPending = NOTPENDING;
            hr = WinNTCloseService();
            BAIL_ON_FAILURE(hr);
            _fValidHandle = FALSE;
            *pdwRetval = SERVICE_ERROR;
            RRETURN(S_OK);
        }

    }
error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\winnt\csess.cxx ===
//---------------------------------------------------------------------------DSI
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  csess.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTSession, CWinNTSessionGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( Session );
DECLARE_DEBUG( Session );
#define SessionDebugOut(x) SessionInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CWinNTSession);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTSession);
DEFINE_IADs_TempImplementation(CWinNTSession);
DEFINE_IADs_PutGetImplementation(CWinNTSession, SessionClass,gdwSessionTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTSession, SessionClass,gdwSessionTableSize)

CWinNTSession::CWinNTSession()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pszComputerName = NULL;
    _pszUserName  = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTSession);
    return;

}

CWinNTSession::~CWinNTSession()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pszComputerName){
        FreeADsStr(_pszComputerName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pProperty