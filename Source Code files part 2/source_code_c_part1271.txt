Y
DBTryToFindDNT(DBPOS FAR *pDB, ULONG tag)
{
    JET_ERR  err;
    ULONG    actuallen;
    JET_RETRIEVECOLUMN jCol[2];

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we have to cancel rec.  Callers should
    // take care of this by either not being in an init rec in the first place,
    // or by doing their own cancel rec or update rec.  This is important since
    // cancelling a rec here leaves the caller under the mistaking impression
    // that a JetSetColumn they've done is just waiting for an update rec to
    // be flushed to disk.  Anyway, assert on it now, but keep going if they
    // have done this.
    // later, we might want to change this to error if we are in a
    // init rec.
    Assert(pDB->JetRetrieveBits == 0);
    DBCancelRec(pDB);
    DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                 &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID,
                        pDB->JetObjTbl, JET_bitSeekEQ)) {
        return DIRERR_OBJ_NOT_FOUND;
    }

    (pDB)->DNT = tag;

    if (tag == ROOTTAG) {
        pDB->PDNT = 0;
        pDB->NCDNT = 0;
    }
    else {
        memset(jCol, 0, sizeof(jCol));

        jCol[0].columnid = pdntid;
        jCol[0].pvData = &pDB->PDNT;
        jCol[0].cbData = sizeof(ULONG);
        jCol[0].cbActual = sizeof(ULONG);
        jCol[0].itagSequence = 1;

        jCol[1].columnid = ncdntid;
        jCol[1].pvData = &pDB->NCDNT;
        jCol[1].cbData = sizeof(ULONG);
        jCol[1].cbActual = sizeof(ULONG);
        jCol[1].itagSequence = 1;

        JetRetrieveColumnsSuccess(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  jCol,
                                  2);
    }

    pDB->JetNewRec = FALSE;
    (pDB)->root = (tag == ROOTTAG);
    pDB->fFlushCacheOnUpdate = FALSE;

    DPRINT1(2, "DBTryToFindDNT complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function begins a JET transaction.
*/
USHORT
DBTransIn(DBPOS FAR *pDB)
{
    THSTATE     *pTHS = pDB->pTHS;
    UUID *pCurrInvocationID;

    Assert(pDB);
    Assert(VALID_DBPOS(pDB));
    Assert(VALID_THSTATE(pTHS));

    // Allow us to start maintaining state regarding escrow updates.
    // However do not do this for the Hidden DBPOS. The hidden DBPOS
    // uses a seperate Jet session other than the one in pTHS and can
    // cause problems if someone interleaved normal DBcalls and Hidden
    // DBPOS calls. Also we never expect escrow updates on the hidden DBPOS.

    if (!pDB->fHidden) {
        NESTED_TRANSACTIONAL_DATA  *pNewInfo;

        pNewInfo = (NESTED_TRANSACTIONAL_DATA *)
            dbAlloc(sizeof(NESTED_TRANSACTIONAL_DATA));

        // NESTED_TRANSACTIONAL_DATA structs are hung in a linked list off the
        // thread state. Inner-most transaction is at the front of the list,
        // outer-most transaction is at the end of the list.  So on transaction
        // begin, we only need to insert into the front of the list.

#if DBG
        __try {
            // Count the number of transactional data blobs we already have

            NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
            DWORD count=0;

            while(pTestInfo) {
                count++;
                pTestInfo = pTestInfo->pOuter;
            }

            Assert(count == pTHS->JetCache.transLevel);
        }
        __except (TRUE) {
            Assert(!"Failed to walk to the end of the xactional data");
        }
#endif
        
        pNewInfo->pOuter = pTHS->JetCache.dataPtr;
        pTHS->JetCache.dataPtr = pNewInfo;

    }


    // We need to begin the transaction now.  We also need to pick up some
    // dnreadcache stuff, if this is from transaction level 0 to 1.
    if(pTHS->JetCache.transLevel) {
        // simple case.
        JetBeginTransactionEx(pDB->JetSessID);
    }
    else {
        // This is going from transaction level 0 to transaction level 1.  We
        // need to atomically start a transaction and pick up a new global
        // dnread cache.  Atomicity is needed to keep us from starting a
        // transaction in thread A, then having thread B commit a change which
        // affects the global dnread cache, then having thread C create a new
        // global dnread cache, then finally picking up this new cache for use
        // in thread A.  In this unlikely series of events, thread A has a
        // global DNRead cache which is inconsistent with his transacted view of
        // the database.  If we force thread A to begin a transaction and pick
        // up the DNRead cache before thread C can replace it, we avoid such an
        // unlikely fate.
        // In order to achieve this ordering use a resource representing the
        // globaldnread cache on the anchor.  We take it non-exclusive here (so
        // that no threads block while trying to enter a transaction) in thread
        // A, and we take it exclusively when writing the new read cache to the
        // anchor (so that we get the necessary atomicity in this thread) in
        // thread C.  In concrete terms, dbReplaceCacheInAnchor uses the same
        // resource in an exclusive fashion.

        RtlAcquireResourceShared(&resGlobalDNReadCache, TRUE);\
        __try {
            // Get a global dnread cache.
            dbResetGlobalDNReadCache(pTHS);
            
            // Begin the transaction.
            JetBeginTransactionEx(pDB->JetSessID);
        }
        __finally {
            RtlReleaseResource(&resGlobalDNReadCache);
        }
        
        // Refresh the local part of the DN read cache.
        dbResetLocalDNReadCache(pTHS, FALSE);

        // Refresh our invocation ID.
        // Note that local var pCurrInvocationID is used for atomicity.
        pCurrInvocationID = gAnchor.pCurrInvocationID;
        if (NULL == pCurrInvocationID) {
            // In startup, before real invocation ID has been read.
            pTHS->InvocationID = gNullUuid;
        } else {
            // Normal operation.
            pTHS->InvocationID = *pCurrInvocationID;
        }
    }
    
    pDB->transincount++;

    // Assert that we should not be using nested DBTransIn, rather use
    // multiple DBPos's

    Assert((pDB->transincount<2)
            && "Do not use nested DBtransIn, use Addtional pDB's");

    // if this is not the DBPOS used for the hidden record then
    // then increment the transaction level in the Thread state. Hidden record
    // DBPOS is on a seperate JetSession so the transaction level is not linked
    // to the thread state
    if (!pDB->fHidden) {
        pTHS->JetCache.transLevel++;
    
        if (1 == pTHS->JetCache.transLevel) {
            // Starting our first level transaction.  Until we return to level
            // 0, we are a potential drain on Jet resources -- version store, in
            // particular.  Record the current time (in ticks) so we can sanity
            // check it later to make sure we haven't been here "too long."
            pTHS->JetCache.cTickTransLevel1Started = GetTickCount();
        }
    }

    pDB->JetRetrieveBits = 0;
    DPRINT1(2,"DBTransIn complete Sess: %lx\n", pDB->JetSessID);

    DPRINT4(3,"TransIn pDB tcount:%d thread dbcount:%x Sess:%lx pDB:%x\n", 
               pDB->transincount,
               pTHS->opendbcount,
               pDB->JetSessID,
               pDB);

    return 0;
}

VOID
dbTrackModifiedDNTsForTransaction (
        PDBPOS pDB,
        DWORD NCDNT,
        ULONG cAncestors,
        DWORD *pdwAncestors,
        BOOL  fNotifyWaiters,
        DWORD fChangeType)
{
    
    THSTATE *pTHS = pDB->pTHS;
    
    MODIFIED_OBJ_INFO *pTemp2;
    MODIFIED_OBJ_INFO *pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;

    
    if(pTemp && pTemp->cItems < MODIFIED_OBJ_INFO_NUM_OBJS) {
        pTemp->Objects[pTemp->cItems].ulNCDNT = NCDNT;
        pTemp->Objects[pTemp->cItems].pAncestors = pdwAncestors;
        pTemp->Objects[pTemp->cItems].cAncestors = cAncestors;
        pTemp->Objects[pTemp->cItems].fNotifyWaiters = fNotifyWaiters;
        pTemp->Objects[pTemp->cItems].fChangeType = fChangeType;
        pTemp->cItems += 1;
    }
    else {
        pTemp2 =
            (MODIFIED_OBJ_INFO *)THAllocOrgEx(pTHS, sizeof(MODIFIED_OBJ_INFO)); 
        pTemp2->pNext = pTemp;
        pTHS->JetCache.dataPtr->pModifiedObjects = pTemp2;
        pTemp2->Objects[0].ulNCDNT = NCDNT;
        pTemp2->Objects[0].pAncestors = pdwAncestors;
        pTemp2->Objects[0].cAncestors = cAncestors;
        pTemp2->Objects[0].fNotifyWaiters = fNotifyWaiters;
        pTemp2->Objects[0].fChangeType = fChangeType;
        pTemp2->cItems = 1;
    }
}

DWORD
ComplainAndContinue (
        BOOL fDoAssert
        )
{
    if(fDoAssert) {
        Assert(!"POSTPROCESSING transactional data must NEVER except!\n");
    }
    return EXCEPTION_CONTINUE_SEARCH;
}


BOOL
dbPreProcessTransactionalData(
        PDBPOS pDB,
        BOOL fCommit
        )
/*++
    Preprocess any transactional data.  This is called before the actual end of
    transaction. This routine calls out the the various portions of the DS that
    track transactional data to let them prepare to commit transactional data.
    These pre-process routines should return success if they have managed to
    correctly prepare for commit (e.g. they may validate the data, allocate
    memory used by the post-proccess code, etc).  If the pre-process routines
    return success, then the post-process routines MUST NOT FAIL.  If the
    pre-process routines succeed, we're going to make a commit to the Jet
    Database.   We can't have the post process routines failing after we have
    done the DB commit.

    Pre-process routines are allowed to cause exceptions.  Post-process routines
    should NEVER throw exceptions.
    
    Note that if the dbpos we're dealing with is for the hidden table, no
    transactional data should be present.
--*/
{
    NESTED_TRANSACTIONAL_DATA *pInfo;
    THSTATE *pTHS;
    BOOL     retVal1, retVal2, retVal3, retVal4;
    
    if(pDB->fHidden) {
        return TRUE;
    }
    
    pTHS = pDB->pTHS;
    
    pInfo = pTHS->JetCache.dataPtr;

    Assert(pInfo);
    Assert(!pInfo->preProcessed);
    Assert(pTHS->JetCache.transLevel > 0);

#if DBG
    __try {
        // Count the number of transactional data blobs we already have
        
        NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
        DWORD count=0;
        
        while(pTestInfo) {
            count++;
            pTestInfo = pTestInfo->pOuter;
        }
        
        Assert(count == pTHS->JetCache.transLevel);
    }
    __except (TRUE) {
        Assert(!"Failed to walk to the end of the xactional data");
    }
#endif
    
    // GroupTypeCachePreProcessTransactionalData does not exist, since it
    // doesn't need to do anything
    // (I.E. GroupTypeCachePostProcessTransactionalData does all the work and
    // should never fail)

    retVal1 = dnReadPreProcessTransactionalData(fCommit);
    retVal2 = dbEscrowPreProcessTransactionalData(pDB, fCommit);
    retVal3 = LoopbackTaskPreProcessTransactionalData(fCommit);
    retVal4 = ObjCachingPreProcessTransactionalData(fCommit);
    
    pInfo->preProcessed = TRUE;
    
    return (retVal1 && retVal2 && retVal3 && retVal4);
}


void
dbPostProcessTrackModifiedDNTsForTransaction (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++
    Called when after a transaction has ended. If the transaction is aborted,
    the transactional data associated with the deepest transaction is deleted.
    If a transaction is committed to some level other than 0, the transactional
    data is propagated to the next level up.  If committed to 0, calls several
    other routines that make use of the data.
    
    Regardless of commit or abort and level, the data associated with the
    current transaction level is no longer associated (i.e., it is deleted, or
    it is moved, or it is acted on then deleted.)
    
--*/       
{
    DWORD          i;
    MODIFIED_OBJ_INFO *pTemp2;
    MODIFIED_OBJ_INFO *pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
 
    
    Assert(VALID_THSTATE(pTHS));

    if(!pTHS->JetCache.dataPtr->pModifiedObjects ) {
        // nothing to do.
        return;
    }
    
    if ( !fCommitted ) {
        // Aborted transaction - throw away all the data of 
        // this (possibly nested) transaction.
        pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        while(pTemp) {
            pTemp2 = pTemp->pNext;
            THFreeOrg(pTHS, pTemp);
            pTemp = pTemp2;
        }
        // reset ptr so that md.c:Dump_ModifiedObjectInfo will not get confused
        pTHS->JetCache.dataPtr->pModifiedObjects = NULL;
    }
    else if (pTHS->JetCache.transLevel > 0) {
        // Committing, to non-zero level.  Propagate the ModifiedObjects
        // updates to the outer transaction.
        
        // first, find the end of the outer transactions modified dnt info
        // chain.
        Assert(pTHS->JetCache.dataPtr->pOuter);
        if(!pTHS->JetCache.dataPtr->pOuter->pModifiedObjects) {
            pTHS->JetCache.dataPtr->pOuter->pModifiedObjects =
                pTHS->JetCache.dataPtr->pModifiedObjects;
        }
        else {
            pTemp = pTHS->JetCache.dataPtr->pOuter->pModifiedObjects;
            
            while(pTemp->pNext) {
                pTemp = pTemp->pNext;
            }
            
            
            pTemp->pNext = pTHS->JetCache.dataPtr->pModifiedObjects;
            pTHS->JetCache.dataPtr->pModifiedObjects = NULL;
        }
    }
    else {
        // OK, we're committing to transaction level 0.  Give the people who
        // care about this data a chance to do something with it, then delete
        // the data. 
        
        __try {
            GroupTypeCachePostProcessTransactionalData(pTHS,
                                                       fCommit,
                                                       fCommitted); 

            NotifyWaitersPostProcessTransactionalData(pTHS,
                                                      fCommit,
                                                      fCommitted); 
        }
        __except(ComplainAndContinue(TRUE)) {
            Assert(!"Hey, we shouldn't be here!\n");
        }
        
        // Free up stuff
        pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        while(pTemp) {
            pTemp2 = pTemp->pNext;
            THFreeOrg(pTHS, pTemp);
            pTemp = pTemp2;
        }
        // reset ptr so that md.c:Dump_ModifiedObjectInfo will not get confused
        pTHS->JetCache.dataPtr->pModifiedObjects = NULL;

        if (gfDsaWritable == FALSE) {
            // We didn't think we could write to the database, but we can!
            // Tell NetLogon, who cares about such things.
            SetDsaWritability(TRUE, 0);
        }

    }
}

VOID
dbPostProcessTransactionalData(
    IN DBPOS *pDB,
    IN BOOL fCommit,
    IN BOOL fCommitted
    )
/*++
    Postprocess any transactional data.  This is called after the actual end of
    transaction.  Mostly, call out the the various portions of the DS that track
    transactional data to let them clean up, then cut the current transaction
    out of the transactional data linked list.

    The various routines called by this wrapper routine are responsible for
    cleaning up the memory that has been allocated for their use.  This routine
    is responsible for cleaning up the linked list of transactional data blobs.

    The post processing routines SHOULD NEVER FAIL!!!!!  Since we've already
    committed the Jet transaction, these calls must suceed.  Therefore, all the
    necessary memory allocation must have been done in the pre-processing phase.
    
    Note that if the dbpos we're dealing with is for the hidden table, no
    transactional data should be present.
--*/
{
    NESTED_TRANSACTIONAL_DATA *pInfo;
    THSTATE *pTHS=pDB->pTHS;

    Assert( pDB );

    if( pDB->fHidden ) {
        return;
    }

    pInfo = pTHS->JetCache.dataPtr;

    Assert( pInfo );
    Assert( pInfo->preProcessed || !fCommitted);

#if DBG
    __try {
        // Count the number of transactional data blobs we already have
        
        NESTED_TRANSACTIONAL_DATA *pTestInfo = pTHS->JetCache.dataPtr;
        DWORD count=0;
        
        while(pTestInfo) {
            count++;
            pTestInfo = pTestInfo->pOuter;
        }
        
        Assert(count == (1 + pTHS->JetCache.transLevel));
    }
    __except (TRUE) {
        Assert(!"Failed to walk to the end of the xactional data");
    }
#endif
    

    __try {
        __try {
            LoopbackTaskPostProcessTransactionalData(pTHS,
                                                     fCommit,
                                                     fCommitted);

            dbPostProcessTrackModifiedDNTsForTransaction(pTHS,
                                                         fCommit,
                                                         fCommitted); 

            dnReadPostProcessTransactionalData(pTHS,
                                               fCommit,
                                               fCommitted);

            dbEscrowPostProcessTransactionalData(pDB,
                                                 fCommit,
                                                 fCommitted);

            ObjCachingPostProcessTransactionalData(pTHS,
                                                   fCommit,
                                                   fCommitted);

            // Do this last, so that prior routines have a chance to set the bit
            if (    (0 == pTHS->JetCache.transLevel) 
                 && (pTHS->fExecuteKccOnCommit) ) {
                if (fCommitted) {
                    DRS_MSG_KCC_EXECUTE msg;
                    DWORD err;

                    // Request the KCC to run immediately to revise topology
                    memset( &msg, 0, sizeof(msg) );
                    msg.V1.dwTaskID = DS_KCC_TASKID_UPDATE_TOPOLOGY;
                    // Do async, this could take a while...
                    msg.V1.dwFlags = DS_KCC_FLAG_ASYNC_OP;
                    err = KccExecuteTask( 1, &msg );
                    if (err && (ERROR_DS_NOT_INSTALLED != err)) {
                        LogUnhandledError(err);
                    }
                    // Ignore failures
                }
                pTHS->fExecuteKccOnCommit = 0;
            }
        }
        __except(ComplainAndContinue(TRUE)) {
            Assert(!"Hey, we shouldn't be here!\n");
        }
    }
    __finally {
        // Strip this transaction's TRANSACTIONALDATA out of the linked
        // list.

        pTHS->JetCache.dataPtr = pInfo->pOuter;
        dbFree(pInfo);

        // Stop treating a newly created row as special; its just
        // another existing object, now.
        if (pTHS->JetCache.transLevel == 0) {
            pDB->NewlyCreatedDNT = INVALIDDNT;
        }

        // If this was a level 0 transaction terminating, then THSTATE
        // should not have any transactional data remaining, otherwise
        // it should.

        Assert((pTHS->JetCache.transLevel == 0)?
               NULL == pTHS->JetCache.dataPtr :
               NULL != pTHS->JetCache.dataPtr);
    }

}
/* Tiny wrapper used only to get the required exception handler out
 * from the innards of a finally block, where the compiler would not
 * let it appear, presumably for reasons of good taste.
 */
NTSTATUS MyNetNotifyDsChange(NL_DS_CHANGE_TYPE change)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    __try {
        I_NetNotifyDsChange(change);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
    return status;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function completes the current JET transaction.
*/
USHORT
DBTransOut(DBPOS FAR *pDB, BOOL fCommit, BOOL fLazy)
{
    ULONG err;
    BOOL fCommitted = FALSE;
    BOOL fPreProcessed = FALSE;
    THSTATE    *pTHS=pDB->pTHS;

    Assert(pDB);
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pDB));

    // JLiem suspects that we have DB corruption stemming from committing
    // transactions while still in the midst of a prepare update.
    Assert((FALSE == fCommit) || (0 == pDB->JetRetrieveBits));


    // Commit or rollback JET transaction

    __try
    {

        fPreProcessed = dbPreProcessTransactionalData(pDB, fCommit);

        if (fPreProcessed && fCommit)
        {
#if DBG
            // Assert that if we opened a pDB at transaction level n
            // then we do not commit beyond transactionlevel n. This assert
            // is not applicable to the hidden DBPOS
            Assert((pDB->fHidden)||((pDB->transincount+pDB->TransactionLevelAtOpen)
                    >= pTHS->JetCache.transLevel));
#endif

            if (pDB->JetCacheRec && pDB->transincount == 1)
                {
                //  should either succeed or fail with update not prepared
                err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
                Assert(err == 0 || err == JET_errUpdateNotPrepared);
                pDB->JetCacheRec = FALSE;
                }

            JetCommitTransactionEx(pDB->JetSessID,
                                   (pTHS->fLazyCommit || fLazy)?
                                   JET_bitCommitLazyFlush : 0);
            fCommitted = TRUE;
        }

    }
    __finally
    {
        // We have to test for abnormal termination here, instead of down
        // below where we need it because AT() tells you about the try block
        // that most closely encloses you, and we're about to start a new try!
        // Were we to just call AT() inside the try block below (as we used
        // to), it would always return false.
        BOOL fAbnormalTermination = AbnormalTermination();

        __try {
            // Rollback if commit is not specified or if errors occurred
            if ((!fCommit ) || (!fPreProcessed) || (fAbnormalTermination)) {
                JetRollback(pDB->JetSessID, 0);
            }
            
            pDB->transincount--;
            
            // Bump the transaction level down in THSTATE if this is not the
            // hidden record.
            if (!pDB->fHidden) {
                pTHS->JetCache.transLevel--;
                
                // We need to call dbFlushUncUsn's upon a commit to a level 0
                // transaction. The real test for level 0 is
                // pTHS->transactionlevel  going to 0. 

                // we don't notify interested parties, update anchor when in singleuser mode
                // cause our internal state is propably broken and we are planning on rebooting
                // shortly
                if (0 == pTHS->JetCache.transLevel && !pTHS->fSingleUserModeThread) {
                    // Here we have commited changes, update uncommited usn data
                    
                    dbFlushUncUsns ();
                    
                    // Let NetLogon know if we changed anything important 
                    // As well, notify SAM of changes, too.
                    if (fCommitted) {
                        if (pTHS->fNlSubnetNotify) {
                            MyNetNotifyDsChange(NlSubnetObjectChanged);
                        }
                        if (pTHS->fNlSiteObjNotify) {
                            MyNetNotifyDsChange(NlSiteObjectChanged);
                        }
                        if (pTHS->fNlSiteNotify) {
                            MyNetNotifyDsChange(NlSiteChanged);
                            SamINotifyServerDelta(SampNotifySiteChanged);
                        }
                        if (pTHS->fNlDnsRootAliasNotify) {
                            MyNetNotifyDsChange(NlDnsRootAliasChanged);
                            InsertInTaskQueue(TQ_WriteServerInfo,
                                              (void *)(DWORD)SERVINFO_RUN_ONCE,
                                              0);
                        }
                        if (pTHS->fAnchorInvalidated) {
                            InsertInTaskQueue(TQ_RebuildAnchor,
                                              NULL,
                                              0);
                        }
                        if (pTHS->fBehaviorVersionUpdate) {
                            InsertInTaskQueue(TQ_BehaviorVersionUpdate,
                                              (void *)(DWORD)1,  //run once 
                                              0);
                        }
                    }
                    
                    pTHS->fNlSubnetNotify = 0;
                    pTHS->fNlSiteObjNotify = 0;
                    pTHS->fNlSiteNotify = 0;
                    pTHS->fNlDnsRootAliasNotify = 0;
                    pTHS->fAnchorInvalidated = 0;
                    pTHS->fBehaviorVersionUpdate = 0;

                    pTHS->JetCache.cTickTransLevel1Started = 0;
                }
            }
            
            // we keep the locked DN all the way till this pDB goes to level 0
            if ( pDB->pDNsAdded && (0 == pDB->transincount) ) {
                dbUnlockDNs(pDB);
            }
            
            // Process and dispose of the list of replica notifications
            // This is for the entire thread and not DBPOS specific
            // This only happens when finishing the level 0 transaction
            
            if ( (0 == pTHS->JetCache.transLevel) && (pTHS->pNotifyNCs) )  {
                PNCnotification pItem, pNext;
                
                pItem = (PNCnotification) pTHS->pNotifyNCs;
                while (pItem) {
                    
                    if (fCommitted) {
                        NotifyReplicas( pItem->ulNCDNT, pItem->fUrgent );
                    }
                    
                    pNext = pItem->pNext;
                    
                    dbFree( pItem );
                    
                    pItem = pNext;
                }
                pTHS->pNotifyNCs = NULL;
            }

        }
        __finally {
            dbPostProcessTransactionalData( pDB, fCommit, fCommitted );
        }


        DPRINT4(3,"TransOut pDB tcount:%d thread dbcount:%x Sess:%lx pDB:%x\n",
               pDB->transincount,
               pTHS->opendbcount,
               pDB->JetSessID,
               pDB);
    }

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function begins a JET transaction and loads the current JET
   record into the copy buffer. If there is a record already in the copy
   buffer then ther is already a transaction & we just return.
*/

DWORD
dbInitRec(DBPOS FAR *pDB)
{
    ULONG    err;
    ULONG    actuallen;

    Assert(VALID_DBPOS(pDB));

    if (pDB->JetRetrieveBits == JET_bitRetrieveCopy)
        return 0;

    if (pDB->JetCacheRec)
        {
        //  should either succeed or fail with update not prepared
        err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
        Assert(err == 0 || err == JET_errUpdateNotPrepared);
        pDB->JetCacheRec = FALSE;
        }

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl,
        (pDB->JetNewRec ? JET_prepInsert : DS_JET_PREPARE_FOR_REPLACE));

    pDB->JetRetrieveBits = JET_bitRetrieveCopy;

    // if this is a new record get its brand new  DNT and store it in pDB->DNT
    if (pDB->JetNewRec)
    {
        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
            dntid, &(pDB)->DNT, sizeof((pDB)->DNT),
            &actuallen, pDB->JetRetrieveBits, NULL);
    }

    if (pDB->fIsMetaDataCached) {
        // We shouldn't have any replication meta data hanging around from a
        // previous record.
        Assert(!"Lingering replication meta data found!");
        dbFreeMetaDataVector(pDB);
    }
    if (pDB->fIsLinkMetaDataCached) {
        // We shouldn't have any replication meta data hanging around from a
        // previous record.
        Assert(!"Lingering link replication meta data found!");
        THFreeEx( pDB->pTHS, pDB->pLinkMetaData );
        pDB->fIsLinkMetaDataCached = FALSE;
    }

    DPRINT1(2, "dbInitRec complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Update the permanent record from the copy buffer, complete the
   current transaction. Check for new record, this cannot be written
   as the name has not yet been added, leave in copy buffer.
*/
USHORT
DBUpdateRec(DBPOS FAR *pDB)
{
    DPRINT1(2, "DBUpdateRec entered DNT:%ld\n", (pDB)->DNT);

    Assert(VALID_DBPOS(pDB));

    if (pDB->JetNewRec || pDB->JetRetrieveBits != JET_bitRetrieveCopy)
        return 0;

    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

    pDB->JetRetrieveBits = 0;

    if (pDB->fFlushCacheOnUpdate) {
        // Flush this record from the read cache, now that other cursors can
        // see it by its new name.
        dbFlushDNReadCache(pDB, pDB->DNT);
        pDB->fFlushCacheOnUpdate = FALSE;
    }

    if (pDB->fIsMetaDataCached) {
        dbFreeMetaDataVector(pDB);
    }

    if (pDB->fIsLinkMetaDataCached) {
        THFreeEx( pDB->pTHS, pDB->pLinkMetaData );
        pDB->pLinkMetaData = FALSE;
        pDB->fIsLinkMetaDataCached = FALSE;
    }

    DPRINT1(2, "DBUpdateRec complete DNT:%ld\n", (pDB)->DNT);

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function invalidates the JetObjTbl copy buffer.
*/
USHORT
DBCancelRec(DBPOS FAR *pDB)
{
    ULONG err;

    DPRINT1(2, "DBCancelRec entered DNT:%ld\n", (pDB)->DNT);

    if (pDB->fIsMetaDataCached) {
        // Destroy any replicated meta data we've cached for the previous
        // record.

        dbFreeMetaDataVector(pDB);
    }

    if (pDB->fIsLinkMetaDataCached) {
        // Ditto
        THFreeEx( pDB->pTHS, pDB->pLinkMetaData );
        pDB->pLinkMetaData = FALSE;
        pDB->fIsLinkMetaDataCached = FALSE;
    }

    if (!pDB->JetRetrieveBits && !pDB->JetCacheRec)
        return 0;

    pDB->JetRetrieveBits = 0;
    pDB->JetCacheRec = FALSE;
    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    //  should either succeed or fail with update not prepared
    err = JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepCancel);
    Assert(err == 0 || err == JET_errUpdateNotPrepared);

    DPRINT1(2, "DBCancelRec complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

void
DBCreateRestart(
        DBPOS *pDB,
        PRESTART *ppRestart,
        DWORD SearchFlags,
        DWORD problem,
        RESOBJ *pResObj
        )
/*++

Build a restart argument.  We hand marshall the data, so we are sensitive to the
data structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    RESTART *pRestart;
    BYTE   rgbKey[DB_CB_MAX_KEY];
    DWORD  cbDBKeyCurrent = DB_CB_MAX_KEY;
    DWORD  NumKeyIndices = 0, NumDNTs = 0;
    DWORD  cdwAllocated;
    DWORD  dataIndex=0;
    DWORD  err;
    KEY_INDEX *pIndex;
    DWORD cdwCurrentKey, cdwHeader, cdwVLVCurrentKey;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX  *pPackedIndex;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;

    *ppRestart = NULL;

    // we are not interested in keeping the current key if we are on
    // a temp table or we are doing VLV
    if(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE && !pDB->Key.pVLV) {
        // Get the current bound key
        DBGetKeyFromObjTable(pDB,
                             rgbKey,
                             &cbDBKeyCurrent);
    }
    else {
        cbDBKeyCurrent = 0;
    }
    cdwCurrentKey = (cbDBKeyCurrent / sizeof(DWORD)) + 1;

    if (pVLV) {
        cdwVLVCurrentKey = (pVLV->cbCurrPositionKey / sizeof(DWORD)) + 1;
    }
    else {
        cdwVLVCurrentKey = 1;
    }

    // Figure out how much to allocate for the header portion.  Note that we
    // count in DWORDs to ease directly accessing the pRestart->data array.
    cdwHeader = (sizeof(PACKED_KEY_HEADER)/sizeof(DWORD));

    cdwAllocated = (cdwHeader + cdwCurrentKey + cdwVLVCurrentKey) * 2;
    pRestart = (RESTART *)
        THAllocEx(pTHS, sizeof(RESTART) + cdwAllocated * sizeof(DWORD));
    pPackedHeader =(PACKED_KEY_HEADER *)pRestart->data;

    pPackedHeader->NumIndices = 0;
    pPackedHeader->NumDNTs = 0;
    pPackedHeader->StartDNT = pDB->DNT;
    pPackedHeader->cbCurrentKey = cbDBKeyCurrent;
    pPackedHeader->ulSearchType = pDB->Key.ulSearchType;
    pPackedHeader->ulSorted = pDB->Key.ulSorted;
    pPackedHeader->indexType = pDB->Key.indexType;
    pPackedHeader->bOnCandidate = pDB->Key.bOnCandidate;
    pPackedHeader->dupDetectionType = pDB->Key.dupDetectionType;
    pPackedHeader->BaseResObj = *pResObj;
    pPackedHeader->BaseResObj.pObj = NULL;
    pPackedHeader->BaseGuid = pResObj->pObj->Guid;
    pPackedHeader->bOneNC = pDB->Key.bOneNC;
    pPackedHeader->SearchEntriesReturned = pDB->SearchEntriesReturned;
    pPackedHeader->SearchEntriesVisited = pDB->SearchEntriesVisited;
    pPackedHeader->fVLVSearch = pVLV != NULL;

    if (pVLV) {
        pRestart->restartType = NTDS_RESTART_VLV;
        pPackedHeader->ulVLVContentCount =  pVLV->contentCount;
        pPackedHeader->ulVLVTargetPosition = pVLV->currPosition;
        pPackedHeader->cbVLVCurrPositionKey = pVLV->cbCurrPositionKey;
        pPackedHeader->bUsingMAPIContainer = pVLV->bUsingMAPIContainer;
        pPackedHeader->MAPIContainerDNT = pVLV->MAPIContainerDNT;
    }
    else {
        pRestart->restartType = NTDS_RESTART_PAGED;
        pPackedHeader->ulVLVContentCount =  0;
        pPackedHeader->ulVLVTargetPosition = 0;
        pPackedHeader->cbVLVCurrPositionKey = 0;
        pPackedHeader->bUsingMAPIContainer = 0;
        pPackedHeader->MAPIContainerDNT = 0;
    }
    pPackedHeader->asqMode = pDB->Key.asqMode;
    pPackedHeader->ulASQLastUpperBound = pDB->Key.ulASQLastUpperBound;

    Assert(pDB->Key.ulSearchRootDnt == pResObj->DNT || pPackedHeader->bUsingMAPIContainer);
    Assert(pDB->Key.ulSearchRootPDNT == pResObj->PDNT);
    Assert(pDB->Key.ulSearchRootNcdnt == pResObj->NCDNT);

    memcpy(&pPackedHeader[1], rgbKey, cbDBKeyCurrent);

    dataIndex = cdwCurrentKey + cdwHeader;

    // now the VLV position
    if (pVLV && pVLV->cbCurrPositionKey) {
        memcpy(&pRestart->data[dataIndex], 
               pVLV->rgbCurrPositionKey, 
               pVLV->cbCurrPositionKey);

        dataIndex += cdwVLVCurrentKey;
    }

    // Now, do the index_keys.
    pIndex = pDB->Key.pIndex;
    while(pIndex) {
        DWORD  cbIndexName;
        DWORD  cdwBytes, cdwIndex;
        PUCHAR pBytes;

        NumKeyIndices++;
        // Figure out how much space this key index will take
        cbIndexName = strlen(pIndex->szIndexName);
        cdwBytes = (cbIndexName +
                    pIndex->cbDBKeyLower +
                    pIndex->cbDBKeyUpper) / sizeof(DWORD) + 1;
        cdwIndex = sizeof(PACKED_KEY_INDEX)/sizeof(DWORD);

        if(cdwAllocated < dataIndex + cdwBytes + cdwIndex) {
            // Need more space
            cdwAllocated = (cdwAllocated + cdwBytes + cdwIndex) * 2;
            pRestart = (RESTART *)
                THReAllocEx(pTHS,
                            pRestart,
                            sizeof(RESTART) + cdwAllocated * sizeof(DWORD));
        }

        pPackedIndex = (PACKED_KEY_INDEX *)&pRestart->data[dataIndex];

        pPackedIndex->bPDNT = pIndex->bIsPDNTBased;
        pPackedIndex->cbIndexName = cbIndexName;
        pPackedIndex->bIsSingleValued = pIndex->bIsSingleValued;
        pPackedIndex->bIsEqualityBased = pIndex->bIsEqualityBased;
        pPackedIndex->bIsForSort = pIndex->bIsForSort;
        pPackedIndex->cbDBKeyLower = pIndex->cbDBKeyLower;
        pPackedIndex->cbDBKeyUpper = pIndex->cbDBKeyUpper;

        // Now, unpack the bytes of the data.
        pBytes = (PUCHAR)&pPackedIndex[1];

        memcpy(pBytes, pIndex->szIndexName, cbIndexName);
        pBytes = &pBytes[cbIndexName];

        memcpy(pBytes, pIndex->rgbDBKeyLower, pIndex->cbDBKeyLower);
        pBytes = &pBytes[pIndex->cbDBKeyLower];

        memcpy(pBytes, pIndex->rgbDBKeyUpper, pIndex->cbDBKeyUpper);
        pBytes = &pBytes[pIndex->cbDBKeyUpper];

        dataIndex += cdwIndex + cdwBytes;

        pIndex = pIndex->pNext;
    }

    // OK, now marshall the DNTs we are tracking for duplicate detection or
    // Sorted table output (we might store either of these in a jet temp table,
    // or we might store DNTs for duplicate detection in a memory block.)
    if(pDB->JetSortTbl) {
        Assert (!pVLV);

        // Yes, we have a jet temp table.  Therefore, we need to marshall the
        // DNTs in that temp table.

        if(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE) {
            // == TEMP_TABLE_INDEX_TYPE means that the temp table holds sorted
            // candidates.  
            // Since it is not set, we are using the temp table to track objects
            // we have already returned or at least considered and rejected.  In
            // this case we need to marshall ALL the DNTs in the temp table.  If
            // we were holding sorted candidates, we don't need all the DNTs,
            // just the ones that are after the "currency" point (we've already
            // looked at the ones before "currency"
            err = JetMove(pDB->JetSessID,
                          pDB->JetSortTbl,
                          JET_MoveFirst,
                          0);
        }
        else {
            err = 0;
        }

        if(!err) {
            do {
                NumDNTs++;

                if(dataIndex >= cdwAllocated) {
                    cdwAllocated *= 2;
                    pRestart = THReAllocEx(pTHS,
                                           pRestart,
                                           (sizeof(RESTART) +
                                            (cdwAllocated * sizeof(DWORD))));
                }

                // OK, pull the DNT out of the sort table
                DBGetDNTSortTable (
                        pDB,
                        &pRestart->data[dataIndex]);
                
                if( (problem == PA_PROBLEM_SIZE_LIMIT) &&
                    (pRestart->data[dataIndex] == pDB->DNT)) {
                    // Actually, we don't put the start DNT in this list.  In
                    // the case of a restart for a size limit, we've verified
                    // that the current object should be returned.  Part of that
                    // verification meant checking this table for duplicates,
                    // which adds the value to the table.  So, we need to make
                    // sure that the object is NOT in the table, so that when we
                    // restart, it still passes the duplicate test.
                    NumDNTs--;
                }
                else {
                    dataIndex++;
                }
                err = JetMove(pDB->JetSessID,
                              pDB->JetSortTbl,
                              JET_MoveNext,
                              0);

            } while (!err);
        }
    }
    else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        DWORD iDNTSave;
        DWORD cDNTSave;

        // save all entries for ASQ or VLV
        if (pDB->Key.asqRequest.fPresent || pDB->Key.pVLV) {
            iDNTSave = 0;
            cDNTSave = pDB->Key.cdwCountDNTs;
        }
        // save only the unvisited entries for sorted search
        else {
            iDNTSave = (pDB->Key.currRecPos + 1) - 1;
            cDNTSave = pDB->Key.cdwCountDNTs - iDNTSave;
        }
        
        if( (dataIndex + cDNTSave) >= cdwAllocated) {
            cdwAllocated = (dataIndex + cDNTSave) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (sizeof(RESTART) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        memcpy (&pRestart->data[dataIndex], 
                pDB->Key.pDNTs + iDNTSave, 
                cDNTSave * sizeof (DWORD));

        dataIndex += cDNTSave;
        NumDNTs = cDNTSave;
    }
    else if(pDB->Key.cDupBlock) {
        DWORD i;

        Assert (!pVLV && "VLV search should not use DupDetection");

        // We are storing some DNTs for duplicate detection in an in-memory
        // duplicate detection block.  Marshall them.
        if(dataIndex + pDB->Key.cDupBlock >= cdwAllocated) {
            cdwAllocated =
                (max(cdwAllocated, dataIndex + pDB->Key.cDupBlock)) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (sizeof(RESTART) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        // First, make sure we've allocated enough memory.
        for(i=0;i<pDB->Key.cDupBlock;i++) {
            NumDNTs++;

            pRestart->data[dataIndex] = pDB->Key.pDupBlock[i];

            if(problem == PA_PROBLEM_SIZE_LIMIT &&
               pRestart->data[dataIndex] == pDB->DNT ) {
                // Actually, we don't put the start DNT in this list.  In
                // the case of a restart for a size limit, we've verified
                // that the current object should be returned.  Part of that
                // verification meant checking this table for duplicates,
                // which adds the value to the table.  So, we need to make
                // sure that the object is NOT in the table, so that when we
                // restart, it still passes the duplicate test.
                NumDNTs--;
            }
            else {
                dataIndex++;
            }
        }
    } else if (pDB->Key.plhtDup ){
        LHT_STAT    statLHT;
        LHT_POS     posLHT;
        ULONG       DNT;
        
        Assert (!pVLV && "VLV search should not use DupDetection");

        // We are storing some DNTs for duplicate detection in a hash table.
        // Marshall them.
        LhtQueryStatistics(
            pDB->Key.plhtDup,
            &statLHT );
        
        if(dataIndex + statLHT.cEntry >= cdwAllocated) {
            cdwAllocated =
                (DWORD)(max(cdwAllocated, dataIndex + statLHT.cEntry)) * 2;
            pRestart = THReAllocEx(pTHS,
                                   pRestart,
                                   (sizeof(RESTART) +
                                    (cdwAllocated * sizeof(DWORD))));
        }

        // First, make sure we've allocated enough memory.
        LhtMoveBeforeFirst(
            pDB->Key.plhtDup,
            &posLHT);
        while (LhtMoveNext(&posLHT) == LHT_errSuccess) {
            LhtRetrieveEntry(
                &posLHT,
                &DNT);

            NumDNTs++;

            pRestart->data[dataIndex] = DNT;

            if(problem == PA_PROBLEM_SIZE_LIMIT &&
               pRestart->data[dataIndex] == pDB->DNT ) {
                // Actually, we don't put the start DNT in this list.  In
                // the case of a restart for a size limit, we've verified
                // that the current object should be returned.  Part of that
                // verification meant checking this table for duplicates,
                // which adds the value to the table.  So, we need to make
                // sure that the object is NOT in the table, so that when we
                // restart, it still passes the duplicate test.
                NumDNTs--;
            }
            else {
                dataIndex++;
            }
        }
    }


    pRestart->structLen = sizeof(RESTART) + (dataIndex * sizeof(DWORD));
    pPackedHeader =(PACKED_KEY_HEADER *)pRestart->data;

    pPackedHeader->NumIndices = NumKeyIndices;
    pPackedHeader->NumDNTs = NumDNTs;

    *ppRestart = THReAllocEx(pTHS,
                             pRestart,
                             (sizeof(RESTART) +
                              (dataIndex * sizeof(DWORD))));
}


DWORD
DBCreateRestartForSAM(
        DBPOS    *pDB,
        PRESTART *ppRestart,
        eIndexId  idIndexForRestart,
        RESOBJ   *pResObj,
        DWORD     SamAccountType
        )
/*++

  Build a restart argument to allow SAM to make a call that looks like a
  restart.  We hand marshall the data, so we are sensitive to the data
  structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

  INPUT
    pDB - the DBPOS to use
    idIndexForRestart - index to use for restarting. 
    pResObj - the current Result Object
    SamAccountType - the AccountType that we are using
  
  OUTPUT
    ppRestart- where to put the Restart data
  
  RETURN
    0 on success, otherwise error (Jet error or DB_ERR_BAD_INDEX).

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    DWORD       cDwordSize=0;
    DWORD       cdwCurrentKey, cdwIndexKeys, cdwHeader, cdwIndex;
    DWORD       StartDNT;
    ULONG       SamAccountTypeUpperBound;
    ULONG       SamAccountTypeLowerBound;
    CHAR        rgbKeyCurrent[DB_CB_MAX_KEY];
    DWORD       cbDBKeyCurrent = DB_CB_MAX_KEY;
    CHAR        rgbDBKeyUpper[DB_CB_MAX_KEY];
    DWORD       cbDBKeyUpper = DB_CB_MAX_KEY;
    CHAR        rgbDBKeyLower[DB_CB_MAX_KEY];
    DWORD       cbDBKeyLower = DB_CB_MAX_KEY;
    DWORD       cbIndexName;
    INDEX_VALUE IV[3];
    DWORD       dwError;
    PUCHAR      pBytes;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX *pPackedIndex;
    char        *szIndexForRestart;

    *ppRestart = NULL;

    // Get the current DNT
    StartDNT = pDB->DNT;

    // size of the index name.
    if (idIndexForRestart == Idx_NcAccTypeName) {
        szIndexForRestart = SZ_NC_ACCTYPE_NAME_INDEX;
        cbIndexName = strlen(szIndexForRestart);
    }
    else {
        // we don't support other indexes for now.
        // so return a error
        cbIndexName = 0;    //avoid C4701
        return DB_ERR_BAD_INDEX;
    }

    // Get the current Key.
    DBGetKeyFromObjTable(pDB,
                         rgbKeyCurrent,
                         &cbDBKeyCurrent);


    //
    // Get the upper bound key. This requires seeking to the last
    // possible position in the current Index that can still Satisfy
    // us
    //

    SamAccountTypeUpperBound = SamAccountType + 1;
    IV[0].pvData = &pResObj->NCDNT;
    IV[0].cbData = sizeof(ULONG);
    IV[1].pvData = &SamAccountTypeUpperBound;
    IV[1].cbData = sizeof(ULONG);

    if(dwError = DBSeek(pDB, IV, 2, DB_SeekLE)) {
        return dwError;
    }

    //
    // Make the upper bound Key, we are either positioned on the last object
    // that is acceptable or the first object that is uacceptable
    //

    DBGetKeyFromObjTable(pDB,
                         rgbDBKeyUpper,
                         &cbDBKeyUpper);


    //
    // Get the lower bound key. First position on the first object
    // with the correct Sam account type value
    //

    SamAccountTypeLowerBound = SamAccountType - 1;
    IV[0].pvData = &pResObj->NCDNT;
    IV[0].cbData = sizeof(ULONG);
    IV[1].pvData = &SamAccountTypeLowerBound;
    IV[1].cbData = sizeof(ULONG);

    if(dwError = DBSeek(pDB, IV, 2, DB_SeekGE)) {
        return dwError;
    }

    //
    // Get the lower bound key. For purpose of the Restart Structure
    //

    DBGetKeyFromObjTable(pDB,
                         rgbDBKeyLower,
                         &cbDBKeyLower);


    // Now, allocate the size of the structure we need. Calculate the
    // DWORDS or DWORD equivalents we need.  We use DWORDs instead of bytes to
    // aid the process of leaving things aligned on DWORD boundaries.

    // First, the size of the current key.  Add one to the result of the
    // division to handle those cases where have some bytes left over (e.g. 4,
    // 5, 6, and 7 bytes end up using 2 DWORDs, even though 4 bytes only really
    // needs 1 DWORD. This calculation is faster, and not too much of a space
    // waste.
    cdwCurrentKey = cbDBKeyCurrent/sizeof(DWORD) + 1;

    // Next, the size of the packed index name, upper, and lower bound keys.
    cdwIndexKeys = (cbIndexName + cbDBKeyUpper + cbDBKeyLower)/sizeof(DWORD) +1;


    // The size of the constant header portion
    cdwHeader = sizeof(PACKED_KEY_HEADER)/sizeof(DWORD);

    // The size of the constant Key Index portion;
    cdwIndex = sizeof(PACKED_KEY_INDEX)/sizeof(DWORD);

    // The whole size is the sum of those four sizes.
    cDwordSize = cdwHeader + cdwIndex + cdwCurrentKey + cdwIndexKeys;

    *ppRestart = THAllocEx(pTHS, sizeof(RESTART) + (cDwordSize * sizeof(DWORD)));
    (*ppRestart)->structLen = sizeof(RESTART) + (cDwordSize * sizeof(DWORD));

    pPackedHeader = (PACKED_KEY_HEADER *)(*ppRestart)->data;

    // OK, fill in the structure.
    pPackedHeader->NumIndices = 1;
    pPackedHeader->NumDNTs = 0;
    pPackedHeader->StartDNT = StartDNT;
    pPackedHeader->cbCurrentKey = cbDBKeyCurrent;
    pPackedHeader->ulSearchType = SE_CHOICE_WHOLE_SUBTREE;
    pPackedHeader->ulSorted = SORT_NEVER;
    pPackedHeader->indexType = GENERIC_INDEX_TYPE;
    pPackedHeader->bOnCandidate = FALSE;
    pPackedHeader->dupDetectionType = DUP_NEVER;
    pPackedHeader->BaseResObj = *pResObj;
    pPackedHeader->BaseResObj.pObj = NULL;
    pPackedHeader->BaseGuid = pResObj->pObj->Guid;
    pPackedHeader->bOneNC = TRUE;
    pPackedHeader->SearchEntriesReturned = pDB->SearchEntriesReturned;
    pPackedHeader->SearchEntriesVisited = pDB->SearchEntriesVisited;

    memcpy(&pPackedHeader[1], rgbKeyCurrent, cbDBKeyCurrent);

    // Now, the key index
    pPackedIndex = (PACKED_KEY_INDEX *)
        &(*ppRestart)->data[cdwHeader + cdwCurrentKey];

    // How many bytes in the index name?
    pPackedIndex->bPDNT = FALSE;
    pPackedIndex->bIsSingleValued = TRUE;
    pPackedIndex->bIsEqualityBased = FALSE;
    pPackedIndex->bIsForSort = FALSE;
    pPackedIndex->cbIndexName = cbIndexName;
    pPackedIndex->cbDBKeyLower = cbDBKeyLower;
    pPackedIndex->cbDBKeyUpper = cbDBKeyUpper;

    // Now, pack the bytes of the data.
    pBytes = (PUCHAR)&pPackedIndex[1];

    memcpy(pBytes, szIndexForRestart, cbIndexName);
    pBytes = &pBytes[cbIndexName];

    memcpy(pBytes, rgbDBKeyLower, cbDBKeyLower);
    pBytes = &pBytes[cbDBKeyLower];

    memcpy(pBytes, rgbDBKeyUpper, cbDBKeyUpper);

    return 0;

}

RESOBJ *
ResObjFromRestart(THSTATE *pTHS,
                  DSNAME  * pDN,
                  RESTART * pRestart
                  )
{
    PACKED_KEY_HEADER *pPackedHeader;
    RESOBJ * pResObj;

    pPackedHeader = (PACKED_KEY_HEADER *)pRestart->data;

    pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
    *pResObj = pPackedHeader->BaseResObj;
    pResObj->pObj = pDN;
    if (fNullUuid(&pDN->Guid)) {
        pDN->Guid = pPackedHeader->BaseGuid;
    }
    else {
        Assert(0 == memcmp(&pDN->Guid,
                           &pPackedHeader->BaseGuid,
                           sizeof(GUID)));
    }

    return pResObj;
}

DWORD
dbUnMarshallRestart (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        BYTE *pDBKeyCurrent,
        DWORD SearchFlags, 
        DWORD *cbDBKeyCurrent,
        DWORD *StartDNT
        )

/*++

  Hand unmarshall the data packed into the restart arg.  Note that we are
  sensitive to the data structures PACKED_KEY_HEADER and PACKED_KEY_INDEX

--*/
{
    THSTATE   *pTHS=pDB->pTHS;
    ULONG     *pData = (ULONG *)pArgRestart->data;
    PUCHAR     pBytes = NULL;
    KEY_INDEX *pIndex, **pIndexPrevNext;
    ULONG      ulTemp, NumKeyIndices, NumDNTs, cbIndexName, cbBytes, i;
    ATTCACHE  *pAC;
    PACKED_KEY_HEADER *pPackedHeader;
    PACKED_KEY_INDEX  *pPackedIndex;
    ULONG     *pEnd;
    DWORD     err;
    BOOL      fVLVsearch;
    VLV_SEARCH   *pVLV;
    DWORD     SortFlags = 0;

    Assert(VALID_DBPOS(pDB));

    // We've been seeing some corrupted restarts, so assert that the
    // buffer seems ok.  Further tests are included below for free builds.
    Assert(IsValidReadPointer(pArgRestart, pArgRestart->structLen));
    pEnd = pArgRestart->data + (pArgRestart->structLen/sizeof(ULONG));

    // Set up the key

    pPackedHeader = (PACKED_KEY_HEADER *)pArgRestart->data;

    NumKeyIndices = pPackedHeader->NumIndices;
    NumDNTs = pPackedHeader->NumDNTs;
    *StartDNT = pPackedHeader->StartDNT;
    *cbDBKeyCurrent = pPackedHeader->cbCurrentKey;
    pDB->Key.ulSearchType = pPackedHeader->ulSearchType;
    pDB->Key.ulSearchRootDnt = pPackedHeader->BaseResObj.DNT;
    pDB->Key.ulSearchRootPDNT = pPackedHeader->BaseResObj.PDNT;
    pDB->Key.ulSearchRootNcdnt = pPackedHeader->BaseResObj.NCDNT;
    pDB->Key.bOneNC = pPackedHeader->bOneNC;
    pDB->Key.ulSorted = pPackedHeader->ulSorted;
    pDB->Key.indexType = pPackedHeader->indexType;
    pDB->Key.bOnCandidate = pPackedHeader->bOnCandidate;
    pDB->Key.dupDetectionType = pPackedHeader->dupDetectionType;
    pDB->SearchEntriesReturned = pPackedHeader->SearchEntriesReturned;
    pDB->SearchEntriesVisited = pPackedHeader->SearchEntriesVisited;
    
    fVLVsearch = pPackedHeader->fVLVSearch;
    if (fVLVsearch) {
        Assert (pDB->Key.pVLV);
        pVLV = pDB->Key.pVLV;
        pVLV->contentCount = pPackedHeader->ulVLVContentCount;
        pVLV->currPosition = pPackedHeader->ulVLVTargetPosition;
        pVLV->cbCurrPositionKey = pPackedHeader->cbVLVCurrPositionKey;
        pVLV->bUsingMAPIContainer = pPackedHeader->bUsingMAPIContainer;
        pVLV->MAPIContainerDNT = pPackedHeader->MAPIContainerDNT;

        if (pVLV->bUsingMAPIContainer) {
            pDB->Key.ulSearchRootDnt = pVLV->MAPIContainerDNT;
            pDB->Key.ulSearchType = SE_CHOICE_IMMED_CHLDRN;
        }
    }

    // overwrite asqMode, to make sure we use what we stored
    pDB->Key.asqMode = pPackedHeader->asqMode;  
    pDB->Key.ulASQLastUpperBound = pPackedHeader->ulASQLastUpperBound;

    if (NumKeyIndices * sizeof(PACKED_KEY_INDEX) > pArgRestart->structLen) {
        // There is no way that this restart can be valid, because it's
        // not even long enough to hold its fixed data, much less any
        // variable data that goes with it.
        return DB_ERR_BUFFER_INADEQUATE;
    }

    if(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE || 
       pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE ||
       fVLVsearch) {
        // force dbMoveToNextSeachCandidate to to a JET_MoveFirst, not a
        // JET_MoveNext.
        pDB->Key.fSearchInProgress = FALSE;
    }
    else {
        pDB->Key.fSearchInProgress = TRUE;
    }

    pData = (DWORD *)(&pPackedHeader[1]);
    if (pEnd < (pData + *cbDBKeyCurrent/sizeof(DWORD))) {
        return DB_ERR_BUFFER_INADEQUATE;
    }
    memcpy(pDBKeyCurrent, pData, *cbDBKeyCurrent);
    pData = &pData[(*cbDBKeyCurrent / sizeof(DWORD)) + 1];

    // now the VLV position
    if (pDB->Key.pVLV && pDB->Key.pVLV->cbCurrPositionKey) {
        if (pEnd < (pData + pDB->Key.pVLV->cbCurrPositionKey/sizeof(DWORD))) {
            return DB_ERR_BUFFER_INADEQUATE;
        }
        memcpy(pDB->Key.pVLV->rgbCurrPositionKey, pData, pDB->Key.pVLV->cbCurrPositionKey);
        pData = &pData[(pDB->Key.pVLV->cbCurrPositionKey / sizeof(DWORD)) + 1];
    }

    // Now, the Key Indices.
    pPackedIndex = (PACKED_KEY_INDEX *) pData;

    pDB->Key.pIndex = NULL;
    pIndexPrevNext = &pDB->Key.pIndex;
    while(NumKeyIndices) {
        // Test for buffer overrun
        if (pEnd < (pData + sizeof(PACKED_KEY_INDEX)/sizeof(DWORD))) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        // Unpack key indices
        pIndex = dbAlloc(sizeof(KEY_INDEX));
        pIndex->pNext = NULL;
        *pIndexPrevNext = pIndex;
        pIndexPrevNext = &(pIndex->pNext);

        // We don't bother storing this.
        pIndex->ulEstimatedRecsInRange = 0;

        pIndex->bIsPDNTBased = pPackedIndex->bPDNT;
        pIndex->bIsSingleValued = pPackedIndex->bIsSingleValued;
        pIndex->bIsEqualityBased = pPackedIndex->bIsEqualityBased;
        pIndex->bIsForSort = pPackedIndex->bIsForSort;
        cbIndexName = pPackedIndex->cbIndexName;
        pIndex->cbDBKeyLower = pPackedIndex->cbDBKeyLower;
        pIndex->cbDBKeyUpper = pPackedIndex->cbDBKeyUpper;

        // Now, unpack the bytes of the data.
        pBytes = (PUCHAR)&pPackedIndex[1];
        cbBytes = (cbIndexName +
                   pIndex->cbDBKeyUpper +
                   pIndex->cbDBKeyLower  );
        if ((PUCHAR)pEnd < (pBytes + cbBytes)) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        pIndex->szIndexName = dbAlloc(cbIndexName+1);
        memcpy(pIndex->szIndexName, pBytes, cbIndexName);
        pIndex->szIndexName[cbIndexName] = 0;
        pBytes = &pBytes[cbIndexName];

        pIndex->rgbDBKeyLower = dbAlloc(pIndex->cbDBKeyLower);
        memcpy(pIndex->rgbDBKeyLower, pBytes, pIndex->cbDBKeyLower);
        pBytes = &pBytes[pIndex->cbDBKeyLower];

        pIndex->rgbDBKeyUpper = dbAlloc(pIndex->cbDBKeyUpper);
        memcpy(pIndex->rgbDBKeyUpper, pBytes, pIndex->cbDBKeyUpper);
        pBytes = &pBytes[pIndex->cbDBKeyUpper];

        // Now, adjust pData
        pData = (DWORD *)(&pPackedIndex[1]);
        pData = &pData[cbBytes/sizeof(DWORD) + 1];
        pPackedIndex = (PACKED_KEY_INDEX *)pData;

        // Keep pData aligned to ULONG packing
        NumKeyIndices--;
    }

    pData = (DWORD *)pPackedIndex;

    if (pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE ||
        pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        if ( (pData + NumDNTs) > pEnd ) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        // force TEMP_TABLE_INDEX_TYPE to become TEMP_TABLE_MEMORY_ARRAY_TYPE
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;

        if (pDB->Key.pDNTs) {
            pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, NumDNTs * sizeof(DWORD));
        }
        else {
            pDB->Key.pDNTs = THAllocEx(pTHS, NumDNTs * sizeof(DWORD));
        }
        pDB->Key.cdwCountDNTs = NumDNTs;


        memcpy (pDB->Key.pDNTs,
                pData,
                NumDNTs * sizeof (DWORD));

        pData += NumDNTs;
    }
    else {
        switch (pDB->Key.dupDetectionType) {
        case DUP_NEVER:
            // We're not actually tracking duplicates.  We'd better not have any
            // DNTs.
            Assert(!NumDNTs);
            break;

        case DUP_HASH_TABLE:
            Assert (!fVLVsearch);
            // We're tracking duplicates in a hash table.  Set it up.
            dbSearchDuplicateCreateHashTable( &pDB->Key.plhtDup );

            for(i=0;i<NumDNTs;i++) {
                LHT_ERR     errLHT;
                LHT_POS     posLHT;
                
                errLHT = LhtFindEntry(
                            pDB->Key.plhtDup,
                            &pData[i],
                            &posLHT);
                Assert( errLHT == LHT_errSuccess );
                errLHT = LhtInsertEntry(
                            &posLHT,
                            &pData[i]);
                if (errLHT != LHT_errSuccess) {
                    Assert(errLHT == LHT_errOutOfMemory);
                    RaiseDsaExcept(
                        DSA_MEM_EXCEPTION,
                        0,
                        0,
                        DSID(FILENO, __LINE__),
                        DS_EVENT_SEV_MINIMAL);
                }
            }
            break;

        case DUP_MEMORY:
            Assert (!fVLVsearch);
            // We're tracking duplicates in a memory block.  Set it up.
            pDB->Key.pDupBlock = THAllocEx(pTHS, DUP_BLOCK_SIZE * sizeof(DWORD));
            pDB->Key.cDupBlock = NumDNTs;
            memcpy(pDB->Key.pDupBlock, pData, NumDNTs * sizeof(DWORD));
            break;

        default:
            // Huh?
            break;
        }
    }
    return 0;
}

#if DBG

BOOL IsValidDBPOS(DBPOS * pDB)
{
    THSTATE *pTHS = pTHStls;  // For assertion comparison
    DWORD    cTicks;

    // A null DBPOS is never valid
    if (NULL == pDB)
      return FALSE;

    // The DBPOS should be from this thread.
    if (pTHS != pDB->pTHS) {
        return FALSE;
    }

    if (pDB->fHidden) {
        // There should only be one hidden DBPOS
        if (pDB != pDBhidden) {
            return FALSE;
        }
    }
    else {
        // A normal, non-hidden DBPOS, which has links to its THSTATE info.

        // Except for the hidden DBPOS, our transaction levels should match
        // what out THSTATE thinks we have.
        if ((pDB->TransactionLevelAtOpen + pDB->transincount)
            > pTHS->JetCache.transLevel) {
            return FALSE;
        }

        if (0 != pTHS->JetCache.transLevel) {
            cTicks = GetTickCount() - pTHS->JetCache.cTickTransLevel1Started;
            Assert((cTicks <= gcMaxTicksAllowedForTransaction)
                   && "This transaction has been open for longer than it should "
                      "have been under normal operation.  "
                      "Please contact dsdev.");
        }
    }

    // There are only two valid values for this field, make sure we have
    // one of them.
    if (   (pDB->JetRetrieveBits != 0)
        && (pDB->JetRetrieveBits != JET_bitRetrieveCopy))
      return FALSE;

    return TRUE;

}
#endif


// Put the knowlege of how to create MAPI string DNs in one place.
#define MAPI_DN_TEMPLATE_W L"/o=NT5/ou=00000000000000000000000000000000/cn=00000000000000000000000000000000"
#define MAPI_DN_TEMPLATE_A "/o=NT5/ou=00000000000000000000000000000000/cn=00000000000000000000000000000000"
#define DOMAIN_GUID_OFFSET 10
#define OBJECT_GUID_OFFSET 46

DWORD
DBMapiNameFromGuid_W (
        wchar_t *pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        )
/*++
Description
    Given a buffer to hold a unicode value, and a count of chars in that buffer,
    and a guid, fill in that buffer with a MAPI DN.  Returns the length of the
    buffer (in characters.)  Checks the buffer size against the length, and if
    the buffer is not long enough, returns a length 0 (and an unmodified
    buffer).
--*/
{
    DWORD i;
    PUCHAR pucGuidObj = (PUCHAR) pGuidObj;
    PUCHAR pucGuidNC = (PUCHAR) pGuidNC;

    *pSize = (sizeof(MAPI_DN_TEMPLATE_A)-1);

    if(countChars <  *pSize) {
        // Hey, we don't have room.
        return 0;
    }

    memcpy(pStringDN, MAPI_DN_TEMPLATE_W, sizeof(MAPI_DN_TEMPLATE_W));
    // write in the domain and object guids.
    for(i=0;i<sizeof(GUID);i++) {
        wsprintfW(&(pStringDN[(2*i) + DOMAIN_GUID_OFFSET]),L"%02X",
                  pucGuidNC[i]);
        wsprintfW(&(pStringDN[(2*i) + OBJECT_GUID_OFFSET]),L"%02X",
                  pucGuidObj[i]);
    }
    pStringDN[OBJECT_GUID_OFFSET-4]=L'/';
    return (sizeof(MAPI_DN_TEMPLATE_A)-1);
}
DWORD
DBMapiNameFromGuid_A (
        PUCHAR pStringDN,
        DWORD countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        )
/*++
Description
    Given a buffer to hold a 8 bit value, and a count of chars in that buffer,
    and a guid, fill in that buffer with a MAPI DN.  Returns the length of the
    buffer (in characters.)  Checks the buffer size against the length, and if
    the buffer is not long enough, returns a length 0 (and an unmodified
    buffer).
--*/
{
    DWORD i;
    PUCHAR pucGuidObj = (PUCHAR) pGuidObj;
    PUCHAR pucGuidNC = (PUCHAR) pGuidNC;

    *pSize = (sizeof(MAPI_DN_TEMPLATE_A)-1);

    if(countChars <  *pSize) {
        // Hey, we don't have room.
        return 0;
    }

    memcpy(pStringDN, MAPI_DN_TEMPLATE_A, sizeof(MAPI_DN_TEMPLATE_A));
    // write in the domain and object guids.
    for(i=0;i<sizeof(GUID);i++) {
        wsprintf(&(pStringDN[(2*i) + DOMAIN_GUID_OFFSET]),"%02X",
                 pucGuidNC[i]);
        wsprintf(&(pStringDN[(2*i) + OBJECT_GUID_OFFSET]),"%02X",
                 pucGuidObj[i]);
    }
    pStringDN[OBJECT_GUID_OFFSET-4]='/';
    return (sizeof(MAPI_DN_TEMPLATE_A)-1);
}

DWORD
DBGetGuidFromMAPIDN (
        PUCHAR pStringDN,
        GUID *pGuid
        )
/*++
Description
    Given a string DN and a pointer to a guid, fill in the guid based on the
    string DN if the String DN is a properly formatted NT5 default MAPI DN.
    Returns 0 on success, an error code otherwise.
--*/
{
    CHAR        acTmp[3];
    PUCHAR      pTemp, myGuid = (PUCHAR)pGuid;
    DWORD       i;

    if(strlen(pStringDN) != sizeof(MAPI_DN_TEMPLATE_A) - 1) {
        // Nope, we don't know what this thing is.
        return DB_ERR_UNKNOWN_ERROR;
    }

    // See if its ours
    if(_strnicmp(pStringDN, "/o=NT5/ou=", 10)) {
        // Nope, we don't know what this thing is.
        return DB_ERR_UNKNOWN_ERROR;
    }

    // OK, make sure the next 32 characters are a guid
    for(i=10;i<42;i++) {
        if(!isxdigit(pStringDN[i])) {
            // Nope
            return DB_ERR_UNKNOWN_ERROR;
        }
    }

    // Check to see if the name has a GUID in an ok place
    if (pStringDN[42] == '\0') {
        // The name has been truncated, and we want the domain GUID
        pTemp = &pStringDN[10];
    }
    else if(_strnicmp(&pStringDN[42],"/cn=",4)) {
        // Something we don't recognize
        return DB_ERR_UNKNOWN_ERROR;
    }
    else {
        // A normal three part name
        pTemp = &pStringDN[OBJECT_GUID_OFFSET];
    }

    // OK, the string looks ok, it is ours if the GUID is there

    acTmp[2]=0;
    for(i=0;i<16;i++) {
        acTmp[0] = (CHAR)tolower(*pTemp++);
        acTmp[1] = (CHAR)tolower(*pTemp++);
        if(isxdigit(acTmp[0]) && isxdigit(acTmp[1])) {
            myGuid[i] = (UCHAR)strtol(acTmp, NULL, 16);
        }
        else {
            return DB_ERR_UNKNOWN_ERROR;  // non-hex digit
        }
    }
    return 0;
}

// defined in the MAPI head.
extern DWORD
ABDispTypeFromClass (
        ATTRTYP objClass
        );

DWORD
dbMapiTypeFromObjClass (
        ATTRTYP objClass,
        wchar_t *pTemp
        )
{

    wsprintfW(pTemp, L"%02X", ABDispTypeFromClass(objClass));

    return 0;
}

void
DBNotifyReplicasCurrDbObj (
                           DBPOS *pDB,
                           BOOL fUrgent
                           )
/*++
Description:

    Notify the replicas of the NC of the object being modified that they need
    to do inbound replication.

    First, here we queue the NCDNT for the object on a per-thread notification
    list.

    Later, when the transaction commits in DbTransOut, we enqueue the NCDNT
    for the replica notification thread using NotifyReplica(). That routine
    dequeues the items and does the actual notification in mdnotify.c.

    Find the NCDNT for the object and queue it on a list inside the thread
    state.  pNotifyNCs list is a sorted, single linked list

    Postpone checks on the suitability of the NC (ie does it have replicas)
    until later.

Arguments:

    pDB - DBPOS positioned on the object
    fUrgent - Whether replication should occur immediately, or not

Return Values:

    None.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    PNCnotification pEntry, pPrev, pNew;
    ULONG ncdnt, err;
    SYNTAX_INTEGER it;

    DPRINT3(1,"DBNotifyreplicasCurrent, DNT=%d, NCDNT=%d, Urgent = %d\n",
            pDB->DNT, pDB->NCDNT, fUrgent);

    Assert(VALID_DBPOS(pDB));

    // do nothing if in singleusermode
    if (pTHS->fSingleUserModeThread) {
        return;
    }

    // Calculate the notify NCDNT of the object.
    // If the object is a NC_HEAD, use itself for its NCDNT
    // Ignore uninstantiated objects (pure subrefs)

    if (err = DBGetSingleValue( pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }
    if (it & IT_UNINSTANT) {
        return;
    } else if (it & IT_NC_HEAD) {
        ncdnt = pDB->DNT;
    } else {
        Assert( pDB->NCDNT );
        ncdnt = pDB->NCDNT;
    }

    // Locate existing entry in sorted list
    for( pPrev = NULL, pEntry = (PNCnotification) pTHS->pNotifyNCs;
        (pEntry != NULL);
        pPrev = pEntry, pEntry = pEntry->pNext ) {

        if (pEntry->ulNCDNT > ncdnt) {
            break;
        } else if (pEntry->ulNCDNT == ncdnt) {
            // Entry is already present in the list
            pEntry->fUrgent |= fUrgent; // Promote if needed
            return;
        }
    }

    // Enqueue a new notification
    pNew = (PNCnotification) dbAlloc( sizeof( NCnotification ) );
    pNew->ulNCDNT = ncdnt;
    pNew->fUrgent = fUrgent;
    pNew->pNext = pEntry;
    if (pPrev == NULL) {
        pTHS->pNotifyNCs = pNew;
    } else {
        pPrev->pNext = pNew;
    }

} /* DBNotifyReplicasCurrent */

void
DBNotifyReplicas (
                  DSNAME *pObj,
                  BOOL fUrgent
                  )
/*++
Description:

    Notify the replicas of the NC of the object being modified that they need
    to do inbound replication.

    See above routine.

    This routine is called with a DSNAME to be found

Arguments:

    pObj - DSNAME of object, whose NC is to be notified
    fUrgent - Whether replication should occur immediately, or not

Return Values:

    None.

--*/
{
    DBPOS *pDB;

    DPRINT2(1,"DBNotifyreplicas, DN='%ws', Urgent Flag = %d\n",
            pObj->StringName, fUrgent);

    // Open a new DB stream
    DBOpen2(FALSE, &pDB);
    __try
    {
        // Position on the object, verify existance
        if (DBFindDSName(pDB, pObj)) {
            __leave;
        }

        DBNotifyReplicasCurrDbObj( pDB, fUrgent );
    }
    __finally
    {
        DBClose(pDB, TRUE);
    }
} /* DBNotifyReplicas */

// convert from jet pages to megabytes by shifting right 7 (* 8k / 1mb)
#if JET_PAGE_SIZE != (8 * 1024)
    Fix the macro that converts jet pages to megabytes
#else
#define JET_PAGES_TO_MB(_pages) ((_pages) >> (20 - 13))
#endif
void
DBDefrag(DBPOS *pDB)
/*++
 * Description:
 *    Invokes JET online defragmentation.  We don't have to wait for anything
 *    to finish, because the OLD thread will quietly exit when it finishes
 *    or when JetTerm is called, whichever comes first.  We tell OLD to make
 *    one pass through the database, but to only run for at most half a
 *    garbage collection interval, just so we can be sure that it doesn't
 *    run forever.
 *
 * Arguments:
 *    pDB  - DBPOS containing session to use
 *
 * Return value:
 *    none
 */
{
    JET_ERR err;
    unsigned long ulFreePages1, ulFreePages2, ulAllocPages;
    unsigned long ulFreeMB, ulAllocMB;
    unsigned long ulPasses = 1;
    unsigned long ulSeconds = min( gulGCPeriodSecs/2, csecOnlineDefragPeriodMax );

    // Log an event with free space vs. allocated space

    // Allocated space
    err = JetGetDatabaseInfo(pDB->JetSessID,
                             pDB->JetDBID,
                             &ulAllocPages,
                             sizeof(ulAllocPages),
                             JET_DbInfoSpaceOwned);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetDatabaseInfo(DbinfoSpaceOwned) ==> %d\n", err);
        goto DoDefrag;
    }

    // Free space available in the database
    err = JetGetDatabaseInfo(pDB->JetSessID,
                             pDB->JetDBID,
                             &ulFreePages1,
                             sizeof(ulFreePages1),
                             JET_DbInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetDatabaseInfo(DbInfoSpaceAvailable) ==> %d\n", err);
        goto DoDefrag;
    }

    // Plus free space available in the object table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetObjTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(ObjTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        goto DoDefrag;
    }
    ulFreePages1 += ulFreePages2;

    // Plus free space available in the link table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetLinkTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(LinkTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        goto DoDefrag;
    }
    ulFreePages1 += ulFreePages2;

    // Plus free space available in the SD table
    err = JetGetTableInfo(pDB->JetSessID,
                          pDB->JetSDTbl,
                          &ulFreePages2,
                          sizeof(ulFreePages2),
                          JET_TblInfoSpaceAvailable);
    if (err != JET_errSuccess) {
        DPRINT1(0, "JetGetTableInfo(SDTbl, TblInfoSpaceAvailable) ==> %d\n", err);
        goto DoDefrag;
    }
    ulFreePages1 += ulFreePages2;

    // Log the event for free vs. allocated space
    ulFreeMB = JET_PAGES_TO_MB(ulFreePages1);
    ulAllocMB = JET_PAGES_TO_MB(ulAllocPages);
    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_DB_FREE_SPACE,
             szInsertUL(ulFreeMB),
             szInsertUL(ulAllocMB),
             NULL);

DoDefrag:
    err = JetDefragment(pDB->JetSessID,
                        pDB->JetDBID,
                        NULL,
                        &ulPasses,
                        &ulSeconds,
                        JET_bitDefragmentBatchStart);
    DPRINT1((USHORT)(err == JET_errSuccess ? 1 : 0),
            "JetDefragment (defragment batch start) returned error code %d\n",
            err);
}



DWORD
DBGetDepthFirstChildren (
        DBPOS   *pDB,
        PDSNAME **ppNames,
        DWORD   *iLastName,
        DWORD   *cMaxNames,
        BOOL    *fWrapped,
        BOOL    fPhantomizeSemantics
        )
/*++
  pDB - DBPOS to use
  ppNames - where to put an array of PDSNAMEs
  iLastName - index of the end of the list.
  cMaxNames - size of allocated arrays of PDSNAMEs.
  fWrapped - set to TRUE if this routine runs out of room to allocate and
             overwrites values early in the list.
  fPhantomizeSemantics - return immediate children in full DSNAME format.

  For example, if the routine is limited to 5 values and 8 values need to be
  returned, like the following tree:

                   1
                 /   \
               2      5
             / \     /  \
            3   4   6    7
                          \
                           8


   the algorithm will start filling the 5 element array as follows:

   | 1 |   |   |   |   |
   | 1 | 2 | 5 |   |   |
   | 1 | 2 | 5 | 3 | 4 |
   | 6 | 7 | 5 | 3 | 4 |
   | 6 | 7 | 8 | 3 | 4 |

   The return values might look like this.
   ppNames = 6, 7, 8, 3, 4
   iLastName = 2
   cMaxNames = 5
   fWrapped = TRUE

   If all those objects were deleted, leaving the tree:

                   1
                 /   \
                2     5

   If the algorithm is run again:
   | 1 |   |   |   |   |
   | 1 | 2 | 5 |   |   |

   Then, the return values would look like
   ppNames = 1, 2, 5
   iLastName = 2
   cMaxNames = < doesn't matter >
   fWrapped = FALSE


   NOTE: The client has to delete the entries in the correct order:
         from iLastName to zero
         from cMaxNames to iLastName (if fWrapped == TRUE)


    BUGBUG: maybe we would like to re-write the algorithm to delete
            entries as we go:
            have an array that we keep the path in the tree that we
            are positioned at any time and delete all the leafs under
            this entry. if we encounter an entry that is not a leaf,
            add it to the array and continue from this entry. if the
            current entry has no more childs, remove it and continue
            with the last entry in the array.
--*/
{
    #define DEPTHFIRST_START_ENTRIES   (1024)
    #define DEPTHFIRST_MAX_ENTRIES     (DEPTHFIRST_START_ENTRIES * 16)

    THSTATE     *pTHS=pDB->pTHS;
    DWORD        parentIndex = 0;
    DWORD        ParentDNT;
    ATTCACHE    *pACDistName;
    INDEX_VALUE  IV[1];
    DWORD        len, iLastNameUsed;
    DWORD        err;
    DWORD        cAllocated = DEPTHFIRST_START_ENTRIES; // Initial allocation size
    PDSNAME     *pNames;
    DWORD        cParents = 0;
    BOOL         bSkipTest;

    pNames = THAllocEx(pTHS, cAllocated * sizeof(PDSNAME));
    *fWrapped = FALSE;

    IV[0].pvData = &ParentDNT;
    IV[0].cbData = sizeof(ParentDNT);

    *iLastName = 0;

    pACDistName = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
    Assert(pACDistName != NULL);
    // prefix complains about pAC beeing NULL, 447347, bogus since we are using constant


    // start by putting the root object in position 0.
    if (DBGetAttVal_AC(pDB,
                       1,
                       pACDistName,
                       DBGETATTVAL_fSHORTNAME,
                       0,
                       &len,
                       (PUCHAR *)&pNames[parentIndex])) {
        DPRINT(2,"Problem retrieving DN attribute\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_DN,
                 szInsertSz(""),
                 NULL,
                 NULL);

        return DB_ERR_DSNAME_LOOKUP_FAILED;
    }

    // Set to the PDNT index
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetObjTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);

    iLastNameUsed = 1;

    // Get the children of the object in position parentIndex
    do {
        bSkipTest = FALSE;
        // find the children of the object at pNames[parentIndex]
        ParentDNT = DNTFromShortDSName(pNames[parentIndex]);

        // Now, set an index range in the PDNT index to get all the children.
        // Use GE because this is a compound index.
        err = DBSeek(pDB, IV, 1, DB_SeekGE);

        if((!err || err == JET_wrnSeekNotEqual) && (pDB->PDNT == ParentDNT)) {
            // OK, we're GE. Set an indexRange.
            if ( fPhantomizeSemantics && cParents++ ) {
                // Only evaluate first parent in phantomization case.
                break;
            }

            // set an index range on the children
            err = DBSetIndexRange(pDB, IV, 1);

            while(!err) {
                // First, see if this is a real, non-deleted object.
                if(fPhantomizeSemantics || !DBIsObjDeleted(pDB)) {

                    // Yep, it's a real object.
                    if (DBGetAttVal_AC(pDB,
                                       1,
                                       pACDistName,
                                       fPhantomizeSemantics
                                        ? DBGETATTVAL_fREALLOC
                                        : (DBGETATTVAL_fSHORTNAME
                                                    | DBGETATTVAL_fREALLOC),
                                       (pNames[iLastNameUsed]
                                        ? pNames[iLastNameUsed]->structLen
                                        : 0),
                                       &len,
                                       (PUCHAR *)&pNames[iLastNameUsed])) {
                        DPRINT(2,"Problem retrieving DN attribute\n");
                        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                                 DS_EVENT_SEV_MINIMAL,
                                 DIRLOG_CANT_RETRIEVE_DN,
                                 szInsertSz(""),
                                 NULL,
                                 NULL);

                        return DB_ERR_DSNAME_LOOKUP_FAILED;
                    }

                    // we want to skip the test below, since we added at least
                    // one entry in the iLastNameUsed position, so if it just happens
                    // and iLastNameUsed and parentIndex are off by one, we don't
                    // want to exit, but keep going for one more round
                    bSkipTest = TRUE;

                    iLastNameUsed++;

                    if(iLastNameUsed == cAllocated) {
                        // We used up all the available space.
                        if(cAllocated < DEPTHFIRST_MAX_ENTRIES) { // Max allocation size
                            // That's OK, we'll just reallocate some more
                            cAllocated *= 2;
                            pNames =
                                THReAllocEx(pTHS,
                                            pNames,
                                            cAllocated * sizeof(PDSNAME));
                        }
                        else {
                            // We won't allow any more growth, so just wrap.
                            *fWrapped = TRUE;
                            iLastNameUsed = 0;
                        }
                    }

                    // if we have an overlap, we don't want to enumerate any
                    // more children of this parent. instead we want to check
                    // whether we have any more internal nodes in the list
                    if(iLastNameUsed == (parentIndex+1) ||
                       ((iLastNameUsed == cAllocated) && (parentIndex==0))) {

                        break;
                    }
                }
                // get next children
                err = DBMove(pDB, FALSE, DB_MoveNext);
            }
        }
        // advance to the next potential internal node
        parentIndex++;
        if(parentIndex == cAllocated) {
            parentIndex = 0;
        }

        // if we recently added an entry, we don't want to finish looking
        // for internal nodes.
        // otherwise, we stop looking whenever we exhausted all the possible
        // internal nodes (overlapping of parentIndex and iLastNameUsed)
    } while(bSkipTest || (parentIndex != iLastNameUsed));

    *iLastName = parentIndex;
    *cMaxNames = cAllocated;
    *ppNames = pNames;

    return 0;
}

char rgchPhantomIndex[] = "+" SZUSNCHANGED "\0+" SZGUID "\0";

DWORD
DBCreatePhantomIndex (
        DBPOS *pDB
        )
{
    JET_CONDITIONALCOLUMN condColumn;
    JET_INDEXCREATE       indexCreate;
    JET_UNICODEINDEX      unicodeIndexData;
    DWORD                 err;

    memset(&condColumn, 0, sizeof(condColumn));
    condColumn.cbStruct = sizeof(condColumn);
    condColumn.szColumnName = SZDISTNAME;
    condColumn.grbit =  JET_bitIndexColumnMustBeNull;

    memset(&indexCreate, 0, sizeof(indexCreate));
    indexCreate.cbStruct = sizeof(indexCreate);
    indexCreate.szIndexName = SZPHANTOMINDEX;
    indexCreate.szKey = rgchPhantomIndex;
    indexCreate.cbKey = sizeof(rgchPhantomIndex);
    indexCreate.grbit = (JET_bitIndexIgnoreNull |
                         JET_bitIndexUnicode    |
                         JET_bitIndexIgnoreAnyNull);
    indexCreate.ulDensity = 100;
    indexCreate.cbVarSegMac = 8;
    indexCreate.rgconditionalcolumn = &condColumn;
    indexCreate.cConditionalColumn = 1;
    indexCreate.err = 0;
    indexCreate.pidxunicode = &unicodeIndexData;

    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
    unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
    unicodeIndexData.dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                      LCMAP_SORTKEY);


    err =  JetCreateIndex2(pDB->JetSessID, pDB->JetObjTbl, &indexCreate, 1);

    return err;
}


DWORD
DBUpdateUsnChanged(
        DBPOS *pDB
        )
{
    USN usnChanged;

    // Verify that we aren't already in a prepared update.
    Assert(pDB->JetRetrieveBits == 0);

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
    usnChanged = DBGetNewUsn();

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, usnchangedid,
                   &usnChanged, sizeof(usnChanged), 0, NULL);
    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

    return 0;
}

PDSNAME
DBGetCurrentDSName(
        DBPOS *pDB
        )
/*++
  Description:
     Semi-reliably get the dsname for the current object. That is, since
     phantoms don't have a dsname attribute, use the DNT and call sb table
     routines to turn it into the dsname.  Therefore, this routine works for
     both real objects and phantoms.
     Mostly, this is just a wrapper around sbTableGetDSName, which is not
     exported by the dblayer.

  Returns the dsname in thalloced memory.  NULL is returned if something went
  wrong (which should be quite rare).

--*/
{
    DWORD   rtn;
    DSNAME *pName=NULL;

    __try {
        if(rtn=sbTableGetDSName(pDB, pDB->DNT, &pName,0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return NULL;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pName = NULL;
    }

    return pName;
}
PDSNAME
DBGetDSNameFromDnt(
        DBPOS *pDB,
        ULONG ulDnt
        )
/*++
  Description:
     Semi-reliably get the dsname for the current object. That is, since
     phantoms don't have a dsname attribute, use the DNT and call sb table
     routines to turn it into the dsname.  Therefore, this routine works for
     both real objects and phantoms.
     Mostly, this is just a wrapper around sbTableGetDSName, which is not
     exported by the dblayer.

  Returns the dsname in thalloced memory.  NULL is returned if something went
  wrong (which should be quite rare).

--*/
{
    DWORD   rtn;
    DSNAME *pName=NULL;

    __try {
        if(rtn=sbTableGetDSName(pDB, ulDnt, &pName,0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return NULL;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pName = NULL;
    }

    return pName;
}

UCHAR *
DBGetExtDnFromDnt(
    DBPOS *pDB,
    ULONG ulDnt
    )

/*++

Routine Description:

Return a buffer containing the DN corresponding to a DNT.

We want to avoid disturbing the current DBPOS.

pString should be freed by the caller.

Arguments:

    pTHS -
    ulDnt -

Return Value:

    UCHAR * -

--*/

{
    char   errBuff[128];
    DSNAME *pDN = NULL;
    ULONG  len, err;
    UCHAR *pString;

    // Translate the backlink dnt if possible
    // pDN is null if this doesn't work
    pDN = DBGetDSNameFromDnt( pDB, ulDnt );
    if (!pDN) {
        sprintf(errBuff, "Error retrieving the DN attribute of DNT 0x%x", ulDnt);
        len = strlen(errBuff);
        pString = THAllocEx(pDB->pTHS, len+1);
        memcpy(pString, errBuff, len+1);
        return pString;
    }

    pString = MakeDNPrintable(pDN);

    THFreeEx( pDB->pTHS, pDN );

    return pString;
} /* GetExtDnFromDnt */

ULONG
DBClaimWriteLock(DBPOS *pDB)
{
    ULONG err;

    err = JetGetLock(pDB->JetSessID, pDB->JetObjTbl, JET_bitWriteLock);
    if (err == JET_errSuccess) {
        return 0;
    }
    else {
        return DB_ERR_WRITE_CONFLICT;
    }
}

ULONG
DBClaimReadLock(DBPOS *pDB)
{
    ULONG err;

    err = JetGetLock(pDB->JetSessID, pDB->JetObjTbl, JET_bitReadLock);
    if (err == JET_errSuccess) {
        return 0;
    }
    else {
        return DB_ERR_WRITE_CONFLICT;
    }
}


/* CountAncestorsIndexSize
 *
 * This routine (invoked off of the task queue) counts the ancestors index size.
 * This size is used in index optimizations by the filter optimizer.
 *
 * INPUT:
 *   A bunch of junk that we don't use, to match the task queue prototype
 * OUTPUT
 *   pcSecsUntilNextIteration: When the to schedule this task next
 */
void CountAncestorsIndexSize  (
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    THSTATE             *pTHS = pTHStls;
    NAMING_CONTEXT_LIST *pNCL;
    ULONG                ulSizeEstimate;
    DBPOS               *pDB;
    DWORD                rootDNT = ROOTTAG;
    NCL_ENUMERATOR       nclEnum;

    Assert(!pTHS->pDB);
    DBOpen(&pTHS->pDB);
    Assert(pTHS->pDB);
    __try {
        pDB = pTHS->pDB;
        DPRINT(1,"Processing CountAncestorsIndexSize request\n");

        ulSizeEstimate = CountAncestorsIndexSizeHelper (pDB, sizeof (rootDNT), &rootDNT);

        if (ulSizeEstimate) {
            gulEstimatedAncestorsIndexSize = ulSizeEstimate;
        }
        else {
            gulEstimatedAncestorsIndexSize = 100000000;
        }

        DPRINT1 (1, "Estimated GC Ancestor Index Size: %d\n", gulEstimatedAncestorsIndexSize);

        NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
        // we are modifying global data here! no big deal since we don't update any ptrs
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            pNCL->ulEstimatedSize = CountAncestorsIndexSizeHelper (pTHS->pDB,
                                                                   pNCL->cbAncestors,
                                                                   pNCL->pAncestors);

            DPRINT2 (1, "Estimated Ancestor Index Size for %ws = %d\n",
                              pNCL->pNC->StringName, pNCL->ulEstimatedSize);
        }
    }
    __finally {
            DBClose(pTHS->pDB, TRUE);
        *pcSecsUntilNextIteration = 33 * 60; // 33 minutes. why ? why not ?
    }
}

ULONG CountAncestorsIndexSizeHelper (DBPOS *pDB,
                                     DWORD  cbAncestors,
                                     DWORD *pAncestors)
{
    JET_ERR     err;
    DWORD       BeginNum, BeginDenom;
    DWORD       EndNum, EndDenom;
    DWORD       Denom;
    JET_RECPOS  RecPos;

    ULONG       dwException, ulErrorCode, dsid;
    PVOID       dwEA;

    ULONG       ulSizeEstimate = 0;

    DWORD       numAncestors;
    DWORD       cbAncestorsBuff;
    DWORD       *pAncestorsBuff;
    DWORD       realDNT, pseudoDNT;

    numAncestors = cbAncestors / sizeof (DWORD);
    Assert (numAncestors);

    if (numAncestors == 0) {
        return 0;
    }

    cbAncestorsBuff = cbAncestors;
    pAncestorsBuff = THAllocEx (pDB->pTHS, cbAncestors);
    memcpy (pAncestorsBuff, pAncestors, cbAncestors);

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZANCESTORSINDEX,
                               &idxAncestors,
                               0);

    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 pAncestorsBuff,
                 cbAncestorsBuff,
                 JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetSearchTbl,
                    JET_bitSeekGE);

    if ((err == JET_errSuccess) ||
        (err == JET_wrnRecordFoundGreater)) {

        JetGetRecordPosition(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             &RecPos,
                             sizeof(JET_RECPOS));
        BeginNum = RecPos.centriesLT;
        BeginDenom = RecPos.centriesTotal;

        numAncestors--;
        //pAncestorsBuff[numAncestors]++;

        // We thus take the last DNT and
        // byte swap it (so that it's in big-endian order), increment it,
        // and then re-swap it.  This gives us the DNT that would be next in
        // byte order.
        realDNT = pAncestorsBuff[numAncestors];
        pseudoDNT = (realDNT >> 24) & 0x000000ff;
        pseudoDNT |= (realDNT >> 8) & 0x0000ff00;
        pseudoDNT |= (realDNT << 8) & 0x00ff0000;
        pseudoDNT |= (realDNT << 24) & 0xff000000;
        ++pseudoDNT;
        realDNT = (pseudoDNT >> 24) & 0x000000ff;
        realDNT |= (pseudoDNT >> 8) & 0x0000ff00;
        realDNT |= (pseudoDNT << 8) & 0x00ff0000;
        realDNT |= (pseudoDNT << 24) & 0xff000000;

        pAncestorsBuff[numAncestors] = realDNT;



        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetSearchTbl,
                     pAncestorsBuff,
                     cbAncestorsBuff,
                     JET_bitNewKey | JET_bitStrLimit | JET_bitSubStrLimit);

        err = JetSeekEx(pDB->JetSessID,
                        pDB->JetSearchTbl,
                        JET_bitSeekLE);

        if ( (err == JET_errSuccess) ||
             (err == JET_wrnRecordFoundLess)) {

            JetGetRecordPosition(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 &RecPos,
                                 sizeof(JET_RECPOS));

            EndNum = RecPos.centriesLT;
            EndDenom = RecPos.centriesTotal;

            // Normalize the fractions of the fractional position
            // to the average of the two denominators.
            // denominator
            Denom = (BeginDenom + EndDenom)/2;
            EndNum = MulDiv(EndNum, Denom, EndDenom);
            BeginNum = MulDiv(BeginNum, Denom, BeginDenom);

            if(EndNum <= BeginNum) {
                ulSizeEstimate = 0;
            }
            else {
                ulSizeEstimate = EndNum - BeginNum;
            }
        }
    }

    return ulSizeEstimate;
}

DB_ERR
DBErrFromJetErr(
    IN  DWORD   jetErr
    )
{
    switch (jetErr) {
    case JET_errKeyDuplicate:
        return DB_ERR_ALREADY_INSERTED;

    case JET_errNoCurrentRecord:
        return DB_ERR_NO_CURRENT_RECORD;

    case JET_errRecordNotFound:
        return DB_ERR_RECORD_NOT_FOUND;

    default:
        return DB_ERR_DATABASE_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drachkpt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drachkpt.c
//
//--------------------------------------------------------------------------

/*++

    This File Contains Services Pertaining to taking checkpoints, to support
    downlevel replication. Checkpoints are taken to prevent Full syncs with
    NT4 domain controllers, upon a role transfer. For more details please read
    the theory of operation

    Author

        Murlis

    Revision History

        10/13/97 Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>

#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "mappings.h"
#include "samsrvp.h"
#include "drarpc.h"
#include <nlwrap.h>                     /* I_NetLogon* wrappers */

#include <fileno.h>
#define  FILENO FILENO_DRACHKPT


#define DRACHKPT_SUCCESS_RETRY_INTERVAL 3600
#define DRACHKPT_FAILURE_RETRY_INTERVAL  (4*3600)
#define MAX_CHANGELOG_BUFFER_SIZE 16384
#define NUM_CHKPT_RETRIES 5

ULONG
NtStatusToDraError(NTSTATUS NtStatus);




/*--------------------------------------------------------------------------------------------

                                THEORY OF OPERATION


        NT4 Incremental Replication Protocol ( netlogon replication protocol )
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        The netlogon replication protocol, defines an incremental
    replication scheme based on a change log. The change log is a sequence of change entries,
    each entry consisting of a unique monotonically increasing sequence number ( the serial
    number ) and information that describes the change. An NT4 BDC remembers the highest sequence
    number that it has seen, and replicates in changes and change log entries having a sequence
        number higher than the highest sequence number that it has seen.



        Role Transfer in NT4
        ~~~~~~~~~~~~~~~~~~~~~

         Upon a role transfer in a NT4 system, all the NT4 BDC's will start replicating with the
        new PDC. The new PDC has a change log nearly identical to the old PDC. I use the term, nearly,
    because the new PDC, sees the same order of changes as the old one, but It may lag behind the
    old PDC. Freshly made changes on the new PDC, are distinguished from changes made on the old PDC,
        by means of a promotion count ---- A constant large offset is added to the sequence number after
        a promotion. An NT4 BDC that is at a sequence number greater, than the highest sequence number
        at the new PDC during the time of promotion knows to undo all the changes such that it is at the
        same state as the new PDC at promotion time  and sync afresh to the changes on to the new PDC.

        Mixed Mode Operation of NT4 and NT5 Controllers
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        In a mixed domain environment, NT5 Domain controllers replicate amongst themselves using
        the DS replication protocol, while the NT5 PDC replicates to NT4 Domain controllers using
        the netlogon replication protocol. With no further work, a full sync on role transfer needs to
        be forced. This is because a change log maintained on a NT5 BDC is not guarenteed to contain
        changes in the same order, as the change log in the PDC. This can potentially confuse an NT4
        BDC.

        Full Sync avoidance through checkpointing
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        The requirement for non NT4 BDC full sync role transfer is that the new PDC has a change log
        that is "substantially similar" to the change log on the original PDC. The term substantially
        similar means that the 2 change log's have the same ordering of changes but the change log on
        the new PDC is not completely upto date. This change log is maintained through a periodic
        checkpointing scheme. The term checkpointing means "transfer of change log from PDC to BDC
        taking checkpoint after ensuring that the BDC taking the checkpoint has all the changes described in the
        change log, and contains no changes not described in the change log".  The basic checkpoint
        algorithm can be described as

                1. Synchronize with PDC
                2. Make PDC synchronize to you
                3. Grab the change log

                For a successful checkpoint no external modifications should occur to the database
        during steps 1, 2 and 3.

        After taking a checkpoint the BDC sets its state such that it continues building the change log
        locally with the locally made changes having a sequence number offset by a promotion increment.
        This is best illustrated by an example


        Assume that changes A, B and C are made on the PDC. The PDC has a change log like

        1. A
        2. B
        3. C
        where 1. 2. and 3. are the respective sequence numbers

        Immediately after taking a checkpoint, an NT5 BDC will have a change log like

        1. A
        2. B
        3. C

        Suppose now change D is made on the PDC and change E is made on the NT5 BDC. The PDC
        change log will be

        1. A
        2. B
        3. C
        4. D
        5. E

        The NT5 BDC change log will look like

        1. A
        2. B
        3. C
        1004. E
        1005. D

        Where 1000 is the promotion increment. If the NT5 BDC is promoted to be PDC, then to an NT4
        BDC it will appear as if the new PDC had been in sync only upto change C ( serial no 3),
        at the time of  promotion and then changes E and D have been freshly made on it. It will
        therefore undo changes D and E ( described by seria numbers 4 and 5 ) and then apply changes
        E and D (serial numbers 1004 and 1005 ).


        Best Effort checkpointing
        ~~~~~~~~~~~~~~~~~~~~~~~~~~

        Gurarenteed checkpointing implies that the 3 steps to successful checkpointing be performed
        with the database locked against external modifications. This guarentees the fact that a
        successful checkpoint will be taken whenever attempted subject to machine availability
        constraints. Locking the database while doing network operations opens up windows for deadlock,
        or possible long periods where the DC may not be available for modifications.

        Best Effort checkpointing on the other hand does not lock the database, but rather has a
        mechanism to detect whether external modifications took place while executing the steps for taking
        a checkpoint. If modifications took place, the algorithm will retry the process. After a certain
        number of retries, if still the checkpoint cannot be taken, the operation is described as a
        failure, and the check point taking is rescheduled for a later time. Best effort checkpointing
        recognizes the fact that the probability of modifications is small, therefore the probability
        of taking a checkpoint with the database unlocked is high.

----------------------------------------------------------------------------------------------------*/


NTSTATUS
DraReadNT4ChangeLog(
    IN OUT PVOID * Restart,
    IN OUT PULONG  RestartLength,
    IN ULONG   PreferredMaximumLength,
    OUT PULONG   SizeOfChanges,
    OUT PVOID  * Buffer
    )
/*++

    This function reads the netlogon changelog by calling the appropriate
    netlogon API. All memory allocation issues are taken care of in this
    function. Netlogon uses the process heap, while DS uses a thread heap.
    If necessary reallocations are done, so that consisted usage of the thread
    heap is the only model that is exposed to the callers of this routine

    Paramters

        Restart  IN/OUT parameter, that takes in a restart to be passed to
                  netlogon, and compute a new restart after the call is completed

        RestartLength IN/OUT parameter specifying the length of the restart
                      structure

        PreferredMaximumLength -- The maximum length of that data that can be
                     retrieved in a single shot.

        SizeofChanges   -- The size of the change buffer is returned in here

        Buffer          -- The actual buffer is returned in here
--*/
{
    ULONG OldRestartLength = *RestartLength;
    PVOID NetlogonRestart = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls;



    //
    // Allocate space for the change buffer
    //

    *Buffer = THAllocEx(pTHS,PreferredMaximumLength);


    //
    // Read the change log from netlogon
    //

    __try {
        NtStatus = dsI_NetLogonReadChangeLog(
                   *Restart,               // In context
                    OldRestartLength,       // In context size
                    PreferredMaximumLength, // Buffer Size
                    *Buffer,                // Buffer for netlogon to fill in change log
                    SizeOfChanges,           // Bytes read
                    &NetlogonRestart,       // out context
                    RestartLength          // out context length
                    );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


    if (NT_SUCCESS(NtStatus))
    {
        //
        // Copy the restart structure into thread memory
        //

        *Restart = (PVOID) THAllocEx(pTHS,*RestartLength);
        RtlCopyMemory(*Restart,NetlogonRestart,*RestartLength);
        dsI_NetLogonFree(NetlogonRestart);

    }

    return NtStatus;
}


NTSTATUS
DraGetNT4ReplicationState(
            IN  DSNAME * pDomain,
            NT4_REPLICATION_STATE *ReplicationState
            )
/*++

    This routine will obtain the serial numbers for the
    3 databases. The first cut of this implementation,
    obtains the serial number only for the Sam account domain.
    Once the test bed has been proved the routine will be generalized
    to builtin and lsa serial numbers.

    Parameters

        pDomain -- DS Name of the Domain for which the serial number
                   has to be obtained

        SamSerialNumber -- The serial number of the Sam database
        BuiltinSerialNumber -- The serial number of the builtin database
        LsaSerialNumber     -- The serial number of the lsa database

    Return values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    THSTATE     *pTHSSaved = NULL;

    //
    // Save Current thread state. Making in process
    // calls into SAM and LSA, which can result in
    // database operations involving a thread state
    //

    pTHSSaved = THSave();

    //
    // Obtain the serial numbers from SAM
    //

    SampGetSerialNumberDomain2(
        &pDomain->Sid,
        &ReplicationState->SamSerialNumber,
        &ReplicationState->SamCreationTime,
        &ReplicationState->BuiltinSerialNumber,
        &ReplicationState->BuiltinCreationTime
        );




    //
    // Obtain the serial number for the LSA database
    //

    //
    // N.B.  Setting this value to one will always cause
    // a full sync of the LSA database upon a promotion.  This
    // gaurentees that the BDC's are up to date with the new PDC.
    // The LSA database is typically small so this is acceptable
    // performance-wise.
    //

    ReplicationState->LsaSerialNumber.QuadPart = 1;
    NtQuerySystemTime(&ReplicationState->LsaCreationTime);

    THRestore(pTHSSaved);

    return NtStatus;
}

NTSTATUS
DraSetNT4ReplicationState(
            IN  DSNAME * pDomain,
            IN  NT4_REPLICATION_STATE * ReplicationState
            )
/*++

    This routine will sts the serial numbers  and creation time for the
    3 databases. It will also give dummy change notifications, to
    make the world consistent for an NT4 BDC. The first cut of this implementation,
    obtains the serial number only for the Sam account domain.
    Once the test bed has been proved the routine will be generalized
    to builtin and lsa serial numbers.

    Parameters

        pDomain -- DS Name of the Domain for which the serial number
                   has to be obtained

        ReplicationState -- Structure containing the serial number and
                   creation time of the domain.

    Return values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    THSTATE     *pTHSSaved = NULL;
    UCHAR       BuiltinDomainSid[]={0x01,0x01,0x00,0x00,
                                    0x00,0x00,0x00,0x05,
                                    0x20,0x00,0x00,0x00
                                    };

    //
    // Save Current thread state. Making in process
    // calls into SAM and LSA, which can result in
    // database operations involving a thread state
    //

    pTHSSaved = THSave();

    //
    // Set the serial numbers from SAM
    //

    NtStatus = SampSetSerialNumberDomain2(
                    &pDomain->Sid,
                    &ReplicationState->SamSerialNumber,
                    &ReplicationState->SamCreationTime,
                    &ReplicationState->BuiltinSerialNumber,
                    &ReplicationState->BuiltinCreationTime
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Give Dummy Sam notifications for both account and
    // and builtin SAM domains
    //

    SampNotifyReplicatedInChange(
            &pDomain->Sid,
            TRUE,
            SecurityDbChange,
            SampDomainObjectType,
            NULL,
            0,
            0,      // group type
            CALLERTYPE_INTERNAL,  // it is from task queue, not triggered by ldap client, don't audit
            FALSE
            );

    SampNotifyReplicatedInChange(
            (PSID) BuiltinDomainSid,
            TRUE,
            SecurityDbChange,
            SampDomainObjectType,
            NULL,
            0,
            0,      // group type
            CALLERTYPE_INTERNAL,  // it is from task queue, not triggered by ldap client, don't audit
            FALSE
            );

    //
    // For now do nothing for the LSA
    //

Error:


    THRestore(pTHSSaved);

    return NtStatus;
}

ULONG
IDL_DRSGetNT4ChangeLog(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_NT4_CHGLOG_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine reads the change log from netlogon and returns the log
        in the reply message. This is the server side of the RPC routine

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        dwOutVersion  The Clients version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0, win32status;
    NTSTATUS                ReadStatus = STATUS_SUCCESS;
    THSTATE                 *pTHS = NULL;

    drsReferenceContext( rpc_handle, IDL_DRSGETNT4CHANGELOG );
    __try {
	__try
	    {

	    //
	    // Currently we support only one out version
	    //

	    *pdwOutVersion=1;

	    //
	    // Discard request if we're not installed
	    //

	    if ( DsaIsInstalling() )
		{
		DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
	    }


	    if (    ( NULL == pmsgIn )
		    || ( 1 != dwInVersion )
		    || (NULL==pmsgOut)
		    )
		{
		DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
	    }

	    //
	    // Initialize thread state and open data base.
	    //

	    if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM)))
		{
		NtStatus = STATUS_INSUFFICIENT_RESOURCES;
	    }
	    else
		{
		//
		// PREFIX: PREFIX complains that there is the possibility
		// of pTHS->CurrSchemaPtr being NULL at this point.  However,
		// the only time that CurrSchemaPtr could be NULL is at the
		// system start up.  By the time that the RPC interfaces
		// of the DS are enabled and this function could be called,
		// CurrSchemaPtr will no longer be NULL.
		//
		Assert(NULL != pTHS->CurrSchemaPtr);

		Assert(1 == dwInVersion);
		LogAndTraceEvent(TRUE,
				 DS_EVENT_CAT_RPC_SERVER,
				 DS_EVENT_SEV_EXTENSIVE,
				 DIRLOG_IDL_DRS_GET_NT4_CHGLOG_ENTRY,
				 EVENT_TRACE_TYPE_START,
				 DsGuidDrsGetNT4ChgLog,
				 szInsertUL(pmsgIn->V1.dwFlags),
				 szInsertUL(pmsgIn->V1.PreferredMaximumLength),
				 NULL, NULL, NULL, NULL, NULL, NULL);

		//
		// Make the security check, wether we have rights to take
		// a checkpoint
		//
		if (!IsDraAccessGranted(pTHS, gAnchor.pDomainDN,
					&RIGHT_DS_REPL_GET_CHANGES, &win32status))
		    {
		    // CODE.IMP: IsDraAccessGranted has returned a more specific failure
		    // reason, but we are not using it at this point.
		    NtStatus = STATUS_ACCESS_DENIED;
		}
		else
		    {
		    pTHS->fDSA = TRUE;



		    //
		    // Intitalize Return Values
		    //

		    RtlZeroMemory(&pmsgOut->V1,sizeof(DRS_MSG_NT4_CHGLOG_REQ_V1));


		    //
		    // Read the Change Log from Netlogon, if Changelog read
		    // was requested
		    //

		    if (pmsgIn->V1.dwFlags & DRS_NT4_CHGLOG_GET_CHANGE_LOG)
			{
			pmsgOut->V1.pRestart = pmsgIn->V1.pRestart;
			pmsgOut->V1.cbRestart = pmsgIn->V1.cbRestart;


			NtStatus = DraReadNT4ChangeLog(
			    &pmsgOut->V1.pRestart,
			    &pmsgOut->V1.cbRestart,
			    pmsgIn->V1.PreferredMaximumLength,
			    &pmsgOut->V1.cbLog,
			    &pmsgOut->V1.pLog
			    );
		    }

		    //
		    // Save of the Read Status
		    //

		    ReadStatus = NtStatus;

		    if ((pmsgIn->V1.dwFlags & DRS_NT4_CHGLOG_GET_SERIAL_NUMBERS)
			&& (NT_SUCCESS(NtStatus)))
			{



			//
			// Grab the serial Numbers in the database
			// at the current time
			//

			NtStatus = DraGetNT4ReplicationState(
			    gAnchor.pDomainDN,
			    &pmsgOut->V1.ReplicationState
			    );
		    }


		    //
		    // Map any Errors
		    //
		    ret = NtStatusToDraError(NtStatus);
		    if (NT_SUCCESS(NtStatus))
			{
			pmsgOut->V1.ActualNtStatus = ReadStatus;
		    }
		    else
			{
			pmsgOut->V1.ActualNtStatus = NtStatus;
		    }

		} // End of Successful Access check
	    } // End of Successful Thread Creation
	} // End of Try Block
	__except ( GetDraException( GetExceptionInformation(), &ret ) )
	{
	    //
	    // Return DS Busy as status code for any outstantding
	    // exceptions
	    //
	    pmsgOut->V1.ActualNtStatus = STATUS_INSUFFICIENT_RESOURCES;
	}

	if (NULL != pTHS) {
	    Assert(1 == *pdwOutVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_NT4_CHGLOG_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsGetNT4ChgLog,
			     szInsertHex(pmsgOut->V1.ActualNtStatus),
			     NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
    }
    __finally {
	drsDereferenceContext( rpc_handle, IDL_DRSGETNT4CHANGELOG );
    }
    return ret;
}




VOID
DraPreventModifications()
/*++

    Routine Description

        This routine prevents modifications to the SAM / LSA databases by
        acquiring the SAM lock and LSA lock for exclusive access. This is
        sufficient to prevent in bound replication also, as the netlogon
        notification path, will try to acquire the lock, before giving out
        the notification.

--*/
{
    SampAcquireSamLockExclusive();
}

VOID
DraAllowModifications()
/*++

    Routine Description

        This routine will allow modifications to SAM / LSA databases by
        releasing the SAM lock and the LSA lock for exclusive access. This
        release is done corresponding to order of the acquire

--*/
{
    SampReleaseSamLockExclusive();
}


BOOLEAN
DraSameSite(
   THSTATE * pTHS,
   DSNAME * Machine1,
   DSNAME * Machine2
   )
/*++

    Routine Description

        This routine will check wether Machine 1 and Machine 2 are in the
        same site. The check is done, by comparing wether they have the same
        parent

    Parameters

        Machine1  -- Ds Name of the First machine
        Machine2  -- Ds Name of the second machine


    Return Values

        TRUE     -- If they are in the same site
        FALSE    -- False Otherwise
--*/
{
    DSNAME * Parent1, * Parent2;
    BOOLEAN ret;

    Parent1 = THAllocEx(pTHS,Machine1->structLen);
    Parent2 = THAllocEx(pTHS,Machine2->structLen);
    if (   TrimDSNameBy(Machine1,2,Parent1)
        || TrimDSNameBy(Machine2,2,Parent2)
        || !NameMatched(Parent1,Parent2))
        ret = FALSE;
    else
        ret = TRUE;

    THFreeEx(pTHS,Parent1);
    THFreeEx(pTHS,Parent2);
    return ret;
}

NTSTATUS
DraGetPDCChangeLog(
    THSTATE *pTHS,
    IN  LPWSTR pszPDCFDCServer,
    IN  OUT HANDLE *ChangeLogHandle,
    OUT NT4_REPLICATION_STATE * ReplicationState,
    IN  OUT PVOID  *ppRestart,
    IN  OUT PULONG pcbRestart
    )
/*++

    Routine Description

        This routine will open a new change log locally if required and then
        grab the change log from the PDC and set it on the new change log.

    Parameters

        szPDCFDCServer --- The name of the PDC / FDC
        ChangeLogHandle -- Handle to the open change log
        ppRestart       --  In-Out parameter descibing a restart structure to
                            incrementaly update the change log

        pcbRestart      --  The length of the restart structure is passed in
                            or updated in her

    Return Values

        STATUS_SUCCESS
        Other NT error codes to indicate errors pertaining to resource failures

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        RetrieveStatus;
    PVOID           pLog=NULL;
    ULONG           cbLog=0;
    LARGE_INTEGER   SamSerialNumber;
    LARGE_INTEGER   LsaSerialNumber;
    LARGE_INTEGER   BuiltinSerialNumber;
    ULONG           RetCode = 0;

    //
    // If the change log has not been opened then open it
    //

    if (INVALID_HANDLE_VALUE==*ChangeLogHandle)
    {
        __try {
            NtStatus = dsI_NetLogonNewChangeLog(ChangeLogHandle);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

    //
    // Grab the change log from the PDC in chunks, till there is no
    // further entries
    //

    do
    {
        pLog = NULL;

        RetCode = I_DRSGetNT4ChangeLog(
                        pTHS,
                        pszPDCFDCServer,
                        DRS_NT4_CHGLOG_GET_CHANGE_LOG
                        |DRS_NT4_CHGLOG_GET_SERIAL_NUMBERS,
                        MAX_CHANGELOG_BUFFER_SIZE,
                        ppRestart,
                        pcbRestart,
                        &pLog,
                        &cbLog,
                        ReplicationState,
                        &NtStatus
                        );

        if (0!=RetCode)
        {
            //
            // Morph any connect errors to this error code
            //

            NtStatus = STATUS_DOMAIN_CONTROLLER_NOT_FOUND;
            goto Error;
        }

        //
        // If the actual call failed then also abort
        //

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Save the return code returned by the RPC call
        //

        RetrieveStatus = NtStatus;

        //
        // Now append the changes to the new change log
        //

        __try {
            NtStatus = dsI_NetLogonAppendChangeLog(
                        *ChangeLogHandle,
                        pLog,
                        cbLog
                        );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (NULL!=pLog)
        {
            THFree(pLog);
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    } while (STATUS_MORE_ENTRIES==RetrieveStatus);


Error:


    return NtStatus;
}

NTSTATUS
DraGetPDCFDCRoleOwner(
    DSNAME * pDomain,
    DSNAME ** ppRoleOwner
    )
/*++

    Routine Description

        This routine retrieves the FSMO role owner property
        for PDCness for the appropriate domain.

    Parameters

        pDomain -- DS name of the domain object
        ppRoleOwner -- The DS name of the role owner is returned in here

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure
--*/
{
    THSTATE * pTHS = pTHStls;
    ULONG     RoleOwnerSize;

    Assert(NULL!=pTHS);

    __try
    {
        //
        // Begin a Transaction
        //

        DBOpen2(TRUE,&pTHS->pDB);

        //
        // Position on the Domain object
        //

        if (0!=DBFindDSName(
                    pTHS->pDB,
                    pDomain))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // Read the Value
        //

        if (0!=DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_FSMO_ROLE_OWNER,
                DBGETATTVAL_fREALLOC,
                0,
                &RoleOwnerSize,
                (PUCHAR *)ppRoleOwner
                ))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    __finally
    {
        //
        // End the Transaction
        //

        DBClose(pTHS->pDB,TRUE);
    }

    return STATUS_SUCCESS;
}

BOOLEAN
TestForCheckpoint(
    IN NT4_REPLICATION_STATE *StartState,
    IN NT4_REPLICATION_STATE *EndState
    )
{
    return (( StartState->SamSerialNumber.QuadPart==EndState->SamSerialNumber.QuadPart) &&
           ( StartState->BuiltinSerialNumber.QuadPart==EndState->BuiltinSerialNumber.QuadPart) &&
           ( StartState->LsaSerialNumber.QuadPart==EndState->LsaSerialNumber.QuadPart));
}


ULONG
DraSynchronizeWithPdc(
    DSNAME * pDomain,
    DSNAME * pPDC
    )
/*++

    Routine Description

            This routine makes the call to synchronize with the PDC,
            after saving the current thread state

    Parameters

        pDOmain --- The DSNAME of the Domain object
        pPDC    --- The DSNAME of the NTDS DSA object for the PDC

    Return Values

        0 Success
        Other Replication Error Codes

--*/
{
    ULONG retCode = 0;
    THSTATE *pTHSSaved=NULL;

    __try
    {
        //
        // Save the existing thread state, as DirReplicaSynchronize will create a new
        // one as the DRA.
        //

        pTHSSaved = THSave();

        //
        // Synchronize with the PDC
        //

        //
        // DirReplica synchronize today keeps retrying till synchronization is achieved
        // As per JeffParh this is not a problem, as replication is "faster" than anything
        // else, and will eventually catch up. This delays the checkpointing, but is not
        // fatal to the algorithm. In case this proves to be a problem, then we should
        // pass in a ulOption to DirReplicaSynchronize, that it abandon the operatio, after
        // a few cycles of "GetNcChanges -- UpDateNc"
        //

        retCode =DirReplicaSynchronize(
                    pDomain,
                    NULL,
                    &pPDC->Guid,
                    0
                    );

        //
        // free the thread state created by DirReplicaSynchronize
        //
    }
    __finally
    {

        free_thread_state();

        THRestore(pTHSSaved);

    }

    return retCode;
}

DWORD
DraTakeCheckPoint(
            IN ULONG RetryCount,
            OUT PULONG RescheduleInterval
            )
/*++

    This routine does all the client side work of taking a checkpoint


  Parameters

    RetryCount -- The number of times this routine should retry the
    checkpoint operation.

    RescheduleInterval -- Time after which this task should be rescheduled

  Return values

   Void Function
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CheckpointTaken = FALSE;
    NT4_REPLICATION_STATE ReplicationStateAtPDC,
                          ReplicationStateLocalAtStart,
                          ReplicationStateLocalAtEnd;
    THSTATE       *pTHS = pTHStls;
    HANDLE        ChangeLogHandle = INVALID_HANDLE_VALUE;
    DSNAME        *pDomain = gAnchor.pDomainDN;
    DSNAME        *pDSA    = gAnchor.pDSADN;
    DSNAME        *pPDC, *pPDCAfterSync;
    PVOID         pRestart = NULL;
    ULONG         cbRestart =  0;
    ULONG         retCode ;
    LPWSTR        szPDCFDCServer = NULL;
    BOOLEAN       MixedDomain;



    Assert(NULL!=pTHS);

    //
    // First Check the mixed domain setting
    //

    NtStatus = SamIMixedDomain2(&pDomain->Sid,&MixedDomain);

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);
        goto Failure;
    }

    if (!MixedDomain)
    {
        //
        // If not a mixed domain, then no checkpointing
        //

        goto Success;
    }

    //
    // Get the PDC or FDC role owner
    //

    NtStatus = DraGetPDCFDCRoleOwner(
                    pDomain,            // The domain, whose PDC ness we are testing
                    &pPDC
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);
        goto Failure;
    }

    //
    // Check wether we are in same site, or are the PDC ourselves
    //

    if (NameMatched(pDSA,pPDC))
    {
        //
        // If we are the PDC itself then return success
        //


        goto Success;
    }

    if (!DraSameSite(pTHS,pDSA,pPDC))
    {
        //
        // Not in the same site. Return a filure
        // Do not log an event and set the reschedule interval to be the
        // success interval
        //

        *RescheduleInterval = DRACHKPT_SUCCESS_RETRY_INTERVAL;
        return(ERROR_DS_DRA_NO_REPLICA);
    }



    //
    // O.K we are now a "candidate PDCFDC" ie we are not the PDC or FDC, and are
    // in the same site as the PDC or FDC. Therefore proceed with taking the
    // checkpoint.
    //

    //
    // Synchronize with the PDC
    //

    retCode = DraSynchronizeWithPdc(
                    pDomain,
                    pPDC
                    );

    if (0!=retCode)
    {

        goto Failure;
    }


    //
    // After the Sync verify again that the PDC is the same, and in the same site
    // We could have had an out of date FSMO, and we need to make sure that it is
    // more upto date. It is true, that we could always make a DsGetDcName to obtain
    // the PDC, but then this mechanism should also be "adequate". Therefore we can
    // can trim out one network operation. We need to do the sync anyway in the success
    // case, and therefore we can save the network operation of calling DsGetDcName
    //

    //
    // Get the PDC or FDC role owner once again !
    //

    NtStatus = DraGetPDCFDCRoleOwner(
                    pDomain,            // The domain, whose PDC ness we are testing
                    &pPDCAfterSync
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        retCode = RtlNtStatusToDosError(NtStatus);;
        goto Failure;
    }

    //
    // Verify that the PDC remained the same
    //

    if (!NameMatched(pPDC,pPDCAfterSync))
    {
        retCode = ERROR_DS_PDC_OPERATION_IN_PROGRESS;
        goto Failure;
    }

    //
    // Note At this point, it is safe to assume, that the machine we think
    // is the PDC is the PDC itself. This is because the FSMO operation
    // guarentees us that every machine has accurate knowledge of its own role.
    //

    do
    {

         //
         // Get local serial numbers
         //

        NtStatus = DraGetNT4ReplicationState(
                        pDomain,
                        &ReplicationStateLocalAtStart
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            retCode = RtlNtStatusToDosError(NtStatus);
            goto Failure;
        }



        //
        // Make the PDC synchronize with Us
        //

        szPDCFDCServer   = DSaddrFromName(pTHS,
                                          pPDC);
        if (NULL==szPDCFDCServer)
        {
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            goto Failure;
        }

        retCode = I_DRSReplicaSync(
                        pTHS,
                        szPDCFDCServer, // PDC server
                        pDomain,      // NC to synchronize
                        NULL,         // String name of source
                        &pDSA->Guid,  // Invocation Id of Source
                        0);

        if (0!=retCode)
        {
            goto Failure;
        }

        //
        // Get the complete change log
        //

        NtStatus = DraGetPDCChangeLog(
                        pTHS,
                        szPDCFDCServer,
                        &ChangeLogHandle,
                        &ReplicationStateAtPDC,
                        &pRestart,
                        &cbRestart
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            retCode = RtlNtStatusToDosError(NtStatus);
            goto Failure;
        }

        //
        // Synchronize with the PDC.
        //

        retCode = DraSynchronizeWithPdc(
                        pDomain,
                        pPDC
                        );

        if (0!=retCode)
        {
            goto Failure;
        }

        __try
        {

            //
            // Prevent modifications to accounts database
            //

            DraPreventModifications();

            //
            // Check Checkpoint criteria
            //

             NtStatus = DraGetNT4ReplicationState(
                            pDomain,
                            &ReplicationStateLocalAtEnd
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                retCode = RtlNtStatusToDosError(NtStatus);
                goto Failure;
            }

            CheckpointTaken = TestForCheckpoint(
                                &ReplicationStateLocalAtStart,
                                &ReplicationStateLocalAtEnd
                                );
            //
            // If Criteria Matched, commit and close change log
            //

            if (CheckpointTaken)
            {
                LARGE_INTEGER PromotionIncrement = DOMAIN_PROMOTION_INCREMENT;

                //
                // Add the promotion count to the serial
                // numbers retrieved from the PDC
                //

                ReplicationStateAtPDC.SamSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;
                ReplicationStateAtPDC.BuiltinSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;
                ReplicationStateAtPDC.LsaSerialNumber.QuadPart+=
                                        PromotionIncrement.QuadPart;


                //
                // Commit the change log making it the new log
                //

                __try {
                    NtStatus = dsI_NetLogonCloseChangeLog(
                                ChangeLogHandle,
                                TRUE
                                );
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                ChangeLogHandle = INVALID_HANDLE_VALUE;

                if (!NT_SUCCESS(NtStatus))
                {
                    retCode = RtlNtStatusToDosError(NtStatus);
                    goto Failure;
                }


                //
                // Set the new set of serial numbers and creation time
                //


                NtStatus = DraSetNT4ReplicationState(
                                pDomain,
                                &ReplicationStateAtPDC
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    retCode = RtlNtStatusToDosError(NtStatus);
                    goto Failure;
                }

            }
        }
        __finally
        {

            //
            // Reenable modifications to accounts database
            //

            DraAllowModifications();
        }

        //
        // Bump down retry count
        //

        RetryCount--;

    } while ( (!CheckpointTaken) && (RetryCount>0));


    if (!CheckpointTaken)
    {
        retCode = ERROR_DS_NO_CHECKPOINT_WITH_PDC;
        goto Failure;
    }

Success:

    //
    // The call succeeded. Either the checkpoint was taken,
    // or it is not necessary to take the check point.
    // Reschedule the operation at success interval

    *RescheduleInterval = DRACHKPT_SUCCESS_RETRY_INTERVAL;

     LogEvent(
         DS_EVENT_CAT_REPLICATION,
         DS_EVENT_SEV_MINIMAL,
         DIRLOG_NT4_REPLICATION_CHECKPOINT_SUCCESSFUL,
         NULL,
         NULL,
         NULL);

    return(0);

Failure:

     LogEvent(
         DS_EVENT_CAT_REPLICATION,
         DS_EVENT_SEV_ALWAYS,
         DIRLOG_NT4_REPLICATION_CHECKPOINT_UNSUCCESSFUL,
         szInsertWin32Msg(retCode),
         NULL,
         NULL);

    if (INVALID_HANDLE_VALUE!=ChangeLogHandle)
    {
        __try {
            dsI_NetLogonCloseChangeLog(
                                     ChangeLogHandle,
                                     FALSE
                                     );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }

    }

    *RescheduleInterval  = DRACHKPT_FAILURE_RETRY_INTERVAL;
    Assert(0!=retCode);
    return(retCode);

}

VOID
NT4ReplicationCheckpoint(
    VOID *  pV,
    VOID ** ppVNext,
    DWORD * pcSecsUntilNextIteration
    )
{
    DraTakeCheckPoint(NUM_CHKPT_RETRIES, pcSecsUntilNextIteration);
}

#ifdef INCLUDE_UNIT_TESTS
VOID
TestCheckPoint(VOID)
/*++
    Routine Description

        This is a basic test, that allows, manual initiation of
        a checkpoint

--*/
{
    ULONG RetryInterval;


    DraTakeCheckPoint(3,&RetryInterval);
}

VOID
RoleTransferStress(VOID)
/*++

    This is a more advanced test, that every 10 minutes will initiate
    taking a checkpoint followed by a role transfer. Coupled with a modify
    intensive test, this test is a good test bed for the non full sync
    role transfer code. The role transfer stress iterates through about
    48 iterations, which makes it run for about 8 hrs.

--*/
{
    ULONG i;
    ULONG RetryInterval;
    OPARG OpArg;
    OPRES *OpRes;
    PSID  DomainSid;
    ULONG RetCode;

    for (i=0;i<48;i++)
    {
        DraTakeCheckPoint(NUM_CHKPT_RETRIES,&RetryInterval);
        if (DRACHKPT_SUCCESS_RETRY_INTERVAL==RetryInterval)
        {
            KdPrint(("DS:RoleTransferStress : CheckPointSucceeded\n"));
        }
        else
        {
            KdPrint(("DS:RoleTransferStress : CheckPointFailed\n"));
        }

        RtlZeroMemory(&OpArg, sizeof(OPARG));
        OpArg.eOp = OP_CTRL_BECOME_PDC;
        DomainSid =  &gAnchor.pDomainDN->Sid;
        OpArg.pBuf = DomainSid;
        OpArg.cbBuf = RtlLengthSid(DomainSid);

        RetCode = DirOperationControl(&OpArg, &OpRes);

        if (0!=RetCode)
        {
            KdPrint(("DS:RoleTransferStress : Promotion Failed\n"));
        }
        else
        {
            KdPrint(("DS:RoleTransferStress: Promotion Succeeded\n"));
        }

        pTHStls->errCode=0;
        pTHStls->pErrInfo = NULL;

        Sleep(60*10*1000/*10 minutes*/);

        THRefresh();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\draasync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draasync.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database

#include <dsaapi.h>
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <mdglobal.h>                   // MD global definition header
#undef INCLUDE_OPTION_TRANSLATION_TABLES

#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dsconfig.h>
#include <windns.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsutil.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/


#include "debug.h"                      /* standard debugging header */
#define DEBSUB     "DRAASYNC:"          /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dstaskq.h"                    /* task queue stuff */
#include <ntdsctr.h>
#include "dsexcept.h"
#include "dramail.h"

#include <fileno.h>
#define  FILENO FILENO_DRAASYNC

#define THIRTY_MINUTES_IN_MSECS  (30*60*1000)
#define THIRTY_5_MINUTES_IN_SECS (35*60)

DWORD
draTranslateOptions(
    IN  DWORD                   InternalOptions,
    IN  OPTION_TRANSLATION *    Table
    );

#if DBG
// Do not query directly -- use helper function below.
BOOL g_fDraQueueIsLockedByTestHook = FALSE;

BOOL
draQueueIsLockedByTestHook(
    IN  DWORD   cNumMsecToWaitForLockRelease
    );
#endif

// If we have any operations in the queue at this priority or higher we will
// automatically boost AsyncThread's thread priority.
ULONG gulDraThreadOpPriThreshold = DEFAULT_DRA_THREAD_OP_PRI_THRESHOLD;

void dsa_notify(void);

DWORD TidDRAAsync = 0;

// The AO currently being worked on (sync or async).  Guarded by csAOList.
AO *gpaoCurrent = NULL;

// csAsyncThreadStart - guards multiple async thread starts.

CRITICAL_SECTION csAsyncThreadStart;

// csAOList - guards the async op list.

CRITICAL_SECTION csAOList;

// csLastReplicaMTX - guards pLastReplicaMTX
CRITICAL_SECTION csLastReplicaMTX;

// This is the count of async operations in the queue. We count operations
// in and out, and when there are none left, we assert that this is zero.
// Updates to this are shielded by csAOList.
ULONG gulpaocount = 0;

// This is how large we'll let gulpaocount grow before we increase the
// priority of the AyncThread
ULONG gulAOQAggressionLimit = DEFAULT_DRA_AOQ_LIMIT;

// Priorities for the DRA async thread.  Low vs. high is controlled by
// gulAOQAggressionLimit and gulDraThreadOpPriThreshold.
int gnDraThreadPriHigh = DEFAULT_DRA_THREAD_PRI_HIGH;
int gnDraThreadPriLow  = DEFAULT_DRA_THREAD_PRI_LOW;

// hmtxSyncLock
// Ensures that only one DRA operation (with the exception of getncchanges)
// runs at a time.

HANDLE hmtxSyncLock;

// paoFirst
// First pao in the list

AO *paoFirst = NULL;

// hevEntriesInAOList
// Event is unsignalled if no (unserviced) entries in async op list,
// signalled otherwise. This is cleared by AsyncOpThread after  servicing
// the last entry and signalled by AddAsyncOp when a new entry is added.

HANDLE hevEntriesInAOList = 0L;

// hevDRASetup
// Event is signalled when the DRA has been initialized

HANDLE hevDRASetup = 0L;

/* fAsyncThreadExists - Does the Async Op service thread exist? This thread
        is created the first time an async op is called, after that it lives
        forever.
*/
BOOL fAsyncThreadExists = FALSE;
HANDLE hAsyncThread;
HANDLE hmtxAsyncThread;

// fAsyncThreadAlive. Cleared by daemon, set by async thread,

BOOL fAsyncThreadAlive;

// fAsyncCheckStarted. Is the daemon started?
BOOL fAsyncAndQueueCheckStarted=FALSE;
ULONG gulReplQueueCheckTime;

DWORD lastSeen;         // Last thing async thread did

// gfDRABusy. Indicates DRA is busy doing something. When we detect
// that the async thread appears to be hung, we check that this flag
// to ensure that the DRA is not busy on a long async or sync
// task (such as synchronization).

BOOL gfDRABusy = FALSE;

// Time at which execution of the current AO began, or 0 if none.
DSTIME gtimeOpStarted = 0;

// Unique ID (per machine, per boot) for this AO.
ULONG gulSerialNumber = 0;

// Maximum number of mins we have to wait for a replication job before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxMinsSlowReplWarning = 0;

// Forward declarations

void CheckAsyncThread();
void CheckReplQueue();
void CheckAsyncThreadAndReplQueue(void *pv, void **ppvNext, DWORD *pcSecsUntilNext);

void GetDRASyncLock()
{
retrydrasl:

    if (WaitForSingleObject(hmtxSyncLock, THIRTY_MINUTES_IN_MSECS)) {
        if (!gfDRABusy) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_BASIC,
                        DIRLOG_DRA_DISPATCHER_TIMEOUT,
                        NULL,
                        NULL,
                        NULL);
        }
        goto retrydrasl;
    }
    Assert( TidDRAAsync == 0 ); // No recursive ownership
    TidDRAAsync = GetCurrentThreadId();
    Assert( TidDRAAsync != 0 );
}

void FreeDRASyncLock ()
{
    // We better own it
    Assert(OWN_DRA_LOCK());
    // Do this first so there won't be a timing window where the var is set
    // once the mutex is released.
    TidDRAAsync = 0;

    if (!ReleaseMutex(hmtxSyncLock)) {
        DWORD dwret;
        dwret = GetLastError();
        Assert (FALSE);
    }
}


void
FreeAO(
    IN  AO *  pao
    )
/*++

Routine Description:

    Free the given AO structure.

Arguments:

    pao (IN) - Pointer to AO structure to free.

Return Values:

    None.

--*/
{
    if (AO_OP_REP_SYNC == pao->ulOperation) {
        DEC(pcPendSync);
    }
    DEC(pcDRAReplQueueOps);

    if (pao->hDone) {
        CloseHandle(pao->hDone);
    }

    free(pao);
}

void logEventPaoFinished(
    AO *pao,
    DWORD cMinsDiff,
    DWORD ret
    )
{
    DPRINT4( 0, "Perf warning: Repl op %d, options 0x%x, status %d took %d mins.\n",
             pao->ulOperation, pao->ulOptions, ret, cMinsDiff );

    // szInsertDN can handle null arguments
    // Do we need a new event category for performance advisories?

    switch (pao->ulOperation) {

    case AO_OP_REP_ADD:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_ADD_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_add.pNC),
                  szInsertDN(pao->args.rep_add.pSourceDsaDN), // opt
                  szInsertDN(pao->args.rep_add.pTransportDN), // opt
                  szInsertMTX(pao->args.rep_add.pDSASMtx_addr),
                  sizeof( ret ),
                  &ret
            );
        break;
    case AO_OP_REP_DEL:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_DELETE_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_del.pNC),
                  szInsertMTX(pao->args.rep_del.pSDSAMtx_addr),
                  szInsertSz(""),  // unused parameter
                  szInsertSz(""),  // unused parameter
                  sizeof( ret ),
                  &ret
            );
        break;
    case AO_OP_REP_SYNC:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_SYNCHRONIZE_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.rep_sync.pNC),
                  pao->ulOptions & DRS_SYNC_BYNAME
                  ? szInsertWC(pao->args.rep_sync.pszDSA)      // opt
                  : szInsertUUID(&(pao->args.rep_sync.invocationid)),
                  szInsertSz(""),  // unused parameter
                  szInsertSz(""),  // unused parameter
                  sizeof( ret ),
                  &ret
            );
        break;
    case AO_OP_UPD_REFS:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_UPDATE_REFERENCES ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertDN(pao->args.upd_refs.pNC),
                  szInsertMTX(pao->args.upd_refs.pDSAMtx_addr),
                  szInsertUUID(&(pao->args.rep_sync.invocationid)),
                  szInsertSz(""),  // unused parameter
                  sizeof( ret ),
                  &ret
            );
        break;
    case AO_OP_REP_MOD:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertDsMsg( DIRLOG_PAO_MODIFY_REPLICA ),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  pao->args.rep_mod.puuidSourceDRA  // opt
                   ? szInsertUUID(pao->args.rep_mod.puuidSourceDRA)
                  :  szInsertSz(""),
                  pao->args.rep_mod.pmtxSourceDRA    // opt
                   ? szInsertMTX(pao->args.rep_mod.pmtxSourceDRA)
                  :  szInsertSz(""),
                  szInsertHex(pao->args.rep_mod.ulReplicaFlags),
                  szInsertHex(pao->args.rep_mod.ulModifyFields),
                  sizeof( ret ),
                  &ret
            );
        break;
    default:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_DRA_REPLICATION_FINISHED,
                  szInsertUL(cMinsDiff),
                  szInsertUL(pao->ulOperation),
                  szInsertHex(pao->ulOptions),
                  szInsertWin32Msg(ret),
                  szInsertSz(""),  // unused parameter
                  szInsertSz(""),  // unused parameter
                  szInsertSz(""),  // unused parameter
                  szInsertSz(""),  // unused parameter
                  sizeof( ret ),
                  &ret
            );
        break;
    }
}

DWORD DispatchPao(AO *pao)
{
    THSTATE *pTHS=NULL;
    DWORD ret;

    GetDRASyncLock();

    EnterCriticalSection(&csAOList);
    __try {
        Assert(NULL == gpaoCurrent);
        Assert(0 == gtimeOpStarted);
        gpaoCurrent = pao;
        pao->paoNext = paoFirst;
        gtimeOpStarted = GetSecondsSince1601();
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }
    __try {         /* Exception handler */

        /* Save type of thread we are so that deep in other code we will
         * know whether we should allow preemption or not.
         */

        __try {         // Finally handler

            // Discard request if we're not installed (unless it's install)

            Assert(OWN_DRA_LOCK());    // We'd better own it

            InitDraThread(&pTHS);

            // If you update this switch, please update logEventPao as well
            switch (pao->ulOperation) {

            case AO_OP_REP_ADD:
                pTHS->fIsValidLongRunningTask = TRUE;
                ret = DRA_ReplicaAdd(
                        pTHS,
                        pao->args.rep_add.pNC,
                        pao->args.rep_add.pSourceDsaDN,
                        pao->args.rep_add.pTransportDN,
                        pao->args.rep_add.pDSASMtx_addr,
                        pao->args.rep_add.pszSourceDsaDnsDomainName,
                        pao->args.rep_add.preptimesSync,
                        pao->ulOptions);
                break;

            case AO_OP_REP_DEL:
                pTHS->fIsValidLongRunningTask = TRUE;
                ret = DRA_ReplicaDel(
                        pTHS,
                        pao->args.rep_del.pNC,
                        pao->args.rep_del.pSDSAMtx_addr,
                        pao->ulOptions);
                break;

            case AO_OP_REP_SYNC:
                pTHS->fIsValidLongRunningTask = TRUE;
                ret = DRA_ReplicaSync(
                        pTHS,
                        pao->args.rep_sync.pNC,
                        &pao->args.rep_sync.invocationid,
                        pao->args.rep_sync.pszDSA,
                        pao->ulOptions);
                break;

            case AO_OP_UPD_REFS:
                ret = DRA_UpdateRefs(
                        pTHS,
                        pao->args.upd_refs.pNC,
                        pao->args.upd_refs.pDSAMtx_addr,
                        &pao->args.upd_refs.invocationid,
                        pao->ulOptions);
                break;

            case AO_OP_REP_MOD:
                ret = DRA_ReplicaModify(
                        pTHS,
                        pao->args.rep_mod.pNC,
                        pao->args.rep_mod.puuidSourceDRA,
                        pao->args.rep_mod.puuidTransportObj,
                        pao->args.rep_mod.pmtxSourceDRA,
                        &pao->args.rep_mod.rtSchedule,
                        pao->args.rep_mod.ulReplicaFlags,
                        pao->args.rep_mod.ulModifyFields,
                        pao->ulOptions
                        );
                break;

            default:
                RAISE_DRAERR_INCONSISTENT( pao->ulOperation );
                break;
            }
        } __finally {
            DWORD cMinsDiff = (DWORD) ((GetSecondsSince1601() - gtimeOpStarted) / 60);
            // Done with this operation.
            EnterCriticalSection(&csAOList);
            __try {
                gpaoCurrent = NULL;
                gtimeOpStarted = 0;
                gulpaocount--;
            }
            __finally {
                LeaveCriticalSection(&csAOList);
            }

            FreeDRASyncLock();

            if (cMinsDiff > gcMaxMinsSlowReplWarning) {
                logEventPaoFinished( pao, cMinsDiff, ret );
            }
        }

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // This is a normal exit path if we encounter a bad parameter
        // or out of memory etc, so nothing to do. Filter function
        // converts exception data to return code in ret, and
        // will assert if debug and the exception code is access
        // violation or unrecognized.
        ;
    }

    if(!pTHS) {
        ret = DRAERR_InternalError;
    }
    else if (pTHS->fSyncSet){
        // Correct problem now we've detected it
        pTHS->fSyncSet = FALSE;
        ret = DRAERR_InternalError;
    }

    if (ret) {
        if ( (ret == ERROR_DS_DRA_PREEMPTED) ||
             (ret == ERROR_DS_DRA_ABANDON_SYNC) ) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_CALL_EXIT_WARN,
                     szInsertUL(ret),
                     NULL,
                     NULL);
        } else {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_CALL_EXIT_BAD,
                     szInsertUL(ret),
                     NULL,
                     NULL);
        }
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_CALL_EXIT_OK,
                 NULL,
                 NULL,
                 NULL);
    }

    if (pTHS) {
        DraReturn(pTHS, ret);
    }

    free_thread_state();

    Assert(!OWN_DRA_LOCK());    // We better not own it

    return ret;
}

// PaoGet
// Get the first pao in the list if there is one and remove it from the list.

AO *
PaoGet(void)
{
    AO * paoRet;

    /* verify that if I'm here, I have the correct critical section */
    Assert(OWN_CRIT_SEC(csAOList));

    paoRet = paoFirst;
    if (paoRet) {
        paoFirst = paoRet->paoNext;
    }

    return paoRet;
}

void __cdecl
AsyncThread(void * unused)
/*++

Routine Description:

    Replication worker thread.  All serialized replication operations -- adds,
    syncs, deletes, etc. -- are performed by this thread.

    The only exception to this is that replication updates received via ISM are
    applied in the MailThread().

Arguments:

    Unused.

Return Values:

    None.

--*/
{
    DWORD dwException;
    ULONG ulErrorCode;
    ULONG ul2;
    PVOID dwEA;
    AO *  pao;

    __try { /* except */

        // Wait until DRA is setup.

        WaitForSingleObject(hevDRASetup, INFINITE);

        while (!eServiceShutdown) {
            HANDLE rghEnqueueWaits[2];

            fAsyncThreadAlive = TRUE;

            rghEnqueueWaits[0] = hevEntriesInAOList;
            rghEnqueueWaits[1] = hServDoneEvent;

            // Wait until there is an entry to service
            WaitForMultipleObjects(ARRAY_SIZE(rghEnqueueWaits),
                                   rghEnqueueWaits,
                                   FALSE,
                                   THIRTY_MINUTES_IN_MSECS);

            if (eServiceShutdown) {
                break;
            }

            /* Grab the async thread mutex, which tells the main thread that
             * there is an active async thread.
             */
            WaitForSingleObject(hmtxAsyncThread,INFINITE);

            InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);
            __try { /* finally */
                // Gain access to list
retrycrit:
#if DBG
                while (draQueueIsLockedByTestHook(5 * 1000)) {
                    DPRINT(0, "TEST HOOK: Replication queue is still locked, as requested.\n");
                }
#endif
                __try {
                    EnterCriticalSection(&csAOList);
                }
                __except (HandleMostExceptions(GetExceptionCode())) {
                    goto retrycrit;
                }
#if DBG
                if (draQueueIsLockedByTestHook(0)) {
                    LeaveCriticalSection(&csAOList);
                    goto retrycrit;
                }
#endif
                __try {
                    pao = PaoGet();

                    if (pao == NULL) {
                        ResetEvent(hevEntriesInAOList);
                    }
                }
                __finally {
                    LeaveCriticalSection(&csAOList);
                }

                if (pao != NULL) {
                    DWORD status;

                    lastSeen = 12;

                    // Dispatch routine and set return status.

                    status = DispatchPao(pao);

                    if (pao->ulOptions & DRS_ASYNC_OP) {
                        // Clean up.  DoOpDRS() does this for synchronous ops.
                        FreeAO(pao);
                    }
                    else {
                        // Record status and inform waiting thread we're done.
                        pao->ulResult = status;
                        if (!SetEvent(pao->hDone)) {
                            Assert(!"SetEvent() failed!");
                        }
                    }

                    lastSeen = 13;
                }
                else {
                    // We're completely caught up with all pending
                    // replication requests, which can reasonably be
                    // interpreted as saying we don't need to work
                    // quite so hard in the future.  Assuming that our
                    // initial syncs have already been scheduled (and
                    // completed), we should lower the priority of the
                    // async thread a notch, so as to let client threads
                    // zip through faster.
                    if (gfInitSyncsFinished) {
                        SetThreadPriority(GetCurrentThread(),
                                          gnDraThreadPriLow);
                    }
                }
            } __finally {
                InterlockedDecrement((ULONG *) &ulcActiveReplicationThreads);
                ReleaseMutex(hmtxAsyncThread);
                Assert(!OWN_DRA_LOCK());    // We'd better not own it
            }
        }
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException, &dwEA,
                               &ulErrorCode, &ul2)) {
        /* Oops, we died.  Don't log, since we believe that we've been here
         * at least once without a pTHStls.  Write up an obituary and then
         * lie down.
         */
        // We should never get here.  There is nothing in this function that
        // should generate any exception we would catch -- DispatchPao() wraps
        // itself in its own __try/__except.
        Assert(!"AsyncThread() exception caught!");
        fAsyncThreadAlive=FALSE;
        fAsyncThreadExists=FALSE;
        _endthreadex(dwException);
    }

    fAsyncThreadExists = FALSE;
}

BOOL
draIsSameOp(
    IN  AO *  pao1,
    IN  AO *  pao2
    )
/*++

Routine Description:

    Compare two operations to see if they describe the same operation type
    with identical parameters.

Arguments:

    pao1, pao2 (IN) - Operations to compare.

Return Values:

    None.

--*/
{
// TRUE iff (both NULL) || (neither NULL && NameMatched())
#define SAME_DN(a,b)                        \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && NameMatched(a,b)))

// TRUE iff (both NULL) || (neither NULL && MtxSame())
#define SAME_MTX(a,b)                       \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && MtxSame(a,b)))

// TRUE iff (both NULL) || (neither NULL && DnsNameCompare())
#define SAME_DNSNAME(a,b)                      \
    ((NULL == (a))                          \
     ? (NULL == (b))                        \
     : ((NULL != (b)) && DnsNameCompare_W (a,b)))

// TRUE iff (both NULL) || (neither NULL && !memcmp())
#define SAME_SCHED(a,b)                                     \
    ((NULL == (a))                                          \
     ? (NULL == (b))                                        \
     : ((NULL != (b)) && !memcmp(a,b,sizeof(REPLTIMES))))

// TRUE iff (both NULL) || (neither NULL && !memcmp())
#define SAME_UUID(a,b)                                  \
    ((NULL == (a))                                      \
     ? (NULL == (b))                                    \
     : ((NULL != (b)) && !memcmp(a,b,sizeof(GUID))))

    BOOL fIsIdentical = FALSE;

    if ((pao1->ulOperation == pao2->ulOperation)
        && (pao1->ulOptions == pao2->ulOptions)) {

        // If these are synchronous ops being waited on by different callers,
        // can they really be the same?
        Assert(pao1->hDone == NULL);
        Assert(pao2->hDone == NULL);

        switch (pao1->ulOperation) {
        case AO_OP_REP_ADD:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_add.pNC, pao2->args.rep_add.pNC)
                  && SAME_DN(pao1->args.rep_add.pSourceDsaDN,
                             pao2->args.rep_add.pSourceDsaDN)
                  && SAME_DN(pao1->args.rep_add.pTransportDN,
                             pao2->args.rep_add.pTransportDN)
                  && SAME_MTX(pao1->args.rep_add.pDSASMtx_addr,
                              pao2->args.rep_add.pDSASMtx_addr)
                  && SAME_DNSNAME(pao1->args.rep_add.pszSourceDsaDnsDomainName,
                                  pao2->args.rep_add.pszSourceDsaDnsDomainName)
                  && SAME_SCHED(pao1->args.rep_add.preptimesSync,
                                pao2->args.rep_add.preptimesSync);
            break;

        case AO_OP_REP_DEL:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_del.pNC, pao2->args.rep_del.pNC)
                  && SAME_MTX(pao1->args.rep_del.pSDSAMtx_addr,
                              pao2->args.rep_del.pSDSAMtx_addr);
            break;

        case AO_OP_REP_MOD:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_mod.pNC, pao2->args.rep_mod.pNC)
                  && SAME_UUID(pao1->args.rep_mod.puuidSourceDRA,
                               pao2->args.rep_mod.puuidSourceDRA)
                  && SAME_UUID(pao1->args.rep_mod.puuidTransportObj,
                               pao2->args.rep_mod.puuidTransportObj)
                  && SAME_MTX(pao1->args.rep_mod.pmtxSourceDRA,
                              pao2->args.rep_mod.pmtxSourceDRA)
                  && SAME_SCHED(&pao1->args.rep_mod.rtSchedule,
                                &pao2->args.rep_mod.rtSchedule)
                  && (pao1->args.rep_mod.ulReplicaFlags
                      == pao2->args.rep_mod.ulReplicaFlags)
                  && (pao1->args.rep_mod.ulModifyFields
                      == pao2->args.rep_mod.ulModifyFields);
            break;

        case AO_OP_REP_SYNC:
            fIsIdentical
                =    SAME_DN(pao1->args.rep_sync.pNC, pao2->args.rep_sync.pNC)
                  && SAME_UUID(&pao1->args.rep_sync.invocationid,
                               &pao2->args.rep_sync.invocationid)
                  && SAME_DNSNAME(pao1->args.rep_sync.pszDSA,
                                  pao2->args.rep_sync.pszDSA);
            break;

        case AO_OP_UPD_REFS:
            fIsIdentical
                =    SAME_DN(pao1->args.upd_refs.pNC, pao2->args.upd_refs.pNC)
                  && SAME_MTX(pao1->args.upd_refs.pDSAMtx_addr,
                              pao2->args.upd_refs.pDSAMtx_addr)
                  && SAME_UUID(&pao1->args.upd_refs.invocationid,
                               &pao2->args.upd_refs.invocationid);
            break;

        default:
            Assert(!"Unknown op type!");
        }
    }

    return fIsIdentical;
}


void
draFilterDuplicateOpsFromQueue(
    IN  AO *    pao,
    OUT BOOL *  pfAddToQ
    )
/*++

Routine Description:

    Scan the replication queue to determine if the given operation should be
    added to the queue.  There are three possibilities:

    1. There are no similar operations in the queue.  Queue is unchanged,
       *pfAddToQ = TRUE.

    2. There are one or more similar operations in the queue that are superseded
       by the new operation.  The superseded operations are removed from the
       queue, *pfAddToQ = TRUE.

    3. There is an existing operation in the queue that supersedes the new
       operation.  Queue is unchanged, *pfAddToQ = FALSE.

Arguments:

    pao (IN) - New operation that is a candidate for being added to the queue.

    pfAddToQ (OUT) - On return, TRUE iff the new operation should be added to
        the queue.

Return Values:

    None.

--*/
{
    BOOL  fHaveNewSyncAll = FALSE;
    AO *  paoTmp;
    AO *  paoTmpNext;
    AO ** ppaoPrevNext;
    BOOL  fAddToQ = TRUE;

    Assert(OWN_CRIT_SEC(csAOList));

    if (!(pao->ulOptions & DRS_ASYNC_OP)
        || (pao->ulOptions & DRS_NO_DISCARD)) {
        // We never consolidate synchronous or explicitly non-discardable
        // operations.
        *pfAddToQ = TRUE;
        return;
    }

    fHaveNewSyncAll = (pao->ulOperation == AO_OP_REP_SYNC)
                      && (pao->ulOptions & DRS_SYNC_ALL);

    for (paoTmp=paoFirst, ppaoPrevNext = &paoFirst;
         NULL != paoTmp;
         paoTmp = paoTmpNext) {

        // Save next pointer in case we free paoTmp
        paoTmpNext = paoTmp->paoNext;

        // If not same op type or existing op is non-discardable or synchronous,
        // no match.
        if ((pao->ulOperation != paoTmp->ulOperation)
            || !(paoTmp->ulOptions & DRS_ASYNC_OP)
            || (paoTmp->ulOptions & DRS_NO_DISCARD)) {
            continue;
        }

        if (AO_OP_REP_SYNC == pao->ulOperation) {
            // If this async op is a sync of the same NC with
            // the same writeable flag and the same syncing options,
            // check it further.

            if (((paoTmp->ulOptions & DRS_FULL_SYNC_NOW)
                 == (pao->ulOptions & DRS_FULL_SYNC_NOW))
                && NameMatched(pao->args.rep_sync.pNC,
                               paoTmp->args.rep_sync.pNC)
                && ((pao->ulOptions & DRS_WRIT_REP)
                    == (paoTmp->ulOptions & DRS_WRIT_REP))) {

                if (fHaveNewSyncAll) {
                    // If existing op is sync all, discard new op,
                    // unless the new op is of higher priority, in
                    // which case discard the old one
                    if ((paoTmp->ulOptions & DRS_SYNC_ALL)
                        && (paoTmp->ulPriority >= pao->ulPriority)) {
                        fAddToQ = FALSE;
                        break;
                    } else {
                        // This sync will be performed as a part of
                        // the new sync all, so remove
                        // existing sync from q.

                        gulpaocount--;
                        *ppaoPrevNext = paoTmp->paoNext;
                        FreeAO(paoTmp);
                        continue;       // Skip inc of ppaoPrevNext
                    }
                } else {
                    // New async op is not sync all, discard it if
                    // the existing op is a sync all, or identical
                    // specific sync.
                    // If the new op is higher priority, then leave
                    // both ops in the queue.

                    if ((paoTmp->ulPriority >= pao->ulPriority)
                        && ((paoTmp->ulOptions & DRS_SYNC_ALL)
                            || ((paoTmp->ulOptions & DRS_SYNC_BYNAME)
                                && (pao->ulOptions & DRS_SYNC_BYNAME)
                                && !_wcsicmp(paoTmp->args.rep_sync.pszDSA,
                                             pao->args.rep_sync.pszDSA))
                            || (!(paoTmp->ulOptions & DRS_SYNC_BYNAME)
                                && !(pao->ulOptions & DRS_SYNC_BYNAME)
                                && !memcmp(&pao->args.rep_sync.invocationid,
                                           &paoTmp->args.rep_sync.invocationid,
                                           sizeof(UUID))))) {
                        fAddToQ = FALSE;
                        break;
                    }
                }
            }
        } else if (draIsSameOp(pao, paoTmp)) {
            // Existing operation in the queue is sufficient to cover this
            // request.
            fAddToQ = FALSE;
            break;
        }

        ppaoPrevNext = &(paoTmp->paoNext);
    }

    *pfAddToQ = fAddToQ;
}


void
AddAsyncOp(
    IN OUT  AO *  pao
    )
/*++

Routine Description:

    Enqueue the operation described by the given AO structure to our worker
    thread (AsyncThread()) by inserting it into the priority queue.  If the
    operation is an asynchronous sync request it may be dropped (and freed)
    if an existing item in the queue is identical or is a superset of the
    request.  Conversely, if the new operation is a superset of an existing
    operation, the existing operation is removed from the queue.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to enqueue.

Return Values:

    None.

--*/
{
    BOOL fAddToQ = TRUE;
    AO *paoTmp;
    AO *paoTmpNext;
    AO **ppaoPrevNext;

    // Get permission to access list

retrycrit:
    __try {
        EnterCriticalSection(&csAOList);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        goto retrycrit;
    }

    __try {
        __try {
            EnterCriticalSection(&csAsyncThreadStart);
            if (!fAsyncThreadExists) {
                /* Set up task that checks that the async thread */
		/* and the status of the replication queue       */
                if (!fAsyncAndQueueCheckStarted) {
                    InsertInTaskQueue(TQ_CheckAsyncQueue, NULL, THIRTY_5_MINUTES_IN_SECS);
                    fAsyncAndQueueCheckStarted = TRUE;
                } 
                hAsyncThread = (HANDLE) _beginthread(AsyncThread, 0, NULL);
                fAsyncThreadExists = TRUE;
            }
        } __finally {
            LeaveCriticalSection(&csAsyncThreadStart);
        }

        draFilterDuplicateOpsFromQueue(pao, &fAddToQ);

        // If required, add pao to the list.  It is inserted immediately before
        // the first operation with a lesser priority.

        if (fAddToQ) {

            gulpaocount++;

            /* verify that if I'm here,
             * I have the correct critical section
             */
            Assert(OWN_CRIT_SEC(csAOList));

            // Find the 'next' pointer of the immediate predecessor of where pao
            // should be put in the queue.  (It should be enqueued right after
            // all other operations at its own or greater priority level.)
            for (ppaoPrevNext = &paoFirst, paoTmp = paoFirst;
                 (NULL != paoTmp) && (paoTmp->ulPriority >= pao->ulPriority);
                 ppaoPrevNext = &paoTmp->paoNext, paoTmp = paoTmp->paoNext) {
                ;  
            }

            // Wedge pao into its proper place in the queue.
            *ppaoPrevNext = pao;
            pao->paoNext = paoTmp;

            if (NULL != gpaoCurrent) {
                // In this case gpaoCurrent is the head of the linked list.
                // Make sure whatever we've added is linked in behind it.
                gpaoCurrent->paoNext = paoFirst;
            }

            // If we think it deserves it, make sure the AsyncThread is
            // running at its full normal priority
            if ((pao->ulPriority >= gulDraThreadOpPriThreshold)
                || (gulpaocount >= gulAOQAggressionLimit)) {
                SetThreadPriority(hAsyncThread, gnDraThreadPriHigh);
            }

            // Set hevEntriesInAOList
            if (!SetEvent(hevEntriesInAOList)) {
                Assert(FALSE);
            }
        } else {
            // Not queueing this op, so free its memory.
            FreeAO(pao);
        }
    } __finally {
        LeaveCriticalSection(&csAOList);
    }
}


void
SetOpPriority(
    IN OUT  AO *    pao
    )
/*++

Routine Description:

    Determine the priority of the operation described by the given AO structure
    and set its ulPriority element accordingly.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to manipulate.

Return Values:

    None.

--*/
{
    BOOL fWriteableNC = FALSE;
    BOOL fSystemNC = FALSE;
    NCL_ENUMERATOR nclEnum;

    switch (pao->ulOperation) {
    case AO_OP_REP_ADD:
    case AO_OP_REP_SYNC:
        if (pao->ulOptions & DRS_WRIT_REP) {
            fWriteableNC = TRUE;
        }
        else {
            NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
            NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pao->args.rep_sync.pNC);
            if (NCLEnumeratorGetNext(&nclEnum)) {
                fWriteableNC = TRUE;
            }
        }

        // Check for system NC's
        if (!DsaIsInstalling()) {
            Assert( gAnchor.pDMD );
            Assert( gAnchor.pConfigDN );

            fSystemNC = ( 
                (gAnchor.pDMD ? NameMatched( pao->args.rep_sync.pNC, gAnchor.pDMD ) : FALSE ) ||
                (gAnchor.pConfigDN ? NameMatched( pao->args.rep_sync.pNC, gAnchor.pConfigDN ) : FALSE )
                );
        }

        pao->ulPriority = AOPRI_SYNCHRONIZE_BASE;

        if (fWriteableNC) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_WRITEABLE;
        }

        if (!(pao->ulOptions & DRS_ASYNC_OP)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_SYNC;
        }

        if (!(pao->ulOptions & DRS_NEVER_SYNCED)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_INCREMENTAL;
        }

        if (pao->ulOptions & DRS_PREEMPTED) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_PREEMPTED;
        }

        if (fSystemNC) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_SYSTEM_NC;
        }
        
        // We use notification as an approximation of intrasitedness.  We could have
        // also used compression for this purpose.  Ideally we would compare the
        // site guids, or the presence of the transport dn, neither of which is
        // handy here. The reason we prefer notification is because it corresponds
        // to a sense of nearness. A link between sites which has notification
        // explicitly enabled by the user is considered "intrasite" for our purposes.
        if (!(pao->ulOptions & DRS_NEVER_NOTIFY)) {
            pao->ulPriority += AOPRI_SYNCHRONIZE_BOOST_INTRASITE;
        }

        break;

    case AO_OP_REP_DEL:
        pao->ulPriority = (pao->ulOptions & DRS_ASYNC_OP)
                            ? AOPRI_ASYNC_DELETE
                            : AOPRI_SYNC_DELETE;
        break;

    case AO_OP_UPD_REFS:
        pao->ulPriority = (pao->ulOptions & DRS_GETCHG_CHECK)
                            ? AOPRI_UPDATE_REFS_VERIFY
                            : AOPRI_UPDATE_REFS;
        break;

    case AO_OP_REP_MOD:
        pao->ulPriority = (pao->ulOptions & DRS_ASYNC_OP)
                            ? AOPRI_ASYNC_MODIFY
                            : AOPRI_SYNC_MODIFY;
        break;

    default:
        Assert(!"Unknown AO_OP in SetOpPriority()!");
        pao->ulPriority = 0;
        break;
    }
}


DWORD
DoOpDRS(
    IN OUT  AO *  pao
    )
/*++

Routine Description:

    Execute the operation described by the given AO -- synchronously or
    asynchronously, depending upon whether DRS_ASYNC_OP was specified in the
    AO options.

    pao must be malloc()'ed.  This routine (or one of its minions) will see to
    it that the structure is free()'d.

    This is the primary interface between the in-process replication head
    (DirReplica* in dradir.c) and the worker thread.

Arguments:

    pao (IN/OUT) - Pointer to AO structure to execute.

Return Values:

    None.

--*/
{
    DWORD retval = ERROR_SUCCESS;
    BOOL  fWaitForCompletion;

    pao->hDone = NULL;

    if (AO_OP_REP_SYNC == pao->ulOperation) {
        INC(pcPendSync); 
    }
    INC(pcDRAReplQueueOps);

    if (eServiceShutdown) {
        FreeAO(pao);
        return ERROR_DS_SHUTTING_DOWN;
    }

    __try {
        pao->timeEnqueued   = GetSecondsSince1601();
        pao->ulSerialNumber = InterlockedIncrement(&gulSerialNumber);

        // Determine priority level for this operation.
        SetOpPriority(pao);

        if (pao->ulOptions & DRS_ASYNC_OP) {
            fWaitForCompletion = FALSE;
        }
        else {
            fWaitForCompletion = TRUE;
            pao->hDone = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == pao->hDone) {
                retval = GetLastError();
                __leave;
            }
        }

        // Enqueue operation to our worker thread.
        AddAsyncOp(pao);

        if (fWaitForCompletion) {
            // Wait for the operation to be completed.
            HANDLE rgHandles[3];
            DWORD  waitStatus;

            rgHandles[0] = pao->hDone;
            rgHandles[1] = hServDoneEvent;
            rgHandles[2] = hAsyncThread;

            do {
                waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgHandles),
                                                    rgHandles,
                                                    FALSE,
                                                    THIRTY_MINUTES_IN_MSECS);
                switch (waitStatus) {
                case WAIT_OBJECT_0:
                    // Task completed.
                    retval = pao->ulResult;
                    break;

                case WAIT_OBJECT_0 + 1:
                    // DS is shutting down.
                    Assert(eServiceShutdown);
                    retval = ERROR_DS_SHUTTING_DOWN;
                    break;

                case WAIT_OBJECT_0 + 2:
                    // AsyncThread terminated -- should never happen.
                    Assert(!"AsyncThread() terminated unexpectedly!");
                    retval = ERROR_DS_SHUTTING_DOWN;
                    break;

                case WAIT_FAILED:
                    // Failure!
                    retval = GetLastError();
                    break;

                case WAIT_TIMEOUT:
                    // Task not done yet -- make sure we're making progress.
                    if (!gfDRABusy) {
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_BASIC,
                                 DIRLOG_DRA_DISPATCHER_TIMEOUT,
                                 NULL,
                                 NULL,
                                 NULL);
                    }
                    break;
                }
            } while (WAIT_TIMEOUT == waitStatus);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &retval)) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_CALL_EXIT_BAD,
                 szInsertUL(retval),
                 NULL,
                 NULL);
    }

    if (fWaitForCompletion && !eServiceShutdown) {
        // Clean up.  (In the async case, the AsyncThread does this.)
        // In the shutdown case, the AsyncThread() may be operating on this
        // very request, and when it finishes it will still try to signal us.
        // In that case, let it do so, and leak pao.  (We're about to
        // terminate anyway.)
        FreeAO(pao);
    }

    return retval;
}

BOOL
CheckReplQueueFileTimeLessThan(const FILETIME* pftimeOne, const FILETIME* pftimeTwo) {
    FILETIME ftimeZeroTime;
    DSTimeToFileTime(0,&ftimeZeroTime);
    //zero file time is invalid
    //"missing" time is not less than (assume missing time is current time since
    //time hasn't happened "yet", it's time will be at least current time)
    if (CompareFileTime(&ftimeZeroTime,pftimeOne)>=0) {
	return FALSE;
    }
    //same rational here
    if (CompareFileTime(&ftimeZeroTime,pftimeTwo)>=0) {
	return TRUE;
    }
    return (CompareFileTime(pftimeOne,pftimeTwo)<=0);

}

//CheckReplQueue
// Runs periodically to check the status of the replication queue.  Logs events if the
// currently executing operation is taking more than X time to execute (X is configurable 
// in the registry) and logs events if it finds an operation in the queue that is being
// starved not because of a long running event but because other higher priority events
// are run continually - ie the replication workload for this interval is too high.

void CheckReplQueue()
{
     //start
    DWORD err;
    DS_REPL_QUEUE_STATISTICSW * pReplQueueStats;
    THSTATE      *pTHS = pTHStls;
    FILETIME ftimeCurrTimeMinusSecInQueue;
    FILETIME ftimeOldestOp;
    DSTIME timeCurrentOpStarted;
    DSTIME timeOldestOp;
    
    ULONG ulSecInQueue;
    ULONG ulSecInExecution;
    CHAR szTime[SZDSTIME_LEN];
    LPSTR lpstrTime = NULL;
	
    DPRINT(1, " Entering critical section \n");
    EnterCriticalSection(&csAOList);

    __try {
	err = draGetQueueStatistics(pTHS, &pReplQueueStats);  
    } __finally {
	DPRINT(1, " Leaving critical section \n");
	LeaveCriticalSection(&csAOList);
    }

    if (!err) { 
	//gulReplQueueCheckTime is a registry variable, defaults to 12 hours (in seconds)
	ulSecInQueue = gulReplQueueCheckTime;
	ulSecInExecution = gulReplQueueCheckTime;

	FileTimeToDSTime(pReplQueueStats->ftimeCurrentOpStarted,&timeCurrentOpStarted);
	DSTimeToFileTime(GetSecondsSince1601()-ulSecInQueue,&ftimeCurrTimeMinusSecInQueue);


	if ((timeCurrentOpStarted!=0) && (timeCurrentOpStarted+ulSecInExecution<GetSecondsSince1601())) {
	    //current operation is stuck in the queue, log an error for this.
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_REPLICATION_OP_OVER_TIME_LIMIT,
		     szInsertDSTIME(timeCurrentOpStarted,szTime),
		     szInsertInt((ULONG)pReplQueueStats->cNumPendingOps),
		     NULL);
	}
	else if ((pReplQueueStats->cNumPendingOps>0)
		 &&
		 (
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestSync,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestAdd,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestDel,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestMod,&ftimeCurrTimeMinusSecInQueue))
		  ||
		  (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestUpdRefs,&ftimeCurrTimeMinusSecInQueue))
		  )
		 ) {
	    //some operation is being starved, find which operation and
	    //find the oldest time and convert it to dstime to print in the log  
	    ftimeOldestOp = pReplQueueStats->ftimeOldestSync;
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestAdd,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestAdd;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestDel,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestDel;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestMod,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestMod;
	    }
	    if (CheckReplQueueFileTimeLessThan(&pReplQueueStats->ftimeOldestUpdRefs,&ftimeOldestOp)) {
		ftimeOldestOp = pReplQueueStats->ftimeOldestUpdRefs;
	    }
	    FileTimeToDSTime(ftimeOldestOp,&timeOldestOp);
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_REPLICATION_OP_NOT_EXECUTING,
		     szInsertDSTIME(timeOldestOp,szTime),  
		     szInsertInt((ULONG)pReplQueueStats->cNumPendingOps),
		     NULL);

	}
    }
    else {
	Assert(!"Replication Queue Statistics are not available!");
    }
} //CheckReplQueue

// CheckAsyncThread.
//
// Runs periodically to check async thread is alive and that no thread
// is stuck in the mail DLL.
// This routine sets the fAsyncThreadAlive flag to FALSE, and if the
// dispatcher loop code has not set it to TRUE by the next time this
// routine runs, we log that the dispatcher thread is hung or gone.

void CheckAsyncThread()
{
    DWORD dwExitCode;

    if(eServiceShutdown) {
	/* Don't bother */
	goto End;
    }

    // Now check to see if the async thread is ok.

    if ((fAsyncThreadAlive == FALSE) && (!gfDRABusy)) {

	/* Thread does not appear to be executing dispatcher loop,
		 * see if the thread has terminated.
		 */

	GetExitCodeThread (hAsyncThread, &dwExitCode);
	if (dwExitCode != STILL_ACTIVE) {
	    __try {
		/* Yep, the thread is dead, */

		EnterCriticalSection(&csAsyncThreadStart);

		LogEvent(DS_EVENT_CAT_REPLICATION,
			 DS_EVENT_SEV_MINIMAL,
			 DIRLOG_DRA_DISP_DEAD_DETAILS,
			 szInsertHex(dwExitCode),
			 NULL,
			 NULL);


		if(!fAsyncThreadExists) {
		    /* And no one else has already restarted it.
				 * Restart the asyncthread.
			     */
		    hAsyncThread = (HANDLE)_beginthread(AsyncThread,
							0,
							NULL);
		    fAsyncThreadExists = TRUE;

		}

	    } __finally {
		LeaveCriticalSection(&csAsyncThreadStart);
	    }

	} else {
	    /* Thread is running, see if it has hung in an RPC call */

	    EnterCriticalSection(&csLastReplicaMTX);

	    __try {

		if (pLastReplicaMTX) {
		    /*
			     * We seem to be stuck in an RPC call.
			     * This is handled by RpcCancel(De)Register code.
			     * continue.
			     */

		    NULL;
		} else {
		    /* The thread is alive, but stuck somewhere other
			     * than an RPC call.  Log this condition.
			     */
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_DRA_DISPATCHER_DEAD,
			     szInsertUL(lastSeen),
			     NULL,
			     NULL);
		    /* One possibility is that the thread is languishing
			     * at some reduced priority.  Jack it back up.
				 */
		    SetThreadPriority(hAsyncThread,
				      gnDraThreadPriHigh);
		}
	    }
	    __finally {
		LeaveCriticalSection(&csLastReplicaMTX);
	    }
	}
    } else {
	// Dispatcher loop has been executed since last time this routine
	// ran, or DRA is busy. Clear the alive and busy flags so that
	// unless dispatcher loop runs again, or the DRA sets the busy
	// flag again, we'll notice we're dead next time.

	fAsyncThreadAlive = FALSE;
	gfDRABusy = FALSE;
    }
    End:;

}

// Taskq function to run CheckAsyncThread and CheckReplQueue
void 
CheckAsyncThreadAndReplQueue(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration) {
    __try {
	CheckAsyncThread();
	CheckReplQueue();
    }
    __finally {
	/* Set task to run again */
	if(!eServiceShutdown) {
	    *ppvNext = NULL;
	    *pcSecsUntilNextIteration = THIRTY_5_MINUTES_IN_SECS;
	}
    }

    (void) pv;   // unused
}

ULONG
draGetQueueStatistics(
    IN THSTATE * pTHS,
    OUT DS_REPL_QUEUE_STATISTICSW ** ppQueueStats)
/*++

Routine Description:

    Return statistics about the pending operations. Return the results
    by allocating and populating a DS_REPL_QUEUE_STATISTICSW structure.

    This data is public, available via ntdsapi.h.

    Caller must have already acquired the csAOList lock.

Arguments:

    pTHS (IN)

    ppPendingOps (OUT) - On successful return, holds a pointer to the
        populated queue statistics structure. This pointer will always
        be allocated unless the function returns an error.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DS_REPL_QUEUE_STATISTICSW * pQueueStats;
    AO * pao;
    DSTIME * ptimeOldestSync = NULL;
    DSTIME * ptimeOldestAdd = NULL;
    DSTIME * ptimeOldestDel = NULL;
    DSTIME * ptimeOldestMod = NULL;
    DSTIME * ptimeOldestUpdRefs = NULL;
    FILETIME ftimeTime;

    Assert(ARGUMENT_PRESENT(pTHS));
    Assert(ARGUMENT_PRESENT(ppQueueStats));
    Assert(OWN_CRIT_SEC(csAOList));

    pQueueStats = THAllocEx(pTHS, sizeof(DS_REPL_QUEUE_STATISTICSW));
    Assert(pQueueStats);

    // Set pQueueStats->ftimeCurrentOpStarted to
    // the time at which current op started executing.
    if (NULL != gpaoCurrent) {
        DSTimeToFileTime(gtimeOpStarted,
                         &pQueueStats->ftimeCurrentOpStarted);
    }

    // Set pQueueStats->cNumPendingOps to
    // the number of pending operations in the queue
    for (pao = gpaoCurrent ? gpaoCurrent : paoFirst;
         NULL != pao;
         pao = pao->paoNext)
    {
        pQueueStats->cNumPendingOps++;
	Assert(pQueueStats->cNumPendingOps <= gulpaocount); 

	//find oldest operation of each AO_OP_REP_ type
	switch (pao->ulOperation) {
	case AO_OP_REP_SYNC:
	    if (ptimeOldestSync) { 
		ptimeOldestSync = (*ptimeOldestSync > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestSync;
	    }
	    else {
		ptimeOldestSync = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_ADD:
	    if (ptimeOldestAdd) { 
		ptimeOldestAdd = (*ptimeOldestAdd > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestAdd;
	    }
	    else {
		ptimeOldestAdd = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_DEL:
	    if (ptimeOldestDel) { 
		ptimeOldestDel = (*ptimeOldestDel > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestDel;
	    }
	    else {
		ptimeOldestDel = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_REP_MOD:
	    if (ptimeOldestMod) { 
		ptimeOldestMod = (*ptimeOldestMod > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestMod;
	    }
	    else {
		ptimeOldestMod = &(pao->timeEnqueued);
	    }
	    break;

	case AO_OP_UPD_REFS:
	    if (ptimeOldestUpdRefs) { 
		ptimeOldestUpdRefs = (*ptimeOldestUpdRefs > pao->timeEnqueued) ? &(pao->timeEnqueued) : ptimeOldestUpdRefs;
	    }
	    else {
		ptimeOldestUpdRefs = &(pao->timeEnqueued);
	    }
	    break; 

        default:
	    Assert(!"Logic error - unhandled AO op type");
            DRA_EXCEPT(DRAERR_InternalError, 0);
	}

    }
    
    if (ptimeOldestSync) {
	DSTimeToFileTime(*ptimeOldestSync,&ftimeTime);
	pQueueStats->ftimeOldestSync = ftimeTime;
    }
         
    if (ptimeOldestAdd) {
	DSTimeToFileTime(*ptimeOldestAdd,&ftimeTime);
	pQueueStats->ftimeOldestAdd = ftimeTime;
    }

    if (ptimeOldestDel) {
	DSTimeToFileTime(*ptimeOldestDel,&ftimeTime);
	pQueueStats->ftimeOldestDel = ftimeTime;
    }
    if (ptimeOldestMod) {
	DSTimeToFileTime(*ptimeOldestMod,&ftimeTime);
	pQueueStats->ftimeOldestMod = ftimeTime;
    }
    if (ptimeOldestUpdRefs) {
	DSTimeToFileTime(*ptimeOldestUpdRefs,&ftimeTime);
	pQueueStats->ftimeOldestUpdRefs = ftimeTime;
    }
    *ppQueueStats = pQueueStats;
    return 0;
}

ULONG
draGetPendingOps(
    IN THSTATE * pTHS,
    IN DBPOS * pDB,
    OUT DS_REPL_PENDING_OPSW ** ppPendingOps
    )
/*++

Routine Description:

    Return the pending replication syncs.

    This data is public, available via ntdsapi.h.

    Caller must have already acquired the csAOList lock.

Arguments:

    pTHS (IN)

    ppPendingOps (OUT) - On successful return, holds a pointer to the
        completed pending syncs structure.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD                   cbPendingOps;
    DS_REPL_PENDING_OPSW *  pPendingOps;
    DS_REPL_OPW *           pOp;
    DS_REPL_OPW *           pOp2;
    AO *                    pao;
    DWORD                   dwFindFlags;
    MTX_ADDR *              pmtxDsaAddress;
    MTX_ADDR *              pmtxToFree;
    BOOL                    fTryToFindDSAInRepAtt;
    REPLICA_LINK *          pRepsFrom;
    DWORD                   cbRepsFrom;
    DSNAME                  GuidOnlyDN = {0};
    DSNAME *                pFullDN;
    ATTCACHE *              pAC;
    DWORD                   i;
    DWORD                   j;
    OPTION_TRANSLATION *    pOptionXlat;
    DSNAME *                pNC;

    Assert(OWN_CRIT_SEC(csAOList));

    GuidOnlyDN.structLen = DSNameSizeFromLen(0);

    cbPendingOps = offsetof(DS_REPL_PENDING_OPSW, rgPendingOp)
                     + sizeof(pPendingOps->rgPendingOp[0])
                       * gulpaocount;
    pPendingOps = THAllocEx(pTHS, cbPendingOps);

    if (NULL != gpaoCurrent) {
        // Translate time at which current op started executing.
        DSTimeToFileTime(gtimeOpStarted,
                         &pPendingOps->ftimeCurrentOpStarted);
    }

    pOp = &pPendingOps->rgPendingOp[0];

    for (pao = gpaoCurrent ? gpaoCurrent : paoFirst;
         NULL != pao;
         pao = pao->paoNext) {

        pmtxDsaAddress = NULL;
        pNC = NULL;

        DSTimeToFileTime(pao->timeEnqueued, &pOp->ftimeEnqueued);

        pOp->ulSerialNumber = pao->ulSerialNumber;
        pOp->ulPriority     = pao->ulPriority;

        switch (pao->ulOperation) {
        case AO_OP_REP_SYNC:
            // Is an enqueued sync operation.
            pOp->OpType = DS_REPL_OP_TYPE_SYNC;
            pOptionXlat = RepSyncOptionToDra;
            pNC = pao->args.rep_sync.pNC;

            if (pao->ulOptions & DRS_SYNC_BYNAME) {
                pOp->pszDsaAddress = pao->args.rep_sync.pszDSA;
            }
            else {
                pOp->uuidDsaObjGuid = pao->args.rep_sync.invocationid;
            }
            break;

        case AO_OP_REP_ADD:
            // Is an enqueued add operation.
            pOp->OpType = DS_REPL_OP_TYPE_ADD;
            pOptionXlat = RepAddOptionToDra;
            pNC = pao->args.rep_add.pNC;

            pmtxDsaAddress = pao->args.rep_add.pDSASMtx_addr;

            if (NULL != pao->args.rep_add.pSourceDsaDN) {
                pOp->pszDsaDN = pao->args.rep_add.pSourceDsaDN->StringName;
                pOp->uuidDsaObjGuid = pao->args.rep_add.pSourceDsaDN->Guid;
            }
            break;

        case AO_OP_REP_DEL:
            // Is an enqueued delete operation.
            pOp->OpType = DS_REPL_OP_TYPE_DELETE;
            pOptionXlat = RepDelOptionToDra;
            pNC = pao->args.rep_del.pNC;

            pmtxDsaAddress = pao->args.rep_del.pSDSAMtx_addr;
            break;

        case AO_OP_REP_MOD:
            // Is an enqueued modify operation.
            pOp->OpType = DS_REPL_OP_TYPE_MODIFY;
            pOptionXlat = RepModOptionToDra;
            pNC = pao->args.rep_mod.pNC;

            if (fNullUuid(pao->args.rep_mod.puuidSourceDRA)) {
                pmtxDsaAddress = pao->args.rep_mod.pmtxSourceDRA;
            }
            else {
                pOp->uuidDsaObjGuid = *pao->args.rep_mod.puuidSourceDRA;
            }
            break;

        case AO_OP_UPD_REFS:
            // Is an enqueued repsTo update operation.
            pOp->OpType = DS_REPL_OP_TYPE_UPDATE_REFS;
            pOptionXlat = UpdRefOptionToDra;
            pNC = pao->args.upd_refs.pNC;

            pmtxDsaAddress = pao->args.upd_refs.pDSAMtx_addr;
            pOp->uuidDsaObjGuid = pao->args.upd_refs.invocationid;
            break;

        default:
            Assert(!"Logic error - unhandled AO op type");
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Convert NC name.
        Assert(NULL != pNC);
        pOp->pszNamingContext = pao->args.rep_del.pNC->StringName;
        pOp->uuidNamingContextObjGuid = pao->args.rep_del.pNC->Guid;


        // Translate options bits to their public form.
        pOp->ulOptions = draTranslateOptions(pao->ulOptions,
                                             pOptionXlat);

        // Translate MTX_ADDR to transport address if necessary.
        if ((NULL == pOp->pszDsaAddress)
            && (NULL != pmtxDsaAddress)) {
            pOp->pszDsaAddress = TransportAddrFromMtxAddrEx(pmtxDsaAddress);
        }

        // If we have only one of the DSA's guid & address, try to use the one
        // we do have to determine the other.
        fTryToFindDSAInRepAtt = FALSE;
        pmtxToFree = NULL;
        if (fNullUuid(&pOp->uuidDsaObjGuid)) {
            // Don't have the DSA objectGuid.
            if ((NULL == pmtxDsaAddress)
                && (NULL != pOp->pszDsaAddress)) {
                // Derive MTX_ADDR from transport address.
                pmtxDsaAddress
                    = MtxAddrFromTransportAddrEx(pTHS, pOp->pszDsaAddress);
                pmtxToFree = pmtxDsaAddress;
            }

            if (NULL != pmtxDsaAddress) {
                // Try to derive ntdsDsa objectGuid from transport address.
                fTryToFindDSAInRepAtt = TRUE;
                dwFindFlags = DRS_FIND_DSA_BY_ADDRESS;
            }
        }
        else if (NULL == pOp->pszDsaAddress) {
            if (!fNullUuid(&pOp->uuidDsaObjGuid)) {
                // Try to derive transport address from ntdsDsa objectGuid.
                fTryToFindDSAInRepAtt = TRUE;
                dwFindFlags = DRS_FIND_DSA_BY_UUID;
            }
        }

        if (fTryToFindDSAInRepAtt
            && !DBFindDSName(pDB, pNC)
            && (0 == FindDSAinRepAtt(pDB,
                                     ATT_REPS_FROM,
                                     dwFindFlags,
                                     &pOp->uuidDsaObjGuid,
                                     pmtxDsaAddress,
                                     NULL,
                                     &pRepsFrom,
                                     &cbRepsFrom))) {
            // We're able to find a repsFrom for this source.
            if (DRS_FIND_DSA_BY_ADDRESS == dwFindFlags) {
                Assert(NULL != pOp->pszDsaAddress);
                pOp->uuidDsaObjGuid = pRepsFrom->V1.uuidDsaObj;
            }
            else {
                Assert(!fNullUuid(&pOp->uuidDsaObjGuid));
                pOp->pszDsaAddress
                    = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFrom));
            }

            THFreeEx(pTHS, pRepsFrom);
        }

        if (NULL != pmtxToFree) {
            THFreeEx(pTHS, pmtxToFree);
        }

        pPendingOps->cNumPendingOps++;
        Assert(pPendingOps->cNumPendingOps <= gulpaocount);
        pOp++;
    }

    // Translate any ntdsDsa objectGuids we found into string names, if we don't
    // already know them.
    pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);

    for (i = 0; i < pPendingOps->cNumPendingOps; i++) {
        pOp = &pPendingOps->rgPendingOp[i];

        if ((NULL == pOp->pszDsaDN)
            && !fNullUuid(&pOp->uuidDsaObjGuid)) {

            GuidOnlyDN.Guid = pOp->uuidDsaObjGuid;
            if (!DBFindDSName(pDB, &GuidOnlyDN)) {
                pFullDN = GetExtDSName(pDB);
                pOp->pszDsaDN = pFullDN->StringName;

                for (j = i+1; j < pPendingOps->cNumPendingOps; j++) {
                    pOp2 = &pPendingOps->rgPendingOp[j];

                    if (0 == memcmp(&pOp->uuidDsaObjGuid,
                                    &pOp2->uuidDsaObjGuid,
                                    sizeof(GUID))) {
                        // Same guid, same DN.
                        pOp2->pszDsaDN = pFullDN->StringName;
                    }
                }
            }
        }
    }

    *ppPendingOps = pPendingOps;

    return 0;
}


BOOL
IsHigherPriorityDraOpWaiting(void)
/*++

Routine Description:

    Determine whether there is a higher priority operation waiting in the queue
    than that that is currently executing.

Arguments:

    None.

Return Values:

    TRUE if a higher priority operation is waiting (and therefore the current
    operation should be preempted); FALSE otherwise.

--*/
{
    BOOL fPreempt = FALSE;

    // Note that gpaoCurrent will be NULL in the mail-based UpdateNC() case --
    // see ProcessUpdReplica() in dramail.c.

    EnterCriticalSection(&csAOList);
    __try {
        fPreempt = (NULL != gpaoCurrent)
                   && (NULL != paoFirst)
                   && (gpaoCurrent->ulPriority < paoFirst->ulPriority);
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }

    return fPreempt;
}


BOOL
IsDraOpWaiting(void)
/*++

Routine Description:

    Determine whether there is a operation waiting in the queue

Arguments:

    None.

Return Values:

    TRUE if an operation is waiting; FALSE otherwise.

--*/
{
    BOOL fWaiting = FALSE;

    // Note that gpaoCurrent will be NULL in the mail-based UpdateNC() case --
    // see ProcessUpdReplica() in dramail.c.

    EnterCriticalSection(&csAOList);
    __try {
        fWaiting = (NULL != paoFirst);
    }
    __finally {
        LeaveCriticalSection(&csAOList);
    }

    return fWaiting;
}


void
InitDraQueue(void)
/*++

Routine Description:

    Initialize the worker thread state.  Called once (indirectly) per
    DsInitialize().

Arguments:

    None.

Return Values:

    None.

--*/
{
    gpaoCurrent = NULL;
    gulpaocount = 0;
    paoFirst = NULL;
    fAsyncThreadAlive = FALSE;
    fAsyncAndQueueCheckStarted = FALSE;
}


DWORD
draTranslateOptions(
    IN  DWORD                   InternalOptions,
    IN  OPTION_TRANSLATION *    Table
    )
/*++

Routine Description:

    Utility routine to translate options bit from internal form to their
    public equivalent.

Arguments:

    InternalOptions -

    Table -

Return Value:

    Translated options.

--*/
{
    DWORD i, publicOptions;

    publicOptions = 0;
    for(i = 0; 0 != Table[i].InternalOption; i++) {
        if (InternalOptions & Table[i].InternalOption) {
            publicOptions |= Table[i].PublicOption;
        }
    }

    return publicOptions;
} /* draTranslateOptions */

#if DBG

BOOL
draQueueIsLockedByTestHook(
    IN  DWORD   cNumMsecToWaitForLockRelease
    )
/*++

Routine Description:

    Determine whether the queue should be considered "locked," ergo no
    operations should be dispatched.

    This routine is provided solely as a test hook.

Arguments:

    cNumMsecToWaitForLockRelease (IN) - Number of milliseconds to wait for queue
        to be unlocked, if we initially find it to be locked.

Return Values:

    TRUE if queue is locked, FALSE otherwise.

--*/
{
    HANDLE hevWaitHandles[2] = {hevEntriesInAOList, hServDoneEvent};
    DWORD cTickStart = GetTickCount();
    DWORD cTickDiff;
    DWORD cNumMsecRemainingToWait = cNumMsecToWaitForLockRelease;

    while (!eServiceShutdown
           && g_fDraQueueIsLockedByTestHook
           && cNumMsecRemainingToWait) {
        // Queue is locked and caller asked us to wait a bit to see if it's
        // unlocked.  Poll every half second to see if the lock has been
        // released yet.  If this were anything more than a test hook, we would
        // implement a new event rather than poll, but as it is we're trying to
        // minimize code impact.

        WaitForSingleObject(hServDoneEvent,
                            min(cNumMsecRemainingToWait, 500));

        cTickDiff = GetTickCount() - cTickStart;
        if (cTickDiff > cNumMsecToWaitForLockRelease) {
            cNumMsecRemainingToWait = 0;
        } else {
            cNumMsecRemainingToWait = cNumMsecToWaitForLockRelease - cTickDiff;
        }
    }

    if (eServiceShutdown) {
        // Shutting down -- clear any remaining queue locks so we can bail out.
        g_fDraQueueIsLockedByTestHook = FALSE;
    }

    return g_fDraQueueIsLockedByTestHook;
}

ULONG
DraSetQueueLock(
    IN  BOOL  fSetLock
    )
/*++

Routine Description:

    Lock (or unlock, if !fSetLock) the replication operation queue.  While the
    queue is locked no operations in the queue will be performed or removed
    (although additional operations can be added).

    This routine is provided solely as a test hook.

Arguments:

    fSetLock (IN) - Acquire (fSetLock) or release (!fSetLock) lock.

Return Values:

    Win32 error code.

--*/
{
    g_fDraQueueIsLockedByTestHook = fSetLock;

    return 0;
}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dracrypt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dracrypt.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to sign/encrypt asynchronous (e.g., mail) replication messages.

DETAILS:

CREATED:

    3/5/98      Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <wincrypt.h>
#include <certca.h>
#include <cryptui.h>

#include <ntdsctr.h>                    // PerfMon hook support
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <attids.h>
#include <drs.h>                        // DRS_MSG_*

#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsexcept.h"

#include "drserr.h"
#include "dramail.h"
#include "drautil.h"

#include "debug.h"                      /* standard debugging header */
#define  DEBSUB "DRACRYPT:"             /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_DRACRYPT


///////////////////////////////////////////////////////////////////////////////
//
//  MACROS
//

// Use this constant definition (or one similar to it) to define
// a single encoding type that can be used in all parameters and
// data members that require one or the other or both.
#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING)

// How frequently do we log an error if we have no DC certificate? (secs)
#define NO_CERT_LOG_INTERVAL (15 * 60)

// Various hooks for unit test harness.
#ifdef TEST_HARNESS

#undef THAllocEx
#define THAllocEx(pTHS, x) LocalAlloc(LPTR, x)

#undef THReAllocEx
#define THReAllocEx(pTHS, x, y) LocalReAlloc(x, y, LPTR)

#define THFree(x) LocalFree(x)

#undef DRA_EXCEPT
#define DRA_EXCEPT(x, y)                                                    \
    {                                                                       \
        CHAR sz[1024];                                                      \
        sprintf(sz, "DRA_EXCEPT(%d, 0x%x) @ line %d\n", x, y, __LINE__);    \
        OutputDebugString(sz);                                              \
        DebugBreak();                                                       \
        ExitProcess(-1);                                                    \
    }

#undef LogUnhandledError
#define LogUnhandledError(x)                                                \
    {                                                                       \
        CHAR sz[1024];                                                      \
        sprintf(sz, "LogUnhandledError(0x%x) @ line %d\n", x, __LINE__);    \
        OutputDebugString(sz);                                              \
        DebugBreak();                                                       \
        ExitProcess(-1);                                                    \
    }

#endif // #ifdef TEST_HARNESS


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION PROTOTYPES
//

PCCERT_CONTEXT
draGetDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore
    );

void
draVerifyCertAuthorization(
    IN  THSTATE      *  pTHS,
    IN  PCCERT_CONTEXT  pCertContext
    );

#ifdef TEST_HARNESS
#define draIsDsaComputerObjGuid(x) (TRUE)
#else // #ifdef TEST_HARNESS
BOOL
draIsDsaComputerObjGuid(
    IN  GUID *  pComputerObjGuid
    );
#endif // #else // #ifdef TEST_HARNESS


void
draGetCertArrayToSend(
    IN  THSTATE *           pTHS,
    IN  HCERTSTORE          hCertStore,
    OUT DWORD *             pcNumCerts,
    OUT PCCERT_CONTEXT **   prgpCerts
    );

void
draFreeCertArray(
    IN  DWORD               cNumCerts,
    IN  PCCERT_CONTEXT *    rgpCerts
    );

PCCERT_CONTEXT
WINAPI
draGetAndVerifySignerCertificate(
    IN  VOID *      pvGetArg,
    IN  DWORD       dwCertEncodingType,
    IN  PCERT_INFO  pSignerId,
    IN  HCERTSTORE  hCertStore
    );

CERT_ALT_NAME_ENTRY *
draGetCertAltNameEntry(
    IN  THSTATE *       pTHS,
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           dwAltNameChoice,
    IN  LPSTR           pszOtherNameOID     OPTIONAL
    );


///////////////////////////////////////////////////////////////////////////////
//
//  GLOBAL FUNCTION IMPLEMENTATIONS
//

void
draSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsignedMailRepMsg,
    OUT MAIL_REP_MSG ** ppSignedMailRepMsg
    )
/*++

Routine Description:

    Sign the given asynchronous replication message.

    This code is aware of variable length headers.

Arguments:

    pUnsignedMailRepMsg (IN) - Message to sign.
    
    ppSignedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated signed version of the message.

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BYTE *                      MessageArray[1];
    DWORD                       MessageSizeArray[] = {pUnsignedMailRepMsg->cbDataSize};
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCert = NULL;
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_SIGN_MESSAGE_PARA     SigParams;
    DWORD                       cbSignedData;
    MAIL_REP_MSG *              pSignedMailRepMsg;
    DWORD                       winError;
    PCCERT_CONTEXT *            rgpCertsToSend = NULL;
    DWORD                       cCertsToSend = 0;
    PCHAR                       pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pUnsignedMailRepMsg));

    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Get our certificate plus the signing CAs' certificates.
        draGetCertArrayToSend(pTHS, hStoreHandle, &cCertsToSend,
                              &rgpCertsToSend);
        pSignerCert = rgpCertsToSend[0];

        // Initialize the Algorithm Identifier structure.
        memset(&HashAlgorithm, 0, sizeof(HashAlgorithm));
        HashAlgorithm.pszObjId = szOID_RSA_MD5;

        // Initialize the signature structure.
        memset(&SigParams, 0, sizeof(SigParams));
        SigParams.cbSize            = sizeof(SigParams);
        SigParams.dwMsgEncodingType = MY_ENCODING_TYPE;
        SigParams.pSigningCert      = pSignerCert;
        SigParams.HashAlgorithm     = HashAlgorithm;
        SigParams.cMsgCert          = cCertsToSend;
        SigParams.rgpMsgCert        = rgpCertsToSend;

        pbDataIn = MAIL_REP_MSG_DATA(pUnsignedMailRepMsg);
        MessageArray[0] = pbDataIn;

        // Get the size of the buffer needed to hold the signed data.
        ok = CryptSignMessage(
                  &SigParams,               // Signature parameters
                  FALSE,                    // Not detached
                  ARRAY_SIZE(MessageArray), // Number of messages
                  MessageArray,             // Messages to be signed
                  MessageSizeArray,         // Size of messages
                  NULL,                     // Buffer for signed msg
                  &cbSignedData);           // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Allocate memory for the signed blob.
        pSignedMailRepMsg = THAllocEx(pTHS,
                                      pUnsignedMailRepMsg->cbDataOffset
                                      + cbSignedData);

        // Copy all but the message data.
        memcpy(pSignedMailRepMsg,
               pUnsignedMailRepMsg,
               pUnsignedMailRepMsg->cbDataOffset);

        pbDataOut = MAIL_REP_MSG_DATA(pSignedMailRepMsg);

        // Sign the message.
        ok = CryptSignMessage(
                  &SigParams,               // Signature parameters
                  FALSE,                    // Not detached
                  ARRAY_SIZE(MessageArray), // Number of messages
                  MessageArray,             // Messages to be signed
                  MessageSizeArray,         // Size of messages
                  pbDataOut,                // Buffer for signed msg
                  &cbSignedData);           // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now signed.
        pSignedMailRepMsg->dwMsgType |= MRM_MSG_SIGNED;
        pSignedMailRepMsg->cbUnsignedDataSize = pSignedMailRepMsg->cbDataSize;
        pSignedMailRepMsg->cbDataSize         = cbSignedData;

        *ppSignedMailRepMsg = pSignedMailRepMsg;
    }
    __finally {
        if (NULL != rgpCertsToSend) {
            draFreeCertArray(cCertsToSend, rgpCertsToSend);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSignedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsignedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    )
/*++

Routine Description:

    Verify the signature on a given replication message.  Also ensure that
    the sender's certificate is signed by a certifying authority we trust,
    and that it was issued to a domain controller in our enterprise.

    This routine takes the message header and the data pointer as separate
    items. This allows the caller to specify separate buffers for each
    that will be concatenated into a new buffer.

Arguments:

    pSignedMailRepMsg (IN) - Message to verify.  Data field not valid.

    pbData (IN) - Start of data

    ppunsignedmailrepmsg (OUT) - On return, holds a pointer to the thread-
        allocated unsigned version of the message.
        
    phSignerCert (OUT, OPTIONAL) - Holds a handle to the sender's certificate
        on return.  This handle can be used in subsequent calls to
        draEncryptAndSignMessage(), for example.  It is the caller's
        responsibility to eventually call draFreeCertHandle(*phSignerCert).

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BOOL                        ok = FALSE;
    PCCERT_CONTEXT              pSignerCertContext = NULL;
    DWORD                       winError;
    CRYPT_VERIFY_MESSAGE_PARA   VerifyParams;
    MAIL_REP_MSG *              pUnsignedMailRepMsg;
    PCCERT_CONTEXT              pCertContext;

    Assert(pSignedMailRepMsg->dwMsgType & MRM_MSG_SIGNED);
    Assert(MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(pSignedMailRepMsg));

    __try {
        // Initialize the CRYPT_VERIFY_MESSAGE_PARA structure (Step 4).
        memset(&VerifyParams, 0, sizeof(VerifyParams));
        VerifyParams.cbSize                   = sizeof(VerifyParams);
        VerifyParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        VerifyParams.pfnGetSignerCertificate  = draGetAndVerifySignerCertificate;
        
        // Allocate buffer to hold the unsigned message.
        pUnsignedMailRepMsg = THAllocEx(pTHS,
                                        MAIL_REP_MSG_CURRENT_HEADER_SIZE
                                        + pSignedMailRepMsg->cbUnsignedDataSize);
        *pUnsignedMailRepMsg = *pSignedMailRepMsg;
        pUnsignedMailRepMsg->cbDataOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        pUnsignedMailRepMsg->cbDataSize = pSignedMailRepMsg->cbUnsignedDataSize;

        ok = CryptVerifyMessageSignature(
                    &VerifyParams,                      // Verify parameters
                    0,                                  // Signer index
                    pbData,                             // Pointer to signed blob
                    pSignedMailRepMsg->cbDataSize,      // Size of signed blob
                    MAIL_REP_MSG_DATA(pUnsignedMailRepMsg), // Buffer for decoded msg
                    &pUnsignedMailRepMsg->cbDataSize,   // Size of buffer
                    &pSignerCertContext);               // Pointer to signer cert
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now unsigned.
        pUnsignedMailRepMsg->dwMsgType &= ~MRM_MSG_SIGNED;

        // Verify sender's authorization.
        draVerifyCertAuthorization(pTHS, pSignerCertContext);

        // Return unsigned message to caller.
        *ppUnsignedMailRepMsg = pUnsignedMailRepMsg;

        // Return signer's cert if requested.
        if (NULL != phSignerCert) {
            *phSignerCert = (DRA_CERT_HANDLE) pSignerCertContext;
        }
    }
    __finally {
        if (pSignerCertContext
            && (AbnormalTermination() || (NULL == phSignerCert))
            && !CertFreeCertificateContext(pSignerCertContext)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draEncryptAndSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsealedMailRepMsg,
    IN  DRA_CERT_HANDLE hRecipientCert,
    OUT MAIL_REP_MSG ** ppSealedMailRepMsg
    )
/*++

Routine Description:

    Sign & seal the given asynchronous replication message.

    This code is aware of variable length headers.

Arguments:

    pUnsealedMailRepMsg (IN) - Message to seal.
    
    hRecipientCert (IN) - Handle to certificate of the recipient for which the
        message is to be encrypted.
    
    ppSealedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated sealed version of the message.

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCert = NULL;
    PCCERT_CONTEXT *            rgpCertsToSend = NULL;
    DWORD                       cCertsToSend;
    PCCERT_CONTEXT              MsgRecipientArray[1];
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_ALGORITHM_IDENTIFIER  CryptAlgorithm;
    CRYPT_SIGN_MESSAGE_PARA     SigParams;
    CRYPT_ENCRYPT_MESSAGE_PARA  EncryptParams;
    CMSG_RC4_AUX_INFO           Rc4AuxInfo;
    DWORD                       cbSignedData = 0;
    MAIL_REP_MSG *              pSealedMailRepMsg;
    DWORD                       winError;
    PCCERT_CONTEXT              pCertContext = (PCCERT_CONTEXT) hRecipientCert;
    PCHAR                       pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pUnsealedMailRepMsg));
    
    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Get our certificate plus the signing CAs' certificates.
        draGetCertArrayToSend(pTHS, hStoreHandle, &cCertsToSend,
                              &rgpCertsToSend);
        pSignerCert = rgpCertsToSend[0];

        // Initialize the Algorithm Identifier for hashing.
        memset(&HashAlgorithm, 0, sizeof(HashAlgorithm));
        HashAlgorithm.pszObjId = szOID_RSA_MD5;

        // Initialize the signature structure.
        memset(&SigParams, 0, sizeof(SigParams));
        SigParams.cbSize            = sizeof(SigParams);
        SigParams.dwMsgEncodingType = MY_ENCODING_TYPE;
        SigParams.pSigningCert      = pSignerCert;
        SigParams.HashAlgorithm     = HashAlgorithm;
        SigParams.cMsgCert          = cCertsToSend;
        SigParams.rgpMsgCert        = rgpCertsToSend;

        // Initialize the Algorithm Identifier for encrypting.
        memset(&CryptAlgorithm, 0, sizeof(CryptAlgorithm));
        CryptAlgorithm.pszObjId = szOID_RSA_RC4;

        // Initialize array of recipients.
        MsgRecipientArray[0] = pCertContext;

        // Specify RC4 key size of 56 bits
        memset( &Rc4AuxInfo, 0, sizeof(Rc4AuxInfo) );
        Rc4AuxInfo.cbSize      = sizeof(Rc4AuxInfo);
        Rc4AuxInfo.dwBitLen    = 56;

        // Initialize the encryption structure.
        memset(&EncryptParams, 0, sizeof(EncryptParams));
        EncryptParams.cbSize                     = sizeof(EncryptParams);
        EncryptParams.dwMsgEncodingType          = MY_ENCODING_TYPE;
        EncryptParams.ContentEncryptionAlgorithm = CryptAlgorithm;
        EncryptParams.pvEncryptionAuxInfo        = &Rc4AuxInfo;

        pbDataIn = MAIL_REP_MSG_DATA(pUnsealedMailRepMsg);

        // Get the size of the buffer needed to hold the signed/encrypted data.
        ok = CryptSignAndEncryptMessage(
                  &SigParams,                   // Signature parameters
                  &EncryptParams,               // Encryption params
                  ARRAY_SIZE(MsgRecipientArray),// Number of recipients
                  MsgRecipientArray,            // Recipients
                  pbDataIn,
                  pUnsealedMailRepMsg->cbDataSize,
                  NULL,                         // Buffer for signed msg
                  &cbSignedData);               // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Allocate memory for the signed blob.
        pSealedMailRepMsg = THAllocEx(pTHS,
                                      pUnsealedMailRepMsg->cbDataOffset
                                      + cbSignedData);

        // Copy all but the message data.
        memcpy(pSealedMailRepMsg,
               pUnsealedMailRepMsg,
               pUnsealedMailRepMsg->cbDataOffset);

        pbDataOut = MAIL_REP_MSG_DATA(pSealedMailRepMsg);

        // Sign the message.
        ok = CryptSignAndEncryptMessage(
                  &SigParams,                   // Signature parameters
                  &EncryptParams,               // Encryption params
                  ARRAY_SIZE(MsgRecipientArray),// Number of recipients
                  MsgRecipientArray,            // Recipients
                  pbDataIn,
                  pUnsealedMailRepMsg->cbDataSize,
                  pbDataOut,                    // Buffer for signed msg
                  &cbSignedData);               // Size of buffer
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now signed & encrypted.
        pSealedMailRepMsg->dwMsgType |= MRM_MSG_SIGNED | MRM_MSG_SEALED;
        pSealedMailRepMsg->cbUnsignedDataSize = pSealedMailRepMsg->cbDataSize;
        pSealedMailRepMsg->cbDataSize         = cbSignedData;

        *ppSealedMailRepMsg = pSealedMailRepMsg;
    }
    __finally {
        if (NULL != rgpCertsToSend) {
            draFreeCertArray(cCertsToSend, rgpCertsToSend);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draDecryptAndVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSealedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsealedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    )
/*++

Routine Description:

    Decrypt and verify the signature on a given replication message.  Also
    ensure that the sender's certificate is signed by a certifying authority we
    trust, and that it was issued to a domain controller in our enterprise.

    This routine takes the message header and the data pointer as separate
    items. This allows the caller to specify separate buffers for each
    that will be concatenated into a new buffer.

Arguments:

    pSignedMailRepMsg (IN) - Message to verify. Data field not valid.
    
    pbData (IN ) - Start of data

    ppUnsignedMailRepMsg (OUT) - On return, holds a pointer to the thread-
        allocated unsigned version of the message.
        
    phSignerCert (OUT, OPTIONAL) - Holds a handle to the sender's certificate
        on return.  This handle can be used in subsequent calls to
        draEncryptAndSignMessage(), for example.  It is the caller's
        responsibility to eventually call draFreeCertHandle(*phSignerCert).

Return Values:

    None.  Throws DRA exception on failure.

--*/
{
    BOOL                        ok = FALSE;
    HCERTSTORE                  hStoreHandle = NULL;
    PCCERT_CONTEXT              pSignerCertContext = NULL;
    DWORD                       winError;
    CRYPT_DECRYPT_MESSAGE_PARA  DecryptParams;
    CRYPT_VERIFY_MESSAGE_PARA   VerifyParams;
    MAIL_REP_MSG *              pUnsealedMailRepMsg;

    Assert((pSealedMailRepMsg->dwMsgType & MRM_MSG_SEALED)
           && (pSealedMailRepMsg->dwMsgType & MRM_MSG_SIGNED));
    Assert(MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(pSealedMailRepMsg));

    __try {
        // Get a handle to a crytographic provider.
        hStoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                     0,
                                     0,
                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                     L"MY");
        if (!hStoreHandle) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }
        
        // Initialize the decryption parameters.
        memset(&DecryptParams, 0, sizeof(DecryptParams));
        DecryptParams.cbSize                   = sizeof(DecryptParams);
        DecryptParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        DecryptParams.cCertStore               = 1;
        DecryptParams.rghCertStore             = &hStoreHandle;
        
        // Initialize the CRYPT_VERIFY_MESSAGE_PARA structure.
        memset(&VerifyParams, 0, sizeof(VerifyParams));
        VerifyParams.cbSize                   = sizeof(VerifyParams);
        VerifyParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
        VerifyParams.pfnGetSignerCertificate  = draGetAndVerifySignerCertificate;
        
        // Allocate buffer to hold the unsigned message.
        pUnsealedMailRepMsg = THAllocEx(pTHS,
                                        MAIL_REP_MSG_CURRENT_HEADER_SIZE
                                        + pSealedMailRepMsg->cbUnsignedDataSize);
        *pUnsealedMailRepMsg = *pSealedMailRepMsg;
        pUnsealedMailRepMsg->cbDataOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        pUnsealedMailRepMsg->cbDataSize = pSealedMailRepMsg->cbUnsignedDataSize;

        ok = CryptDecryptAndVerifyMessageSignature(
                    &DecryptParams,                     // Decrypt parameters
                    &VerifyParams,                      // Verify parameters
                    0,                                  // Signer index
                    pbData,                             // Pointer to sealed blob
                    pSealedMailRepMsg->cbDataSize,      // Size of sealed blob
                    MAIL_REP_MSG_DATA(pUnsealedMailRepMsg), // Buffer for decoded msg
                    &pUnsealedMailRepMsg->cbDataSize,   // Size of buffer
                    NULL,                               // Pointer to xchg cert
                    &pSignerCertContext);               // Pointer to signer cert
        if (!ok) {
            winError = GetLastError();
            DRA_EXCEPT(DRAERR_CryptError, winError);
        }

        // Message is now unsealed.
        pUnsealedMailRepMsg->dwMsgType &= ~(MRM_MSG_SIGNED | MRM_MSG_SEALED);

        // Verify sender's authorization.
        draVerifyCertAuthorization(pTHS, pSignerCertContext);

        // Return unsealed message to caller.
        *ppUnsealedMailRepMsg = pUnsealedMailRepMsg;

        // Return signer's cert if requested.
        if (NULL != phSignerCert) {
            *phSignerCert = (DRA_CERT_HANDLE) pSignerCertContext;
        }
    }
    __finally {
        if (pSignerCertContext
            && (AbnormalTermination() || (NULL == phSignerCert))
            && !CertFreeCertificateContext(pSignerCertContext)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }

        if (hStoreHandle
            && !CertCloseStore(hStoreHandle, CERT_CLOSE_STORE_CHECK_FLAG)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draFreeCertHandle(
    IN  DRA_CERT_HANDLE hCert
    )
/*++

Routine Description:

    Frees a cert handle returned by a prior call to draVerifyMessageSignature()
    or draDecryptAndVerifyMessageSignature().

Arguments:

    hCert (IN) - Handle to free.
    
Return Values:

    None.

--*/
{
    PCCERT_CONTEXT  pCertContext = (PCCERT_CONTEXT) hCert;
    DWORD           winError;

    Assert(NULL != pCertContext);

    if (!CertFreeCertificateContext(pCertContext)) {
        winError = GetLastError();
        LogUnhandledError(winError);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION IMPLEMENTATIONS
//


PCCERT_CONTEXT
draGetDCCertEx(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore,
    IN  BOOL        fRequestV2Certificate
    )
/*++

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.  This routine checks for one specific type of certificate at a time.
    It must be called several times to check all the possibilities. In this sense
    it is a helper function meant to be called as part of a logic get dc cert
    function.  This routine does not except, but returns null quietly if the type
    you want is not present.

    For background on the need for V2 certificates, see bug 148245. In summary, a V1
    cert looks like this:
    V1 cert
        ENROLL_CERTYPE_EXTENSION with type CERTTYPE_DC
        SUBJECT_ALT_NAME2 extension with REPLICATION OID
    This was found to be nonstandard after W2K shipped.
    The V2 cert looks like this:
        (no ENROLL_CERTTYPE_EXTENSION)
        CERTIFICATE_TEMPLATE extension
        SUBJECT_ALT_NAME2 extension with REPLICATION OID
        
    A Whistler or later enterprise CA will only have a V2 cert. A W2K CA, or a
    W2K CA upgraded to Whistler will have both a V1 and a V2 cert.

    Given the way the W2K code to find the certificate worked, it was not
    predictable which one it would find.  We want the code to prefer a V2 certificate
    if one is available.  For example, in a Whistler only forest, we must use
    the V2 certificate, even if the CA was originally upgraded from W2K.

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    fRequestV2Certificate - Whether we should only accept a V2 certificate    
    
Return Values:

    Handle to the certificate.  NULL if none matching.

--*/
{
    PCCERT_CONTEXT          pCertContext = NULL;
    BOOL                    ok = FALSE;
    CERT_EXTENSION *        pCertExtension;
    DWORD                   cbCertTypeMax = 0;
    DWORD                   cbCertType;
    CERT_NAME_VALUE *       pCertType = NULL;
    HRESULT                 hr;
    HCERTTYPE               hCertType;
    LPWSTR *                ppszCertTypePropertyList;

    if (!fRequestV2Certificate) {
        cbCertTypeMax = 512;

        // Allocate buffer to hold cert type extension.
        pCertType = THAllocEx(pTHS, cbCertTypeMax);
    }

    // Grovel through each of our certificates, looking for the one of type DC.
    for (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
         (NULL != pCertContext);
         pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)) {

        if (fRequestV2Certificate) {
            // A V2 certificate has a CERTIFICATE_TEMPLATE extension, but
            // no ENROLL_CERTTYPE extension.
            if (!CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                   pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)) {
                continue;
            }
            // A certificate suitable for mail-based replication will have our
            // OID in it, by definition.
            if (!draGetCertAltNameEntry(pTHS,
                                        pCertContext,
                                        CERT_ALT_NAME_OTHER_NAME,
                                        szOID_NTDS_REPLICATION)) {
                continue;
            }

            // We found one!
            break;
        }

        // Find the cert type.
        pCertExtension = CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                           pCertContext->pCertInfo->cExtension,
                                           pCertContext->pCertInfo->rgExtension);

        if (NULL != pCertExtension) {
            BOOL fCertFound = FALSE;
    
            // Decode the cert type.
            cbCertType = cbCertTypeMax;
            ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                   X509_UNICODE_ANY_STRING,
                                   pCertExtension->Value.pbData,
                                   pCertExtension->Value.cbData,
                                   0,
                                   (void *) pCertType,
                                   &cbCertType);
            
            if (!ok && (ERROR_MORE_DATA == GetLastError())) {
                // Our buffer isn't big enough to hold this cert; realloc and
                // try again.
                DPRINT1(0, "Buffer insufficient; reallocing to %u bytes.\n",
                        cbCertType);
                pCertType = THReAllocEx(pTHS, pCertType, cbCertType);
                cbCertTypeMax = cbCertType;
            
                ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                       X509_UNICODE_ANY_STRING,
                                       pCertExtension->Value.pbData,
                                       pCertExtension->Value.cbData,
                                       0,
                                       (void *) pCertType,
                                       &cbCertType);
            }
            
            if (ok && (0 != cbCertType)) {
                LPWSTR pszCertTypeName = (LPWSTR) pCertType->Value.pbData;

                hCertType = NULL;
                ppszCertTypePropertyList = NULL;

                // Get a handle to the cert type
                hr = CAFindCertTypeByName( 
                    pszCertTypeName,
                    NULL, // hCAInfo
                    CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, // dwFlags
                    &hCertType
                    );

                if (FAILED(hr)) {
                    DPRINT1(0,"CAFindCertTypeByName failed, error 0x%x\n",hr );
                } else {

                    // Get the base name property of the cert type object
                    hr = CAGetCertTypeProperty( hCertType,
                                                CERTTYPE_PROP_CN,
                                                &ppszCertTypePropertyList
                        );
                    if (FAILED(hr)) {
                        DPRINT1( 0, "CAGetCertTypeProperty failed, error 0x%x\n",hr );
                    } else {
                        Assert( ppszCertTypePropertyList[1] == NULL );

                        if (0 == _wcsicmp(ppszCertTypePropertyList[0],
                                          wszCERTTYPE_DC )) {
                            // We found our DC certificate; we're done!
                            fCertFound = TRUE;
                        }
                    } // if failed
                } // if failed

                if (ppszCertTypePropertyList != NULL) {
                    hr = CAFreeCertTypeProperty( hCertType,
                                                 ppszCertTypePropertyList );
                    if (FAILED(hr)) {
                        DPRINT1( 0, "CAFreeCertTypeProperty failed, error 0x%x\n",hr );
                    }
                }
                if (hCertType != NULL) {
                    hr = CACloseCertType( hCertType );
                    if (FAILED(hr)) {
                        DPRINT1(0,"CACloseCertType failed, error 0x%x\n",hr );
                    }
                }

                if (fCertFound) {
                    // leave loop after freeing resources
                    break;
                }
            } // if ok
        } // if null == cert extension
    } // for

    if (NULL != pCertType) {
        THFree(pCertType);
    }

    return pCertContext;
}

PCCERT_CONTEXT
draGetDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore
    )
/*++

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    
Return Values:

    Handle to the certificate.  Throws DRA exception if not found or on other
    error.

--*/
{
    static DSTIME           timeLastFailureLogged = 0;

    PCCERT_CONTEXT          pDCCert = NULL;

    pDCCert = draGetDCCertEx(pTHS, hCertStore, TRUE /*v2 */ );
    if (!pDCCert) {
        pDCCert = draGetDCCertEx(pTHS, hCertStore, FALSE /* v1 */ );
        if (pDCCert) {
            DPRINT( 1, "A V1 domain controller certificate is being used.\n" );
        }
    } else {
        DPRINT( 1, "A V2 mail replication certificate is being used.\n" );
    }

    if (!pDCCert) {
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastFailureLogged)
            || (timeCurrent > (timeLastFailureLogged + NO_CERT_LOG_INTERVAL))) {
            // Log event to alert admin that we have no certificate.
            timeLastFailureLogged = timeCurrent;
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_NO_CERTIFICATE,
                     NULL, NULL, NULL);
        }

        DPRINT(0, "No certificate of type suitable for mail-based replication found.\n");
        DRA_EXCEPT(DRAERR_CryptError, 0);
    }
    else if (0 != timeLastFailureLogged) {
        // We failed to find a certificate earlier in this boot, but now we have
        // one.
        timeLastFailureLogged = 0;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_CERTIFICATE_ACQUIRED,
                 NULL, NULL, NULL);
    }

    return pDCCert;
}


void
draVerifyCertAuthorization(
    IN  THSTATE      *  pTHS,
    IN  PCCERT_CONTEXT  pCertContext
    )
/*++

Routine Description:

    Verify that the given certificate is trustworthy.  Checks that we trust one
    or more of the certifying authorities and that the owner of the certificate
    is a DC in our enterprise.

Arguments:

    pCertContext (IN) - Cert to verify.
    
Return Values:

    None.  Throws DRA exception on authorization failure.

--*/
{
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    BOOL                  ok;
    DWORD                 winError;
    DWORD                 i;
    CRYPT_OBJID_BLOB *    pEncodedGuidBlob = NULL;
    DWORD                 cbDecodedGuidBlob;
    CRYPT_DATA_BLOB *     pDecodedGuidBlob = NULL;
    GUID                  ComputerObjGuid;

    pCertAltNameEntry = draGetCertAltNameEntry(pTHS,
                                               pCertContext,
                                               CERT_ALT_NAME_OTHER_NAME,
                                               szOID_NTDS_REPLICATION);
    if (NULL == pCertAltNameEntry) {
        DPRINT(0, "Certificate contains no szOID_NTDS_REPLICATION alt subject name;"
                  " access denied.\n");
        DRA_EXCEPT(DRAERR_AccessDenied, 0);
    }
    
    pEncodedGuidBlob = &pCertAltNameEntry->pOtherName->Value;

    cbDecodedGuidBlob = 64;
    pDecodedGuidBlob = (CRYPT_DATA_BLOB *) THAllocEx(pTHS, cbDecodedGuidBlob);

    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_OCTET_STRING,
                           pEncodedGuidBlob->pbData,
                           pEncodedGuidBlob->cbData,
                           0,
                           pDecodedGuidBlob,
                           &cbDecodedGuidBlob);
    if (!ok
        || (0 == cbDecodedGuidBlob)
        || (sizeof(GUID) != pDecodedGuidBlob->cbData)) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode computer objectGuid (error 0x%x); access denied.\n",
                winError);
        DRA_EXCEPT(DRAERR_AccessDenied, winError);
    }

    // The following statement is here to make extra sure the GUID is suitably
    // aligned.  (But it may be unnecessary.)
    memcpy(&ComputerObjGuid, pDecodedGuidBlob->pbData, sizeof(GUID));

#if DBG
    {
        CHAR szGuid[33];
        
        for (i = 0; i < sizeof(GUID); i++) {
            sprintf(szGuid+2*i, "%02x", 0xFF & ((BYTE *) &ComputerObjGuid)[i]);
        }
        szGuid[32] = '\0';

        DPRINT1(2, "Sent by DSA with computer objectGuid %s.\n", szGuid);
    }
#endif

    if (!draIsDsaComputerObjGuid(&ComputerObjGuid)) {
        // Computer object guid does not correspond to a DS DC in our
        // enterprise (or at least we haven't seen its addition to the
        // enterprise yet).
        DRA_EXCEPT(DRAERR_AccessDenied, 0);
    }
    
    if(pDecodedGuidBlob != NULL) THFreeEx(pTHS, pDecodedGuidBlob);

}


#ifndef TEST_HARNESS
BOOL
draIsDsaComputerObjGuid(
    IN  GUID *  pComputerObjGuid
    )
/*++

Routine Description:

    Is the given guid that of a computer object representing a DS DC in our
    enterprise?

Arguments:

    pComputerObjGuid (IN) - Guid to check.
    
Return Values:

    TRUE - is the guid of a computer object representing a DS DC in our
        enterprise.
        
    FALSE - is not.

--*/
{
    BOOL          fIsDsa = FALSE;
    THSTATE *     pTHS = pTHStls;
    DSNAME        ComputerDN = {0};
    DB_ERR        err;
    DWORD         cb;
    DSNAME *      pServerDN = NULL;
    DSNAME *      pNtdsDsaDN = NULL;
    CLASSCACHE *  pCC;
    DWORD         iServer = 0;

    Assert(NULL != pComputerObjGuid);
    Assert(NULL == pTHS->pDB);

    ComputerDN.structLen = sizeof(ComputerDN);
    ComputerDN.Guid = *pComputerObjGuid;

    BeginDraTransaction(SYNC_READ_ONLY);

    __try {
        // Find the computer record (object or phantom).
        err = DBFindDSName(pTHS->pDB, &ComputerDN);
        if (err && (DS_ERR_NOT_AN_OBJECT != err)) {
            DPRINT1(0, "Can't find computer record, error 0x%x.\n", err);
            __leave;
        }

        // Determine which server object in the config container corresponds to
        // it. Check all values: backlinks are inherently multi-valued.  It is possible
        // that a server was retired without dcdemote, its NTDS-DSA object was removed
        // using ntdsutil, and another server was promoted with the same name in a new
        // site. If the computer account was re-used, we will have a computer account
        // with two backlinks to two servers, only one of which has a valid NTDS-DSA.
        while ((err = DBGetAttVal(pTHS->pDB, ++iServer, ATT_SERVER_REFERENCE_BL,
                                  0, 0, &cb, (BYTE **) &pServerDN)) == 0) {

            // Construct the name of the child ntdsDsa object.
            pNtdsDsaDN = (DSNAME *) THAllocEx(pTHS, (pServerDN->structLen + 50));
            err = AppendRDN(pServerDN,
                            pNtdsDsaDN,
                            pServerDN->structLen + 50,
                            L"NTDS Settings",
                            0,
                            ATT_COMMON_NAME);
            Assert(!err);
        
        // Seek to the ntdsDsa object.
            err = DBFindDSName(pTHS->pDB, pNtdsDsaDN);
            if (err) {
                DPRINT2(0, "Can't find ntdsDsa object \"%ls\", error 0x%x.\n",
                        pNtdsDsaDN->StringName, err);
                continue;
            }

            // Is it indeed an ntdsDsa object?
            GetObjSchema(pTHS->pDB, &pCC);
            if (CLASS_NTDS_DSA != pCC->ClassId) {
                DPRINT1(0, "%ls is not an ntdsDsa object -- spoof attempt?\n",
                        pNtdsDsaDN->StringName);
                continue;
            }
        
            // Okay, we trust you.
            fIsDsa = TRUE;
            break;
        }
    }
    __finally {
        EndDraTransaction(!AbnormalTermination());
    }

    // Log why we did not authenticate the guid
    if (!fIsDsa) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_CERT_ACCESS_DENIED_NOT_DC,
                 szInsertUUID(pComputerObjGuid),
                 szInsertDN(pServerDN),  // szInsertDn can handle nulls too
                 szInsertDN(pNtdsDsaDN)  // ditto
                 );
    }

    if (NULL != pServerDN) {
        THFree(pServerDN);
    }

    if(pNtdsDsaDN != NULL) THFreeEx(pTHS, pNtdsDsaDN);

    return fIsDsa;
}
#endif // #ifndef TEST_HARNESS


void
draLogAccessDeniedError(
    IN  THSTATE *           pTHS,
    IN  PCCERT_CONTEXT      pCertContext OPTIONAL,
    IN  DWORD               winError,
    IN  DWORD               dwTrustError
    )

/*++

Routine Description:

    Log an access denied event

    One of winError or dwTrustError must be specified non-zero.

Arguments:

    pTHS - thread state
    pCertContext - Certificate Context, optional
    winError - api call failure status
    dwTrustError - Certificate chain error

Return Value:

    None

--*/

{
    DWORD                 cch;
    LPWSTR                pwszIssuerName = NULL;
    LPWSTR                pwszSubjectDnsName = NULL;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    DWORD dwMsgID, dwErrCode;

    if (pCertContext) {
        // Derive issuer name (for logging purposes).
        cch = CertGetNameStringW(pCertContext,
                                 CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                 CERT_NAME_ISSUER_FLAG,
                                 NULL,
                                 NULL,
                                 0);
        if (0 != cch) {
            pwszIssuerName = THAlloc(cch * sizeof(WCHAR));

            if (NULL != pwszIssuerName) {
                CertGetNameStringW(pCertContext,
                                   CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                   CERT_NAME_ISSUER_FLAG,
                                   NULL,
                                   pwszIssuerName,
                                   cch);
            }
        }

        // Derive subject's DNS name (for logging purposes).
        pCertAltNameEntry = draGetCertAltNameEntry(pTHS,
                                                   pCertContext,
                                                   CERT_ALT_NAME_DNS_NAME,
                                                   NULL);
        if (NULL != pCertAltNameEntry) {
            pwszSubjectDnsName = pCertAltNameEntry->pwszDNSName;
        }
    }

    // Log "access denied" event for admin.

    if (winError) {
        dwMsgID = DIRLOG_DRA_CERT_ACCESS_DENIED_WINERR;
        dwErrCode = winError;
    }
    else {
        Assert(dwTrustError);
        dwMsgID = DIRLOG_DRA_CERT_ACCESS_DENIED_TRUSTERR;
        dwErrCode = dwTrustError;
    }
        
    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      dwMsgID,
                      szInsertWC(pwszSubjectDnsName ? pwszSubjectDnsName : L""),
                      szInsertWC(pwszIssuerName ? pwszIssuerName : L""),
                      szInsertWin32Msg(winError),
                      NULL, NULL, NULL, NULL, NULL,
                      sizeof(dwErrCode),
                      &dwErrCode);

} /* draLogAccessDeniedError */

void
draGetCertArrayToSend(
    IN  THSTATE *           pTHS,
    IN  HCERTSTORE          hCertStore,
    OUT DWORD *             pcNumCerts,
    OUT PCCERT_CONTEXT **   prgpCerts
    )
/*++

Routine Description:

    Retrieves array of certificate contexts to include in outbound messages.
    The array includes the local DC's certificates plus all the signing CAs'
    certificates up to the root.

Arguments:

    hCertStore (IN) - Certificate store from which to retrieve DC certificate.
    
    pcNumCerts (OUT) - On return, the number of certificates in the array.
    
    prgpCerts (OUT) - On return, the array of certificate contexts.

Return Values:

    None.
    
--*/
{
    PCCERT_CONTEXT          pDCCert = NULL;
    PCCERT_CHAIN_CONTEXT    pChainContext = NULL;
    CERT_CHAIN_PARA         ChainPara;
    PCERT_SIMPLE_CHAIN      pChain;
    DWORD                   iCert;
    DWORD                   winError;

    //
    // NOTE: If any usage checks need to be done, then place them in
    //       the chain parameters under the Usage field
    //

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    pDCCert = draGetDCCert(pTHS, hCertStore );

    Assert( pDCCert );  // An exception should have been raised

    if (!CertGetCertificateChain(HCCE_LOCAL_MACHINE,
                                 pDCCert,
                                 NULL,
                                 NULL,
                                 &ChainPara,
                                 0,
                                 NULL,
                                 &pChainContext)) {
        winError = GetLastError();
        DPRINT1(0, "CertGetCertificateChain() failed, error %d.\n", winError);
        draLogAccessDeniedError( pTHS, pDCCert, winError, 0 );
        DRA_EXCEPT(DRAERR_CryptError, winError);
    }

    __try {
        DWORD dwTrustError = pChainContext->TrustStatus.dwErrorStatus;
        if (CERT_TRUST_NO_ERROR != dwTrustError ) {
            DPRINT1(0, "CertGetCertificateChain() failed, trust status %d.\n",
                    dwTrustError );
            draLogAccessDeniedError( pTHS, pDCCert, 0, dwTrustError );
            DRA_EXCEPT(DRAERR_CryptError, dwTrustError );
        }

        Assert(1 == pChainContext->cChain);
        pChain = pChainContext->rgpChain[0];
        
        *prgpCerts = (PCCERT_CONTEXT *) THAllocEx(pTHS,
                                                  pChain->cElement
                                                  * sizeof(PCCERT_CONTEXT));
        *pcNumCerts = pChain->cElement;

        for (iCert = 0; iCert < pChain->cElement; iCert++) {
            (*prgpCerts)[iCert] = CertDuplicateCertificateContext(
                                      pChain->rgpElement[iCert]->pCertContext);
            Assert(NULL != (*prgpCerts)[iCert]);
        }
    }
    __finally {
        if (NULL != pChainContext) {
            CertFreeCertificateChain(pChainContext);
        }
        
        if ((NULL != pDCCert)
            && !CertFreeCertificateContext(pDCCert)) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
    }
}


void
draFreeCertArray(
    IN  DWORD             cNumCerts,
    IN  PCCERT_CONTEXT *  rgpCerts
    )
/*++

Routine Description:

    Frees an array of certificate contexts (such as that returned by
    draGetCertArrayToSend()).

Arguments:

    cNumCerts (IN) - Number of certificates in array.
    
    pCerts (IN) - Array of certificate contexts to free.

Return Values:

    None.
    
--*/
{
    DWORD iCert;
    DWORD winError;

    if (NULL != rgpCerts) {
        for (iCert = 0; iCert < cNumCerts; iCert++) {
            if (!CertFreeCertificateContext(rgpCerts[iCert])) {
                winError = GetLastError();
                LogUnhandledError(winError);
            }
        }
    }
}


PCCERT_CONTEXT
WINAPI
draGetAndVerifySignerCertificate(
    IN  VOID *      pvGetArg,
    IN  DWORD       dwCertEncodingType,
    IN  PCERT_INFO  pSignerId,
    IN  HCERTSTORE  hCertStore
    )
/*++

Routine Description:

    Helper function for draVerifyMessageSignature() and
    draDecryptAndVerifyMessageSignature().

Arguments:

    See description of pfnGetSignerCertificate field of
    CRYPT_VERIFY_MESSAGE_PARA structure in Win32 SDK.

Return Values:

    NULL or valid certificate context.

--*/
{
    CERT_CHAIN_PARA       ChainPara;
    PCCERT_CHAIN_CONTEXT  pChainContext = NULL;
    PCCERT_CONTEXT        pCertContext = NULL;
    DWORD                 winError = ERROR_SUCCESS;
    DWORD                 dwTrustError = 0;
    THSTATE *             pTHS = pTHStls;

    if (NULL == pSignerId) {
        return NULL;
    }

    pCertContext = CertGetSubjectCertificateFromStore(hCertStore,
                                                      dwCertEncodingType,
                                                      pSignerId);

    if (NULL != pCertContext) {
        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        if (CertGetCertificateChain(HCCE_LOCAL_MACHINE,
                                    pCertContext,
                                    NULL,
                                    hCertStore,
                                    &ChainPara,
                                    0,
                                    NULL,
                                    &pChainContext)) {
            if (CERT_TRUST_NO_ERROR
                == pChainContext->TrustStatus.dwErrorStatus) {
            }
            else {
                dwTrustError = pChainContext->TrustStatus.dwErrorStatus;
                DPRINT1(0, "Sender's cert chain is not trusted, trust status = 0x%x.\n",
                        dwTrustError);
            }

            CertFreeCertificateChain(pChainContext);
        }
        else {
            winError = GetLastError();
            DPRINT1(0, "Can't retrieve sender's cert chain, error 0x%x.\n",
                    winError);
        }

    }
    else {
        winError = GetLastError();
        DPRINT1(0, "Can't CertGetSubjectCertificateFromStore(), error 0x%x.\n",
                winError);
    }

    // If we got either kind of error, log access denied
    if (winError || dwTrustError ) {
        draLogAccessDeniedError( pTHS, pCertContext, winError, dwTrustError );

        if ( pCertContext ) {
            // Free the context we acquired.
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }
    }

    return pCertContext;
}


CERT_ALT_NAME_ENTRY *
draGetCertAltNameEntry(
    IN  THSTATE *       pTHS,
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           dwAltNameChoice,
    IN  LPSTR           pszOtherNameOID     OPTIONAL
    )
/*++

Routine Description:

    Retrieve a specific alt subject name entry from the given certificate.

Arguments:

    pCertContext (IN) - Certificate from which info is to be derived.
    
    dwAltNameChoice (IN) - The CERT_ALT_NAME_* for the desired alternate name.
    
    pszOtherNameOID (IN) - If retrieving CERT_ALT_NAME_OTHER_NAME, an OID
        specifying the specific "other name" desired.  Must be NULL for other
        values of dwAltNameChoice.
        
Return Values:

    A pointer to the CERT_ALT_NAME_ENTRY (success) or NULL (failure).
    
--*/
{
    CERT_EXTENSION *      pCertExtension;
    CERT_ALT_NAME_INFO *  pCertAltNameInfo;
    DWORD                 cbCertAltNameInfo = 0;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry = NULL;
    BOOL                  ok;
    DWORD                 winError;
    DWORD                 i;
    
    Assert((CERT_ALT_NAME_OTHER_NAME == dwAltNameChoice)
           || (NULL == pszOtherNameOID));

    // Find the cert extension containing the alternate subject names.
    pCertExtension = CertFindExtension(szOID_SUBJECT_ALT_NAME2,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);
    if (NULL == pCertExtension) {
        DPRINT(0, "Certificate has no alt subject name.\n");
        LogUnhandledError(0);
        return NULL;
    }
        
    // Decode the list of alternate subject names.
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           NULL,
                           &cbCertAltNameInfo);
    if (!ok || (0 == cbCertAltNameInfo)) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode alt subject name (error 0x%x).\n", winError);
        LogUnhandledError(winError);
        return NULL;
    }
    
    pCertAltNameInfo = THAlloc(cbCertAltNameInfo);
    
    if (NULL == pCertAltNameInfo) {
        DPRINT1(0, "Failed to allocate %d bytes.\n", cbCertAltNameInfo);
        LogUnhandledError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
        
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           pCertAltNameInfo,
                           &cbCertAltNameInfo);
    if (!ok) {
        winError = GetLastError();
        DPRINT1(0, "Can't decode alt subject name (error 0x%x).\n", winError);
        LogUnhandledError(winError);
        return NULL;
    }
    
    // Grovel through the alternate names to find the one the caller asked for.
    for (i = 0; i < pCertAltNameInfo->cAltEntry; i++) {
        if ((dwAltNameChoice
             == pCertAltNameInfo->rgAltEntry[i].dwAltNameChoice)
            && ((NULL == pszOtherNameOID)
                || (0 == strcmp(pszOtherNameOID,
                                pCertAltNameInfo->rgAltEntry[i]
                                    .pOtherName->pszObjId)))) {
            pCertAltNameEntry = &pCertAltNameInfo->rgAltEntry[i];
            break;
        }
    }

    return pCertAltNameEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\draerror.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draerror.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>			// MD local definition header
#include <dsatools.h>			// needed for output allocation

// Logging headers.
#include "dsevent.h"			/* header Audit\Alert logging */
#include "mdcodes.h"			/* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"			/* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAERROR:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"

#include <fileno.h>
#define  FILENO FILENO_DRAERROR


// This is a global flag to control whether full attribute sync mode is
// invoked on the current packet if it is found to have an incomplete set
// of attributes.  It is OFF by default in debug builds in order to catch
// USN/UTD corruption problems.

#if DBG
BOOL gfDraCorrectMissingObject = FALSE;
#else
BOOL gfDraCorrectMissingObject = TRUE;
#endif


// DraErrOutOfMem

void DraErrOutOfMem(void)
{

    DPRINT(0,"DRA - OUT OF MEMORY\n");

    LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_BASIC,
                        DIRLOG_DRA_OUT_OF_MEMORY,
                        NULL,
                        NULL,
                        NULL);

    DRA_EXCEPT (DRAERR_OutOfMem, 0);
}

// DraErrInconsistent - Called when we detect an inconistent state within the
// DRA. Writes appropriate log entries. Id is the DSID of the caller. A
// macro makes this easier to call.

void  DraErrInconsistent(DWORD Arg, DWORD Id)
{
    LogEvent(DS_EVENT_CAT_REPLICATION,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CODE_INCONSISTENCY,
  	    szInsertUL( Arg ),
  	    szInsertUL( Id ),
  	    NULL);
    DRA_EXCEPT_DSID(DRAERR_InternalError, Arg, Id);
}

// DraErrBusy - Called whenever we get a dblayer SYSERR.

void DraErrBusy(void)
{
    DRA_EXCEPT (DRAERR_Busy, 0);
}

// DraErrMissingAtt - Called whenever we are unable to read an expected
// attribute. We make an error log entry.

void DraErrMissingAtt(PDSNAME pDN, ATTRTYP type)
{
    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_MISSING_EXPECTED_ATT,
  	    szInsertUL(type),
  	    szInsertWC(pDN->StringName),
  	    NULL);

    DRA_EXCEPT (DRAERR_InternalError, type);
}

// DraErrCannotFindNC - The master NC cannot be found.

void DraErrCannotFindNC(DSNAME *pNC)
{
    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CANT_FIND_EXPECTED_NC,
  	    szInsertWC(pNC->StringName),
	    NULL,
  	    NULL);

    DRA_EXCEPT (DRAERR_InconsistentDIT, 0);
}

// DraErrInappropriateInstanceType - an inappropriate instance type was
// encountered.

void DraErrInappropriateInstanceType(DSNAME *pDN, ATTRTYP type)
{
    DRA_EXCEPT (DRAERR_InconsistentDIT, type);
}


void
DraErrMissingObject(
    IN  THSTATE *pTHS,
    IN  ENTINF *pEnt
    )
/*++

Routine Description:

    Called when there is no local information regarding the object and the
    inbound replication stream does not contain enough attribute information
    to create it.
    
    This is either (1) the result of a replication error, where the USN
    bookmarks were advanced further than they should have been somewhere, or
    (2) a symptom of not having fully replicated within a tombstone lifetime.

    There are a small number of legitimate situations where we expect to run into
    this condition. In these cases we do not log nor assert on check builds. These are:
    1. A TTL object has expired on the destination by the time that a change replicates in.
    2. An object has been phantomized because of a cross domain move operation, but
    there is insufficient information in PreProcessProxyObject to know if the
    operation should be prevented.


Arguments:

    pEnt (IN) - Entry info for the incomplete inbound object.
    
Return Values:

    None.  Throws a replication exception.
    
--*/
{
    DPRINT1(0, "Object %ws is incomplete for add\n", pEnt->pName->StringName);

    // Dynamic objects may disappear at any time without a tombstone.
    // Request the whole object from the source
    if (pEnt->ulFlags & ENTINF_DYNAMIC_OBJECT) {
        DRA_EXCEPT(DRAERR_MissingObject, 0);
    }

    // See if the target object exists as a phantom with a name indicative of
    // being cross domain moved.  This code is to prevent assertions on a checked
    // build when this scenario occurs during test. The scenario is this. System A
    // is a GC. On system B, object is cross domain moved from domain1 to domain2.
    // System A replicates in domain2 BEFORE replicating in domain1. System A demotes
    // the object from domain1 to domain2. System A is then un-GC'd. The object
    // becomes a phantom in domain 2.  If a change comes for the old object in domain1
    // before the proxy object arrives, we won't have the full contents of the object.

    {
        COMMARG commArg;
        CROSS_REF *pIncomingNcCr, *pPhantomNcCr;
        DSNAME *pPhantomDN;
        DWORD cbName=0, err;

        InitCommarg(&commArg);

        // See if the object exists locally as a phantom, meaning the object was here
        // once but has disappeared for some reason.

        err = DBFindDSName(pTHS->pDB, pEnt->pName);
        if (err == DIRERR_NOT_AN_OBJECT) {

            // Get incoming object CR by name
            if (!(pIncomingNcCr = FindBestCrossRef(pEnt->pName, &commArg))) {
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }
            // Turn the DNT into the dsname (don't just read the name off
            // the object, phantoms don't have such a thing.
            if ( !(pPhantomDN = DBGetDSNameFromDnt( pTHS->pDB, pTHS->pDB->DNT ))) {
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }

            // Get the CrossRef for the phantom.
            // This may not exist if the CrossRef containing the phantom was deleted
            // from the enterprise
            pPhantomNcCr = FindBestCrossRef(pPhantomDN, &commArg);

            DPRINT1( 1, "Incoming NC: %ls\n", pIncomingNcCr->pNC->StringName );
            DPRINT1( 1, "Phantom NC: %ls\n",
                     pPhantomNcCr ? pPhantomNcCr->pNC->StringName : L"not found" );

            if ( !pPhantomNcCr ||
                 (!NameMatched(pIncomingNcCr->pNC, pPhantomNcCr->pNC)) )
            {
                // Phantom is not in the current domain
                // Allow it to be regenerated
                DRA_EXCEPT(DRAERR_MissingObject, 0);
            }
        }
    }

    Assert(gfDraCorrectMissingObject
           && "Asked to create an object with insufficient attributes "
              "break, then ed ntdsa!gfDraCorrectMissingObject 1 to "
              "auto-correct");
    
    // Use a global variable to control whether we correct or abort
    if (!gfDraCorrectMissingObject) {
        // Abort the packet, don't apply
        DRA_EXCEPT(DRAERR_InternalError, DRAERR_MissingObject);
    }
    else {
        // This exception is caught and handled to work around the failure.
        DRA_EXCEPT(DRAERR_MissingObject, 0);
    }
}


void
DraLogGetChangesFailure(
    IN DSNAME *pNC,
    IN LPWSTR pszDsaAddr,
    IN DWORD ret,
    IN DWORD ulExtendedOp
    )

/*++

Routine Description:

    Log an source-side Get Changes failure.
    Common normal errors are not logged.

Arguments:

    pNC - naming context
    pszDsaAddr - The destination server's address
    ret - win32 error code
    ulExtendedOp - the Extended FSMO operation if any

Return Value:

    None

--*/

{
    // Filter out "normal" errors

    // "Normal" errors are:
    // ERROR_REVISION_MISMATCH - Client and server are not compatible
    // DRAERR_SourceDisabled - Outbound replication is disabled by admin
    // DRAERR_BadDN, BadNC - NC not present
    // DRAERR_NoReplica - NC being removed
    // ERROR_DS_DRA_SCHEMA_INFO_SHIP - Schema cache is temporarily invalid, perhaps
    //      while indices are being rebuilt

    switch (ret) {
    case ERROR_REVISION_MISMATCH:
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case DRAERR_SourceDisabled:
    case DRAERR_BadDN:
    case DRAERR_BadNC:
    case DRAERR_NoReplica:
        return;

    default:
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_GETCHANGES_FAILED,
                          szInsertDN(pNC),
                          szInsertWC(pszDsaAddr),
                          szInsertWin32Msg( ret ),
                          szInsertUL(ulExtendedOp),
                          NULL, NULL, NULL, NULL,
                          sizeof( ret ),
                          &ret );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dradir.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dradir.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRADIR:"            /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"

#include <fileno.h>
#define  FILENO FILENO_DRADIR

/* Macro to force alignment of a buffer.  Assumes that it may move pointer
 * forward up to 7 bytes.
 */
#define ALIGN_BUFF(pb)  pb += (8 - ((DWORD_PTR)(pb) % 8)) % 8
#define ALIGN_PAD(x) (x * 8)


ULONG
DirReplicaAdd(
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  LPWSTR      pszSourceDsaAddress,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Add inbound replication of an NC (which may or may not already exist
    locally) from a given source DSA.

Arguments:

    pNC (IN) - NC for which to add the replica.  The NC record must exist
        locally as either an object (instantiated or not) or a reference
        phantom (i.e., a phantom with a guid).

    pSourceDsaDN (IN, OPTIONAL) - DN of the source DSA's ntdsDsa object.
        Required if ulOptions includes DRS_ASYNC_REP; ignored otherwise.

    pTransportDN (IN, OPTIONAL) - DN of the interSiteTransport object
        representing the transport by which to communicate with the source
        server.  Required if ulOptions includes DRS_MAIL_REP; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pszSourceDsaDnsDomainName (IN, OPTIONAL) - DNS domain name of the source
        server.  If pszSourceDsaAddress is not a GUID-based DNS name for an
        ntdsDsa object that is present on the local machine, this parameter
        is required if the caller wants mutual authentication.

    preptimesSync (IN, OPTIONAL) - Schedule by which to replicate the NC from
        this source in the future.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_ASYNC_OP
            Perform this operation asynchronously.
        DRS_WRIT_REP
            Create a writeable replica.  Otherwise, read-only.
        DRS_MAIL_REP
            Sync from the source DSA via mail (i.e., an ISM transport) rather
            than RPC.
        DRS_ASYNC_REP
            Don't replicate the NC now -- just save enough state such that we
            know to replicate it later.
        DRS_INIT_SYNC
            Sync the NC from this source when the DSA is started.
        DRS_PER_SYNC
            Sync the NC from this source periodically, as defined by the
            schedule passed in the preptimesSync argument.
        DRS_CRITICAL_ONLY
            Sync only the critical objects now
        DRS_DISABLE_AUTO_SYNC
            Disable notification-based synchronization for the NC from this
            source.  (Synchronization can be forced by using the DRS_SYNC_FORCED
            bit in the sync request options.)
        DRS_DISABLE_PERIODIC_SYNC
            Disable periodic synchronization for the NC from this source.
            (Synchronization can be forced by using the DRS_SYNC_FORCED bit in
            the sync request options.)

Return Values:

    0 - Success.
    DRSERR_* - Failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    unsigned int cbTimes;
    DWORD cbSourceDsaDN;
    DWORD cbTransportDN;
    DWORD cbDnsDomainName;
    ULONG ret;
    MTX_ADDR *pmtx_addr;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;

    if (    ( NULL == pNC )
         || ( NULL == pszSourceDsaAddress )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from setting reserved flags
    if (ulOptions & (~REPADD_OPTIONS)) {
        Assert( !"Unexpected replica add options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                    // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        pmtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszSourceDsaAddress);

        cbTimes = (preptimesSync == NULL) ? 0 : sizeof(REPLTIMES);
        cbSourceDsaDN = (NULL == pSourceDsaDN) ? 0 : pSourceDsaDN->structLen;
        cbTransportDN = (NULL == pTransportDN) ? 0 : pTransportDN->structLen;
        cbDnsDomainName = (NULL == pszSourceDsaDnsDomainName)
                            ? 0
                            : sizeof(WCHAR) * (1 + wcslen(pszSourceDsaDnsDomainName));

        if ((pao = malloc(sizeof(AO) +
                          ALIGN_PAD(6) + /* align pad for 6 variable-length args */
                          pNC->structLen +
                          cbSourceDsaDN +
                          cbTransportDN +
                          MTX_TSIZE(pmtx_addr) +
                          cbDnsDomainName +
                          cbTimes)) == NULL) {
            ret = DRAERR_OutOfMem;
            DEC(pcThread);              // PerfMon hook
            return ret;
        }

        pao->ulOperation = AO_OP_REP_ADD;
        pao->ulOptions = ulOptions;

        // Append variable-length arguments.

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);

        pao->args.rep_add.pNC = (DSNAME *)(pb);
        memcpy(pb, pNC, pNC->structLen);
        pb += pNC->structLen;
        ALIGN_BUFF(pb);

        if (cbSourceDsaDN) {
            pao->args.rep_add.pSourceDsaDN = (DSNAME *) pb;
            memcpy(pb, pSourceDsaDN, cbSourceDsaDN);
            pb += cbSourceDsaDN;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pSourceDsaDN = NULL;
        }

        if (cbTransportDN) {
            pao->args.rep_add.pTransportDN = (DSNAME *) pb;
            memcpy(pb, pTransportDN, cbTransportDN);
            pb += cbTransportDN;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pTransportDN = NULL;
        }

        if (cbDnsDomainName) {
            pao->args.rep_add.pszSourceDsaDnsDomainName = (LPWSTR) pb;
            memcpy(pb, pszSourceDsaDnsDomainName, cbDnsDomainName);
            pb += cbDnsDomainName;
            ALIGN_BUFF(pb);
        }
        else {
            pao->args.rep_add.pszSourceDsaDnsDomainName = NULL;
        }

        pao->args.rep_add.pDSASMtx_addr = (MTX_ADDR*)(pb);
        memcpy(pb, pmtx_addr, MTX_TSIZE(pmtx_addr));
        pb += MTX_TSIZE(pmtx_addr);
        ALIGN_BUFF(pb);

        if (cbTimes) {
            pao->args.rep_add.preptimesSync = (REPLTIMES *)pb;
            memcpy(pb, preptimesSync, cbTimes);
        }
        else {
            pao->args.rep_add.preptimesSync = NULL;
        }

        ret = DoOpDRS(pao);

        THFreeEx(pTHS, pmtx_addr);
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}


ULONG
DirReplicaDelete(
    IN  DSNAME *          pNC,
    IN  LPWSTR            pszSourceDRA,         OPTIONAL
    IN  ULONG             ulOptions
    )
/*++

Routine Description:

    Delete a source of a given NC for the local server.

Arguments:

    pNC (IN) - Name of the NC for which to delete a source.

    pszSourceDRA (IN, OPTIONAL) - DSA for which to delete the source.  Required
        unless ulOptions & DRS_NO_SOURCE.

    ulOptions (IN) - Bitwise OR of zero or more of the following:
        DRS_ASYNC_OP
            Perform this operation asynchronously.
        DRS_REF_OK
            Allow deletion of read-only replica even if it sources other read-
            only replicas.
        DRS_NO_SOURCE
            Delete all the objects in the NC.  Incompatible with (and rejected
            for) writeable NCs that are not non-domain NCs.  This is valid only
            for read-only and non-domain NCs, and then only if the NC has no
            source.
        DRS_LOCAL_ONLY
            Do not contact the source telling it to scratch this server from
            its Rep-To for this NC.  Otherwise, if the link is RPC-based, the
            source will be contacted.
        DRS_IGNORE_ERROR
            Ignore any error generated by contacting the source to tell it to
            scratch this server from its Reps-To for this NC.
        DRS_ASYNC_REP
            If a tree removal is required (i.e., if DRS_NO_SOURCE), do that
            part asynchronously.

Return Values:

    0 on success, or Win32 error on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    ULONG ret;
    MTX_ADDR *pSDSAMtx_addr = NULL;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;
    DWORD cb;

    if ( NULL == pNC )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    if (ulOptions & (~REPDEL_OPTIONS)) {
        Assert( !"Unexpected replica del options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                    // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        cb = sizeof(AO) + ALIGN_PAD(2) + pNC->structLen;

        if (NULL != pszSourceDRA) {
            pSDSAMtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
            cb += MTX_TSIZE (pSDSAMtx_addr);
        }

        if ((pao = malloc(cb)) == NULL) {
            ret =  DRAERR_OutOfMem;
            return ret;
        }

        pao->ulOperation = AO_OP_REP_DEL;
        pao->ulOptions = ulOptions;

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);
        pao->args.rep_del.pNC = (DSNAME *)(pb);
        memcpy(pao->args.rep_del.pNC, pNC, pNC->structLen);

        if (NULL == pszSourceDRA) {
            pao->args.rep_del.pSDSAMtx_addr = NULL;
        }
        else {
            pb += pNC->structLen;
            ALIGN_BUFF(pb);
            pao->args.rep_del.pSDSAMtx_addr = (MTX_ADDR*)(pb);
            memcpy(pb, pSDSAMtx_addr, MTX_TSIZE(pSDSAMtx_addr));
        }

        ret = DoOpDRS(pao);

        if (NULL != pSDSAMtx_addr) {
            THFreeEx(pTHS, pSDSAMtx_addr);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}


ULONG
DirReplicaSynchronize(
    DSNAME *    pNC,
    LPWSTR      pszSourceDRA,
    UUID *      puuidSourceDRA,
    ULONG       ulOptions
    )
//
//  Synchronize a replica of a given NC on the local server, pulling changes
//  from the specified source server.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC to synchronize.
//      pszSourceDRA (LPWSTR)
//          DSA with which to synchronize the replica.  Ignored if ulOptions
//          does not include DRS_SYNC_BYNAME.
//      puuidSourceDRA (UUID *)
//          objectGuid of DSA with which to synchronize the replica.  Ignored
//          if ulOptions includes DRS_SYNC_BYNAME.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//                  Required when using DRS_SYNC_ALL
//              DRS_SYNC_BYNAME
//                  Use pszSourceDRA instead of puuidSourceDRA to identify
//                  source.
//              DRS_SYNC_ALL
//                  Sync from all sources.
//              DRS_CRITICAL
//                  Sync only the critical objects now
//              DRS_SYNC_FORCED
//                  Sync even if link is currently disabled.
//              DRS_FULL_SYNC_NOW
//                  Sync starting from scratch (i.e., at the first USN).
//              DRS_NO_DISCARD
//                  Don't discard this synchronization request, even if a
//                  similar sync is pending.
//
//              DRS_WRIT_REP
//                  Replica is writeable.  Not needed unless we're
//                  INIT_SYNCing as a part of startup (i.e., clients need
//                  not set this flag).
//              DRS_INIT_SYNC_NOW
//                  This sync is part of INIT_SYNCing this DSA as a part
//                  of startup.  Clients should not set this flag.
//              DRS_ABAN_SYNC
//                  Sync of this DSA has been abandoned and rescheduled
//                  once because no progress was being made; don't abandon
//                  it again.  Clients should not set this flag.
//              DRS_SYNC_RETRY
//                  Asynchronous sync of this NC failed once; if this sync
//                  fails, don't retry again.  Clients should not set this
//                  flag.
//              DRS_PER_SYNC
//                  This is a periodic sync request as scheduled by the admin.
//              DRS_SYNC_URGENT
//                  This is a notification of an update that was marked urgent.
//                  Notifications caused by this update will also be marked
//                  urgent.
//              DRS_ADD_REF
//                  Request source DSA to ensure it has a Reps-To for the local
//                  DSA such that it properly sends change notifications.  Valid
//                  only for replicas across the RPC transport.  Clients should
//                  have no need to set this flag.
//              DRS_TWOWAY_SYNC
//                  This sync is being performed because the remote DC was
//                  configured for two-way syncs (see DirRepicaAdd()).
//              DRS_SYNC_PAS
//                  This sync is for getting Partial Attribute Set changes
//                  to a destination GC.
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE *       pTHS = pTHStls;
    AO *            pao;
    ULONG           ret;
    ULONG           ulpaosize;
    UCHAR *         pb;
    BOOL            fDRAOnEntry;
    BOOL            fResetfDRAOnExit = FALSE;
    MTX_ADDR *      pmtx = NULL;
    REPLICA_LINK *  pRepsFromRef = NULL;
    ULONG           cbRepsFromRef;
    BOOL            fAttExists;

    if ((NULL == pNC )
        || ((ulOptions & DRS_SYNC_BYNAME) && (NULL == pszSourceDRA))) {
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                                // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        ret = DRAERR_Success;

        if ((DRS_ASYNC_OP & ulOptions)
            && (DRS_UPDATE_NOTIFICATION & ulOptions)) {
            // We're not going to sync just yet (asynchronous sync was requested),
            // but check to see that we actually replicate from this source so we
            // can inform the caller if he is in error.

            BOOL fCommit = FALSE;

            BeginDraTransaction(SYNC_READ_ONLY);

            __try {
                ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                             NULL);

                if (ret) {
                    // No NC.
                    ret = DRAERR_BadNC;
                    __leave;
                }

                if (!(ulOptions & DRS_SYNC_ALL)) {
                    if (ulOptions & DRS_SYNC_BYNAME) {
                        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
                    }

                    ret = FindDSAinRepAtt(
                            pTHS->pDB,
                            ATT_REPS_FROM,
                            ( ulOptions & DRS_SYNC_BYNAME )
                                ? DRS_FIND_DSA_BY_ADDRESS
                                : DRS_FIND_DSA_BY_UUID,
                            puuidSourceDRA,
                            pmtx,
                            &fAttExists,
                            &pRepsFromRef,
                            &cbRepsFromRef );

                    if (ret) {
                        // We don't source this NC from the given DSA.
                        ret = DRAERR_NoReplica;
                        __leave;
                    }

                    if ((pRepsFromRef->V1.ulReplicaFlags & DRS_NEVER_NOTIFY)
                        && !(ulOptions & DRS_TWOWAY_SYNC)) {
                        // We should not be getting notifications along this
                        // link.  (Perhaps it was once intrasite and is now
                        // intersite and therefore notification-less.)  By
                        // returning "no replica" we are informing the source
                        // to remove his "Reps-To" value for us, and therefore
                        // not to generate future change notifications.
                        ret = DRAERR_NoReplica;
                        __leave;
                    }
                }
            }
            __finally {
                EndDraTransaction(TRUE);
                Assert(NULL == pTHS->pDB);
            }
        }

        if (!ret) {
            // Determine pao size
            ulpaosize = sizeof(AO) + ALIGN_PAD(2) + pNC->structLen;
            if (ulOptions & DRS_SYNC_BYNAME) {
                ulpaosize += sizeof(WCHAR) * (1 + wcslen(pszSourceDRA));
            }

            if ((pao = malloc (ulpaosize)) == NULL) {
                ret =  DRAERR_OutOfMem;
                return ret;
            }

            pao->ulOperation = AO_OP_REP_SYNC;
            pao->ulOptions = ulOptions;

            pb = ((UCHAR *)pao + sizeof(AO));
            ALIGN_BUFF(pb);
            pao->args.rep_sync.pNC = (DSNAME *)(pb);
            memcpy(pb, pNC, pNC->structLen);

            // Copy over UUID or name, and zero out unused parameter.

            if (ulOptions & DRS_SYNC_BYNAME) {
                pb += pNC->structLen;
                ALIGN_BUFF(pb);
                pao->args.rep_sync.pszDSA = (LPWSTR) pb;
                wcscpy(pao->args.rep_sync.pszDSA, pszSourceDRA);
            }
            else {
                // Allow for pinvocation id being NULL.
                if (NULL != puuidSourceDRA) {
                    pao->args.rep_sync.invocationid = *puuidSourceDRA;
                }
                pao->args.rep_sync.pszDSA = NULL;
            }

            ret =  DoOpDRS(pao);
        }

        if (NULL != pmtx) {
            THFreeEx(pTHS, pmtx);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}

ULONG
DirReplicaModify(
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    LPWSTR      pszSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    )
//
//  Update the REPLICA_LINK value corresponding to the given server in the
//  Reps-From attribute of the given NC.
//
//  The value must already exist.
//
//  Either the UUID or the MTX_ADDR may be used to identify the current value.
//  If a UUID is specified, the UUID will be used for comparison.  Otherwise,
//  the MTX_ADDR will be used for comparison.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-From should be modified.
//      puuidSourceDRA (UUID *)
//          Invocation-ID of the referenced DRA.  May be NULL if:
//            . ulModifyFields does not include DRS_UPDATE_ADDRESS and
//            . pmtxSourceDRA is non-NULL.
//      puuidTransportObj (UUID *)
//          objectGuid of the transport by which replication is to be performed.
//          Ignored if ulModifyFields does not include DRS_UPDATE_TRANSPORT.
//      pszSourceDRA (LPWSTR)
//          DSA for which the reference should be added or deleted.  Ignored if
//          puuidSourceDRA is non-NULL and ulModifyFields does not include
//          DRS_UPDATE_ADDRESS.
//      prtSchedule (REPLTIMES *)
//          Periodic replication schedule for this replica.  Ignored if
//          ulModifyFields does not include DRS_UPDATE_SCHEDULE.
//      ulReplicaFlags (ULONG)
//          Flags to set for this replica.  Ignored if ulModifyFields does not
//          include DRS_UPDATE_FLAGS.
//      ulModifyFields (ULONG)
//          Fields to update.  One or more of the following bit flags:
//              DRS_UPDATE_ADDRESS
//                  Update the MTX_ADDR associated with the referenced server.
//              DRS_UPDATE_SCHEDULE
//                  Update the periodic replication schedule associated with
//                  the replica.
//              DRS_UPDATE_FLAGS
//                  Update the flags associated with the replica.
//              DRS_UPDATE_TRANSPORT
//                  Update the transport associated with the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE *   pTHS = pTHStls;
    AO *        pao;
    BYTE *      pb;
    ULONG       ret;
    BOOL        fDRAOnEntry;
    BOOL        fResetfDRAOnExit = FALSE;
    DWORD       cbAO;
    MTX_ADDR *  pmtxSourceDRA = NULL;

    // Note that DRS_UPDATE_ALL is rejected by this check
    if (    ( NULL == pNC )
         || ( ( NULL == puuidSourceDRA ) && ( NULL == pszSourceDRA ) )
         || ( ( NULL == pszSourceDRA   ) && ( DRS_UPDATE_ADDRESS  & ulModifyFields ) )
         || ( ( NULL == prtSchedule    ) && ( DRS_UPDATE_SCHEDULE & ulModifyFields ) )
         || ( 0 == ulModifyFields )
         || (    ulModifyFields
              != (   ulModifyFields
                   & ( DRS_UPDATE_ADDRESS | DRS_UPDATE_SCHEDULE | DRS_UPDATE_FLAGS
                       | DRS_UPDATE_TRANSPORT
                     )
                 )
            )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    if (ulOptions & (~REPMOD_OPTIONS)) {
        Assert( !"Unexpected replica modify options" );
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from setting inappropriate flags
    // Note that the caller may specify a system flag at this point,
    // and we enforce later than he cannot change its state
    if ( ( (ulModifyFields & DRS_UPDATE_FLAGS) != 0 ) &&
         (ulReplicaFlags & (~RFR_FLAGS)) ) {
        Assert( !"Unexpected replica modify flags" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);          // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        cbAO = sizeof(AO) + ALIGN_PAD(1) + pNC->structLen;

        if ((NULL == puuidSourceDRA)
            || fNullUuid( puuidSourceDRA )
            || (DRS_UPDATE_ADDRESS & ulModifyFields)) {

            pmtxSourceDRA = MtxAddrFromTransportAddrEx(pTHS, pszSourceDRA);
            cbAO += ALIGN_PAD(1) + MTX_TSIZE(pmtxSourceDRA);
        }

        if (NULL != puuidTransportObj) {
            cbAO += ALIGN_PAD(1) + sizeof(UUID);
        }

        pao = malloc(cbAO);

        if (NULL == pao) {
            ret = DRAERR_OutOfMem;
        }
        else {
            memset(pao, 0, cbAO);

            pao->ulOperation = AO_OP_REP_MOD;
            pao->ulOptions   = ulOptions;

            pb = (BYTE *)pao + sizeof(AO);

            ALIGN_BUFF(pb);
            pao->args.rep_mod.pNC = (DSNAME *) pb;
            memcpy(pb, pNC, pNC->structLen);
            pb += pNC->structLen;

            if (NULL != puuidSourceDRA) {
                pao->args.rep_mod.puuidSourceDRA = &pao->args.rep_mod.uuidSourceDRA;
                pao->args.rep_mod.uuidSourceDRA = *puuidSourceDRA;
            }

            if (NULL != puuidTransportObj) {
                pao->args.rep_mod.puuidTransportObj = &pao->args.rep_mod.uuidTransportObj;
                pao->args.rep_mod.uuidTransportObj = *puuidTransportObj;
            }

            if ((NULL == puuidSourceDRA)
                || fNullUuid(puuidSourceDRA)
                || (DRS_UPDATE_ADDRESS & ulModifyFields)) {
                ALIGN_BUFF(pb);
                pao->args.rep_mod.pmtxSourceDRA = (MTX_ADDR *) pb;
                memcpy(pb, pmtxSourceDRA, MTX_TSIZE(pmtxSourceDRA));
            }

            if (DRS_UPDATE_SCHEDULE & ulModifyFields) {
                pao->args.rep_mod.rtSchedule = *prtSchedule;
            }

            pao->args.rep_mod.ulReplicaFlags = ulReplicaFlags;
            pao->args.rep_mod.ulModifyFields = ulModifyFields;

            ret = DoOpDRS(pao);
        }

        if (NULL != pmtxSourceDRA) {
            THFreeEx(pTHS, pmtxSourceDRA);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    Assert((NULL == pTHS) || (NULL == pTHS->pDB));

    return ret;
}

ULONG
DirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    )
//
//  Add or remove a target server from the Reps-To property on the given NC.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-To should be modified.
//      pszRepsToDRA (LPWSTR)
//          Network address of DSA for which the reference should be added
//          or deleted.
//      puuidRepsToDRA (UUID *)
//          Invocation-ID of DSA for which the reference should be added
//          or deleted.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DRS_ASYNC_OP
//                  Perform this operation asynchronously.
//              DRS_WRIT_REP
//                  Destination is writeable or readonly
//              DRS_ADD_REF
//                  Add the given server to the Reps-To property.
//              DRS_DEL_REF
//                  Remove the given server from the Reps-To property.
//          Note that DRS_ADD_REF and DRS_DEL_REF may be paired to perform
//          "add or update".
//
//  RETURNS:
//      DRS error (DWORD), as defined in \nt\private\ds\src\inc\drserr.h.
//
{
    THSTATE * pTHS = pTHStls;
    AO *pao;
    UCHAR *pb;
    ULONG ret;
    MTX_ADDR *pDSAMtx_addr;
    BOOL fDRAOnEntry;
    BOOL fResetfDRAOnExit = FALSE;

    if (    ( NULL == pNC )
         || ( NULL == pszRepsToDRA )
         || ( NULL == puuidRepsToDRA )
         || ( fNullUuid( puuidRepsToDRA ) )
         || ( 0 == ( ulOptions & ( DRS_ADD_REF | DRS_DEL_REF ) ) )
       )
    {
        return DRAERR_InvalidParameter;
    }

    // This prevents callers from using reserved flags
    // Note that DRS_GETCHG_CHECK might be considered a system-only flag
    // from its name, but its functon is closer to IGNORE_ERROR. As such
    // we do not prevent remote callers from setting it.
    if (ulOptions & (~REPUPDREF_OPTIONS)) {
        Assert( !"Unexpected replica update reference options" );
        return DRAERR_InvalidParameter;
    }

    PERFINC(pcRepl);                                // PerfMon hook

    if (NULL != pTHS) {
        fDRAOnEntry = pTHS->fDRA;
        fResetfDRAOnExit = TRUE;
    }

    __try {
        InitDraThread(&pTHS);

        pDSAMtx_addr = MtxAddrFromTransportAddrEx(pTHS, pszRepsToDRA);

        if ((pao = malloc(sizeof(AO) + ALIGN_PAD(2) + pNC->structLen +
                          MTX_TSIZE(pDSAMtx_addr))) == NULL) {
            ret = DRAERR_OutOfMem;
            __leave;
        }

        pao->ulOperation = AO_OP_UPD_REFS;
        pao->ulOptions = ulOptions;

        pb = (UCHAR *)pao + sizeof(AO);
        ALIGN_BUFF(pb);
        pao->args.upd_refs.pNC = (DSNAME *)(pb);
        memcpy(pb, pNC, pNC->structLen);

        pb += pNC->structLen;
        ALIGN_BUFF(pb);
        pao->args.upd_refs.pDSAMtx_addr = (MTX_ADDR *)(pb);
        memcpy(pb, pDSAMtx_addr, MTX_TSIZE(pDSAMtx_addr));

        if (NULL != puuidRepsToDRA) {
            pao->args.upd_refs.invocationid = *puuidRepsToDRA;
        }

        ret = DoOpDRS(pao);

        THFreeEx(pTHS, pDSAMtx_addr);
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {
        ;
    }

    if (fResetfDRAOnExit) {
        pTHS->fDRA = fDRAOnEntry;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\draexist.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draexist.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Defines DRS object existence functions - client and server.

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <03/04/01>  gregjohn

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include <attids.h>
#include <ntdsa.h>
#include <dsjet.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
// #include <dominfo.h>
#include <dsatools.h>                   // needed for output allocation

#include "dsevent.h"
#include "mdcodes.h"

#include "drs.h"
#include "objids.h"
#include "anchor.h"
// #include <heurist.h>
// #include "usn.h"
#include <drserr.h>                     // for DRA errors
#include <dsexcept.h>                   // for GetDraExcpetion
// #include "dstaskq.h"
#include "drautil.h"
#include "drancrep.h"
#include "drameta.h"
// #include "dramail.h"
#include "ntdsctr.h"                    // for INC and DEC calls to perf counters

//#include <dsutil.h>

#include "debug.h"              // standard debugging header
#define DEBSUB "DRAEXIST:"       // define the subsystem for debugging

// #include "dsconfig.h"

//#include <ntdsvsrv.h>
//#include <nlwrap.h>
//#include <dsgetdc.h>
//#include <ldapagnt.h>
//#include <dns.h>
//#include <nspi.h>

#include "drarpc.h"                     // for ReferenceContext and DereferenceContext
#include "drsuapi.h"
#include "drauptod.h"
#include <crypto\md5.h>                 // for Md5

#include <fileno.h>
#define  FILENO FILENO_DRAEXIST

#define OBJECT_EXISTENCE_GUID_NUMBER_PER_PACKET 1000

#if DBG
#define DPRINT1GUID(x,y,z) DPRINT1Guid(x,y,z)
DPRINT1Guid(
    USHORT        Verbosity,
    LPSTR         Message,
    GUID          guid
    )
    {
	LPWSTR pszGuid = NULL;
	UuidToStringW(&guid, &pszGuid);
	DPRINT1(Verbosity, Message, pszGuid);
	RpcStringFreeW(&pszGuid);
}
#else
#define DPRINT1GUID(x,y,z) 
#endif

DB_ERR
DraGetObjectExistence(
    IN  THSTATE *                pTHS,
    IN  DBPOS *                  pDB,
    IN  GUID                     guidStart,
    IN  UPTODATE_VECTOR *        pUpToDateVecCommon,
    IN  ULONG                    dntNC,
    IN OUT DWORD *               pcGuids,
    OUT  UCHAR                   Md5Digest[MD5DIGESTLEN],
    OUT GUID *                   pNextGuid, 
    OUT GUID *                   prgGuids[]
    )
/*++

Routine Description:
    
    Given a guid and NC to begin with and a UTD, return a checksum and list of guids to
    objects whose creation time is earlier than the UTD and whose objects
    are in the given NC and greater than the start guid in sort order.  Also returns
    a Guid to start the next itteration at.  If DraGetObjectExistence returns success and
    pNextGuid is gNullUuid, then there are no more Guids to iterate.

Arguments:
 
    pTHS - 
    pDB - 
    guidStart - guid to begin search
    pUpToDateVecCommon - utd to date creation times with
    Md5Digest[MD5DIGESTLEN] - returned Md5 checksum
    dntNC - dnt of NC to search
    pNextGuid - returned guid for next loop iteration
    pcGuids - on input, the max number of guids to put in list
	      on output, the number actually found 
    prgGuids[] - returned list of guids

Return Values:

    0 on success or DB_ERR on failure.  On output pNextGuid is only valid on success.

--*/
{

    INDEX_VALUE                      IV[2];
    DB_ERR                           err = 0;
    ULONG                            cGuidAssimilated = 0;
    PROPERTY_META_DATA_VECTOR *      pMetaDataVec = NULL;
    PROPERTY_META_DATA *             pMetaData = NULL;
    ULONG                            cb;
    ULONG                            ulGuidExamined = 0;
    MD5_CTX                          Md5Context;

    // verify input 
    Assert(*prgGuids==NULL);

    // initalize
    MD5Init(
	&Md5Context
	);

    // locate guids
    err = DBSetCurrentIndex(pDB, Idx_NcGuid, NULL, FALSE);
    if (err) {
	return err;
    }
    *prgGuids = THAllocEx(pTHS, *pcGuids*sizeof(GUID));

    // set nc search criteria
    IV[0].cbData = sizeof(ULONG);
    IV[0].pvData = &dntNC;
    if (!memcmp(&guidStart, &gNullUuid, sizeof(GUID))) {
	// no guid to start, so start at beginning of NC 
	err = DBSeek(pDB, IV, 1, DB_SeekGE);
    } else {
	// set guid search criteria
	IV[1].cbData = sizeof(GUID);
	IV[1].pvData = &guidStart;

	// if not found, start at guid greater in order
	err = DBSeek(pDB, IV, 2, DB_SeekGE);
    }

    // while we want to examine more guids
    //       and we have no error (including errors of no objects left)
    //       and we are in the correct NC
    while ((cGuidAssimilated < *pcGuids) && (!err) && (pDB->NCDNT==dntNC)) { 
	// get the meta data of the objects
	err = DBGetAttVal(pDB, 
			  1, 
			  ATT_REPL_PROPERTY_META_DATA,
			  0, 
			  0, 
			  &cb, 
			  (LPBYTE *) &pMetaDataVec);

	if (!err) { 
	    pMetaData = ReplLookupMetaData(ATT_WHEN_CREATED,
					   pMetaDataVec, 
					   NULL);

	    if (pMetaData==NULL) {
		Assert(!"Object must have metadata");
		err = DB_ERR_UNKNOWN_ERROR;
	    }
	    else { 
		if (!UpToDateVec_IsChangeNeeded(pUpToDateVecCommon,
						&pMetaData->uuidDsaOriginating,
						pMetaData->usnOriginating)) {
		    // guid is within the Common utd, copy it into the list and update the digest

		    Assert(cGuidAssimilated < *pcGuids);

		    // add guid to the list
		    GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &((*prgGuids)[cGuidAssimilated]), sizeof(GUID) );  

		    // update the digest
		    MD5Update(
			&Md5Context,
			(PBYTE) &((*prgGuids)[cGuidAssimilated]),
			sizeof(GUID)
			);    

		    DPRINT2(1, "OBJECT EXISTENCE:  Assimilating:(%d of %d) - ", cGuidAssimilated, ulGuidExamined);
		    DPRINT1GUID(1, "%S\n", (*prgGuids)[cGuidAssimilated]);
		    cGuidAssimilated++;
		}
		else {
		    GUID tmpGuid;
		    GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &tmpGuid, sizeof(GUID) );
		    DPRINT1GUID(1, "OBJECT EXISTENCE:  Object (%S) not within common UTD\n", tmpGuid); 
		}
		// move to the next guid
		err = DBMove(pDB, FALSE, DB_MoveNext);
		ulGuidExamined++;
	    }
	}
	if (pMetaDataVec!=NULL) {
	    THFreeEx(pTHS, pMetaDataVec);
	    pMetaDataVec = NULL;
	}
    }

    // find the next value to examine for the next iteration
    if ((!err) && (pDB->NCDNT==dntNC)) { 
	GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, pNextGuid, sizeof(GUID) );
    }
    else if ((err==DB_ERR_RECORD_NOT_FOUND) || (err==DB_ERR_NO_CURRENT_RECORD)) {
	// no more values to examine
	err = ERROR_SUCCESS; 
	memcpy(pNextGuid, &gNullUuid, sizeof(GUID));
    }
    else {
	memcpy(pNextGuid, &gNullUuid, sizeof(GUID));
    }

    // set return variables
    *pcGuids = cGuidAssimilated;

    Assert((cGuidAssimilated != 0) ||
	   0==memcpy(pNextGuid, &gNullUuid, sizeof(GUID)));

    MD5Final(
	&Md5Context
	);
    memcpy(Md5Digest, Md5Context.digest, MD5DIGESTLEN*sizeof(UCHAR));

    return err;
}

#define LOCATE_GUID_MATCH (0)
#define LOCATE_OUT_OF_SCOPE (1)
#define LOCATE_NOT_FOUND (2)

DWORD
LocateGUID(
    IN     GUID                    guidSearch,
    IN OUT ULONG *                 pulPosition,
    IN     GUID                    rgGuids[],
    IN     ULONG                   cGuids
    )
/*++

Routine Description:
    
    Given a guid, a list of sorted guids, and a position in the list
    return TRUE if the guid is found forward from position, else return
    false.  Update pulPosition to reflect search (for faster subsequent searches)
    
    WARNING:  This routine depends upon the Guid sort order returned from
    a JET index.  It doesn't follow the external definition of UuidCompare, but
    instead uses memcmp.  If this sort order ever changes, this function MUST
    be updated.  

Arguments:

    guidSearch 		- guid to search for
    ulPositionStart 	- position in array to start searching from
    rgGuids     	- array of guids
    cGuids     		- size of array in guids

Return Values:

    true if found, false otherwise.  
    pulPostion -> position found.

--*/
{
    ULONG ul = *pulPosition;
    int compareValue = 1;
    DWORD dwReturn;

    if (cGuids==0) {
	return LOCATE_NOT_FOUND;
    }

    if (!(ul<cGuids)) {
	Assert(!"Cannot evaluate final Guid for Not Found Vs. Out of Scope");
	return LOCATE_OUT_OF_SCOPE;
    }

    while ((ul<cGuids) && (compareValue > 0)) {
	compareValue = memcmp(&guidSearch, &(rgGuids[ul++]), sizeof(GUID));  
    }    

    if (compareValue==0) {
	// found it
	dwReturn = LOCATE_GUID_MATCH;
    }
    else if (compareValue < 0) {
	// didn't find
	dwReturn = LOCATE_NOT_FOUND;
    }
    else { // ul>=cGuids - no more to search and not found
	Assert(ul==cGuids);
	dwReturn = LOCATE_OUT_OF_SCOPE;
    }
    *pulPosition = ul - 1; // last inc went too far, compensate
    return dwReturn;
}

DWORD
DraGetRemoteObjectExistence(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    ULONG                        cGuids,
    GUID                         guidStart,
    UPTODATE_VECTOR *            putodCommon,
    DSNAME *                     pNC,
    UCHAR                        Md5Digest[MD5DIGESTLEN],
    OUT BOOL *                   pfMatch,
    OUT ULONG *                  pcNumGuids,
    OUT GUID *                   prgGuids[]
    )
/*++

Routine Description:
    
    Contact a DC and request Object Existence test using the inputted
    Md5Digest Checksum.  Return results (ie match or guid list)

Arguments:

    pTHS - 
    pszServer - DC to contact 
    cGuids - number of guids in object existence range
    guidStart - guid to begin at
    putodCommon - utd for object exitence
    pNC - nc for object existence
    Md5Digest[MD5DIGESTLEN] - checksum for object existence
    pfMatch - returned bool
    pcNumGuids - returned num of guids
    prgGuids - returned guids


Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DRS_MSG_EXISTREQ             msgInExist;
    DRS_MSG_EXISTREPLY           msgOutExist;
    DWORD                        dwOutVersion = 0;
    DWORD                        ret = ERROR_SUCCESS;
    UPTODATE_VECTOR *            putodVector = NULL;

    // Call the source for it's checksum/guid list
    memset(&msgInExist, 0, sizeof(DRS_MSG_EXISTREQ));
    memset(&msgOutExist, 0, sizeof(DRS_MSG_EXISTREPLY));

    msgInExist.V1.cGuids = cGuids; 
    msgInExist.V1.guidStart = guidStart;

    // we only need V1 info, so only pass V1 info, convert
    putodVector = UpToDateVec_Convert(pTHS, 1, putodCommon);
    Assert(putodVector->dwVersion==1);
    msgInExist.V1.pUpToDateVecCommonV1 = putodVector; 
    msgInExist.V1.pNC = pNC;  
    memcpy(msgInExist.V1.Md5Digest, Md5Digest, MD5DIGESTLEN*sizeof(UCHAR));  

    // make the call
    ret = I_DRSGetObjectExistence(pTHS, pszServer, &msgInExist, &dwOutVersion, &msgOutExist);

    if ((ret==ERROR_SUCCESS) && (dwOutVersion!=1)) {
	Assert(!"Incorrect version number from GetObjectExistence!");
	DRA_EXCEPT(DRAERR_InternalError,0);
    }

    if (ret==ERROR_SUCCESS) {
	*prgGuids = msgOutExist.V1.rgGuids;
	*pcNumGuids = msgOutExist.V1.cNumGuids;

	*pfMatch=  msgOutExist.V1.dwStatusFlags & DRS_EXIST_MATCH; 
    }
    
    if (putodVector!=NULL) {
	THFreeEx(pTHS, putodVector);
    }

    return ret;
}

DWORD
DraObjectExistenceCheckDelete(
    THSTATE *                    pTHS,
    DSNAME *                     pDNDelete
    )
/*++

Routine Description:
    
    Check that the object pointed to by pTHS->pDB and pDNDelete is a valid
    object for ObjectExistence to delete

Arguments:

    pTHS - pTHS->pDB should be located on object
    pDNDelete - DSNAME of object (could be looked up here, but calling
		function already had this value) 

Return Values:

    0 - delete-able object
    ERROR - do not delete

--*/
{
    DWORD                        ret = ERROR_SUCCESS;
    ULONG IsCritical;
    ULONG instanceType;

    ret = NoDelCriticalObjects(pDNDelete, pTHS->pDB->DNT);
    if (ret) {
	THClearErrors();
	ret = ERROR_DS_CANT_DELETE;
    }

    if (ret==ERROR_SUCCESS) {
	if ((0 == DBGetSingleValue(pTHS->pDB,
				   ATT_IS_CRITICAL_SYSTEM_OBJECT,
				   &IsCritical,
				   sizeof(IsCritical),
				   NULL))
	    && IsCritical) {
	    // This object is marked as critical.  Fail.
	    ret = ERROR_DS_CANT_DELETE;
	}
    }

    if (ret==ERROR_SUCCESS) {
	if ((0 == DBGetSingleValue(pTHS->pDB,
				   ATT_INSTANCE_TYPE,
				   &instanceType,
				   sizeof(instanceType),
				   NULL))
	    && (instanceType & IT_NC_HEAD)) {
	    // this object is an NC head
	    ret = ERROR_DS_CANT_DELETE;
	}
    }

    return ret;
}

DWORD 
DraObjectExistenceDelete(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    GUID                         guidDelete,
    ULONG                        dntNC,
    BOOL                         fAdvisoryMode
    )
/*++

Routine Description:
    
    If fAdvisoryMode is false, delete the object guidDelete and/or
    log this attempt/success.

Arguments:

    pTHS - 
    pszServer - name of Source for logging
    guidDelete - guid of object to delete
    dntNC - NC of object to delete (to locate with index)
    fAdvisoryMode - if TRUE, don't delete, only log message 

Return Values:

    0 on success, Win Error on failure

--*/
{
    INDEX_VALUE                  IV[2];   
    DSNAME *                     pDNDelete = NULL;
    ULONG                        cbDNDelete;
    DWORD                        ret = ERROR_SUCCESS;

    DBSetCurrentIndex(pTHS->pDB, Idx_NcGuid, NULL, FALSE);
    // locate the guid in the DB
    IV[0].cbData = sizeof(ULONG);
    IV[0].pvData = &dntNC;
    IV[1].cbData = sizeof(GUID);
    IV[1].pvData = &guidDelete;
    ret = DBSeek(pTHS->pDB, IV, 2, DB_SeekEQ);
    if (ret) {
	if ((ret==DB_ERR_NO_CURRENT_RECORD) || (ret==DB_ERR_RECORD_NOT_FOUND)) {
	    // it's either an error, or it was deleted during execution.  we
	    // didn't delete it, so log that fact.
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_LOR_OBJECT_DELETION_FAILED,
		     szInsertWC(L""),
		     szInsertUUID(&guidDelete), 
		     szInsertWC(pszServer));
	    // not a fatal error, continue...
	    return ERROR_SUCCESS;
	} else {  
	    // bad news, log this and except
	    LogEvent8(DS_EVENT_CAT_REPLICATION,
		      DS_EVENT_SEV_ALWAYS,
		      DIRLOG_LOR_OBJECT_DELETION_ERROR_FATAL,
		      szInsertUUID(&guidDelete), 
		      szInsertWC(pszServer),
		      szInsertWin32Msg(ret),
		      szInsertUL(ret),
		      NULL,
		      NULL,
		      NULL,
		      NULL);
	    DRA_EXCEPT(DRAERR_DBError, ret);
	}
    }

    // located object, get object DN
    cbDNDelete = 0;
    ret = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
		      0, 0,
		      &cbDNDelete, (PUCHAR *)&pDNDelete);
    if ((ret) || (pDNDelete==NULL)) {
	// bad news, log this and except 
	LogEvent8(DS_EVENT_CAT_REPLICATION,
		  DS_EVENT_SEV_ALWAYS,
		  DIRLOG_LOR_OBJECT_DELETION_ERROR_FATAL,
		  szInsertUUID(&guidDelete), 
		  szInsertWC(pszServer),
		  szInsertWin32Msg(ret),
		  szInsertUL(ret),
		  NULL,
		  NULL,
		  NULL,
		  NULL);
	DRA_EXCEPT(DRAERR_InternalError, ret);
    }

    if (fAdvisoryMode) { 
	LogEvent(DS_EVENT_CAT_REPLICATION,
		 DS_EVENT_SEV_ALWAYS,
		 DIRLOG_LOR_OBJECT_DELETION_ADVISORY,
		 szInsertWC(pDNDelete->StringName),
		 szInsertUUID(&guidDelete), 
		 szInsertWC(pszServer));
    } else {
	__try { 
	    #if DBG 
	    { 
		GUID guidDelete;
		GetExpectedRepAtt(pTHS->pDB, ATT_OBJECT_GUID, &guidDelete, sizeof(GUID)); 
		Assert(!memcmp(&guidDelete, &guidDelete, sizeof(GUID))); 
	    }
	    #endif

	    // Delete it
	    DPRINT1GUID(1, "DELETE:  %S\n", guidDelete);

	    ret = DraObjectExistenceCheckDelete(pTHS,     
						pDNDelete);
	    if (ret==ERROR_SUCCESS) {  
		BOOL fOrigfDRA;
		fOrigfDRA = pTHS->fDRA;  
		__try {  
		    pTHS->fDRA = TRUE;
		    ret = DeleteLocalObj(pTHS, pDNDelete, TRUE, TRUE, NULL);
		}
		__finally {  
		    pTHS->fDRA = fOrigfDRA;
		}

		if (ret==ERROR_DS_CANT_DELETE) {
		    DPRINT1GUID(1,"Can't delete %S\n", guidDelete);
		    // log can't delete
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_LOR_OBJECT_DELETION_FAILED,
			     szInsertWC(pDNDelete->StringName),
			     szInsertUUID(&guidDelete), 
			     szInsertWC(pszServer)); 
		} else if (ret!=ERROR_SUCCESS) {  
		    LogEvent8(DS_EVENT_CAT_REPLICATION,
			      DS_EVENT_SEV_ALWAYS,
			      DIRLOG_LOR_OBJECT_DELETION_ERROR,
			      szInsertWC(pDNDelete->StringName),
			      szInsertUUID(&guidDelete), 
			      szInsertWC(pszServer),
			      szInsertWin32Msg(ret),
			      szInsertUL(ret),
			      NULL,
			      NULL,
			      NULL);
		} else {
		    // success
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_LOR_OBJECT_DELETION,
			     szInsertWC(pDNDelete->StringName),
			     szInsertUUID(&guidDelete), 
			     szInsertWC(pszServer));
		}
	    } else {
		LogEvent(DS_EVENT_CAT_REPLICATION,
			 DS_EVENT_SEV_ALWAYS,
			 DIRLOG_LOR_OBJECT_DELETION_FAILED_CRITICAL_OBJECT,
			 szInsertWC(pDNDelete->StringName),
			 szInsertUUID(&(pDNDelete->Guid)), 
			 szInsertWC(pszServer)); 
	    }
	}
	__except(GetDraException(GetExceptionInformation(), &ret)) {  
	    LogEvent8(DS_EVENT_CAT_REPLICATION,
		      DS_EVENT_SEV_ALWAYS,
		      DIRLOG_LOR_OBJECT_DELETION_ERROR,
		      szInsertWC(pDNDelete->StringName),
		      szInsertUUID(&guidDelete), 
		      szInsertWC(pszServer),
		      szInsertWin32Msg(ret),
		      szInsertUL(ret),
		      NULL,
		      NULL,
		      NULL);
	}
    }

    if (pDNDelete!=NULL) {
	THFreeEx(pTHS, pDNDelete);
	pDNDelete = NULL;
    }

    return ret;
}

DWORD				       
DraDoObjectExistenceMismatch(
    THSTATE *                    pTHS,
    LPWSTR                       pszServer,
    GUID                         rgGuidsDestination[],
    ULONG                        cGuidsDestination,
    GUID                         rgGuidsSource[],
    ULONG                        cGuidsSource,
    BOOL                         fAdvisory,
    ULONG                        dntNC,
    OUT ULONG *                  pulDeleted,
    OUT GUID *                   pguidNext
    )
/*++

Routine Description:
    
    The source and destination mismatch the guid set.  Locate the 
    offending guids on the destination and delete them.  It is possible
    that the source simply has extra guids in this range, in this case
    we will find that the guid list is out of scope, and we will
    set pguidNext and return.

Arguments:

    pTHS - 
    pszServer - name of Source for logging
    rgGuidsDestination[] - guid list from destination	
    cGuidsDestination - count of guids from destination
    rgGuidsSource[] - guid list from source
    cGuidsSource - count of guids from source
    fAdvisory - actually delete, or just log
    dntNC - NC of guids
    pulDeleted - count of object deleted, or logged if fAdvisory
    pguidNext - if out of scope on source list, this is should be start of next guid list

Return Values:

    0 on success, Win Error on failure

--*/
{
    ULONG                        ulGuidsSource = 0;
    ULONG                        ulGuidsDestination = 0;
    ULONG                        ulTotalObjectsDeleted = 0;
    DWORD                        dwLocate = LOCATE_GUID_MATCH;
    DWORD                        ret = ERROR_SUCCESS;

    // checksum mismatch, delete (or in advisory mode simply log) objects
    // which exist in this set of guids, and do not exist in the set
    // retrieved from the source

    // the two lists should be in order, with the source list starting
    // at least at the start of rgGuidsDestination
    if (!((cGuidsDestination==0) // race condition, this is possible
	   ||
	   (cGuidsSource==0) // Source list empty
	   ||  
	   // if we have guids in both lists, then the source must return
	   // a list that begins at least as large as the first destination
	   // guid to ensure progress
	   (0 >= memcmp(&(rgGuidsDestination[0]), &(rgGuidsSource[0]), sizeof(GUID)))
	   )) {
	DRA_EXCEPT(DRAERR_InternalError, 0);
    }

      while ((ulGuidsDestination < cGuidsDestination) && (dwLocate!=LOCATE_OUT_OF_SCOPE)) {
	// search the source's guid list for rgGuidsDestination[ulGuidsDestination]
	// there are 3 return values, either 
	// LOCATE_GUID_MATCH - both source and destination have object
	// LOCATE_NOT_FOUND - guid is not in source list and should be (in order list)
	// LOCATE_OUT_OF_SCOPE - source list is out of scope, ie the guid to be found
	// 			is greater than (in order list) than every guid in the list.
	//			in this case we need to exit the loop and request another
	//                      comparison, this time starting at this guid  
	dwLocate = LocateGUID(rgGuidsDestination[ulGuidsDestination], &ulGuidsSource, rgGuidsSource, cGuidsSource);   
	if (dwLocate==LOCATE_NOT_FOUND) {
	    // if fAdvisory, attempt to delete this object.
	    ret = DraObjectExistenceDelete(pTHS,
					   pszServer,
					   rgGuidsDestination[ulGuidsDestination],
					   dntNC,
					   fAdvisory
					   ); 
	    if (ret==ERROR_SUCCESS) {
		ulTotalObjectsDeleted++;
		*pulDeleted++;
	    }
	    ret = ERROR_SUCCESS;
	} else if (dwLocate==LOCATE_OUT_OF_SCOPE) {
	    DPRINT1GUID(1, "Out of scope on guid:  %S\n", rgGuidsDestination[ulGuidsDestination]); 
	    Assert(ulGuidsDestination!=0);
	    memcpy(pguidNext, &(rgGuidsDestination[ulGuidsDestination]), sizeof(GUID)); 
	} 
	#if DBG
	else {
	    Assert(dwLocate==LOCATE_GUID_MATCH);
	}
	#endif
	ulGuidsDestination++;
    }

    __try {
	// commit transaction for all deletes in this packet
	ret = DBTransOut(pTHS->pDB, TRUE, TRUE);
	if (ret) {
	    DRA_EXCEPT(ret,0);
	} 
	LogEvent(DS_EVENT_CAT_REPLICATION,
		 DS_EVENT_SEV_MINIMAL,
		 DIRLOG_LOR_SUCCESS_TRANSACTION,
		 szInsertWC(pszServer),
		 szInsertUL(ulTotalObjectsDeleted),
		 NULL);
    }
    __except(GetDraException(GetExceptionInformation(), &ret)) {  
	// log that the transaction failed
	LogEvent8(DS_EVENT_CAT_REPLICATION,
		  DS_EVENT_SEV_ALWAYS,
		  DIRLOG_LOR_FAILURE_TRANSACTION,
		  szInsertWC(pszServer),
		  szInsertUL(ulTotalObjectsDeleted),
		  szInsertWin32Msg(ret),
		  szInsertUL(ret),
		  NULL,
		  NULL,
		  NULL,
		  NULL); 
    }
    // open another transaction
    ret = DBTransIn(pTHS->pDB);
    return ret;
}

DWORD
DraVerifyObjectHelper(
    THSTATE *                    pTHS,
    UPTODATE_VECTOR *            putodCommon,
    ULONG                        dntNC,
    DSNAME *                     pNC,
    LPWSTR                       pszServer,
    BOOL                         fAdvisory,
    ULONG *                      pulTotal
    )
/*++

Routine Description:
    
    Do the work for IDL_DRSReplicaVerifyObjects

Arguments:

    pTHS - 
    putodCommon -
    dntNC -
    pNC -
    pszServer -
    fAdvisory -
    pulTotal -
    
Return Values:

    0 on success, Win Error on failure

--*/
{
    BOOL                         fComplete          = FALSE;
    DWORD                        ret                = ERROR_SUCCESS;
    ULONG                        cGuids;
    GUID                         guidStart          = gNullUuid;
    MD5_CTX                      Md5Context;
    GUID                         guidNext           = gNullUuid;
    GUID *                       rgGuids            = NULL;
    UPTODATE_VECTOR *            putodVector        = NULL;
    GUID *                       rgGuidsServer      = NULL;
    ULONG                        cGuidsServer       = 0;
    BOOL                         fMatch;
    ULONG                        ulDeleted          = 0;

    // while there are more objects in the NC whose creation is within the merged utd
    while (!fComplete) {
	cGuids = OBJECT_EXISTENCE_GUID_NUMBER_PER_PACKET;
	// get guids and checksums on destination and source
	ret = DraGetObjectExistence(pTHS,
				    pTHS->pDB,
				    guidStart,      
				    putodCommon,
				    dntNC,
				    &cGuids,      
				    (UCHAR *)Md5Context.digest,
				    &guidNext,     
				    &rgGuids);
	if (ret) {  
	    // if this doesn't return, cannot safely continue
	    DRA_EXCEPT(ret,0);
	}

	if (cGuids>0) { 
	    ret = DraGetRemoteObjectExistence(pTHS,
					      pszServer,
					      cGuids,
					      ((cGuids > 0) ? rgGuids[0] : gNullUuid), //guidStart
					      putodCommon,
					      pNC,
					      Md5Context.digest,
					      &fMatch,
					      &cGuidsServer,
					      &rgGuidsServer
					      );
	} else {
	    // if we don't have any guids to examine, then consider it matched
	    // since we're done with our work 
	    fMatch=TRUE;
	    // we aren't going to continue, so guidNext should be NULL
	    Assert(0==memcmp(&guidNext, &gNullUuid, sizeof(GUID)));
	}
	
	if (ret) {  
	    // if this doesn't return, cannot safely continue
	    DRA_EXCEPT(ret,0);
	}

	if (fMatch) {
	    DPRINT(1,"Checksum Matched\n");
	} else {
	    DPRINT(1,"Checksum Mismatched\n");
	    ulDeleted = 0;
	    // objects mismatched, check the lists
	    // if needed, update guidNext
	    ret = DraDoObjectExistenceMismatch(pTHS,
					       pszServer,
					       rgGuids,
					       cGuids,
					       rgGuidsServer,
					       cGuidsServer,
					       fAdvisory,
					       dntNC,
					       &ulDeleted,
					       &guidNext
					       );
	    *pulTotal += ulDeleted;
	}
	memcpy(&guidStart, &guidNext, sizeof(GUID));

	if (fNullUuid(&guidNext)) {
	    // No Guid to search for?  Then we're done.
	    fComplete = TRUE;
	}
	// clean up 
	if (putodVector) {
	    THFreeEx(pTHS, putodVector);
	}
	if (rgGuids) {
	    THFreeEx(pTHS, rgGuids);
	    rgGuids = NULL;
	}
    }
    
    return ret;
}

DWORD DraGetRemoteUTD(
    THSTATE *                    pTHS,
    LPWSTR                       pszRemoteServer,
    LPWSTR                       pszNC,
    GUID                         guidRemoteServer,
    UPTODATE_VECTOR **           pputodVectorRemoteServer
    )
/*++

Routine Description:
    
    Retrieve a UTD from a remote server

Arguments:

    pTHS	
    pszRemoteServer - server to retrieve UTD from
    pszNC - NC of UTD to retrieve
    guidRemoteServer - GUID fo server to retrieve UTD from
    pputodVectorRemoteServer - returned UTD

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DRS_MSG_GETREPLINFO_REQ      msgInInfo;
    DRS_MSG_GETREPLINFO_REPLY    msgOutInfo;
    DWORD                        dwOutVersion = 0;
    DWORD                        ret = ERROR_SUCCESS;

    memset(&msgInInfo, 0, sizeof(DRS_MSG_GETREPLINFO_REQ));
    memset(&msgOutInfo, 0, sizeof(DRS_MSG_GETREPLINFO_REPLY));

    msgInInfo.V2.InfoType = DS_REPL_INFO_UPTODATE_VECTOR_V1;
    msgInInfo.V2.pszObjectDN = pszNC;
    msgInInfo.V2.uuidSourceDsaObjGuid=guidRemoteServer;

    ret = I_DRSGetReplInfo(pTHS, pszRemoteServer, 2, &msgInInfo, &dwOutVersion, &msgOutInfo); 

    if ((ret==ERROR_SUCCESS) && (
		   (dwOutVersion!=DS_REPL_INFO_UPTODATE_VECTOR_V1) ||
		   (msgOutInfo.pUpToDateVec==NULL) || 
		   (msgOutInfo.pUpToDateVec->dwVersion!=1)
		   )
	) {
	Assert(!"GetReplInfo returned incorrect response!");
	DRA_EXCEPT(DRAERR_InternalError,0);
    } else if (ret==ERROR_SUCCESS) {
	*pputodVectorRemoteServer = UpToDateVec_Convert(pTHS, UPTODATE_VECTOR_NATIVE_VERSION, (UPTODATE_VECTOR *)msgOutInfo.pUpToDateVec);
	Assert((*pputodVectorRemoteServer)->dwVersion==UPTODATE_VECTOR_NATIVE_VERSION);
    }    
    return ret;
}


ULONG
IDL_DRSReplicaVerifyObjects(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwVersion,
    IN  DRS_MSG_REPVERIFYOBJ *  pmsgVerify
    )
/*++

Routine Description:
    
    Verify the existence of all objects on a destination (this) server with objects
    on the source (located in pmsgVerify).  Any objects found which were
    deleted and garbage collected on the source server are either
    deleted and/or logged on the destination depending on 
    advisory mode (in pmsgVerify).
    
    WARNING:  The successfull completion of this routine requires that both destination
    and source sort any two GUIDs in the same order.  If the sort order changes, 
    LocateGUIDPosition must be modified, and a new message version must be created to
    pass to IDL_DRSGetObjectExistence to pass guids in a new sort order.

Arguments:

    hDrs - 
    dwVersion - 
    pmsgVerify - 

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    THSTATE *                    pTHS = NULL;
    DWORD                        ret = ERROR_SUCCESS;
    LPWSTR                       pszServer = NULL;
    DSNAME                       dnServer;
    ULONG                        instanceType;
    UPTODATE_VECTOR *            putodThis = NULL;
    UPTODATE_VECTOR *            putodMerge = NULL;
    ULONG                        ulOptions;
    ULONG                        ulTotalDelete = 0;
    ULONG                        dntNC = 0;
    UPTODATE_VECTOR *            putodVector = NULL;

    drsReferenceContext( hDrs, IDL_DRSREPLICAVERIFYOBJECTS );
    INC(pcThread);
    __try {
	__try {

	    // ValidateInput
	    if ((dwVersion!=1) ||
		(pmsgVerify==NULL) || 
		(fNullUuid(&(pmsgVerify->V1.uuidDsaSrc))) ||
		(pmsgVerify->V1.pNC==NULL)
		 ) {
		DRA_EXCEPT(DRAERR_InvalidParameter, 0);  
	    }  

	    // Init Thread
	    if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
		// Failed to initialize a THSTATE.
		DRA_EXCEPT(DRAERR_OutOfMem, 0);
	    } 
	    
	    // Check Security Access
	    if (!IsDraAccessGranted(pTHS, pmsgVerify->V1.pNC,
				    &RIGHT_DS_REPL_SYNC, &ret)) {  
		DRA_EXCEPT(ret, 0);
	    }
 
	    // initialize variables
	    ulOptions = pmsgVerify->V1.ulOptions;

	    // Get source server name
	    dnServer.Guid=pmsgVerify->V1.uuidDsaSrc;
	    dnServer.NameLen=0;  
	    pszServer = GuidBasedDNSNameFromDSName(&dnServer);
	    if (pszServer==NULL) {
		DRA_EXCEPT(DRAERR_InvalidParameter,0);
	    }

	    // Log Event
	    LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
		     (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		                  DIRLOG_LOR_BEGIN_ADVISORY : \
		                  DIRLOG_LOR_BEGIN,
                     szInsertWC(pszServer),
		     NULL, 
		     NULL);

	    // Retreive UTD's
	    ret = DraGetRemoteUTD(pTHS,
				  pszServer,
				  pmsgVerify->V1.pNC->StringName,
				  pmsgVerify->V1.uuidDsaSrc,
				  &putodVector
				  );

	    if (ret!=ERROR_SUCCESS) {  
		DRA_EXCEPT(ret,0);
	    }
	    DBOpen2(TRUE, &pTHS->pDB);
	    __try {  
		if (ret = FindNC(pTHS->pDB, pmsgVerify->V1.pNC,
				 FIND_MASTER_NC | FIND_REPLICA_NC, 
				 &instanceType)) {
		    DRA_EXCEPT(DRAERR_BadNC, ret);
		}
		// Save the DNT of the NC object  
		dntNC = pTHS->pDB->DNT;
		
		UpToDateVec_Read(pTHS->pDB, instanceType, UTODVEC_fUpdateLocalCursor,
				 DBGetHighestCommittedUSN(), &putodThis);   
 
		// merge UTD's
		UpToDateVec_Merge(pTHS, putodThis, putodVector, &putodMerge); 

		ret = DraVerifyObjectHelper(pTHS,
					    putodMerge,
					    dntNC,
					    pmsgVerify->V1.pNC,
					    pszServer,
					    (ulOptions & DS_EXIST_ADVISORY_MODE),
					    &ulTotalDelete
					    );
	    }
	    __finally {  
		DBClose(pTHS->pDB, TRUE);  
	    } 
	}
	__except(GetDraException(GetExceptionInformation(), &ret)) {
	    ;
	}
	
	// log success / minor failures here
	if (ret==ERROR_SUCCESS) {
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		     DIRLOG_LOR_END_ADVISORY_SUCCESS : \
		     DIRLOG_LOR_END_SUCCESS,
		     szInsertWC(pszServer),
		     szInsertUL(ulTotalDelete), 
		     NULL);
	}
	else {
	    LogEvent8(DS_EVENT_CAT_REPLICATION,
		      DS_EVENT_SEV_ALWAYS,
		      (ulOptions & DS_EXIST_ADVISORY_MODE) ? \
		      DIRLOG_LOR_END_ADVISORY_FAILURE : \
		      DIRLOG_LOR_END_FAILURE,
		      szInsertWC(pszServer),
		      szInsertWin32Msg(ret), 
		      szInsertUL(ret),
		      szInsertUL(ulTotalDelete),
		      NULL,
		      NULL,
		      NULL,
		      NULL);  
	}
	
	if (pszServer) {
	    THFreeEx(pTHS, pszServer);
	}
	if (putodVector) {
	    THFreeEx(pTHS, putodVector);  
	}
	if (putodThis) {
	    THFreeEx(pTHS, putodThis);
	}
    }
    __finally {
	DEC(pcThread);
	drsDereferenceContext( hDrs, IDL_DRSREPLICAVERIFYOBJECTS );
    }
    return ret;
}

ULONG
IDL_DRSGetObjectExistence(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwInVersion,
    IN  DRS_MSG_EXISTREQ *      pmsgIn,
    OUT DWORD *                 pdwOutVersion,
    OUT DRS_MSG_EXISTREPLY *    pmsgOut
    )
/*++

Routine Description:
    
    Calculate a list of guids and compute a checksum.  If checksum matches inputted
    checksum, return DRS_EXIST_MATCH, else return the list of GUIDs.

Arguments:

    hDrs - 
    dwInVersion -
    pmsgIn -
    pdwOutVersion -
    pmsgOut -

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    DWORD                       ret;
    MD5_CTX                     Md5Context;
    ULONG                       dntNC;
    ULONG                       instanceType = 0;
    GUID *                      rgGuids = NULL;
    ULONG                       cGuids = 0;
    THSTATE *                   pTHS;
    UPTODATE_VECTOR *           putodVector = NULL;
    GUID                        GuidNext;

    drsReferenceContext( hDrs, IDL_DRSGETOBJECTEXISTENCE );
    INC(pcThread);
    __try {
	__try { 
	    //
	    // Initialize
	    //

	    // Verify Input
	    if ((dwInVersion!=1) ||
		(pmsgIn==NULL) ||
		(pmsgIn->V1.pNC==NULL) ||
		(pmsgIn->V1.pUpToDateVecCommonV1==NULL) ||
		(pmsgIn->V1.pUpToDateVecCommonV1->dwVersion!=1)
		) {
		DRA_EXCEPT(DRAERR_InvalidParameter, 0);  
	    } 
	    *pdwOutVersion=1; 

	    if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
		// Failed to initialize a THSTATE.
		DRA_EXCEPT(DRAERR_OutOfMem, 0);
	    }

	    // Check Security Access
	    if (!IsDraAccessGranted(pTHS, pmsgIn->V1.pNC,
				    &RIGHT_DS_REPL_GET_CHANGES, &ret)) {  
		DRA_EXCEPT(ret, 0);
	    }

	    // Calculate checksum/guids
	    DBOpen2(TRUE, &pTHS->pDB);
	    __try { 
		if (ret = FindNC(pTHS->pDB, pmsgIn->V1.pNC,
				 FIND_MASTER_NC, 
				 &instanceType)) {
		    DRA_EXCEPT(DRAERR_BadNC, ret);
		}
		dntNC = pTHS->pDB->DNT;
		cGuids = pmsgIn->V1.cGuids; 

		// Convert to native version
		putodVector = UpToDateVec_Convert(pTHS, UPTODATE_VECTOR_NATIVE_VERSION, (UPTODATE_VECTOR *)pmsgIn->V1.pUpToDateVecCommonV1);
		ret = DraGetObjectExistence(pTHS,
					    pTHS->pDB,
					    pmsgIn->V1.guidStart,
					    putodVector,
					    dntNC,
					    &cGuids,
					    (UCHAR *)Md5Context.digest,
					    &GuidNext,     
					    &rgGuids);
		//if meta data matches, send the A-OK!
		//else send guids.
		if (!memcmp(Md5Context.digest, pmsgIn->V1.Md5Digest, MD5DIGESTLEN*sizeof(UCHAR))) {
		    pmsgOut->V1.dwStatusFlags = DRS_EXIST_MATCH;
		    pmsgOut->V1.cNumGuids = 0;
		    pmsgOut->V1.rgGuids = NULL;
		    DPRINT(1, "Get Object Existence Checksum Success.\n");
		}
		else {
		    pmsgOut->V1.dwStatusFlags = 0;
		    pmsgOut->V1.cNumGuids = cGuids;
		    pmsgOut->V1.rgGuids = rgGuids;
		    DPRINT(1, "Get Object Existence Checksum Failed.\n");
		}
	    }
	    __finally {
		DBClose(pTHS->pDB, TRUE);
	    } 
	}
	 __except(GetDraException(GetExceptionInformation(), &ret)) {
	    ;
	}

	 // clean up  
	 if (putodVector!=NULL) {
	     THFreeEx(pTHS, putodVector);
	 }
    }
    __finally {
	DEC(pcThread);
	drsDereferenceContext( hDrs, IDL_DRSGETOBJECTEXISTENCE );
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drademot.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       drdemot.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Implementation of DirReplicaDemote, used to remove a writeable NC from a
    DSA either as part of full DC demotion or "on the fly" by itself.

DETAILS:

CREATED:

    2000/05/01  Jeff Parham (jeffparh)
        Parts adapted from ntdsetup (author ColinBr).

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winldap.h>
#include <ntldap.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <attids.h>
#include <objids.h>

#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes
#include "dsexcept.h"
#include "anchor.h"
#include "dstaskq.h"

#include "drserr.h"
#include "dsaapi.h"
#include "drautil.h"
#include "drsuapi.h"
#include "drancrep.h"

#include "debug.h"                      // standard debugging header
#define  DEBSUB "DRADEMOT:"              // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_DRADEMOT


///////////////////////////////////////////////////////////////////////////////
//
//  MACROS
//

#define DRA_REPORT_STATUS_TO_NTDSETUP0(msg) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), NULL, NULL, NULL, NULL, NULL); \
    } \
}

#define DRA_REPORT_STATUS_TO_NTDSETUP1(msg, s1) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), (s1), NULL, NULL, NULL, NULL); \
    } \
}

#define DRA_REPORT_STATUS_TO_NTDSETUP2(msg, s1, s2) { \
    if (gpfnInstallCallBack) { \
        SetInstallStatusMessage((msg), (s1), (s2), NULL, NULL, NULL); \
    } \
}


///////////////////////////////////////////////////////////////////////////////
//
//  MODULE VARIABLES
//

// Tracks state information re an ongoing DC demotion.
typedef struct _DRS_DEMOTE_INFO {
    // Info re an ongoing FSMO transfer being done as part of demotion.
    GUID  DsaObjGuid;
    DWORD tidDemoteThread;
} DRS_DEMOTE_INFO;

DRS_DEMOTE_INFO * gpDemoteInfo = NULL;


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION PROTOTYPES
//

DWORD
draGetDSADNFromDNSName(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszDNSName,
    OUT DSNAME ** ppDSADN
    );

void
draGiveAwayFsmoRoles(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    );

void
draCompletePendingLinkCleanup(
    IN  THSTATE *   pTHS
    );

void
draReplicateOffChanges(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    );


///////////////////////////////////////////////////////////////////////////////
//
//  GLOBAL FUNCTION IMPLEMENTATIONS
//

ULONG
DirReplicaGetDemoteTarget(
    IN      DSNAME *                        pNC,
    IN OUT  DRS_DEMOTE_TARGET_SEARCH_INFO * pDTSInfo,
    OUT     LPWSTR *                        ppszDemoteTargetDNSName,
    OUT     DSNAME **                       ppDemoteTargetDSADN
    )
/*++

Routine Description:

    Locate a DSA to which any remaining updates and FSMO roles can be
    transferred as part of demoting an NDNC replica.

    Caller can continue to call this API to get further candidates until
    an error is returned.

    Invokes the locator to find candidates.  An alternate implementation
    would be to search the config NC.

Arguments:

    pNC (IN) - NC being demoted.

    pDTSInfo (IN/OUT) - A search handle, of sorts.  Should be initialized to
        all zeros on the first call.  Caller may keep invoking this function
        as long as it returns success in order to find additional targets.

    ppszDemoteTargetDNSName (OUT) - On successful return, holds the DNS host
        name of the discovered target.  Caller should THFree when no longer
        useful.

    ppDemoteTargetDSADN (OUT) - On successful return, holds the ntdsDsa DN
        of the discovered target.  Caller should THFree when no longer useful.

Return Values:

    0 or Win32 error.

--*/
{
    THSTATE * pTHS = pTHStls;
    LPWSTR pszNC = pNC->StringName;
    DWORD err;
    BOOL fFoundDC;

    __try {
        if (NULL == pTHS) {
            pTHS = InitTHSTATE(CALLERTYPE_DRA);
            if (NULL == pTHS) {
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }
        }

        do {
            ULONG ulGetDCFlags = DS_AVOID_SELF | DS_IS_DNS_NAME | DS_RETURN_DNS_NAME
                                 | DS_ONLY_LDAP_NEEDED | DS_WRITABLE_REQUIRED;
            DS_NAME_RESULTW * pNameResult = NULL;
            DOMAIN_CONTROLLER_INFOW * pDCInfo = NULL;
            LPWSTR pszNCDnsName;
            DWORD cchNCDnsName;

            fFoundDC = FALSE;
            *ppDemoteTargetDSADN = NULL;
            *ppszDemoteTargetDNSName = NULL;

            __try {
                switch (pDTSInfo->cNumAttemptsSoFar) {
                case 0:
                    // Try to find a suitable DC, use the DC in the locator cache if
                    // available.
                    break;

                case 1:
                    // Try again to find a suitable DC, this time forcing the locator to
                    // refresh its cache.
                    ulGetDCFlags |= DS_FORCE_REDISCOVERY;
                    break;

                default:
                    Assert(!"Logic error!");
                case 2:
                    // Bag of tricks is empty.
                    err = ERROR_NO_SUCH_DOMAIN;
                    __leave;
                }

                // Convert NC name into a DNS name.
                err = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY, DS_FQDN_1779_NAME,
                                    DS_CANONICAL_NAME, 1, &pszNC, &pNameResult);
                if (err
                    || (1 != pNameResult->cItems)
                    || (DS_NAME_NO_ERROR != pNameResult->rItems[0].status)) {
                    if (!err) {
                        err = ERROR_DS_NAME_ERROR_RESOLVING;
                    }
                    DPRINT2(0, "Can't crack %ls into DNS name, error %d.\n",
                           pNC->StringName, err);
                    DRA_EXCEPT(err, 0);
                }

                pszNCDnsName = pNameResult->rItems[0].pName;
                cchNCDnsName = wcslen(pszNCDnsName);

                Assert(0 != cchNCDnsName);
                Assert(L'/' == pNameResult->rItems[0].pName[cchNCDnsName - 1]);

                if ((0 != cchNCDnsName)
                    && (L'/' == pNameResult->rItems[0].pName[cchNCDnsName - 1])) {
                    pNameResult->rItems[0].pName[cchNCDnsName - 1] = L'\0';
                }

                // Find another DC that hosts this NC.
                err = DsGetDcNameW(NULL, pszNCDnsName, &pNC->Guid, NULL, ulGetDCFlags,
                                   &pDCInfo);
                if (err) {
                    DPRINT2(0, "Can't find DC for %ls, error %d.\n",
                            pNC->StringName, err);
                    DRA_EXCEPT(err, 0);
                }

                Assert(NULL != pDCInfo);
                Assert(pDCInfo->Flags & DS_NDNC_FLAG);
                Assert(pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG);

                fFoundDC = TRUE;
                pDTSInfo->cNumAttemptsSoFar++;

                *ppszDemoteTargetDNSName
                    = THAllocEx(pTHS,
                                sizeof(WCHAR)
                                * (1 + wcslen(pDCInfo->DomainControllerName)));
                wcscpy(*ppszDemoteTargetDNSName, pDCInfo->DomainControllerName);

                // Translate DSA DNS name into an ntdsDsa DN.
                err = draGetDSADNFromDNSName(pTHS,
                                             pDCInfo->DomainControllerName,
                                             ppDemoteTargetDSADN);
                if (err) {
                    DPRINT2(0, "Can't resolve DNS name %ls into an ntdsDsa DN, error %d.\n",
                            pDCInfo->DomainControllerName, err);

                    // Note that we __leave rather than DRA_EXCEPT so that we
                    // try the next cnadidate.
                    __leave;
                }

                Assert(NULL != *ppDemoteTargetDSADN);
                Assert(!fNullUuid(&(*ppDemoteTargetDSADN)->Guid));

                if (0 == memcmp(&(*ppDemoteTargetDSADN)->Guid,
                                &pDTSInfo->guidLastDSA,
                                sizeof(GUID))) {
                    // Found the same DC this time as we did last time.  Don't try
                    // it again.
                    Assert(2 == pDTSInfo->cNumAttemptsSoFar);
                    DPRINT1(0, "Forced DC location found same bad demotion target %ls.\n",
                            pDCInfo->DomainControllerName);
                    err = ERROR_NO_SUCH_DOMAIN;
                    DRA_EXCEPT(err, 0);
                }

                // Remember this candidate.
                pDTSInfo->guidLastDSA = (*ppDemoteTargetDSADN)->Guid;
            } __finally {
                if (NULL != pDCInfo) {
                    NetApiBufferFree(pDCInfo);
                }

                if (NULL != pNameResult) {
                    DsFreeNameResultW(pNameResult);
                }
            }
        } while (fFoundDC && err); // Found a candidate but e.g. couldn't resolve
                                   // its DNS name into a DN.
    } __except(GetDraException(GetExceptionInformation(), &err)) {
        ;
    }

    // If we didn't find a candidate then we must have set an appropriate error
    // to return.
    Assert(fFoundDC || err);

    // We return values iff there was no error.
    Assert(!!err == !*ppDemoteTargetDSADN);
    Assert(!!err == !*ppszDemoteTargetDNSName);

    return err;
}

ULONG
DirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Removes a writeable NC from a DSA, either as part of full DC demotion or
    "on the fly" by itself.

Arguments:

    pNC (IN) - Name of the writeable NC to remove.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pOtherDSADN (IN) - NTDS Settings (ntdsDsa) DN of the DSA to give FSMO
        roles/replicate to.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_NO_SOURCE - This DC should no longer act as a replication source for
            this NC.  Set when a single NC is being removed from a running
            system, as opposed to when the entire DC is being demoted.  Not
            setting this flag during DC demotion makes this routine non-
            destructive, such that if some later part of the DC demotion fails
            then the DC can still operate with all the NCs it had prior to the
            demotion attempt.

Return Values:

    0 on success, Win32 error on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    SYNTAX_INTEGER it;
    DWORD err;

    __try {
        if ((NULL == pNC)
            || (NULL == pOtherDSADN)) {
            DRA_EXCEPT(DRAERR_InvalidParameter, 0);
        }

        if (NULL == pTHS) {
            pTHS = InitTHSTATE(CALLERTYPE_DRA);
            if (NULL == pTHS) {
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }
        }

        SyncTransSet(SYNC_WRITE);

        __try {
            // Validate NC argument.
            err = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC, &it);
            if (err) {
                // Writeable NC not instantiated on this DSA.
                DRA_EXCEPT(err, 0);
            }

            if (it & IT_NC_GOING) {
                // NC is already in the process of being torn down.  It's too
                // late to give away FSMO roles, etc.  The DS will take care of
                // completing the NC removal.
                DRA_EXCEPT(DRAERR_NoReplica, it);
            }

            if ((DRS_NO_SOURCE & ulOptions)
                && DBHasValues(pTHS->pDB, ATT_REPS_FROM)) {
                // We still have inbound replication partners for this NC.
                // Those must be removed first (unless we're demoting the entire
                // DC).
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }

            // Validate other DSA DN argument.
            err = DBFindDSName(pTHS->pDB, pOtherDSADN);
            if (err) {
                DRA_EXCEPT(DRAERR_BadDN, err);
            }

            DBFillGuidAndSid(pTHS->pDB, pOtherDSADN);
        } __finally {
            // Close transaction before beginning operations that may go off
            // machine.
            SyncTransEnd(pTHS, !AbnormalTermination());
        }

        // Transfer NC-specific FSMO roles to other DSA.
        draGiveAwayFsmoRoles(pTHS, pNC, pszOtherDSADNSName, pOtherDSADN);

        // Disable further originating writes and inbound replication of
        // this NC (on this DSA).
        // BUGBUG - jeffparh - TODO

        // Complete any pending link cleanup tasks -- e.g., touching the
        // membership of pre-existing groups that have been switched to
        // universal groups.  This is necessary in this specific case to
        // ensure that GCs quiesce to a consistent state (i.e., by
        // appropriately adding the membership of the now-universal
        // group).
        draCompletePendingLinkCleanup(pTHS);

        // Replicate off any local changes to other DSA.
        draReplicateOffChanges(pTHS, pNC, pszOtherDSADNSName, pOtherDSADN);

        if (DRS_NO_SOURCE & ulOptions) {
            // Schedule asynchronous removal of the NC from the DS (if this is
            // not a full DC demotion).
            err = DirReplicaDelete(pNC,
                                   NULL,
                                   DRS_REF_OK | DRS_NO_SOURCE | DRS_ASYNC_REP);
            if (err) {
                DRA_EXCEPT(err, 0);
            }
        }
    } __except(GetDraException(GetExceptionInformation(), &err)) {
        ;
    }

    return err;
}


BOOL
draIsCompletionOfDemoteFsmoTransfer(
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn    OPTIONAL
    )
/*++

Routine Description:

    Detects whether the caller is involved in completing a FSMO transfer that's
    being performed as part of DC (not just NC) demotion.  Since as a rule
    writes are disabled during DC demotion (even replicator writes), the caller
    uses this information to determine whether he can bypass write restrictions.
    Without bypassing write restrictions, he would generate a
    DRA_EXCEPT(DRAERR_Busy, 0) when calling BeginDraTransaction.

    The sequence of events is:

    DC1   ntdsetup!NtdsPrepareForDemotion
        * ntdsetup!NtdspDisableDs <- disables further writes
          ntdsa!DirReplicaDemote(pNC, DC2)
          ntdsa!draGiveAwayFsmoRoles(pNC, DC2)
          ntdsa!GiveawayAllFsmoRoles(pNC, DC2)
          ntdsa!ReqFsmoOpAux(pFSMO, FSMO_ABANDON_ROLE, DC2)
          ntdsa!I_DRSGetNCChanges(DC2, {DC1, pFSMO, FSMO_ABANDON_ROLE})

    DC2   ntdsa!IDL_DRSGetNCChanges({DC1, pFSMO, FSMO_ABANDON_ROLE})
          ntdsa!DoFSMOOp({DC1, pFSMO, FSMO_ABANDON_ROLE})
          ntdsa!GenericBecomeMaster(pFSMO)
          ntdsa!ReqFsmoOpAux(pFSMO, FSMO_REQ_ROLE, DC1)
          ntdsa!I_DRSGetNCChanges(DC1, {DC2, pFSMO, FSMO_REQ_ROLE})

    DC1   ntdsa!IDL_DRSGetNCChanges({DC2, pFSMO, FSMO_REQ_ROLE})
          ntdsa!DoFSMOOp({DC2, pFSMO, FSMO_REQ_ROLE})
        * ntdsa!draIsCompletionOfDemoteFsmoTransfer({DC2, pFSMO, FSMO_REQ_ROLE})
        * ntdsa!BeginDraTransaction(SYNC_WRITE, TRUE) <- okay to bypass chk
          ntdsa!FSMORoleTransfer(pFSMO, DC2)
          return from ntdsa!IDL_DRSGetNCChanges

    DC2   return from ntdsa!IDL_DRSGetNCChanges

    DC1 * ntdsa!draIsCompletionOfDemoteFsmoTransfer(NULL)
        * ntdsa!BeginDraTransaction(SYNC_WRITE, TRUE) <- okay to bypass chk
          return from ntdsa!draGiveAwayFsmoRoles
          ...

Arguments:

    pMsgIn (IN, OPTIONAL) - If present, indicates DC1 is (possibly) fulfilling
        DC2's FSMO_REQ_ROLE request.  If not present, indicates DC1 is
        (possibly) writing the updates returned from the completed
        FSMO_ABANDON_ROLE request.

Return Values:

    TRUE - This is the completion of the DC demote FSMO transfer and therefore
        the value of ntdsa!gUpdatesEnabled can be ignored.

    FALSE - Otherwise, in which case ntdsa!gUpdatesEnabled should be adhered to.

--*/
{
    DRS_DEMOTE_INFO * pDemoteInfo = gpDemoteInfo;
    BOOL fIsCompletionOfDemoteFsmoTransfer = FALSE;

    if (// Performing DC demotion.
        !gUpdatesEnabled
        && (NULL != pDemoteInfo)
        && ((// Writing new role owner value so we can send back to new owner.
             (NULL != pMsgIn)
             && (FSMO_REQ_ROLE == pMsgIn->ulExtendedOp)
             && (0 == memcmp(&pDemoteInfo->DsaObjGuid,
                             &pMsgIn->uuidDsaObjDest,
                             sizeof(GUID))))
            || (// Applying updates in reply from new owner.
                (NULL == pMsgIn)
                && (pDemoteInfo->tidDemoteThread == GetCurrentThreadId())))) {
        fIsCompletionOfDemoteFsmoTransfer = TRUE;
    }

    return fIsCompletionOfDemoteFsmoTransfer;
}


///////////////////////////////////////////////////////////////////////////////
//
//  LOCAL FUNCTION IMPLEMENTATIONS
//


DWORD
draGetDSADNFromDNSName(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszDNSName,
    OUT DSNAME ** ppDSADN
    )
/*++

Routine Description:

    Convert a DSA DNS name (such as that returned by the locator) into a DSA
    DN.  Goes off machine as an LDAP client to read the DSA's rootDSE (similar
    to invoking the locator).

    An alternate implementation would be to search for all server objects
    in the config NC that have this DNS name as their ATT_DNS_HOST_NAME, then
    find the first one that has a live ntdsDsa child.  However, we're about
    to go contact this machine anyway (to transfer FSMO roles and force
    replication), so it doesn't really make much difference.

Arguments:

    pszDNSName (IN) - DNS name of the remote DSA.

    ppDSADN (OUT) - On successful return, the corresponding ntdsDsa DN.

Return Values:

    0 or Win32 error.

--*/
{
#define SZRAWUUID_LEN (2 * sizeof(GUID)) // 2 hex characters per byte

    LPWSTR rgpszAttrsToRead[] = {
        LDAP_OPATT_DS_SERVICE_NAME_W,
        NULL
    };

    LDAPControlW ExtendedDNCtrl = {
        LDAP_SERVER_EXTENDED_DN_OID_W, {0, NULL}, TRUE // isCritical
    };

    LDAPControlW * rgpServerCtrls[] = {
        &ExtendedDNCtrl,
        NULL
    };

    LDAP_TIMEVAL tvTimeout = {2 * 60, 0}; // 2 minutes (possible dial-on-demand)

    LDAP * hld = NULL;
    LDAPMessage * pResults = NULL;
    LDAPMessage * pEntry = NULL;
    DWORD err = 0;
    int ldErr;
    LPWSTR * ppszDsServiceName;
    WCHAR szGuid[1 + SZRAWUUID_LEN];
    BYTE rgbGuid[sizeof(GUID)];
    DWORD ib;
    WCHAR szHexByte[3] = {0};
    GUID guidDsaObj;
    ULONG ulOptions;
    DSNAME * pGuidOnlyDN = (DSNAME *) THAllocEx(pTHS,DSNameSizeFromLen(0));

    *ppDSADN = NULL;
    Assert(!pTHS->fSyncSet);

    __try {
        if ((L'\\' == pszDNSName[0]) && (L'\\' == pszDNSName[1])) {
            // Skip '\\' prefix -- ldap_initW doesn't like it.
            pszDNSName += 2;
        }

        hld = ldap_initW(pszDNSName, LDAP_PORT);
        if (!hld) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT2(0, "ldap_initW to %ls failed, error %d.\n", pszDNSName, err);
            __leave;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        ldErr = ldap_search_ext_sW(hld, NULL, LDAP_SCOPE_BASE,
                                   L"(objectClass=*)", rgpszAttrsToRead, 0,
                                   rgpServerCtrls, NULL, &tvTimeout,
                                   LDAP_NO_LIMIT, &pResults);
        if (ldErr) {
            err = LdapMapErrorToWin32(ldErr);
            Assert(err);
            DPRINT3(0, "ldap_search of %ls failed, error %d (LDAP error %d).\n",
                    pszDNSName, err, ldErr);
            __leave;
        }

        pEntry = ldap_first_entry(hld, pResults);
        if (NULL == pEntry) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT2(0, "ldap_first_entry failed, error %d.\n", pszDNSName, err);
            __leave;
        }

        ppszDsServiceName = ldap_get_valuesW(hld, pEntry,
                                             LDAP_OPATT_DS_SERVICE_NAME_W);
        if (NULL == ppszDsServiceName) {
            err = LdapGetLastError();
            Assert(err);
            DPRINT1(0, "ldap_get_values failed, error %d.\n", err);
            __leave;
        }

        Assert(1 == ldap_count_valuesW(ppszDsServiceName));

        if ((NULL == ppszDsServiceName[0])
            || (0 != wcsncmp(ppszDsServiceName[0], L"<GUID=", 6))
            || (wcslen(ppszDsServiceName[0] + 6) < SZRAWUUID_LEN)
            || (L'>' != ppszDsServiceName[0][6+SZRAWUUID_LEN])) {
            // DN didn't come back in the format we expected.
            err = ERROR_DS_INVALID_DN_SYNTAX;
            DPRINT1(0, "Unexpected syntax for DN.\n", err);
            __leave;
        }

        wcsncpy(szGuid, ppszDsServiceName[0] + 6, SZRAWUUID_LEN);
        szGuid[SZRAWUUID_LEN] = 0;

        // Decode hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
        for (ib = 0; ib < sizeof(GUID); ib++) {
            szHexByte[0] = towlower(szGuid[2*ib]);
            szHexByte[1] = towlower(szGuid[2*ib + 1]);
            if (iswxdigit(szHexByte[0]) && iswxdigit(szHexByte[1])) {
                rgbGuid[ib] = (BYTE) wcstol(szHexByte, NULL, 16);
            }
            else {
                // DN didn't come back in the format we expected.
                err = ERROR_DS_INVALID_DN_SYNTAX;
                DPRINT2(0, "Unexpected syntax for guid '%ls'.\n", szGuid, err);
                __leave;
            }
        }

        // Get the local string DN for this object, which may be different from
        // the remote string DN due to replication latency.
        pGuidOnlyDN->structLen = DSNameSizeFromLen(0);
        pGuidOnlyDN->NameLen = 0;
        memcpy(&pGuidOnlyDN->Guid, rgbGuid, sizeof(GUID));

        SyncTransSet(SYNC_WRITE);

        __try {
            err = DBFindDSName(pTHS->pDB, pGuidOnlyDN);
            if (err) {
                DPRINT2(0, "Unable to find DSA object with guid %ls, error %d.\n",
                        szGuid, err);
                err = ERROR_DS_CANT_FIND_DSA_OBJ;
                __leave;
            }

            *ppDSADN = GetExtDSName(pTHS->pDB);
            if (NULL == *ppDSADN) {
                err = ERROR_DS_DRA_DB_ERROR;
                __leave;
            }
        } __finally {
            SyncTransEnd(pTHS, !AbnormalTermination());
        }
    } __finally {
        if (NULL != pResults) {
            ldap_msgfree(pResults);
        }

        if (NULL != hld) {
            ldap_unbind(hld);
        }

        THFreeEx(pTHS,pGuidOnlyDN);
    }

    if (!err && (NULL == *ppDSADN)) {
        Assert(!"Logic error!");
        err = ERROR_DS_UNKNOWN_ERROR;
    }

    return err;
}

void
draGiveAwayFsmoRoles(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    )
/*++

Routine Description:

    Invoke the appropriate DS operational control to tranfer FSMO roles held by
    the local DSA for pNC to pOtherDSADN.

    Adapted from ntdsetup!NtdspGetRidOfAllFSMOs.

Arguments:

    pTHS (IN)

    pNC (IN) - NC for which to give up FSMO roles.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pOtherDSADN (IN) - DN of ntdsDsa object for DSA to transfer FSMO roles to.

Return Values:

    None.  Throws exception on failure.

--*/
{
    DWORD err;
    DWORD dirErr;
    OPARG OpArg = {0};
    OPRES *pOpRes = NULL;
    DWORD cbFsmoData;
    FSMO_GIVEAWAY_DATA *pFsmoData = NULL;
    LPWSTR psz;
    DRS_DEMOTE_INFO * pDemoteInfo;

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES,
                                   pNC->StringName,
                                   pszOtherDSADNSName);

    pDemoteInfo = malloc(sizeof(*pDemoteInfo));
    if (NULL == pDemoteInfo) {
        DRA_EXCEPT(DRAERR_OutOfMem, sizeof(*pDemoteInfo));
    }

    __try {
        pDemoteInfo->DsaObjGuid = pOtherDSADN->Guid;
        pDemoteInfo->tidDemoteThread = GetCurrentThreadId();
        gpDemoteInfo = pDemoteInfo;

        cbFsmoData = offsetof(FSMO_GIVEAWAY_DATA, V2)
                     + offsetof(FSMO_GIVEAWAY_DATA_V2, Strings)
                     + (pOtherDSADN->NameLen + 1) * sizeof(WCHAR)
                     + (pNC->NameLen + 1) * sizeof(WCHAR);
        pFsmoData = THAllocEx(pTHS, cbFsmoData);

        pFsmoData->Version = 2;

        if (NameMatched(gAnchor.pDMD, pNC)
            || NameMatched(gAnchor.pConfigDN, pNC)) {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_ENTERPRISE;
        } else if (NameMatched(gAnchor.pDomainDN, pNC)) {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_DOMAIN;
        } else {
            pFsmoData->V2.Flags = FSMO_GIVEAWAY_NONDOMAIN;
        }

        psz = pFsmoData->V2.Strings;

        // Copy DSA name.
        pFsmoData->V2.NameLen = pOtherDSADN->NameLen;
        memcpy(psz, pOtherDSADN->StringName, sizeof(WCHAR) * pOtherDSADN->NameLen);
        // Already null-terminated by virtue of THAlloc().
        psz += 1 + pOtherDSADN->NameLen;

        // Copy NC name.
        pFsmoData->V2.NCLen = pNC->NameLen;
        memcpy(psz, pNC->StringName, sizeof(WCHAR) * pNC->NameLen);
        // Already null-terminated by virtue of THAlloc().

        OpArg.eOp = OP_CTRL_FSMO_GIVEAWAY;
        OpArg.pBuf = (BYTE *) pFsmoData;
        OpArg.cbBuf = cbFsmoData;

        dirErr = DirOperationControl(&OpArg, &pOpRes);
    } __finally {
        gpDemoteInfo = NULL;
        DELAYED_FREE(pDemoteInfo);
    }

    err = DirErrorToWinError(dirErr, &pOpRes->CommRes);
    if (err) {
        DRA_EXCEPT(err, 0);
    }

    
    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES_COMPELETE,
                                   pNC->StringName,
                                   pszOtherDSADNSName);
    

    THFreeEx(pTHS, pFsmoData);
    THFreeEx(pTHS, pOpRes);
}


void
draCompletePendingLinkCleanup(
    IN  THSTATE *   pTHS
    )
/*++

Routine Description:

    Force a run of the link cleaner to complete any pending link cleanup tasks.

Parameters:

    pTHS (IN)

Return Values:

    None.  Throws exception on failure.

--*/
{
    DRA_REPORT_STATUS_TO_NTDSETUP0(DIRMSG_DEMOTE_NC_COMPLETING_LINK_CLEANUP);

#ifdef LATER
    DWORD err;
    DWORD dirErr;
    OPARG OpArg = {0};
    OPRES *pOpRes = NULL;
    DWORD LinkCleanupData = 0;

    OpArg.eOp = OP_CTRL_LINK_CLEANUP;
    OpArg.pBuf = (BYTE *) &LinkCleanupData;
    OpArg.cbBuf = sizeof(LinkCleanupData);

    do {
        dirErr = DirOperationControl(&OpArg, &pOpRes);

        err = DirErrorToWinError(dirErr, &pOpRes->CommRes);
        if (err) {
            DRA_EXCEPT(err, 0);
        }

        err = pOpRes->ulExtendedRet;
        THFreeEx(pTHS, pOpRes);
        pOpRes = NULL;
    } while (!err);

    // Link cleanup completed successfully!
    Assert(ERROR_NO_MORE_ITEMS == err);
#else
    ;
#endif
}


void
draReplicateOffChanges(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN
    )
/*++

Routine Description:

    Ensure pszOtherDSAAddr has all updates in pNC that we have (be they
    originated or replicated).

Parameters:

    pTHS (IN)

    pNC (IN) - NC to sync.

    pszOtherDSADNSName (IN) - DNS name of DSA to transfer FSMO roles to.  Used
        for display purposes only -- replication still uses the GUID-based DNS
        name.

    pszOtherDSAAddr (IN) - DNS name (GUID-based or otherwise) of DSA to push
        changes to.

Return Values:

    None.  Throws exception on failure.

--*/
{
    DWORD err;
    LPWSTR pszOtherDSAAddr = NULL;
    LPWSTR pszOurGuidDNSName;

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES,
                                   pNC->StringName,
                                   pszOtherDSADNSName);

    // Get network address of the other DSA.
    pszOtherDSAAddr = DSaddrFromName(pTHS, pOtherDSADN);
    if (NULL == pszOtherDSAAddr) {
        DRA_EXCEPT(DRAERR_OutOfMem, 0);
    }

    // Tell pszOtherDSAAddr to get changes from us.
    err = I_DRSReplicaSync(pTHS, pszOtherDSAAddr, pNC, NULL,
                           &gAnchor.pDSADN->Guid, DRS_WRIT_REP);

    if (ERROR_DS_DRA_NO_REPLICA == err) {
        // pszOtherDSAAddr does not currently have a replication agreement
        // (repsFrom) for us -- tell it to add one.

        pszOurGuidDNSName = TransportAddrFromMtxAddrEx(gAnchor.pmtxDSA);

        err = I_DRSReplicaAdd(pTHS, pszOtherDSAAddr, pNC, NULL, NULL,
                              pszOurGuidDNSName, NULL, DRS_WRIT_REP);
        if (err) {
            DRA_EXCEPT(err, 0);
        }

        THFreeEx(pTHS, pszOurGuidDNSName);
    } else if (err) {
        // Sync failed with an error other than ERROR_DS_DRA_NO_REPLICA.
        DRA_EXCEPT(err, 0);
    }

    // Sync or add completed successfully!

    DRA_REPORT_STATUS_TO_NTDSETUP2(DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES_COMPELETE,
                                   pNC->StringName,
                                   pszOtherDSADNSName);
    

    THFreeEx(pTHS, pszOtherDSAAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dragtchg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dragtchg.c
//
//--------------------------------------------------------------------------
/*++

ABSTRACT:

    Outbound replication methods.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dstrace.h>
// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsconfig.h"                   // Registry sections

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <filtypes.h>
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAGTCHG:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drametap.h"
#include "drasch.h"
#include "drancrep.h" // For RenameLocalObject

// RID Manager header.
#include <samsrvp.h>
#include <ridmgr.h>                     // RID FSMO access in SAM

// Cross domain move.
#include <xdommove.h>

// Jet functions
#include <dsjet.h>

#include <fileno.h>
#define  FILENO FILENO_DRAGTCHG

// Bogus encoding buffer to satisfy the RPC encoding library.  The contents will
// never be used, so we don't have to worry about multiple threads accessing it
// concurrently.
BYTE grgbFauxEncodingBuffer[16];

// Maximum number of milliseconds we should spend in a single DRA_GetNCChanges
// call looking for objects to ship.
const ULONG gulDraMaxTicksForGetChanges = 60 * 1000;

// Forward declarations.

ULONG AcquireRidFsmoLock(DSNAME *pDomainDN, int msToWait);
VOID  ReleaseRidFsmoLock(DSNAME *pDomainDN);
BOOL  IsRidFsmoLockHeldByMe();

void FSMORegisterObj(THSTATE *pTHS, HANDLE hRetList, DSNAME * pObj);
ULONG GetSchemaRoleObjectsToShip(DSNAME *pFSMO,
                           USN_VECTOR *pusnvecFrom,
                           HANDLE hList);
ULONG GetProxyObjects(DSNAME *pDomainDN,
                      HANDLE hList,
                      USN_VECTOR *pusnvecFrom);
ULONG GetDomainRoleTransferObjects(THSTATE *pTHS,
                                   HANDLE hList,
                                   USN_VECTOR *pusnvecFrom);

void
AddAnyUpdatesToOutputList(
    IN      DBPOS *                     pDB,
    IN      DWORD                       dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR        pSecurity,
    IN      ULONG                       dntNC,
    IN      USN                         usnHighPropUpdateDest,
    IN      PARTIAL_ATTR_VECTOR *       pPartialAttrVec,
    IN      DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,
    IN      handle_t                    hEncoding,              OPTIONAL
    IN OUT  DWORD *                     pcbTotalOutSize,        OPTIONAL
    IN OUT  DWORD *                     pcNumOutputObjects,
    IN OUT  DNT_HASH_ENTRY *            pDntHashTable,
    IN OUT  REPLENTINFLIST ***          pppEntInfListNext
    );

void
AddAnyValuesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      USN                             usnHighPropUpdateDest,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,
    IN OUT  ULONG *                         pcAllocatedValues,
    IN OUT  ULONG *                         pcNumValues,
    IN OUT  REPLVALINF **                   ppValues
    );



/* AddToList - Add the current object (pTHStls->pDB) to the results list. The
*       current position in the results list is given by ppEntInfList, 'pSel'
*       specifies which attributes are wanted.
*
*  Notes:
*       This routine returns DSA type error codes not suitable for returning
*       from DRA APIs.
*
*  Returns:
*       BOOL - whether an entry was added
*/
BOOL
AddToList(
    IN  DBPOS                     * pDB,
    IN  DWORD                       dwDirSyncControlFlags,
    IN  PSECURITY_DESCRIPTOR        pSecurity,
    IN  ENTINFSEL *                 pSel,
    IN  PROPERTY_META_DATA_VECTOR * pMetaData,
    IN  BOOL                        fIsNCPrefix,
    OUT REPLENTINFLIST **           ppEntInfList
    )
{
    REPLENTINFLIST *pEntInfList;
    PROPERTY_META_DATA_EXT_VECTOR *pMetaDataExt = NULL;
    DWORD err, dwGetEntInfFlags = 0, dwSecurityFlags = 0;
    RANGEINFSEL *pSelRange = NULL;
    RANGEINFSEL selRange;
    RANGEINF *pRange = NULL;
    RANGEINF range;
    BOOL fUseRangeToLimitValues =
        ( (dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY) &&
          (!(dwDirSyncControlFlags & DRS_DIRSYNC_INCREMENTAL_VALUES)) );
    BOOL fResult = TRUE;

    if (fUseRangeToLimitValues) {
        memset( &selRange, 0, sizeof( selRange ) );
        // Limit any attribute to return no more than 5000 values
        selRange.valueLimit = 5000;
        pSelRange = &selRange;

        // GetEntInf requires an output range structure
        memset( &range, 0, sizeof( range ) );
        pRange = &range;
        // After the call, pRange->pRange points to a range info item
    }

    if (dwDirSyncControlFlags & DRS_DIRSYNC_OBJECT_SECURITY) {
        Assert( pSecurity );  // Should already have one

        dwSecurityFlags = (SACL_SECURITY_INFORMATION  |
                           OWNER_SECURITY_INFORMATION |
                           GROUP_SECURITY_INFORMATION |
                           DACL_SECURITY_INFORMATION  );
    } else {
        Assert( !pSecurity );  // Should not have one
        dwGetEntInfFlags = GETENTINF_NO_SECURITY;
    }

    pEntInfList = THAllocEx(pDB->pTHS, sizeof(REPLENTINFLIST));

    err = GetEntInf(pDB,
                    pSel,
                    pSelRange,
                    &(pEntInfList->Entinf),
                    pRange,
                    dwSecurityFlags,
                    pSecurity,
                    dwGetEntInfFlags,
                    NULL,
                    NULL);
    if (err) {
        DPRINT(2,"Error in getting object info\n");
        DRA_EXCEPT(DRAERR_DBError, err);
    }
    else if ( pEntInfList->Entinf.AttrBlock.attrCount ) {
        DPRINT1(2, "Object retrieved (%S)\n",
                pEntInfList->Entinf.pName->StringName);

        // If this is the NC prefix, mark it as such in the data to ship.
        pEntInfList->fIsNCPrefix = fIsNCPrefix;

        // Build remaining data to ship in pEntInfList.
        ReplPrepareDataToShip(
            pDB->pTHS,
            pSel,
            pMetaData,
            pEntInfList
            );

        *ppEntInfList = pEntInfList;
    } else {
        fResult = FALSE;
        THFreeEx( pDB->pTHS, pEntInfList );
    }

    return fResult;
}

//
// AddToOutputList
//
// Adds the selection to the output list and increments the count.
//

void
AddToOutputList (
    IN      DBPOS                     * pDB,
    IN      DWORD                       dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR        pSecurity,
    IN      ENTINFSEL *                 pSel,
    IN      PROPERTY_META_DATA_VECTOR * pMetaData,
    IN      BOOL                        fIsNCPrefix,
    IN      handle_t                    hEncoding,          OPTIONAL
    IN OUT  ULONG *                     pcbTotalOutSize,    OPTIONAL
    IN OUT  REPLENTINFLIST ***          pppEntInfListNext,
    IN OUT  ULONG *                     pcEntries
    )
{
    BOOL fEntryWasAdded;

    fEntryWasAdded = AddToList(pDB,
                               dwDirSyncControlFlags,
                               pSecurity,
                               pSel,
                               pMetaData,
                               fIsNCPrefix,
                               *pppEntInfListNext);

    if (fEntryWasAdded) {
        // Update count and continuation ref.
        (*pcEntries)++;

        if ((NULL != hEncoding) && (NULL != pcbTotalOutSize)) {
            // Update byte count of return message.
            *pcbTotalOutSize += REPLENTINFLIST_AlignSize(hEncoding,
                                                         **pppEntInfListNext);
        }

        *pppEntInfListNext = &((**pppEntInfListNext)->pNextEntInf);
        **pppEntInfListNext = NULL;
    }
}


ULONG
FSMORidRequest(
    IN THSTATE *pTHS,
    IN DSNAME *pFSMO,
    IN DSNAME *pReqDsa,
    IN ULARGE_INTEGER *pliClientAllocPool,
    OUT HANDLE  pList
    )
/*++

Routine Description:

    This routine calls into SAM to allocate a rid pool for pReqDsa.  The rid
    pool is updated on pReqDsa's rid object on the attribute AllocatedPool.
    Both the computer object and the rid object are returned in pList.

Parameters:

    pFSMO:  the dsname of the FSMO

    pReqDsa: the dsname of the request dsa (ntdsa object)

    pliClientAllocPool: the client's notion of what its alloc'ed pool is

    pList: objects to ship back to pReqDsa


Return Values:

    An error from the FSMO_ERR space


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG err = 0;
    ULONG FsmoStatus = FSMO_ERR_SUCCESS;

    ULONG cbRet = 0;
    DBPOS *pDB;

    DSNAME *pRoleOwner = NULL;
    DSNAME *pRidManager = NULL;
    DSNAME **ObjectsToReturn = NULL;
    BOOL    fSaveDRA = FALSE;
    ULONG   i;

    //
    // Parameter check
    //
    Assert( pFSMO );
    Assert( pReqDsa );
    Assert( pList );

    //
    // N.B. Access check done in RPC server side stub for REPL_GET_NC_CHANGES
    //

    BeginDraTransaction( SYNC_READ_ONLY );
    try
    {
        pDB = pTHS->pDB;

        //
        // Though, we are passed in the dsname of the rid manager object,
        // double check this is the object we think is the rid manager object
        //
        err = DBFindDSName(pDB, gAnchor.pDomainDN);
        if ( 0 == err )
        {
            DPRINT1( 0, "DSA: FSMO Domain = %ws\n", gAnchor.pDomainDN->StringName );

            err = DBGetAttVal(pDB,
                              1,
                              ATT_RID_MANAGER_REFERENCE,
                              0,
                              0,
                              &cbRet,
                              (UCHAR **)&pRidManager);
        }

        if ( 0 != err )
        {
            FsmoStatus = FSMO_ERR_UPDATE_ERR;
            goto Cleanup;
        }

        DPRINT1( 1, "DSA: FSMO RID Mgr = %ws\n", pRidManager->StringName );
        if ( !NameMatched( pFSMO, pRidManager ) )
        {
            //
            // There is a mismatch of rid manager objects - refuse the request
            //
            DPRINT2( 1, "DSA: Rid manager mismatch.  Slave: %ws ; Master %ws",
                    pFSMO->StringName, pRidManager->StringName );
            FsmoStatus = FSMO_ERR_MISMATCH;
        }

    }
    _finally
    {
        EndDraTransaction( TRUE );
    }


    //
    // We aren't really the dra agent.  This flag can cause unwanted errors
    //
    fSaveDRA = pTHS->fDRA;
    pTHS->fDRA = FALSE;

    //
    // Now perform the operation
    //

    NtStatus = SamIFloatingSingleMasterOpEx(pFSMO,
                                            pReqDsa,
                                            SAMP_REQUEST_RID_POOL,
                                            pliClientAllocPool,
                                            &ObjectsToReturn );

    pTHS->fDRA = fSaveDRA;

    if ( !NT_SUCCESS(NtStatus) )
    {
        DPRINT1( 0, "DSA: SamIFloatingSingleMasterOp status = 0x%lx\n",
                 NtStatus );

        if ( NtStatus == STATUS_NO_MORE_RIDS )
        {
            FsmoStatus =  FSMO_ERR_RID_ALLOC;
        }
        else if ( NtStatus == STATUS_INVALID_OWNER )
        {
            FsmoStatus =  FSMO_ERR_NOT_OWNER;
        }
        else
        {
            //
            // This must have been a resource err
            //
            FsmoStatus = FSMO_ERR_UPDATE_ERR;
        }

        goto Cleanup;
    }
    Assert( ObjectsToReturn );

    //
    // Replicate back the objects modified
    //
    for (i = 0; NULL != ObjectsToReturn[i]; i++)
    {
        FSMORegisterObj(pTHS, pList, ObjectsToReturn[i] );
    }

Cleanup:

    return( FsmoStatus );

}


typedef struct _FSMOlist {
    DSNAME * pObj;
    struct _FSMOlist *pNext;
} FSMOlist;
/*++ FSMORegisterObj
 *
 * A routine called by FSMO server-side worker code that identifies an
 * object as one to be returned by the FSMO operation.  Note that the
 * object name is only added to the list if it is not already present.
 * The objects added into this list will be freed automatically.
 *
 * INPUT:
 *  pObj - pointer to DSNAME of object to be added to return list
 *  hRetList - handle to list
 * OUTPUT:
 *  none
 * RETURN VALUE:
 *  none
 */
void FSMORegisterObj(THSTATE *pTHS,
                     HANDLE hRetList,
                     DSNAME * pObj)
{
    FSMOlist * pList;

    Assert(hRetList && pObj);

    pList = (FSMOlist *) hRetList;
    while (pList->pNext && !NameMatched(pObj, pList->pObj)) {
        pList = pList->pNext;
    }
    if (!NameMatched(pObj, pList->pObj)) {
        Assert(pList->pNext == NULL);
        pList->pNext = THAllocEx(pTHS, sizeof(FSMOlist));
        pList->pNext->pNext = NULL;
        pList->pNext->pObj = pObj;
    }
}

/*++ FSMORoleTransfer
 *
 * Scaffold Role-Owner transfer.  Code to handle pre- or post-processing
 * (e.g, determining desirability of transfer, or sending notification)
 * can be done by testing the name of the object in either the pre- or post-
 * testing branch.
 *
 * INPUT:
 *  pFSMO - name of FSMO object
 *  pReqDSName - name of requesting DS
 *  usnvecFrom - usn vector sent from client
 *  hList - handle to output list
 * OUTPUT:
 *  none
 * RETURN VALUE:
 *  FSMO_ERR_xxx return code
 */
ULONG FSMORoleTransfer(DSNAME * pFSMO,
                       DSNAME * pReqDSName,
                       USN_VECTOR *pusnvecFrom,
                       HANDLE   hList)
{
    THSTATE *pTHS = pTHStls;
    ULONG err;
    DSNAME * pDN;
    ULONG cbRet;
    DBPOS * const pDB = pTHS->pDB;
    MODIFYARG ModArg;
    MODIFYRES ModRes;
    ATTRVAL AVal;

    err = DBFindDSName(pDB, pFSMO);
    if (err) {
        return FSMO_ERR_UPDATE_ERR;
    }

    // Find the current owner of this role
    err = DBGetAttVal(pDB,
                      1,
                      ATT_FSMO_ROLE_OWNER,
                      0,
                      0,
                      &cbRet,
                      (UCHAR **)&pDN);
    if (err) {
        return FSMO_ERR_UPDATE_ERR;
    }

    if (!NameMatched(pDN, gAnchor.pDSADN)
        || !IsFSMOSelfOwnershipValid( pFSMO )) {
        // If this DSA isn't the owner, fail
        THFreeEx(pTHS, pDN);
        return FSMO_ERR_NOT_OWNER;
    }

    /******/
    /* Any object specific pre-processing of the change (e.g, determination
     * as to whether or not we should transfer the role) should be done here.
     */
    // SCHEMA FSMO pre-processing
    if (   NameMatched(pFSMO, gAnchor.pDMD)
        && !SCExpiredSchemaFsmoLease()) {
        THFreeEx(pTHS, pDN);
        return(FSMO_ERR_PENDING_OP);
    }

    // RID FSMO pre-processing
    DBFindDSName(pDB, gAnchor.pDomainDN);
    DBGetAttVal(pDB,
                1,
                ATT_RID_MANAGER_REFERENCE,
                DBGETATTVAL_fREALLOC,
                cbRet,
                &cbRet,
                (UCHAR **)&pDN);
    if ( NameMatched(pFSMO, pDN) ) {
        // Acquire the RID FSMO lock so as to insure exclusion with respect
        // to cross domain moves.  See CheckRidOwnership in mdmoddn.c.
        // Only one domain per DC in product 1, so know which domain to use.
        if ( AcquireRidFsmoLock(gAnchor.pDomainDN, 1000) ) {
            THFreeEx(pTHS, pDN);
            return(FSMO_ERR_PENDING_OP);
        }
    }

    // Perform everything else within try/finally so we are guaranteed
    // to release the RID FSMO lock if we are holding it.

    _try {
        if ( IsRidFsmoLockHeldByMe() ) {
            // Fill hlist with all the proxy objects as these
            // move with RID FSMO.  Only one domain per DC in
            // product 1, so know which domain to use.
            if ( GetProxyObjects(gAnchor.pDomainDN, hList, pusnvecFrom) ) {
                THFreeEx(pTHS, pDN);
                return(FSMO_ERR_EXCEPTION);
            }
        }

        if ( NameMatched(pFSMO, gAnchor.pPartitionsDN) ) {
            if (GetDomainRoleTransferObjects(pTHS,
                                             hList,
                                             pusnvecFrom)) {
                THFreeEx(pTHS, pDN);
                return(FSMO_ERR_EXCEPTION);
            }
        }

        THFreeEx(pTHS, pDN);
        pDN = NULL;
        cbRet = 0;
        /*** End of preprocessing ***/

        /* Ok, we can go ahead and change the owner, but we need to do it via
         * normal calls so that meta-data gets set correctly.
         */

        ZeroMemory(&ModArg, sizeof(ModArg));
        ZeroMemory(&ModRes, sizeof(ModRes));

        ModArg.pObject = pFSMO;
        ModArg.count = 1;
        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        ModArg.FirstMod.AttrInf.attrTyp = ATT_FSMO_ROLE_OWNER;
        ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
        AVal.valLen = pReqDSName->structLen;
        AVal.pVal = (UCHAR*)pReqDSName;
        InitCommarg(&ModArg.CommArg);

        pTHS->fDRA = FALSE;
        pTHS->fDSA = TRUE;
        DoNameRes(pTHS,
                  0,
                  ModArg.pObject,
                  &ModArg.CommArg,
                  &ModRes.CommRes,
                  &ModArg.pResObj);
        if (0 == pTHS->errCode) {
            err = LocalModify(pTHS, &ModArg);
        }
        pTHS->fDRA = TRUE;
        pTHS->fDSA = FALSE;

        if (pTHS->errCode) {
            return FSMO_ERR_UPDATE_ERR;
        }

        /* Note that we don't have to register the object, because the
         * FSMO object itself is pre-registered.
         */

        /*** This is where role-transfer post-processing goes, which consists
          *  largely of identifying objects that must be transferred when
          *  transferring the role.
         ***/

        if (NameMatched(pFSMO, gAnchor.pDMD)) {
            /* If this is a schema master change operation, return all
             * schema objects along with the role transfer
             * PERFHINT: This code enumerates all schema objects that we
             * might need to transfer via direct usn comparison, but that
             * will erroneously include ones which have already replicated from
             * here to the destination indirectly (via a third DSA).  Those
             * extra objects will be filtered out before being transmitted,
             * but it would have been better to not even pick up their names
             * here.  Unfortunately that's hard to do, because it would require
             * fiddling around with replication logic that no one willing to
             * work on FSMO code understands.
             */
            err = GetSchemaRoleObjectsToShip(pFSMO, pusnvecFrom, hList);
        }
        else if (NameMatched(pFSMO, gAnchor.pDomainDN)) {
            // This is the FSMO for PDC-ness in the domain.
            // We must issue a synchronous notification to netlogon, lsa, and
            // SAM that the role has changed.
            if (FSMO_ERR_SUCCESS == err) {
                NTSTATUS IgnoreStatus;
                THSTATE  *pTHSSave;

                // THSave and restore around SamINotifyRoleChange. This is
                // because SamINotifyRoleChange makes LSA calls, which may
                // potentially access the DS database

                pTHSSave = THSave();

                IgnoreStatus = SamINotifyRoleChange(
                                                    &pFSMO->Sid, // domain sid
                                                    DomainServerRoleBackup // new role
                                                    );

                // If the notification failed, we have a problem on our hands, we
                // have already changed our FSMO, and cannot do anything about it.
                // And we cannot do anything to undo it. However the chances of
                // this happening should be extremely rare ( as the notification
                // is an in -memory operation )
                // Therfore just assert that it succeeded.

                THRestore(pTHSSave);

                Assert(NT_SUCCESS(IgnoreStatus));
            }
        }
        /*** End of post-processing ***/
    } _finally {
        if ( IsRidFsmoLockHeldByMe() ) {
            // Only one domain per DC in product 1, so know which domain to use.
            ReleaseRidFsmoLock(gAnchor.pDomainDN);
        }
    }

    if (err) {
        return FSMO_ERR_UPDATE_ERR;
    }

    return FSMO_ERR_SUCCESS;
}

/*++ GetSchemaRoleObjectsToShip
 *
 * Gets all changes in the NC containing the FSMO object
 *
 * INPUT:
 *   pFSMO - FSMO object
 *   usnvecFrom - usn vector used in searching
 *   hList - FSMOList to append to
 *
 * OUTPUT:
 *  0 on success, non-0 on error
*/

ULONG GetSchemaRoleObjectsToShip(DSNAME * pFSMO,
                       USN_VECTOR *pusnvecFrom,
                       HANDLE hList)
{
    ULONG           ret;
    USN             usnChangedSeekStart;
    USN             usnChangedFound;
    ULONG           cbReturned;
    ULONG           count, cObj;
    ULONG           dntNC;
    THSTATE * pTHS = pTHStls;
    FSMOlist *pList = (FSMOlist *) hList, *pTail;
    DSNAME *pNC = NULL, *pObj;

    pTail = pList;

    // Find the NC object, get and save its DNT.
    pNC = FindNCParentDSName(pFSMO, FALSE, FALSE);
    if (pNC == NULL) {
        DPRINT(0,"GetObjectsToShip: FindNCParentDSName failed\n");
        return 1;
    }

    if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL)) {
        DPRINT1(0,"GetObjectsToShip: FindNC failed, err %d\n",ret);
        return 1;
    }

    // Save the DNT of the NC object
    dntNC = pTHS->pDB->DNT;

    // set the seek start to one higher than the watermark
    usnChangedSeekStart = pusnvecFrom->usnHighObjUpdate + 1;

    // Initialize no. of objects. hList already has one element
    // (pMsgIn->pNC added in DoFSMOOp)
    cObj=1;

    // No limit on objects, we want all changes.
    // Note: This code is taken straight from parts of GetNCChanges
    while (TRUE) {
        if (GetNextObjByUsn(pTHS->pDB,
                            dntNC,
                            usnChangedSeekStart,
                            NULL /*nousnfound*/ )) {
            // No more updated items. Set no continuation
            break;
        }

        // Get the USN-Changed from the record.
        if(DBGetSingleValue(pTHS->pDB, ATT_USN_CHANGED, &usnChangedFound,
                   sizeof(usnChangedFound), NULL)) {
            DPRINT(0,"GetObjectsToShip: Error getting usn changed\n");
            return 1;
        }

        // set the search start for the next iteration
        usnChangedSeekStart = usnChangedFound + 1;

        // Get the DSNAME of the object
        if (DBGetAttVal(pTHStls->pDB, 1, ATT_OBJ_DIST_NAME, DBGETATTVAL_fREALLOC,
                0, &cbReturned, (LPBYTE *) &pObj))
        {
            DPRINT(0,"GetObjectsToShip: Error getting obj DSName\n");
            return 1;
        }

        // Add to end of list
        // Duplicates could be added into the list, though rare.
        // It doesn't matter, because the duplicates will be eliminated
        // later when composing the output list.
        Assert(pTail->pNext == NULL);
        pTail->pNext = THAllocEx(pTHS, sizeof(FSMOlist));
        pTail->pNext->pNext = NULL;
        pTail->pNext->pObj = pObj;
        pTail = pTail->pNext;
        cObj++;

    } /* while */

    return 0;
} /* GetSchemaRoleObjectsToShip */



/*++ DoFSMOOp
 *
 * Main server side driver routine that control FSMO operations
 *
 * INPUT:
 *  pTHS - THSTATE
 *  pMsgIn - input request message
 *  pMsgOut - results message
 * OUTPUT:
 *  pMsgOut - filled in
 */
ULONG DoFSMOOp(THSTATE *pTHS,
               DRS_MSG_GETCHGREQ_NATIVE *pMsgIn,
               DRS_MSG_GETCHGREPLY_NATIVE *pMsgOut)
{
    DSNAME ReqDSName, *pReqDSName;
    BOOL fCommit = FALSE;
    ENTINFSEL sel;
    FSMOlist * pList, * pTemp;
    ULONG err;

    DSNAME * pObjName = NULL;
    ULONG cbObjName = 0;
    PROPERTY_META_DATA_VECTOR *pMetaData = NULL;
    ULONG cbMetaData = 0;
    ULONG cbRet;
    SYNTAX_INTEGER itHere;
    ULONG *pitHere = &itHere;
    ULONG len;
    REPLENTINFLIST * pEIListHead = NULL;
    REPLENTINFLIST ** ppEIListNext = &pEIListHead;
    CLASSCACHE *pCC;
    BOOL fNCPrefix;
    DWORD numValues = 0;
    SCHEMA_PREFIX_TABLE * pLocalPrefixTable;
    OPRES OpRes;
    BOOL fBypassUpdatesEnabledCheck = FALSE;
    DNT_HASH_ENTRY * pDntHashTable;
    ULONG   dntNC = INVALIDDNT;
    SYNTAX_INTEGER  it;


    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    Assert(pMsgIn->ulExtendedOp);

    // Read-only destinations not supported -- i.e., we don't filter on the
    // partial attribute set, etc.
    Assert(DRS_WRIT_REP & pMsgIn->ulFlags);

    /* Initialize variables */
    memset(&ReqDSName, 0, sizeof(DSNAME));
    ReqDSName.Guid = pMsgIn->uuidDsaObjDest;
    ReqDSName.structLen = DSNameSizeFromLen(0);
    pMsgOut->pNC = pMsgIn->pNC;
    pMsgOut->uuidDsaObjSrc = gAnchor.pDSADN->Guid;
    pMsgOut->uuidInvocIdSrc = pTHS->InvocationID;
    pMsgOut->PrefixTableSrc = *pLocalPrefixTable;
    memset(&sel, 0, sizeof(sel));
    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = (pMsgIn->ulFlags & DRS_MAIL_REP) ?
      EN_ATTSET_LIST_DRA_EXT : EN_ATTSET_LIST_DRA;
    pMsgOut->fMoreData = FALSE;
    pList = THAllocEx(pTHS, sizeof(*pList));
    pList->pObj = THAllocEx(pTHS,pMsgIn->pNC->structLen);
    memcpy(pList->pObj, pMsgIn->pNC, pMsgIn->pNC->structLen);
    pList->pNext = NULL;
    pMsgOut->ulExtendedRet = FSMO_ERR_EXCEPTION;

    // If updates are disabled, it's okay to generate writes iff we're demoting
    // this DC and this is our demotion partner requesting we complete the FSMO
    // transfer that we initiated as part of the demotion.
    fBypassUpdatesEnabledCheck = draIsCompletionOfDemoteFsmoTransfer(pMsgIn);

    BeginDraTransactionEx(SYNC_WRITE, fBypassUpdatesEnabledCheck);

    __try {
        /* First, let's make sure we recognize the caller, by checking to
         * see that his object is present on this server.
         */
        err = DBFindDSName(pTHS->pDB, &ReqDSName);
        if (err) {
            pMsgOut->ulExtendedRet = FSMO_ERR_UNKNOWN_CALLER;
            __leave;
        }
        err = DBGetAttVal(pTHS->pDB,
                          1,
                          ATT_OBJ_DIST_NAME,
                          0,
                          0,
                          &cbRet,
                          (UCHAR **)&pReqDSName);
        if (err) {
            DRA_EXCEPT(DRAERR_DBError, err);
        }

        switch(pMsgIn->ulExtendedOp) {
          case FSMO_REQ_PDC:    // obsolete
          case FSMO_RID_REQ_ROLE: // obsolete
            //fall through to general case

          case FSMO_REQ_ROLE:
            /* generic role-owner transfer */
            pMsgOut->ulExtendedRet = FSMORoleTransfer(pMsgIn->pNC,
                                                      pReqDSName,
                                                      &pMsgIn->usnvecFrom,
                                                      (HANDLE)pList);
            
            if ( pMsgOut->ulExtendedRet != FSMO_ERR_SUCCESS ) {
                LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_FSMO_XFER_FAILURE,
                          szInsertDN(pMsgIn->pNC),          
                          szInsertDN(gAnchor.pDSADN),        
                          szInsertDN(pReqDSName)           
                          );

            }
            else {
                LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_FSMO_XFER,
                          szInsertDN(pMsgIn->pNC),          
                          szInsertDN(pReqDSName),
                          szInsertDN(gAnchor.pDSADN)
                          );
            }
            break;


          case FSMO_ABANDON_ROLE:
            /* a request to take away a role */
            EndDraTransaction(TRUE);
            pTHS->fDSA = TRUE;
            err = GenericBecomeMaster(pMsgIn->pNC,
                                      0,
                                      gNullUuid,
                                      &OpRes);
            pMsgOut->ulExtendedRet = OpRes.ulExtendedRet;
            BeginDraTransaction(SYNC_READ_ONLY);
            break;

        case FSMO_REQ_RID_ALLOC:

            /* RID pool allocation request */
            EndDraTransaction(TRUE);
            pTHS->fDSA = TRUE;

            pMsgOut->ulExtendedRet = FSMORidRequest(pTHS,
                                                    pMsgIn->pNC,
                                                    pReqDSName,
                                                    &pMsgIn->liFsmoInfo,
                                                    (HANDLE) pList );

            BeginDraTransaction(SYNC_READ_ONLY);

            break;

          default:
            pMsgOut->ulExtendedRet = FSMO_ERR_UNKNOWN_OP;
        }

        switch (pMsgOut->ulExtendedRet) {
          case FSMO_ERR_SUCCESS:
          case FSMO_ERR_NOT_OWNER:
            fCommit = TRUE;
            break;

          default:
            Assert(fCommit == FALSE);
        }
    }
    __finally {

        EndDraTransaction(fCommit);
    }

    Assert(pMsgOut->ulExtendedRet);

    if (!fCommit) {
        /* We didn't want to update our database, so it must have been
         * an error, which means that we should not be proclaiming
         * success to the caller.  Further, we have nothing to pass back.
         */
        Assert(pMsgOut->ulExtendedRet != FSMO_ERR_SUCCESS);
        return 0;
    }

    /* If we've gotten here, we have data to return to our caller,
     * so start a new read transaction and walk down the list of objects
     * to be returned, gathering the correct data from each.
     */

    /* Build a couple auxilliary data structures that let us optimize the
     * set of objects that need to be returned.
     */
    pDntHashTable = dntHashTableAllocate( pTHS );

    /* N.B. A New transaction should be started since additions maybe be
     * stored in the dn cache and when the DBGetAttVal is called the guid
     * maybe be returned.
     */

    BeginDraTransaction(SYNC_READ_ONLY);

    __try {


        do {

            // seek to object
            err = DBFindDSName(pTHS->pDB,pList->pObj);
            if (err) {
                DRA_EXCEPT(DRAERR_DBError, err);
            }

            if ( INVALIDDNT == dntNC ) {
                //
                // Get ncDnt. If the object is the NC head, we'll use its
                // DNT, otherwise use pDB->NCDNT. We find if it is via its
                // instance type.
                //

                if ( (err=GetExistingAtt(
                                pTHS->pDB,
                                ATT_INSTANCE_TYPE,
                                &it,
                                sizeof( it )
                                 ) ) )
                {
                    DRA_EXCEPT(DRAERR_DBError, err);
                }
                dntNC = FExitIt( it )? (pTHS->pDB->DNT): (pTHS->pDB->NCDNT);
            }

            AddAnyUpdatesToOutputList(pTHS->pDB,
                                      0, // dwDirSyncControlFlags
                                      NULL, // No security desc
                                      dntNC,
                                      pMsgIn->usnvecFrom.usnHighPropUpdate,
                                      NULL,
                                      pMsgIn,
                                      NULL,
                                      NULL,
                                      &pMsgOut->cNumObjects,
                                      pDntHashTable,
                                      &ppEIListNext);
            pTemp = pList;
            pList = pList->pNext;
            THFreeEx(pTHS,pTemp->pObj);
            THFreeEx(pTHS,pTemp);
        } while (pList);

        // return created output list
        *ppEIListNext = NULL;
        pMsgOut->pObjects = pEIListHead;

        //no extra values to ship back
        pMsgOut->cNumBytes = 0;
        pMsgOut->rgValues = NULL;
    }
    __finally {
        /* Always commit reads */
        EndDraTransaction(TRUE);
    }
    return 0;
}

//
//  This functions checks if the object
//  referred to by pDB is a univarsal group
//  object and decides whether the group
//  member property should be shipped to the
//  GC or not.
//
//  Returns TRUE if the group member property
//  should filtered; FALSE, otherwise.
//  Throws a DRA exception if there is any DB related
//  failure.
//
BOOL IsFilterGroupMember(DBPOS *pDB, CLASSCACHE *pCC)
{
    SYNTAX_OBJECT_ID    objClass;
    ULONG               ulGroupType;
    BOOL                fFilter = FALSE;

    if (CLASS_GROUP == pCC->ClassId)
    {
        if (DBGetSingleValue(pDB, ATT_GROUP_TYPE, &ulGroupType, sizeof(ulGroupType), NULL))
        {
            if (DBIsObjDeleted(pDB))
            {
                // Okay for ATT_GROUP_TYPE to be absent on tombstones.
                // In this case the membership is absent, too, but we
                // should replicate it out anyway so that the meta data
                // is correct.
                fFilter = FALSE;
            }
            else
            {
                // Object is live; group type must be present.
                DraErrMissingAtt(GetExtDSName(pDB), ATT_GROUP_TYPE);
            }
        }
        else
        {
            // group types are defined in sdk\inc\ntsam.h
            fFilter = !(ulGroupType & GROUP_TYPE_UNIVERSAL_GROUP);
        }
    }

    return fFilter;
}

void
draImproveCallersUsnVector(
    IN     THSTATE *          pTHS,
    IN     UUID *             puuidDsaObjDest,
    IN     UPTODATE_VECTOR *  putodvec,
    IN     UUID *             puuidInvocIdPresented,
    IN     ULONG              ulFlags,
    IN OUT USN_VECTOR *       pusnvecFrom
    )
/*++

Routine Description:

    Improve the USN vector presented by the destination DSA based upon his
    UTD vector, whether we've been restored since he last replicated, etc.

Arguments:

    pTHS (IN)

    puuidDsaObjDest (IN) - objectGuid of the destination DSA's ntdsDsa
        object.

    putodvec (IN) - UTD vector presented by dest DSA.

    puuidInvocIdPresented (IN) - invocationID dest DSA thinks we're running
        with.

    ulFlags - incoming replication flag.

    pusnvecFrom (IN/OUT) - usn vector to massage.

Return Values:

    None.  Throws exceptions on critical failures.

--*/
{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec = NULL;
    REPL_DSA_SIGNATURE_V1 *     pEntry;
    DBPOS *                     pDB = pTHS->pDB;
    DWORD                       err;
    CHAR                        szTime[SZDSTIME_LEN];
    USN_VECTOR                  usnvecOrig = *pusnvecFrom;
    USN                         usnFromUtdVec;
    DWORD                       i;
    USN                         usnRetired = 0;

    if ((0 != memcmp(&pTHS->InvocationID, puuidInvocIdPresented, sizeof(UUID)))
        && !fNullUuid(puuidInvocIdPresented)
        && (0 != memcmp(&gusnvecFromScratch,
                        pusnvecFrom,
                        sizeof(USN_VECTOR)))) {
        // Caller is performing incremental replication but did not present our
        // current invocation ID.  This means either he didn't get his
        // replication state from us or we've been restored from backup since he
        // last replicated from us.
        //
        // If the latter, we may need to update his USN vector.  Consider the
        // following:
        //
        // (1) Dest last synced up to USN X generated under our old ID.
        //     We were backed up at USN X+Y, generated changes up to
        //     X+Y+Z under our old ID, and later restored at USN X+Y.
        //     => Dest should sync starting at USN X.
        //
        // (2) We were backed up at USN X.  We generated further
        //     changes.  Dest last synced up to USN X+Y.  We were
        //     restored at USN X.  Changes generated under our new ID
        //     from X to X+Y are different from those generated under
        //     our old ID from X to X+Y.  However we know those at X
        //     and below are identical, which dest claims to have seen.
        //     => Dest should sync starting at USN X.
        //
        // I.e., dest should always sync starting from the lower of the
        // "backed up at" and "last synced at" USNs.

        err = DBFindDSName(pDB, gAnchor.pDSADN);
        if (err) {
            DRA_EXCEPT(DRAERR_DBError, err);
        }

        pSigVec = DraReadRetiredDsaSignatureVector(pTHS, pDB);
        if (NULL == pSigVec) {
            // Implies caller did not get his state from us to begin with.
            // The USN vector presented is useless.  This might occur if the
            // local DSA has been demoted and repromoted.
            DPRINT(0, "Dest DSA presented unrecognized invocation ID -- will sync from scratch.\n");
            *pusnvecFrom = gusnvecFromScratch;
        }
        else {
            Assert(1 == pSigVec->dwVersion);

            // Try to find the invocation ID presented by the caller in our restored
            // signature list.
            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                usnRetired = pEntry->usnRetired;

                if (0 == memcmp(&pEntry->uuidDsaSignature,
                                puuidInvocIdPresented,
                                sizeof(UUID))) {
                    // The dest DSA presented an invocation ID we have since retired.
                    DPRINT1(0, "Dest DSA has not replicated from us since our restore on %s.\n",
                            DSTimeToDisplayString(pEntry->timeRetired, szTime));

                    if (pEntry->usnRetired < pusnvecFrom->usnHighPropUpdate) {
                        DPRINT2(0, "Rolling back usnHighPropUpdate from %I64d to %I64d.\n",
                                pusnvecFrom->usnHighPropUpdate, pEntry->usnRetired);
                        pusnvecFrom->usnHighPropUpdate = pEntry->usnRetired;
                    }

                    if (pEntry->usnRetired < pusnvecFrom->usnHighObjUpdate) {
                        DPRINT2(0, "Rolling back usnHighObjUpdate from %I64d to %I64d.\n",
                                pusnvecFrom->usnHighObjUpdate, pEntry->usnRetired);
                        pusnvecFrom->usnHighObjUpdate = pEntry->usnRetired;
                    }
                    break;
                }
            }

            if (i == pSigVec->V1.cNumSignatures) {
                // Implies caller did not get his state from us to begin with,
                // or that the invocationID he had for us was produced during
                // a restore that was later wiped out by a subsequent restore
                // of a backup preceding the original restore.  (Got that? :-))
                // The USN vector presented is useless.
                DPRINT(0, "Dest DSA presented unrecognized invocation ID -- will sync from scratch.\n");
                *pusnvecFrom = gusnvecFromScratch;
            }
        }

        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_ADJUSTED_DEST_BOOKMARKS_AFTER_RESTORE,
                  szInsertUUID(puuidDsaObjDest),
                  szInsertUSN(usnRetired),
                  szInsertUUID(puuidInvocIdPresented),
                  szInsertUSN(usnvecOrig.usnHighObjUpdate),
                  szInsertUSN(usnvecOrig.usnHighPropUpdate),
                  szInsertUUID(&pTHS->InvocationID),
                  szInsertUSN(pusnvecFrom->usnHighObjUpdate),
                  szInsertUSN(pusnvecFrom->usnHighPropUpdate));
    }

    if (UpToDateVec_GetCursorUSN(putodvec, &pTHS->InvocationID, &usnFromUtdVec)
        && (usnFromUtdVec > pusnvecFrom->usnHighPropUpdate)) {
        // The caller's UTD vector says he is transitively up-to-date with our
        // changes up to a higher USN than he is directly up-to-date.  Rather
        // than seeking to those objects with which he is transitively up-to-
        // date then throwing them out one-by-one after the UTD vector tells us
        // he's already seen the changes, skip those objects altogether.
        pusnvecFrom->usnHighPropUpdate = usnFromUtdVec;

        if (!(ulFlags & DRS_SYNC_PAS) &&
            usnFromUtdVec > pusnvecFrom->usnHighObjUpdate) {
            // improve obj usn unless we're in PAS mode in which case
            // we have to start from time 0 & can't optimize here.
            pusnvecFrom->usnHighObjUpdate = usnFromUtdVec;
        }
    }

#if DBG
    // Assert that the dest claims he is no more up-to-date wrt us than we are
    // with ourselves.  Ignore if dest didn't tell us what he thought our
    // invocation ID was (implying a pre WIn2k RTM RC1 build), as if we were
    // restored since he last replicated from us he may present "out of bounds"
    // USNs.  (In which case he'll reset his USN vector to 0 when he learns of
    // our new invocation ID via the reply.)
    if (!fNullUuid(puuidInvocIdPresented)) {
        USN usnLowestC = 1 + DBGetHighestCommittedUSN();

        Assert(pusnvecFrom->usnHighPropUpdate < usnLowestC);
        Assert(pusnvecFrom->usnHighObjUpdate < usnLowestC);
    }
#endif

    // PERF 99-05-23 JeffParh, bug 93068
    //
    // If we really wanted to get fancy we could handle the case where we've
    // been restored, the target DSA is adding us as a new replication partner,
    // and he is transitively up-to-date wrt one of our old invocation IDs but
    // not our current invocation ID.  I.e., we could use occurrences of our
    // retired DSA signatures that we found in the UTD vector he presnted in
    // order to improve his USN vector.  To do this we'd probably want to cache
    // the retired DSA signature list on gAnchor to avoid re-reading it so
    // often.  And we'd need some pretty sophisticated test cases.
    //
    // Note that this would also help the following sequence:
    // 1. Backup.
    // 2. Restore, producing new invocation ID.
    // 3. Partner syncs from us, optimizing his bookmarks and getting our new
    //    invocation ID.
    // 4. We're again restored from the same backup.
    // 5. Partner syncs from us, presenting the invocation ID he received
    //    following the first restore.  Since local knowledge of this invocation
    //    ID was wiped out in the second restore, we force the partner to sync
    //    from USN 0.
    //
    // If we recognized old invocation IDs in the UTD vector, we could avoid
    // the full sync in step 5.
}


int __cdecl
CompareReplValInf(
    const void * Arg1,
    const void * Arg2
    )

/*++

Routine Description:

    Sort an array of REPLVALINF structures.

    This is done for reasons of grouping the entries for processing efficiency, NOT for
    duplicate removal.  The destination of an RPC request batches updates to values by
    containing object.  At the source using the LDAP replication control, the code for
        LDAP_ReplicaMsgToSearchResultFull ()
    groups changes by containing object, attribute, and present/absent status.

    It is possible to see duplicate values identical in all respects except for metadata. Since
    we pick up changes in multiple transactions, it is possible to see the same object
    changed more than once.  The convergence properties of our algorithm guarantee that we
    can apply changes to a value or object in any order, regardless of whether the changes
    arrive in one packet or several.  In short, duplicates are an hopefully infrequent, but
    definite possibility here.

Arguments:

    Arg1 -
    Arg2 -

Return Value:

    int __cdecl -

--*/

{
    THSTATE *pTHS = pTHStls;
    int state;
    REPLVALINF *pVal1 = (REPLVALINF *) Arg1;
    REPLVALINF *pVal2 = (REPLVALINF *) Arg2;
    ATTCACHE *pAC;
    DSNAME *pdnValue1, *pdnValue2;

    Assert( !fNullUuid( &pVal1->pObject->Guid ) );
    Assert( !fNullUuid( &pVal2->pObject->Guid ) );

    // Sort by containing object guid first
    state = memcmp(&pVal1->pObject->Guid, &pVal2->pObject->Guid, sizeof(GUID));
    if (state) {
        return state;
    }

    // Sort by attrtyp second
    state = ((int) pVal1->attrTyp) - ((int) pVal2->attrTyp) ;
    if (state) {
        return state;
    }

    // Sort by isPresent third
    // This will sort by absent values first
    state = ((int) pVal1->fIsPresent) - ((int) pVal2->fIsPresent) ;
    if (state) {
        return state;
    }

    // Sort on the value itself as a (mostly) tie-breaker

    // Since attrTyp1 == attrType2, both use same pAC
    pAC = SCGetAttById(pTHS, pVal1->attrTyp);
    if (!pAC) {
        DRA_EXCEPT(DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }
    // Get the DSNAME output of the ATTRVAL
    pdnValue1 = DSNameFromAttrVal( pAC, &(pVal1->Aval) );
    if (pdnValue1 == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }
    pdnValue2 = DSNameFromAttrVal( pAC, &(pVal2->Aval) );
    if (pdnValue2 == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }

    // Sort by value guid last
    state = memcmp(&pdnValue1->Guid, &pdnValue2->Guid, sizeof(GUID));
    if (state) {
        return state;
    }

    // The values are duplicates. As stated above, duplicates do not affect the correctness
    // of the replication algorithm. To further differentiate would only serve to help
    // qsort efficiency. To further differentiate, we could compare the
    // binary data in a value, if any.  Finally, the values should differ in their
    // metadata stamps.

    // Not executed. Keep compiler happy
    return 0;
} /* CompareReplValInf */


DWORD
ProcessPartialSets(
    IN  THSTATE *                   pTHS,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pmsgIn,
    IN  BOOL                        fIsPartialSource,
    OUT PARTIAL_ATTR_VECTOR **      ppNewDestPAS
    )
/*++

Routine Description:

    Process partial sets for RO replication:
     - handle prefix mapping
     - use local PAS if dest didn't sent one (W2K dest)
     - PAS only: combine dest's PAS & extended PAS
     - RO src+dest only: ensure that we have dest's PAS

Arguments:

    pTHS - Thread state
    pmsgIn - incoming repl request
    fIsPartialSource - are we RO as well
    ppNewDestPAS - combined PAS.

Return Value:

    Error: in DRAERR error space
    Success: DRAERR_success

--*/
{
    SCHEMA_PREFIX_MAP_HANDLE        hPrefixMap = NULL;
    PARTIAL_ATTR_VECTOR             *pNCPAS = NULL;

    Assert(ppNewDestPAS);
    Assert(pmsgIn->pPartialAttrSet);


    if ( pmsgIn->PrefixTableDest.PrefixCount ) {
        //
        // Dest sent Prefix Table
        //

        //
        // Attribute Mapping
        // Dest sent a prefix table & attr vector, thus map ATTRTYPs in
        // destination's partial attribute set to local ATTRTYPs.

        hPrefixMap = PrefixMapOpenHandle(
                        &pmsgIn->PrefixTableDest,
                        &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable);
        if (!PrefixMapTypes(hPrefixMap,
                            pmsgIn->pPartialAttrSet->cAttrs,
                            pmsgIn->pPartialAttrSet->rgPartialAttr)) {
            // Mapping failed.
            return(DRAERR_SchemaMismatch);
        }
        // sort results in place
        qsort(pmsgIn->pPartialAttrSet->rgPartialAttr,
              pmsgIn->pPartialAttrSet->cAttrs,
              sizeof(ATTRTYP),
              CompareAttrtyp);
    }

    if ( pmsgIn->ulFlags & DRS_SYNC_PAS ) {

         //
         // PAS replication
         //

         // parameter sanity
         if (!pmsgIn->pPartialAttrSet || !pmsgIn->pPartialAttrSetEx) {
             // how come? all PAS requests should contain both PAS sets!
             Assert(!"Invalid PAS replcation request: no PAS in packet\n");
             return(DRAERR_InternalError);
         }


         // Now map prefix table for extended PAS vector
         Assert(hPrefixMap);
         if (!PrefixMapTypes(hPrefixMap,
                             pmsgIn->pPartialAttrSetEx->cAttrs,
                             pmsgIn->pPartialAttrSetEx->rgPartialAttr)) {
             // Mapping failed.
             return(DRAERR_SchemaMismatch);
         }
         // sort results in place
         qsort(pmsgIn->pPartialAttrSetEx->rgPartialAttr,
               pmsgIn->pPartialAttrSetEx->cAttrs,
               sizeof(ATTRTYP),
               CompareAttrtyp);

    }

    if ( hPrefixMap ) {
        // done w/ PrefixMap handle. Close it.
        PrefixMapCloseHandle(&hPrefixMap);
    }



    // although could get generated later, we calculate this here & pass on
    // to prevent expensive re-calc later.
    *ppNewDestPAS = GC_CombinePartialAttributeSet(
                    pTHS,
                    (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSet,
                    (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSetEx);
    Assert(*ppNewDestPAS);

    //
    // RO Destination. If source is RO, then we must ensure that
    // we can supply source w/ the current PAS.
    // (if we're RW, we always have all attributes).
    // Except: if we'd generated the PAS vector, skip the check.
    //

    if (fIsPartialSource &&
        (PVOID)pmsgIn->pPartialAttrSet !=
        (PVOID)((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec) {
        // get PAS from NC head
        if (!GC_ReadPartialAttributeSet(pmsgIn->pNC, &pNCPAS)) {
            // Unable to read the partial attribute set on the NCHead
            return(DRAERR_DBError);
        }

        // ensure working PAS is contained in NC head's PAS.
        // that is, make sure all attributes in requested set were
        // commited by the replication engine on the NC head
        // (see bug Q:452022)
        if (!GC_IsSubsetOfPartialSet(*ppNewDestPAS,
                                     pNCPAS)) {
            // NC PAS doesn't contain all attributes in working set.
            // Are we waiting to replicate them in?
            return(DRAERR_IncompatiblePartialSet);
        }                           // pNewDestPAS isn't subset of PAS
    }                               // fIsPartialSource

    return DRAERR_Success;
}

DWORD
DraGetNcSize(
    IN  THSTATE *                     pTHS,
    IN  BOOL                          fCriticalOnly,
    IN  ULONG                         dntNC
)
/*++

Routine Description:

    Get the approximate size of the NC.  First, try to get the size of the
    NC from the local memory NC cache on the gAnchor.  If not present or 
    the size is 0 (meaning not cached), then actually query the database.

    The original database query was too expensive on the big DIT machines,
    so now we've got this.  NOTE: This blows your currency, and throws
    exceptions for errors.

Arguments:

    pTHS (IN)
        pTHS->fLinkedValueReplication (IN) - If the forest is in LVR mode.

    fCriticalOnly (IN) - If we want the critical objects only.

    dntNC (IN) - The Naming Context of interest.

Return Values:

    Approximate count of number of objects in NC.  Currency will be lost!

--*/
{
    NCL_ENUMERATOR          nclData;
    NAMING_CONTEXT_LIST *   pNCL = NULL;
    ULONG                   ulEstimatedSize;

    // If it's critical objects only it shouldn't matter, the count will be
    // relatively quick.
    if(!fCriticalOnly){
        NCLEnumeratorInit(&nclData, CATALOG_MASTER_NC);
        NCLEnumeratorSetFilter(&nclData, NCL_ENUMERATOR_FILTER_NCDNT, (void *)UlongToPtr(dntNC));
        pNCL = NCLEnumeratorGetNext(&nclData);
        if(pNCL &&
           pNCL->ulEstimatedSize != 0){
            // YES! We got a cached hit with valid data.
            return(pNCL->ulEstimatedSize);
        }
        // We don't check the partial replica list, because this list does
        // not cache the estimated size.  If someone ever decided to cache
        // the estimated size of the partial replica NCs, this should be
        // updated to try that cache first.
    }

    if (!fCriticalOnly) {
        ulEstimatedSize = DBGetEstimatedNCSizeEx(pTHS->pDB, dntNC);
        if(ulEstimatedSize == 0){
            return(DBGetNCSizeEx( pTHS->pDB, pTHS->pDB->JetObjTbl,
                              Idx_DraUsn,
                              dntNC ) );
        } else {
            return(ulEstimatedSize);
        }
    } else {
        return(DBGetNCSizeEx( pTHS->pDB, pTHS->pDB->JetObjTbl,
                              Idx_DraUsnCritical,
                              dntNC ) );
    }

    Assert(!"We should never get this far!");
    return 0;
    // currency is lost after this.  Make sure callers reestablish.
}
  

ULONG
DRA_GetNCChanges(
    IN  THSTATE *                     pTHS,
    IN  FILTER *                      pFilter OPTIONAL,
    IN  DWORD                         dwDirSyncControlFlags,
    IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut
    )
/*++

Routine Description:

    Construct an outbound replication packet at the request of another replica
    or a DirSync client.

Arguments:

    pTHS (IN)

    pFilter (IN, OPTIONAL) - If specified, only objects that match the filter
        will be returned.  Used by DirSync clients.

    pmsgIn (IN) - Describes the desired changes, including the NC and the sync
        point to start from.

    pmsgOut (OUT) - On successful return, holds the changes and the next sync
        point (amongst other things).

Return Values:

    Win32 error.

--*/
{
    USN                             usnLowestC;
    ULONG                           ret;
    USN                             usnChangedSeekStart;
    REPLENTINFLIST *                pEntInfListHead;
    REPLENTINFLIST **               ppEntInfListNext;
    USN                             usnChangedFound = 0;
    char                            szUuid[ SZUUID_LEN ];
    ULONG                           dntNC;
    BOOL                            fInsertNCPrefix;
    DNT_HASH_ENTRY *                pDntHashTable;
    DWORD                           cbAncestorsSize = 0;
    ULONG *                         pdntAncestors = NULL;
    DWORD                           cNumAncestors;
    DWORD                           iAncestor;
    SYNTAX_INTEGER                  instanceType;
    SCHEMA_PREFIX_TABLE *           pLocalPrefixTable;
    USN_VECTOR                      usnvecFrom;
    USN                             usnFromUtdVec;
    BOOLEAN                         fReturnCritical;
    CLASSCACHE *                    pccNC;
    FILTER *                        pIntFilter = NULL;
    handle_t                        hEncoding = NULL;
    DWORD                           cbEncodedSize = 0;
    ULONG                           ulOutMsgMaxObjects;
    ULONG                           ulOutMsgMaxBytes;
    ULONG                           ulTickToTimeOut;
    PARTIAL_ATTR_VECTOR             *pNewDestPAS=NULL;
    BOOL                            fIsPartialSource;
    ULONG                           cAllocatedValues = 0;
    BOOL                            fValueChangeFound = FALSE;
    PVOID                           pvCachingContext = NULL;
    DBPOS                           *pDBAnc = NULL;
    POBJECT_TYPE_LIST               pFilterSecurity;
    DWORD *                         pResults;
    ULONG                           FilterSecuritySize;
    BOOL *                          pbSortSkip = NULL;
    PSECURITY_DESCRIPTOR            pSecurity = NULL;
    DRS_EXTENSIONS *                pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    // When using DirSync Control, filter must be specified
    Assert( !dwDirSyncControlFlags || pFilter );

    fReturnCritical = (((pmsgIn->ulFlags) & DRS_CRITICAL_ONLY) != 0);

    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    ZeroMemory(pmsgOut, sizeof(*pmsgOut));
    // The mail-based reply must have a minimum of fields filled in
    // Do this first so that these are filled in on error.

    // Send "from" vector back to destination such that if it is
    // replicating aynchronously (e.g., by mail), it can ensure that
    // the reply it gets from this source corresponds to the last batch
    // of changes it requested.
    pmsgOut->usnvecFrom = pmsgIn->usnvecFrom;

    pmsgOut->pNC = THAllocEx(pTHS,  pmsgIn->pNC->structLen);
    memcpy(pmsgOut->pNC, pmsgIn->pNC, pmsgIn->pNC->structLen);

    // Caller needs to know our UUIDs.
    pmsgOut->uuidDsaObjSrc = gAnchor.pDSADN->Guid;
    pmsgOut->uuidInvocIdSrc = pTHS->InvocationID;



    // Log parameters
    LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GETNCCH_ENTRY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidGetNcChanges,
                     szInsertUUID(&pmsgIn->uuidDsaObjDest),
                     szInsertDN(pmsgIn->pNC),
                     szInsertUSN(pmsgIn->usnvecFrom.usnHighObjUpdate),
                     szInsertHex(pmsgIn->ulFlags),
                     szInsertUL(fReturnCritical),
                     szInsertUL(pmsgIn->ulExtendedOp),
                     NULL,
                     NULL);

    // Check for invalid parameters
    if (    ( NULL == pmsgIn      )
         || ( NULL == pmsgIn->pNC )
         || ( NULL == pmsgOut     ) )
    {
        ret = DRAERR_InvalidParameter;
        goto LogAndLeave;
    }

    // Reject if outbound replication is disabled
    if (    (    gAnchor.fDisableOutboundRepl
              && !( pmsgIn->ulFlags & DRS_SYNC_FORCED )
            )
       )
    {
        ret = DRAERR_SourceDisabled;
        goto LogAndLeave;
    }

    if (!(dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY)
        && (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
            != REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote))) {
        // The replication epoch has changed (usually as the result of a domain
        // rename).  We are not supposed to communicate with DCs of other
        // epochs.
        DSNAME *pdnRemoteDsa = draGetServerDsNameFromGuid(pTHS,
                                                          Idx_ObjectGuid,
                                                          &pmsgIn->uuidDsaObjDest);

        DPRINT3(0, "GetChanges request from %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                pdnRemoteDsa->StringName,
                REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote),
                REPL_EPOCH_FROM_DRS_EXT(pextLocal));

        LogEvent(DS_EVENT_CAT_RPC_SERVER,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                 szInsertDN(pdnRemoteDsa),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));

        THFreeEx(pTHS, pdnRemoteDsa);

        ret = ERROR_DS_DIFFERENT_REPL_EPOCHS;
        goto LogAndLeave;
    }

    // Create hash table to use to determine whether a given object has already
    // been put in the output buffer.
    pDntHashTable = dntHashTableAllocate( pTHS );

    // Determine the USN vector to start from.
    usnvecFrom = pmsgIn->usnvecFrom;

    pmsgOut->PrefixTableSrc = *pLocalPrefixTable;

    // If we're doing a FSMO extended operation, branch off now
    if (pmsgIn->ulExtendedOp) {
        ret = DoFSMOOp(pTHS, pmsgIn, pmsgOut);
        goto LogAndLeave;
    }

    // Calculate the tick at which we should terminate our attempts to find
    // more objects to put in the outbound packet.  We will chop off the packet
    // and send what we have when
    // (1) the packet has crested the object limit,
    // (2) the packet has crested the byte count limit, or
    // (3) gulDraMaxTicksForGetChanges (msecs) have transpired.
    ulTickToTimeOut = GetTickCount() + gulDraMaxTicksForGetChanges;

    // Before we start a transaction, determine the lowest uncommitted
    // usn that exists. It's there because transactions can be committed out of USN order.
    // I.e., USNs are allocated sequentially, but they may well not be committed to the
    // database sequentially.  usnLowestC is the highest USN for which we know there are no
    // transactions in progress using a lower USN.  Returning a USN higher than this value
    // could cause us to miss sending an update, leading to divergence

    // [Jeffparh] The call to DBGetHighestUncommittedUSN() has to be made
    // before the transaction starts to avoid a race condition.  (We want to
    // make sure that the USN we get here has indeed been committed before
    // our transaction starts, otherwise we wouldn't see it in our
    // transaction.)

    usnLowestC = 1 + DBGetHighestCommittedUSN();

    BeginDraTransaction(SYNC_READ_ONLY);

    // From here on, all exceptions trapped to end clean up.

    __try {
        // Convert caller-supplied filter (if any) to internal version.
        if (NULL != pFilter) {
            if ( (ret = DBMakeFilterInternal(pTHS->pDB, pFilter, &pIntFilter)) != ERROR_SUCCESS) {
                DRA_EXCEPT(ret, 0);
            }
            GetFilterSecurity(pTHS,
                              pIntFilter,
                              SORT_NEVER,
                              0, // SortAttr
                              FALSE, // fABSearch
                              &pFilterSecurity,
                              &pbSortSkip,
                              &pResults,
                              &FilterSecuritySize);
        }

        // Make server-side modifications to from vector.
        // Note: we modify the private copy so that later we can return the
        // original unmodified from vector.
        if (pmsgIn->ulFlags & DRS_FULL_SYNC_PACKET) {
            // In "full sync packet" mode, return all properties.
            pmsgIn->pUpToDateVecDest = NULL;
            usnvecFrom.usnHighPropUpdate = 0;
        }
        else {
            // The more typical cases.
            draImproveCallersUsnVector(pTHS,
                                       &pmsgIn->uuidDsaObjDest,
                                       pmsgIn->pUpToDateVecDest,
                                       &pmsgIn->uuidInvocIdSrc,
                                       pmsgIn->ulFlags,
                                       &usnvecFrom);
        }


        // The new water mark is at least as high as the water mark that was
        // passed in even if no new objects have been written.
        pmsgOut->usnvecTo = usnvecFrom;

        // Find the NC object, get and save its DNT.
        if (ret = FindNC(pTHS->pDB, pmsgIn->pNC,
                         FIND_MASTER_NC | FIND_REPLICA_NC, &instanceType)) {
            DRA_EXCEPT_NOLOG(DRAERR_BadDN, ret);
        }

        // Save the DNT of the NC object
        dntNC = pTHS->pDB->DNT;

        // If NC is in the process of being removed, it's an invalid replication
        // source.  It's perfectly acceptable for e.g. an interior node in a
        // partially removed NC to have a phantom parent, which is taboo for
        // replication sources.
        if (instanceType & IT_NC_GOING) {
            DRA_EXCEPT(DRAERR_NoReplica, ret);
        }

        // If this is a placeholder NC, it is not yet populated locally so we
        // should refuse outbound replication.
        GetObjSchema(pTHS->pDB, &pccNC);
        if (CLASS_TOP == pccNC->ClassId) {
            DRA_EXCEPT_NOLOG(DRAERR_NoReplica, 0);
        }

        if (!(pmsgIn->ulFlags & DRS_ASYNC_REP) ) {
            // Go ahead and get up-to-date vector now.  We don't do so
            // afterwards so that we don't risk skipping sending changes due to
            // an originating write occurring between the time we insert the
            // last element into the return buffer and the time we update the
            // vector with our latest USN.
            //
            // We skip this in the DRS_ASYNC_REP case since we're just going
            // to reset the destination's replication state anyway -- we will
            // never return a UTD vector to a caller who specified the
            // DRS_ASYNC_REP flag.

            UpToDateVec_Read(pTHS->pDB,
                             instanceType,
                             UTODVEC_fUpdateLocalCursor,
                             usnLowestC - 1,
                             &pmsgOut->pUpToDateVecSrc);

            Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(pmsgOut->pUpToDateVecSrc));
        }

        //
        // Partial-Attribute-Set setup
        //
        if (dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY) {
            // for dirsync clients, use specified partial attr set.
            pNewDestPAS = (PARTIAL_ATTR_VECTOR*)pmsgIn->pPartialAttrSet;
        }


        // remember if we're partial
        fIsPartialSource = FPartialReplicaIt(instanceType);

        if (!(pmsgIn->ulFlags & DRS_WRIT_REP)) {
            // Destination is a partial replica --
            // Partial Attribute Set Processing
            ret = ProcessPartialSets(
                        pTHS,
                        pmsgIn,
                        fIsPartialSource,
                        &pNewDestPAS );
            if (ret) {
                DRA_EXCEPT(ret, 0);
            }
        }
        else if (fIsPartialSource) {
            // Destination is a full or master replica and the local machine is
            // a partial replica; replication cannot proceed.
            DRA_EXCEPT(DRAERR_SourceIsPartialReplica, 0);
        }

        // We will start searching from one higher than the highest
        // usnChanged given.
        usnChangedSeekStart = usnvecFrom.usnHighObjUpdate + 1;

        // Initialize the output list
        pEntInfListHead = NULL;
        ppEntInfListNext = &pEntInfListHead;
        pmsgOut->cNumObjects = 0;

        pmsgOut->fMoreData = TRUE;

        // Look for changes on the NC prefix first.  Note that the NC prefix
        // must be special-cased in this manner as it will never be found by
        // GetNextObjByIndex() -- its dntNC is that of its parent NC, not its
        // own dnt, and is thus missing from the index for the NC as a whole.

        fInsertNCPrefix = TRUE;

        // Return the number of objects in the NC
        if (pmsgIn->ulFlags & DRS_GET_NC_SIZE) {
            pmsgOut->cNumNcSizeObjects = DraGetNcSize(pTHS, fReturnCritical, dntNC);

            if (pTHS->fLinkedValueReplication) {
                // Only values in the database after LVR mode enabled
                pmsgOut->cNumNcSizeValues =
                    DBGetNCSizeEx( pTHS->pDB, pTHS->pDB->JetLinkTbl,
                                   Idx_LinkDraUsn, dntNC );
            }

            // currency is lost after this, but ok, since reestablished below
        }

        // Sanity check cutoff values provided by client
        if (DRS_MAIL_REP & pmsgIn->ulFlags) {
            // Async (e.g., mail-based) intersite request.
            ulOutMsgMaxObjects = gcMaxAsyncInterSiteObjects;
            ulOutMsgMaxBytes = gcMaxAsyncInterSiteBytes;
        } else if (IS_REMOTE_DSA_IN_SITE(pTHS->pextRemote, gAnchor.pSiteDN)) {
            // DirSync/RPC intrasite request.  (Note that we err on the
            // side of "same site" if we can't tell for sure.)
            ulOutMsgMaxObjects = gcMaxIntraSiteObjects;
            ulOutMsgMaxBytes = gcMaxIntraSiteBytes;
        } else {
            // RPC intersite request.
            ulOutMsgMaxObjects = gcMaxInterSiteObjects;
            ulOutMsgMaxBytes = gcMaxInterSiteBytes;
        }

        pmsgIn->cMaxObjects = min(pmsgIn->cMaxObjects, ulOutMsgMaxObjects);
        pmsgIn->cMaxBytes = min(pmsgIn->cMaxBytes, ulOutMsgMaxBytes);
        pmsgIn->cMaxObjects = max(pmsgIn->cMaxObjects, DRA_MAX_GETCHGREQ_OBJS_MIN);
        pmsgIn->cMaxBytes = max(pmsgIn->cMaxBytes, DRA_MAX_GETCHGREQ_BYTES_MIN);


        // Create encoding handle to be used to size the data we're going to
        // ship.
        ret = MesEncodeFixedBufferHandleCreate(grgbFauxEncodingBuffer,
                                               sizeof(grgbFauxEncodingBuffer),
                                               &cbEncodedSize,
                                               &hEncoding);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        // While we have less than the maximum number of objects, search for
        // next object. We also check to see if the search loop has taken too
        // much time. This can happen when we are finding objects, but filtering
        // them out because the destination has already seen them according to
        // his UTD vector.  This is a common scenario when we are a newly
        // installed source and other older members are full syncing from us
        // for their first time.
        while ( (pmsgOut->cNumObjects < pmsgIn->cMaxObjects) &&
                (pmsgOut->cNumBytes < pmsgIn->cMaxBytes)  &&
                (CompareTickTime(GetTickCount(), ulTickToTimeOut) < 0) &&
                (eServiceShutdown == eRunning)) {

            // Close the outstanding transaction and open another. We close the
            // transaction so that we don't hold one long term and make a lot
            // of work for the DBLayer. We have a transaction open while we find
            // and examine an object so that it's not modified or deleted while
            // we're reading it.

            DBTransOut(pTHS->pDB, TRUE, TRUE);      // Commit, lazy
            DBTransIn(pTHS->pDB);

            if ( fInsertNCPrefix )
            {
                USN usnChanged;

                ret = DBFindDNT(pTHS->pDB, dntNC);
                if (0 != ret) {
                    // We found it just a second ago....
                    DRA_EXCEPT( DRAERR_DBError, ret );
                }

                fInsertNCPrefix = FALSE;

                // We have to seek to the NC head since it's NCDNT is not its
                // own DNT.  See, however, if we can filter it out up-front by
                // checking it's USN-Changed value.
                GetExpectedRepAtt(pTHS->pDB,
                                  ATT_USN_CHANGED,
                                  &usnChanged,
                                  sizeof(usnChanged));

                if (usnChanged < usnChangedSeekStart) {
                    // Nothing to see here; move along.
                    continue;
                }
            }
            else if (pmsgIn->ulFlags & DRS_ASYNC_REP) {
                // The destination is attempting to asynchronously add a replica
                // from the local machine.  We've already added any changes the
                // destination hasn't seen (if any) from the NC head to the
                // replication stream; call it quits.  The destination will do
                // the remainder of the replication later.
                pmsgOut->fMoreData = FALSE;
                memset(&pmsgOut->usnvecTo, 0, sizeof(pmsgOut->usnvecTo));
                break;
            }
            else {
                ret = GetNextObjOrValByUsn(pTHS->pDB,
                                           dntNC,
                                           usnChangedSeekStart,
                                           fReturnCritical,
                                           FALSE, // return both
                                           &ulTickToTimeOut,
                                           &pvCachingContext, // Caching context
                                           &usnChangedFound,
                                           &fValueChangeFound );
                if (ERROR_NO_MORE_ITEMS == ret) {
                    // No more updated items.  Set no continuation.
                    pmsgOut->fMoreData = FALSE;
                    break;
                }
                else if (ret && (ERROR_TIMEOUT != ret)) {
                    Assert(!"GetNextObjByIndex() returned unexpected error!");
                    DRA_EXCEPT(ret, 0);
                }

                // Don't return a maxusn past the lowest uncommitted (but return
                // object).
                if (usnChangedFound < usnLowestC) {

                    Assert(usnChangedFound > pmsgOut->usnvecTo.usnHighObjUpdate);
                    pmsgOut->usnvecTo.usnHighObjUpdate = usnChangedFound;
                }

                if (ERROR_TIMEOUT == ret) {
                    // Our time limit expired.  Return any objects we've found
                    // in this packet (if any) along with the updated USN.
                    // (Thus, even if we aren't returning any objects in this
                    // packet, we're still making progress.)
                    Assert(pmsgIn->usnvecFrom.usnHighObjUpdate
                           < pmsgOut->usnvecTo.usnHighObjUpdate);
                    break;
                }

                Assert(!ret);

                // set the usnChangedSeekStart for the next iteration
                usnChangedSeekStart = usnChangedFound + 1;
            }

            //
            // Found a change to potentially ship.
            // The change, either an object or a value, is represented by currency
            // in either the ObjTbl or LinkTbl respectively. This currency must be
            // preserved until the AddAnyXXX calls below are executed.
            //
            // [wlees 7/14/00] Having currency in the link table outside a single
            // DB layer call is an extension (for good or ill) of the original design.
            // The link table does not have the usual mechanisms to express currency,
            // such as a row tag and a means to seek to it. Hence the use of pDBAnc
            // below to preserve the whole DBPOS.
            //

            // Does this object match the filter and optionally security
            // provided by the caller?
            if (NULL != pIntFilter) {
                BOOL fMatch;
                DB_ERR dbErr;

                // Make this look like a filtered search...
                DBSetFilter(pTHS->pDB, 
                            pIntFilter, 
                            pFilterSecurity,
                            pResults,
                            FilterSecuritySize, 
                            pbSortSkip
                    );

                pTHS->pDB->Key.ulSearchType = SE_CHOICE_BASE_ONLY;
                pTHS->pDB->Key.dupDetectionType = DUP_NEVER;
                pTHS->pDB->Key.ulSorted = SORT_NEVER;
                pTHS->pDB->Key.indexType = UNSET_INDEX_TYPE;

                dbErr = DBMatchSearchCriteria(pTHS->pDB,
                                              (dwDirSyncControlFlags & DRS_DIRSYNC_OBJECT_SECURITY) ?
                                              &pSecurity : NULL,
                                              &fMatch );
                if (DB_success != dbErr) {
                    DRA_EXCEPT( DRAERR_DBError, dbErr );
                }


                // This is necessary else other dblayer calls will try to free our
                // pIntFilter that was cached in the dbpos
                memset(&pTHS->pDB->Key, 0, sizeof(KEY));

                if (!fMatch) {
                    // Not a match; skip it.
                    DPRINT1(1, "Object %ls does not match filter criteria; skipping...\n",
                            GetExtDSName(pTHS->pDB)->StringName);
                    continue;
                }
                Assert( (!(dwDirSyncControlFlags & DRS_DIRSYNC_OBJECT_SECURITY)) ||
                        pSecurity );
            }


            //  If the object's not already in the output list, and if there are
            //  changes for this object that the destination has not yet seen,
            //  ship them.

            if (    ( pmsgIn->ulFlags & DRS_GET_ANC )
                 && ( pTHS->pDB->DNT != dntNC )
               )
            {
                DWORD dntObj = pTHS->pDB->DNT;
#if DBG
                DBPOS *pDBSave = pTHS->pDB;
#endif

                // Caller wants all ancestors, presumably because he couldn't
                // apply objects in the order we gave him last time.  (This
                // can occur when older objects are moved under newer objects.)

                DBGetAncestors(
                    pTHS->pDB,
                    &cbAncestorsSize,
                    &pdntAncestors,
                    &cNumAncestors
                    );

                // Skip over any ancestors preceding the head of this NC.
                for ( iAncestor = 0;
                      pdntAncestors[ iAncestor ] != dntNC;
                      iAncestor++
                    )
                {
                    ;
                }

                // And skip the NC head, too, since we've already added it to
                // the output list if necessary.
                iAncestor++;

                if (!fValueChangeFound) {
                    // Skip ourself, since we are added below
                    cNumAncestors--;
                }
                
                // For each remaining ancestor, ship it if we have changes the
                // destination hasn't seen (and if we haven't already added it
                // to the output buffer).

                // Open a new DB stream to preserve pTHS->pDB currency
                // This will be re-used for all object in this packet
                if (!pDBAnc) {
                    DBOpen2(FALSE, &pDBAnc);
                }

#if DBG
                // Verify no one is using this
                pTHS->pDB = NULL;
                __try {
#endif

                for ( ; iAncestor < cNumAncestors; iAncestor++ )
                {
                    ret = DBFindDNT( pDBAnc, pdntAncestors[ iAncestor ] );
                    if ( 0 != ret )
                    {
                        DRA_EXCEPT( DRAERR_DBError, ret );
                    }

                    AddAnyUpdatesToOutputList(
                        pDBAnc,
                        dwDirSyncControlFlags,
                        NULL, // No SD fetched yet
                        dntNC,
                        usnvecFrom.usnHighPropUpdate,
                        pNewDestPAS,
                        pmsgIn,
                        hEncoding,
                        &pmsgOut->cNumBytes,
                        &pmsgOut->cNumObjects,
                        pDntHashTable,
                        &ppEntInfListNext
                        );
                }

#if DBG
                } __finally {
                    Assert( pTHS->pDB == NULL );
                    pTHS->pDB = pDBSave;
                }
#endif                
                Assert( dntObj == pTHS->pDB->DNT );
            }

            // If value change found, not dirsync, or
            // dirsync and want values ...
            if ( (fValueChangeFound) &&
                 ( (!(dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY)) ||
                   (dwDirSyncControlFlags & DRS_DIRSYNC_INCREMENTAL_VALUES) )
                ) {
                AddAnyValuesToOutputList(
                    pTHS->pDB,
                    dwDirSyncControlFlags,
                    pSecurity,
                    usnvecFrom.usnHighPropUpdate,
                    pmsgIn,
                    pNewDestPAS,
                    hEncoding,
                    &pmsgOut->cNumBytes,
                    &cAllocatedValues,
                    &(pmsgOut->cNumValues),
                    &(pmsgOut->rgValues)
                    );
            } else {
                // Add the object we found via the creation or update index to the
                // output list (if any changes need to be sent for it).
                AddAnyUpdatesToOutputList(
                    pTHS->pDB,
                    dwDirSyncControlFlags,
                    pSecurity,
                    dntNC,
                    usnvecFrom.usnHighPropUpdate,
                    pNewDestPAS,
                    pmsgIn,
                    hEncoding,
                    &pmsgOut->cNumBytes,
                    &pmsgOut->cNumObjects,
                    pDntHashTable,
                    &ppEntInfListNext
                    );
            }
        }  // while ()

        // Either there are no more changes, or we have hit max object limit

        //
        // Wrap up response message
        //

        if (pmsgOut->fMoreData) {
            //
            // Actions on "more data"
            //

            // don't send up-to-date vector until there are no more changes
            if (NULL != pmsgOut->pUpToDateVecSrc) {
                THFreeEx(pTHS, pmsgOut->pUpToDateVecSrc);
                pmsgOut->pUpToDateVecSrc = NULL;
            }
        }
        else {
            //
            // Actions on "no more data"
            //

            // update property update watermark if it is the end of the repl session
            pmsgOut->usnvecTo.usnHighPropUpdate = pmsgOut->usnvecTo.usnHighObjUpdate;
        }

        // Add in size of the packet header.  (The struct does not yet include
        // the linked list of objects, but their size is already accounted for
        // in pmsgOut->cNumBytes.)
        pmsgOut->cNumBytes += DRS_MSG_GETCHGREPLY_V6_AlignSize(hEncoding,
                                                               pmsgOut);

        *ppEntInfListNext = NULL;
        pmsgOut->pObjects = pEntInfListHead;

        // Verify outbound USN vector is okay, but only if inbound USN vector
        // was also okay.  See restore remarks above.
        if (((usnvecFrom.usnHighPropUpdate < usnLowestC)
             && (pmsgOut->usnvecTo.usnHighPropUpdate >= usnLowestC))
            || ((usnvecFrom.usnHighObjUpdate < usnLowestC)
                && (pmsgOut->usnvecTo.usnHighObjUpdate >= usnLowestC))) {
            Assert(!"USN vector being given to destination implies he's more "
                    "up to date with respect to us than we are!");
            DRA_EXCEPT(DRAERR_InternalError, (ULONG) usnLowestC);
        }

        // NCs being removed cannot be used as replication sources (see similar
        // check at beginning of this function).  We must check at the end of
        // the function as we may have begun to tear down the NC while this
        // function was executing.  We verify that the NC has neither begun
        // (IT_NC_GOING) or completed (FPrefixIt) teardown.
        if ((ret = DBFindDNT(pTHS->pDB, dntNC))
            || (instanceType & IT_NC_GOING)
            || !FPrefixIt(instanceType)) {
            DRA_EXCEPT(DRAERR_NoReplica, ret);
        }

        // Note that the total byte size we calculate is just a little higher
        // than it really is (i.e., a little higher than what we'd get by
        // calling DRS_MSG_GETCHGREPLY_V1_AlignSize(hEncoding, pmsgOut) now),
        // presumably due to more padding bytes in the size we calculate
        // incrementally than are really need if we marshall the entire
        // structure at once.  In empirical testing the difference is only on
        // the order of 0.5%.
        DPRINT3(1, "Sending %d objects in %d bytes to %s.\n", pmsgOut->cNumObjects,
                                                              pmsgOut->cNumBytes,
                                                              UuidToStr(&pmsgIn->uuidDsaObjDest, szUuid));
    } __finally {

        if (pDBAnc) {
            DBClose(pDBAnc, TRUE);
        }

        EndDraTransaction(TRUE);

        if (NULL != hEncoding) {
            MesHandleFree(hEncoding);
        }
    }

    // Normal, non-FSMO-transfer exit path.  If we had hit an error, we would
    // have generated an exception -- we didn't, so we're successful.
    ret = 0;

LogAndLeave:

    // Sort the returned value list.
    // We do this here so that the list generated by DoFsmoOp can
    // take advantage of this as well.
    if ( (!ret) && (pmsgOut->cNumValues) ) {
        qsort( pmsgOut->rgValues,
               pmsgOut->cNumValues,
               sizeof( REPLVALINF ),
               CompareReplValInf );
    }

    LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GETNCCH_EXIT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidGetNcChanges,
                     szInsertUL(pmsgOut->cNumObjects),
                     szInsertUL(pmsgOut->cNumBytes),
                     szInsertUSN(pmsgOut->usnvecTo.usnHighObjUpdate),
                     szInsertUL(pmsgOut->ulExtendedRet),
                     NULL, NULL, NULL, NULL);

    pmsgOut->dwDRSError = ret;

    return ret;
}


void
moveOrphanToLostAndFound(
    IN      DBPOS *                         pDB,
    IN      ULONG                           dntNC,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      DSNAME *                        pdnObj
    )

/*++

Routine Description:

    An object has been found during outbound replication with a phantom parent.
    Move the object to Lost & Found

    This code corrects corrupt databases that were possible when running W2K and W2K SP1.
    To get into this situation, two bugs had to occur. The first was that a live object
    had to be left under a deleted parent. The correct behavior now is to move the object
    to Lost & Found. Second, the deleted parent had to be phantomized by the garbage
    collector. Now, the garbage collector will not phantomize deleted parents until their
    children are phantomized.

Arguments:

    pDB - Database position
    dntNC - DNT of NC
    pMsgIn - Get NC Changes request message
    pdnObj - DSNAME of object

Return Value:

    None
    Excepts on error

--*/

{
    DWORD ret;
    DSNAME *pNC;
    GUID objectGuid, objGuidLostAndFound;
    WCHAR   szRDN[ MAX_RDN_SIZE ];
    DWORD   cb;
    ATTR attrRdn;
    ATTRVAL attrvalRdn;

    DPRINT1( 0, "moveOrphanToLostAndFound, orphan = %ws\n", pdnObj->StringName);

    // Get the naming context
    if (pMsgIn->ulExtendedOp) {
        // For a FSMO operation, pMsgIn->pNC points to the FSMO object
        pNC = FindNCParentDSName(pMsgIn->pNC, FALSE, FALSE);
    } else {
        pNC = pMsgIn->pNC;
    }
    if (NULL == pNC) {
        DRA_EXCEPT( DRAERR_InternalError, 0 );
    }

    // Compute the guid of the lost and found container for this nc
    draGetLostAndFoundGuid(pDB->pTHS, pNC, &objGuidLostAndFound);

    // Get the current object's guid
    GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &(objectGuid), sizeof(GUID) );

    // Get the current name of the object
    ret = DBGetSingleValue(pDB, ATT_RDN, szRDN, sizeof(szRDN), &cb);
    if (ret) {
        DRA_EXCEPT (DRAERR_DBError, ret);
    }

    attrvalRdn.valLen = cb;
    attrvalRdn.pVal = (BYTE *) szRDN;

    // New name same as the old name
    attrRdn.attrTyp = ATT_RDN;
    attrRdn.AttrVal.valCount = 1;
    attrRdn.AttrVal.pAVal = &attrvalRdn;

    // Reparent the object to lost & found
    // The replicator can rename objects even on GC's
    ret = RenameLocalObj(pDB->pTHS,
                         dntNC,
                         &attrRdn,
                         &objectGuid,
                         &objGuidLostAndFound,
                         NULL,  // Originating write
                         TRUE, // fMoveToLostAndFound,
                         FALSE ); // fDeleteLocalObj
    if (ret) {
        DPRINT2( 0, "Failed to reparent orphan %ws, error %d\n", pdnObj->StringName, ret );
        LogEvent8WithData( DS_EVENT_CAT_REPLICATION,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_DRA_ORPHAN_MOVE_FAILURE,
                           szInsertDN(pdnObj),
                           szInsertUUID(&objectGuid),
                           szInsertDN(pNC),
                           szInsertWin32Msg(ret),
                           NULL, NULL, NULL, NULL,
                           sizeof(ret),
                           &ret );
        // We failed to rename the object. Except here with the reason. Outbound
        // replication will stop until someone can get rid of or move this object.
        // Note that we are not reporting the original exception that got us here,
        // which was missing parent or not an object.
        DRA_EXCEPT( ret, 0 );
    } else {
        // Log success
        DPRINT1( 0, "Successfully reparented orphan %ws\n", pdnObj->StringName );
        LogEvent( DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_ORPHAN_MOVE_SUCCESS,
                  szInsertDN(pdnObj),
                  szInsertUUID(&objectGuid),
                  szInsertDN(pNC) );
    }

} /* moveOrphanToLostAndFound */


void
AddAnyUpdatesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      ULONG                           dntNC,
    IN      USN                             usnHighPropUpdateDest,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,        OPTIONAL
    IN OUT  DWORD *                         pcNumOutputObjects,
    IN OUT  DNT_HASH_ENTRY *                pDntHashTable,
    IN OUT  REPLENTINFLIST ***              pppEntInfListNext
    )
/*++

Routine Description:

    Adds the object with currency to the list of objects to be shipped to the
    replication client if there are changes the destination has not yet seen and
    if it has not already been added.

Arguments:

    pDB - Currency set on object to be shipped (if necessary).

    dwDirSyncControlFlags - Flags when being used as part of LDAP control

    dntNC - The DNT of the head of the NC being replicated.

    usnHighPropUpdateDest - Highest USN the remote machine has seen of changes
        made on the local machine.

    pmsgin - Incoming replication packet (for additional processing info)

    hEncoding (IN, OPTIONAL) - Encoding handle, if pcbTotalOutSize is desired
        (i.e., non-NULL).

    pcbTotalOutSize (IN/OUT, OPTIONAL) - Total number of bytes in output msg.

    pcNumOutputObjects (IN/OUT) - Number of objects in the output buffer.

    pDntHashTable (IN/OUT) - Hash table of objects currently in the uutput
        buffer.  Used to protect against duplicates.

    pppEntInfListNext (IN/OUT) - If the candidate object is to be shipped, is
        updated with the information ot be shipped for this object and is
        incremented to point to a free buffer for the next object.

Return Values:

    None.  Throws appropriate exeception on error.

--*/
{
    THSTATE                    *pTHS=pDB->pTHS;
    DSNAME *                    pdnObj = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec = NULL;
    DWORD                       cbReturned;
    CLASSCACHE *                pClassSch;
    BOOL                        fIsSubRef = FALSE;
    ENTINFSEL                   sel;
    SYNTAX_INTEGER              it;
    DNT_HASH_ENTRY *            pNewEntry;
    ATTRTYP                     rdnType;
    BOOL                        fFilterGroupMember = FALSE;
    BOOL                        fPublic =
        (dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY) != 0; // no secrets
    BOOL                        fMergeValues =
        ( (dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY) &&
          (!(dwDirSyncControlFlags & DRS_DIRSYNC_INCREMENTAL_VALUES)) );
    BOOL fFreeSD = FALSE;

    // Has this object already been added to the output buffer?
    // We can attempt to add multiple identical objects because of get anc mode.
    // It is also possible that we will find multiple versions of the same object
    // while searching for changes because we use multiple transactions. This guarantees
    // that only the first is returned. This is NOT required for correctness however.
    if (dntHashTablePresent( pDntHashTable, pDB->DNT, NULL )) {
        // Object is already in output buffer; bail.
        return;
    }

    // Get its DN, ...
    if ( DBGetAttVal(
            pDB,
            1,
            ATT_OBJ_DIST_NAME,
            0,
            0,
            &cbReturned,
            (LPBYTE *) &pdnObj
            )
       )
    {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // ...meta data vector, ...
    if ( DBGetAttVal(
            pDB,
            1,
            ATT_REPL_PROPERTY_META_DATA,
            0,
            0,
            &cbReturned,
            (LPBYTE *) &pMetaDataVec
            )
       )
    {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    // Get SD if needed
    if ( (dwDirSyncControlFlags & DRS_DIRSYNC_OBJECT_SECURITY) &&
         (!pSecurity) ) {
        ULONG ulLen;
        if (DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                        0, 0, &ulLen, (PUCHAR *)&pSecurity))
        {
            DRA_EXCEPT(DRAERR_DBError, 0);
        }
        fFreeSD = TRUE;
    }

    // Old DirSync clients only...
    if (fMergeValues) {
        // We are here because we want to include link value changes in the context
        // of an object change entry that describes the whole object, including all
        // values. Since linked value metadata is stored in a separate table, we
        // must merge it in here.
        DBImproveAttrMetaDataFromLinkMetaData(
            pDB,
            &pMetaDataVec,
            &cbReturned
            );
    }

    if (pMetaDataVec)
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVec);
    }

    // ...and object class.
    GetObjSchema( pDB, &pClassSch );

    // ...and rdnType
    // A superceding class may have an rdnattid that is different
    // from the object's rdnType. Use the rdnType from the object
    // and not the rdnattid from the class.
    GetObjRdnType( pDB, pClassSch, &rdnType );

    if ( dntNC != pDB->DNT )
    {
        // Not the prefix of this NC; is it a subref?
        GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
        fIsSubRef = FExitIt( it );
    }

    // need to filter group member only for a GC replication and if the
    // object under consideration satisfies the requirement for this special
    // filtering
    fFilterGroupMember = (pPartialAttrVec && IsFilterGroupMember(pDB, pClassSch));

    memset( &sel, 0, sizeof( ENTINFSEL ) );
    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel    = fPublic ? EN_ATTSET_LIST_DRA_PUBLIC : EN_ATTSET_LIST_DRA;

    // Determine subset of attributes to be shipped (if any).
    ReplFilterPropsToShip(
        pTHS,
        pdnObj,
        rdnType,
        fIsSubRef,
        usnHighPropUpdateDest,
        pPartialAttrVec,
        pMetaDataVec,
        &sel.AttrTypBlock,
        fFilterGroupMember,
        pMsgIn
        );

    // fMergeValues is true when we are being called by the LDAP replication control
    // and the caller desires the old semantics of returning all values instead of
    // just incremental changes.
    // The setting of fMergeValues affects how we retrieve values.
    // 1. fScopeLegacyLinks is a mechanism to control whether new style values with
    // metadata are visible. Under normal outbound replication of objects and attributes,
    // we want new style values to be invisible. Under normal operation, fMergeValues is
    // false, and thus scope limiting is true.
    // 2. We pass an argument to AddToList to control whether we limit the number of
    // values that may be added. Normally, outbound replication has no value limits
    // and so when fMerge is false, we apply no limits. However, when the replication
    // control is called in the old mode, we want to place some limits.

    if ( sel.AttrTypBlock.attrCount )
    {
        DWORD err = 0;

        pDB->fScopeLegacyLinks = !fMergeValues;
        __try {
            __try {
                // We have at least one property to ship from this object, so add it to
                // the output list.
                // The fifth argument controls whether we limit the number of values added
                // to attributes in the list.
                AddToOutputList(
                    pDB,
                    dwDirSyncControlFlags,
                    pSecurity,
                    &sel,
                    pMetaDataVec,
                    (pDB->DNT == dntNC),
                    hEncoding,
                    pcbTotalOutSize,
                    pppEntInfListNext,
                    pcNumOutputObjects
                    );
            } __finally {
                pDB->fScopeLegacyLinks = FALSE;
            }

            // Add object to hash table.
            dntHashTableInsert( pTHS, pDntHashTable, pDB->DNT, 0 );
        }
        __except (GetDraAnyOneWin32Exception(GetExceptionInformation(), &err, DRAERR_MissingParent)) {

            // An object has been found which has a phantomized parent
            // Do not include the object at the current point in the change stream.
            // Rename the object to lost and found
            // The rename will be found later in the change stream
            moveOrphanToLostAndFound( pDB, dntNC, pMsgIn, pdnObj );
        }
    }
    else {
        DPRINT2(4, "Property-filtered object %ws at usn %I64d\n",
                pdnObj->StringName, usnHighPropUpdateDest);
    }

    // Be heap-friendly.
    THFreeEx(pTHS, pMetaDataVec );
    THFreeEx(pTHS, pdnObj );
    if ( fFreeSD && (pSecurity)) {
        THFreeEx( pTHS, pSecurity );
    }
}


void
AddAnyValuesToOutputList(
    IN      DBPOS *                         pDB,
    IN      DWORD                           dwDirSyncControlFlags,
    IN      PSECURITY_DESCRIPTOR            pSecurity,
    IN      USN                             usnHighPropUpdateDest,
    IN      DRS_MSG_GETCHGREQ_NATIVE *      pMsgIn,
    IN      PARTIAL_ATTR_VECTOR *           pPartialAttrVec,
    IN      handle_t                        hEncoding,              OPTIONAL
    IN OUT  DWORD *                         pcbTotalOutSize,
    IN OUT  ULONG *                         pcAllocatedValues,
    IN OUT  ULONG *                         pcNumValues,
    IN OUT  REPLVALINF **                   ppValues
    )

/*++

Routine Description:

Add the current value to the output array.

It is assumed that the link table is positioned on the value to be added, and
that the object table is positioned on the containing object of the link.

The output list is an array that is grown in chunks as needed.

Source-side filtering is performed, so that a value is not added if
it is not needed.

Arguments:

    pDB - database context
    usnHighPropUpdateDest - destination's directly up to date usn
    pMsgIn - input request message
    pPartialAttrVec - destinations partial attribute vector. Passed when
              destination is a GC
    hEncoding - RPC marshalling encoding buffer, used for calculating sizes
    pcAllocatedValues - Currently allocated size of output array
    pcNumValues - Number of actual values in the array currently
    ppValues - Output array, reallocated as needed
    pcbTotalOutSize - Running total of bytes in output array

Return Value:

    None
    Exceptions raised

--*/

{
    ULONG ulLinkDnt, ulValueDnt, ulLinkBase, ulLinkId;
    ATTCACHE *pAC;
    VALUE_META_DATA valueMetaData;
    REPLVALINF *pReplValInf;
    DSTIME timeDeleted;
    DWORD err, cbReturned;
    GUID uuidObject;
    CHAR szUuid[ SZUUID_LEN ];
    USN usnCursor = 0;
    BOOL fIgnoreWatermarks = FALSE;

    Assert( pcAllocatedValues && pcNumValues && ppValues );

    Assert( pDB->pTHS->fLinkedValueReplication );

    //
    // Gather all the data about the change up front
    //

    // Get the link properties
    // We better be positioned on a value change for this to work
    DBGetLinkTableData( pDB, &ulLinkDnt, &ulValueDnt, &ulLinkBase );
    DPRINT3( 2, "AddAnyValues: linkdnt=%d, valuednt=%d, linkbase=%d\n",
             ulLinkDnt, ulValueDnt, ulLinkBase );

    // Compute which attribute this is
    ulLinkId = MakeLinkId(ulLinkBase);
    pAC = SCGetAttByLinkId(pDB->pTHS, ulLinkId);
    if (!pAC) {
        DRA_EXCEPT(DRAERR_InternalError, DRAERR_SchemaMismatch);
    }

    // get value metadata
    DBGetLinkValueMetaData( pDB, pAC, &valueMetaData );

    // Object table is positioned on containing object, get guid
    err = DBGetSingleValue(pDB, ATT_OBJECT_GUID,
                           &(uuidObject), sizeof(GUID), NULL);
    if (err) {
        DRA_EXCEPT (DRAERR_DBError, err);
    }

    // Get the dest's USN wrt orig of change
    // Get usnCursor only if we are going to log
    if (LogEventWouldLog( DS_EVENT_CAT_REPLICATION, DS_EVENT_SEV_EXTENSIVE )) {
        UpToDateVec_GetCursorUSN(
            pMsgIn->pUpToDateVecDest,
            &(valueMetaData.MetaData.uuidDsaOriginating),
            &usnCursor );
    }

    //
    // Filter the change
    //

    // Filter attribute based on partial attribute set
    if (pPartialAttrVec) {
        if ( ReplFilterGCAttr(
                        pAC->id,
                        pPartialAttrVec,
                        pMsgIn,
                        FALSE,
                        &fIgnoreWatermarks)) {
            DPRINT1( 3, "Attribute %s is not partial attribute set, value filtered\n",
                     pAC->name );
            // Log that value was filtered
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_EXTENSIVE,
                       DIRLOG_LVR_FILTERED_NOT_PAS,
                       szInsertUSN( valueMetaData.MetaData.usnProperty ),
                       szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                       szInsertUUID( &uuidObject ),
                       szInsertSz( pAC->name ),
                       szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                       NULL, NULL, NULL );
            return;
        }

        // need to filter group member only for a GC replication and if the
        // object under consideration satisfies the requirement for this special
        // filtering
        if (ATT_MEMBER == pAC->id) {
            CLASSCACHE *pClassSch;

            // Get object class
            GetObjSchema( pDB, &pClassSch );

            if (IsFilterGroupMember(pDB, pClassSch)) {
                DPRINT1( 3, "Attribute %s is special group member, value filtered\n",
                     pAC->name );
                // Log that value was filtered
                LogEvent8( DS_EVENT_CAT_REPLICATION,
                           DS_EVENT_SEV_EXTENSIVE,
                           DIRLOG_LVR_FILTERED_NOT_GROUP,
                           szInsertUSN( valueMetaData.MetaData.usnProperty ),
                           szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                           szInsertUUID( &uuidObject ),
                           szInsertSz( pAC->name ),
                           szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                           NULL, NULL, NULL );
                return;
            }
        }
    }

    // Does the client already have this value?
    if (!fIgnoreWatermarks &&
        !ReplValueIsChangeNeeded(
            usnHighPropUpdateDest,
            pMsgIn->pUpToDateVecDest,
            &valueMetaData )) {

        DPRINT( 3, "Client already has this change, value filtered\n" );

        // Log that value was filtered
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_FILTERED_NOT_NEEDED,
                   szInsertUSN( valueMetaData.MetaData.usnProperty ),
                   szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
                   szInsertUUID( &uuidObject ),
                   szInsertSz( pAC->name ),
                   szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                   szInsertUSN( usnHighPropUpdateDest ),
                   szInsertUSN( usnCursor ),
                   NULL );

        return;
    }

    //
    // Ship it!
    //

    // Allocate/resize output array as needed
    if (*ppValues == NULL) {
        // Never allocated before
        *pcAllocatedValues = 200;
        *ppValues = THAllocEx( pDB->pTHS,
                               (*pcAllocatedValues) * sizeof( REPLVALINF ) );
    } else if ( (*pcNumValues) == (*pcAllocatedValues) ) {
        // Need to grow array
        *pcAllocatedValues *= 2;
        *ppValues = THReAllocEx( pDB->pTHS,
                                 *ppValues,
                                 (*pcAllocatedValues) * sizeof( REPLVALINF ) );
    }

    pReplValInf = &( (*ppValues)[ (*pcNumValues) ] );

    // Populate the REPLVALINF
    // Fill in the object name depending on what the caller wants
    if (dwDirSyncControlFlags & DRS_DIRSYNC_PUBLIC_DATA_ONLY) {
        // LDAP replication control wants the full name
        // Get its DN, ...
        if ( DBGetAttVal(
            pDB,
            1,
            ATT_OBJ_DIST_NAME,
            DBGETATTVAL_fREALLOC,
            0,
            &cbReturned,
            (LPBYTE *) &( pReplValInf->pObject )
            ) )
        {
            DRA_EXCEPT(DRAERR_DBError, 0);
        }

    } else {
        // Client is another DSA: needs the GUID only
        pReplValInf->pObject = THAllocEx( pDB->pTHS, DSNameSizeFromLen( 0 ) );
        memcpy( &(pReplValInf->pObject->Guid), &uuidObject, sizeof( GUID ) );
        pReplValInf->pObject->structLen = DSNameSizeFromLen( 0 );
    }

    // Check whether containing attribute is readable
    if (dwDirSyncControlFlags & DRS_DIRSYNC_OBJECT_SECURITY) {
        DWORD       cInAtts;
        ATTCACHE    *rgpAC[1];
        ATTRTYP     classid;
        CLASSCACHE *pCC;
        ULONG ulLen;

        Assert( pReplValInf->pObject->NameLen );  // Need a name
        Assert( pSecurity );

        // Get the class cache value
        err = DBGetSingleValue(pDB, ATT_OBJECT_CLASS,
                               &classid, sizeof(classid), NULL);
        if (err) {
            DRA_EXCEPT (DRAERR_DBError, err);
        }
        pCC = SCGetClassById(pDB->pTHS, classid);
        if (!pCC) {
            DRA_EXCEPT (DRAERR_DBError, ERROR_DS_OBJECT_CLASS_REQUIRED);
        }

        cInAtts = 1;
        rgpAC[0] = pAC;
    
        CheckReadSecurity(pDB->pTHS,
                          0,
                          pSecurity,
                          pReplValInf->pObject,
                          &cInAtts,
                          pCC,
                          rgpAC);
        if (rgpAC[0] == NULL) {
            // Value is not visible
            DPRINT2( 0, "Attribute %s is not visible: value %s not returned.\n",
                     pAC->name,
                     DBGetExtDnFromDnt( pDB, ulValueDnt ) );
            return;
        }
    }


    DPRINT2( 2, "AddAnyValues, Adding guid %s as REPLVALINF[%d]\n",
             DsUuidToStructuredString(&(pReplValInf->pObject->Guid), szUuid),
             *pcNumValues );
    DPRINT1( 2, "Value retrieved: %s\n", DBGetExtDnFromDnt( pDB, ulValueDnt ) );

    pReplValInf->attrTyp = pAC->id;

    // Get the currently positioned value.
    // Since we do the positioning, we don't want the dblayer to do it too.
    // Specify a sequence of zero to indicate it doesn't need to move.
    // pReplValInf->Aval is zero'd already
    err = DBGetNextLinkValEx_AC( pDB,
                                 FALSE /*notfirst*/,
                                 0, // Use currently positioned value
                                 &pAC, // Attribute
                                 0, // Flags
                                 0, // In buff size
                                 &(pReplValInf->Aval.valLen), // pLen
                                 &(pReplValInf->Aval.pVal) // ppVal
        );
    if (err) {
        DRA_EXCEPT (DRAERR_DBError, err);
    }

    DBGetLinkTableDataDel( pDB, &timeDeleted );
    pReplValInf->fIsPresent = (timeDeleted == 0);

    // Convert to external form
    pReplValInf->MetaData.timeCreated = valueMetaData.timeCreated;
    pReplValInf->MetaData.MetaData.dwVersion = valueMetaData.MetaData.dwVersion;
    pReplValInf->MetaData.MetaData.timeChanged = valueMetaData.MetaData.timeChanged;
    pReplValInf->MetaData.MetaData.uuidDsaOriginating =
        valueMetaData.MetaData.uuidDsaOriginating;
    pReplValInf->MetaData.MetaData.usnOriginating = valueMetaData.MetaData.usnOriginating;

    // Update count and continuation ref.
    (*pcNumValues)++;

    //TODO: Add counter for linked values
    PERFINC(pcDRAPropShipped);

    if ((NULL != hEncoding) && (NULL != pcbTotalOutSize)) {
        // Update byte count of return message.
        *pcbTotalOutSize += REPLVALINF_AlignSize(hEncoding, pReplValInf );
    }

    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_LVR_SHIPPED,
               szInsertUSN( valueMetaData.MetaData.usnProperty ),
               szInsertSz( GetExtDN( pDB->pTHS, pDB ) ),
               szInsertUUID( &uuidObject ),
               szInsertSz( pAC->name ),
               szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
               szInsertUSN( usnHighPropUpdateDest ),
               szInsertUSN( usnCursor ),
               NULL );

} /* AddAnyValuesToOutputList */

extern CRITICAL_SECTION csRidFsmo;
BOOL                    gfRidFsmoLocked = FALSE;
DWORD                   gdwRidFsmoLockHolderThreadId;

// Acquire the RID FSMO lock for a given domain or return an
// appropriate WIN32 error code.  Needs improvement to handle
// multiple domains per DC.

// N.B. The reason we spin/wait rather than block on the critical
// section is that cross domain move must hold the lock while going
// off machine.  A spin/wait algorithm insures that no one is
// blocked forever as can happen with remoted RPC calls.

ULONG
AcquireRidFsmoLock(
    DSNAME  *pDomainDN,
    int     msToWait)
{
    ULONG   retVal = 1;
    int     waitInterval = 0;

    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));

    do {
        EnterCriticalSection(&csRidFsmo);

        if ( waitInterval < 500 ) {
            // Wait 50 ms longer each time so that initial latency is low.
            waitInterval += 50;
        }

        if ( !gfRidFsmoLocked ) {
            retVal = 0;
            gdwRidFsmoLockHolderThreadId = GetCurrentThreadId();
            gfRidFsmoLocked = TRUE;
            LeaveCriticalSection(&csRidFsmo);
            break;
        }

        LeaveCriticalSection(&csRidFsmo);
        Sleep((waitInterval < msToWait) ? waitInterval : msToWait);
        msToWait -= waitInterval;
    }
    while ( msToWait > 0 );

    return(retVal);
}

// Release the RID FSMO lock for a given domain.  Needs improvement to
// handle multiple domains per DC.

VOID
ReleaseRidFsmoLock(
    DSNAME *pDomainDN)
{
    BOOL    fLockHeldByMe;

    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));
    EnterCriticalSection(&csRidFsmo);
    fLockHeldByMe = IsRidFsmoLockHeldByMe();
    gfRidFsmoLocked = FALSE;
    LeaveCriticalSection(&csRidFsmo);
    Assert(fLockHeldByMe);
}

BOOL
IsRidFsmoLockHeldByMe()
{
    BOOL    fRetVal;

    EnterCriticalSection(&csRidFsmo);
    fRetVal = (    gfRidFsmoLocked
                && (GetCurrentThreadId() == gdwRidFsmoLockHolderThreadId) );
    LeaveCriticalSection(&csRidFsmo);
    return(fRetVal);
}

ULONG
GetProxyObjects(
    DSNAME      *pDomainDN,
    HANDLE      hList,
    USN_VECTOR  *pusnvecFrom)
/*++
  Routine Description:

    Adds to hlist all the proxy objects which move with the RID FSMO.
    We prevent two replicas of a domain from moving their respective
    copies of an object to two different domains concurrently by:

        1) A RID FSMO lock is held while performing the move - specifically
           while transitioning from a real object to a phantom.

        2) All proxy objects are created in the infrastructure container.
           This makes them easy to find for step (3).

        3) All proxy objects move with the RID FSMO.  Since the destination
           of the FSMO transfer must apply all the changes that came with the
           FSMO before claiming FSMO ownership, it will end up phantomizing
           any object which has already been moved of the prior FSMO role
           owner.  Thus there is no local object to move anymore and the
           problem is prevented.  See logic in ProcessProxyObject in ..\dra
           for how we deal with objects that are moved out and then back
           in to the same domain.

    This routine finds the proxy objects which need to move.

  Arguments:

    pDomainDN - DSNAME of domain whose objects we need to ship.

    hList - HANDLE for FSMOlist which will hold the object names.

    pusnvecFrom - Pointer to the destination's USN_VECTOR with respect to us.

  Return Value:

    0 on success, !0 otherwise.
    May throw exceptions.
--*/
{
    THSTATE     *pTHS = pTHStls;
    FSMOlist    *pList = (FSMOlist *) hList;
    ATTRTYP     objClass = CLASS_INFRASTRUCTURE_UPDATE;
    FILTER      andFilter, classFilter, proxyFilter, usnFilter;
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    ENTINFLIST  *pEntInfList;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));  // product 1 assert.

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&selection, 0, sizeof(selection));

    memset(&andFilter, 0, sizeof (andFilter));
    memset(&classFilter, 0, sizeof (classFilter));
    memset(&proxyFilter, 0, sizeof (proxyFilter));
    memset(&usnFilter, 0, sizeof (usnFilter));

    // We note that proxy objects do not become visible until they have been
    // both created and deleted.  In addition, proxy objects are the only
    // CLASS_INFRASTRUCTURE_UPDATE objects with ATT_PROXIED_OBJECT_NAME
    // properties.  Thus, we can quickly get the list of objects the
    // destination needs by searching:

    //  - under the infrastructure container
    //  - match on object category
    //  - existence of a proxy value
    //  - usn changed > than destination's usnHighObjUpdate


    // class filter
    // Can't use object category as that is stripped on delete.  Efficiency
    // not an issue as we'll use the PDNT index due to SE_CHOICE_IMMED_CHLDRN.
    classFilter.pNextFilter = NULL;
    classFilter.choice = FILTER_CHOICE_ITEM;
    classFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    classFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    classFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(objClass);
    classFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) &objClass;

    // existence of proxy value filter
    proxyFilter.pNextFilter = &classFilter;
    proxyFilter.choice = FILTER_CHOICE_ITEM;
    proxyFilter.FilterTypes.Item.choice = FI_CHOICE_PRESENT;
    proxyFilter.FilterTypes.Item.FilTypes.present = ATT_PROXIED_OBJECT_NAME;

    // usn filter
    usnFilter.pNextFilter = &proxyFilter;
    usnFilter.choice = FILTER_CHOICE_ITEM;
    usnFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    usnFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USN_CHANGED;
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                    sizeof(pusnvecFrom->usnHighObjUpdate);
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                    (UCHAR *) &pusnvecFrom->usnHighObjUpdate;

    // AND filter
    andFilter.pNextFilter = NULL;
    andFilter.choice = FILTER_CHOICE_AND;
    andFilter.FilterTypes.And.count = 3;
    andFilter.FilterTypes.And.pFirstFilter = &usnFilter;

    // selection
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    // search arg
    if ( !gAnchor.pInfraStructureDN ) {
        return(1);
    }

    searchArg.pObject = THAllocEx(pTHS, gAnchor.pInfraStructureDN->structLen);
    memcpy(searchArg.pObject,
           gAnchor.pInfraStructureDN,
           gAnchor.pInfraStructureDN->structLen);
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &andFilter;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);
    searchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;

    SearchBody(pTHS, &searchArg, &searchRes, 0);
    if ( pTHS->errCode ) {
        return(1);
    } else if ( 0 == searchRes.count ) {
        return(0);
    }

    pEntInfList = &searchRes.FirstEntInf;
    while ( pEntInfList )
    {
        FSMORegisterObj(pTHS, hList, pEntInfList->Entinf.pName);
        pEntInfList = pEntInfList->pNextEntInf;
    }

    return(0);
}

ULONG
GetDomainRoleTransferObjects(
    THSTATE     *pTHS,
    HANDLE      hList,
    USN_VECTOR  *pusnvecFrom)
/*++
  Routine Description:

    Adds to hlist all the objects required for Domain role transfer.


  Arguments:

    hList - HANDLE for FSMOlist which will hold the object names.

    pusnvecFrom - Pointer to the destination's USN_VECTOR with respect to us.

  Return Value:

    0 on success, !0 otherwise.
    May throw exceptions.
--*/
{
    FSMOlist    *pList = (FSMOlist *) hList;
    ATTRTYP     objClass = CLASS_INFRASTRUCTURE_UPDATE;
    FILTER      usnFilter;
    SEARCHARG   searchArg;
    SEARCHRES   searchRes;
    ENTINFSEL   selection;
    ENTINFLIST  *pEntInfList;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&selection, 0, sizeof(selection));

    memset(&usnFilter, 0, sizeof (FILTER));

    // We need to send along all the cross refs, which is basically all
    // the objects immediately under the partitions container.

    // usn filter
    usnFilter.pNextFilter = NULL;
    usnFilter.choice = FILTER_CHOICE_ITEM;
    usnFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    usnFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USN_CHANGED;
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                    sizeof(pusnvecFrom->usnHighObjUpdate);
    usnFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                    (UCHAR *) &pusnvecFrom->usnHighObjUpdate;

    // selection
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    searchArg.pObject = THAllocEx(pTHS, gAnchor.pPartitionsDN->structLen);
    memcpy(searchArg.pObject,
           gAnchor.pPartitionsDN,
           gAnchor.pPartitionsDN->structLen);
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &usnFilter;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);

    SearchBody(pTHS, &searchArg, &searchRes, 0);
    if ( pTHS->errCode ) {
        return(1);
    } else if ( 0 == searchRes.count ) {
        return(0);
    }

    pEntInfList = &searchRes.FirstEntInf;
    while ( pEntInfList )
    {
        FSMORegisterObj(pTHS, hList, pEntInfList->Entinf.pName);
        pEntInfList = pEntInfList->pNextEntInf;
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drameta.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drameta.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines all per-property meta-data parsing,
    and updating functions.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support
#include <limits.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include "dsutil.h"        // DSTIMEtoDisplayString

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAMETA:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drametap.h"
#include "drasch.h"
#include "drancrep.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMETA

// The number of entries we grow the meta data vector by on each
// (re-)allocation.
#define MDV_ENTRIES_TO_GROW     ( 20 )

#define ReplIsReqAttr(attrtyp) (    (ATT_INSTANCE_TYPE == (attrtyp)) \
                                 || (ATT_PROXIED_OBJECT_NAME == (attrtyp)) )
#define g_cReqAttr (2)

//
// Forward declarations
//
BOOL
ReplIsNonShippedAttr(
    THSTATE *pTHS,
    ATTRTYP rdnType,
    ATTRTYP attrtyp
    );


BOOL
ReplValueIsChangeNeeded(
    IN USN usnPropWaterMark,
    IN UPTODATE_VECTOR *pUpTodateVecDest,
    VALUE_META_DATA *pValueMetaData
    )

/*++

Routine Description:

    Test whether a given value is needed at the destination according to the
    incoming USN, Up-To-Dateness Vector, and local metadata.

Arguments:

    usnPropWaterMark - dest's directly up to date usn
    pUpTodateVecDest - dest's UTD vector
    pValueMetaData - value metadata to check

Return Value:

    BOOL -

--*/

{
    if ( (usnPropWaterMark >= pValueMetaData->MetaData.usnProperty) ||
         (!UpToDateVec_IsChangeNeeded(pUpTodateVecDest,
                                      &pValueMetaData->MetaData.uuidDsaOriginating,
                                      pValueMetaData->MetaData.usnOriginating)) ) {
        // Log that change is not needed
        return FALSE;
    } else {
        // Log that change is needed
        return TRUE;
    }
} /* ReplValueIsChangeNeeded */


BOOL
ReplFilterGCAttr(
    IN  ATTRTYP                     attid,             
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrVec,   
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,            
    IN  BOOL                        fFilterGroupMember,
    OUT BOOL *                      pfIgnoreWatermarks 
    )
/*++

Routine Description:

    Global Catalog attribute filtering:
      - Should the attribute should be filtered?
      - Or should just the watermarks be reset for
        further evaluation?

Arguments:

    attid - attribute id to be evaluated
    pPartialAttrVec - generated PAS (base+extended in PAS cycles)
    pMsgIn - input request
    pfIgnoreWatermarks - decision for PAS cycles whether to ignore watermarks


Return Value:

    TRUE - filter it, ie don't include it
    FALSE - don't filter, include it

    pfIgnoreWatermarks is set to TRUE only if attid is in
    the extended set.

Remarks:



--*/
{


    // param sanity
    Assert(pPartialAttrVec &&
           pMsgIn &&
           pfIgnoreWatermarks)

    // default: don't ignore watermarks
    *pfIgnoreWatermarks = FALSE;

    // EITHER not member of set
    if ( !GC_IsMemberOfPartialSet( pPartialAttrVec, attid, NULL)  ||
         // OR explicit request to filter member attr
         (fFilterGroupMember && (ATT_MEMBER == attid)))

    {
        DPRINT1(3, "Filtered property %d due to PAS/group membership condition\n",
                attid);
        return TRUE;
    }

    if (pMsgIn->pPartialAttrSetEx &&
        GC_IsMemberOfPartialSet(
            (PARTIAL_ATTR_VECTOR*)pMsgIn->pPartialAttrSetEx,
            attid,
            NULL)) {
            // PAS replication: Attribute is in the extended set
            //  - zero out usnPropWatermark & UTD.
            Assert(pMsgIn->ulFlags & DRS_SYNC_PAS);
            DPRINT1(3, "Fixed usn & UTD for property %d to zero.\n", attid);
            *pfIgnoreWatermarks = TRUE;
    }

    // don't filter out this property
    return FALSE;
}




/*************************************************************************************
Routine Description:

    This routine parses an array of property meta data of an object and identifies
    all properties that are changed after the given water mark.

Arguments:
    pDSName - DSName of the object (used only for logging)
    rdnType - rdnType for this object
    fIsSubRef - is this object a subref of the NC we're replicating?
    fIsObjCreation - are we replicating the creation of this object?
    usnObjCreate - USN corresponding to the creation of the object
    usnPropWaterMark - USN beyond which we want to identify the changes
    pUpTodateVecDest - points tothe up-to-date vector of the destination DSA
    puuidDsaObjDest - points to the ntdsDsa objectGuid of the destination DSA
                        (used only for logging)
    pMetaData - points to the property meta-data of the object
    pAttrBlock - points to the ATTRBLOCK structure that would receive the list of
                    attributes to be shipped
    fFilterGroupMember - tells if the group member property should be explicitly
                            filtered
    pMsgIn - replication message for additional processing info

Return Value:

    None.  Throws appropriate exception on error.
**************************************************************************************/
void
ReplFilterPropsToShip(
    IN  THSTATE *                   pTHS,              
    IN  DSNAME *                    pDSName,           
    IN  ATTRTYP                     rdnType,
    IN  BOOL                        fIsSubRef,          
    IN  USN                         usnPropWaterMark,   
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrVec,   
    IN  PROPERTY_META_DATA_VECTOR * pMetaData,         
    OUT ATTRBLOCK *                 pAttrBlock,        
    IN  BOOL                        fFilterGroupMember, 
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn
    )
{
    ULONG           i;
    BOOL            fShip = FALSE;
    BOOL            fShipEval;      // temp to simplify alg readability
    BOOL            fIgnoreWatermarks = FALSE;
    UUID            *puuidDsaObjDest = &pMsgIn->uuidDsaObjDest;

    if (!pDSName || !puuidDsaObjDest || !pMetaData || !pAttrBlock)
    {
        DRA_EXCEPT( DRAERR_InvalidParameter, 0 );
    }

    VALIDATE_META_DATA_VECTOR_VERSION(pMetaData);

    // The pAttr array of pAttrBlock is used by ReplPrepareDataToShip() as part
    // of ENTINFSEL structure we use as an output buffer, so we can't reuse any
    // pre-existing allocation.
    pAttrBlock->pAttr = THAllocEx(pTHS, pMetaData->V1.cNumProps * sizeof(ATTR));
    pAttrBlock->attrCount = 0;

    // for each entry of the meta data determine if the corresponding property
    // needs to be shipped
    for (i = 0; i < pMetaData->V1.cNumProps; i++)
    {
        // Property need not be shipped if any of the following conditions are met:
        // a) a partial set is specified and it is not one of the attributes in the
        //    partial set or it is group member attribute to be filtered
        // b) property changed prior  to prop water mark mentioned by the
        //    destination,
        // c) the property chage is already seen by the destination, or
        // d) it is one of the non-shipped attributes.
        // e) Partial Attr Set replication evaluation (see details below)
        //

        // Assume we ship this property-- Then negate as we find reasons not to.
        fShipEval = TRUE;


        // partial attr vector test
        // this vector can be the combined base+extended PAS vectors in PAS cycles
        if ( pPartialAttrVec )
        {
            fShipEval = !ReplFilterGCAttr(
                            pMetaData->V1.rgMetaData[i].attrType,
                            pPartialAttrVec,
                            pMsgIn,
                            fFilterGroupMember,
                            &fIgnoreWatermarks);

        }

        if ( fShipEval && !fIgnoreWatermarks &&
             (usnPropWaterMark >= pMetaData->V1.rgMetaData[i].usnProperty ||
              ReplIsNonShippedAttr(pTHS, rdnType, pMetaData->V1.rgMetaData[i]. attrType) ||
              !UpToDateVec_IsChangeNeeded(
                    pMsgIn->pUpToDateVecDest,
                    &pMetaData->V1.rgMetaData[i].uuidDsaOriginating,
                    pMetaData->V1.rgMetaData[i].usnOriginating) ) )

        {
            DPRINT1(3, "Filtered property %d due to watermark/UTD/schema condition\n",
                    pMetaData->V1.rgMetaData[i].attrType);
            fShipEval = FALSE;
        }


        if ( !fShipEval )
        {
            //
            // We're not shipping this attribute unless it is required
            //

            if (ReplIsReqAttr(pMetaData->V1.rgMetaData[i].attrType))
            {
                // This property doesn't have any new change, but still we will
                // have to ship this property as it is a required property
                pAttrBlock->pAttr[pAttrBlock->attrCount++].attrTyp = pMetaData->V1.rgMetaData[i].attrType;
            }
            else
            {
                CHAR  buf[150];

                LogEvent8(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_VERBOSE,
                          DIRLOG_DRA_PROPERTY_FILTERED,
                          szInsertAttrType(pMetaData->V1.rgMetaData[i].attrType,buf),
                          szInsertDN(pDSName),
                          szInsertUUID(&pDSName->Guid),
                          szInsertUUID(puuidDsaObjDest),
                          NULL, NULL, NULL, NULL);
                continue;
            }
        }
        else
        {
            CHAR  buf[150];

            // we are shipping this property because the destination hasn't seen it
            fShip = TRUE;

            // This property should be shipped - add it to the ATTRBLOCK
            pAttrBlock->pAttr[pAttrBlock->attrCount++].attrTyp = pMetaData->V1.rgMetaData[i].attrType;

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_NOT_FILTERED,
                      szInsertAttrType(pMetaData->V1.rgMetaData[i].attrType,buf),
                      szInsertDN(pDSName),
                      szInsertUUID(&pDSName->Guid),
                      szInsertUUID(puuidDsaObjDest),
                      NULL, NULL, NULL, NULL);
        }

    }

    // Note that if a subref is found by our USN search we will always
    // send its required attributes, even if no other attributes need to be
    // shipped.  This is to ensure that the SUBREF object is shipped to the
    // target DSA, even if that DSA is the one that sent it to use in the first
    // place.  This is required such that the target DSA can properly set the
    // Instance-Type of the object to include IT_NC_ABOVE (and properly modify
    // its NCDNT).
    //
    // To illustrate:
    //
    // Consider an enterprise composed of machines A and B, each in a seperate
    // domain.  A holds the parent domain; B, the child domain.  Initially,
    // replication has quiesced and neither machine is a GC.  This implies
    // the NC head for B's domain on B has an Instance-Type that does _not_
    // include IT_NC_ABOVE, as it does not hold a copy of domain A.  This
    // also implies that A has a SUBREF for B's domain.
    //
    // A is promoted to be a GC.  It replaces its SUBREF for B's domain with
    // the real NC head for B.
    //
    // B is then promoted to be a GC.  In doing so, it requests changes for
    // A's domain from A.  Since A got the NC_FULL_REPLICA_SUBREF for B's
    // domain from B, propagation dampening filters it out and it never gets
    // to B.  Thus, B never "realizes" the head of it own domain NC should
    // have the IT_NC_ABOVE bit set, as it never sees the object replicated
    // from A's domain corresponding to it.  (This logic to change the
    // Instance-Type on child NC heads when replicated a corresponding
    // SUBREF exists in UpdateRepObj().)
    //
    // Thus, we always send at least a minimal SUBREF if we're replicating its
    // creation.

    if (!fShip && !fIsSubRef)
    {
        // no property needs to be shipped, attrCount might still be non-zero due to the
        // addition of required attributes in the loop. But require attributes need to be
        // shipped only if there is at least one genuinely modified attribute exists.
        THFreeEx(pTHS, pAttrBlock->pAttr);
        pAttrBlock->attrCount = 0;
        pAttrBlock->pAttr = NULL;

        PERFINC(pcDRAOutObjsFiltered);
    }
    else
    {
        Assert(pAttrBlock->attrCount > 0);

        if (pAttrBlock->attrCount != pMetaData->V1.cNumProps) {
            // We're not shipping the whole object, so free the portion of the
            // ATTRBLOCK we're not using.
            pAttrBlock->pAttr = THReAllocEx(pTHS, pAttrBlock->pAttr,
                                            pAttrBlock->attrCount * sizeof(ATTR));
        }

        PERFINC(pcDRAObjShipped);

        IADJUST(pcDRAPropShipped, ((LONG) pAttrBlock->attrCount));
    }
}


/*************************************************************************************
Routine Description:
    Decides whether or not an attribute type is not to be shipped during replication

Arguments:
    attrType - the attribute type to check.

Return Value:
    TRUE if the attribute is Not to be shipped, false otherwise.
**************************************************************************************/
BOOL
ReplIsNonShippedAttr(THSTATE *pTHS,
                     ATTRTYP rdnType,
                     ATTRTYP attrtyp)
{
    ATTCACHE *pAC = NULL;

    pAC = SCGetAttById(pTHS, attrtyp);
    if (NULL == pAC)
    {
        DRA_EXCEPT(DRAERR_SchemaMismatch, attrtyp);
    }

    if (pAC->bIsNotReplicated) {
        return TRUE;
    }

    // RDN att should not be shipped
    // A superceding class may have an rdnattid that is different
    // from the object's rdnType. Use the rdnType from the object
    // and not the rdnattid from the class. 
    if ( rdnType == attrtyp ) {
        return TRUE;
    }

    // Some useful LVR debugging output
#if DBG
    if ( (pAC->ulLinkID) && (pTHS->fLinkedValueReplication) ) {
        DPRINT2( 1, "Source returning a legacy attribute change for object %s attribute %s\n",
                 GetExtDN( pTHS, pTHS->pDB), pAC->name );
    }
#endif

    // Attribute will be shipped
    return FALSE;
}

/*************************************************************************************
Routine Description:

    This routine creates a new unique RDN Attr using the given RDN and suffixing it
    with the string form of the given GUID. If the length of given RDN is too long
    to suffix a GUID the given RDN is truncated so that the new length doesn't exceed
    MAX_RDN_SIZE.

Arguments:
    pTHS - local thread state.
    pAttrRDN - pointer to the RDN Attr.
    pGuid - pointer to the object Guid

Return Value:
    None.
**************************************************************************************/
void
ReplMorphRDN(
    IN      THSTATE *   pTHS,
    IN OUT  ATTR *      pAttrRDN,
    IN      GUID *      pGuid
    )
{
    BYTE *    pbOldRDN;
    DWORD     cchRDN;

    pbOldRDN = pAttrRDN->AttrVal.pAVal->pVal;

    // Make sure we have enough room to store the largest RDN we could
    // construct.  Note that we throw away the old allocation; we don't know
    // for sure that it was thread-allocated.  (It might be in an RPC buffer.)
    pAttrRDN->AttrVal.pAVal->pVal = THAllocEx(pTHS, sizeof(WCHAR)*MAX_RDN_SIZE);

    memcpy(pAttrRDN->AttrVal.pAVal->pVal,
           pbOldRDN,
           pAttrRDN->AttrVal.pAVal->valLen);

    cchRDN = pAttrRDN->AttrVal.pAVal->valLen / sizeof(WCHAR);

    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              pGuid,
              (WCHAR *) pAttrRDN->AttrVal.pAVal->pVal,
              &cchRDN);

    pAttrRDN->AttrVal.pAVal->valLen = cchRDN * sizeof(WCHAR);
}


PROPERTY_META_DATA *
ReplLookupMetaData(
    IN  ATTRTYP                     attrtyp,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVec,
    OUT DWORD *                     piProp          OPTIONAL
    )
/*++

Routine Description:

    Find the meta data for the given attribute in the meta data vector.
    Optionally returns the index at which the entry was found, or, if the
    corresponding meta data is absent, the index at which the entry would be
    inserted to preserve the sort order.

Arguments:

    attrtyp - Attribute to search for.
    pMetaDataVec - Meta data vector to search.
    piProp (OUT) - If non-NULL, on return holds the index at which the meta data
        was found in the vector or, if absent, the index at which meta data for
        this attribute would be inserted to preserve the sort order.

Return Values:

    NULL - No pre-existing meta data for this attribute was found in the vector.
    non-NULL - A pointer to the pre-existing meta data for this attribute.

--*/
{
    BOOL        fFound;
    LONG        iPropBegin;
    LONG        iPropEnd;
    LONG        iPropCurrent;
    int         nDiff;

#if DBG
    ATTCACHE *  pAC;

    // We shouldn't be looking for meta data for non-replicated attributes.
    pAC = SCGetAttById(pTHStls, attrtyp);
    Assert((NULL != pAC) && !pAC->bIsNotReplicated);
#endif

    fFound = FALSE;
    iPropCurrent = 0;

    if ( NULL != pMetaDataVec )
    {
        iPropBegin = 0;
        iPropEnd   = pMetaDataVec->V1.cNumProps - 1;

        // Find meta data entry corresponding to the given attribute.
        while ( !fFound && ( iPropEnd >= iPropBegin ) )
        {
            iPropCurrent = ( iPropBegin + iPropEnd ) / 2;

            nDiff = CompareAttrtyp(&attrtyp, &pMetaDataVec->V1.rgMetaData[ iPropCurrent ].attrType);

            if ( nDiff < 0 )
            {
                if ( iPropEnd != iPropBegin )
                {
                    // Further narrow search.
                    iPropEnd = iPropCurrent - 1;
                }
                else
                {
                    // Entry not found; it should be inserted before this entry.
                    break;
                }
            }
            else if ( nDiff > 0 )
            {
                if ( iPropEnd != iPropBegin )
                {
                    // Further narrow search.
                    iPropBegin = iPropCurrent + 1;
                }
                else
                {
                    // Entry not found; it should be inserted after this entry.
                    iPropCurrent++;
                    break;
                }
            }
            else
            {
                // Found it.
                fFound = TRUE;
            }
        }
    }

    if ( NULL != piProp )
    {
        *piProp = iPropCurrent;
    }

    return fFound ? &pMetaDataVec->V1.rgMetaData[ iPropCurrent ] : NULL;
}

PROPERTY_META_DATA *
ReplInsertMetaData(
    IN      THSTATE                       * pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced,
    OUT     BOOL *                          pfIsNewElement          OPTIONAL
    )
/*++

Routine Description:

    Returns a pointer to the pre-existing meta data for the given attribute in
    the vector, or, if none exists, inserts new meta data in the vector for this
    attribute.

    If an entry is inserted, its elements will be nulled with the exception of
    the attribute type, which will be set to that passed as an argument.

Arguments:

    attrtyp (IN) - Attribute for which meta data is to be found or inserted.
    ppMetaDataVec (IN/OUT) - The current meta data vector.
    pcbMetaDataVecAlloced (IN/OUT) - The allocated size of the meta data vector.
    pfIsNewElement (OUT) - If present, holds TRUE if the returned meta data
        was inserted, or FALSE if meta data was already present.

Return Values:

    Pointer to the meta data for the given attribute.  (Never NULL.)

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   iProp;

    pMetaData = ReplLookupMetaData( attrtyp, *ppMetaDataVec, &iProp );

    if ( NULL != pfIsNewElement )
    {
        *pfIsNewElement = ( NULL == pMetaData );
    }

    if ( NULL == pMetaData )
    {
        // No pre-existing meta data found for this attribute.

        // We need to expand the vector and insert a new entry for this
        // attribute.

        // Is there enough memory allocated for the vector to grow an entry
        // in-place?
        if (    ( NULL == *ppMetaDataVec )
             || (   *pcbMetaDataVecAlloced
                  < MetaDataVecV1SizeFromLen( (*ppMetaDataVec)->V1.cNumProps + 1 )
                )
           )
        {
            // No, we must (re-)allocate memory for the vector.

            // Allocate more than we need right now to cut down on the number of
            // reallocations we'll potentially have to do later.

            DWORD cbNewSize;

            if ( NULL == *ppMetaDataVec )
            {
                // Allocate new vector.
                Assert( 0 == *pcbMetaDataVecAlloced );

                cbNewSize = MetaDataVecV1SizeFromLen( MDV_ENTRIES_TO_GROW );
                *ppMetaDataVec = THAllocEx(pTHS,  cbNewSize );

                (*ppMetaDataVec)->dwVersion = VERSION_V1;
                (*ppMetaDataVec)->V1.cNumProps = 0;

            }
            else
            {
                // Reallocate pre-existing vector.
                Assert( 0 != *pcbMetaDataVecAlloced );

                cbNewSize = MetaDataVecV1SizeFromLen(
                                (*ppMetaDataVec)->V1.cNumProps
                                    + MDV_ENTRIES_TO_GROW
                                );
                *ppMetaDataVec = THReAllocEx(pTHS, *ppMetaDataVec, cbNewSize );
            }

            *pcbMetaDataVecAlloced = cbNewSize;
        }

        pMetaData = &(*ppMetaDataVec)->V1.rgMetaData[ iProp ];

        // Shift up all entries after the index at which we're inserting.
        MoveMemory( pMetaData + 1,
                    pMetaData,
                    (   sizeof( PROPERTY_META_DATA )
                      * ( (*ppMetaDataVec)->V1.cNumProps - iProp ) ) );
        (*ppMetaDataVec)->V1.cNumProps++;

        // Initialize meta data for new attribute.
        memset( pMetaData, 0, sizeof( *pMetaData ) );
        pMetaData->attrType = attrtyp;
    }

    Assert( NULL != pMetaData );

// Check for metadata corruption
// These checks are looser than the corresponding checks in dbmeta.c: these checks
// occur before the meta data vector is completely filled in.
#if DBG
    {
        USN localHighestUsn = gusnEC;

        for( iProp = 0; iProp < (*ppMetaDataVec)->V1.cNumProps; iProp++ ) {
            PROPERTY_META_DATA *pTestMetaData =
                &((*ppMetaDataVec)->V1.rgMetaData[ iProp ]);
            if ((pTestMetaData->usnProperty == USN_PROPERTY_TOUCHED) || (pTestMetaData->usnProperty == USN_PROPERTY_GCREMOVED))
            {
                // Contents indeterminate, will be rewritten
                continue;
            }
            if ( (pTestMetaData == pMetaData) && (pTestMetaData->usnProperty == 0) )
            {
                // New record, initialized to zero
                continue;
            }
            // Should be properly constructed
            // For a replicated write, usnProperty is zero until flush-time
            Assert( (pTestMetaData->usnProperty >= 0) &&
                    (pTestMetaData->usnProperty < localHighestUsn) );
            // Assert( pTestMetaData->dwVersion ); // fails for underriden metadata
            Assert( pTestMetaData->timeChanged );

            Assert( pTestMetaData->usnOriginating );
        }
    }
#endif

    return pMetaData;
}

void
ReplOverrideMetaData(
    IN      ATTRTYP                     attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVec
    )
/*++

Routine Description:

    Override the meta data assoicated with the given attribute such that it is
    marked as an originating write on the local machine that will win
    reconciliation over the current meta data.

Arguments:

    attrtyp (IN) - Attribute for which to override meta data.

    pMetaDataVec (IN/OUT) - Vector containing the meta data to override.

Return Values:

    None.  Generates DRA exception if no meta data for the attribute currently
    exists.

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   iProp;

    // Find the meta data for this attribute.
    pMetaData = ReplLookupMetaData(attrtyp, pMetaDataVec, &iProp);

    if (NULL != pMetaData) {
        // Meta data is present for this attribute.  Flag it so we'll know to
        // override it in dbFlushMetaDataVector().
        pMetaData->usnProperty = USN_PROPERTY_TOUCHED;
    }
    else {
        DRA_EXCEPT(DRAERR_InternalError, (UINT_PTR) pMetaDataVec);
    }
}


void
ReplUnderrideMetaData(
    IN      THSTATE *                     pTHS,
    IN      ATTRTYP                       attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **  ppMetaDataVec,
    IN OUT  DWORD *                       pcbMetaDataVecAlloced    OPTIONAL
    )
/*++

Routine Description:

    Underride the meta data assoicated with the given attribute such that it
    will always lose when compared against a "real" change to the attribute.

Arguments:

    pTHS (IN)

    attrtyp (IN) - Attribute for which to override meta data.

    ppMetaDataVec (IN/OUT) - Vector containing the meta data to underride.

    pcbMetaDataVecAlloced (IN/OUT, OPTIONAL) - Size in bytes of the buffer
        allocated for *ppMetaDataVec.

Return Values:

    None.

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   cbMetaDataVecAlloced = 0;

    if (NULL == pcbMetaDataVecAlloced) {
        // No buffer size specified.  Assume the buffer is just large enough to
        // hold the vector.
        cbMetaDataVecAlloced = *ppMetaDataVec
                                    ? (DWORD)MetaDataVecV1Size(*ppMetaDataVec)
                                    : 0;
        pcbMetaDataVecAlloced = &cbMetaDataVecAlloced;
    }

    // Find/insert the meta data for this attribute.
    pMetaData = ReplInsertMetaData(pTHS,
                                   attrtyp,
                                   ppMetaDataVec,
                                   pcbMetaDataVecAlloced,
                                   NULL);

    // Flag the meta data such that when we get ready to commit the change
    // we'll know what to do.  (See dbFlushMetaDataVector().)
    pMetaData->usnProperty = USN_PROPERTY_TOUCHED;
    pMetaData->dwVersion   = ULONG_MAX;
}


void
ReplPrepareDataToShip(
    IN      THSTATE                   * pTHS,
    IN      ENTINFSEL *                 pSel,
    IN      PROPERTY_META_DATA_VECTOR * pMetaDataVec,
    IN OUT  REPLENTINFLIST *            pList
    )
/*++

Routine Description:

    Given the attributes we decided should be shipped for an object, their
    corresponding meta data, and the values actually present on that object,
    construct the appropriate information to put on the wire such that these
    changes can be applied on a remote DSA.

Arguments:

    pSel (IN) - The subset of attributes we previously decided (in
        ReplFilterPropsToShip()) should be shipped to the remote DSA.
    pMetaDataVec (IN) - The complete meta data vector for this object.
    pList (IN/OUT) - The data to be put on the wire.  On entry should contain
        the appropriate value for fIsNCPrefix and the Entinf read from the
        local object.

Return Values:

    None.

--*/
{
    PROPERTY_META_DATA *        pMetaData;
    PROPERTY_META_DATA_EXT *    pMetaDataExt;
    ATTR *                      pAttrRead;
    ATTR *                      pAttrOut;
    DWORD                       cNumAttrsReadRemaining;
    DWORD                       iAttr;
    BOOL                        fIncludeParentGuid;
    DWORD                       cNumValues = 0;
    DWORD                       cNumDNValues = 0;
    ATTCACHE *                  pAC;

    // The entries in ENTINFSEL and the ENTINF are each sorted by attrtyp.

    // (This is because we build the ENTINFSEL entry by entry from the meta data
    // vector, which we maintain as sorted, and any attributes that occur in the
    // ENTINF should occur in the same order as they were in the ENTINFSEL
    // (though some attributes in the ENTINFSEL may be absent from the ENTINF).)

#if DBG
    pAttrOut = &pSel->AttrTypBlock.pAttr[ 0 ];
    for ( iAttr = 1; iAttr < pSel->AttrTypBlock.attrCount; iAttr++ )
    {
        Assert( pAttrOut->attrTyp < (pAttrOut + 1)->attrTyp );
        pAttrOut++;
    }

    pAttrOut = &pList->Entinf.AttrBlock.pAttr[ 0 ];
    for ( iAttr = 1; iAttr < pList->Entinf.AttrBlock.attrCount; iAttr++ )
    {
        Assert( pAttrOut->attrTyp < (pAttrOut + 1)->attrTyp );
        pAttrOut++;
    }
#endif

    // The meta data vector contains an entry for all replicable attributes.
    // The ENTINFSEL contains a subset of these attributes, specifically only
    // those attributes that replication deemed should be shipped to this
    // receiver.  The ENTINF, in turn, contains a subset of the attributes in
    // the ENTINFSEL, lacking any attributes from the ENTINFSEL that are not
    // currently present on the object (but once were).

    VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVec);
    Assert( 0 != pMetaDataVec->V1.cNumProps );
    Assert( pSel->AttrTypBlock.attrCount <= pMetaDataVec->V1.cNumProps );
    Assert( pList->Entinf.AttrBlock.attrCount <= pSel->AttrTypBlock.attrCount );

    // Allocate a wire-format meta data vector for this object.
    pList->pMetaDataExt = THAllocEx(pTHS,
                                MetaDataExtVecSizeFromLen(
                                    pSel->AttrTypBlock.attrCount
                                    )
                                );
    pList->pMetaDataExt->cNumProps = pSel->AttrTypBlock.attrCount;

    // Cue up the local meta data (which spans all local attributes) and the
    // on-the-wire meta data (which spans only those attributes we're going to
    // ship).
    pMetaData = &pMetaDataVec->V1.rgMetaData[ 0 ];
    pMetaDataExt = &pList->pMetaDataExt->rgMetaData[ 0 ];

    // Cue up the attributes we read (which excludes those we have deleted).
    cNumAttrsReadRemaining = pList->Entinf.AttrBlock.attrCount;
    pAttrRead = cNumAttrsReadRemaining
                    ? &pList->Entinf.AttrBlock.pAttr[ 0 ]
                    : NULL;

    // Cue up the attribute output list.  Note that we reuse the list from the
    // ENTINFSEL, filling in attribute values that we read as appropriate.
    pList->Entinf.AttrBlock = pSel->AttrTypBlock;
    pAttrOut = &pList->Entinf.AttrBlock.pAttr[ 0 ];

    // Default to not putting the GUID of the parent of this object on the wire.
    // We only need to do so if this is a rename or creation (indicated by the
    // presence of ATT_RDN amongst the attributes to be shipped) and this is not
    // the head of the NC we're replicating.
    fIncludeParentGuid = FALSE;

    // For each attribute we previously decided should be shipped...
    // (as reflected by the fact that it occurs in the ENTINFSEL)
    for ( iAttr = 0; iAttr < pList->Entinf.AttrBlock.attrCount; iAttr++ )
    {
        // Do we need to put the parent object's GUID on the wire?
        if ( ( ATT_RDN == pAttrOut->attrTyp ) && !pList->fIsNCPrefix )
        {
            fIncludeParentGuid = TRUE;
        }

        // Move to the meta data for this attribute (skipping over meta data for
        // attributes we're not going to ship).
        while ( pMetaData->attrType < pAttrOut->attrTyp )
        {
            pMetaData++;
        }
        Assert( pMetaData->attrType == pAttrOut->attrTyp );

        if (    ( NULL != pAttrRead )
             && ( pAttrOut->attrTyp == pAttrRead->attrTyp )
           )
        {
            // This attribute currently has values locally.  Put the values
            // we read onto the wire.
            pAttrOut->AttrVal = pAttrRead->AttrVal;
            pAttrRead = --cNumAttrsReadRemaining ? pAttrRead+1 : NULL;

            pAC = SCGetAttById(pTHS, pAttrOut->attrTyp);
            Assert((NULL != pAC) && "GetEntInf() found it, but we can't!");

            if (IS_DN_VALUED_ATTR(pAC)) {
                cNumDNValues += pAttrOut->AttrVal.valCount;
            }

            cNumValues += pAttrOut->AttrVal.valCount;
        }
        else
        {
            // This attribute currently has no values locally; i.e., all
            // previous values have been deleted.  Put "no value" onto the
            // wire (which will later be interpreted by ModifyLocalObj() as
            // an attribute deletion).
            Assert( 0 == pAttrOut->AttrVal.valCount );
            Assert( NULL == pAttrOut->AttrVal.pAVal );
        }

        // Put the meta data for this attribute onto the wire, too.
        pMetaDataExt->dwVersion          = pMetaData->dwVersion;
        pMetaDataExt->timeChanged        = pMetaData->timeChanged;
        pMetaDataExt->uuidDsaOriginating = pMetaData->uuidDsaOriginating;
        pMetaDataExt->usnOriginating     = pMetaData->usnOriginating;

        // Nnnnext!
        pAttrOut++;
        pMetaDataExt++;
        pMetaData++;
    }

    // We should have put all the attributes we read onto the wire.
    Assert( NULL == pAttrRead );

    // There should be a one-to-one correspondence between meta data and
    // attribute values.
    Assert(    pList->Entinf.AttrBlock.attrCount
            == pList->pMetaDataExt->cNumProps
          );

    // Include parent GUID if necessary.
    if ( fIncludeParentGuid )
    {
        DSNAME * pdnParent = (DSNAME *) THAllocEx(pTHS, pList->Entinf.pName->structLen );
        ULONG    err;

        Assert( !pList->fIsNCPrefix );

        // Since this is not the prefix of the NC, the parent must be
        // instantiated locally.

        err = TrimDSNameBy( pList->Entinf.pName, 1, pdnParent );
        Assert( 0 == err );

        err = FillGuidAndSid( pdnParent );
        if (err) {
            if (err == DIRERR_NOT_AN_OBJECT) {
                DRA_EXCEPT(DRAERR_MissingParent, 0);
            } else {
                DRA_EXCEPT(DRAERR_InternalError, err);
            }
        }

        pList->pParentGuid = THAllocEx(pTHS, sizeof( GUID ) );
        *pList->pParentGuid = pdnParent->Guid;

        if(pdnParent != NULL) THFreeEx(pTHS, pdnParent);

    }

    // Update perfmon with outbound value counts.
    IADJUST(pcDRAOutValues, cNumValues);
    IADJUST(pcDRAOutDNValues, cNumDNValues);
}

BOOL
ProperValueForDeletedObject (
                             ATTR * pAttr
    )
/*++
Description:
    Given an attribute from a deleted object, verify that the attribute has the
    expected value.
    Only two attributes have required values when an object is deleted:
        ATT_IS_DELETED - should be true
        ATT_RDN - should be set to invalid value

Arguments:
    pAttr - Attribute

Return Values:
    TRUE - Attribute has expected value
    FALSE - Attribute does not have expected value

--*/
{
    BOOL result = FALSE;

    switch (pAttr->attrTyp) {
    case ATT_RDN:
        if (pAttr->AttrVal.valCount == 1) {
            result = (fVerifyRDN( (WCHAR *)pAttr->AttrVal.pAVal->pVal,
                               pAttr->AttrVal.pAVal->valLen / sizeof( WCHAR) ) ?
                     TRUE : FALSE );
        }
        break;
    default:
        result = TRUE;
        break;
    }

    DPRINT3( 4, "ProperValueForDel: a:%x l:%d result:%d\n",
             pAttr->attrTyp, pAttr->AttrVal.pAVal->valLen, result );
    return result;
} /* ProperValueForDeletedObject */

VOID
FetchLocalValue(
    THSTATE *pTHS,
    ATTR * pAttr
    )
/*++

Routine Description:

    Populate the attribute structure with the local value(s) of the attribute

    It is implicit that the database is positioned on the desired object.

    We use GetEntInf instead of DBGetAttVal so that we can correctly fetch even
    multi-valued attributes and attributes with no value.

Arguments:

    pAttr - Attribute to be updated

Return Values:

    None

--*/
{
    ENTINFSEL sel;
    ATTR      attrSel;
    ENTINF    entinf;
    DWORD     retErr;

    memset(&attrSel, 0, sizeof(attrSel));
    attrSel.attrTyp = pAttr->attrTyp;

    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = EN_ATTSET_LIST_DRA;

    sel.AttrTypBlock.pAttr = &attrSel;
    sel.AttrTypBlock.attrCount = 1;

    // The memory allocated to the structures pointed to by pAttr
    // (which we are orphaning) and the memory for the new value are on the
    // per-transaction heap and will be freed when the call completes
    if (retErr = GetEntInf(pTHS->pDB, &sel, NULL, &entinf, NULL, 0, NULL,
                           GETENTINF_NO_SECURITY,
                           NULL, NULL))
    {
        DRA_EXCEPT(DRAERR_DBError, retErr);
    }

    // we asked for one attribute - so we should get back not more than 1
    Assert(entinf.AttrBlock.attrCount <= 1);

    if (entinf.AttrBlock.attrCount)
    {
        // we did fetch the attr - replace the contents of pAttr with fetched value
        *pAttr = entinf.AttrBlock.pAttr[0];
    }
    else
    {
        // attribute doesn't exist locally - set the attr's valCount to 0 so
        // that ModifyLocalObj will handle it correctly.
        pAttr->AttrVal.valCount = 0;
        pAttr->AttrVal.pAVal = NULL;
    }
}

void
OverrideWithLocalValue(
    THSTATE *pTHS,
    ATTR *pAttr,
    PROPERTY_META_DATA *pMetaDataRemote,
    DSTIME *pTimeNow,
    USN *pusnLocal)
/*++

Description:

    This routing takes overrides the value in attr with the local value, and
    updates the pMetaDataRemote to reflect the override.

Arguments:

    pAttr - Attribute being checked

    pMetaDataRemote - meta data entry constructed in the remote vector for this
        attribute (modified by this function to reflect the local override)

    pTimeNow - pointer the a new timestamp (if *pTimeNow is 0, then this call
        would  create new timestamp & usn and return them through pTimeNow and
        pusnLocal pointers)

    pusnLocal - pointer to the new usn

Return Value:

    None.

--*/
{
    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

    // Replace with local value
    FetchLocalValue( pTHS, pAttr );

    // Allocate timestamp and usn once, only when needed
    if (*pTimeNow == 0) {
        *pTimeNow = DBTime();
        *pusnLocal = DBGetNewUsn();
    }

    // Replace metadata with new metadata
    pMetaDataRemote->dwVersion++;
    pMetaDataRemote->timeChanged = *pTimeNow;
    pMetaDataRemote->uuidDsaOriginating = pTHS->InvocationID;
    pMetaDataRemote->usnOriginating = *pusnLocal;
}


void
OverrideValues (
    THSTATE *pTHS,
    DSNAME *pName,
    GUID **ppParentGuid,
    ATTR *pAttr,
    BOOL *pfApplyAttribute,
    BOOL fIsAncestorOfLocalDsa,
    BOOL fLocalObjDeleted,
    BOOL fDeleteLocalObj,
    USHORT RemoteObjDeletion,
    PROPERTY_META_DATA *pMetaDataLocal,
    PROPERTY_META_DATA *pMetaDataRemote,
    DSTIME *pTimeNow,
    USN *pusnLocal
    )
/*++
Description:

 [wlees 98763] Determine if we should override the value of a RDN

 There are two cases for overriding values:

 1. The remote value has won, the local value is already deleted, and the remote update
    is neither a deletion nor a undeletion, and the remote value is not proper for
    a deleted object ==> REJECT THE REMOTE VALUE

    Note: the proper value check is necessary to dampen the subsequent replication
    caused by the override

 2. The local value won, the local value is not deleted, and the remote value is a
    deletion, and the local value is not proper for a deletion ==> REJECT THE LOCAL VALUE

 When we override a value in either case, we must construct new metadata that is
 definitive for the local and remote.

Jeffparh wrote:

An alternative design might be to allow RDN "changes" on deleted objects if and only if
the metadata wins and the inbound "change" is the local value.
If the remote metadata wins and the inbound RDN value is not a proper value for a deleted object,
the DS should update its local meta data to "win" over the inbound change --
i.e., we should flag a local change, with a version number in the metadata that is 1
greater than that in the inbound metadata.  This will cause the override to replicate out
and quiesce even if the override is done by multiple servers.

A proper RDN for a deleted object must be invalid for normal operations -- see fVerifyRDN in
mdadd.c.

Whenever we have an inbound update for an attribute, we have
initial local metadata ML,
inbound metadata MI, and
resultant local metadata ML'.
Associated with each is a set of values -- VL, VI, and VL'.

If we claim to have successfully updated the object, we must have one of the following
conditions to ensure changes replicate out and machines quiesce to the same value/metadata.

Local metadata/value won.  ML >= MI, ML' = ML, VL' = VL.
Remote metadata/value won.  MI > ML, ML' = MI, VL' = VI.
Local metadata won, remote value overrides.  ML' > ML > MI, VL' = VI.
Remote metdata won, local value overrides.  ML' > MI > ML, VL' = VL.

This implies that the metadata we have after applying these changes must always be greater
than or equal to both the local and the inbound metadata; i.e., ML' >= ML, ML' >= MI.

---
JeffParh (99-08-25) re bug 374144 (server object getting moved to Lost&Found):

    There are two cases to be concerned about:
    (1) The move of an ancestor of the local DSA object is originated on a
        remote machine.
    (2) The move of an ancestor of the local DSA object is originated on the
        local machine.

    You can see below how (1) is handled.  (2) is a little more tricky, however.

    First, how does (2) occur?  Consider two DCs -- DC1 and DC2 -- in the
    same domain, and two sites S1 and S2.  Initially both DCs are in S1.  On
    DC1 delete S2 while simultaneously moving DC1 into S2 on DC2.  With
    currently checked in bits, DC1 receives the move of its own server object
    into S2 and, upon finding the new parent object is deleted, moves it into
    LostAndFoundConfig.  I.e., the damage to DC1 has been originated on DC1
    itself!

    Now, how does the fix for (1) also fix (2)?  The move to
    LostAndFoundConfig comes into UpdateRepObj() just like an inbound update.
    I.e., we make one call into UpdateRepObj() and discover the parent is
    missing, re-request the packet asking for parent objects (not terribly
    important to the topic at hand), retry the UpdateRepObj() again failing
    with missing parent (ditto re relevancy), then decide to move to L&F and
    make yet another call to UpdateRepObj() after changing the DN.  Thus our
    originating update to move to L&F comes in to UpdateRepObj() just like a
    replicated-in change -- the only difference is in the fMoveToLostAndFound
    flag (which triggers an originating write to the last known parent
    attribute) and the fact that the meta data dictates this is a local
    change.  Ergo the code for (1) is triggered and all is well.

Arguments:

    pTHS -
    pName - Name of the inbound object.
    ppParentGuid - Holds a pointer to the inbound guid of the parent object on
        the source DSA (for move operations).  Reset to NULL on return if we
        choose to override the move.
    pAttr - Remote attribute being checked
    pfApplyAttribute - Pointer to storage indicating
        Whether the remote value won reconcilliation.  Possibly updated.
    fIsAncestorOfLocalDsa - TRUE iff the object being replicated is a current
        config NC ancestor of (or is) the ntdsDsa object corresponding to the
        local machine.
    FLocalObjDeleted - Local object is already deleted
    fDeleteLocalObj - Local object is not yet deleted, but we will delete it in
        applying this change.
    RemoteObjDeletion - One of: being deleted, deletion being reversed, no deletion status change
    pMetaDataLocal - Current local meta data entry
    pMetaDataRemote - Current newly contructed output meta data entry, possible updated
    pTimeNow - Pointer to storage for new timestamp, if allocated
    pusnLocal - Pointer to storage for new usn, if allocated

Return Values:

--*/
{
    ATTR localAttr;
    ATTRVAL localAttrval;
    CHAR buf[150];

    // Performance note. This path is executed on every attribute we replicate
    // in. Try to defer doing any expensive work until deeper in the if nesting
    // when you know it is needed.

    // The DSA object itself is considered an ancestor for our purposes.
    Assert(fIsAncestorOfLocalDsa || !NameMatched(pName, gAnchor.pDSADN) || DsaIsInstalling());

    if ( (pAttr->attrTyp != ATT_RDN) &&
         !fIsAncestorOfLocalDsa ) {
        return;
    }

    Assert(!(fLocalObjDeleted && fDeleteLocalObj));
    Assert(!fDeleteLocalObj || (OBJECT_BEING_DELETED == RemoteObjDeletion));

    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

    if (*pfApplyAttribute) {

        // Case 1: remote metadata won, local value overrides

        if ( (fLocalObjDeleted) &&
             (RemoteObjDeletion == OBJECT_DELETION_NOT_CHANGED) &&
             (!ProperValueForDeletedObject( pAttr )) ) {
            Assert(!fDeleteLocalObj);

            // Get the local value of the attribute
            localAttr.attrTyp = pAttr->attrTyp;
            localAttr.AttrVal.valCount = 1;
            localAttr.AttrVal.pAVal = &localAttrval;

            FetchLocalValue( pTHS, &localAttr );

            // See if the local attribute is a better choice
            if (ProperValueForDeletedObject( &localAttr )) {
                // Override the attr with local value
                OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote, pTimeNow,
                                       pusnLocal);

                if ( *ppParentGuid ) {
                    // disallow modification of the parent of a locally
                    // deleted object (bugref 105173)
                    *ppParentGuid = NULL;
                }

                DPRINT2( 2, "Override: attr %x remote metadata won, local value overrides, new version = %d\n",
                         pAttr->attrTyp, pMetaDataRemote->dwVersion);
            } else {
                // The local attribute has been corrupted somehow.  The SD prop
                // probably rewrote it wrong. Allow the incoming attribute to win
                // so that we'll converge to something and not have a storm.

                // Note that this should not be necessary, since we no longer
                // have constant SDs for deleted objects, but keeping here as
                // failure detection.
                Assert( !"Local attribute does not have proper value for deleted object.\nCheck event log for details." );
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_VALUE_NOT_PROPER_FOR_DELETED,
                         szInsertDN(pName),
                         szInsertUUID(&(pName->Guid)),
                         szInsertAttrType(pAttr->attrTyp,buf) );
            }
        }

        if (fIsAncestorOfLocalDsa) {
            if (NameMatched(pName, gAnchor.pDSADN)) {
                // An inbound update for our own ntdsDsa object.  We are
                // authoritative for some attributes of our DSA object -- override
                // any inbound updates for those.

                if ((ATT_RDN == pAttr->attrTyp)
                    || (ATT_INVOCATION_ID == pAttr->attrTyp)
                    || (ATT_RETIRED_REPL_DSA_SIGNATURES == pAttr->attrTyp)
                    || (ATT_MS_DS_HAS_INSTANTIATED_NCS == pAttr->attrTyp)
                    || (ATT_MS_DS_BEHAVIOR_VERSION == pAttr->attrTyp)
                    || (ATT_HAS_MASTER_NCS == pAttr->attrTyp)
                    || (ATT_HAS_PARTIAL_REPLICA_NCS == pAttr->attrTyp)) {
                    DPRINT1(0, "Overriding inbound update to attr 0x%x of our local DSA object.\n",
                            pAttr->attrTyp);
                    OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote,
                                           pTimeNow, pusnLocal);

                    if (ATT_RDN == pAttr->attrTyp) {
                        // If we override the rename, we also override the move.
                        *ppParentGuid = NULL;
                    }
                }
            }
            else if ((ATT_RDN == pAttr->attrTyp)
                     && (NULL != ppParentGuid)) {
                // Is a move of an ancestor of our local ntdsDsa object.
                GUID guidLostAndFound;

                draGetLostAndFoundGuid(pTHS, gAnchor.pConfigDN,
                                       &guidLostAndFound);

                if (0 == memcmp(&guidLostAndFound, *ppParentGuid,
                                sizeof(GUID))) {
                    // Inbound move of an ntdsDsa ancestor to the LostAndFound
                    // container.  Override.

                    DPRINT1(0, "Overriding inbound move of local DSA ancestor %ls to Lost&Found.\n",
                            pName->StringName);

                    OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote,
                                           pTimeNow, pusnLocal);
                    *ppParentGuid = NULL;
                }
            }
        }

    } else {

        // Case 2: local metadata won, remote value overrides

        if (fDeleteLocalObj) {
            // Get the local value of the attribute
            localAttr.attrTyp = pAttr->attrTyp;
            localAttr.AttrVal.valCount = 1;
            localAttr.AttrVal.pAVal = &localAttrval;

            FetchLocalValue( pTHS, &localAttr );

            // Verify that the local value needs to be updated
            if (!ProperValueForDeletedObject( &localAttr )) {

                // Make sure incoming value is right
                if (ProperValueForDeletedObject( pAttr )) {

                    // We will apply the attribute and the remote value is what we want
                    *pfApplyAttribute = TRUE;

                    // Allocate timestamp and usn once, only when needed
                    if (*pTimeNow == 0) {
                        *pTimeNow = DBTime();
                        *pusnLocal = DBGetNewUsn();
                    }

                    // Construct new metadata
                    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);
                    pMetaDataRemote->dwVersion = pMetaDataLocal->dwVersion + 1;
                    pMetaDataRemote->timeChanged = *pTimeNow;
                    pMetaDataRemote->uuidDsaOriginating = pTHS->InvocationID;
                    pMetaDataRemote->usnOriginating = *pusnLocal;

                    DPRINT2( 2, "Override: attr %x local metadata won, remote value overrides, new version = %d\n",
                             pAttr->attrTyp, pMetaDataRemote->dwVersion);
                } else {
                    // The incoming deletion has an improperly valued attribute.
                    // Has pDeletedSD changed in a future version??
                    // Leave the improper local attribute value alone and allow it
                    // to win so that we'll quiece, even though its to different values.

                    // Note that this should not be necessary, since we no
                    // longer have constant SDs for deleted objects, but
                    // keeping here as failure detection.
                    Assert( "Incoming attribute does not have proper value for deleted object" );
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_VALUE_NOT_PROPER_FOR_DELETED,
                             szInsertDN(pName),
                             szInsertUUID(&(pName->Guid)),
                             szInsertAttrType(pAttr->attrTyp,buf) );
                }
            }
        }
    }

} /* OverrideValues */


DWORD
ReplReconcileRemoteMetaDataVec(
    IN      THSTATE *                       pTHS,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecLocal,      OPTIONAL
    IN      BOOL                            fIsAncestorOfLocalDsa,
    IN      BOOL                            fLocalObjDeleted,
    IN      BOOL                            fDeleteLocalObj,
    IN      BOOL                            fBadDelete,
    IN      USHORT                          RemoteObjDeletion,
    IN      ENTINF *                        pent,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecRemote,
    IN OUT  GUID **                         ppParentGuid,
    OUT     ATTRBLOCK *                     pAttrBlockOut,
    OUT     PROPERTY_META_DATA_VECTOR **    ppMetaDataVecOut
    )
/*++

Routine Description:

    Given a set of inbound attributes and their corresponding meta data in
    conjunction with the pre-existing local meta data for the object (if any),
    determine which of the inbound attributes should be applied, and return
    an appropriate internal version of the remote meta data vector to later
    be applied when the object is committed.

    If a local copy of the object does not exist (signified by a NULL local
    meta data vector), meta data for all inbound attributes is added to the
    remote meta data vector.

    If a local copy of the object does exist, each inbound attribute is
    individually reconciled with the pre-existing local version (if any).
    Only inbound attributes that win reconciliation are added to the remote
    meta data vector; those that lose will be removed from the ENTINF.

    [wlees #98763] Special attributes of deleted objects always win

Arguments:

    pMetaDataVecLocal (IN) - Pre-existing local meta data vector for this object
        (if any).

    fIsAncestorOfLocalDsa (IN) - TRUE iff the object being replicated is a
        current config NC ancestor of (or is) the ntdsDsa object corresponding
        to the local machine.

    fLocalObjDeleted (IN) - True if local object is deleted, otherwise false.

    fDeleteLocalObj (IN) - True if local object is not yet deleted, but will be
        deleted in applying this change.

    fBadDelete (IN) - True if the local object is a system-critical object and
                        the object has been deleted on the remote DS.

    RemoteObjDeletion (IN) - Deletion status of remote object as judged by its
        attributes: being deleted, deletion being reversed, or no deletion
        status change.

    pent (IN) - Inbound object name/attributes.

    pMetaDataVecRemote (IN) - Remote meta data for all attributes to be applied.

    ppParentGuid (IN/OUT) - Holds pointer to the inbound guid of this object's
        parent on the source DC (for move operations).  Reset to NULL on return
        if reconciliation dictates that the object should not be moved.

    pAttrBlockOut (OUT) - On return, holds the attributes (and their values)
        that should be applied.  (pAttrBlockOut->pAttr is THAlloc()'ed.)

    ppMetaDataVecOut (OUT) - On return, holds the meta data vector for the
        attributes returned in pAttrBlockOut.  (The vector is THAlloc()'ed.)

Return Values:

    TRUE - There are attributes to be applied.
    FALSE - All inbound attributes lost reconciliation.

--*/
{
    BOOL                        fHaveChangesToApply;
    DWORD                       cbMetaDataVecRemoteAlloced;
    ATTR *                      pAttr;
    PROPERTY_META_DATA *        pMetaDataRemote;
    PROPERTY_META_DATA *        pMetaDataLocal;
    PROPERTY_META_DATA *        pNextMetaDataLocal;
    DWORD                       cNumPropsLocal;
    BOOL                        fLocalObjExists;
    DWORD                       iAttr;
    BOOL                        fApplyAttribute;
    int                         nDiff;
    DSTIME                      TimeNow = 0;
    USN                         usnLocal;
    BOOL                        fIsCreation = FALSE;
    CHAR                        buf[150];


    Assert(NULL != pMetaDataVecRemote);
    VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecRemote);

    // There should be a one-to-one correspondence between remote attributes and
    // meta data for those attributes.
    Assert( pent->AttrBlock.attrCount == pMetaDataVecRemote->V1.cNumProps );

    // sanity check if the local object is a tombstone,it still has meta data
    Assert( !(fLocalObjDeleted && !pMetaDataVecLocal) );

    // Deleted objects shouldn't need to be re-deleted.
    Assert(!(fLocalObjDeleted && fDeleteLocalObj));

    // If it's a bad deletion, we certainly shouldn't be carrying it out.
    Assert(!(fDeleteLocalObj && fBadDelete));

    if (pMetaDataVecLocal)
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecLocal);
    }


    // Local object exists if we have pre-existing local meta data for it.
    fLocalObjExists = ( NULL != pMetaDataVecLocal );

    if (fBadDelete) {
        // If this is a bad deletion, don't move the object.
        *ppParentGuid = NULL;
    }


    // Cue up the first entry in the local meta data vector (if any).
    if (    ( NULL != pMetaDataVecLocal )
         && ( 0 != pMetaDataVecLocal->V1.cNumProps )
       )
    {
        pNextMetaDataLocal = &pMetaDataVecLocal->V1.rgMetaData[ 0 ];
        cNumPropsLocal = pMetaDataVecLocal->V1.cNumProps;
    }
    else
    {
        pNextMetaDataLocal = NULL;
    }

    // Allocate and cue up the resultant attrblock.
    pAttr = THAllocEx(pTHS, sizeof(ATTR) * pent->AttrBlock.attrCount);
    pAttrBlockOut->pAttr = pAttr;
    pAttrBlockOut->attrCount = 0;

    // Allocate and cue up the resultant meta data vector.
    *ppMetaDataVecOut = THAllocEx(pTHS, MetaDataVecV1Size(pMetaDataVecRemote));
    (*ppMetaDataVecOut)->dwVersion = 1;
    pMetaDataRemote = &(*ppMetaDataVecOut)->V1.rgMetaData[ 0 ];

    // Reconcile each replicated attribute.
    // Changes that are reconciled in favor of the inbound attribute have their
    // meta data added to the internal meta data vector we will return to the
    // caller, and the the attribute itself will be present in the returned
    // attrblock.

    for ( iAttr = 0; iAttr < pent->AttrBlock.attrCount; iAttr++ )
    {
        *pAttr = pent->AttrBlock.pAttr[iAttr];
        *pMetaDataRemote = pMetaDataVecRemote->V1.rgMetaData[ iAttr ];

        Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

        if ( fLocalObjExists )
        {
            // Local object exists; determine whether or not the inbound
            // attribute should be applied.

            // Skip over irrelevant local meta data.
            while (    ( NULL != pNextMetaDataLocal )
                    && ( pNextMetaDataLocal->attrType < pAttr->attrTyp )
                  )
            {
                if ( --cNumPropsLocal )
                    pNextMetaDataLocal++;
                else
                    pNextMetaDataLocal = NULL;
            }

            // Get corresponding local meta data (if any).
            if (    ( NULL != pNextMetaDataLocal )
                 && ( pNextMetaDataLocal->attrType == pAttr->attrTyp )
               )
            {
                pMetaDataLocal = pNextMetaDataLocal;
            }
            else
            {
                pMetaDataLocal = NULL;
            }

            // Should we apply this attribute?
            nDiff = ReplCompareMetaData(pMetaDataRemote,
                                        pMetaDataLocal);
            if (0 == nDiff) {
                // Same meta data; attribute already applied locally.
                fApplyAttribute = FALSE;
            }
            else {
                fApplyAttribute = (nDiff > 0);
            }
        }
        else
        {
            // No local object; apply all incoming attributes.
            fApplyAttribute = TRUE;
            pMetaDataLocal = NULL;
        }

        if (fBadDelete)
        {
            // we don't allow the deletion of this object - so, we can't let attributes from
            // the remote DS that were changed/removed as part of the deletion to win
            if (fApplyAttribute)
            {
                ATTCACHE *pAC = SCGetAttById(pTHS, pAttr->attrTyp);

                if (NULL == pAC)
                {
                    DsaExcept(DSA_EXCEPTION,
                              DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                              pAttr->attrTyp);
                }

                // just a sanity assert - we shouldn't be getting any backlinks
                Assert(!FIsBacklink(pAC->ulLinkID));

                // Since we consider this to be a bad delete, we should override EVERY winning
                // change with the local value and force it to replicate out in an attempt to
                // revive the deleted object on the other machine(s). It should be noted that
                // this would reinstantiate only the replicated attributes. Non-replicated attributes
                // will not be revived. Links are revived using ReplOverrideLinks().
                OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote, &TimeNow,
                                       &usnLocal);
            }
        }
        else
        {
            // Check if we need to override special attributes for deleted objects
            OverrideValues(pTHS,
                           pent->pName,
                           ppParentGuid,
                           pAttr,
                           &fApplyAttribute,
                           fIsAncestorOfLocalDsa,
                           fLocalObjDeleted,
                           fDeleteLocalObj,
                           RemoteObjDeletion,
                           pMetaDataLocal,
                           pMetaDataRemote,
                           &TimeNow,
                           &usnLocal);
        }

        if ( fApplyAttribute )
        {
            CHAR buf1[SZDSTIME_LEN + 1];

            DPRINT5(2,
                    "APPLY: (a:%x, l:%d, v:%d, t:%I64x, u:%I64x)\n",
                    pAttr->attrTyp,
                    pAttr->AttrVal.valCount ? pAttr->AttrVal.pAVal->valLen : 0,
                    pMetaDataRemote->dwVersion,
                    (__int64) pMetaDataRemote->timeChanged,
                    pMetaDataRemote->usnOriginating);

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_APPLIED,
                      szInsertAttrType(pAttr->attrTyp,buf),
                      szInsertDN(pent->pName),
                      szInsertUUID(&pent->pName->Guid),
                      szInsertUL( pMetaDataRemote->dwVersion ),
                      szInsertDSTIME( pMetaDataRemote->timeChanged, buf1 ),
                      szInsertUSN( pMetaDataRemote->usnOriginating ),
                      NULL, NULL);
            // We should apply this replicated attribute.

            fIsCreation |= (ATT_OBJECT_CLASS == pAttr->attrTyp);

            // Move on to the next attribute.
            pAttrBlockOut->attrCount++;
            pAttr++;
            (*ppMetaDataVecOut)->V1.cNumProps++;
            pMetaDataRemote++;
        } else {
            DPRINT2( 2,
                     "ReplRecon: attr %x keep local value, local version = %d\n",
                     pAttr->attrTyp, pMetaDataLocal->dwVersion);

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_NOT_APPLIED,
                      szInsertAttrType(pAttr->attrTyp,buf),
                      szInsertDN(pent->pName),
                      szInsertUUID(&pent->pName->Guid),
                      szInsertUL( pMetaDataLocal->dwVersion ),
                      NULL, NULL, NULL, NULL);

            // Note that since we shifted the array we need not change the
            // values of iAttr or pAttr to move on to the next attribute.
        }
    }

    Assert(1 == (*ppMetaDataVecOut)->dwVersion);
    Assert((*ppMetaDataVecOut)->V1.cNumProps == pAttrBlockOut->attrCount);

    fHaveChangesToApply = (    ( NULL != *ppMetaDataVecOut )
                            && ( 0 != (*ppMetaDataVecOut)->V1.cNumProps )
                          );

    if (fHaveChangesToApply) {
        if (fIsCreation) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_APPLYING_OBJ_CREATION,
                     szInsertDN(pent->pName),
                     szInsertUUID(&pent->pName->Guid),
                     NULL);
            return UPDATE_OBJECT_CREATION;
        }
        else {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_APPLYING_OBJ_UPDATE,
                     szInsertDN(pent->pName),
                     szInsertUUID(&pent->pName->Guid),
                     NULL);
            return UPDATE_OBJECT_UPDATE;
        }
    } else {
        return UPDATE_NOT_UPDATED;
    }
}


int
ReplCompareMetaData(
    IN      PROPERTY_META_DATA *    pMetaData1,
    IN      PROPERTY_META_DATA *    pMetaData2  OPTIONAL
    )
/*++

Routine Description:

    Compare meta data to determine which "wins" for reconciliation.

    Order of precedence is higher version, higher timestamp, higher DSA guid.

Arguments:

    pMetaData1, pMetaData2 (IN) - meta data to compare.

Return Values:

    1   pMetaData1 wins
    0   pMetaData1 and pMetaData2 identical
    -1  pMetaData2 wins

--*/
{
    LONGLONG  diff = 0;

    Assert(pMetaData1);
    Assert(!pMetaData2 || (pMetaData1->attrType == pMetaData2->attrType));

    if (!pMetaData2) {
        diff = 1;
    }

    if (0 == diff) {
        diff = ReplCompareVersions(pMetaData1->dwVersion,
                                   pMetaData2->dwVersion);
    }

    if (0 == diff) {
        diff = pMetaData1->timeChanged - pMetaData2->timeChanged;
    }

    if (0 == diff) {
        diff = memcmp(&pMetaData1->uuidDsaOriginating,
                      &pMetaData2->uuidDsaOriginating,
                      sizeof(UUID));
    }

    return (diff < 0) ? -1
                      : (diff > 0) ? 1
                                   : 0;
}


int
ReplCompareValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2,
    BOOL *pfConflict OPTIONAL
    )

/*++

Routine Description:

    Compare to value meta data stamps and return the result

    Also return an indicator whether there was a difference in the timeCreated
    field, indicating a collision.

Arguments:

    pValueMetaData1 -
    pValueMetaData2 -
    pfConflict - true if values different in creation time

Return Value:

    int -
    1   pMetaData1 wins
    0   pMetaData1 and pMetaData2 identical
    -1  pMetaData2 wins

--*/

{
    LONGLONG  diff = 0;
    BOOL fConflict = FALSE;
    BOOL fIsLegacy1, fIsLegacy2;

    // If either is a legacy value, it loses
    fIsLegacy1 = IsLegacyValueMetaData( pValueMetaData1 );
    fIsLegacy2 = IsLegacyValueMetaData( pValueMetaData2 );

    if (fIsLegacy1 && fIsLegacy2) {
        // Both metadata are legacy
        // The only remaining field that is defined is timeCreated.
        Assert( !"It is not expected to have two legacy metadata items" );
        diff = pValueMetaData1->timeCreated - pValueMetaData2->timeCreated;
        fConflict = (diff != 0);
    } else if (fIsLegacy1) {
        // pMetaData1 is legacy
        return -1;
    } else if (fIsLegacy2) {
        // pMetaData2 is legacy
        return 1;
    } else {

        // The time created field is most significant and is checked first
        // Followed by the rest of the usual metadata

        diff = pValueMetaData1->timeCreated - pValueMetaData2->timeCreated;
        if (diff == 0) {
            diff = ReplCompareMetaData(
                &(pValueMetaData1->MetaData),
                &(pValueMetaData2->MetaData) );
        } else {
            fConflict = TRUE;
        }
    }

    if (pfConflict) {
        *pfConflict = fConflict;
    }
    return (diff < 0) ? -1
                      : (diff > 0) ? 1
                                   : 0;
} /* ReplCompareValueMetaData */


int
__inline
ReplCompareVersions(
    IN DWORD Version1,
    IN DWORD Version2
    )
/*++

Routine Description:

    This function compares two meta-data version numbers, taking wrap-around
    into account, and determines which is larger.

Arguments:

    Version1 - Supplies the first version number.
    Version2 - Supplies the second version number.

Return Value:

    1   Version1 > Version2
    0   Version1 = Version1
    -1  Version1 < Version2

--*/
{

    //
    // Our solution to handling version number wrap-around is the following.
    // For each number N, there is a range of numbers which are less than N
    // and a range of numbers which are greater than N.  Depending upon the
    // value of N, this range of numbers less than N may or may not wrap
    // around.  In the non-wrap-around case, these ranges will look something
    // like this:
    //
    //         0xFFFFFFFF +----------+  --+
    //                    |          |    |
    //                    |          |    |-- greater than N
    //                    |          |    |
    //                    |          |    |
    //                    |----------|  --+
    //                    |//////////|    |
    //                    |//////////|    |
    //         0x7FFFFFFF |/-/-/-/-/-|    |
    //                    |//////////|    |-- less than N
    //                    |//////////|    |
    //                    |//////////|    |
    //                    |//////////|    |
    //                    |----------|  --+
    //                    |          |    |-- greater than N
    //                    |          |    |
    //         0x00000000 +----------+  --+
    //
    // Another thing to consider is how large the range of numbers less than
    // N should be.  Since we have 2^32 total numbers to work with, it seems
    // fair that we should make half of them (2^31) less than N and the other
    // half greater than N.  Now, for any range of numbers [A,B], the number
    // of integers that fall in that range is B - A + 1.  We would like to
    // find a constant C such that the range [N-C,N] contains exactly 2^31
    // integers.  Thus, we must have
    //
    //     N - (N-C) + 1 = 2^31
    //
    //     N - N + C + 1 = 2^31
    //
    //     C + 1 = 2^31
    //
    //     C = 2^31 - 1 = 0x7FFFFFFF
    //
    // Now that we have found C, we can describe more precisely what these
    // ranges look like.  There are two cases to consider:  (1) the case where
    // the range of numbers less than N does not wrap around and (2) the case
    // where it does wrap around.  Let's examine these cases individually.
    //
    // 1) Range does not wrap-around:  N >= 0x7FFFFFFF
    //
    //         0xFFFFFFFF +----------+
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |----------| <--- N
    //                    |//////////|
    //                    |//////////|
    //         0x7FFFFFFF |/-/-/-/-/-|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |----------| <--- N - 0x7FFFFFFF
    //                    |          |
    //                    |          |
    //         0x00000000 +----------+
    //
    // In this case, another number M is greater than N if only if it falls
    // into the area beneath N - 0x7FFFFFFF or into the area above N.  Hence,
    //
    //    N < M if and only if M < (N - 0x7FFFFFFF) or N < M.
    //
    // 2) Range does wrap-around:  N < 0x7FFFFFFF
    //
    //         0xFFFFFFFF +----------+
    //                    |//////////|
    //                    |//////////|
    //                    |----------| <--- N - 0x7FFFFFFF
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |          |
    //         0x7FFFFFFF | - - - - -|
    //                    |          |
    //                    |          |
    //                    |----------| <--- N
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //         0x00000000 +----------+
    //
    // In this case, another number M is greater than N if only if it falls
    // into the area in between N - 0x7FFFFFFF and N.  Hence,
    //
    //   N < M if and only if (N < M) && (M < N - 0x7FFFFFFF)
    //
    // Unfortunately, this scheme as described above does not work perfectly.
    // There is a set of pairs of numbers (A,B) for which this scheme says both
    // that A < B and B < A.  This is not right!  The set of pairs for which
    // this occurs is any pair (N, N + 0x80000000).  Instead of complicating
    // our technique, we will just handle these cases with special code.
    //

    // Let's get this possibility out of the way.
    if ( Version1 == Version2 ) {

        return 0;

    }

    if ( Version1 > 0x7FFFFFFF ) {

        // This is case 1, the no-wrap-around case.

        // Look for the special case pair.
        if ( Version2 == Version1 - 0x80000000 ) {

            return 1;

        }

        if ( (Version2 < Version1 - 0x7FFFFFFF) || (Version1 < Version2) ) {

            return -1;  // Version2 > Version1

        } else {

            return 1;   // Version2 < Version1

        }

    } else  if ( Version1 < 0x7FFFFFFF ) {

        // This is case 2, the wrap-around case.

        // Look for the special case pair.
        if ( Version2 == Version1 + 0x80000000 ) {

            return -1;

        }

        if ( (Version1 < Version2) && (Version2 < Version1 - 0x7FFFFFFF) ) {

            return -1;   // Version2 < Version1

        } else {

            return 1;  // Version2 > Version1

        }

    } else {

        // Technically, this is also case 1, the no-wrap-around case.  However,
        // the special case code is different here, so we'll handle it as a
        // separate case.

        // Look for the special case pair.
        if ( Version2 == 0xFFFFFFFF ) {

            return -1;

        }

        if ( (Version2 < Version1 - 0x7FFFFFFF) || (Version1 < Version2) ) {

            return -1;  // Version2 > Version1

        } else {

            return 1;   // Version2 < Version1

        }

    }

} // ReplCompareVersions

#define ReplMetaIsOverridden(pTHS, pMeta, pTime, pUsn) \
    ((0 == memcmp(&((pMeta)->uuidDsaOriginating), \
                  &(pTHS)->InvocationID, \
                  sizeof(UUID))) \
     && (*(pTime) == (pMeta)->timeChanged) \
     && (*(pUsn) == (pMeta)->usnOriginating))


BOOL
ReplPruneOverrideAttrForSize(
    THSTATE *                   pTHS,
    DSNAME *                    pName,
    DSTIME *                    pTimeNow,
    USN *                       pusnLocal,
    ATTRBLOCK *                 pAttrBlock,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )

/*++

Routine Description:

This routine is called when the incoming modification has resulted in the
record being too big.  This can happen under the following scenario:

Two systems each add a large number of values to two (or more) different
attributes, and the total record size is exceeded during replication

Note that two servers cannot each originate a large change to the same
attribute and have it cause a record to big condition.  This is because
two changes to the same attribute during the same window will result in a
version collision, with the older update winning.

In this case we want to prune some incoming attributes.
By prune in this case we mean override.  We want to
1. Not apply the incoming change, and
2. Make our local value override so this reverses the incoming change
at the originating site.

Jeff Parham:  Pruning the inbound data is the right thing to do, I believe.
Add or update the local meta data for that property to make the pre-existing
local values (if any) win.  The problem is you don;t necessarily know which
attribute's values (or attributes' values, for that matter -- there may be more
than one) pushed you over the limit.  The inbound packet has a bunch of attributes
and a bunch of values -- all that you'll know is that you attempted to apply
them as a whole and you exceeded the record size.

Now you have to decide which attribute to prune.
I'd start by pruning the non-system attribute that grew
the highest number of values.  If you exhaust all the inbound non-system attributes
you may be forced to prune system attributes or to prune unchanged pre-existing
local values.  The latter is probably better -- I'd avoid pruning system attributes
until the bitter end.  You could start with the most recently changed
non-system attribute on the local machine and move on from there.

Here is some more commentary about what contributes to record size:

Q: Is there one record limit for the whole object, or is each attribute its own record
and thus each attribute has its own limit?
Jeff Parham:  All non-linked attributes for the object reside on a single record
(the datatable (aka object table) record with the DNT associated with that
record's DN).  Some values also reside on the record (e.g., DWORD values;
there are more).  At any rate each non-linked value (not just the attributes
-- the values too) consumes a portion of the record for a header,
regardless of whether the value is stored on the record or in the long value table.

CODE.IMPROVEMENT: Consider a greater number of attributes as reserved. Sam owned
attributes are all single valued with the exception of linked valued attributes, so
they are not likely to be a source of trouble here.

CODE.IMPROVEMENT: Instead of rejecting an attribute change completely, it might
make sense to remove one value at a time until the record fits?

Arguments:

Assume: thread state, and positioned on object to be updated.

    pTHS -
    pName -
    pAttrBlock -
    pfRetryUpdate -

Return Value:

    None

--*/

{
    ATTR *pAttrCandidate;
    PROPERTY_META_DATA *pMetaDataRemCandidate;
    ULONG chooseReserved;
    CHAR buf[150]; // scratch buffer for event logging code
    CHAR buf1[SZDSTIME_LEN + 1]; // another

    DPRINT1( 1, "ReplPruneAttributesForSize, name = %ws\n", pName->StringName );

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert( pMetaDataVecRemote );

    // Perform two passes: non-reserved attributes first, then special ones...

    for( chooseReserved = 0; chooseReserved < 2; chooseReserved++ ) {

        ULONG i, largestValueDifference = 0;
        pAttrCandidate = NULL;
        pMetaDataRemCandidate = NULL;

        for( i = 0; i < pAttrBlock->attrCount; i++ ) {

            ATTR *pAttr = &(pAttrBlock->pAttr[i]);
            ATTCACHE *pAC = SCGetAttById(pTHS, pAttr->attrTyp);
            PROPERTY_META_DATA *pMetaDataRemote =
                &(pMetaDataVecRemote->V1.rgMetaData[ i ]);
            DWORD numberIncomingValues = pAttr->AttrVal.valCount;
            DWORD numberValueDifference, numberExistingValues;
            BOOL fReserved = (pAC->bSystemOnly);

            Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

            // Exclude linked, already overridden, and attr removals
            if ( (pAC->ulLinkID) ||
                 (ReplMetaIsOverridden(pTHS, pMetaDataRemote, pTimeNow, pusnLocal)) ||
                 (numberIncomingValues == 0) ) {
                continue;
            }
            if ( (chooseReserved != 0) != (fReserved) ) {
                continue;
            }

            numberExistingValues = DBGetValueCount_AC( pTHS->pDB, pAC );

            // Value change does not make the problem worse
            if (numberIncomingValues <= numberExistingValues) {
                continue;
            }
            numberValueDifference = numberIncomingValues - numberExistingValues;

            if (numberValueDifference > largestValueDifference) {
                largestValueDifference = numberValueDifference;
                pAttrCandidate = pAttr;
                pMetaDataRemCandidate = pMetaDataRemote;
            }
        }

        if (pAttrCandidate) {
            goto success;
        }
    }

    DPRINT1( 0, "ReplPrune: no more attributes to prune for %ws\n",
             pName->StringName );
    Assert( FALSE && "Ran out of incoming attributes to prune, and record still too big" );
    LogEvent( DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_RECORD_TOO_BIG_PRUNE_FAILURE,
              szInsertDN(pName),
              szInsertUUID(&(pName->Guid)),
              NULL);

    return FALSE;

success:

    Assert( pAttrCandidate && pMetaDataRemCandidate );

    // Note that if this was an attribute creation, and the attribute
    // didn't exist locally, an attribute removal will be the override used

    OverrideWithLocalValue( pTHS, pAttrCandidate, pMetaDataRemCandidate,
                            pTimeNow, pusnLocal );

    DPRINT3( 1, "ReplPrune: pruned/override w/local value for attr %s, object %ws, new ver %d\n",
             ConvertAttrTypeToStr(pAttrCandidate->attrTyp,buf),
             pName->StringName,
             pMetaDataRemCandidate->dwVersion
        );

    LogEvent8(  DS_EVENT_CAT_REPLICATION,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_DRA_RECORD_TOO_BIG_OVERRIDE,
                szInsertDN(pName),
                szInsertUUID(&(pName->Guid)),
                szInsertAttrType(pAttrCandidate->attrTyp,buf),
                szInsertUL( pMetaDataRemCandidate->dwVersion ),
                szInsertDSTIME( pMetaDataRemCandidate->timeChanged, buf1 ),
                szInsertUSN( pMetaDataRemCandidate->usnOriginating ),
                NULL, NULL);

    return TRUE;
} /* ReplPruneAttributesForSize */



VOID
ReplOverrideLinks(
    IN THSTATE *pTHS
    )

/*++

Routine Description:

    Cause any linked values associated with this object to replicate out.

    This is essentially an authoritative restore of all links associated with
    this object.

    This is used to revive forward and backward links of an object that has been
    wrongly deleted.

    ISSUE wlees/jeffparh Sep 29, 2000
[JeffParh]  2432.  Might be worth a comment that this helps us only for those links
on objects held by the DSA that detects the bad deletion.  Links from objects in NCs
not hosted by this machine and links from objects that haven't yet replicated to this
machine will still end up being inconsistent.  I.e., this code is a good step in the
right direction, but doesn't fully solve the problem of link inconsistency on object
resuscitation.  (Same problem occurs in auth restore, for which there's an open
Blackcomb bug.)

Arguments:

    pTHS - 

Return Value:

    None

--*/

{
    BOOL fSaveScopeLegacyLinks;

    if (!pTHS->fLinkedValueReplication) {
        // OverrideWithLocalValue should have handled all the legacy values
        return;
    }

    DPRINT1( 0, "Reviving links for object %s\n",
             GetExtDN( pTHS, pTHS->pDB) );

    // This routine may be called during legacy replication, when links with
    // metadata are not visible.  Further, DBTouchLinks is not effective during
    // legacy replication because it will not write value metadata in this mode.
    // Temporarily make metadata visible so that we may re-write all links with
    // current metadata, forcing them to replicate out individually.
    fSaveScopeLegacyLinks = pTHS->pDB->fScopeLegacyLinks;
    pTHS->pDB->fScopeLegacyLinks = FALSE;
    __try {

        DBTouchLinks_AC( pTHS->pDB,
                         NULL /* all linked attributes */,
                         FALSE /* forward links */ );

        DBTouchLinks_AC( pTHS->pDB,
                         NULL /* all linked attributes */,
                         TRUE /* backward links */ );
    } __finally {
        pTHS->pDB->fScopeLegacyLinks = fSaveScopeLegacyLinks;
    }

} /* ReplOverrideLinks */


#if DBG
void
ReplCheckMetadataWasApplied(
    IN      THSTATE *                   pTHS,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )

/*++

Routine Description:

Jeffparh writes:
I've been thinking that perhaps we should add assertions in the replication path
to ensure that, after an inbound update has been successfully applied, the meta data
for the inbound attribute on the resultant local object is greater than or equal to
the inbound meta data.  I.e., that for each inbound attribute we either set the
local meta data to be the same as the inbound meta data or we have a "better" change
already.  That would help us catch these sorts of inconsistencies earlier.

   It is assumed that the metadata on the DBPOS has already been flushed to disk.
   That is, the update has already completed, but the transaction may be still open.

   The list of remote metadata being supplied to this function is the list of
   metadata that should have been applied. That is, the function
   ReplReconcileRemoteMetaDataVec has already been called. The remote metadata is
   that which should have won and been applied.

   This routine is called after metadata reconcilation, after any over or underriding
   requests, and after the update itself has taken place. The metadata vector
   passed in here was the final vector used to write the metadata to disk. Although
   the vector reflects the request for over or under-ride, it does not contain
   the actual version number or USN, since they were assigned by dbFlushMetaDataVector.

This check verifies that the remote metadata that we received from our partner was
actually used during the local replicated write to form the new metadata vector.  This
check verifies that all of the inbound attributes were actually touched during the
replicated write, and that the remote metadata was merged successfully.  This check
verifies the use of two routines:
    DBTouchMetaData
    dbFlushMetaDataVector

Arguments:

    pTHS -
    pMetaDataVecRemote - Metadata that should be applied

Return Value:

    None

--*/

{
    DWORD i, cProps, cbReturned;
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal = NULL;
    PROPERTY_META_DATA *pMetaDataRemote, *pMetaDataLocal;
    int nDiff;
    DBPOS *pDB = pTHS->pDB;
    PROPERTY_META_DATA metaDataAdjusted;
    ATTCACHE *pAC;
    CHAR buf[20];

    Assert(VALID_DBPOS(pDB));
    Assert( !pDB->fIsMetaDataCached );

    if ( (!pMetaDataVecRemote) || (!(pMetaDataVecRemote->V1.cNumProps)) ) {
        // Nothing to apply
        return;
    }

    // Read the local metadata
    if (DBGetAttVal(pTHS->pDB, 1,  ATT_REPL_PROPERTY_META_DATA,
                    0, 0, &cbReturned, (LPBYTE *) &pMetaDataVecLocal))
    {
        // This should always succeed since we assume that this routine is called
        // after successful add or modify operations.
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    // The list of remote metadata to be applied should have been applied.
    // All of these should have been applied.
    // Verify that local attributes were touched.
    pMetaDataRemote = &(pMetaDataVecRemote->V1.rgMetaData[0]);
    cProps = pMetaDataVecRemote->V1.cNumProps;
    for( i = 0; i < cProps; i++, pMetaDataRemote++ ) {
        ATTRTYP attrType = pMetaDataRemote->attrType;

        // Skip writing SchemaInfo if fDRA during normal running. It will
        // be written directly by the dra thread at the end of schema NC
        // sync.

        if (attrType == ATT_SCHEMA_INFO) {
            continue;
        }

        pMetaDataLocal = ReplLookupMetaData(
            pMetaDataRemote->attrType,
            pMetaDataVecLocal,
            NULL );

        if (!pMetaDataLocal) {
            DPRINT( 0, "Local metadata is missing.\n" );
        } else {
            // Account for the fact that during flush the metadata may have been
            // over- or underridden. Compensate to make remote metadata comparable.
            if (pMetaDataRemote->usnProperty == USN_PROPERTY_TOUCHED) {
                metaDataAdjusted = *pMetaDataRemote;
                metaDataAdjusted.dwVersion++;
                metaDataAdjusted.timeChanged = pMetaDataLocal->timeChanged;
                metaDataAdjusted.uuidDsaOriginating = pMetaDataLocal->uuidDsaOriginating;
                nDiff = ReplCompareMetaData(&metaDataAdjusted, pMetaDataLocal);
            } else {
                // Compare the adjusted pre-write remote vector with the post-flush vector.
                nDiff = ReplCompareMetaData(pMetaDataRemote, pMetaDataLocal);
            }

            // 1 = remote wins, 0 = same, -1 = local wins

            if (nDiff == 0) {
                // We expect that the winning remote metadata that we have is the same
                // as what is now on the object (what should have been written).
                continue;
            } else if (nDiff == 1) {
                // 1 means local metadata underrides (loses)
                DPRINT( 0, "Local metadata lost unexpectedly (bad underride).\n" );
            } else // if (nDiff == -1)
            {
                // -1 means local metadata overrides
                DPRINT( 0, "Local metadata won unexpectedly (bad override).\n" );
            }
        }

        pAC = SCGetAttById(pTHS, attrType);
        DPRINT1( 0, "Attribute %s metadata not written properly\n",
                 pAC ? pAC->name : _ultoa( attrType, buf, 16 ) );
        DPRINT1( 0, "Remote metadata vector:\n!dsexts.dump PROPERTY_META_DATA_VECTOR %p\n",
                 pMetaDataVecRemote );
        DPRINT1( 0, "Local metadata vector:\n!dsexts.dump PROPERTY_META_DATA_VECTOR %p\n",
                 pMetaDataVecLocal );


        Assert( FALSE && "metadata not written properly" );
    }

    // Be heap friendly
    if (NULL != pMetaDataVecLocal) {
        THFreeEx(pTHS, pMetaDataVecLocal);
        pMetaDataVecLocal = NULL;
    }

} /* ReplCheckMetadataWasApplied */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dramderr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       dramderr.c
//
//--------------------------------------------------------------------------

/*++

Abstract:   This file contains routines for transporting thread state errors
            across the RPC DRS_* routines.  The main two public routines are:
                draEncodeError()
                draDecodeDraErrorDataAndSetThError()
            the server calls draEncodeError() when it's operation is done, and
            an error may need to be transported back to the client.  The client
            unpacks the error data and has his own thread error state set by
            draDecodeDraErrorDataAndSetThError().

Author:     Brett Shirley (BrettSh)

Notes:      ...

Revision History:

    2001-04-13  Initial creation.

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB "DRAMDERR:"              /* define the subsystem for debugging */

#include "drserr.h"
#include "drautil.h"
#include "drauptod.h"
#include "dramail.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMDERR


////////////////////////////////////////////////////////////////////////////////
//
//  WIRE - THREAD_STATE TRANSLATION FUNCTIONS (HELPER FUNCTIONS)
//


void    
draXlateThDirErrToWireDirErr(
    THSTATE *             pTHS,
    DWORD                 prob,
    DIRERR_DRS_WIRE_V1 *  pErrInfo
)
/*++

Routine Description:

    This is a helper function to draEncodeError(), whose primary
    purpose is to just deal with a presumed valid thread state
    error.  There is assumed to be an error if you call this func.
    This routine throws exceptions if the thread error state ins't
    exactly as we'd expect it to be, or there is no more memory.

    Changes to this function should be accompained by changes to her
    sister fuctnion draXlateWireDirErrToThDirErr()
    
    BUGBUG: pNewFilter in the AtrErr is the only thing not transfered,
    if someone ever needs this functionality I suggest they add it
    and increment the error data version.  It would complete the
    robustness of this routine

Arguments:

    pTHS [IN] - This is the error state to pack onto the wire version.
        The error state is in pTHS->errCode & pTHS->pErrInfo.
    prob [IN] - This is the pTHS->errCode.
    pErrInfo [IN] - The on the wire thread error structure to fill im
        and initialize all fields (depending on the prob) of this
        struct.

Return Value:

    None

--*/
{  
    PROBLEMLIST *                    pAttrProbList;
    PROBLEMLIST_DRS_WIRE_V1 *        pAttrProbListDest;
    CONTREF *                        pContRef;
    CONTREF_DRS_WIRE_V1 *            pContRefDest;
    DSA_ADDRESS_LIST *               pDAL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDALDest = NULL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDALTemp;
    
    ULONG   i;

    // Only supposed to call this in case there is an error state in
    // the thread state (pTHS->errCode and pTHS->pErrInfo)
    Assert(pTHS);
    Assert(pTHS->errCode);
    Assert(pTHS->pErrInfo);
    Assert(prob);
    Assert(pErrInfo);

    switch(prob){
    
    case attributeError:
        // Note: Not deep copied, no need.
        pErrInfo->AtrErr.pObject = pTHS->pErrInfo->AtrErr.pObject;
        pErrInfo->AtrErr.count = pTHS->pErrInfo->AtrErr.count;
        
        // According to DoSetAttError, there will always be at least 1 error.
        Assert(pTHS->pErrInfo->AtrErr.count != 0);
        pAttrProbList = &pTHS->pErrInfo->AtrErr.FirstProblem;
        pAttrProbListDest = &pErrInfo->AtrErr.FirstProblem;
        // Copy the list of problems
        for(i = 0; i < pErrInfo->AtrErr.count; i++){
            
            // First copy all the individual elements.
            pAttrProbListDest->intprob.dsid = pAttrProbList->intprob.dsid;
            pAttrProbListDest->intprob.extendedErr = pAttrProbList->intprob.extendedErr;
            pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedData;
            pAttrProbListDest->intprob.problem = pAttrProbList->intprob.problem;
            pAttrProbListDest->intprob.type = pAttrProbList->intprob.type;
            pAttrProbListDest->intprob.valReturned = pAttrProbList->intprob.valReturned;
            if(pAttrProbListDest->intprob.valReturned){
                pAttrProbListDest->intprob.Val.valLen = pAttrProbList->intprob.Val.valLen;
                // Note: Not deep copied, no need.
                pAttrProbListDest->intprob.Val.pVal = pAttrProbList->intprob.Val.pVal;
            }

            // Second continue to the next problem if there is one.
            if(pAttrProbList->pNextProblem){
                // There is a next problem, maybe it's world hunger?
                Assert(i < (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = THAllocEx(pTHS, sizeof(PROBLEMLIST_DRS_WIRE_V1));
                pAttrProbListDest = pAttrProbListDest->pNextProblem;
            } else {
                // All the world's problems have been solved or at 
                // least copied. :)
                Assert(i == (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = NULL;
            }

        } // end for loop
        Assert(i == pErrInfo->AtrErr.count);
        break;

    case nameError:
        pErrInfo->NamErr.dsid = pTHS->pErrInfo->NamErr.dsid;
        pErrInfo->NamErr.extendedErr = pTHS->pErrInfo->NamErr.extendedErr;
        pErrInfo->NamErr.extendedData = pTHS->pErrInfo->NamErr.extendedData;
        pErrInfo->NamErr.problem = pTHS->pErrInfo->NamErr.problem;
        // Note: Not deep copied, no need.
        pErrInfo->NamErr.pMatched = pTHS->pErrInfo->NamErr.pMatched;
        break;

    case referralError:
        pErrInfo->RefErr.dsid = pTHS->pErrInfo->RefErr.dsid;
        pErrInfo->RefErr.extendedErr = pTHS->pErrInfo->RefErr.extendedErr;
        pErrInfo->RefErr.extendedData = pTHS->pErrInfo->RefErr.extendedData;

        pContRef = &pTHS->pErrInfo->RefErr.Refer;
        pContRefDest = &pErrInfo->RefErr.Refer;
        while(pContRef){
            
            // First copy all the elements.
            // Note: Not deep copied, no need.
            pContRefDest->pTarget = pContRef->pTarget;
                // Indented for clarity, copy OpState
                pContRefDest->OpState.nameRes = pContRef->OpState.nameRes;
                pContRefDest->OpState.unusedPad = pContRef->OpState.unusedPad;
                pContRefDest->OpState.nextRDN = pContRef->OpState.nextRDN;
            pContRefDest->aliasRDN = pContRef->aliasRDN;
            pContRefDest->RDNsInternal = pContRef->RDNsInternal;
            pContRefDest->refType = pContRef->refType;
            pContRefDest->count = pContRef->count;

            for(i = 0, pDAL = pContRef->pDAL;
                (i < pContRef->count) && pDAL;
                i++, pDAL = pDAL->pNextAddress){

                pDALTemp = pDALDest;
                pDALDest = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST_DRS_WIRE_V1));
                if(i == 0){
                    // Must put the first one in the ContRef.
                    pContRefDest->pDAL = pDALDest;
                } else {
                    // Must use pDALTemp to build pDAL's in order.
                    pDALTemp->pNextAddress = pDALDest;
                }

                // Note: Not deep copied, no need.  Also note that
                // we didn't pack the original DSA_ADDRESS || UNICODE_STRING
                // in the data structure and left as a pointer for eash of 
                // creating a marshleable structure.
                pDALDest->pAddress = &pDAL->Address;

            }
            Assert(i == pContRef->count);
            // We DO _NOT_ want to copy this very complicated structure
            // if we can help it.  I don't think we need this for our
            // purposes today, so I'll pass the buck.  Further, I don't 
            // think this we will ever have a filter from a referral
            // for trying to add an object to the Partitions container.
            //   So we'll set it to NULL and Assert it is NULL.
            Assert(pContRef->pNewFilter == NULL);
            // There is no pNewFilter attribute, but might be added in the
            // next version of the error state packing function.
            // pContRefDest->pNewFilter = NULL;
            pContRefDest->bNewChoice = pContRef->bNewChoice;
            // Who cares if bNewChoise is TRUE we'll copy this anyway.
            pContRefDest->choice = pContRef->choice;

            // Second if there's a next guy, allocate room for him, and continue.
            if(pContRef->pNextContRef){
                pContRefDest->pNextContRef = THAllocEx(pTHS, sizeof(CONTREF_DRS_WIRE_V1));
            } else {
                pContRefDest->pNextContRef = NULL;
            }
            pContRef = pContRef->pNextContRef;
        }
        break;

    case securityError:
        pErrInfo->SecErr.dsid = pTHS->pErrInfo->SecErr.dsid;
        pErrInfo->SecErr.extendedErr = pTHS->pErrInfo->SecErr.extendedErr;
        pErrInfo->SecErr.extendedData = pTHS->pErrInfo->SecErr.extendedData;
        pErrInfo->SecErr.problem = pTHS->pErrInfo->SecErr.problem;
        break;

    case serviceError:
        pErrInfo->SvcErr.dsid = pTHS->pErrInfo->SvcErr.dsid;
        pErrInfo->SvcErr.extendedErr = pTHS->pErrInfo->SvcErr.extendedErr;
        pErrInfo->SvcErr.extendedData = pTHS->pErrInfo->SvcErr.extendedData;
        pErrInfo->SvcErr.problem = pTHS->pErrInfo->SvcErr.problem;
        break;

    case updError:
        pErrInfo->UpdErr.dsid = pTHS->pErrInfo->UpdErr.dsid;
        pErrInfo->UpdErr.extendedErr = pTHS->pErrInfo->UpdErr.extendedErr;
        pErrInfo->UpdErr.extendedData = pTHS->pErrInfo->UpdErr.extendedData;
        pErrInfo->UpdErr.problem = pTHS->pErrInfo->UpdErr.problem;
        break;

    case systemError:     
        pErrInfo->SysErr.dsid = pTHS->pErrInfo->SysErr.dsid;
        pErrInfo->SysErr.extendedErr = pTHS->pErrInfo->SysErr.extendedErr;
        pErrInfo->SysErr.extendedData = pTHS->pErrInfo->SysErr.extendedData;
        pErrInfo->SysErr.problem = pTHS->pErrInfo->SysErr.problem;
        break;

    default:
        Assert(!"New error type someone update draXlateThDirErrToWireDirErr() & draXlateWireDirErrToThDirErr routines");
        DRA_EXCEPT (ERROR_DS_CODE_INCONSISTENCY, 0);
    }

    return;
}

void
draXlateWireDirErrToThDirErr(
              IN     DWORD                 errCode,
              IN     DIRERR_DRS_WIRE_V1 *  pErrInfo,
    OPTIONAL  IN     DWORD                 dwOptErr,
              IN OUT THSTATE *             pTHS
    )
/*++

Routine Description:

    This is a helper function to draDecodeDraErrorDataAndSetThError(),
    to decode and fill in the pErrInfo potion of the thread state error
    only.

    Changes to this function should be accompained by changes to her
    sister fuctnion draXlateThDirErrToWireDirErr()

    BUGBUG: pNewFilter in the AtrErr is the only thing not transfered,
    if someone ever needs this functionality I suggest they add it.  It
    would complete the robustness of this routine

Arguments:

    errCode [IN] - The errCode (serviceError, attributeError,
        etc) from the wire error info. Set by the remote server.
    pErrInfo [IN] - The thread error state from the wire error
        info.  Set by the remote server.  
    dwOptErr [IN] - (Optional) This allows the caller to specify
        a more useful user error in the extendedError of the 
        operation.  In this case the existing extendedError is 
        moved to the extendedData field and the original
        extendedData field is lost.  If this param is 0, then
        the thread state error is propogated perfectly.
    pTHS - This is really the out parameter, because we store the
        thread error state in pTHS->pErrInfo.

Return Value:

    None

--*/
{
    PROBLEMLIST *                    pAttrProbListDest;
    PROBLEMLIST_DRS_WIRE_V1 *        pAttrProbList;
    CONTREF *                        pContRefDest;
    CONTREF_DRS_WIRE_V1 *            pContRef;
    DSA_ADDRESS_LIST *               pDALDest = NULL;
    DSA_ADDRESS_LIST *               pDALTemp = NULL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDAL;
    
    ULONG    i;

    Assert(pTHS);
    Assert(errCode);
    Assert(pErrInfo);
    Assert(pTHS->pErrInfo);

    switch(errCode){
    case attributeError:
        // Note: Not deep copied, no need.
        pTHS->pErrInfo->AtrErr.pObject = pErrInfo->AtrErr.pObject;
        pTHS->pErrInfo->AtrErr.count = pErrInfo->AtrErr.count;
        
        Assert(pErrInfo->AtrErr.count != 0);
        pAttrProbList = &pErrInfo->AtrErr.FirstProblem;
        pAttrProbListDest = &pTHS->pErrInfo->AtrErr.FirstProblem;
        // Copy the list of problems
        for(i = 0; i < pErrInfo->AtrErr.count; i++){

            // First copy over all the individual elements.
            pAttrProbListDest->intprob.dsid = pAttrProbList->intprob.dsid;
            if (dwOptErr) {
                pAttrProbListDest->intprob.extendedErr = dwOptErr;
                pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedErr;
            } else {                                              
                pAttrProbListDest->intprob.extendedErr = pAttrProbList->intprob.extendedErr;
                pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedData;
            }
            pAttrProbListDest->intprob.problem = pAttrProbList->intprob.problem;
            pAttrProbListDest->intprob.type = pAttrProbList->intprob.type;
            pAttrProbListDest->intprob.valReturned = pAttrProbList->intprob.valReturned;
            if(pAttrProbList->intprob.valReturned){
                pAttrProbListDest->intprob.Val.valLen = pAttrProbList->intprob.Val.valLen;
                // Note: Not deep copied, no need.
                pAttrProbListDest->intprob.Val.pVal = pAttrProbList->intprob.Val.pVal;
            }

            // Second continue to the next problem if there is one.
            if(pAttrProbList->pNextProblem){
                // There is a next problem.
                Assert(i < (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = (PROBLEMLIST *) THAllocEx(pTHS, sizeof(PROBLEMLIST));
                pAttrProbListDest = pAttrProbListDest->pNextProblem;
            } else {
                // No more problems, NULL terminate linked list.
                Assert(i == (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = NULL;
            }
        }
        break;

    case nameError:
        pTHS->pErrInfo->NamErr.dsid = pErrInfo->NamErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->NamErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->NamErr.extendedData = pErrInfo->NamErr.extendedErr;
        } else {
            pTHS->pErrInfo->NamErr.extendedErr = pErrInfo->NamErr.extendedErr;
            pTHS->pErrInfo->NamErr.extendedData = pErrInfo->NamErr.extendedData;
        }
        pTHS->pErrInfo->NamErr.problem = pErrInfo->NamErr.problem;
        // Note: Not deep copied, no need.
        pTHS->pErrInfo->NamErr.pMatched = pErrInfo->NamErr.pMatched;
        break;

    case referralError:
        pTHS->pErrInfo->RefErr.dsid = pErrInfo->RefErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->RefErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->RefErr.extendedData = pErrInfo->RefErr.extendedErr;
        } else {
            pTHS->pErrInfo->RefErr.extendedErr = pErrInfo->RefErr.extendedErr;
            pTHS->pErrInfo->RefErr.extendedData = pErrInfo->RefErr.extendedData;
        }

        pContRef = &pErrInfo->RefErr.Refer;
        pContRefDest = &pTHS->pErrInfo->RefErr.Refer;
        while(pContRef){

            // First copy all the elements.
            // Note: Not deep copied, no need.
            pContRefDest->pTarget = pContRef->pTarget;
                // indented for clarity, copy OpState
                pContRefDest->OpState.nameRes = pContRef->OpState.nameRes;
                pContRefDest->OpState.unusedPad = pContRef->OpState.unusedPad;
                pContRefDest->OpState.nextRDN = pContRef->OpState.nextRDN;
            pContRefDest->aliasRDN = pContRef->aliasRDN;
            pContRefDest->RDNsInternal = pContRef->RDNsInternal;
            pContRefDest->refType = pContRef->refType;
            pContRefDest->count = pContRef->count;

            for(i = 0, pDAL = pContRef->pDAL;
                (i < pContRef->count) && pDAL;
                i++, pDAL = pDAL->pNextAddress){

                pDALTemp = pDALDest;
                pDALDest = (DSA_ADDRESS_LIST *) THAllocEx(pTHS, 
                                     sizeof(DSA_ADDRESS_LIST));
                if(i == 0){
                    // Must be the first one in the ContRef.
                    pContRefDest->pDAL = pDALDest;
                } else {
                    // Must use pDALTemp to build the pDAL's in order.
                    pDALTemp->pNextAddress = pDALDest;
                }

                // Copy the Address UNICODE_STRING structure.
                pDALDest->Address.Buffer = (WCHAR *) THAllocEx(pTHS, pDAL->pAddress->Length + sizeof(UNICODE_NULL));
                pDALDest->Address.Length = pDAL->pAddress->Length;
                pDALDest->Address.MaximumLength = pDAL->pAddress->MaximumLength;
                memcpy(pDALDest->Address.Buffer, 
                       pDAL->pAddress->Buffer,
                       pDAL->pAddress->Length);
                       
            } // End of For each DSA_ADDRESS structure.

            Assert(i == pContRef->count);
            // We DO _NOT_ want to copy this very complicated structure
            // if we can help it.  I don't think we need this for our
            // purposes today, so I'll pass the buck.  Further, I don't 
            // think this we will ever have a filter from a referral
            // for trying to add an object to the Partitions container.
            //   So we'll set it to NULL.  It wasn't even packed up
            //   on the other side in draXlateThDirErrToWireDirErr().
            pContRefDest->pNewFilter = NULL;
            pContRefDest->bNewChoice = pContRef->bNewChoice;
            // who cares if bNewChoice is TRUE we'll copy this anyway.
            pContRefDest->choice = pContRef->choice;

            // Second if there's a next guy, allocate room for him, and continue.
            if(pContRef->pNextContRef){
                pContRefDest->pNextContRef = (CONTREF *) THAllocEx(pTHS, sizeof(CONTREF));
            } else {
                pContRefDest->pNextContRef = NULL;
            }
            pContRef = pContRef->pNextContRef;
        } // Wnd while We still have Referral structures to copy.

        break;

    case securityError:
        pTHS->pErrInfo->SecErr.dsid = pErrInfo->SecErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SecErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SecErr.extendedData = pErrInfo->SecErr.extendedErr;
        } else {
            pTHS->pErrInfo->SecErr.extendedErr = pErrInfo->SecErr.extendedErr;
            pTHS->pErrInfo->SecErr.extendedData = pErrInfo->SecErr.extendedData;
        }
        pTHS->pErrInfo->SecErr.problem = pErrInfo->SecErr.problem;
        break;

    case serviceError:
        pTHS->pErrInfo->SvcErr.dsid = pErrInfo->SvcErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SvcErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SvcErr.extendedData = pErrInfo->SvcErr.extendedErr;
        } else {
            pTHS->pErrInfo->SvcErr.extendedErr = pErrInfo->SvcErr.extendedErr;
            pTHS->pErrInfo->SvcErr.extendedData = pErrInfo->SvcErr.extendedData;
        }
        pTHS->pErrInfo->SvcErr.problem = pErrInfo->SvcErr.problem;
        break;

    case updError:
        pTHS->pErrInfo->UpdErr.dsid = pErrInfo->UpdErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->UpdErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->UpdErr.extendedData = pErrInfo->UpdErr.extendedErr;
        } else {
            pTHS->pErrInfo->UpdErr.extendedErr = pErrInfo->UpdErr.extendedErr;
            pTHS->pErrInfo->UpdErr.extendedData = pErrInfo->UpdErr.extendedData;
        }
        pTHS->pErrInfo->UpdErr.problem = pErrInfo->UpdErr.problem;
        break;

    case systemError:
        pTHS->pErrInfo->SysErr.dsid = pErrInfo->SysErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SysErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SysErr.extendedData = pErrInfo->SysErr.extendedErr;
        } else {
            pTHS->pErrInfo->SysErr.extendedErr = pErrInfo->SysErr.extendedErr;
            pTHS->pErrInfo->SysErr.extendedData = pErrInfo->SysErr.extendedData;
        }
        pTHS->pErrInfo->SysErr.problem = pErrInfo->SysErr.problem;
        break;

    default:
        Assert(!"New error type someone update draXlateThDirErrToWireDirErr() & draXlateWireDirErrToThDirErr()\n");
    }

}



////////////////////////////////////////////////////////////////////////////////
//
//  ERROR ENCODE / DECODE FUNCTIONS (PUBLIC FUNCTIONS)
//


void
draEncodeError(
    OPTIONAL IN  THSTATE *                  pTHS,      // For Dir* error info
    OPTIONAL IN  DWORD                      ulRepErr,  // DRS error
             OUT DWORD *                    pdwErrVer,
             OUT DRS_ERROR_DATA **          ppErrData  // Out Message
    )
/*++

Routine Description:

    This is the public function for packing up the thread error and
    replication error state set by whatever operation just proceeded.
    Anyone who wants to send the thread error state across the wire,
    can use this function for that purpose.  The function will set
    success error data if there is no error.  This error data is 
    intended to be used by it's sister function, 
    draDecodeDraErrorDataAndSetThError().

    NOTE: about the contract between the Encode/Decode functions.
    // This sets the success/error state of the AddEntry reply message
    // This data _MUST_ in V1 include:
    //    *pdwErrVer = 1;
    //    pErrData = allocated memory if pTHS is non-NULL
    //    pErrData->V1.dwRepError = <error || 0>;
    //    pErrData->V1.errCode = <thread prob (1-7) || 0>;
    //    pErrData->V1.pErrInfo = if(pErrData->V1.errCode != 0) allocated memory
    // If we couldn't allocate even enough memory for pErrData or the
    //   thread state (pTHS) was NULL, then *pErrData will be NULL
    // If we couldn't allocate the thread state error, or the thread
    //   state error was inconsistent, then we put an error in dwRepError,
    //   set pErrData->V1.errCode to 0, and pErrData->V1.pErrInfo to NULL.

Arguments:

    pTHS [IN] - This is used both for allocating memory, and for 
        grabbing the thread error state (pTHS->errCode & pTHS->pErrInfo).
        This may be NULL, in the case where we haven't even been able
        to init a thread state.
    ulRepErr [IN] - This is the optional replication operation error,
        such as Version of RPC call/message not supported, no memory,
        invalid parameter.
    pdwErrVer [OUT] - The version of the error data to set.  Note that
        whatever version you set, you need to make sure that the client
        side draDecodeDraErrorDataAndSetThError() will be able to under-
        stand it.  This is usually done with DRS_EXT_ bits.
    ppErrData [OUT] - The pointer to put the allocated memory for the
        error data in.  If we can't allocate the memory, because pTHS
        is NULL or there is no memory, then *ppErrData must equal NULL,
        to indicate a serious error to the sister function.

Return Value:

    None

--*/
{
    DRS_ERROR_DATA *                    pErrData = NULL;
    ULONG                               dwException, ulErrorCode, dsid;
    PVOID                               dwEA;

    Assert(pdwErrVer);
    Assert(ppErrData);

    // This function should be called for only version 1 of the error
    // data.
    *pdwErrVer = 1;
    *ppErrData = NULL;

    if(pTHS){ 

        __try {

            // Allocate space for the error data.
            pErrData = THAllocEx(pTHS, sizeof(DRS_ERROR_DATA_V1));

            // Set the output param.
            *ppErrData = pErrData;

            // We've got room to pack up the error state.
            // Set Replication Error/Success value.
            pErrData->V1.dwRepError = ulRepErr;
            // Set Thread State Error/Success value.
            pErrData->V1.errCode = pTHS->errCode;
            if (pTHS->errCode) {

                //
                // Set this only on a thread state error being present.
                //

                if ( pTHS->pErrInfo == NULL ) {
                    // Just want to be safe in case I don't understand the code for setting
                    // the error state info in src\mderror.c,
                    Assert(!"Any time pTHS->errCode is set, pTHS->pErrInfo shouldn't be NULL.");
                    DRA_EXCEPT (ERROR_DS_CODE_INCONSISTENCY, 0);
                } 

                // Looks like valid thread error state, allocate wire thread error info.
                pErrData->V1.pErrInfo = (DIRERR_DRS_WIRE_V1 *) THAllocEx(pTHS, sizeof(DIRERR_DRS_WIRE_V1));

                // Finally translate the thread error state to the wire version.
                draXlateThDirErrToWireDirErr(pTHS, pErrData->V1.errCode, pErrData->V1.pErrInfo);

            } // If pTHS->errCode set.

        } __except (GetExceptionData(GetExceptionInformation(), &dwException,
                       &dwEA, &ulErrorCode, &dsid)) {

              // Probably (should) fail with out of memory or code inconsistency.
              Assert(ulErrorCode == ERROR_NOT_ENOUGH_MEMORY ||
                     ulErrorCode == ERROR_DS_CODE_INCONSISTENCY);
              if(pErrData){
                  // Can't be sure about the thread state error, so kill
                  // the return(wire) thread error and return a dwRepError.
                  pErrData->V1.errCode = 0;
                  if(pErrData->V1.pErrInfo) { 
                      THFreeEx(pTHS, pErrData->V1.pErrInfo);
                  }
                  pErrData->V1.pErrInfo = NULL;
                  pErrData->V1.dwRepError = ulErrorCode;

              } // else no pErrData allocated, bail with *ppErrData = NULL,
                // indicate fatal error.

        } // End __except() there was a fatal error setting the error state 
       
    } // else no pTHS to allocate memory with, leave *ppErrData NULL to 
      // indicate fatal error.

    // Finally validate that this is valid.
    DPRINT1(1, "Returning error reply version = %ul\n", *pdwErrVer);
    Assert(*pdwErrVer == 1);

#if DBG
    if(pErrData){
         Assert(pErrData->V1.errCode == 0 || pErrData->V1.pErrInfo);
    }
#endif

}

void
draDecodeDraErrorDataAndSetThError(
              IN     DWORD                 dwVer,
              IN     DRS_ERROR_DATA *      pErrData,
    OPTIONAL  IN     DWORD                 dwOptionalError,
              IN OUT THSTATE *             pTHS
    )
/*++

Routine Description:

    This is the public function for unpacking the remote error
    state set by our sister function (draEncodeError()), and
    setting the thread error state for this thread.  
        
Arguments:

    dwVer [IN] - The version of the DRA/DRS error data being
        provided.  Currently only support for version 1 exists.
    pErrData [IN] - The actualy DRA/DRS error data being provided.
        This error state data consists of 3 things:
            dwRepError - The error set by the replication/DRA/DRS
                API on the remote side of the RPC call.  This is
                often if something went wrong such that we didn't
                even get to the part where we actually set the
                thread error state.
            errCode - This is the remote servers pTHS->errCode for
                the operation that we asked the server to perform.
            pErrInfo - This is a _WIRE_ version of the pTHS->pErrInfo
                thread error info for the operation that we asked
                the server to perform.
    dwOptErr [IN] - (Optional) This allows the caller to specify
        a more useful user error in the extendedError of the 
        operation.  In this case the existing extendedError is 
        moved to the extendedData field and the original
        extendedData field is lost.  If this param is 0, then
        the thread state error is propogated perfectly.
    pTHS [IN/OUT] - This is how we get at the error state that gets
        setup.

Return Value:

    None, 
    
    NOTE: though there is no return value, if there was some error
    info in the error data, then a thread state error will be set
    in pTHS.

--*/
{
    Assert(pTHS->errCode == 0);
    Assert(pErrData);
    
    if (dwVer != 1) {
        
        // Just in case, someone in the next version of WinXP messes up.
        Assert(dwVer == 1);
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_CODE_INCONSISTENCY);
        return;

    }
    if (pErrData == NULL) {

        // This means the the DRS_AddEntry call failed on the server because
        // the DC was shutting down or out of memory.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_SERVER_DOWN);
        return;

    }

    // Set the thread state error depening on how we got the error.
    if(pErrData->V1.errCode){

        if(pErrData->V1.pErrInfo == NULL){
            Assert(!"Should never happen, RPC would've thrown an error, or remote side should've set a dwRepError.");
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_CODE_INCONSISTENCY);
            return;
        }
        // Got an error from the remote thread state error, crack it out
        // of the reply data and set the error.
        pTHS->errCode = pErrData->V1.errCode;
        pTHS->pErrInfo = (DIRERR *) THAllocEx(pTHS, sizeof(DIRERR));
        draXlateWireDirErrToThDirErr(pErrData->V1.errCode,
                                     pErrData->V1.pErrInfo,
                                     dwOptionalError,
                                     pTHS);

    } else if (pErrData->V1.dwRepError) {

        // Got a repl error from the remote repl API side, set an 
        // intelligent error.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                    pErrData->V1.dwRepError);

    } // else the operation was successful, don't set the thread state error.
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drainit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drainit.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

This module contains the task queue functions which accomplish initial sync, delayed
gc promotion, as well as initial syncs.

There are four task queue functions ("threads") in this module:

CheckSyncProgress - Starts inital syncs.  Also reexecuted periodically to check that
the syncs are making progress.  When the syncs finish, drancrep.c calls us back
at InitSyncAttemptComplete().

CheckFullSyncProgress - Checks whether the primary domain has completed atleast
one successful sync since installation.  This routine calls DsaSetIsSynchronized
when this criteria is met. This routine is called by InitSyncAttemptComplete when
all the writeable init syncs have completed.

CheckGCPromotionProgress - Checks whether all readonly domains are present, and if
present, whether they have completed atleast one successful sync since installation.
This routine calls UpdateAnchorFromDsaOptions when this criteria is met.  This
routine is called from InitSyncAttemptComplete when all readonly init syncs have
completed.

SynchronizeReplica - Looks at the master and readonly ncs hosted by this server
to see if there are any that need to be periodicaly synced.  If any are found,
a synchronization is started for each of them.

Here is the calling hierarchy:
InitDraTasks()
    call AddInitSyncList for each writeable partition
    InsertInTaskQueue( SynchronizeReplica )
    CheckSyncProgress( TRUE ) // start syncs

InitSyncAttemptComplete() - called when a sync completes in success or error
    Mark (nc, source) pair as complete
    If success or last source, mark nc as complete
    If all writeable ncs complete, call CheckFullSyncProgress()
    If all readonly ncs complete, call UpdateAnchorFromDsaOptionsDelayed( TRUE )
    If all ncs complete, call CheckInitSyncsFinished()

These are the requirements for advertising the DC in general by calling
DsaSetIsSynchronized():
1. Initial syncs of all writable ncs complete.  For each nc, a success must be
achieved or all sources must be tried.  This may involving waiting for multiple
runs of CheckSyncProgress to restart new syncs.
2. CheckFullSyncProgress has run, and has found the primary domain to have synced
atleast once.
3. DsaSetIsSynchronized is called.

These are the requirements for advertising the DC as a GC by calling
UpdateAnchorFromDsaOptions():
1. Initial syncs of all readonly ncs complete.  For each nc, a success must be
achieved or all sources must be tried.  This may involving waiting for multiple
runs of CheckSyncProgress to restart new syncs.
2. UpdateAnchorFromDsaOptionsDelayed is called.  If GC promotion is requested,
CheckGCPromotionProgress() is called.
3. CheckGCPromotionProgress runs and checks whether all readonly ncs are present
and have synced atleast once.  If any have not, we reschedule to try again later.
Once all have met the criteria, we call the real UpdateAnchorFromDsaOptions() to
complete the GC promotion.

Additional commentary on UpdateAnchorFromDsaOptionsDelayed() can be found in
mdinidsa.c

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// SAM headers
#include <samsrvp.h>                    /* for SampInvalidateRidRange() */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>
#include <winsock.h>                    /* htonl, ntohl */
#include <filtypes.h>                   // For filter construction
#include <windns.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAINIT:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drauptod.h"
#include "draasync.h"
#include "drameta.h"
#include "drauptod.h"

#include <fileno.h>
#define  FILENO FILENO_DRAINIT

// Periodic sync defines

#define INIT_PS_ENTRIES 10
#define PS_ENTRIES_INC 10

#define FIFTEEN_MINUTES (15 * 60)

#define SCHEDULE_LEN ((4*24*7)/8)

// Pause before we try and sync mail replicas, to let MTA start

#define MAIL_DELAY_SECS 300     // 5 minutes

#define MAX_GC_PROMOTION_ATTEMPTS       5

extern HANDLE hevDRASetup;

// Head of NC sync data list

NCSYNCDATA *gpNCSDFirst = NULL;

// Count of NCs that have not been synced since startup
ULONG gulNCUnsynced = 0;
// Count of writable ncs unsynced
ULONG gulNCUnsyncedWrite = 0;
// Count of readable ncs unsynced
ULONG gulNCUnsyncedReadOnly = 0;

// Initial syncs finished.  This indicates both writable and readonly
// partitions have been checked.  For most requirements, we only need
// to know that the writable ones have been checked, and use
// gfIsSynchronized instead.
BOOL gfInitSyncsFinished = FALSE;

ULONG gMailReceiveTid = 0;

CRITICAL_SECTION csNCSyncData;

// Time at which we last checked for periodic syncs we might need to perform.
DSTIME gtimeLastPeriodicSync = 0;

// The way we know if we got through the promotion process once
BOOL gfWasPreviouslyPromotedGC = FALSE;

// To Track GC State
CRITICAL_SECTION csGCState;

// Vector of attributes of ntdsDSA objects that dictate what NCs we hold.
const struct {
    ATTRTYP AttrType;
    ULONG   ulFindNCFlags;
} gAtypeCheck[] = {
    {ATT_HAS_MASTER_NCS,          FIND_MASTER_NC},
    {ATT_HAS_PARTIAL_REPLICA_NCS, FIND_REPLICA_NC}
};



// Function prototypes

BOOL fIsBetweenTime(REPLTIMES *, DSTIME, DSTIME);
void DelayedMailStart(void *pv, void **ppvNext,
                      DWORD *pcSecsUntilNextIteration);
NCSYNCDATA * GetNCSyncData (DSNAME *pNC);
void
CheckFullSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    );
void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvParamNextIteration,
    OUT DWORD * pcSecsUntilNextIteration
    );
BOOL
draIsInitSyncCompleteForNc(
    IN DSNAME * pNC
    );







void
CheckSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

?? DO WE REALLY NEED THIS ??
WLEES 9-APR-99. Is this really useful?
This is necessary to start the initial syncs.  But what good does it do
to requeue sync's that have not finished yet?
Sync's that fail and are retriable, are retried in drasync.c
My guess is that this is to catch sync's that complete without calling
us back at SyncAttemptComplete. In this case, we kick them off again.

This routine runs on a replicated server after reboot or install
until admin updates have been enabled.

Run the first time directlty to sync the replicas, and then runs
from the timer thread to ensure that we are making progress on syncing
the replicas.

It may queue syncs that already exist in the queue, but this will
have a minimal performance impact.

This routine also checks to see if updates should be enabled. We use this
functionality to defer setting updates enabled prematurely when we
restart a replicated server.

Arguments:

    pv -
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    ULONG i, ulRet = 0;
    ULONG sourcenum;
    NCSYNCDATA *pNCSDTemp;
    NCSYNCSOURCE *pNcSyncSource;
    BOOL fReplicaFound = TRUE;
    BOOL fSync = FALSE;
    BOOL fProgress = FALSE;

    // If we are passed sync up indication, try and sync each NC\source.
    // Otherwise we queue syuncs only if we're not making progress.
    fSync = (BOOL)(pv != NULL);

    EnterCriticalSection(&csNCSyncData);

    __try {
        __try {
            // If init syncs have finished, we're done, else check
            if (!gfInitSyncsFinished) {

                if (!fSync) {
                    // Not told to sync explicitly, see if we are making progress.

                    // For each NC, see if we have any more synced sources
                    // than last time. If any have, we're getting there

                    for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;
                         pNCSDTemp = pNCSDTemp->pNCSDNext) {
                        if (pNCSDTemp->ulTriedSrcs > pNCSDTemp->ulLastTriedSrcs) {
                            pNCSDTemp->ulLastTriedSrcs = pNCSDTemp->ulTriedSrcs;
                            fProgress = TRUE;
                        }
                        LogEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_BASIC,
                                 fProgress ? DIRLOG_ADUPD_SYNC_PROGRESS : DIRLOG_ADUPD_SYNC_NO_PROGRESS,
                                 szInsertDN((&(pNCSDTemp->NC))),
                                 NULL,
                                 NULL);
                    }
                    // Force sync of unsynced NC sources if we're making no progress.

                    if (!fProgress) {
                        fSync = TRUE;
                    }
                } // if (!Sync ) ...

                // If we were told to sync or have no progress, queue syncs.

                if (fSync) {
                    // Sync each NC from one source, then each NC from the next source, etc.

                    for (sourcenum=0; fReplicaFound; sourcenum++) {

                        // are we being signalled to shutdown?
                        if (eServiceShutdown) {
                            DRA_EXCEPT(DRAERR_Shutdown, 0);
                        }

                        // Set no ith replica found yet.
                        fReplicaFound = FALSE;
                        for (pNCSDTemp = gpNCSDFirst; pNCSDTemp ;
                             pNCSDTemp = pNCSDTemp->pNCSDNext) {
                            // Only queue sync if NC is not already synced from one source
                            if (!(pNCSDTemp->fNCComplete)) {
                                for (pNcSyncSource = pNCSDTemp->pFirstSource, i=0;
                                     pNcSyncSource && (i < sourcenum);
                                     pNcSyncSource = pNcSyncSource->pNextSource, i++) {
                                }
                                // If we have an ith source, sync it.
                                if (pNcSyncSource) {

                                    // Found ith replica of at least one NC.
                                    fReplicaFound = TRUE;

                                    // Sync source by name.
                                    if (fSync) {
                                        ULONG ulSyncFlags =
                                            (pNCSDTemp->ulReplicaFlags &
                                             AO_PRIORITY_FLAGS) |
                                            DRS_ASYNC_OP |
                                            DRS_NO_DISCARD |
                                            DRS_SYNC_BYNAME |
                                            DRS_INIT_SYNC_NOW;

                                        ulRet = DirReplicaSynchronize (
                                            (DSNAME*)&(pNCSDTemp->NC),
                                            pNcSyncSource->szDSA,
                                            NULL,
                                            ulSyncFlags );
                                        Assert( !ulRet );
                                    }
                                }
                            }
                        }
                    } // for each source num
                } // if (fSync)

                CheckInitSyncsFinished();

            } // if ! updates enabled

        } __finally {
            // If updates still not enabled or error, replace task to run again

            if ((!gfInitSyncsFinished) || AbnormalTermination()) {
                if ( NULL != ppvNext ) {
                    // Warn user this is going to take a while...
                    // In this arm so it logged on 2nd and later attempts...
                    if (gulNCUnsyncedWrite!=0) {
			DPRINT( 0, "Init syncs not finished yet, server not advertised\n" );
			LogEvent(DS_EVENT_CAT_REPLICATION,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_ADUPD_INIT_SYNC_ONGOING,
				 NULL,
				 NULL,
				 NULL);
		    }
		    else {
			Assert(gulNCUnsyncedReadOnly!=0);
			DPRINT( 0, "Init syncs for read-only partitions not finished\n");
			LogEvent(DS_EVENT_CAT_REPLICATION,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_ADUPD_INIT_SYNC_ONGOING_READONLY,
				 NULL,
				 NULL,
				 NULL);
		    }
                    // called by Task Scheduler; reschedule in-place
                    *ppvNext = (void *)FALSE;
                    *pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
                } else {
                    // not called by Task Scheduler; must insert new task
                    InsertInTaskQueueSilent(
                        TQ_CheckSyncProgress,
                        (void *)FALSE,
                        SYNC_CHECK_PERIOD_SECS,
                        TRUE);
                }
            }
            LeaveCriticalSection(&csNCSyncData);
        }
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckSyncProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }
} /* CheckSyncProgress */

ULONG
InitDRATasks (
    THSTATE *pTHS
    )

/*++

Routine Description:

Checks through all the master and replica NCs on this DSA, and checks:
If initial sync is required on a NC, it puts the periodic sync task
on the queue.

Note that if DSA is not installed, we return immediately

The requirements for starting an initial sync of a nc are:

a. Initial sync flag is set
   This is controlled by the KCC or by the creator of the manual connection.
   The KCC does not mark inter-site connections as INIT_SYNC

b. Schedule is not NEVER

c1. The replica is writable, OR
c2. We were never fully promoted before, OR
c3. This is not a full sync

    The rationale here is to prevent "maintenance" full sync's from blocking
    GC advertisement.  Full sync's can happen during initial GC promotion,
    or later they may be requested manually or as a result of a partial
    attribute change.  We want promotion related full syncs to go through
    as init syncs, but post-promotion full syncs to be delayed.

    Specifically, the scenario we are trying to avoid is a change in the partial
    attribute set (which sometimes forces full syncs on all links), and then a
    site-wide power failure.  We want to avoid all GC's being down (unadvertised)
    because they are waiting for an init sync full sync.


Arguments:

    pTHS - current thread state

Return Value:

    ULONG - error in DRA error space.

--*/

{
    ULONG ulRet = 0;
    UCHAR syntax;
    UCHAR *pVal;
    ULONG bufSize = 0;
    ULONG len;
    DSNAME *pNC;
    DBPOS *pDBTmp;
    REPLICA_LINK *pRepsFromRef;
    UCHAR i;
    BOOL fSyncsReqd = FALSE;
    BOOL fPerformInitSyncs = TRUE; // Default
    SYNTAX_INTEGER it;

    // Check registry override.  This key controls whether we perform the initial
    // syncs at all.  Once they have been issued, there is no easy way to cancel
    // them.
    GetConfigParam(DRA_PERFORM_INIT_SYNCS, &fPerformInitSyncs, sizeof(BOOL));
    if (!fPerformInitSyncs) {
        DPRINT(0, "DRA Initial Synchronizations are disabled.\n");
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_INIT_SYNCS_DISABLED,
                 NULL,
                 NULL,
                 NULL);
    }


    // Reset AsyncThread() state.
    InitDraQueue();

    // Skip this if not installed. (No replicas if not installed). All we
    // do is release the async queue.

    if ( DsaIsInstalling() ) {
        SetEvent(hevDRASetup);
        return 0;
    }

    // Read DSA object and find all the replica.
    BeginDraTransaction(SYNC_WRITE);
    __try {
        // Find the DSA object
        if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
            DRA_EXCEPT (DRAERR_InternalError, ulRet);
        }

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {
            /* Set up a comparison for a schedule of never.  That is a
             * byte array big enough for 1 bit per every 15 minutes of a
             * week.
             */
            BYTE pScheduleNever[SCHEDULE_LEN] = {0};

            // Search the master and replica NCs to see if there are any that
            // need to be periodically or initally synched. We search the
            // master NCs so that we'll find the writeable replicas too.

            for (i = 0; i < ARRAY_SIZE(gAtypeCheck); i++) {
                ULONG NthValIndex = 0;

                // For each NC that we replicate, see if they need to be
                // initially synchronized and whether they need to be put
                // in the periodic replica scheme.

                while (!(DBGetAttVal(pTHS->pDB,
                                     ++NthValIndex,
                                     gAtypeCheck[i].AttrType,
                                     0,
                                     0, &len, (PUCHAR *)&pNC))) {
                    ULONG NthValIndex = 0;

                    if (ulRet = FindNC(pDBTmp,
                                       pNC,
                                       gAtypeCheck[i].ulFindNCFlags,
                                       &it)) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                    }

                    if (fPerformInitSyncs) {
                        //
                        // Get the repsfrom attribute
                        //
                        while (!(DBGetAttVal(pDBTmp,
                                             ++NthValIndex,
                                             ATT_REPS_FROM,
                                             DBGETATTVAL_fREALLOC,
                                             bufSize, &len, &pVal))) {

                            bufSize=max(bufSize,len);

                            Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
                            VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                            pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufSize);
                            //note: we preserve pVal for DBGetAttVal realloc
                            pVal = (PUCHAR)pRepsFromRef;
                            Assert(bufSize >= pRepsFromRef->V1.cb);

                            Assert( pRepsFromRef->V1.cbOtherDra
                                    == MTX_TSIZE(RL_POTHERDRA(pRepsFromRef)) );

                            // Init sync if
                            // a. Initial sync flag is set (usually by KCC)
                            // b. Schedule is not NEVER
                            // c1. The replica is writable, OR
                            // c2. We were never fully promoted before, OR
                            // c3. This is not a full sync
                            if (
                                (pRepsFromRef->V1.ulReplicaFlags & DRS_INIT_SYNC) &&
                                ( 0 != memcmp(
                                            &pRepsFromRef->V1.rtSchedule,
                                            pScheduleNever,
                                            sizeof( REPLTIMES ) )
                                    ) &&
                                ( (pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP) ||
                                  (!gfWasPreviouslyPromotedGC) ||
                                  (!(pRepsFromRef->V1.ulReplicaFlags & DRS_NEVER_SYNCED))
                                    )
                                )
                            {
                                LPWSTR pszSource;

                                // Mail replicas are not initially synced
                                Assert( !(pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP ));

                                // If this is a non-mail replica add it to the
                                // list of NCs and sources to initial sync.

                                // Add the replica to the list of
                                // NCs and increment sources count.

                                pszSource = TransportAddrFromMtxAddrEx(
                                    RL_POTHERDRA(pRepsFromRef));

                                AddInitSyncList( pNC,
                                                 pRepsFromRef->V1.ulReplicaFlags,
                                                 pszSource );
                                THFreeEx(pTHS, pszSource);
                            }
                        }
                    }

                    //
                    // Make sure the NC exists consistently on
                    // the msds-HasInsatantiatedNCs NC list.
                    // If it isn't, or it's instanceType is different
                    // add it. Otherwise, no-op.
                    //
                    ulRet = AddInstantiatedNC(pTHS, pTHS->pDB, pNC, it, TRUE);
                    if ( ERROR_SUCCESS == ulRet ) {
                        // we're good, commit change to dbase.
                        if (ulRet = DBRepl( pTHS->pDB,pTHS->fDRA,
                                            0, NULL, META_STANDARD_PROCESSING)) {
                            DPRINT1(0, "Error <%lu>: Couldn't dbase commit for AddInstantiatedNC.\n",
                                    ulRet);

                            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                    DS_EVENT_SEV_MINIMAL,
                                    DIRLOG_DATABASE_ERROR,
                                    szInsertWC(pNC->StringName),
                                    NULL,
                                    NULL);

                            Assert(!"Cannot commit Instantiated NC (failed DBRepl)\n");
                            DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                        }
                    }
                    else {
                        DPRINT1(0, "Error: failed to add %S to instantiated NC list\n",
                                    pNC->StringName);
                        Assert(!"Cannot add Instantiated NC\n");
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                    }
                }
            }
            if(bufSize)
                THFree(pVal);

        } __finally {

            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }

        ulRet = 0;

    } _finally {
        EndDraTransaction(!AbnormalTermination());

        // Allow async thread to start
        SetEvent(hevDRASetup);
    }

    DraReturn(pTHS, ulRet);

    gtimeLastPeriodicSync = DBTime();
    InsertInTaskQueue(TQ_SynchronizeReplica,
                      &gtimeLastPeriodicSync,
                      FIFTEEN_MINUTES);

    hMailReceiveThread = (HANDLE) _beginthreadex(NULL,
                                                 0,
                                                 MailReceiveThread,
                                                 NULL,
                                                 0,
                                                 &gMailReceiveTid);

    InsertInTaskQueue(TQ_DelayedMailStart, NULL, MAIL_DELAY_SECS);

    // Check for early termination

    if (!gulNCUnsyncedWrite) {
        // Writes are done, now check synced atleast once criteria
        CheckFullSyncProgress( (void *) NULL, NULL, NULL );
    }

    // If there are no readonly sync's to perform, update the anchor immediately
    if (!gulNCUnsyncedReadOnly) {
        // Reads are done, promote to GC if necessary
        UpdateGCAnchorFromDsaOptionsDelayed( TRUE /* startup */ );
    }

    if (gulNCUnsynced) {
        // Attempt to initial sync replicas as required.
        CheckSyncProgress((void *) TRUE, NULL, NULL);
    } else {
        // Call routine to determine of admin updates can be enabled.
        CheckInitSyncsFinished();
    }

    return ulRet;
}

void
DelayedMailStart(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

// Just calls DRAEnsureMailRunning. Can't call that directly because of
// different parameters

Arguments:

    pv -
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    pv;
    ppvNext;
    pcSecsUntilNextIteration;

    DRAEnsureMailRunning();
} /* DelayedMailStart */

void
AddInitSyncList(
    IN  DSNAME *  pNC,
    IN  ULONG     ulReplicaFlags,
    IN  LPWSTR    pszDSA
    )

/*++

Routine Description:

// Keeps records of sync status of NCs. Called when we startup and have
// a replica to initial sync, or when we add a new replica.

Arguments:

    pNC -
    ulReplicaFlags -
    pszDSA -

Return Value:

    None

--*/

{
    DWORD cchDSA;
    NCSYNCDATA **ppNCSDTemp;
    NCSYNCSOURCE **ppNcSyncSource;

    // Mail-based relicas are not init sync
    Assert(!(ulReplicaFlags & DRS_MAIL_REP));

    DPRINT3( 1, "Adding (nc %ws, source %ws, flags 0x%x) to unsynced list\n",
             pNC->StringName, pszDSA, ulReplicaFlags );
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_DRA_ADUPD_INC_SRC,
             szInsertDN(pNC),
             szInsertWC(pszDSA),
             szInsertUL(ulReplicaFlags));

    EnterCriticalSection(&csNCSyncData);

    __try {
        // If we are finished, we don't keep track anymore
        if (gfInitSyncsFinished) {
            __leave;
        }

        // Search for the NC in the list.

        for (ppNCSDTemp = &gpNCSDFirst; *ppNCSDTemp;
                                ppNCSDTemp = &((*ppNCSDTemp)->pNCSDNext)) {
            if (NameMatched (pNC, &((*ppNCSDTemp)->NC))) {
                break;
            }
        }

        // If it's not there, allocate and keep track of this NC

        if (!(*ppNCSDTemp)) {

            DWORD cb = sizeof(NCSYNCDATA) + pNC->structLen;

            *ppNCSDTemp =DRAMALLOCEX (cb);

            memset((*ppNCSDTemp), 0, cb);
            // Save NC

            memcpy (&((*ppNCSDTemp)->NC), pNC, pNC->structLen);
            (*ppNCSDTemp)->ulReplicaFlags = ulReplicaFlags;

            // Increment the count of sources that need to be synced.
            gulNCUnsynced++;
            if (ulReplicaFlags & DRS_WRIT_REP) {
                gulNCUnsyncedWrite++;
            } else {
                gulNCUnsyncedReadOnly++;
            }
        }

        // Allocate memory for name and copy over.

        for (ppNcSyncSource = &((*ppNCSDTemp)->pFirstSource);
                    *ppNcSyncSource; ppNcSyncSource = &((*ppNcSyncSource)->pNextSource)) {
        }

        cchDSA = wcslen(pszDSA);
        *ppNcSyncSource = DRAMALLOCEX(sizeof(NCSYNCSOURCE)
                                      + sizeof(WCHAR) * (cchDSA + 1) );

        (*ppNcSyncSource)->fCompletedSrc = FALSE;
        (*ppNcSyncSource)->ulResult = ERROR_DS_DRA_REPL_PENDING;
        (*ppNcSyncSource)->pNextSource = NULL;
        (*ppNcSyncSource)->cchDSA = cchDSA;
        wcscpy((*ppNcSyncSource)->szDSA, pszDSA);

        // Increment the count of sources for this NC

        (*ppNCSDTemp)->ulUntriedSrcs++;

    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* AddInitSyncList */

void
InitSyncAttemptComplete(
    IN  DSNAME *  pNC,
    IN  ULONG     ulOptions,
    IN  ULONG     ulResult,
    IN  LPWSTR    pszDSA
    )

/*++

Routine Description:

Record that this NC has been synced (either successfully or otherwise)

Note that our callers, replica delete and replica sync, are simple and liberal
in when they call us. They do not check whether the sync in progress was an actual
init sync. They err on the side of notifying too often rather than leave an init sync
incomplete. Thus we must be generous and defensive in screening out unnecessary
notifications.

Arguments:

    pNC - naming context
    ulResult - final error
    pszDSA - source server

Return Value:

    None

--*/

{
    NCSYNCDATA * pNCSDTemp;
    NCSYNCSOURCE *pNcSyncSource;
    ULONG prevWriteCount = gulNCUnsyncedWrite;
    ULONG prevReadOnlyCount = gulNCUnsyncedReadOnly;

    // Ignore if we're installing.
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return;
    }

    // No longer trying this NC.

    EnterCriticalSection(&csNCSyncData);

    __try {
        // If init syncs are finished, we don't keep track anymore
        if (gfInitSyncsFinished) {
            __leave;
        }

        // Find NC in list

        pNCSDTemp = GetNCSyncData (pNC);
        if (!pNCSDTemp) {
            // This NC completed a sync while init syncs were active, but it was
            // not one of the NCs that was chosen for init sync.  Not all NCs are
            // init synced. The criteria for which NCs are init synced can be found
            // in InitDraTasks(). Just ignore it.
            __leave;
        }

        // Find source.

        for (pNcSyncSource = pNCSDTemp->pFirstSource; pNcSyncSource;
                                pNcSyncSource = pNcSyncSource->pNextSource) {
            if (DnsNameCompare_W(pNcSyncSource->szDSA, pszDSA)) {
                break;
            }
        }

        // Only do the rest of this routine if source is not already completed and we
        // knew about this source.

        if (pNcSyncSource && (!pNcSyncSource->fCompletedSrc)) {

            DPRINT3( 1, "Marking (nc %ws, source %ws) as init sync complete, status %d\n",
                     pNC->StringName, pszDSA, ulResult );

            // Any kind of sync may complete an NC waiting for an init sync.  It just
            // depends on which sync completes first. It may be an INIT_SYNC_NOW sync,
            // or a PERIODIC sync, or a user-requested sync.

            // Record progress
            pNcSyncSource->ulResult = ulResult;

            // Set source as completed (synced or failed)
            pNcSyncSource->fCompletedSrc = TRUE;

            LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_VERBOSE,
                              DIRLOG_DRA_ADUPD_DEC_SRC,
                              szInsertDN(pNC),
                              szInsertWC(pszDSA),
                              szInsertWin32Msg(ulResult),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof(ulResult),
                              &ulResult );

            // If we synced ok from this source, record it
            // here. This stops future syncs of this NC trying to get
            // modifications made by any DSA.

            if ((!ulResult) && (!(pNCSDTemp->fSyncedFromOneSrc))) {
                pNCSDTemp->fSyncedFromOneSrc = TRUE;

                // If this NC is not marked complete (could have been completed
                // by RPC failing all sources, not by syncing) then mark as complete
                // and decrement unsynced NCs count.

                if (!(pNCSDTemp->fNCComplete)) {
                    pNCSDTemp->fNCComplete = TRUE;

                    // NC is synced, decrement unsynced count.

                    if (gulNCUnsynced) {
                        gulNCUnsynced--;
                        if (pNCSDTemp->ulReplicaFlags & DRS_WRIT_REP) {
                            gulNCUnsyncedWrite--;
                        } else {
                            gulNCUnsyncedReadOnly--;
                        }
                    } else {
                        // Count of all unsynced Naming contexts should
                        // never go negative.
                        DRA_EXCEPT (DRAERR_InternalError, gulNCUnsynced);
                    }
                    DPRINT2( 1, "nc %ws successfully init synced from source %ws\n",
                             pNC->StringName, pNcSyncSource->szDSA );
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_DRA_ADUPD_NC_SYNCED,
                             szInsertDN(pNC),
                             szInsertWC(pNcSyncSource->szDSA),
                             NULL);
                }
            }

            // Sync has been attempted, increment tried sources, decrement
            // untried sources, and if we've tried all sources, decrement
            // the count of NCs for which we're waiting.

            pNCSDTemp->ulTriedSrcs++;

            if (pNCSDTemp->ulUntriedSrcs) {
                (pNCSDTemp->ulUntriedSrcs)--;
                if ((!(pNCSDTemp->ulUntriedSrcs)) && (!(pNCSDTemp->fSyncedFromOneSrc))) {

                    // If we weren't fully synced and this was the last source, and
                    // thsi NC isn't already marked complete, mark complete now
                    // and decrement unsynced NCs count.

                    if (!(pNCSDTemp->fNCComplete)) {
                        pNCSDTemp->fNCComplete = TRUE;
                        if (gulNCUnsynced) {
                            gulNCUnsynced--;
                            if (pNCSDTemp->ulReplicaFlags & DRS_WRIT_REP) {
                                gulNCUnsyncedWrite--;
                            } else {
                                gulNCUnsyncedReadOnly--;
                            }
                            DPRINT1( 1, "nc %ws had to give up init sync\n",
                                     pNC->StringName );
                            LogEvent(DS_EVENT_CAT_REPLICATION,
                                     DS_EVENT_SEV_VERBOSE,
                                     DIRLOG_ADUPD_NC_GAVE_UP,
                                     szInsertDN(pNC),
                                     NULL,
                                     NULL);
                        } else {
                            // Count of all unsynced Naming contexts should
                            // never go negative.
                            DRA_EXCEPT (DRAERR_InternalError, gulNCUnsynced);
                        }
                    }
                }
            } else {
                // Count of all unsynced sources should
                // never go negative.
                DRA_EXCEPT (DRAERR_InternalError, pNCSDTemp->ulUntriedSrcs);
            }

            // Some NCs have finished syncing: see if there is anything to do
            if ( (prevWriteCount) && (!gulNCUnsyncedWrite) ) {
                // Write count transitioned to zero
                CheckFullSyncProgress( (void *) NULL, NULL, NULL );
            }
            if ( (prevReadOnlyCount) && (!gulNCUnsyncedReadOnly) ) {
                // ReadOnly count transitioned to zero
                // Promote to GC if necessary
                UpdateGCAnchorFromDsaOptionsDelayed( TRUE /* startup */ );
            }

            // Ok, we have synced or attempted all NCs.
            // Check admin update status and cleanup.
            if (!gulNCUnsynced) {
                CheckInitSyncsFinished();
            }
        }
    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* InitSyncAttemptComplete */


BOOL
draIsInitSyncCompleteForNc(
    IN DSNAME * pNC
    )

/*++

Routine Description:

Check whether initial synchronizations have been completed for this NC.

Note that we return FALSE if initial synchronizations have not started yet.

If an NC was not marked for initial synchronization, it will not be in the
list.  We interpret this situation to mean it is complete.

An init sync can have completed with a successful sync from source, or
may have failed to sync from any source.  We only care whether a sync
attempt is complete, not whether the sync was ultimately successful or
not.

Arguments:

    pNC - Naming context to check

Return Value:

    BOOL - TRUE - Is it complete

--*/

{
    NCSYNCDATA * pNCSDTemp;
    BOOL fResult = FALSE;

    // Can't complete if haven't started yet
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return FALSE;
    }

    EnterCriticalSection(&csNCSyncData);
    __try {
        // If initial synchronizations are done, this nc is done
        if (gfInitSyncsFinished) {
            fResult = TRUE;
            __leave;
        }

        // Get the sync data record. No record means nc does not
        // require an init sync. This nc is done.
        pNCSDTemp = GetNCSyncData (pNC);
        if (!pNCSDTemp) {
            fResult = TRUE;
            __leave;
        }

        // Is this NC sync data record complete?
        fResult = pNCSDTemp->fNCComplete;
    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }

    return fResult;
} /* DraIsInitSyncCompleteForNc */

NCSYNCDATA *
GetNCSyncData(
    DSNAME *pNC
    )

/*++

Routine Description:

// Find NC in NC sync data linked list. Returns NULL if not found. Caller
// must have entered critical section

Arguments:

    pNC -

Return Value:

    NCSYNCDATA * -

--*/

{
    NCSYNCDATA *pNCSDTemp;

    // Find NC in list

    for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;
                                    pNCSDTemp = pNCSDTemp->pNCSDNext) {
        if (NameMatched (pNC, &(pNCSDTemp->NC))) {
            break;
        }
    }
    return pNCSDTemp;
} /* GetNCSyncData */

void
CheckInitSyncsFinished(
    void
    )

/*++

Routine Description:

This routine determines if admin updates can be enabled.

Normally, this check is looking for the number of unsynced partitions to go
to zero.  However, this process can be short circuited by setting the
wait initial synchronizations to zero.

Arguments:

    void -

Return Value:

    None

--*/

{

    NCSYNCDATA *pNCSDTemp;
    NCSYNCDATA *pNCSDNext;
    NCSYNCSOURCE *pNcSyncSource;
    NCSYNCSOURCE *pNcSyncSourceNext;

    EnterCriticalSection(&csNCSyncData);
    __try {

        // Check that there we are installed, that there are no
        // unsynced NCs

        if (DsaIsRunning() &&
            (!gfInitSyncsFinished) &&
            (!gulNCUnsynced) ) {

            Assert( !gulNCUnsyncedWrite );
            Assert( !gulNCUnsyncedReadOnly );
            gfInitSyncsFinished = TRUE;

            // Walk list freeing NC data allocations if any

            for (pNCSDTemp = gpNCSDFirst; pNCSDTemp;) {
                pNCSDNext = pNCSDTemp->pNCSDNext;

                // Free all source allocations

                for (pNcSyncSource = pNCSDTemp->pFirstSource; pNcSyncSource;) {
                    pNcSyncSourceNext = pNcSyncSource->pNextSource;
                    DRAFREE (pNcSyncSource);
                    pNcSyncSource = pNcSyncSourceNext;
                }
                DRAFREE (pNCSDTemp);
                pNCSDTemp = pNCSDNext;
            }
            gpNCSDFirst = NULL;

            DPRINT( 1, "This server has finished the initial syncs phase.\n" );
            LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_VERBOSE,
                        DIRLOG_DRA_ADUPD_ALL_SYNCED,
                        NULL,
                        NULL,
                        NULL);
        }
    } __finally {
        LeaveCriticalSection(&csNCSyncData);
    }
} /* CheckInitSyncsFinished */

void
SynchronizeReplica(
    IN  void *  pvParam,
    OUT void ** ppvParamNextIteration,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

// SynchronizeReplica - Looks for NCs and decides whether
// they need to be periodic synced NOW.  Called from the taskq, and
// reschedules itself after it has run.
//
// Its one parameter is the last time it ran.  It will try to do necessary
// period syncs scheduled between now and the last time it ran.

Arguments:

    pvParam -
    ppvParamNextIteration -
    pcSecsUntilNextIteration -

Return Value:

    None

--*/

{
    DBPOS *pDBTmp;
    DSNAME *pNC=NULL;
    REPLICA_LINK *pRepsFromRef;
    UCHAR *pVal;
    ULONG len;
    ULONG ulRet;
    DSTIME timeNow = DBTime();
    DSTIME timeLastIteration;
    SYNTAX_INTEGER it;
    THSTATE *pTHS = pTHStls;

    Assert(NULL != pvParam);
    timeLastIteration = *((DSTIME *)pvParam);

    *((DSTIME *)pvParam)      = timeNow;
    *ppvParamNextIteration    = pvParam;
    *pcSecsUntilNextIteration = FIFTEEN_MINUTES;

    Assert(!DsaIsInstalling());

    // Set up DB stuff
    if (InitFreeDRAThread(pTHS, SYNC_READ_ONLY)) {
        // Failure,(probably memory) give up.
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_PR_ALLOC_FAIL,
                 NULL,
                 NULL,
                 NULL);
        return;
    }

    __try {
        // Read DSA object and find all the replicas.
        if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
            DRA_EXCEPT (DRAERR_InternalError, ulRet);
        }

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {
            int i;
            ULONG ulSyncFlags;

            // Search the master and replica NCs to see if there are any that
            // need to be periodically synched. We search the
            // master NCs so that we'll find the writeable replicas too.

            for (i = 0; i < ARRAY_SIZE(gAtypeCheck); i++) {
                ULONG NthValIndex=0;
                ULONG bufSize = 0;

                while (!(DBGetAttVal(pTHS->pDB,
                                     ++NthValIndex,
                                     gAtypeCheck[i].AttrType,
                                     0,
                                     0,
                                     &len, (UCHAR**)&pNC))) {
                    // are we being signalled to shutdown?
                    if (eServiceShutdown) {
                        DRA_EXCEPT(DRAERR_Shutdown, 0);
                    }

                    // Go to the NC
                    if (ulRet = FindNC(pDBTmp,
                                       pNC,
                                       gAtypeCheck[i].ulFindNCFlags,
                                       &it)) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ulRet);
                    }

                    if (it & IT_NC_GOING) {
                        // NC tear down has partially completed.  Make sure
                        // there is an operation in the task queue to continue
                        // to make progress.
                        Assert(!DBHasValues(pDBTmp, ATT_REPS_FROM));

                        DirReplicaDelete(pNC,
                                         NULL,
                                         DRS_ASYNC_OP | DRS_NO_SOURCE
                                            | DRS_REF_OK | DRS_IGNORE_ERROR);
                    } else {
                        ULONG NthValIndex = 0;
                        // Get the repsfrom attribute

                        while(!(DBGetAttVal(pDBTmp,
                                            ++NthValIndex,
                                            ATT_REPS_FROM,
                                            DBGETATTVAL_fREALLOC,
                                            bufSize,
                                            &len,&pVal))) {
                            bufSize = max(bufSize, len);

                            Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
                            VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                            pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufSize);
                            //note: we preserve pVal for DBGetAttVal realloc
                            pVal = (PUCHAR)pRepsFromRef;
                            Assert(bufSize >= pRepsFromRef->V1.cb);

                            Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

                            if (     ( pRepsFromRef->V1.ulReplicaFlags & DRS_PER_SYNC )
                                 && !( pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_PERIODIC_SYNC )
                                 &&  ( fIsBetweenTime(
                                        &pRepsFromRef->V1.rtSchedule,
                                        timeLastIteration,
                                        timeNow
                                        )
                                     )
                               )
                            {
                                ulSyncFlags = (pRepsFromRef->V1.ulReplicaFlags
                                                & AO_PRIORITY_FLAGS)
                                              | DRS_PER_SYNC
                                              | DRS_ASYNC_OP;

                                if (!(pRepsFromRef->V1.ulReplicaFlags
                                      & DRS_MAIL_REP)
                                    && !(pRepsFromRef->V1.ulReplicaFlags
                                         & DRS_NEVER_NOTIFY)) {
                                    // Tell the source DSA to make sure it has a
                                    // Reps-To for the local DSA.  This ensures
                                    // the source sends us change notifications.
                                    ulSyncFlags |= DRS_ADD_REF;
                                }

                                DirReplicaSynchronize(
                                        pNC,
                                        NULL,
                                        &pRepsFromRef->V1.uuidDsaObj,
                                        ulSyncFlags);
                            }

                            // are we being signalled to shutdown?

                            if (eServiceShutdown) {
                                DRA_EXCEPT(DRAERR_Shutdown, 0);
                            }
                        }
                    }
                } /* while */
                if(bufSize)
                    THFree(pVal);
            }

            timeLastIteration = timeNow;
        }
        __finally {
            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }
    }

    __finally {


        CloseFreeDRAThread (pTHStls, TRUE);

        EndDraTransaction(!AbnormalTermination());

        // Ok, we're all done.  Reschedule ourselves.

        *((DSTIME *)pvParam)      = timeLastIteration;
        *ppvParamNextIteration    = pvParam;
        *pcSecsUntilNextIteration = FIFTEEN_MINUTES;
    }


    return;

} /* SynchronizeReplica */

int
DSTimeTo15MinuteWindow(
    IN  DSTIME  dstime
    )

/*++

Routine Description:

    Determines which 15-minute window during the week that the given DSTIME
    falls into.  Window 0 is Sunday 12am to 12:14am, window 1 is Sunday
    12:15am to 12:29am, etc.

Arguments:

    dstime (IN) - DSTIME to convert.

Return Values:

    The corresponding 15-minute window.

--*/

{
    int         nWindow;
    SYSTEMTIME  systime;

    DSTimeToUtcSystemTime(dstime, &systime);

    nWindow = (systime.wMinute +
               systime.wHour * 60 +
               systime.wDayOfWeek * 24 * 60) / 15;

    return nWindow;
}


BOOL
fIsBetweenTime(
    REPLTIMES * prt,
    DSTIME timeBegin,
    DSTIME timeEnd
    )

/*++

Routine Description:

// fIsBetweenTime - parse the synchronization schedule to see if any of
//  the bits that are set in the schedule are between timeBegin and timeEnd,
//  not including the 15 minute segment specified by tBeginning, and dealing
//  correctly with wrapping around the end of the week.
//
//  this is called only from SynchronizeReplica to see if we need to sync
//  a particular NC source right now.

Arguments:

    prt -
    timeBegin -
    timeEnd -

Return Value:

    BOOL -

--*/

{
    int bBeginning, bBeginByte;
    UCHAR bBeginBitMask;
    int bEnd, bEndByte;
    UCHAR bEndBitMask;
    int nbyte;
    UCHAR * pVal = prt->rgTimes;

    // Convert to 15 minute segment since start of week.
    bBeginning = DSTimeTo15MinuteWindow(timeBegin);
    bEnd       = DSTimeTo15MinuteWindow(timeEnd);

    /*
     * if any bits in the schedule from (bBeginning, bEnd] are set,
     * return TRUE.
     */

    if(bBeginning != bEnd) {
        /* tBeginning and tEnd are not in the same fifteen minute segment.
         * adjust the count to deal with this, being careful to wrap to the
         * next week.
         */
        bBeginning = (bBeginning + 1) % (7 * 24 * 4);
    }

    bBeginByte = bBeginning / 8;
    bBeginBitMask = (0xFF >> (bBeginning % 8)) & 0xFF;
    bEndByte = bEnd / 8;
    bEndBitMask = (0xFF << (7-(bEnd % 8))) & 0xFF;


    if(bBeginByte == bEndByte) {
        /* need to have the bitmask only hit some of the bits in
         * the appropriate byte, as only one byte is in question here.
         */
        bBeginBitMask = (bEndBitMask &= bBeginBitMask);
    }

    if(pVal[bBeginByte] & bBeginBitMask) {
        return TRUE;
    }

    if(bBeginByte == bEndByte) {
        return FALSE;
    }

    if(bBeginByte < bEndByte)
        for(nbyte = bBeginByte+1;nbyte < bEndByte; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
    else {
        for(nbyte = bBeginByte+1;nbyte < 84; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
        for(nbyte = 0;nbyte < bEndByte; nbyte++) {
            if(pVal[nbyte]) {
                return TRUE;
            }
        }
    }


    if(pVal[bEndByte] & bEndBitMask) {
        return TRUE;
    }

    return FALSE;
} /* fIsBetweenTime */


BOOL
CheckPrimaryDomainFullSyncOnce(
    VOID
    )

/*++

Routine Description:

This code is only called during startup, once.  All machine types call this:
first domain in enterprise
first dc in domain
replica dc in domain

This code is designed to run in the startup thread.  We have a thread state
but not a dbpos.

Check if machine is fully installed
A machine is fully installed when either
1. It is the first machine in its domain
2. It has an uptodate vector, which means it has completed a full sync

Arguments:

    VOID -

Return Value:

    BOOL - true, primary domain is synchronized
           false, try again later

    Exceptions are raised out of this function.

--*/

{
    char szSrcRootDomainSrv[MAX_PATH];
    PDSNAME pdnDomain;
    BOOL    fHasValues = FALSE;
    DBPOS   *pDB;

    // If already synchronized, don't bother
    if (!DsIsBeingBackSynced()) {
        Assert( FALSE );  // SHOULDN'T HAPPEN
        return TRUE;
    }

    // Get the source server. No source server means first machine in domain.
    // First machine is synchronized by definition.
    if ( (GetConfigParam(SRCROOTDOMAINSRV, szSrcRootDomainSrv, MAX_PATH)) ||
         (strlen( szSrcRootDomainSrv ) == 0) )
    {
        return TRUE;
    }

    // Build a DSNAME for the domain NC
    pdnDomain = gAnchor.pDomainDN;
    if ( !pdnDomain )
    {
        // Configuration info missing!
        LogUnhandledError( 0 );
        return FALSE;
    }

    DBOpen (&pDB);
    __try {

        // Look for uptodate vector on Domain NC
        if (DBFindDSName(pDB, pdnDomain))
        {
            // We should not get here, the DRA should have previously
            // confirmed that this object does infact exist.
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

        fHasValues = DBHasValues( pDB, ATT_REPL_UPTODATE_VECTOR );
    } __finally {

        // Close the temporary pDB
        DBClose (pDB, !AbnormalTermination());
    }

    if (!fHasValues) {
        DPRINT1( 0, "Warning: NC %ws has not completed first sync: DC has not been advertised...\n",
                pdnDomain->StringName );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_ADUPD_NC_NEVER_SYNCED_WRITE,
                 szInsertDN(pdnDomain),
                 NULL,
                 NULL);
    }

    return fHasValues;
} /* CheckPrimaryDomainFullSyncOnce */


BOOL
DraIsPartitionSynchronized(
    DSNAME *pNC
    )

/*++

Routine Description:

Check whether the primary writable domain is synchronized.  To be synchronized,
two things have to be true.
1. Init syncs have to be complete for this domain.
2. The domain must have full synced once

Arguments:

    pNC - Naming context to check

Return Value:

    BOOL -

--*/

{
    // During install, we haven't even started to sync yet
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return FALSE;
    }

    // System as a whole already synchronized
    if (gfIsSynchronized) {
        return TRUE;
    }

    // Init syncs must be complete for this NC, AND
    //    This is not the domain NC OR
    //    The domain NC has fully synced atleast once

    return (draIsInitSyncCompleteForNc( pNC ) &&
            ( (!NameMatched( pNC, gAnchor.pDomainDN )) ||
              CheckPrimaryDomainFullSyncOnce() ) );

} /* DraIsPartitionSynchronized */


void
CheckFullSyncProgress(
    IN  void *  pv,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

Check that domain NC has been synchronized atleast once.
Sets IsSynchronized flag when condition is met.
Rescheduled to run periodically as a task queue entry

Arguments:

    pv - not used
    ppvNext -
    pcSecsUntilNextIteration -

Return Value:

    None
    Exceptions are raised out of this function.
    The task queue manager will ignore most of these.

--*/

{
    DWORD ulRet = 0;
    BOOL fSync = FALSE;

    DPRINT( 1, "CheckFullSyncProgress\n" );

    __try {
        __try {
            fSync = CheckPrimaryDomainFullSyncOnce();
            if (fSync) {
                // This routine logs the event
                DsaSetIsSynchronized( TRUE );
            }

            // Note that a false return here means retry
        } __finally {
            // Reschedule if necessary
            if (!fSync) {
                // Helper routine will have logged event
                DPRINT( 1, "Not ready for advertisement yet, rescheduling...\n" );
                if ( NULL != ppvNext ) {
                    // called by Task Scheduler; reschedule in-place
                    *ppvNext = (void *)NULL;
                    *pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
                } else {
                    // not called by Task Scheduler; must insert new task
                    InsertInTaskQueueSilent(
                        TQ_CheckFullSyncProgress,
                        (void *)NULL,
                        SYNC_CHECK_PERIOD_SECS,
                        TRUE);
                }
            }
        }
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckFullSyncProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }
} /* CheckFullSyncProgress */


BOOL
CheckDomainHasSourceInSite(
    THSTATE *pTHS,
    IN DSNAME *pdnDomain
    )

/*++

Routine Description:

Determine if the given domain nc has a source in this site.
We exclude ourselves.

Arguments:

    pTHS -
    pdnDomain -

Return Value:

    BOOL -

--*/

{
    BOOL     fFoundOne = FALSE;
    BOOL     fDSASave = pTHS->fDSA;

    SEARCHARG  SearchArg;
    SEARCHRES  SearchRes;

    FILTER     ObjCatFilter, HasNcFilter, AndFilter;
    FILTER     HasPartialNcFilter, OrFilter;

    CLASSCACHE  *pCC;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert( pdnDomain );
    Assert( gAnchor.pSiteDN );

    // Get the class category

    if (    !(pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA))
         || !pCC->pDefaultObjCategory )
    {
        DPRINT( 0, "Couldn't get Class Category for CLASS NTDS DSA!\n" );
        return FALSE;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjCatFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasNcFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasPartialNcFilter, sizeof( HasPartialNcFilter ) );
    RtlZeroMemory( &OrFilter, sizeof( OrFilter ) );

    HasNcFilter.choice = FILTER_CHOICE_ITEM;
    HasNcFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDomain->structLen;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pdnDomain;

    HasPartialNcFilter.choice = FILTER_CHOICE_ITEM;
    HasPartialNcFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_PARTIAL_REPLICA_NCS;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDomain->structLen;
    HasPartialNcFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pdnDomain;

    OrFilter.choice                     = FILTER_CHOICE_OR;
    OrFilter.FilterTypes.Or.count       = 2;
    OrFilter.FilterTypes.Or.pFirstFilter = &HasNcFilter;
    HasNcFilter.pNextFilter = &HasPartialNcFilter;

    // Search on object category because it is indexed
    ObjCatFilter.choice = FILTER_CHOICE_ITEM;
    ObjCatFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pCC->pDefaultObjCategory->structLen;
    ObjCatFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pCC->pDefaultObjCategory;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCatFilter;
    ObjCatFilter.pNextFilter = &OrFilter;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = gAnchor.pSiteDN;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    memset( &SearchRes, 0, sizeof(SEARCHRES) );
    SearchRes.CommRes.aliasDeref = FALSE;
    SearchRes.PagedResult.pRestart = NULL;

    // Can't use DirSearch because it expects to open and close the
    // thread state DBPOS. In this case we already have one.
    // Set fDSA to search config container

    pTHS->fDSA = TRUE;
    __try {
        SearchBody( pTHS, &SearchArg, &SearchRes, 0 );
    } __finally {
        pTHS->fDSA = fDSASave;
    }

    SearchRes.CommRes.errCode = pTHS->errCode;
    SearchRes.CommRes.pErrInfo = pTHS->pErrInfo;

    if (  0 == pTHS->errCode )
    {
        DWORD i;
        ENTINFLIST *pEntInfList;

        DPRINT2( 1, "Domain %ws can be sourced from %d servers in this site.\n",
                 pdnDomain->StringName, SearchRes.count );

        // Find atleast one system not ourself
        pEntInfList = &(SearchRes.FirstEntInf);
        for( i = 0; i < SearchRes.count; i++ ) {
            Assert( pEntInfList );
            if (!NameMatched( gAnchor.pDSADN, pEntInfList->Entinf.pName )) {
                // CODE.IMPROVEMENT: check whether source DSA is up
                fFoundOne = TRUE;
                break;
            }
            pEntInfList = pEntInfList->pNextEntInf;
        }
    }
    else
    {
        //
        // This is an unexpected condition
        //
        LogUnhandledError( pTHS->errCode );
        LogUnhandledError( DirErrorToWinError( pTHS->errCode, &(SearchRes.CommRes) ) );
    }

    THClearErrors();

    return fFoundOne;
} /* CheckDomainHasSourceInSite */


BOOL
CheckReadOnlyFullSyncOnce(
    THSTATE *pTHS,
    BOOL fStartup
    )

/*++

Routine Description:

This routine verifies that
    for each partial NCs that this server holds,
        It has fully synced once

Note that there may be a window where the config nc says there are more or
less partitions in the enterprise than what is listed on the nc head.
We ignore these.

Assume we have a thread state and PTHS->pDB is valid

Arguments:

    pTHS - thread state
    fStartup - whether is promotion is at startup or not

Return Value:

    BOOL - true, all conditions satisified
           false, try again later

    Exceptions raised on failure

--*/

{
    DWORD ulRet, level;
    DSNAME *pNC;
    BOOL fSatisfied;
    DWORD dwGCPartitionOccupancy;
    DWORD dwTotalExpected, dwTotalPresent, dwTotalFullSynced;
    DWORD dwTotalInSite, dwPresentInSite, dwFullSyncInSite;
    DWORD fInSite;

    // We used to distinguish between the startup and non-startup cases here.
    // Due to the sequence of operations at startup, it is possible for the
    // non-startup case (triggered by dsa modification) may be put into the
    // task queue before the startup case (triggered by init syncs finishing)
    // has a chance to run. This may result in this routine being run twice,
    // the second time occuring on a system which has already successfully
    // promoted.  That case is identical to the case of rebooting an existing,
    // GC, and we simply return success.

    if (gfWasPreviouslyPromotedGC) {
        // Completed gc promotion before
        // "Once a GC, always a GC"
        // This is essentially a grandfather clause rule which says we will
        // never disable a working GC on reboot.  Since GC's are so essential
        // we can't risk taking out their only one.  Thus we tradeoff GC
        // availability for global knowledge completeness.
        return TRUE;
    }

    dwTotalExpected = 0;
    dwTotalPresent = 0;
    dwTotalFullSynced = 0;
    dwTotalInSite = 0;
    dwPresentInSite = 0;
    dwFullSyncInSite = 0;

    // Search the config container for naming contexts that should be on this machine

    BeginDraTransaction(SYNC_READ_ONLY);
    __try {

        CROSS_REF_LIST *pCRL;

        for (pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR) {

            BOOL fHasSources = FALSE, fHasUTDVec = FALSE;
            SYNTAX_INTEGER it;

            // are we being signalled to shutdown?
            if (eServiceShutdown) {
                DRA_EXCEPT(DRAERR_Shutdown, 0);
            }

            // We are not interested in non domain partitions
            if ((pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN) == 0) {
                continue;
            }

            // It is expected to eventually be present on this GC.
            dwTotalExpected++;

            // Are any sources in site?
            if (CheckDomainHasSourceInSite( pTHS, pCRL->CR.pNC )) {
                dwTotalInSite++;
                fInSite = TRUE;
            } else {
                fInSite = FALSE;
            }

            // Check for NC alive and instantiated

            ulRet = FindNC(pTHS->pDB, pCRL->CR.pNC,
                           FIND_MASTER_NC | FIND_REPLICA_NC, &it);
            DPRINT2( 2, "FindNC(%ws) = %d\n", pCRL->CR.pNC->StringName, ulRet );
            if (ulRet) {
                // Tell the user the problem
                DPRINT1( 0, "Warning: NC %ws is not present on this server yet.\n",
                         pCRL->CR.pNC->StringName );

		LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ADUPD_GC_NC_MISSING, 
                         szInsertDN((pCRL->CR.pNC)),
                         NULL,
                         NULL);

                continue;
            }

            // Writable partitions aren't included
            if (FMasterIt(it)) {
                dwTotalExpected--;
                if (fInSite) {
                    dwTotalInSite--;
                }
                continue;
            }

            dwTotalPresent++;

            if ( fInSite ) {
                dwPresentInSite++;
            }

            // REPS-FROM present on RO NC indicates not being deleted
            fHasSources = DBHasValues( pTHS->pDB, ATT_REPS_FROM );
            // UTDVECTOR present indicates successfull sync
            fHasUTDVec = DBHasValues( pTHS->pDB, ATT_REPL_UPTODATE_VECTOR );

            if (fHasSources && fHasUTDVec && !(it &(IT_NC_COMING | IT_NC_GOING))) {
                dwTotalFullSynced++;
                if ( fInSite ) {
                    dwFullSyncInSite++;
                }
            } else {
                // Tell the user the problem
		ULONG cbRepsFrom = 0;
		REPLICA_LINK * pRepsFrom = NULL;
		ULONG ulRepsFrom = 0;
		ATTCACHE *pAC = NULL;  
		CHAR pszLastAttempt[SZDSTIME_LEN + 1];

		pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
		Assert(NULL != pAC);

		while (!DBGetAttVal_AC(pTHS->pDB, ++ulRepsFrom, pAC, 0,
				       0, &cbRepsFrom,
				       (BYTE **) &pRepsFrom)) {  
		    LPWSTR pszDSA = NULL;
		    LPWSTR pszTransport = NULL;
		    Assert(1 == pRepsFrom->dwVersion);

		    // potentially fix repsfrom version &  recalc size
		    pRepsFrom = FixupRepsFrom(pRepsFrom, &cbRepsFrom);
		    
		    pszTransport = GetTransportDisplayName(pTHS, &(pRepsFrom->V1.uuidTransportObj));  
		    pszDSA = GetNtdsDsaDisplayName(pTHS, &(pRepsFrom->V1.uuidDsaObj));

		    if ((pRepsFrom->V1.ulResultLastAttempt==0) || (0 == pRepsFrom->V1.cConsecutiveFailures)) {  
			LogEvent8(DS_EVENT_CAT_GLOBAL_CATALOG,
				  DS_EVENT_SEV_ALWAYS,
				  DIRLOG_ADUPD_NC_SYNC_PROGRESS,
				  szInsertDN((pCRL->CR.pNC)),
				  szInsertWC(pszDSA),
				  pszTransport ? szInsertWC(pszTransport) : szInsertDsMsg(DIRLOG_RPC_MESSAGE),
				  szInsertUSN(pRepsFrom->V1.usnvec.usnHighObjUpdate),
				  szInsertDSTIME(pRepsFrom->V1.timeLastAttempt,pszLastAttempt),
				  szInsertUL(pRepsFrom->V1.ulResultLastAttempt),
				  szInsertWin32Msg(pRepsFrom->V1.ulResultLastAttempt),
				  NULL);
			DPRINT4( 0, 
				 "GC Sync'ed and didn't complete\n\tNC=%S\n\tServer=%S(via %S)\n\tUSN=%d\n",
				 pCRL->CR.pNC->StringName,
				 pszDSA,
				 pszTransport,    
				 pRepsFrom->V1.usnvec.usnHighObjUpdate);
		    }
		    else
		    {
			LogEvent8(DS_EVENT_CAT_GLOBAL_CATALOG,
				  DS_EVENT_SEV_ALWAYS,
				  DIRLOG_ADUPD_NC_SYNC_NO_PROGRESS,
				  szInsertDN((pCRL->CR.pNC)),
				  szInsertWC(pszDSA),
				  pszTransport ? szInsertWC(pszTransport) : szInsertDsMsg(DIRLOG_RPC_MESSAGE),
				  szInsertUSN(pRepsFrom->V1.usnvec.usnHighObjUpdate),
				  szInsertDSTIME(pRepsFrom->V1.timeLastAttempt,pszLastAttempt),
				  szInsertUL(pRepsFrom->V1.cConsecutiveFailures),
				  szInsertUL(pRepsFrom->V1.ulResultLastAttempt),
				  szInsertWin32Msg(pRepsFrom->V1.ulResultLastAttempt));
			DPRINT5( 0, 
				 "GC Sync Failed\n\tNC=%S\n\tServer = %S(via %S)\n\tError=%d\n\tAttempts=%d\n",
				 pCRL->CR.pNC->StringName,
				 pszDSA,
				 pszTransport,
				 pRepsFrom->V1.ulResultLastAttempt,
				 pRepsFrom->V1.cConsecutiveFailures);
		    }
		      
		    if (pszDSA) {
			THFreeEx(pTHS,pszDSA);
		    }
		    if (pszTransport) {
			THFreeEx(pTHS,pszTransport);
		    }
		    // else error message
		    if (pRepsFrom) {
			THFreeEx(pTHS,pRepsFrom);
		    }
		    cbRepsFrom=0;

		}  

		DPRINT1( 0, "Warning: NC %ws has not fully synced once yet.\n",
			 pCRL->CR.pNC->StringName ); 
            }
        }



    } _finally {
        EndDraTransaction(!AbnormalTermination());
    }

    // If an error occurred in the above detection loop, an exception will
    // have been raised, returning control to the caller.

    // Get the occupancy requirement
    dwGCPartitionOccupancy = GC_OCCUPANCY_DEFAULT;

    GetConfigParam(GC_OCCUPANCY, &dwGCPartitionOccupancy, sizeof(DWORD));

    // ensure we're not past the limits
    if ( dwGCPartitionOccupancy > GC_OCCUPANCY_MAX ) {
        dwGCPartitionOccupancy = GC_OCCUPANCY_MAX;
    }

    DPRINT1( 1, "GC Domain Occupancy: Level:%d\n", dwGCPartitionOccupancy);
    DPRINT3( 1, "  INSITE:   Expected:%d, Present:%d, FullSynced:%d\n",
                dwTotalInSite, dwPresentInSite, dwFullSyncInSite);
    DPRINT3( 1, "  INFOREST: Expected:%d, Present:%d, FullSynced:%d\n",
                dwTotalExpected, dwTotalPresent, dwTotalFullSynced);

    // Are there other domains to acquire? If not, we're done!
    if (dwTotalExpected == 0) {
        return TRUE;
    }

    fSatisfied = TRUE;

    for( level = (GC_OCCUPANCY_MIN + 1);
         (level < (GC_OCCUPANCY_MAX + 1) );
         level++ ) {

        if (level > dwGCPartitionOccupancy) {
            // We have exceeded the occupancy requirement
            break;
        }
        switch (level) {
// 1 - Atleast one readonly nc was added
        case GC_OCCUPANCY_ATLEAST_ONE_ADDED:
            fSatisfied = (dwTotalPresent > 0);
            break;
// 2 - At least one nc synced fully
        case GC_OCCUPANCY_ATLEAST_ONE_SYNCED:
            fSatisfied = (dwTotalFullSynced > 0);
            break;
// 3 - All ncs have been added (at least one synced) IN SITE
        case GC_OCCUPANCY_ALL_IN_SITE_ADDED:
            fSatisfied = (dwPresentInSite == dwTotalInSite);
            break;
// 4 - All nc's synced fully IN SITE
        case GC_OCCUPANCY_ALL_IN_SITE_SYNCED:
            fSatisfied = (dwFullSyncInSite == dwTotalInSite);
            break;
// 5 - All ncs have been added (at least one synced) IN FOREST
        case GC_OCCUPANCY_ALL_IN_FOREST_ADDED:
            fSatisfied = (dwTotalPresent == dwTotalExpected);
            break;
// 6 - All nc's synced fully IN FOREST
        case GC_OCCUPANCY_ALL_IN_FOREST_SYNCED:
            fSatisfied = (dwTotalFullSynced == dwTotalExpected);
            break;
        default:
            Assert( FALSE );
        }
        if (!fSatisfied) {
            break;
        }
    }

    if (!fSatisfied) {
        DPRINT2( 0, "Warning: GC Occupancy requirement not met: requirement is %d; current level is %d\n",
                 dwGCPartitionOccupancy, level - 1 );
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GC_OCCUPANCY_NOT_MET,
                 szInsertUL(dwGCPartitionOccupancy),
                 szInsertUL(level - 1),
                 NULL);
        if ( dwTotalExpected > dwTotalInSite ) {
            //
            // There's at least one NC w/ no intra-site sources.
            // Tell admin to expect the delay until we get a
            // scheduled sync from those sources.
            //
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_GC_NO_INTRA_SITE_SOURCES,
                     szInsertUL(dwGCPartitionOccupancy),
                     szInsertUL(level - 1),
                     NULL);
        }
    }

    return fSatisfied;

} /* CheckReadOnlyFullSyncOnce */


void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )

/*++

Routine Description:

Task queue function to see if all the readonly NCs are here.
When they are, finish GC promotion

Arguments:

    pvParam -
    ppvParamNextIteration -
    pcSecsUntilNextIteration -

Return Value:

    None

Remarks:

    Exceptions are raised out of this function.
    The task queue manager will ignore most of these.

    Multi-Thread Limitation: This function cannot execute
    in parallel with itself, nor it does, should, or would.

--*/

{
    THSTATE *pTHS = pTHStls;
    DWORD ulRet = 0;
    BOOL fStartup;
    BOOL fResched = TRUE;
    BOOL fGcDsa = FALSE;
    BOOL fGiveup = FALSE;       // for debugging only
    DWORD       dwOptions = 0;
    DWORD       cbOptions;
    DWORD *     pdwOptions = &dwOptions;

    // static: valid during entire program lifetime (w/ function scope).
    static DWORD dwStartGcPromotionTime = 0;
    static DWORD dwFailedAttempts = 0;

    fStartup = (BOOL)(pvParam != NULL);

    DPRINT( 1, "CheckGCPromotionProgress\n" );

    if (!dwStartGcPromotionTime) {
        //
        // dwStartGcPromotionTime marks the time at which the promotion
        // has started (typically, the time one set the ntdsDsa
        // options = 1). It is used to potentially short a delayed
        // promotion & force it to complete.
        //
        // Here, we're setting the initial time at which the promotion has
        // started, and reset failed attempts count.
        //
        dwStartGcPromotionTime = GetTickCount();
        dwFailedAttempts = 0;
    }

    __try {

	EnterCriticalSection(&csGCState);
	__try { 

	    __try {

		//
		// Check GC conditions:
		//  - read & test ntdsDSa's options.
		//  - see if inbound repl is disabled or the
		//    promotion request has been reverted meanwhile.
		// 

		BeginDraTransaction(SYNC_READ_ONLY);
		__try {

		    // Find the DSA object

		    if (ulRet = DBFindDSName(pTHS->pDB, gAnchor.pDSADN)) {
			DRA_EXCEPT (DRAERR_InternalError, ulRet);
		    }

		    if ( 0 != DBGetAttVal( pTHS->pDB, 1, ATT_OPTIONS,
					   DBGETATTVAL_fCONSTANT, sizeof( dwOptions ),
					   &cbOptions, (unsigned char **) &pdwOptions ) ) {
			dwOptions = 0; // 'salright -- no options set
		    }
		} _finally {
		    EndDraTransaction(!AbnormalTermination());
		}

		fGcDsa = (dwOptions & NTDSDSA_OPT_IS_GC) != 0;

		if (!fGcDsa) {
		    //
		    // Options indicate that we do not wish to become a GC any longer.
		    //
		    DPRINT( 0, "CheckGCPromotionProgress: No longer wish to be a GC: task exiting...\n" );
		    fResched = FALSE;  // do not reschedule
		    if ( !gAnchor.fAmGC ) {
			// Demotion already noted. nothing to do.
			// Just exit.
			__leave;
		    }
		} else {

		    //
		    // GC promotion required.
		    // Test conditions for promotion state:
		    //  - User promotion force via DelayAdvertisement regkey
		    //  - CheckReadOnlyFullSyncOnce
		    //

		    DWORD dwGCDelayAdvertisement = DEFAULT_GC_DELAY_ADVERTISEMENT;

		    // Check if user requested override of delay feature
		    // Can be used to abort the task as well since it is read each time.
		    // The time we started promotion is recorded in dwStartGcPromotionTime.
		    // If the elapsed time of the delay is greater than the delay limit, abort.
		    GetConfigParam(GC_DELAY_ADVERTISEMENT, &dwGCDelayAdvertisement, sizeof(DWORD));
		    if ( (DifferenceTickTime( GetTickCount(), dwStartGcPromotionTime) / 1000) >
			 dwGCDelayAdvertisement ) {
			// No delay, do it right away
			DPRINT( 0, "GC advertisement delay aborted. Promotion occurring now.\n" );
			LogEvent(DS_EVENT_CAT_REPLICATION,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_GC_PROMOTION_CHECKS_DISABLED,
				 szInsertUL(dwGCDelayAdvertisement / 60),
				 szInsertUL(dwGCDelayAdvertisement % 60),
				 NULL);
			fResched = FALSE;
		    }
		    else {
			fResched = !CheckReadOnlyFullSyncOnce( pTHS, fStartup );
		    }
		}

		//
		// Done checking conditions.
		// Now, if no re-scheduling is required, update GC marks.
		//
		if (!fResched) {
		    // Do not reschedule task.
		    // Update GCness marks right now.
		    // Note: this can apply both to promotion & demotion.
		    ulRet = UpdateGCAnchorFromDsaOptions( fStartup );
		    if ( !gAnchor.fAmGC && fGcDsa){
			//
			// We're still not a GC and ntdsDsaOptions claim that we should be.
			// Thus, we failed to update the GC marks when we should succeed.
			// Note: we really care about fAmGC, rather then the error code.
			// The error code is used only for the log.
			//
			Assert(!"Failed to updated GC marks although we should be ready for it.\n");

			if ( dwFailedAttempts >= MAX_GC_PROMOTION_ATTEMPTS ) {
			    //
			    // Failed to promote too many times.
			    // Quit trying & notify user.
			    //
			    LogEvent(DS_EVENT_CAT_REPLICATION,
				     DS_EVENT_SEV_ALWAYS,
				     DIRLOG_GC_PROMOTION_FAILED,
				     szInsertUL(dwFailedAttempts),
				     szInsertUL(ulRet),
				     szInsertWin32Msg(ulRet));
			    dwFailedAttempts = 0;
			    Assert(fResched == FALSE); // give up.
			    fGiveup = TRUE;            // for debugging  only (see assert below)
			}
			else {
			    //
			    // Failed to promote.
			    // Try up to MAX_GC_PROMOTION_ATTEMPTS times.
			    //
			    dwFailedAttempts++;
			    fResched = TRUE;        // re-try
			}
		    }
		}

	    } __finally {

		if ( fResched ) {
		    //
		    // Reschedule task
		    //
		    DPRINT1(0, "GC Promotion being delayed for %d minutes.\n",
			    (SYNC_CHECK_PERIOD_SECS / 60) );
		    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_GC_PROMOTION_DELAYED,
			     szInsertUL(SYNC_CHECK_PERIOD_SECS / 60),
			     NULL,
			     NULL);
		    // Events about retrying are logged in helper function
		    if ( NULL != ppvNext ) {
			// called by Task Scheduler; reschedule in-place
			*ppvNext = pvParam;
			*pcSecsUntilNextIteration = SYNC_CHECK_PERIOD_SECS;
		    } else {
			// not called by Task Scheduler; must insert new task
			InsertInTaskQueueSilent(
			    TQ_CheckGCPromotionProgress,
			    pvParam,
			    SYNC_CHECK_PERIOD_SECS,
			    TRUE);
		    }
		} else {
		    //
		    // Don't Reschedule
		    // Reasons:
		    //  - GC promotion has completed fine
		    //  - or No longer wish to be a GC.
		    //  - or disabled inbound repl.
		    //  - or giving up promotion attempt.
		    // reset start-delay marker (for next re-promotion)
		    Assert( gAnchor.fAmGC                                  ||
			    ((dwOptions & NTDSDSA_OPT_IS_GC) == 0)         ||
			    (dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) ||
			    fGiveup );
		    dwStartGcPromotionTime = 0;
		}
	    }

	}
	__finally {
	    LeaveCriticalSection(&csGCState);
	}
    }
    __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        DPRINT1( 0, "Caught exception %d in task queue function CheckGCPromotionProgress\n", ulRet );
        LogUnhandledError( ulRet );
    }

} /* CheckGCPromotion */


DWORD
DraUpgrade(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    )
/*++

Routine Description:

    Perform DRA Upgrade related operations upon Dsa version upgrade.

    This function is called within the same transaction as the version upgrade
    write. Failure to conduct the operation will result w/ the entire write
    failing. Thus be careful when you decide to fail this.

Arguments:

    pTHS - Thread state
    lOldDsaVer - Old DSA version prior to upgrade
    lNewDsaVer - New DSA version that's going to get commited


Return Value:
    Error in DRAERR error space
    ** Warning: Error may fail DSA installation **

Remarks:
    Assumes pTHS->pDB is on the nTDSdSA object
    Opens a temporary DB cursor.

--*/
{

    DWORD dwErr = ERROR_SUCCESS;
    DBPOS *pDBTmp = NULL;
    ULONG NthValIndex = 0;
    SYNTAX_INTEGER it;
    DSNAME *pNC = NULL;
    ULONG InDnt = pTHS->pDB->DNT;
    ULONG len = 0;
    BOOL fDRASave = pTHS->fDRA;


    Assert(pTHS->JetCache.transLevel > 0);
    Assert(lOldDsaVer < lNewDsaVer);
    Assert(CheckCurrency(gAnchor.pDSADN));

    if ( DS_BEHAVIOR_WIN2000 == lOldDsaVer ) {
        //
        // Perform all actions upon upgrade FROM Win2K
        //


        //
        // Eliminate stale RO NCs
        //

        // Set up the temporary pDB
        DBOpen (&pDBTmp);
        __try {

            // For each RO NC that we replicate,
            // Find its sources. If no sources exist,
            // mark it for demotion.
            //

            while (!(DBGetAttVal(pTHS->pDB,
                                 ++NthValIndex,
                                 ATT_HAS_PARTIAL_REPLICA_NCS,
                                 0,
                                 0, &len, (PUCHAR *)&pNC))) {

                // seek to NC over temp DBPOS & get its instanceType
                if (dwErr = FindNC(pDBTmp,
                                   pNC,
                                   FIND_REPLICA_NC,
                                   &it)) {
                    // this isn't worth aborting the upgrade over
                    // so mark as success, but assert to notify
                    // developer
                    Assert(!"Failed to find RO NC as specified in ntdsDsa object");
                    dwErr = ERROR_SUCCESS;
                    __leave;
                }

                // If we find that the RO NC has no sources,
                // set the IT_NC_GOING bit.
                //
                if ( !(it & IT_NC_GOING) &&
                     !DBHasValues(pDBTmp, ATT_REPS_FROM)) {

                    // set DRA context
                    pTHS->fDRA = TRUE;

                    DPRINT1(0, "Marking sourceless read-only NC %ls for"
                               " tear down.\n",
                            pNC->StringName);
                    __try {
                        it = (it & ~IT_NC_COMING) | IT_NC_GOING;
                        if (dwErr = ChangeInstanceType(pTHS, pNC, it, DSID(FILENO,__LINE__))) {
                            // this isn't worth aborting the upgrade
                            // so mark as success
                            Assert(!"Failed to change Instance Type for RO NC");
                            dwErr = ERROR_SUCCESS;
                            __leave;
                        }
                    } __finally {
                        // restore DRA context
                        pTHS->fDRA = fDRASave;
                        // restore dnt
                        if (pTHS->pDB->DNT != InDnt) {
                            // seek back to ntdsDsa dnt
                            if (dwErr = DBFindDNT(pTHS->pDB, InDnt)) {
                                // impossible. Abort.
                                DRA_EXCEPT (DRAERR_DBError, dwErr);
                            }   // restore dnt
                        }       // dnt was moved
                    }           // finally

                }               // need to change instance type
            }                   // for each RO NC
        }
        __finally {

            // Close the temporary pDB
            DBClose (pDBTmp, !AbnormalTermination());
        }

        // RO source resolution isn't important enough
        // to kill the upgarde
        Assert(dwErr == ERROR_SUCCESS);

    }       // end of win2k upgrade

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drainfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drainfo.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Implements server side of IDL_DRSGetReplInfo() function exported to the DRS
    RPC interface.  Returns various state information pertaining to replication.

DETAILS:

CREATED:

    10/29/98    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                    // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <ntdskcc.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
//#include <ntdsapi.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include <dsutil.h>
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "drauptod.h"
#include "drarpc.h"

#include "debug.h"                      /* standard debugging header */
#define DEBSUB "DRAINFO:"               /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_DRAINFO

// Default item limit
// This limit matches a similar limit in ntdsa\ldap\ldapconv.cxx. If this is ever
// made an ldap policy, we should use that policy here as well.
#define DEFAULT_ITEM_PAGE_SIZE 1000
// For old client's that don't support paging
#define RPC_CLIENT_ITEM_PAGE_SIZE (0xffffffff - 0x1)

void dsa_notify(void);

// Replication via ldap includes
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "draConstr.h"

DWORD
draGetReplStruct(IN THSTATE * pTHS,
                 IN ATTRTYP attrId,
                 IN DSNAME * pObjDSName,
                 IN DWORD dwBaseIndex,
                 IN PDWORD pdwNumRequested, OPTIONAL
                 OUT puReplStructArray * ppReplStructArray);
DWORD
draReplStruct2Attr(IN DS_REPL_STRUCT_TYPE structId,
                   IN puReplStruct pReplStruct,
                   IN OUT PDWORD pdwBufferSize,
                   IN PCHAR pBuffer, OPTIONAL
                   OUT ATTRVAL * pAttr);

ULONG
draGetNeighbors(
    IN  THSTATE *             pTHS,
    IN  DBPOS *               pDB,
    IN  ATTRTYP               attrType,
    IN  DSNAME *              pNCarg,                   OPTIONAL
    IN  UUID *                puuidSourceDsaObjGuid,    OPTIONAL
    IN  DWORD                 dwBaseIndex,
    IN  PDWORD                pdwNumRequested,
    OUT DS_REPL_NEIGHBORSW ** ppNeighbors
    );
void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    );

ULONG
draGetCursors( 
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    );

UPTODATE_VECTOR *
draGetCursorsPrivate(
    IN THSTATE *            pTHS,
    IN LPWSTR               pszNC
    );

ULONG
draGetObjMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwInfoFlags,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppObjMetaData
    );

ULONG
draGetAttrValueMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  ATTCACHE *          pAC,
    IN  DSNAME *            pValueDN,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppAttrValueMetaData
    );

ULONG
draGetFailureCache(
    IN  THSTATE *                     pTHS,
    IN  DBPOS *                       pDB,
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    );

ULONG
draGetClientContexts(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_CLIENT_CONTEXTS **  ppContexts
    );

ATTCACHE *
getAttByNameW(
    IN THSTATE *pTHS,
    IN LPWSTR pszAttributeName
    )

/*++

Routine Description:

    This is a helper function to get an ATTCACHE pointer given a
    Unicode version of the attribute name.

Arguments:

    pTHS -
    pszAttributeName -

Return Value:

    ATTCACHE * -

--*/

{
    LPSTR       paszAttributeName = NULL;
    DWORD       len;
    ATTCACHE    *pAC;

    // Convert Unicode attribute name to Ascii
    paszAttributeName = String8FromUnicodeString(TRUE, CP_UTF8,
                                                 pszAttributeName, -1,
                                                 &len, NULL);
    if (!paszAttributeName) {
        DPRINT( 0, "String8FromUnicodeString failed\n" );
        return NULL;
    }

    pAC = SCGetAttByName( pTHS, (len - 1), paszAttributeName );

    THFreeEx( pTHS, paszAttributeName );

    return pAC;
} /* getAttByNameW */

ULONG
IDL_DRSGetReplInfo(
    DRS_HANDLE                    hDrs,
    DWORD                         dwInVersion,
    DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    DWORD *                       pdwOutVersion,
    DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    )
/*++

Routine Description:

    Return selected replication state (e.g., replication partners, meta data,
    etc.) to an RPC client.

    This routine can handle either a V1 or a V2 request structure. The V2 is a
    superset of V1.

    ISSUE wlees Sep 22, 2000
    The V2 structure uses an enumeration context to pass the base index on input
    and next/end indicator on output. Internally we use base index/num requested
    to represent this information. Perhaps we need a V3 structure that uses this
    same approach.

Arguments:

    hDrs (IN) - DRS RPC context handle.

    dwInVersion (IN) - Version (union discriminator) of input message.

    pMsgIn (IN) - Input message.  Describes the data desired by the caller.
        See drs.idl for possible inputs.

    pdwOutVersion (OUT) - Version (union discriminator) of output message.

    pMsgOut (OUT) - On successful return holds the requested info.  See drs.idl
        for possible return info.

Return Values:

    0 or Win32 error.

--*/
{
    DRS_CLIENT_CONTEXT * pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    ULONG       ret = 0;
    THSTATE *   pTHS = NULL;
    DSNAME *    pObjectDN = NULL;
    DSNAME *    pAccessCheckDN = NULL;
    UUID *      puuidSourceDsaObjGuid = NULL;
    ATTCACHE *  pAC = NULL;
    DWORD       dwEnumerationContext = 0, dwInfoFlags = 0;
    DSNAME *    pValueDN = NULL;
    DWORD       dwNumRequested = 0;
    DWORD       dwBaseIndex = 0;
   
    drsReferenceContext( hDrs, IDL_DRSGETREPLINFO);
    INC(pcThread);   // Perfmon hook
    
    __try {

	if ((NULL == pMsgIn)
	    || (2 < dwInVersion)
	    || (NULL == pMsgIn)
	    || (NULL == pdwOutVersion)
	    || (NULL == pMsgOut)) {
	    return ERROR_INVALID_PARAMETER;
	}
 
	*pdwOutVersion = pMsgIn->V1.InfoType;

	__try {
	    InitDraThread(&pTHS);

	    Assert( dwInVersion <= 2);
	    // Rely on the fact that the V1 and V2 structures have common fields
	    Assert( offsetof(  DRS_MSG_GETREPLINFO_REQ_V1, uuidSourceDsaObjGuid ) ==
		    offsetof(  DRS_MSG_GETREPLINFO_REQ_V2, uuidSourceDsaObjGuid ) );
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_REPL_INFO_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsGetReplInfo,
			     szInsertUL(pMsgIn->V1.InfoType),
			     pMsgIn->V1.pszObjectDN
			     ? szInsertWC(pMsgIn->V1.pszObjectDN)
			     : szInsertSz(""),
		szInsertUUID(&pMsgIn->V1.uuidSourceDsaObjGuid),
		NULL, NULL, NULL, NULL, NULL);

	    // ************************************************************************
	    // Decode message arguments
	    // ************************************************************************

	    if (!fNullUuid(&pMsgIn->V1.uuidSourceDsaObjGuid)) {
		puuidSourceDsaObjGuid = &pMsgIn->V1.uuidSourceDsaObjGuid;
	    }

	    if (NULL != pMsgIn->V1.pszObjectDN) {
		if (UserFriendlyNameToDSName(pMsgIn->V1.pszObjectDN,
					     wcslen(pMsgIn->V1.pszObjectDN),
					     &pObjectDN)) {
		    ret = ERROR_DS_INVALID_DN_SYNTAX;
		    __leave;
		}
	    }

	    // Set the page size of an RPC request according to the capability of
	    // the caller. We have old clients that don't support paging that
	    // won't be able to address items beyond the first page.

	    switch (pMsgIn->V1.InfoType) {
	    case DS_REPL_INFO_CURSORS_2_FOR_NC:
	    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
		dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
		break;
	    default:
		// Default to no paging
		dwNumRequested = RPC_CLIENT_ITEM_PAGE_SIZE;
	    }

	    // The following variables will be defaulted for a V1 message:
	    // pAC, pValueDn, dwBaseIndex, dwNumRequested, dwInfoFlags

	    if (dwInVersion == 2) {
		// Optional parameter. We check for null pAC below.
		if (pMsgIn->V2.pszAttributeName) {
		    pAC = getAttByNameW( pTHS, pMsgIn->V2.pszAttributeName );
		}

		if (NULL != pMsgIn->V2.pszValueDN) {
		    if (UserFriendlyNameToDSName(pMsgIn->V2.pszValueDN,
						 wcslen(pMsgIn->V2.pszValueDN),
						 &pValueDN)) {
			ret = ERROR_DS_INVALID_DN_SYNTAX;
			__leave;
		    }

		    // Require pAC be set as well
		    if (!pAC) {
			ret = ERROR_INVALID_PARAMETER;
			__leave;
		    }
		}

		dwEnumerationContext = pMsgIn->V2.dwEnumerationContext;
		if (dwEnumerationContext == 0xffffffff) {
		    // This is the signal for end of data. It should not be passed in
		    ret = ERROR_NO_MORE_ITEMS;
		    __leave;
		}
		dwBaseIndex = dwEnumerationContext;
		dwInfoFlags = pMsgIn->V2.ulFlags;
		// Range sanity checks are performed in the worker functions
	    }

	    // ************************************************************************
	    // Security check
	    // ************************************************************************

	    // What object do we need to check access against?
	    switch (pMsgIn->V1.InfoType) {
	    case DS_REPL_INFO_NEIGHBORS:
	    case DS_REPL_INFO_REPSTO:
		pAccessCheckDN = (NULL == pObjectDN) ? gAnchor.pDomainDN
		    : pObjectDN;
		break;

	    case DS_REPL_INFO_CURSORS_FOR_NC:
	    case DS_REPL_INFO_CURSORS_2_FOR_NC:
	    case DS_REPL_INFO_CURSORS_3_FOR_NC:
	    case DS_REPL_INFO_UPTODATE_VECTOR_V1:
		if (NULL == pObjectDN) {
		    ret = ERROR_INVALID_PARAMETER;
		    __leave;
		}
		pAccessCheckDN = pObjectDN;
		break;

	    case DS_REPL_INFO_METADATA_FOR_OBJ:
	    case DS_REPL_INFO_METADATA_2_FOR_OBJ:
	    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
	    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
		if (NULL == pObjectDN) {
		    ret = ERROR_INVALID_PARAMETER;
		    __leave;
		}

		if (0 == pObjectDN->NameLen) {
		    // The name presented is e.g. guid-only, but FindNCParentDSName
		    // requires a string name.  Get it.
		    ret = ERROR_DS_DRA_BAD_DN;
		    BeginDraTransaction(SYNC_READ_ONLY);
		    __try {
			DSNAME * pFullObjectDN;
			if ((0 == DBFindDSName(pTHS->pDB, pObjectDN))
			    && (pFullObjectDN = GetExtDSName(pTHS->pDB))) {
			    THFreeEx(pTHS, pObjectDN);
			    pObjectDN = pFullObjectDN;
			    ret = 0;
			}
		    }
		    __finally {
			EndDraTransaction(TRUE);
		    }

		    if (0 != ret) {
			__leave;
		    }
		}

		pAccessCheckDN = FindNCParentDSName(pObjectDN, FALSE, FALSE);
		if (NULL == pAccessCheckDN) {
		    // We don't have the NC for this object.
		    ret = ERROR_DS_DRA_BAD_DN;
		    __leave;
		}
		break;

	    case DS_REPL_INFO_PENDING_OPS:
	    case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
	    case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
	    case DS_REPL_INFO_CLIENT_CONTEXTS:
		pAccessCheckDN = gAnchor.pDomainDN;
		break;

	    default:
		ret = ERROR_INVALID_PARAMETER;
		__leave;
	    }

	    // Verify the caller has the access required to retrieve this
	    // information.
	    Assert(NULL != pAccessCheckDN);
	    if (NULL == pAccessCheckDN) {
		ret = ERROR_DS_DRA_ACCESS_DENIED;
		__leave;
	    }
	    if (!IsDraAccessGranted(pTHS, pAccessCheckDN,
				    &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
		__leave;
	    }

	    // ************************************************************************
	    // Get the information
	    // The code below is not aware of the version of the request
	    // ************************************************************************

	    // No transaction yet.
	    Assert(0 == pTHS->JetCache.transLevel);

	    BeginDraTransaction(SYNC_READ_ONLY);

	    __try {
		switch (pMsgIn->V1.InfoType) {
		case DS_REPL_INFO_NEIGHBORS:
		    ret = draGetNeighbors(pTHS,
					  pTHS->pDB,
					  ATT_REPS_FROM,
					  pObjectDN,
					  puuidSourceDsaObjGuid,
					  dwBaseIndex,
					  &dwNumRequested,
					  &pMsgOut->pNeighbors);
		    break;

		case DS_REPL_INFO_REPSTO:
		    ret = draGetNeighbors(pTHS,
					  pTHS->pDB,
					  ATT_REPS_TO,
					  pObjectDN,
					  puuidSourceDsaObjGuid,
					  dwBaseIndex,
					  &dwNumRequested,
					  &pMsgOut->pRepsTo);
		    break;

		case DS_REPL_INFO_CURSORS_FOR_NC:
		case DS_REPL_INFO_CURSORS_2_FOR_NC:
		case DS_REPL_INFO_CURSORS_3_FOR_NC:
		    Assert((void *) &pMsgOut->pCursors == (void *) &pMsgOut->pCursors2);
		    Assert((void *) &pMsgOut->pCursors == (void *) &pMsgOut->pCursors3);
		    ret = draGetCursors(pTHS,
					pTHS->pDB,
					pObjectDN,
					pMsgIn->V1.InfoType,
					dwBaseIndex,
					&dwNumRequested,
					&pMsgOut->pCursors);
		    // Update the enumeration context for the return
		    if (!ret) {
			switch (pMsgIn->V1.InfoType) {
			case DS_REPL_INFO_CURSORS_FOR_NC:
			    // No enumeration context support.
			    break;

			case DS_REPL_INFO_CURSORS_2_FOR_NC:
			case DS_REPL_INFO_CURSORS_3_FOR_NC:
			    Assert((void *) &pMsgOut->pCursors2->dwEnumerationContext
				   == (void *) &pMsgOut->pCursors3->dwEnumerationContext);
			    // dwNumRequested is end or the index of the last item returned.
			    pMsgOut->pCursors2->dwEnumerationContext = dwNumRequested;
			    if (dwNumRequested != 0xffffffff) {
				// Point to the index of the next item to be returned
				pMsgOut->pCursors2->dwEnumerationContext++;
			    }
			    break;

			default:
			    Assert(!"Logic error!");
			}
		    }
		    break;

		case DS_REPL_INFO_UPTODATE_VECTOR_V1:  
		    {     
			UPTODATE_VECTOR * putodVector = NULL;
			UPTODATE_VECTOR * putodConvert = NULL;   
			putodVector = draGetCursorsPrivate(pTHS, pMsgIn->V1.pszObjectDN);
			// convert to version 1 vector
			pMsgOut->pUpToDateVec = UpToDateVec_Convert(pTHS, 1, putodVector); 
			THFreeEx(pTHS, putodVector);   
		    }
		    break;

		case DS_REPL_INFO_METADATA_FOR_OBJ:
		case DS_REPL_INFO_METADATA_2_FOR_OBJ:
		    ret = draGetObjMetaData(pTHS,
					    pTHS->pDB,
					    pObjectDN,
					    pMsgIn->V1.InfoType,
					    dwInfoFlags,
					    dwBaseIndex,
					    &dwNumRequested,
					    &pMsgOut->pObjMetaData);
		    break;

		case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
		case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
		    Assert(offsetof(DRS_MSG_GETREPLINFO_REPLY, pConnectFailures)
			   == offsetof(DRS_MSG_GETREPLINFO_REPLY, pLinkFailures));
		    ret = draGetFailureCache(pTHS,
					     pTHS->pDB,
					     pMsgIn->V1.InfoType,
					     &pMsgOut->pConnectFailures);
		    break;

		case DS_REPL_INFO_PENDING_OPS:
		    // IMPORTANT NOTE: This critical section must be held until
		    // the queue is marshalled (which doesn't happen until we
		    // leave this routine).  IDL_DRSGetReplInfo_notify(), which
		    // is called by the RPC stub after marshalling is complete,
		    // releases this critsec.
		    EnterCriticalSection(&csAOList);

		    ret = draGetPendingOps(pTHS, pTHS->pDB, &pMsgOut->pPendingOps);
		    break;

		case DS_REPL_INFO_CLIENT_CONTEXTS:
		    ret = draGetClientContexts(pTHS, &pMsgOut->pClientContexts);
		    break;

		case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
		case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
		    if ( pAC && (!(pAC->ulLinkID)) ) {
			ret = ERROR_DS_WRONG_LINKED_ATT_SYNTAX;
			__leave;
		    }

		    Assert((void *) &pMsgOut->pAttrValueMetaData
			   == (void *) &pMsgOut->pAttrValueMetaData2);

		    ret = draGetAttrValueMetaData(pTHS,
						  pTHS->pDB,
						  pObjectDN,
						  pMsgIn->V1.InfoType,
						  pAC,
						  pValueDN,
						  dwBaseIndex,
						  &dwNumRequested,
						  &pMsgOut->pAttrValueMetaData);

		    // Update the enumeration context for the return
		    if (!ret) {
			Assert((void *) &pMsgOut->pAttrValueMetaData->dwEnumerationContext
			       == (void *) &pMsgOut->pAttrValueMetaData2->dwEnumerationContext);

			// dwNumRequested is end or the index of the last item returned.
			pMsgOut->pAttrValueMetaData->dwEnumerationContext = dwNumRequested;
			if (dwNumRequested != 0xffffffff) {
			    // Point to the index of the next item to be returned
			    pMsgOut->pAttrValueMetaData->dwEnumerationContext++;
			}
		    }

		    break;

		default:
		    Assert(!"Logic error");
		    ret = ERROR_INVALID_PARAMETER;
		    break;
		}
	    }
	    __finally {
		EndDraTransaction(TRUE);
	    }
	}
	__except(GetDraException(GetExceptionInformation(), &ret)) {
	    ;
	}

	// Either we were successful or we're not going to return any data.
	// Note that the pNeighbors is arbitrary -- we return a union of a bunch of
	// pointers -- any and all of them should be NULL in the error case.
	Assert((0 == ret) || (NULL == pMsgOut->pNeighbors));

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_REPL_INFO_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsGetReplInfo,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}

    }
    __finally {
	DEC(pcThread);   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSGETREPLINFO );
    }
    return ret;
}


void
IDL_DRSGetReplInfo_notify(void)
/*++

Routine Description:

    Called by RPC after the data returned by IDL_DRSGetReplInfo() has been
    marshalled to clean up any associated resources.

Arguments:

    None.

Return Values:

    None.

--*/
{
    // See DS_REPL_INFO_PENDING_OPS handling in IDL_DRSGetReplInfo().
    if (OWN_CRIT_SEC(csAOList)) {
        LeaveCriticalSection(&csAOList);
    }

    // The usual (free the thread state).
    dsa_notify();
}


VOID
draCheckInputRangeLimits(
    DWORD dwBaseIndex,
    PDWORD pdwNumRequested
    )

/*++

Routine Description:

    Make sure the input limits are correct and consistent

    Since there are three ways that ranges can be generated, we need to assure
    that they are all consistent.  The three input paths are:
    1. RPC call. DRA_DRSGetReplInfo calls worker functions directly.
    2. Non-root atts. DBGetMultipleAtts->dbGetConstructedAtt->draGetLdapReplInfo
    3. RootDSE atts.  LDAP_GetReplDseAtts->draGetLdapReplInfo

    Each worker routine has to deal with boundry conditions itself:
    1. No items requested: dwNumRequested == 0
    2. Base too high: dwBaseIndex > last item available
    3. Limit preceeds boundry: dwBaseIndex + dwNumRequested -1 < last item avail
    3. Limit ends on boundry: dwBaseIndex + dwNumRequested - 1 == last item available
    4. Limit exceeds boundry: dwBaseIndex + dwNumReqested - 1 > last item available

Arguments:

    dwBaseIndex - Starting item. zero-based.
    pdwNumRequested - Count of number of items desired.

Return Value:

    DWORD - 

--*/

{
    // This parameter must be present
    Assert( pdwNumRequested );

    // (*pdwNumRequested == 0) is permitted
    // It means a request for no elements

    // dwBaseIndex == 0xffffffff is permitted
    // It is usually nonsensical since there isn't an element indexed that large

    // (*pdwNumRequested == 0xffffffff) is permitted
    // It means the largest page size possible, effectively none

    // See if range wraps around
    if ( (0xffffffff - *pdwNumRequested) < dwBaseIndex) {
        // Adjust num requested to fit
        *pdwNumRequested = 0xffffffff - dwBaseIndex;
    }

} /* draCheckInputRangeLimits */

DWORD
draRangeSupportUpperIndex(IN DWORD dwAvailable,
                          IN DWORD dwBaseIndex,
                          IN DWORD dwNumRequested)
/*++
Routine Description:

  Algorithm to calculate the return value for the pdwNumRequested passed into range aware
  draGetXXX functions.

  How do I calculate dwBaseIndex and dwNumRequested?
    These values are passed into the draGetXXX functions and should simply be shuttled here.

  How do I calculate dwAvailable if I call an enumeration function?
    Call the enumeration function until it fails or if it returned one more
    than the last requested index (dwBaseIndex + dwNumReqested - 1).

Arguments:

  dwAvailable - number of avaliable items
  dwBaseIndex - base index of first item to be returned
  dwNumRequested - max number of requested items

Return Values:

  A DWORD which should be placed into *pdwNumRequested.
  The value of the DWORD is:
    1. 0xFFFFFFFF if the last index the user requested was equal to or beyond the
       last index of the last item avaliable.
    2. The last index the user requested otherwise.
--*/
{
    DWORD ALL = 0xFFFFFFFF;
    DWORD dwRetUpperIndex;
    DWORD dwReqUpperIndex = dwBaseIndex + dwNumRequested - 1;
    DWORD dwActualUpperIndex = dwAvailable - 1;

    DPRINT3(1, "dwAvail %d, dwBaseIndex %d, dwNumReq %d\n",
        dwAvailable, dwBaseIndex, dwNumRequested);

    // If none were requested, all have been returned
    if (dwNumRequested == 0) {
        dwRetUpperIndex = ALL;
    }

    // If all are requested OR none are avaliable THEN everything has been returned
    else if (ALL == dwNumRequested || 0 == dwAvailable) {
        dwRetUpperIndex = ALL;
    }

    else if (dwReqUpperIndex < dwActualUpperIndex) {
        dwRetUpperIndex = dwReqUpperIndex;
    }

    else {
        Assert(dwReqUpperIndex >= dwActualUpperIndex);
        dwRetUpperIndex = ALL;
    }

    DPRINT1(1, "dwRetUpperIndex %d\n", dwRetUpperIndex);

    return dwRetUpperIndex;
}

/*++
Routine Description:

  Gets a replication structure and maps that structure into a pAttr.

  The PendingOps structure returned from draGetReplStruct needs to be protected
  by a mutex during the conversion from repl struct to attr. After the conversion
  the PendingOps structure is no longer referanced and so the mutex can be
  safely released.

Arguments:

  pTHS - Thread state so we can allocate thread memory
  attrId - the type of attribute requested
  pObjDSName - the CN of the object the attribute is associated with. NULL for root DSE.
  dwBaseIndex - the index to start retreiving values from
  pdwNumRequested - NULL or -1 for all or the number requested. Can not request 0 elements.
  pAttr - the internal data strucutre which hold the results of requests
  
  fXML - return the results as an XML blob

Return Values:

  0 - success
  DB_ERR_NO_VALUE - if the array is zero length

--*/
DWORD
draGetLdapReplInfo(IN THSTATE * pTHS,
                   IN ATTRTYP attrId,
                   IN DSNAME * pObjDSName,
                   IN DWORD dwBaseIndex,
                   IN PDWORD pdwNumRequested, OPTIONAL
                   IN BOOL fXML,
                   OUT ATTR * pAttr)
{
    puReplStructArray pReplStructArray;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    DWORD err, dwBufferSize;
    PCHAR pBuffer;

    Assert(ARGUMENT_PRESENT(pTHS) &&
           ARGUMENT_PRESENT(pAttr));

    __try {
        if (ROOT_DSE_MS_DS_REPL_PENDING_OPS == attrId ||
            ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS == attrId)
        {
            DPRINT(1, " Entering critical section \n");
            EnterCriticalSection(&csAOList);
        }

        // Get the structure  
        err = draGetReplStruct(pTHS, attrId, pObjDSName, dwBaseIndex, pdwNumRequested, &pReplStructArray);
        if (err) {
            __leave;
        }
        DPRINT1(1, " draGetLdapReplInfo, %d values returned \n",
            Repl_GetArrayLength(structId, pReplStructArray));

        // Discover how much memory is needed to wrap the structure in the attribute structure
        err = Repl_StructArray2Attr(structId, pReplStructArray, &dwBufferSize, NULL, pAttr);
        if (err) {
            __leave;
        }

        // Memory must have been requested for the head of the struct array
        Assert(dwBufferSize);
        pBuffer = (PCHAR)THAllocEx(pTHS, dwBufferSize);

        err = Repl_StructArray2Attr(structId, pReplStructArray, &dwBufferSize, pBuffer, pAttr);
        if (err) {
            __leave;
        }

        if (fXML) {
            uReplStruct replStruct;
            DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
            PWSTR szXML;
            DWORD dwXMLLen;
            ATTRVAL *pValue;
            DWORD   count;

            for (count=0; count < pAttr->AttrVal.valCount; count++) {
                
                pValue = &pAttr->AttrVal.pAVal[count];

                err = Repl_DeMarshalValue(structId, (PCHAR)pValue->pVal, pValue->valLen, (PCHAR)&replStruct);
                if (err)
                {
                    DPRINT1(0, " Repl_DeMarshalValue failed with %x \n", err);
                    __leave;
                }

                err = Repl_MarshalXml(&replStruct, attrId, NULL, &dwXMLLen);
                if (err)
                {
                    DPRINT1(0, " Repl_MarshalXml alloc failed with %x \n", err);
                    __leave;
                }

                szXML = (PWSTR)THAllocEx(pTHS, dwXMLLen);
                err = Repl_MarshalXml(&replStruct, attrId, szXML, &dwXMLLen);
                if (err)
                {
                    DPRINT1(0, " Repl_MarshalXml failed with %x \n", err);
                    __leave;
                }

                pValue->pVal = (PUCHAR)szXML;
                pValue->valLen = dwXMLLen;
            }
        }

    } __finally {
        if (OWN_CRIT_SEC(csAOList)) {
            DPRINT(1, " Leaving critical section \n");
            LeaveCriticalSection(&csAOList);
        }
    }

    DPRINT1(1, " Done with draGetLdapReplInfo with code %x \n", err);
    return err;
}

/*++
Routine Description:

  Retrieves the replication structure returned by a draGetXXX function. DraGetXXX
  functions are passed the given pTHS, pObjDSName, dwBaseIndex and pdwNumRequested
  parameters. Other draGetXXX parameters are set to NULL or zero.

  -- pTHS->pDB issues --
  The draGetXXX functions where designed under the assumption that they would
  only be called from RPC and hence the pDB pointer would only be used once.
  However LDAP allows multiple attribute value pairs to be returned from a call
  at once hence each call to draGetXXX needs its own pDB.

  How do I add a different type of replication structure to this function?

    It's recommended to add a case statement that simply calls draGetNewStruct and does
    no other processing. The newDraGet function should allocate any memory it needs. Use
    draRangeSupportUpperIndex() to calculate dwNumRequested.

Arguments:

  pTHS - thread state used to allocate memory for the blobs and garbage collect
  pTHS->pDB - see note above
  attrId - the type of replication information requested
  pObjDSName - Object which owns the attribute
  dwBaseIndex - the index to start gathering data

  pdwNumRequested - the max number of values to return this call. Use 0xFFFFFFFF to
    indicate all values should be returned. If NULL or if the number requested wrap
    around when added to dwBaseIndex, then a temp variable with a value of
    0xFFFFFFFF is passed to the draGetXXX functions so those functions don't have to
    bother checking for those corner cases.

  ppReplStructArray - returned repl structure.

Return Values:

  pdwNumRequested
    number of values in the multivalue - If there are more values available to be returned
    0xFFFFFFF - if all available values were returned

  0 - success
  ERROR_INTERNAL_DB_ERROR if DBOpen2 returns a null DB pointer
  DB_ERR_NO_VALUE - if the array is zero length
  Any errors generated by draGetXXX

--*/
DWORD
draGetReplStruct(IN THSTATE * pTHS,
                 IN ATTRTYP attrId,
                 IN DSNAME * pObjDSName, OPTIONAL
                 IN DWORD dwBaseIndex,
                 IN PDWORD pdwNumRequested, OPTIONAL
                 OUT puReplStructArray * ppReplStructArray)
{
    puReplStructArray pReplStructArray = NULL;
    DWORD err;
    GUID guidZero = { 0 };
    DWORD dwNumRequested;
    DBPOS * pDB = NULL;

    Assert(ARGUMENT_PRESENT(ppReplStructArray) &&
           ARGUMENT_PRESENT(pTHS));
    Assert(Repl_IsRootDseAttr(attrId) ?
        !ARGUMENT_PRESENT(pObjDSName) : ARGUMENT_PRESENT(pObjDSName));
    *ppReplStructArray = NULL;

    DPRINT(1, "In draGetReplStruct \n");
    if (!pdwNumRequested)
    {
        // No range specified
        dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
    } else {
        dwNumRequested = *pdwNumRequested;
    }

    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    DBOpen2(pTHS->pDB ? FALSE : TRUE, &pDB);

    if (!pDB)
    {
        DPRINT(1, "Failed to create a new data base pointer \n");
        return ERROR_INTERNAL_DB_ERROR;
    }

    __try {
        switch (attrId)
        {
        case ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS:
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_FROM, NULL, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS:
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_TO, NULL, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS:
            pObjDSName->Guid = guidZero;
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_FROM, pObjDSName, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS:
            pObjDSName->Guid = guidZero;
            err = draGetNeighbors(pTHS, pDB, ATT_REPS_TO, pObjDSName, NULL,
                dwBaseIndex, &dwNumRequested, &(DS_REPL_NEIGHBORSW *)pReplStructArray);
            break;

        case ATT_MS_DS_NC_REPL_CURSORS:
            err = draGetCursors(pTHS,
                                pDB,
                                pObjDSName,
                                DS_REPL_INFO_CURSORS_3_FOR_NC,
                                dwBaseIndex,
                                &dwNumRequested,
                                &pReplStructArray);
            break;

        case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA:
            err = draGetObjMetaData(pTHS,
                                    pDB,
                                    pObjDSName,
                                    DS_REPL_INFO_METADATA_2_FOR_OBJ,
                                    0,
                                    dwBaseIndex,
                                    &dwNumRequested,
                                    &pReplStructArray);
            break;

        case ATT_MS_DS_REPL_VALUE_META_DATA:
            err = draGetAttrValueMetaData(pTHS,
                                          pDB,
                                          pObjDSName,
                                          DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,
                                          NULL,
                                          NULL,
                                          dwBaseIndex,
                                          &dwNumRequested,
                                          &pReplStructArray);
            if (ERROR_NO_MORE_ITEMS == err) {
                err = DB_ERR_NO_VALUE;
                goto exit;
            }
            break;

            // Root Dse attributes are not passed range information
            // ISSUE wlees Oct 11, 2000  Return range information for these functions
            // 1. Fix the helper routines to use dwBaseIndex and dwNumRequested.
            //    This involves changes to draasync and the kcc. Those routines will
            //    need access to draCheckInputRangeLimits and draRangeUpper
            // 2. Callers of these routines will need to use DsGetReplicaInfo2 or
            //    LDAP attribute ranges in order to page through an extended set
            //    of values.

        case ROOT_DSE_MS_DS_REPL_PENDING_OPS:
            err = draGetPendingOps(pTHS, pDB, &(DS_REPL_PENDING_OPSW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS:
            err = draGetQueueStatistics(pTHS, &(DS_REPL_QUEUE_STATISTICSW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_LINK_FAILURES:
            err = draGetFailureCache(pTHS, pDB, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, &(DS_REPL_KCC_DSA_FAILURESW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        case ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES:
            err = draGetFailureCache(pTHS, pDB, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, &(DS_REPL_KCC_DSA_FAILURESW *)pReplStructArray);
            if (!err) {
                dwNumRequested = 0xffffffff; // all was returned
            }
            break;

        default:
            DPRINT1(1, "draGetReplStruct failed with an unrecognized attrid! %d \n", attrId);
            return ERROR_INVALID_PARAMETER; // Error is ture
        }
    } __finally {
        DBClose(pDB, TRUE);
    }

    if (!err) {
        *ppReplStructArray = pReplStructArray;
        if (pdwNumRequested)
        {
            *pdwNumRequested = dwNumRequested;
            DPRINT3(1, " range {%d,%d} elements {%d} \n", dwBaseIndex, *pdwNumRequested,
                    Repl_GetArrayLength(Repl_Attr2StructTyp(attrId), pReplStructArray));
        }
    }

    // If there was an error, or no records were constructed, make it look to the
    // caller as if there was no attribute value.
    if (err || (0 == Repl_GetArrayLength(Repl_Attr2StructTyp(attrId), pReplStructArray)) ) {
        err = DB_ERR_NO_VALUE;
    }

exit:
    if (DB_ERR_NO_VALUE == err) {
        DPRINT(1, "No values returned - DB_ERR_NO_VALUE\n");
    }
    return err;
}


typedef struct _DRA_GUID_TO_NAME_ELEM {
    UUID *      pGuid;
    LPWSTR *    ppszName;
} DRA_GUID_TO_NAME_ELEM;

int __cdecl
draGuidToStringNameElem_Compare(
    IN  const void *  pElem1,
    IN  const void *  pElem2
    )
{
    return memcmp(((DRA_GUID_TO_NAME_ELEM *) pElem1)->pGuid,
                  ((DRA_GUID_TO_NAME_ELEM *) pElem2)->pGuid,
                  sizeof(GUID));
}

void
draXlateGuidsToStringNames(
    IN      DBPOS *     pDB,
    IN      eIndexId    eIndex,
    IN      DWORD       cbGuidOffset,
    IN      DWORD       cbNameOffset,
    IN      DWORD       cbArrayElementSize,
    IN      DWORD       cNumArrayElements,
    IN OUT  void *      pArrayElements
    )
/*++

Routine Description:

    Translates the guids in an array of structures to the string DNs of the
    objects they represent (by filling in an element of the same structure).
    
    Only one lookup per unique guid is performed.
    
    Assigns NULL string DNs for guids that cannot be resolved.

Arguments:

    pDB (IN) - DBPOS to use to perform database lookups.
    
    eIndex (IN) - Index on which to look up the guids.
    
    cbGuidOffset (IN) - Offset from the beginning of the structure of the
        UUID element (to be converted).
        
    cbNameOffset (IN) - Offset from the beginning of the structure of the
        LPWSTR element (to be filled in).
        
    cbArrayElementSize (IN) - Size in bytes of the structure.
    
    cNumArrayElements (IN) - Total number of structures in the array to be
        converted.
        
    pArrayElements (IN/OUT) - Array of structures to update.

Return Values:

    None.  Throws exception on catastrophic error.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DRA_GUID_TO_NAME_ELEM *pMap;
    DWORD iElem;
    DB_ERR err;
    LPWSTR pszDN = NULL;
    ULONG ulNameLen;

    Assert(cbGuidOffset + sizeof(GUID) <= cbArrayElementSize);
    Assert(cbNameOffset + sizeof(LPWSTR) <= cbArrayElementSize);

    // Sort the elemnts by guid in a lookaside list.
    pMap = THAllocEx(pTHS, cNumArrayElements * sizeof(DRA_GUID_TO_NAME_ELEM));

    for (iElem = 0; iElem < cNumArrayElements; iElem++) {
        BYTE * pbCurrElem = ((BYTE *) pArrayElements) + (cbArrayElementSize * iElem);
        
        pMap[iElem].pGuid = (GUID *) (pbCurrElem + cbGuidOffset);
        pMap[iElem].ppszName = (LPWSTR *) (pbCurrElem + cbNameOffset);
        
        // Default is NULL, in case we fail utterly below (e.g., can't set index).
        Assert(NULL == *(pMap[iElem].ppszName));
    }
    
    err = DBSetCurrentIndex(pDB, eIndex, NULL, FALSE);
    if (!err) {
        qsort(pMap,
              cNumArrayElements,
              sizeof(*pMap),
              draGuidToStringNameElem_Compare);
    
        // Walk through the guid-sorted list and translate the guids to names.
        for (iElem = 0; iElem < cNumArrayElements; iElem++) {
            if ((iElem > 0)
                && (0 == memcmp(pMap[iElem].pGuid,
                                pMap[iElem-1].pGuid,
                                sizeof(GUID)))) {
                // Has same guid (and thus same name) as last element -- copy it.
                *(pMap[iElem].ppszName) = *(pMap[iElem-1].ppszName);
            } else {
                // Look up this guid in the database.
                DSNAME * pDN = NULL;
                INDEX_VALUE IV;
            
                if (!fNullUuid(pMap[iElem].pGuid)) {
                    IV.pvData = pMap[iElem].pGuid;
                    IV.cbData = sizeof(GUID);
        
                    err = DBSeek(pDB, &IV, 1, DB_SeekEQ);
                    if (!err) {
                        pDN = GetExtDSName(pDB);
                    }
                }
 
		if (pDN) {  
		    //get the value we want out of the DSNAME
		    ulNameLen = wcslen(pDN->StringName);
		    pszDN = THAllocEx(pTHS, (ulNameLen+1)*sizeof(WCHAR));
		    wcscpy(pszDN, pDN->StringName);  
		    *(pMap[iElem].ppszName) = pszDN; 

		    //free the DSNAME
		    THFreeEx(pTHS, pDN);
		}
		else {
		    *(pMap[iElem].ppszName) = NULL;
		}



            }
        }
    }

    THFreeEx(pTHS, pMap);
}


ULONG
draGetNeighbors(
    IN  THSTATE *             pTHS,
    IN  DBPOS *               pDB,
    IN  ATTRTYP               attrType,
    IN  DSNAME *              pNCarg,                   OPTIONAL
    IN  UUID *                puuidSourceDsaObjGuid,    OPTIONAL
    IN  DWORD                 dwBaseIndex,
    IN  PDWORD                pdwNumRequested,
    OUT DS_REPL_NEIGHBORSW ** ppNeighbors
    )
/*++

Routine Description:

    Returns the public form of the inbound replication partners for this DSA.
    Optionally filtered by NC and/or source DSA.

Arguments:

    pTHS (IN)

    attrType (IN) - ATT_REPS_FROM or ATT_REPS_TO.

    pNCarg (IN, OPTIONAL) - The NC for which partners are requested.  NULL
        implies all NCs.

    puuidSourceDsaObjGuid (IN, OPTIONAL) - The source DSA for which replication
        state is desired.  If NULL, returns all sources.

    ppNeighbors (OUT) - On return, the associated sources.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD                   cNCs = 0;
    DWORD                   iNC = 0;
    NAMING_CONTEXT_LIST *   pNCL;
    DSNAME **               ppNCs;
    DSNAME *                pNC;
    DWORD                   cb;
    DWORD                   cNeighborsAlloced;
    DS_REPL_NEIGHBORSW *    pNeighbors;
    DS_REPL_NEIGHBORW *     pNeighbor;
    DWORD                   iNeighbor;
    DWORD                   cbRepsFromAlloced = 0;
    REPLICA_LINK *          pRepsFrom = NULL;
    DWORD                   iRepsFrom;
    DWORD                   iFlag;
    ATTCACHE *              pAC;
    DWORD                   err;
    DWORD                   j;
    DSNAME                  GuidOnlyDSName;
    DSNAME *                pDSName;
    NCL_ENUMERATOR          nclMaster, nclReplica;
    DWORD                   dwcNeighbor;
    DWORD                   dwNumRequested;
    DWORD                   dwNumRet;

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    dwcNeighbor = 0;
    dwNumRet = dwBaseIndex + dwNumRequested;

    // Should have a transaction before we get here.
    Assert(1 == pTHS->JetCache.transLevel);

    // Determine which NC(s) we're looking at.
    if (NULL != pNCarg) {
        // Explicit NC given.
        ppNCs = &pNCarg;
        cNCs = 1;
    }
    else {
        // Count the NCs hosted by this machine.
        DPRINT(1, "// Count the NCs hosted by this machine.\n");
        cNCs = 0;
        NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC);
        NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
            cNCs++;
        }
        while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
            cNCs++;
        }

        // Allocate an array for them.
        ppNCs = THAllocEx(pTHS, cNCs * sizeof(DSNAME *));

        // And copy a pointer to each NC name into the array.
        iNC = 0;
        NCLEnumeratorReset(&nclMaster);
        NCLEnumeratorReset(&nclReplica);
        while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
            Assert(iNC < cNCs);
            ppNCs[iNC++] = pNCL->pNC;
        }
        while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
            Assert(iNC < cNCs);
            ppNCs[iNC++] = pNCL->pNC;
        }
    }

    cNeighborsAlloced = 20;

    cb = offsetof(DS_REPL_NEIGHBORSW, rgNeighbor);
    cb += sizeof(DS_REPL_NEIGHBORW) * cNeighborsAlloced;
    pNeighbors = THAllocEx(pTHS, cb);

    pAC = SCGetAttById(pTHS, attrType);
    Assert(NULL != pAC);

    for (iNC = 0; iNC < cNCs; iNC++) {
        pNC = ppNCs[iNC];

        if (pNCarg)
            DPRINT1(1, " Searching for NC {%ws}\n", pNCarg->StringName);
        err = DBFindDSName(pDB, pNC);
        if (err) {
            // It's conceivable this could occur due to gAnchor / transaction
            // incoherency, but that seems awfully unlikely.
            DPRINT2(0, "Can't find NC %ls (DSNAME @ %p)!\n",
                    pNC->StringName, pNC);
            LooseAssert(!"Can't find NC", GlobalKnowledgeCommitDelay);
            if (cNCs == 1) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            } else {
                // Try another...
                continue;
            }
        }

        // Read the repsFrom's.
        iRepsFrom = 0;
        while (!DBGetAttVal_AC(pDB, ++iRepsFrom, pAC, DBGETATTVAL_fREALLOC,
                               cbRepsFromAlloced, &cb,
                               (BYTE **) &pRepsFrom)) {
            cbRepsFromAlloced = max(cbRepsFromAlloced, cb);

            Assert(1 == pRepsFrom->dwVersion);
            Assert(cb == pRepsFrom->V1.cb);

            // potentially fix repsfrom version &  recalc size
            pRepsFrom = FixupRepsFrom(pRepsFrom, &cbRepsFromAlloced);
            Assert(cbRepsFromAlloced >= pRepsFrom->V1.cb);

            if ((NULL != puuidSourceDsaObjGuid)
                && (0 != memcmp(puuidSourceDsaObjGuid,
                                &pRepsFrom->V1.uuidDsaObj,
                                sizeof(GUID)))) {
                // Not interested in this source -- move along.
                continue;
            }

            dwcNeighbor++;
            if (dwcNeighbor - 1 < dwBaseIndex)
            {
                continue;
            }
            if (dwcNeighbor > dwNumRet)
            {
                break;
            }

            if (pNeighbors->cNumNeighbors++ >= cNeighborsAlloced) {
                cNeighborsAlloced *= 2;
                cb = offsetof(DS_REPL_NEIGHBORSW, rgNeighbor);
                cb += sizeof(DS_REPL_NEIGHBORW) * cNeighborsAlloced;
                pNeighbors = THReAllocEx(pTHS, pNeighbors, cb);
            }

            pNeighbor = &pNeighbors->rgNeighbor[pNeighbors->cNumNeighbors - 1];

            pNeighbor->pszNamingContext = pNC->StringName;
            pNeighbor->pszSourceDsaAddress
                = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFrom));
            // pNeighbor->pszSourceDsaDN filled in below
            // pNeighbor->pszAsyncIntersiteTransportDN filled in below

            pNeighbor->uuidNamingContextObjGuid  = pNC->Guid;
            pNeighbor->uuidSourceDsaObjGuid      = pRepsFrom->V1.uuidDsaObj;
            pNeighbor->uuidSourceDsaInvocationID = pRepsFrom->V1.uuidInvocId;
            pNeighbor->uuidAsyncIntersiteTransportObjGuid
                = pRepsFrom->V1.uuidTransportObj;

            pNeighbor->usnLastObjChangeSynced
                = pRepsFrom->V1.usnvec.usnHighObjUpdate;
            pNeighbor->usnAttributeFilter
                = pRepsFrom->V1.usnvec.usnHighPropUpdate;

            DSTimeToFileTime(pRepsFrom->V1.timeLastSuccess,
                             &pNeighbor->ftimeLastSyncSuccess);
            DSTimeToFileTime(pRepsFrom->V1.timeLastAttempt,
                             &pNeighbor->ftimeLastSyncAttempt);

            pNeighbor->dwLastSyncResult = pRepsFrom->V1.ulResultLastAttempt;
            pNeighbor->cNumConsecutiveSyncFailures
                = pRepsFrom->V1.cConsecutiveFailures;

            for (iFlag = 0; RepNbrOptionToDra[iFlag].pwszPublicOption; iFlag++) {
                if (pRepsFrom->V1.ulReplicaFlags &
                    RepNbrOptionToDra[iFlag].InternalOption) {
                    pNeighbor->dwReplicaFlags |= RepNbrOptionToDra[iFlag].PublicOption;
                }
            }
        }
    }

    draXlateGuidsToStringNames(pDB,
                               Idx_ObjectGuid,
                               offsetof(DS_REPL_NEIGHBORW, uuidSourceDsaObjGuid),
                               offsetof(DS_REPL_NEIGHBORW, pszSourceDsaDN),
                               sizeof(DS_REPL_NEIGHBORW),
                               pNeighbors->cNumNeighbors,
                               pNeighbors->rgNeighbor);

    draXlateGuidsToStringNames(pDB,
                               Idx_ObjectGuid,
                               offsetof(DS_REPL_NEIGHBORW, uuidAsyncIntersiteTransportObjGuid),
                               offsetof(DS_REPL_NEIGHBORW, pszAsyncIntersiteTransportDN),
                               sizeof(DS_REPL_NEIGHBORW),
                               pNeighbors->cNumNeighbors,
                               pNeighbors->rgNeighbor);

    if (1 != cNCs) {
        THFreeEx(pTHS, ppNCs);
    }

    if (pNeighbors->cNumNeighbors) {
        DPRINT4(1, " DraGetNeighbors ND, Addr, Trans, Contxt %ws, %ws, %ws, %ws \n",
                pNeighbors->rgNeighbor[0].pszSourceDsaDN,
                pNeighbors->rgNeighbor[0].pszSourceDsaAddress,
                pNeighbors->rgNeighbor[0].pszAsyncIntersiteTransportDN,
                pNeighbors->rgNeighbor[0].pszNamingContext);
    }
    
    *pdwNumRequested = draRangeSupportUpperIndex(dwcNeighbor, dwBaseIndex, dwNumRequested);
    DPRINT5(1, " Neighbors upperBound = %d ni=%d, cn=%d, bi=%d, nr=%d\n",
        *pdwNumRequested, dwcNeighbor, pNeighbors->cNumNeighbors, dwBaseIndex, dwNumRequested);

    *ppNeighbors = pNeighbors;

    return 0;
}

void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    )
/*++

Routine Description:

    Frees the Cursor memory from the draGetCursors call.

Arguments:

    pTHS (IN)
    
    InfoType (IN) - The cursor type

    pCursors (IN) - the allocated cursor from draGetCursors

Return Values:

    None

--*/
{
    DS_REPL_CURSORS_3W *    pCursors3;
    ULONG i;
    
    Assert((DS_REPL_INFO_CURSORS_FOR_NC == InfoType)
	   || (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType)
	   || (DS_REPL_INFO_CURSORS_3_FOR_NC == InfoType));

    if (InfoType == DS_REPL_INFO_CURSORS_3_FOR_NC) {
	pCursors3 = (DS_REPL_CURSORS_3W *) pCursors;
	for (i = 0; i < pCursors3->cNumCursors; i++) {
	    THFreeEx(pTHS, pCursors3->rgCursor[i].pszSourceDsaDN); 
	}
    }
    THFreeEx(pTHS, pCursors);
}

UPTODATE_VECTOR *
draGetCursorsPrivate(
    IN THSTATE *            pTHS,
    IN LPWSTR               pszNC
    ) 
/*++

Routine Description:

    Returns the private form of the up-to-date vector for the given NC.

Arguments:

    pTHS (IN)
    
    pszNC - given NC

Return Values:

    UTD vector, caller must free with THAllocEx

--*/
{
	UPTODATE_VECTOR * putodvec = NULL;
	ULONG instanceType = 0;
	DSNAME * pNC;
	DWORD err = 0;

	pNC = DSNameFromStringW(pTHS, pszNC);

	if (err = FindNC(pTHS->pDB, pNC,
			 FIND_MASTER_NC | FIND_REPLICA_NC, &instanceType)) {
	    DRA_EXCEPT_NOLOG(DRAERR_BadDN, err);
	}

	THFreeEx(pTHS, pNC);

	UpToDateVec_Read(pTHS->pDB, instanceType, UTODVEC_fUpdateLocalCursor,     
			 DBGetHighestCommittedUSN(), &putodvec);

	return putodvec;
}

ULONG
draGetCursors(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    )
/*++

Routine Description:

    Returns the public form of the up-to-date vector for the given NC.

Arguments:

    pTHS (IN)

    pNC (IN) - The NC for which the vector is requested.

    ppCursors (OUT) - On return, the associated vector.

Return Values:

    0 or Win32 error.

--*/
{
    UPTODATE_VECTOR *         putodvec;
    DWORD                     cb;
    DWORD                     iCursor;
    void *                    pCursorsToReturn = NULL;
    SYNTAX_INTEGER            it = 0;
    DWORD                     iIndex;
    DWORD                     dwNumRequested;
    DWORD                     dwNumRet;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;
    DWORD                     cNumCursorsTotal;

    Assert((DS_REPL_INFO_CURSORS_FOR_NC == InfoType)
           || (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType)
           || (DS_REPL_INFO_CURSORS_3_FOR_NC == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    // Should have a transaction before we get here.
    Assert(1 == pTHS->JetCache.transLevel);

    DPRINT1(1, " Searching for NC {%ws}\n", pNC->StringName);
    if (FindNC(pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it) || (it & IT_NC_GOING)) {
        // The name we were given does not correspond to a fully instantiated NC on
        // this machine.
        return ERROR_DS_DRA_BAD_NC;
    }

    UpToDateVec_Read(pDB, it, UTODVEC_fUpdateLocalCursor,
                     DBGetHighestCommittedUSN(), &putodvec);
    Assert((NULL == putodvec)
           || (UPTODATE_VECTOR_NATIVE_VERSION == putodvec->dwVersion));
    
    pNativeUTD = &putodvec->V2;
    cNumCursorsTotal = putodvec ? pNativeUTD->cNumCursors : 0;

    if ((0 == cNumCursorsTotal) || (cNumCursorsTotal <= dwBaseIndex)) {
        dwNumRet = 0;
    } else {
        dwNumRet = min(dwNumRequested, cNumCursorsTotal - dwBaseIndex);
    }

    switch (InfoType) {
    case DS_REPL_INFO_CURSORS_FOR_NC: {
        DS_REPL_CURSORS * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS, rgCursor);
        cb += sizeof(DS_REPL_CURSOR) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
        }

        pCursorsToReturn = pCursors;
        break;
    }

    case DS_REPL_INFO_CURSORS_2_FOR_NC: {
        DS_REPL_CURSORS_2 * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS_2, rgCursor);
        cb += sizeof(DS_REPL_CURSOR_2) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
            DSTimeToFileTime(pNativeUTD->rgCursors[iIndex].timeLastSyncSuccess,
                             &pCursors->rgCursor[iCursor].ftimeLastSyncSuccess);
        }

        pCursorsToReturn = pCursors;
        break;
    }

    case DS_REPL_INFO_CURSORS_3_FOR_NC: {
        DS_REPL_CURSORS_3W * pCursors = NULL;
        
        cb = offsetof(DS_REPL_CURSORS_3W, rgCursor);
        cb += sizeof(DS_REPL_CURSOR_3W) * dwNumRet;
    
        pCursors = THAllocEx(pTHS, cb);
        pCursors->cNumCursors = dwNumRet;

        for (iCursor = 0, iIndex = dwBaseIndex; 
             iCursor < dwNumRet; 
             iIndex++, iCursor++) {
            pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID
                = pNativeUTD->rgCursors[iIndex].uuidDsa;
            pCursors->rgCursor[iCursor].usnAttributeFilter
                = pNativeUTD->rgCursors[iIndex].usnHighPropUpdate;
            DSTimeToFileTime(pNativeUTD->rgCursors[iIndex].timeLastSyncSuccess,
                             &pCursors->rgCursor[iCursor].ftimeLastSyncSuccess);
        }

        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_CURSOR_3W, uuidSourceDsaInvocationID),
                                   offsetof(DS_REPL_CURSOR_3W, pszSourceDsaDN),
                                   sizeof(DS_REPL_CURSOR_3W),
                                   pCursors->cNumCursors,
                                   pCursors->rgCursor);
        
        pCursorsToReturn = pCursors;
        break;
    }

    default:
        Assert(!"Logic error!");
    }


    *pdwNumRequested = draRangeSupportUpperIndex(cNumCursorsTotal, dwBaseIndex, dwNumRequested);

    DPRINT4(1, " Cursors bi=%d nr=%d ub=%d nc=%d\n",
            dwBaseIndex, dwNumRequested, *pdwNumRequested, cNumCursorsTotal);

    if (NULL != putodvec) {
        THFreeEx(pTHS, putodvec);
    }

    *ppCursors = pCursorsToReturn;

    return 0;
}


ULONG
draGetObjMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwInfoFlags,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppObjMetaData
    )
/*++

Routine Description:

    Returns the public form of the object meta data vector for the given object.

Arguments:

    pTHS (IN)

    pObjectDN (IN) - The object for which meta data is requested.

    dwInfoFlags (IN) - Behavior modifiers

    ppObjMetaData (OUT) - On return, the associated meta data.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD                       err;
    DWORD                       cb;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec;
    ATTCACHE *                  pAC;
    PROPERTY_META_DATA *        pIntMetaData;
    DWORD                       i;
    DWORD                       j;
    void *                      pObjMetaDataToReturn = NULL;
    DWORD                       dwNumRequested, dwUpperBound;

    Assert((DS_REPL_INFO_METADATA_FOR_OBJ == InfoType)
           || (DS_REPL_INFO_METADATA_2_FOR_OBJ == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );

    // Find the object.
    err = DBFindDSName(pDB, pObjectDN);
    if (err) {
        return err;
    }

    // Get its meta data.
    err = DBGetAttVal(pDB,
                      1,
                      ATT_REPL_PROPERTY_META_DATA,
                      0,
                      0,
                      &cb,
                      (BYTE **) &pMetaDataVec);
    if (err) {
        DPRINT3(0, "Error %d reading meta data for %ls!\n",
                err, pObjectDN->StringName, pObjectDN);
        return ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
    }

    Assert(1 == pMetaDataVec->dwVersion);
    Assert(cb == MetaDataVecV1Size(pMetaDataVec));

    if (dwInfoFlags & DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS) {
        DBImproveAttrMetaDataFromLinkMetaData(
            pDB,
            &pMetaDataVec,
            &cb
            );
    }

    switch (InfoType) {
    case DS_REPL_INFO_METADATA_FOR_OBJ: {
        DS_REPL_OBJ_META_DATA * pObjMetaData;
        DS_REPL_ATTR_META_DATA * pExtMetaData;
        
        cb = offsetof(DS_REPL_OBJ_META_DATA, rgMetaData);
        cb += sizeof(DS_REPL_ATTR_META_DATA) * pMetaDataVec->V1.cNumProps;
    
        pObjMetaData = THAllocEx(pTHS, cb);
    
        pIntMetaData = &pMetaDataVec->V1.rgMetaData[0];
        pExtMetaData = &pObjMetaData->rgMetaData[0];
        pObjMetaData->cNumEntries = 0;
    
        // Convert meta data into its public form.
        pIntMetaData += dwBaseIndex;
        dwUpperBound = min(pMetaDataVec->V1.cNumProps, dwBaseIndex + dwNumRequested);
        for (i = dwBaseIndex; i < dwUpperBound; i++, pIntMetaData++) {
            pAC = SCGetAttById(pTHS, pIntMetaData->attrType);
            if (NULL == pAC) {
                DPRINT1(0, "Can't find ATTCACHE for attid 0x%x!\n",
                        pIntMetaData->attrType);
                continue;
            }
    
            pExtMetaData->pszAttributeName
                = UnicodeStringFromString8(CP_UTF8, pAC->name, -1);
            pExtMetaData->dwVersion = pIntMetaData->dwVersion;
            DSTimeToFileTime(pIntMetaData->timeChanged,
                             &pExtMetaData->ftimeLastOriginatingChange);
            pExtMetaData->uuidLastOriginatingDsaInvocationID
                = pIntMetaData->uuidDsaOriginating;
            pExtMetaData->usnOriginatingChange = pIntMetaData->usnOriginating;
            pExtMetaData->usnLocalChange = pIntMetaData->usnProperty;
    
            pObjMetaData->cNumEntries++;
            pExtMetaData++;
        }

        pObjMetaDataToReturn = pObjMetaData;
        break;
    }

    case DS_REPL_INFO_METADATA_2_FOR_OBJ: {
        DS_REPL_OBJ_META_DATA_2 * pObjMetaData;
        DS_REPL_ATTR_META_DATA_2 * pExtMetaData;
        
        cb = offsetof(DS_REPL_OBJ_META_DATA_2, rgMetaData);
        cb += sizeof(DS_REPL_ATTR_META_DATA_2) * pMetaDataVec->V1.cNumProps;
    
        pObjMetaData = THAllocEx(pTHS, cb);
    
        pIntMetaData = &pMetaDataVec->V1.rgMetaData[0];
        pExtMetaData = &pObjMetaData->rgMetaData[0];
        pObjMetaData->cNumEntries = 0;
    
        // Convert meta data into its public form.
        pIntMetaData += dwBaseIndex;
        dwUpperBound = min(pMetaDataVec->V1.cNumProps, dwBaseIndex + dwNumRequested);
        for (i = dwBaseIndex; i < dwUpperBound; i++, pIntMetaData++) {
            pAC = SCGetAttById(pTHS, pIntMetaData->attrType);
            if (NULL == pAC) {
                DPRINT1(0, "Can't find ATTCACHE for attid 0x%x!\n",
                        pIntMetaData->attrType);
                continue;
            }
    
            pExtMetaData->pszAttributeName
                = UnicodeStringFromString8(CP_UTF8, pAC->name, -1);
            pExtMetaData->dwVersion = pIntMetaData->dwVersion;
            DSTimeToFileTime(pIntMetaData->timeChanged,
                             &pExtMetaData->ftimeLastOriginatingChange);
            pExtMetaData->uuidLastOriginatingDsaInvocationID
                = pIntMetaData->uuidDsaOriginating;
            pExtMetaData->usnOriginatingChange = pIntMetaData->usnOriginating;
            pExtMetaData->usnLocalChange = pIntMetaData->usnProperty;
    
            pObjMetaData->cNumEntries++;
            pExtMetaData++;
        }
        
        // Translate invocationIDs to DSA DNs where possible.
        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_ATTR_META_DATA_2, uuidLastOriginatingDsaInvocationID),
                                   offsetof(DS_REPL_ATTR_META_DATA_2, pszLastOriginatingDsaDN),
                                   sizeof(DS_REPL_ATTR_META_DATA_2),
                                   pObjMetaData->cNumEntries,
                                   pObjMetaData->rgMetaData);
        
        pObjMetaDataToReturn = pObjMetaData;
        break;
    }

    default:
        Assert(!"Logic error!");
    }

    *pdwNumRequested = draRangeSupportUpperIndex(pMetaDataVec->V1.cNumProps, dwBaseIndex, dwNumRequested);

    *ppObjMetaData = pObjMetaDataToReturn;

    return 0;
}


ULONG
draGetAttrValueMetaData(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pObjectDN,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  ATTCACHE *          pAC,
    IN  DSNAME *            pValueDN,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppAttrValueMetaData
    )
/*++

Routine Description:

    Returns the public form of the attribute value meta data
    for the given object and attribute.

    The attribute range information is communicated through the dwEnumContext
    parameter.

    On input, dwEnumContext contains the starting index. The starting
    index is always 0-based.

    dwNumRequested contains the page size on input.
    It cannot be zero. It may be 0xfffffff to indicate the user wants all.
    On output, it is adjusted to indicate whether all were returned, or
    the last index that the user requested.

    On output, dwEnumContext is updated to contain the base index of the
    next item to return next time.

Arguments:

    pTHS (IN)

    pObjectDN (IN) - The object for which meta data is requested.

    pAC (IN) - Attribute cache entry for the desired attribute

    dwBaseIndex (IN) - Positional context

    ppAttrValueMetaData (OUT) - On return, the associated meta data.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err, cb, cbValLen, cNumEntries = 0, pageSize;
    UCHAR *pVal = NULL;
    void *pAttrValueMetaDataToReturn = NULL;
    DSTIME timeDeleted;
    VALUE_META_DATA valueMetaData;
    ATTCACHE *pACValue;
    DWORD dwNumRequested, dwUpperIndex;

    Assert((DS_REPL_INFO_METADATA_FOR_ATTR_VALUE == InfoType)
           || (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType));

    dwNumRequested = *pdwNumRequested;
    draCheckInputRangeLimits( dwBaseIndex, &dwNumRequested );
    // This is the largest page size we support
    // This check can be removed if we go to an incremental memory
    // allocation model in this routine.
    if (dwNumRequested > DEFAULT_ITEM_PAGE_SIZE) {
        dwNumRequested = DEFAULT_ITEM_PAGE_SIZE;
    }
    pageSize = dwNumRequested;

    DPRINT2(1, "draGetAttrValue base/#req = %d:%d\n", dwBaseIndex, dwNumRequested);

    // Find the object.
    err = DBFindDSName(pDB, pObjectDN);
    if (err) {
        DPRINT1(1, "DBFindDSName returned unexpected db error %d\n", err );
        return err;
    }

    // if pValueDn is set, pAC must be also
    Assert( !pValueDN || pAC );



    // We allocate this early so that we have a structure to return
    // Comment on memory allocation strategy. We allocate a maximal sized structure
    // up front. This will not all be used if the number of items available
    // is less than the page size. Perhaps we should grow the structure
    // incrementally.

    switch (InfoType) {
    case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE:
        cb = offsetof(DS_REPL_ATTR_VALUE_META_DATA, rgMetaData);
        cb += sizeof(DS_REPL_VALUE_META_DATA) * pageSize;
        break;

    case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE:
        cb = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2, rgMetaData);
        cb += sizeof(DS_REPL_VALUE_META_DATA_2) * pageSize;
        break;

    default:
        Assert(!"Logic error");
    }

    pAttrValueMetaDataToReturn = THAllocEx(pTHS, cb);

    // Position on the initial value. When requesting a single value, it will
    // be the only value returned.
    if (dwNumRequested == 0) {
        // No results required
        goto return_results;
    } else if ( (pValueDN) &&
         (pAC->syntax == SYNTAX_DISTNAME_TYPE) ) {
        DWORD fPresent;

        // The valueDN can only express a SYNTAX_DISTNAME_TYPE. It does not
        // express the external form of a SYNTAX_DISTNAME_BINARY type.

        // We know what the value is. Position on it.
        cbValLen = pValueDN->structLen;
        pVal = (UCHAR *) pValueDN;
        err = DBFindAttLinkVal_AC( pDB, pAC, cbValLen, pVal, &fPresent );
        pACValue = pAC;
    } else {
        pACValue = pAC;
        // Position on first value and return it.
        // Sequence is 1 based
        err = DBGetNextLinkValEx_AC (
            pDB, TRUE /*first*/, (dwBaseIndex + 1), &pACValue,
            DBGETATTVAL_fINCLUDE_ABSENT_VALUES,
            0, &cbValLen, &pVal );
    }
    if ( (err == DB_ERR_NO_VALUE) ||
         (err == DB_ERR_VALUE_DOESNT_EXIST) ) {
        // No results returned
        goto return_results;
    } else if (err) {
        // Have DB_ERR, need WIN32
        DPRINT1( 0, "DBGetAttrVal_AC returned unexpected db error %d\n", err );
        return ERROR_DS_DATABASE_ERROR;
    }

    do {
        LPWSTR pszAttributeName;
        DSNAME * pObjectDN = NULL;
        DWORD cbData = 0;
        BYTE * pbData = NULL;

        Assert( pACValue );
        
        // Attribute name
        pszAttributeName = UnicodeStringFromString8(CP_UTF8, pACValue->name, -1);

        // Object name
        switch (pACValue->syntax) {
        case SYNTAX_DISTNAME_TYPE:
            pObjectDN = (DSNAME *) pVal;
            cbData = 0;
            pbData = NULL;
            break;
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
        {
            struct _SYNTAX_DISTNAME_DATA *pDD =
                (struct _SYNTAX_DISTNAME_DATA *) pVal;
            SYNTAX_ADDRESS *pSA = DATAPTR( pDD );

            pObjectDN = NAMEPTR( pDD );
            cbData = pSA->structLen;
            pbData = pSA->byteVal;
            break;
        }
        default:
            Assert( FALSE );
        }

        DBGetLinkValueMetaData( pDB, pACValue, &valueMetaData );
        
        // timeDeleted is set to zero if not present
        DBGetLinkTableDataDel( pDB, &timeDeleted );

        // Convert to external form.
        switch (InfoType) {
        case DS_REPL_INFO_METADATA_FOR_ATTR_VALUE: {
            DS_REPL_ATTR_VALUE_META_DATA *pAttrValueMetaData = pAttrValueMetaDataToReturn;
            DS_REPL_VALUE_META_DATA *pValueMetaData
                = &(pAttrValueMetaData->rgMetaData[pAttrValueMetaData->cNumEntries]);
            
            pValueMetaData->pszAttributeName = pszAttributeName;
            pValueMetaData->pszObjectDn = pObjectDN->StringName;
            pValueMetaData->cbData = cbData;
            pValueMetaData->pbData = pbData;

            DSTimeToFileTime( valueMetaData.timeCreated,
                              &(pValueMetaData->ftimeCreated) );
            pValueMetaData->dwVersion = valueMetaData.MetaData.dwVersion;
            DSTimeToFileTime( valueMetaData.MetaData.timeChanged,
                              &(pValueMetaData->ftimeLastOriginatingChange) );
            pValueMetaData->uuidLastOriginatingDsaInvocationID =
                valueMetaData.MetaData.uuidDsaOriginating;
            pValueMetaData->usnOriginatingChange =
                valueMetaData.MetaData.usnOriginating;
            pValueMetaData->usnLocalChange =
                valueMetaData.MetaData.usnProperty;
    
            DSTimeToFileTime( timeDeleted, &(pValueMetaData->ftimeDeleted) );
    
            cNumEntries = ++(pAttrValueMetaData->cNumEntries);
            break;
        }

        case DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE: {
            DS_REPL_ATTR_VALUE_META_DATA_2 *pAttrValueMetaData = pAttrValueMetaDataToReturn;
            DS_REPL_VALUE_META_DATA_2 *pValueMetaData
                = &(pAttrValueMetaData->rgMetaData[pAttrValueMetaData->cNumEntries]);
            
            pValueMetaData->pszAttributeName = pszAttributeName;
            pValueMetaData->pszObjectDn = pObjectDN->StringName;
            pValueMetaData->cbData = cbData;
            pValueMetaData->pbData = pbData;

            DSTimeToFileTime( valueMetaData.timeCreated,
                              &(pValueMetaData->ftimeCreated) );
            pValueMetaData->dwVersion = valueMetaData.MetaData.dwVersion;
            DSTimeToFileTime( valueMetaData.MetaData.timeChanged,
                              &(pValueMetaData->ftimeLastOriginatingChange) );
            pValueMetaData->uuidLastOriginatingDsaInvocationID =
                valueMetaData.MetaData.uuidDsaOriginating;
            pValueMetaData->usnOriginatingChange =
                valueMetaData.MetaData.usnOriginating;
            pValueMetaData->usnLocalChange =
                valueMetaData.MetaData.usnProperty;
    
            DSTimeToFileTime( timeDeleted, &(pValueMetaData->ftimeDeleted) );
            
            cNumEntries = ++(pAttrValueMetaData->cNumEntries);
            break;
        }

        default:
            Assert(!"Logic error");
        }

        // Get next relative value.
        cbValLen = 0;  // Value has been given away - alloc another
        pVal = NULL;
        pACValue = pAC;
        err = DBGetNextLinkValEx_AC (
            pDB, FALSE /*notfirst*/, 1, &pACValue,
            DBGETATTVAL_fINCLUDE_ABSENT_VALUES,
            0, &cbValLen, &pVal );
    
    } while (!err && (cNumEntries < pageSize));

    if (!err) {
        // We have read all the entries we can and have confirmed that more
        // entries still remain.
        Assert(cNumEntries == pageSize);
        DPRINT(1, "More available\n");
    } else {
        DPRINT(1, "No more available\n");
        // No more values
        // DB_ERR_NO_VALUE is the normal expected result
        // Otherwise, if we got some other error, we just close the page
        // and hope things start working again when he asks again.
    }

    if (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType) {
        // Translate invocationIDs to DSA DNs where possible.
        draXlateGuidsToStringNames(pDB,
                                   Idx_InvocationId,
                                   offsetof(DS_REPL_VALUE_META_DATA_2, uuidLastOriginatingDsaInvocationID),
                                   offsetof(DS_REPL_VALUE_META_DATA_2, pszLastOriginatingDsaDN),
                                   sizeof(DS_REPL_VALUE_META_DATA_2),
                                   cNumEntries,
                                   ((DS_REPL_ATTR_VALUE_META_DATA_2 *) pAttrValueMetaDataToReturn)->rgMetaData);
    }

return_results:

    *pdwNumRequested = draRangeSupportUpperIndex(cNumEntries + dwBaseIndex, dwBaseIndex, dwNumRequested);

    DPRINT1(1, "draGetAttrValue numEntries = %d\n", cNumEntries);
    DPRINT1(1, "draGetAttrValue upper index = %d\n", *pdwNumRequested);

    *ppAttrValueMetaData = pAttrValueMetaDataToReturn;

    return 0;
}


ULONG
draGetFailureCache(
    IN  THSTATE *                     pTHS,
    IN  DBPOS *                       pDB,
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the public form of the requested KCC failure cache.

Arguments:

    pTHS (IN)

    InfoType (IN) - Identifies the cache to return -- either
        DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES or
        DS_REPL_INFO_KCC_DSA_LINK_FAILURES.

    ppFailures (OUT) - On successful return, holds the contents of the cache.

Return Values:

    Win32 error code.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW * pFailures;
    DS_REPL_KCC_DSA_FAILUREW *  pFailure;
    DWORD                       iFailure;
    DWORD                       err;
    DSNAME                      GuidOnlyDSName;
    DSNAME *                    pDSName;

    // Ask the KCC for a copy of the appropriate failure cache.  The KCC will
    // fill in all fields other than the string DNs.
    err = KccGetFailureCache(InfoType, &pFailures);
    if (err) {
        return err;
    }

    Assert(NULL != pFailures);

    // Now look up the objectGuids amd fill in the string DNs.
    GuidOnlyDSName.structLen = DSNameSizeFromLen(0);
    GuidOnlyDSName.NameLen = 0;
    GuidOnlyDSName.SidLen = 0;

    pFailure = &pFailures->rgDsaFailure[0];
    for (iFailure = 0;
         iFailure < pFailures->cNumEntries;
         iFailure++, pFailure++) {
        // Convert DSA object guid to string name.
        Assert(NULL == pFailure->pszDsaDN);
        Assert(!fNullUuid(&pFailure->uuidDsaObjGuid));

        GuidOnlyDSName.Guid = pFailure->uuidDsaObjGuid;

        err = DBFindDSName(pDB, &GuidOnlyDSName);
        if (0 == err) {
            // Resolved this object guid -- get the associated string name.
            pDSName = GetExtDSName(pDB);
            pFailure->pszDsaDN = pDSName->StringName;
        }
    }

    *ppFailures = pFailures;

    return 0;
}


ULONG
draGetClientContexts(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_CLIENT_CONTEXTS **  ppContexts
    )
/*++

Routine Description:

    Returns a list of all outstanding client contexts, sorted by ascending
    last used time.  (I.e., most recently used contexts are at the end of the
    list.)

Arguments:

    pTHS (IN)

    ppContexts (OUT) - On successful return, holds the client context list.

Return Values:

    Win32 error code.

--*/
{
    DS_REPL_CLIENT_CONTEXTS *   pContexts;
    DS_REPL_CLIENT_CONTEXT  *   pContext;
    DRS_CLIENT_CONTEXT *        pCtx;
    DWORD                       cb;
    DWORD                       iCtx;

    EnterCriticalSection(&gcsDrsuapiClientCtxList);
    __try {
        if (!gfDrsuapiClientCtxListInitialized) {
            InitializeListHead(&gDrsuapiClientCtxList);
            Assert(0 == gcNumDrsuapiClientCtxEntries);
            gfDrsuapiClientCtxListInitialized = TRUE;
        }

        cb = offsetof(DS_REPL_CLIENT_CONTEXTS, rgContext)
             + sizeof(DS_REPL_CLIENT_CONTEXT) * gcNumDrsuapiClientCtxEntries;

        pContexts = THAllocEx(pTHS, cb);

        pCtx = (DRS_CLIENT_CONTEXT *) gDrsuapiClientCtxList.Flink;
        for (iCtx = 0; iCtx < gcNumDrsuapiClientCtxEntries; iCtx++) {
            pContext = &pContexts->rgContext[iCtx];

            pContext->hCtx            = (ULONGLONG) pCtx;
            pContext->lReferenceCount = pCtx->lReferenceCount;
            pContext->fIsBound        = TRUE;
            pContext->uuidClient      = pCtx->uuidDsa;
            pContext->IPAddr          = pCtx->IPAddr;
            pContext->timeLastUsed    = pCtx->timeLastUsed;
            pContext->pid             = ((DRS_EXTENSIONS_INT *) &pCtx->extRemote)->pid;

            pCtx = (DRS_CLIENT_CONTEXT *) pCtx->ListEntry.Flink;
        }

        Assert(pCtx == (DRS_CLIENT_CONTEXT *) &gDrsuapiClientCtxList);
        pContexts->cNumContexts = gcNumDrsuapiClientCtxEntries;
    }
    __finally {
        LeaveCriticalSection(&gcsDrsuapiClientCtxList);
    }

    *ppContexts = pContexts;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dramsg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       dramsg.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

Author:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB "DRAMSG:"                /* define the subsystem for debugging */

#include "drserr.h"
#include "drautil.h"
#include "drauptod.h"
#include "dramail.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMSG


////////////////////////////////////////////////////////////////////////////////
//
//  REQUEST TRANSLATION FUNCTIONS
//

void
draXlateNativeRequestToOutboundRequest(
    IN  THSTATE *                   pTHS,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq,
    IN  MTX_ADDR *                  pmtxLocalDSA            OPTIONAL,
    IN  UUID *                      puuidTransportDN        OPTIONAL,
    IN  DWORD                       dwMsgVersionToSend,
    OUT DRS_MSG_GETCHGREQ *         pOutboundReq
    )
/*++

Routine Description:

    Translates a native get changes request into a version appropriate for a
    given remote DSA.

Arguments:

    pTHS (IN)

    pNativeReq (IN) - Native (local) request.

    pmtxLocalDSA (IN, OPTIONAL) - Network address of the local DSA for transport
        with objectGuid *puuidTransportDN.  Ignored if dwMsgVersionToSend does
        not indicate a mail-based request.
        
    puuidTransportDN (IN, OPTIONAL) - objectGuid of interSiteTransport object
        representing the transport over which the reply to this request should
        be sent.  Ignored if dwMsgVersionToSend does not indicate a mail-based
        request.
        
    dwMsgVersionToSend (IN) - Desired message version.
    
    pOutboundReq (OUT) - On return, the translated message.  Can be the same
        as pNativeReq, in which case the message is translated in-place.

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    UPTODATE_VECTOR_V1_WIRE * pUTDV1;

    if (((DRS_MSG_GETCHGREQ *) pNativeReq == pOutboundReq)
        && (DRS_MSG_GETCHGREQ_NATIVE_VERSION != dwMsgVersionToSend)) {
        // We may have to shuffle some fields around; first copy native request.
        DRS_MSG_GETCHGREQ_NATIVE *pNativeReqCopy = alloca(sizeof(DRS_MSG_GETCHGREQ_NATIVE));
        *pNativeReqCopy = *pNativeReq;
        pNativeReq = pNativeReqCopy;
    }
    
    // Convert native UTD format to request wire format (always V1).
    pUTDV1 = UpToDateVec_Convert(pTHS, 1, pNativeReq->pUpToDateVecDest);

    switch (dwMsgVersionToSend) {
    case 4: // Win2k mail-based request.
        Assert(NULL != pmtxLocalDSA);
        Assert(NULL != puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V4.pmtxReturnAddress        = pmtxLocalDSA;
        pOutboundReq->V4.uuidTransportObj         = *puuidTransportDN;
        pOutboundReq->V4.V3.uuidDsaObjDest        = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V4.V3.uuidInvocIdSrc        = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V4.V3.pNC                   = pNativeReq->pNC;
        pOutboundReq->V4.V3.usnvecFrom            = pNativeReq->usnvecFrom;
        pOutboundReq->V4.V3.pUpToDateVecDestV1    = pUTDV1;
        pOutboundReq->V4.V3.pPartialAttrVecDestV1 = NULL; // unused by Win2k
        pOutboundReq->V4.V3.ulFlags               = pNativeReq->ulFlags;
        pOutboundReq->V4.V3.cMaxObjects           = pNativeReq->cMaxObjects;
        pOutboundReq->V4.V3.cMaxBytes             = pNativeReq->cMaxBytes;
        pOutboundReq->V4.V3.ulExtendedOp          = pNativeReq->ulExtendedOp;
        
        // V4.V3.PrefixTableDest is not used by Win2k source DSAs.
        memset(&pOutboundReq->V4.V3.PrefixTableDest,
               0,
               sizeof(pOutboundReq->V4.V3.PrefixTableDest));

        if (pNativeReq->ulFlags & DRS_SYNC_PAS) {
            // Source does not support PAS cycles.
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
        }
        break;
    
    case 5: // Win2k RPC request.
        Assert(NULL == pmtxLocalDSA);
        Assert(NULL == puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V5.uuidDsaObjDest     = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V5.uuidInvocIdSrc     = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V5.pNC                = pNativeReq->pNC;
        pOutboundReq->V5.usnvecFrom         = pNativeReq->usnvecFrom;
        pOutboundReq->V5.pUpToDateVecDestV1 = pUTDV1;
        pOutboundReq->V5.ulFlags            = pNativeReq->ulFlags;
        pOutboundReq->V5.cMaxObjects        = pNativeReq->cMaxObjects;
        pOutboundReq->V5.cMaxBytes          = pNativeReq->cMaxBytes;
        pOutboundReq->V5.ulExtendedOp       = pNativeReq->ulExtendedOp;
        pOutboundReq->V5.liFsmoInfo         = pNativeReq->liFsmoInfo;
        
        if (pNativeReq->ulFlags & DRS_SYNC_PAS) {
            // Source does not support PAS cycles.
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
        }
        break;

    case 7: // Whistler mail-based request.
        Assert(NULL != pmtxLocalDSA);
        Assert(NULL != puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V7.pmtxReturnAddress     = pmtxLocalDSA;
        pOutboundReq->V7.uuidTransportObj      = *puuidTransportDN;
        pOutboundReq->V7.V3.uuidDsaObjDest     = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V7.V3.uuidInvocIdSrc     = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V7.V3.pNC                = pNativeReq->pNC;
        pOutboundReq->V7.V3.usnvecFrom         = pNativeReq->usnvecFrom;
        pOutboundReq->V7.V3.pUpToDateVecDestV1 = pUTDV1;
        pOutboundReq->V7.V3.ulFlags            = pNativeReq->ulFlags;
        pOutboundReq->V7.V3.cMaxObjects        = pNativeReq->cMaxObjects;
        pOutboundReq->V7.V3.cMaxBytes          = pNativeReq->cMaxBytes;
        pOutboundReq->V7.V3.ulExtendedOp       = pNativeReq->ulExtendedOp;
        pOutboundReq->V7.pPartialAttrSet       = pNativeReq->pPartialAttrSet;
        pOutboundReq->V7.pPartialAttrSetEx     = pNativeReq->pPartialAttrSetEx;
        pOutboundReq->V7.PrefixTableDest       = pNativeReq->PrefixTableDest;
        
        // V7.V3.PrefixTableDest is not used by Whistler beta 1 source DSAs.
        // This is a bit confusing, since one of the fields *added* in the V7
        // structure over the V3 is *another* PrefixTableDest structure --
        // V7.PrefixTableDest.
        //
        // This is true for V7.V3.pPartialAttrVecDest vs. V7.pPartialAttrSet,
        // too.
        //
        // In the ideal world we would remove the V7 fields and re-use the
        // V3 fields, but this is more difficult now that we have Whistler
        // beta 1 DCs that rely on the V7 fields.
        
        pOutboundReq->V7.V3.pPartialAttrVecDestV1 = NULL;
        memset(&pOutboundReq->V7.V3.PrefixTableDest,
               0,
               sizeof(pOutboundReq->V7.V3.PrefixTableDest));
        break;

    case 8: // Whistler RPC request.
        Assert(NULL == pmtxLocalDSA);
        Assert(NULL == puuidTransportDN);
        
        if ((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq) {
            pOutboundReq->V8 = *pNativeReq;
        }

        pOutboundReq->V8.pUpToDateVecDest = (UPTODATE_VECTOR *) pUTDV1;
        break;
    
    default:
        DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwMsgVersionToSend);
    }
}


void
draXlateInboundRequestToNativeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwInboundReqVersion,
    IN  DRS_MSG_GETCHGREQ *         pInboundReq,
    IN  DRS_EXTENSIONS *            pExt,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq,
    OUT DWORD *                     pdwReplyVersion,
    OUT MTX_ADDR **                 ppmtxReturnAddress      OPTIONAL,
    OUT UUID *                      puuidTransportObj       OPTIONAL
    )                           
/*++

Routine Description:

    Translates an inbound GetNCChanges request into the native request structure.
    Also determines the reply version desired by the remote DSA.

Arguments:

    pTHS (IN)

    dwInboundReqVersion (IN) - Version of inbound request.

    pInboundReq (IN) - Inbound request message.

    pExt (IN) - DRS extensions supported by the remote DSA.

    pNativeReq (OUT) - On return, holds the request in native format.  May be
        the same as pInboundReq, in which case the message is translated
        in-place.

    pdwReplyVersion (OUT) - Version of reply structure we should return to
        destination DSA.
        
    ppmtxReturnAddress (OUT, OPTIONAL) - If supplied, holds a pointer to the
        network address of the requesting (remote) DSA.  Returned/useful only
        if inbound request is in a mail-based format. 

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    CROSS_REF * pCR;
    DSNAME * pNC;
    MTX_ADDR * pmtxReturnAddress;
    UUID uuidTransportObj;

    // Convert older message formats (preserved for backward compatibility)
    // into the current format (a superset), and throw out requests sent by
    // DCs of long deceased builds.

    if (((DRS_MSG_GETCHGREQ *) pNativeReq == pInboundReq)
        && (DRS_MSG_GETCHGREQ_NATIVE_VERSION != dwInboundReqVersion)) {
        // We may have to shuffle some fields around; first copy native request.
        DRS_MSG_GETCHGREQ *pInboundReqCopy = alloca(sizeof(DRS_MSG_GETCHGREQ));
        *pInboundReqCopy = *pInboundReq;
        pInboundReq = pInboundReqCopy;
    }

    switch (dwInboundReqVersion) {
    case 4: // Win2k mail-based request.
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V4.V3.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V4.V3.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V4.V3.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V4.V3.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V4.V3.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V4.V3.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V4.V3.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V4.V3.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V4.V3.ulExtendedOp;
        pNativeReq->pPartialAttrSet   = NULL;
        pNativeReq->pPartialAttrSetEx = NULL;
        
        memset(&pNativeReq->liFsmoInfo, 0, sizeof(pNativeReq->liFsmoInfo));
        memset(&pNativeReq->PrefixTableDest, 0, sizeof(pNativeReq->PrefixTableDest));
        
        *pdwReplyVersion = 1;
        pmtxReturnAddress = pInboundReq->V4.pmtxReturnAddress;
        uuidTransportObj = pInboundReq->V4.uuidTransportObj;
        break;
    
    case 5: // Win2k RPC request.
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V5.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V5.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V5.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V5.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V5.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V5.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V5.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V5.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V5.ulExtendedOp;
        pNativeReq->liFsmoInfo        = pInboundReq->V5.liFsmoInfo;
        pNativeReq->pPartialAttrSet   = NULL;
        pNativeReq->pPartialAttrSetEx = NULL;
        
        memset(&pNativeReq->PrefixTableDest, 0, sizeof(pNativeReq->PrefixTableDest));

        *pdwReplyVersion = 1;
        pmtxReturnAddress = NULL;
        memset(&uuidTransportObj, 0, sizeof(uuidTransportObj));
        break;

    case 7: // Whistler mail-based request.
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V7.V3.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V7.V3.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V7.V3.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V7.V3.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V7.V3.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V7.V3.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V7.V3.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V7.V3.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V7.V3.ulExtendedOp;
        pNativeReq->pPartialAttrSet   = pInboundReq->V7.pPartialAttrSet;
        pNativeReq->pPartialAttrSetEx = pInboundReq->V7.pPartialAttrSetEx;
        pNativeReq->PrefixTableDest   = pInboundReq->V7.PrefixTableDest;
        
        memset(&pNativeReq->liFsmoInfo, 0, sizeof(pNativeReq->liFsmoInfo));
            
        if (IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V6)) {
            *pdwReplyVersion = 6;
        } else {
            // ISSUE: Can combine EXT_GETCHGREPLY_V5 to V6 after Beta 2 ships
            *pdwReplyVersion = IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V5) ? 5 : 3;
        }
        pmtxReturnAddress = pInboundReq->V7.pmtxReturnAddress;
        uuidTransportObj = pInboundReq->V7.uuidTransportObj;
        break;

    case 8: // Whistler RPC request.
        // Already in the native request format.
        if (pNativeReq != &pInboundReq->V8) {
            *pNativeReq = pInboundReq->V8;
        }
        
        if (IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V6)) {
            *pdwReplyVersion = 6;
        } else {
            // ISSUE: Can combine EXT_GETCHGREPLY_V5 to V6 after Beta 2 ships
            *pdwReplyVersion = IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V5) ? 5 : 3;
        }
        pmtxReturnAddress = NULL;
        memset(&uuidTransportObj, 0, sizeof(uuidTransportObj));
        break;
    
    default:
        // Either a request from an old unsupported build or someone added a
        // new request version to our IDL but hasn't yet taught us what to do
        // with it.
        DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
    }

    if (!(pNativeReq->ulFlags & DRS_WRIT_REP)
        && (NULL == pNativeReq->pPartialAttrSet)) {
        // Partial attribute set for Win2k replicas is derived from the
        // local schema.  We check elsewhere that the two schemas are
        // identical, although there exist degenerate cases where the
        // schemas may really differ but the checks pass -- ergo, one
        // reason the partial attribute set is an explicit parameter
        // post-Win2k.
        pNativeReq->pPartialAttrSet =
            (PARTIAL_ATTR_VECTOR_V1_EXT*)
                ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec;
    }
    
    // Convert embedded UTD vector to native format.
    pNativeReq->pUpToDateVecDest
        = UpToDateVec_Convert(pTHS,
                              UPTODATE_VECTOR_NATIVE_VERSION,
                              pNativeReq->pUpToDateVecDest);

    pCR = FindExactCrossRef(pNativeReq->pNC, NULL);
    if (NULL == pCR) {
        // Note that FSMO transfers send the FSMO object name in the "pNC"
        // field, which is not necessarily the name of the NC.
        pNC = FindNCParentDSName(pNativeReq->pNC, FALSE, FALSE);

        if (NULL != pNC) {
            pCR = FindExactCrossRef(pNC, NULL);
        }

        if (NULL == pCR) {
            // We no longer have a cross-ref for this instantiated replica.
            // This NC must must have been recently removed from the forest.
            // We will remove our replica of this NC as soon as the KCC runs.
            DRA_EXCEPT(DRAERR_BadNC, 0);
        }
    }

    Assert(pCR->flags & FLAG_CR_NTDS_NC);

    if ((pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED)
        && !(pNativeReq->ulFlags & DRS_WRIT_REP)
        && !IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_NONDOMAIN_NCS)) {
        // This request is from a Win2k DSA that, because it's a GC and has
        // no knowledge of the special handling of non-domain NCs, falsely
        // thinks that it is supposed to host a copy of this non-domain NC.
        // Spoof it by returning only the NC head and the Deleted Objects
        // container.  This minimizes the additional replication traffic while
        // preventing the destination DSA from thinking we we are "stale" and
        // routing around us (as it would if we instead returned an error).
        // Win2k SP2 GCs are smart enough not to ask for NDNCs.

        // Why two objects?  Because Win2k DCs can't handle NCs with no interior
        // nodes.  (They generate an exception on outbound replication of that
        // NC in draGetNCSize().)
        
        // See also the companion functionality in
        // draXlateNativeReplyToOutboundReply.
        DPRINT(0, "Spoofing Win2k GC trying to replicate NDNC (part 1).\n");
        
        // Note that we can't reset the usnvecFrom here, as this vector is used
        // as a key at the dest when performing mail-based replication to ensure
        // that the reply corresponds to the last request.
        Assert(0 == pNativeReq->usnvecFrom.usnHighObjUpdate);
        Assert(0 == pNativeReq->usnvecFrom.usnHighPropUpdate);

        // Always send all attributes of the first two objects.  It's not
        // important that we always send all attributes, but it is important
        // that we not filter out either of the first two objects, thereby
        // slowly replicating out all objects in the NDNC.
        pNativeReq->pUpToDateVecDest = NULL;
        
        // Note that DRA_GetNCChanges enforces a minimum on the number of
        // objects it will put in a packet -- as of this writing that
        // minimum is greater than the number of objects we need to return.
        // If more than two objects are returned, we'll chop them out in
        // draXlateNativeReplyToOutboundReply.
        pNativeReq->cMaxObjects = 2;
    }

    if (NULL != ppmtxReturnAddress) {
        *ppmtxReturnAddress = pmtxReturnAddress;
    }

    if (NULL != puuidTransportObj) {
        *puuidTransportObj = uuidTransportObj;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//  REPLY TRANSLATION FUNCTIONS
//

DWORD
draXlateNativeReplyToOutboundReply(
    IN      THSTATE *                       pTHS,
    IN      DRS_MSG_GETCHGREPLY_NATIVE *    pNativeReply,
    IN      DWORD                           dwXlateFlags,
    IN      DRS_EXTENSIONS *                pExt,
    IN OUT  DWORD *                         pdwMsgOutVersion,
    OUT     DRS_MSG_GETCHGREPLY *           pOutboundReply
    )
/*++

Routine Description:

    Translates a native get changes request into a version appropriate for a
    given remote DSA.

Arguments:

    pTHS (IN)

    pNativeReq (IN) - Native (local) request.

    dwXlateFlags - 0 or more of the following bits:
        DRA_XLATE_COMPRESS - Compress the reply.  If compression is successful,
        *pdwMsgOutVersion will be updated to denote a compressed reply.
    
    pExt (IN) - DRS extensions supported by the remote DSA.

    pdwMsgOutVersion (IN/OUT) - Message version to send to remote DSA.  The
        value may be modified if dwFlags & DRA_XLATE_COMPRESS.
        
    pOutboundReply (OUT) - The translated reply, ready to send to remote DSA.
        May be the same as pNativeReq, in which case the message is translated
        in-place.

Return Value:

    If the outbound reply is compressed, the number of compressed bytes is returned.
    Otherwise, 0 is returned.

--*/
{
    DWORD   cbEncodedReply = 0;
    BYTE *  pbEncodedReply;
    DWORD   cbCompressedReply = 0;
    BYTE *  pbCompressedReply;
    DRS_COMPRESSED_BLOB * pComprBlob = NULL;
    UPTODATE_VECTOR * pUTDV1;
    CROSS_REF * pCR;
    DSNAME * pNC;

    Assert(0 == (dwXlateFlags & ~DRA_XLATE_COMPRESS));

    if (((DRS_MSG_GETCHGREPLY *) pNativeReply == pOutboundReply)
        && (DRS_MSG_GETCHGREPLY_NATIVE_VERSION != *pdwMsgOutVersion)) {
        // We may have to shuffle some fields around; first copy native reply.
        DRS_MSG_GETCHGREPLY_NATIVE *pNativeReplyCopy = alloca(sizeof(DRS_MSG_GETCHGREPLY_NATIVE));
        *pNativeReplyCopy = *pNativeReply;
        pNativeReply = pNativeReplyCopy;
    }
    
    if (!IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_NONDOMAIN_NCS)) {
        // The destination DSA does not understand the instance type bits
        // IT_NC_COMING and IT_NC_GOING.  Filter them out of the outbound
        // replication stream.
        ATTR AttrITKey = {ATT_INSTANCE_TYPE};
        REPLENTINFLIST * pObj;
        ATTR * pAttrIT;
        SYNTAX_INTEGER * pIT;

        Assert(0 == offsetof(ATTR, attrTyp));

        for (pObj = pNativeReply->pObjects;
             NULL != pObj;
             pObj = pObj->pNextEntInf) {
            pAttrIT = bsearch(&AttrITKey,
                              pObj->Entinf.AttrBlock.pAttr,
                              pObj->Entinf.AttrBlock.attrCount,
                              sizeof(ATTR),
                              CompareAttrtyp);
            if (NULL != pAttrIT) {
                Assert(ATT_INSTANCE_TYPE == pAttrIT->attrTyp);
                Assert(1 == pAttrIT->AttrVal.valCount);
                Assert(sizeof(SYNTAX_INTEGER) == pAttrIT->AttrVal.pAVal->valLen);

                pIT = (SYNTAX_INTEGER *) pAttrIT->AttrVal.pAVal->pVal;

                if (*pIT & ~IT_MASK_WIN2K) {
                    DPRINT2(0, "Filtering IT bits 0x%x on obj %ls outbound to"
                                " Win2k replica.\n",
                            *pIT & ~IT_MASK_WIN2K,
                            pObj->Entinf.pName->StringName);
                    Assert(!(*pIT & ~IT_MASK_CURRENT));
                    *pIT &= IT_MASK_WIN2K;
                }
            } else {
                Assert(!"Outbound object data doesn't contain instance type?");
            }
        }

        // The destination DC doesn't understand NDNCs.  Is it a pre-SP2 Win2k
        // GC that (erroneously) thinks it should hold a read-only replica of an
        // NDNC?

        pCR = FindExactCrossRef(pNativeReply->pNC, NULL);
        if (NULL == pCR) {
            // Note that FSMO transfers send the FSMO object name in the "pNC"
            // field, which is not necessarily the name of the NC.
            pNC = FindNCParentDSName(pNativeReply->pNC, FALSE, FALSE);
    
            if (NULL != pNC) {
                pCR = FindExactCrossRef(pNC, NULL);
            }
    
            if (NULL == pCR) {
                // We no longer have a cross-ref for this instantiated replica.
                // This NC must must have been recently removed from the forest.
                // We will remove our replica of this NC as soon as the KCC runs.
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
        }
    
        Assert(pCR->flags & FLAG_CR_NTDS_NC);
    
        if (pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
            // This request is from a Win2k DSA that, because it's a GC and has
            // no knowledge of the special handling of non-domain NCs, falsely
            // thinks that it is supposed to host a copy of this non-domain NC.
            // Spoof it by returning only the NC head and the Deleted Objects
            // container.  This minimizes the additional replication traffic
            // while preventing the destination DSA from thinking we we are
            // "stale" and routing around us (as it would if we instead returned
            // an error).  Win2k SP2 GCs are smart enough not to ask for NDNCs.
            
            // See also the companion functionality in
            // draXlateInboundRequestToNativeRequest.

            DPRINT(0, "Spoofing Win2k GC trying to replicate NDNC (part 2).\n");

            // Note that DRA_GetNCChanges enforces a minimum on the number of
            // objects it will put in a packet -- as of this writing that
            // minimum is greater than the number of objects we need to return.
            // So if we have prepared more objects to return than the two we
            // need, remove them from the returned object list.
            if (pNativeReply->cNumObjects > 2) {
                pNativeReply->pObjects->pNextEntInf->pNextEntInf = NULL;
                pNativeReply->cNumObjects = 2;
            }

            Assert((pNativeReply->cNumObjects < 1)
                   || NameMatched(pNativeReply->pObjects->Entinf.pName, pCR->pNC));
            Assert((pNativeReply->cNumObjects < 2)
                   || (0 == wcsncmp(pNativeReply->pObjects->pNextEntInf->Entinf.pName->StringName,
                                    L"CN=Deleted Objects,",
                                    ARRAY_SIZE("CN=Deleted Objects,") - 1)));
            
            memset(&pNativeReply->usnvecTo, 0, sizeof(pNativeReply->usnvecTo));
            pNativeReply->pUpToDateVecSrc = NULL;
            pNativeReply->fMoreData = FALSE;
        }
    }

    // Convert from native reply version to desired reply version (sans
    // compression).

    switch (*pdwMsgOutVersion) {
    case 1: // Win2k reply.
        Assert((DRS_MSG_GETCHGREPLY *) pNativeReply != pOutboundReply);
        
        pOutboundReply->V1.uuidDsaObjSrc     = pNativeReply->uuidDsaObjSrc;
        pOutboundReply->V1.uuidInvocIdSrc    = pNativeReply->uuidInvocIdSrc;
        pOutboundReply->V1.pNC               = pNativeReply->pNC;
        pOutboundReply->V1.usnvecFrom        = pNativeReply->usnvecFrom;
        pOutboundReply->V1.usnvecTo          = pNativeReply->usnvecTo;
        pOutboundReply->V1.pUpToDateVecSrcV1 = UpToDateVec_Convert(pTHS, 1, pNativeReply->pUpToDateVecSrc);
        pOutboundReply->V1.PrefixTableSrc    = pNativeReply->PrefixTableSrc;
        pOutboundReply->V1.ulExtendedRet     = pNativeReply->ulExtendedRet;
        pOutboundReply->V1.cNumObjects       = pNativeReply->cNumObjects;
        pOutboundReply->V1.cNumBytes         = pNativeReply->cNumBytes;
        pOutboundReply->V1.pObjects          = pNativeReply->pObjects;
        pOutboundReply->V1.fMoreData         = pNativeReply->fMoreData;

        // A V1 reply has the nc size in the ulExtendedRet field
        if (pNativeReply->cNumNcSizeObjects) {
            pOutboundReply->V1.ulExtendedRet = pNativeReply->cNumNcSizeObjects;
        }
        
        Assert(!pTHS->fLinkedValueReplication);

        // In a customer scenario, you should never have any values when
        // running in the old mode. However, for testing, we allow a new
        // mode system to be regressed to old. In that case, this assert
        // might go off.
        // Assert(pmsgOutNew->V3.cNumValues == 0);
        break;

    case 3: // Whistler Beta 1 reply.
        Assert((DRS_MSG_GETCHGREPLY *) pNativeReply != pOutboundReply);
        
        pOutboundReply->V3.uuidDsaObjSrc     = pNativeReply->uuidDsaObjSrc;
        pOutboundReply->V3.uuidInvocIdSrc    = pNativeReply->uuidInvocIdSrc;
        pOutboundReply->V3.pNC               = pNativeReply->pNC;
        pOutboundReply->V3.usnvecFrom        = pNativeReply->usnvecFrom;
        pOutboundReply->V3.usnvecTo          = pNativeReply->usnvecTo;
        pOutboundReply->V3.pUpToDateVecSrcV1 = UpToDateVec_Convert(pTHS, 1, pNativeReply->pUpToDateVecSrc);
        pOutboundReply->V3.PrefixTableSrc    = pNativeReply->PrefixTableSrc;
        pOutboundReply->V3.ulExtendedRet     = pNativeReply->ulExtendedRet;
        pOutboundReply->V3.cNumObjects       = pNativeReply->cNumObjects;
        pOutboundReply->V3.cNumBytes         = pNativeReply->cNumBytes;
        pOutboundReply->V3.pObjects          = pNativeReply->pObjects;
        pOutboundReply->V3.fMoreData         = pNativeReply->fMoreData;
        pOutboundReply->V3.cNumNcSizeObjects = pNativeReply->cNumNcSizeObjects;
        pOutboundReply->V3.cNumNcSizeValues  = pNativeReply->cNumNcSizeValues;
        pOutboundReply->V3.cNumValues        = pNativeReply->cNumValues;
        pOutboundReply->V3.rgValues          = pNativeReply->rgValues;
        break;

    case 5: // Whistler reply.
        Assert((DRS_MSG_GETCHGREPLY *) pNativeReply != pOutboundReply);
        
        pOutboundReply->V5.uuidDsaObjSrc     = pNativeReply->uuidDsaObjSrc;
        pOutboundReply->V5.uuidInvocIdSrc    = pNativeReply->uuidInvocIdSrc;
        pOutboundReply->V5.pNC               = pNativeReply->pNC;
        pOutboundReply->V5.usnvecFrom        = pNativeReply->usnvecFrom;
        pOutboundReply->V5.usnvecTo          = pNativeReply->usnvecTo;
        pOutboundReply->V5.pUpToDateVecSrc   = pNativeReply->pUpToDateVecSrc;
        pOutboundReply->V5.PrefixTableSrc    = pNativeReply->PrefixTableSrc;
        pOutboundReply->V5.ulExtendedRet     = pNativeReply->ulExtendedRet;
        pOutboundReply->V5.cNumObjects       = pNativeReply->cNumObjects;
        pOutboundReply->V5.cNumBytes         = pNativeReply->cNumBytes;
        pOutboundReply->V5.pObjects          = pNativeReply->pObjects;
        pOutboundReply->V5.fMoreData         = pNativeReply->fMoreData;
        pOutboundReply->V5.cNumNcSizeObjects = pNativeReply->cNumNcSizeObjects;
        pOutboundReply->V5.cNumNcSizeValues  = pNativeReply->cNumNcSizeValues;
        pOutboundReply->V5.cNumValues        = pNativeReply->cNumValues;
        pOutboundReply->V5.rgValues          = pNativeReply->rgValues;
        break;

    case 6: // Whistler reply.
        if (pNativeReply != &pOutboundReply->V6) {
            pOutboundReply->V6 = *pNativeReply;
        }
        break;

    default:
        // Logic error?
        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, *pdwMsgOutVersion);
    }

    // At this point, pOutboundReply now holds the desired reply format,
    // uncompressed.

    if (DRA_XLATE_COMPRESS & dwXlateFlags) {
        // Compress the outbound message.
        DRS_COMP_ALG_TYPE CompressionAlg;

        // First we encode it into a stream.
        if (!draEncodeReply(pTHS, *pdwMsgOutVersion, pOutboundReply, 0,
                            &pbEncodedReply, &cbEncodedReply)) {
            // Allocate a buffer for the compressed data.
            cbCompressedReply = cbEncodedReply;
            pbCompressedReply = THAllocEx(pTHS, cbCompressedReply);

            // And compress it.
            cbCompressedReply = draCompressBlobDispatch(
                pbCompressedReply, cbCompressedReply,
                pExt,
                pbEncodedReply, cbEncodedReply,
                &CompressionAlg);

            if (0 != cbCompressedReply) {
                // Compression successful; send the compressed form.
                // Note that we're abandoning all the allocations in the
                // original reply; they'll be freed in bulk when the
                // thread state is freed (momentarily).
                switch (*pdwMsgOutVersion) {
                case 1:
                    Assert( DRS_COMP_ALG_MSZIP==CompressionAlg );
                    pComprBlob = &pOutboundReply->V2.CompressedV1;
                    *pdwMsgOutVersion = 2;
                    break;

                case 3:
                case 5:
                case 6:
                    if( IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V7) ) {
                        pComprBlob = &pOutboundReply->V7.CompressedAny;
                        pOutboundReply->V7.dwCompressedVersion = *pdwMsgOutVersion;
                        pOutboundReply->V7.CompressionAlg = CompressionAlg;
                        *pdwMsgOutVersion = 7;
                    } else {
                        Assert( DRS_COMP_ALG_MSZIP==CompressionAlg );
                        pComprBlob = &pOutboundReply->V4.CompressedAny;
                        pOutboundReply->V4.dwCompressedVersion = *pdwMsgOutVersion;
                        *pdwMsgOutVersion = 4;
                    }
                    break;

                default:
                    DRA_EXCEPT(DRAERR_InternalError, *pdwMsgOutVersion);
                }

                pComprBlob->cbUncompressedSize = cbEncodedReply;
                pComprBlob->cbCompressedSize = cbCompressedReply;
                pComprBlob->pbCompressedData = pbCompressedReply;
            }
            // Else compression failed (data may not be compressible);
            // go ahead and send uncompressed reply.

            THFreeEx(pTHS, pbEncodedReply);
        }
        // Else encoding failed; go ahead and send uncompressed reply.
    }

    if (NULL == pComprBlob) {
        // Returning uncompressed reply.
        IADJUST(pcDRAOutBytesTotal,       pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesTotalRate,   pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesNotComp,     pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesNotCompRate, pNativeReply->cNumBytes);
    } else {
        // Returning compressed reply.
        IADJUST(pcDRAOutBytesTotal,        cbCompressedReply);
        IADJUST(pcDRAOutBytesTotalRate,    cbCompressedReply);
        IADJUST(pcDRAOutBytesCompPre,      cbEncodedReply);
        IADJUST(pcDRAOutBytesCompPreRate,  cbEncodedReply);
        IADJUST(pcDRAOutBytesCompPost,     cbCompressedReply);
        IADJUST(pcDRAOutBytesCompPostRate, cbCompressedReply);
    }

    return cbCompressedReply;
}


void
draXlateInboundReplyToNativeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwReplyVersion,
    IN  DRS_MSG_GETCHGREPLY *         pInboundReply,
    IN  DWORD                         dwXlateFlags,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pNativeReply
    )
/*++

Routine Description:

    Translates an inbound GetNCChanges reply into the native reply structure.

Arguments:

    pTHS (IN)

    dwReplyVersion (IN) - Version of inbound reply.

    pInboundReply (IN) - Inbound reply message.

    dwXlateFlags (IN) - 0 or more of the following bits:
        DRA_XLATE_FSMO_REPLY - Reply is the result of a FSMO operation.

    pNativeReply (OUT) - On return, holds the reply in native format.  May be
        the same as pInboundReply, in which case the message is translated
        in-place.

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    DWORD ret, dwOriginalReplyVersion = dwReplyVersion;
    DWORD cbCompressedSize = 0, cbDesiredUncompressedSize = 0, cbActualUncompressedSize = 0;
    BYTE * pbEncodedReply, * pbCompressedData;
    DRS_MSG_GETCHGREPLY UncompressedReply;
    DRS_COMP_ALG_TYPE CompressionAlg;

    // Is the reply encoded and compressed?
    switch (dwReplyVersion) {
    case 2:
        // Encoded/compressed Win2k-compatible V1 reply.
        pbCompressedData = pInboundReply->V2.CompressedV1.pbCompressedData;
        cbCompressedSize = pInboundReply->V2.CompressedV1.cbCompressedSize;
        cbDesiredUncompressedSize = pInboundReply->V2.CompressedV1.cbUncompressedSize;
        dwReplyVersion = 1;
        CompressionAlg = DRS_COMP_ALG_MSZIP;
        break;
    
    case 4:
        // Encoded/compressed Whistler V3, V5 or V6 reply.
        pbCompressedData = pInboundReply->V4.CompressedAny.pbCompressedData;
        cbCompressedSize = pInboundReply->V4.CompressedAny.cbCompressedSize;
        cbDesiredUncompressedSize = pInboundReply->V4.CompressedAny.cbUncompressedSize;
        dwReplyVersion = pInboundReply->V4.dwCompressedVersion;
        CompressionAlg = DRS_COMP_ALG_MSZIP;
        Assert((3 == dwReplyVersion)
               || (5 == dwReplyVersion)
               || (6 == dwReplyVersion)
            );
        break;

    case 7:
    	// Encoded/compressed Whistler reply with support for different
    	// compression algorithms.
        pbCompressedData = pInboundReply->V7.CompressedAny.pbCompressedData;
        cbCompressedSize = pInboundReply->V7.CompressedAny.cbCompressedSize;
        cbDesiredUncompressedSize = pInboundReply->V7.CompressedAny.cbUncompressedSize;
        dwReplyVersion = pInboundReply->V7.dwCompressedVersion;
        CompressionAlg = pInboundReply->V7.CompressionAlg;
        Assert((3 == dwReplyVersion)
               || (5 == dwReplyVersion)
               || (6 == dwReplyVersion)
            );
    	break;

    case 1:
    case 3:
    case 5:
    case 6:
        // Not encoded/compressed.
        pbCompressedData = NULL;
        break;

    default:
        DRA_EXCEPT(DRAERR_InternalError, dwReplyVersion);
    }

    // Decompress/decode if necessary.
    if (NULL != pbCompressedData) {
        // Reply message is compressed and encoded -- recreate original reply.
        BYTE *pbEncodedReply = THAllocEx(pTHS, cbDesiredUncompressedSize);

        // Uncompress the reply.
        cbActualUncompressedSize = draUncompressBlobDispatch(
            pTHS, CompressionAlg,
            pbEncodedReply, cbDesiredUncompressedSize,
            pbCompressedData, cbCompressedSize);

        if (cbDesiredUncompressedSize != cbActualUncompressedSize) {
            DPRINT2(0,
                    "Failed to decompress message; actual uncomp"
                    " size was %u but source says it should have been %u.\n",
                    cbActualUncompressedSize,
                    cbDesiredUncompressedSize);
            DRA_EXCEPT(DRAERR_InvalidParameter,
                       cbActualUncompressedSize - cbDesiredUncompressedSize);
        }

        // Decode the reply.
        ret = draDecodeReply(pTHS,
                             dwReplyVersion,
                             pbEncodedReply,
                             cbDesiredUncompressedSize,
                             &UncompressedReply);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        THFreeEx(pTHS, pbEncodedReply);

        pInboundReply = &UncompressedReply;
    }

    // Convert to native format.
    switch (dwReplyVersion) {
    case 1:
        // A V6 looks like a V1 with zeros at the end.
        if (pNativeReply != &pInboundReply->V6) {
            memcpy(pNativeReply, &pInboundReply->V1, sizeof(pInboundReply->V1));
        }

        memset((BYTE *) pNativeReply + sizeof(DRS_MSG_GETCHGREPLY_V1),
               0,
               sizeof(DRS_MSG_GETCHGREPLY_NATIVE) - sizeof(DRS_MSG_GETCHGREPLY_V1));

        if (!(DRA_XLATE_FSMO_REPLY & dwXlateFlags)) {
            pNativeReply->cNumNcSizeObjects = pNativeReply->ulExtendedRet;
            pNativeReply->ulExtendedRet = 0;
        }
        break;
    
    case 3:
        // A V6 looks like a V3 except a V6 has a V2 UTD vector rather than a
        // V1 UTD vector.
        // A V6 looks like a V3 with zeros at the end.
        if (pNativeReply != &pInboundReply->V6) {
            memcpy(pNativeReply, &pInboundReply->V3, sizeof(pInboundReply->V3));
        }
        memset((BYTE *) pNativeReply + sizeof(DRS_MSG_GETCHGREPLY_V3),
               0,
               sizeof(DRS_MSG_GETCHGREPLY_NATIVE) - sizeof(DRS_MSG_GETCHGREPLY_V1));

        break;
        
    case 5:
        // A V6 looks like a V5 with zeros at the end.
        if (pNativeReply != &pInboundReply->V6) {
            memcpy(pNativeReply, &pInboundReply->V5, sizeof(pInboundReply->V5));
        }
        memset((BYTE *) pNativeReply + sizeof(DRS_MSG_GETCHGREPLY_V5),
               0,
               sizeof(DRS_MSG_GETCHGREPLY_NATIVE) - sizeof(DRS_MSG_GETCHGREPLY_V1));
        break;

    case 6:
        // Already in native format.
        if (pNativeReply != &pInboundReply->V6) {
            *pNativeReply = pInboundReply->V6;
        }
        break;

    default:
        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwReplyVersion);
    }

    if ((NULL != pNativeReply->pUpToDateVecSrc)
        && (UPTODATE_VECTOR_NATIVE_VERSION
            != pNativeReply->pUpToDateVecSrc->dwVersion)) {
        // Convert UTD vector to native format.
        pNativeReply->pUpToDateVecSrc
            = UpToDateVec_Convert(pTHS,
                                  UPTODATE_VECTOR_NATIVE_VERSION,
                                  pNativeReply->pUpToDateVecSrc);

        // The converted UTD will contain no timestamps.  However we know we
        // just talked to this source DSA, so add the current time to the
        // entry in the vector corresponding to this source.
        UpToDateVec_AddTimestamp(&pNativeReply->uuidInvocIdSrc,
                                 GetSecondsSince1601(),
                                 pNativeReply->pUpToDateVecSrc);
    }
    
    // Conversion complete -- update perf counters.
    if (NULL != pbCompressedData) {
        // Compressed.
        DPRINT1(2, "Uncompressed message V%d\n", dwOriginalReplyVersion);

        IADJUST(pcDRAInBytesTotal,        cbCompressedSize);
        IADJUST(pcDRAInBytesTotalRate,    cbCompressedSize);
        IADJUST(pcDRAInBytesCompPre,      cbActualUncompressedSize);
        IADJUST(pcDRAInBytesCompPreRate,  cbActualUncompressedSize);
        IADJUST(pcDRAInBytesCompPost,     cbCompressedSize);
        IADJUST(pcDRAInBytesCompPostRate, cbCompressedSize);
    } else {
        // Uncompressed.
        IADJUST(pcDRAInBytesTotal,       pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesTotalRate,   pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesNotComp,     pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesNotCompRate, pNativeReply->cNumBytes);
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//  REQUEST ENCODE / DECODE FUNCTIONS
//

DWORD
draEncodeRequest(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_GETCHGREQ * pReq,
    IN  DWORD               cbHeaderSize,
    OUT BYTE **             ppbEncodedMsg,
    OUT DWORD *             pcbEncodedMsg
    )
/*++

Routine Description:

    Encodes a request structure into a byte stream.

Arguments:

    pTHS (IN)

    dwMsgVersion (IN) - Version of message to encode.

    pReq (IN) - Message to encode.

    cbHeaderSize (IN) - Number of additional bytes to allocate at beginning of
        the encoded buffer to hold a header or other data.  (0 if none.)

    ppbEncodedMsg (OUT) - On successful return, contains a pointer to the
        THAlloc()'ed buffer holding the encoded message (offset by cbHeaderSize,
        if specified).

    pcbEncodedMsg (OUT) - On successful return, holds the size in bytes of
        *ppbEncodedMsg.  Includes cbHeaderSize.

Return Values:

    Win32 error code.

--*/
{
    char *      pPickdUpdReplicaMsg;
    ULONG       cbPickdSize;
    ULONG       ret = ERROR_SUCCESS;
    handle_t    hEncoding;
    RPC_STATUS  status;
    ULONG       ulEncodedSize;

    *ppbEncodedMsg = NULL;
    *pcbEncodedMsg = 0;

    __try {
        // Create encoding handle. Use bogus parameters because we don't
        // know the size yet, we'll reset to correct parameters later.
        status = MesEncodeFixedBufferHandleCreate(grgbBogusBuffer,
                                                  BOGUS_BUFFER_SIZE,
                                                  &ulEncodedSize,
                                                  &hEncoding);
        if (status != RPC_S_OK) {
            // Event logged below
            DRA_EXCEPT(status, 0);
        }

        __try {
            // Determine size of pickled update replica message.
            switch (dwMsgVersion) {
            case 4:
                cbPickdSize = DRS_MSG_GETCHGREQ_V4_AlignSize(hEncoding, &pReq->V4);
                break;
            
            case 7:
                cbPickdSize = DRS_MSG_GETCHGREQ_V7_AlignSize(hEncoding, &pReq->V7);
                break;
    
            default:
                DRA_EXCEPT(DRAERR_InternalError, dwMsgVersion);
            }

            // Allocate additional space for a header to prefix the allocated
            // data (if requested).
            *ppbEncodedMsg = THAllocEx(pTHS, cbPickdSize + cbHeaderSize);
            *pcbEncodedMsg = cbPickdSize + cbHeaderSize;

            // Set up pointer to encoding area.
            pPickdUpdReplicaMsg = *ppbEncodedMsg + cbHeaderSize;

            // Reset handle so that data is pickled into mail message
            status = MesBufferHandleReset(hEncoding, MES_FIXED_BUFFER_HANDLE,
                                          MES_ENCODE, &pPickdUpdReplicaMsg,
                                          cbPickdSize, &ulEncodedSize);
            if (status != RPC_S_OK) {
                // Event logged below
                DRA_EXCEPT(status, 0);
            }

            // Pickle data into buffer within mail message.
            switch (dwMsgVersion) {
            case 4:
                DRS_MSG_GETCHGREQ_V4_Encode(hEncoding, &pReq->V4);
                break;
            
            case 7:
                DRS_MSG_GETCHGREQ_V7_Encode(hEncoding, &pReq->V7);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        } __finally {
            // Free encoding handle
            MesHandleFree(hEncoding);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_DRA_REQUPD_PICFAULT,
                          szInsertWin32Msg(ret),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(ret),
                          &ret);
        DPRINT2(0, "Failed to encode DRS_MSG_GETCHGREQ, v=%d, error %d.\n",
                dwMsgVersion, ret);

        if (NULL != *ppbEncodedMsg) {
            THFreeEx(pTHS, *ppbEncodedMsg);
            *ppbEncodedMsg = NULL;
            *pcbEncodedMsg = 0;
        }
    }

    return ret;
}


ULONG
draDecodeRequest(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwMsgVersion,
    IN  BYTE *              pbEncodedMsg,
    IN  DWORD               cbEncodedMsg,
    OUT DRS_MSG_GETCHGREQ * pReq
    )
/*++

Routine Description:

    Decodes a DRS_MSG_GETCHGREQ structure from a byte stream, presumably
    encoded by a prior call to draEncodeRequest().

Arguments:

    pTHS (IN)
    
    dwMsgVersion (IN) - Version of the encoded request structure.
    
    pbEncodedMsg (IN) - Byte stream holding encoded request structure.
    
    cbEncodedMsg (IN) - Size in bytes of byte stream.
    
    pReq (OUT) - On successful return, holds the decoded request structure.

Return Values:

    Win32 error code.

--*/
{
    handle_t    hDecoding;
    RPC_STATUS  status;
    ULONG       ret = 0;

    // Set the request to zero so that all pointers are NULL.
    memset(pReq, 0, sizeof(*pReq));

    __try {
        // Set up decoding handle
        status = MesDecodeBufferHandleCreate(pbEncodedMsg, cbEncodedMsg, &hDecoding);
        if (status != RPC_S_OK) {
            DRA_EXCEPT(status, 0);
        }

        __try {
            switch (dwMsgVersion) {
            case 4:
                DRS_MSG_GETCHGREQ_V4_Decode(hDecoding, &pReq->V4);
                break;
            
            case 7:
                DRS_MSG_GETCHGREQ_V7_Decode(hDecoding, &pReq->V7);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        } __finally {
            // Free decoding handle
            MesHandleFree(hDecoding);
        }
    } __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_DRA_MAIL_UPDREP_BADMSG,
                          szInsertWin32Msg(ret),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(ret),
                          &ret);
        DPRINT2(0, "Failed to decode DRS_MSG_GETCHGREQ v=%d, error %d.\n",
                dwMsgVersion, ret);
    }

    return ret;
}



////////////////////////////////////////////////////////////////////////////////
//
//  REPLY ENCODE / DECODE FUNCTIONS
//

ULONG
draEncodeReply(
    IN  THSTATE *               pTHS,
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_GETCHGREPLY *   pReply,
    IN  DWORD                   cbHeaderSize,
    OUT BYTE **                 ppbEncodedMsg,
    OUT DWORD *                 pcbEncodedMsg
    )
/*++

Routine Description:

    Encodes a reply structure into a byte stream.

Arguments:

    pTHS (IN)

    dwMsgVersion (IN) - Version of message to encode

    pReply (IN) - Message to encode.

    cbHeaderSize (IN) - Number of additional bytes to allocate at beginning of
        the encoded buffer to hold a header or other data.  (0 if none.)

    ppbEncodedMsg (OUT) - On successful return, contains a pointer to the
        THAlloc()'ed buffer holding the encoded message (offset by cbHeaderSize,
        if specified).

    pcbEncodedMsg (OUT) - On successful return, holds the size in bytes of
        *ppbEncodedMsg.  Includes cbHeaderSize.

Return Values:

    Win32 error code.

--*/
{
    char *      pPickdUpdReplicaMsg;
    ULONG       cbPickdSize;
    ULONG       ret = ERROR_SUCCESS;
    handle_t    hEncoding;
    RPC_STATUS  status;
    ULONG       ulEncodedSize;

    *ppbEncodedMsg = NULL;
    *pcbEncodedMsg = 0;

    __try {
        // Create encoding handle. Use bogus parameters because we don't
        // know the size yet, we'll reset to correct parameters later.

        status = MesEncodeFixedBufferHandleCreate(grgbBogusBuffer,
                                                  BOGUS_BUFFER_SIZE,
                                                  &ulEncodedSize,
                                                  &hEncoding);
        if (status != RPC_S_OK) {
            // Event logged below
            DRA_EXCEPT(status, 0);
        }

        __try {
            // Determine size of pickled update replica message
            switch (dwMsgVersion) {
            case 1:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V1_AlignSize(hEncoding,
                                                               &pReply->V1);
                break;
            
            case 3:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V3_AlignSize(hEncoding,
                                                               &pReply->V3);
                break;
            
            case 5:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V5_AlignSize(hEncoding,
                                                               &pReply->V5);
                break;

            case 6:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V6_AlignSize(hEncoding,
                                                               &pReply->V6);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }

            // Allocate additional space for a header to prefix the allocated
            // data (if requested).
            *ppbEncodedMsg = THAllocEx(pTHS, cbPickdSize + cbHeaderSize);
            *pcbEncodedMsg = cbPickdSize + cbHeaderSize;

            // Set up pointer to encoding area.
            pPickdUpdReplicaMsg = *ppbEncodedMsg + cbHeaderSize;

            // Reset handle so that data is pickled into mail message
            status = MesBufferHandleReset(hEncoding, MES_FIXED_BUFFER_HANDLE,
                                          MES_ENCODE, &pPickdUpdReplicaMsg,
                                          cbPickdSize, &ulEncodedSize);
            if (status != RPC_S_OK) {
                // Event logged below
                DRA_EXCEPT(status, 0);
            }

            // Pickle data into buffer within mail message.
            switch (dwMsgVersion) {
            case 1:
                DRS_MSG_GETCHGREPLY_V1_Encode(hEncoding, &pReply->V1);
                break;
            case 3:
                DRS_MSG_GETCHGREPLY_V3_Encode(hEncoding, &pReply->V3);
                break;
            case 5:
                DRS_MSG_GETCHGREPLY_V5_Encode(hEncoding, &pReply->V5);
                break;
            case 6:
                DRS_MSG_GETCHGREPLY_V6_Encode(hEncoding, &pReply->V6);
                break;
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        }
        __finally {
            // Free encoding handle
            MesHandleFree(hEncoding);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_UPDREP_PICFAULT,
                 szInsertWin32Msg( ret ),
                 NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                 sizeof( ret ),
                 &ret );
        DPRINT2(0, "Failed to encode DRS_MSG_GETCHGREPLY, v=%d, error %d.\n",
                dwMsgVersion, ret);

        if (NULL != *ppbEncodedMsg) {
            THFreeEx(pTHS, *ppbEncodedMsg);
            *ppbEncodedMsg = NULL;
            *pcbEncodedMsg = 0;
        }
    }

    return ret;
}


ULONG
draDecodeReply(
    IN  THSTATE *               pTHS,
    IN  DWORD                   dwMsgVersion,
    IN  BYTE *                  pbEncodedMsg,
    IN  DWORD                   cbEncodedMsg,
    OUT DRS_MSG_GETCHGREPLY *   pReply
    )
/*++

Routine Description:

    Decodes a DRS_MSG_GETCHGREPLY structure from a byte stream, presumably
    encoded by a prior call to draEncodeReply().

Arguments:

    pTHS (IN)
    
    dwMsgVersion (IN) - Version of the encoded reply structure.
    
    pbEncodedMsg (IN) - Byte stream holding encoded reply structure.
    
    cbEncodedMsg (IN) - Size in bytes of byte stream.
    
    pReply (OUT) - On successful return, holds the decoded reply structure.

Return Values:

    Win32 error code.

--*/
{
    handle_t    hDecoding;
    RPC_STATUS  status;
    ULONG       ret = 0;

    // Set the request to zero so that all pointers are NULL.
    memset(pReply, 0, sizeof(*pReply));

    __try {
        // Set up decoding handle
        status = MesDecodeBufferHandleCreate(pbEncodedMsg, cbEncodedMsg, &hDecoding);
        if (status != RPC_S_OK) {
            DRA_EXCEPT(status, 0);
        }

        __try {
            switch (dwMsgVersion) {
            case 1:
                DRS_MSG_GETCHGREPLY_V1_Decode(hDecoding, &pReply->V1);
                break;
            case 3:
                DRS_MSG_GETCHGREPLY_V3_Decode(hDecoding, &pReply->V3);
                break;
            case 5:
                DRS_MSG_GETCHGREPLY_V5_Decode(hDecoding, &pReply->V5);
                break;
            case 6:
                DRS_MSG_GETCHGREPLY_V6_Decode(hDecoding, &pReply->V6);
                break;
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, 0);
            }
        } __finally {
            // Free decoding handle
            MesHandleFree(hDecoding);
        }
    } __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_DRA_MAIL_UPDREP_BADMSG,
                          szInsertWin32Msg(ret),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(ret),
                          &ret);
        DPRINT2(0, "Failed to decode DRS_MSG_GETCHGREPLY v=%d, error %d.\n",
                dwMsgVersion, ret);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\dramail.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dramail.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to support asynchronous (e.g., mail) replication.

NOTE #1: Variable-length headers
The MAIL_REP_MSG structure has the ability to have the data start at a
variable point from start of the message.  This is called a variable-
length header. This is indicated by the cbDataOffset field in the message.
W2K never set this field, and always expects a fixed header. Post-W2K fill
in this field, can send either a fixed or variable message, and can receive a
fixed or variable message.
Since MAIL_REP_MSG is a fixed size structure, care must be taken when
accessing a variable length header.  The rules are that when constructing
a native message, you can fill in the whole structure and access the 'data'
field as the start of the data. When receiving a message from the wire, or
when contructing a message with a non-native header size, you must NOT
access the data field, but must instead use the cbDataOffset to calculate
where the data should go.

NOTE #2: W2K compatibility and variable length headers
  We send an indication that we can handle variable headers.
  When we get the response,
  W2K will send the fixed header, and post-W2K will send
  an extended header.
  We detect whether the sender can support variable length headers.

NOTE #3: Linked Value Replication Protocol Upgrade
We detect whether a system is capabable of LVR according to the extension
bits in the mail message.
Destination logic:
  Sends the same request regardless of LVR.
  If we are in lvr mode and the dest is not, reject.
  If we are not in lvr mode, and the dest is, upgrade.
Source logic:
  We process the request regardless of LVR mode.
  We return a V1 reply to a W2K, and a V3 reply to post-W2K.
  If we are in lvr mode and the dest is not, reject.
  If we are not in lvr mode, and the dest is, upgrade.

DETAILS:

CREATED:

REVISION HISTORY:

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include <heurist.h>
#include "mci.h"
#include "mdi.h"
#include "permit.h"
#include "dsconfig.h"
#include "dsaapi.h"
#include "dsutil.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAMAIL:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "draasync.h"
#include "dramail.h"
#include "usn.h"
#include "drauptod.h"
#include "drasch.h"
#include "drameta.h"

#include <ismapi.h>
#include <align.h>

#include "xpress.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMAIL

// The service name used to send and receive messages between DSAs via ISM.
#define DRA_ISM_SERVICE_NAME L"NTDS Replication"

// Tests show that the smallest message we ever send appears to be about 700 bytes.
// It's probably not worth compressing such a small message, so we set the limit at
// 1024 bytes. This value was chosen mostly arbitrarily.
#define MIN_COMPRESS_SIZE 0x400

// The maximum value for gulDraCompressionLevel
#define MAX_COMPRESSION_LEVEL 9

// The level at which we compress the data (0=faster, ..., 9=more compression).
// The default value is 9 and the value can be changed with a registry key
ULONG gulDraCompressionLevel;

// This is the approximate maximum number of entries and bytes that we request
// in each mail update message.
ULONG gcMaxAsyncInterSiteObjects = 0;
ULONG gcMaxAsyncInterSiteBytes = 0;

// Delay between checks to see if the ISM service has been started.
#define MAIL_START_RETRY_PAUSE_MSECS    (5*60*1000)

// Delay time if we get an error while attempting to get the next inbound
// intersite message.
#define MAIL_RCVERR_RETRY_PAUSE_MINS    (30)
#define MAIL_RCVERR_RETRY_PAUSE_MSECS   (MAIL_RCVERR_RETRY_PAUSE_MINS*60*1000)

// If we try to apply changes and we get a sync failure, this is how
// long we wait before trying
#define SYNC_FAIL_RETRY_PAUSE_MSECS    5000

// This is the number of times we retry a sync failure before giving up.
#define SYNC_FAILURE_RETRY_COUNT 10

// The MSZIP and XPRESS compression libraries work on data blocks with a certain maximum
// size (see MSZIP_MAX_BLOCK and XPRESS_MAX_BLOCK). When encoding a blob, we split it
// up into blocks and compress each one separately. The compressed blobs are actually a
// sequence of MAIL_COMPRESS_BLOCKs, each of which contains the size and data of a
// compressed block.
typedef struct _MAIL_COMPRESS_BLOCK {
    ULONG cbUncompressedSize;
    ULONG cbCompressedSize;
    BYTE  data[];
} MAIL_COMPRESS_BLOCK;

// This is the maximum size of a block that we pass to the MSZIP library.
#define MSZIP_MAX_BLOCK (32*1024)


// Mail running is indicated by the gfDRAMAilRunning flag being TRUE.
BOOL gfDRAMailRunning = FALSE;

char grgbBogusBuffer[BOGUS_BUFFER_SIZE];

// Maximum number of milliseconds we have to wait for the mail send before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxTicksMailSendMsg = 0;

// Sleep for the given number of milliseconds or until shutdown is initiated,
// whichever comes first.
#define DRA_SLEEP(x)                            \
    WaitForSingleObject(hServDoneEvent, (x));   \
    if (eServiceShutdown) {                     \
        DRA_EXCEPT_NOLOG(DRAERR_Shutdown, 0);   \
    }

#define DWORDMIN(a,b) ((a<b) ? (a) : (b))

// printf templates for subject strings
#define MAX_INT64_D_SZ_LEN (25)
#define MAX_INT_X_SZ_LEN   (12)

#define REQUEST_TEMPLATE L"Get changes request for NC %ws from USNs <%I64d/OU, %I64d/PU> with flags 0x%x"
#define REQUEST_TEMPLATE_LEN (ARRAY_SIZE(REQUEST_TEMPLATE))
//This is how much space is needed for arguments when expanded (not inc nc)
#define REQUEST_VARIABLE_CHARS (MAX_INT64_D_SZ_LEN*2 + MAX_INT_X_SZ_LEN)

#define REPLY_TEMPLATE L"Get changes reply for NC %ws from USNs <%I64d/OU, %I64d/PU> to USNs <%I64d/OU, %I64d/PU>"
#define REPLY_TEMPLATE_LEN (ARRAY_SIZE(REPLY_TEMPLATE))
#define REPLY_VARIABLE_CHARS (MAX_INT64_D_SZ_LEN*4)

// Prototypes
void
ProcessReqUpdate(
    IN  THSTATE *       pTHS,
    IN  DRA_CERT_HANDLE hSenderCert,
    IN  MAIL_REP_MSG *pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed
    );

void
ProcessUpdReplica(
    IN  THSTATE *   pTHS,
    IN  MAIL_REP_MSG *pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed
    );

BOOL
draCompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppCmprsMailRepMsg,
    OUT DRS_COMP_ALG_TYPE *pCompressionAlg
    );

void
draUncompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppUncompressedMailRepMsg
    );

ULONG
SendMailMsg(
    IN      THSTATE *       pTHS,
    IN      LPWSTR          pszTransportDN,
    IN      MTX_ADDR *      pmtxDestDSA,
    IN      LPWSTR          pszSubject,
    IN      DRA_CERT_HANDLE hReceiverCert,      OPTIONAL
    IN OUT  MAIL_REP_MSG *  pMailRepMsg,
    IN OUT  ULONG *         pcbMsgSize
    )
/*++

Routine Description:

    Send message to remote DSA via ISM.  Compresses message before transmission
    if appropriate.

    This routine can send messages with variable length headers.  Routines that it
    calls, draCompress, draSign and draEncrypt, also understand variable length
    headers.

Arguments:

    pszTransportDN (IN) - Transport by which to send message.

    pmtxDestDSA (IN) - Transport-specific address of remote DSA.

    pszSubject (IN) - Subject string describing the message

    hReceiverCert (IN) - A handle to the receiver's certificate.  If non-NULL,
        the sent message will be signed and encrypted.  If NULL, the sent
        message will be signed only.

    pMailRepMsg (IN/OUT) - The pickled message to send.  Updated with
        compression and protocol versions.

    pcbMsgSize (IN/OUT) - The message size.  Reset if the sent message is
        compressed.

Return Values:

    DRAERR_*

--*/
{
    BOOL            fProcessed = FALSE;
    MAIL_REP_MSG *  pProcessedMailRepMsg;
    ISM_MSG         IsmMsg;
    LPWSTR          pszTransportAddress = NULL;
    DWORD           cch;
    DWORD           winErr;
    DRS_COMP_ALG_TYPE CompAlg = DRS_COMP_ALG_NONE;

    // Set the request version
    pMailRepMsg->ProtocolVersionCaller = CURRENT_PROTOCOL_VERSION;

    // This message has not been compressed yet
    pMailRepMsg->CompressionVersionCaller = DRS_COMP_ALG_NONE;

    // Compress the message.
    if( draCompressMessage(pTHS, pMailRepMsg, &pProcessedMailRepMsg, &CompAlg) ) {

        // Compression succeeded; work with the compressed message now
        fProcessed = TRUE;
        pMailRepMsg = pProcessedMailRepMsg;

        // Confirm that an acceptable algorithm was chosen
        Assert(   CompAlg==DRS_COMP_ALG_NONE
               || CompAlg==DRS_COMP_ALG_MSZIP
               || CompAlg==DRS_COMP_ALG_XPRESS );
        pMailRepMsg->CompressionVersionCaller = CompAlg;
    }

    if (NULL == hReceiverCert) {
        // Sign the message, but don't encrypt.
        draSignMessage(pTHS, pMailRepMsg, &pProcessedMailRepMsg);
    }
    else {
        // Sign and encrypt the message.
        draEncryptAndSignMessage(pTHS, pMailRepMsg, hReceiverCert,
                                 &pProcessedMailRepMsg);
    }

    if (fProcessed) {
        // We've processed the message once already; free the intermediate
        // version.  (As a corollary to this, we never free the original message
        // passed to us by the caller.)
        THFreeEx(pTHS, pMailRepMsg);
    }

    // Use the signed message as the one we will send.
    fProcessed = TRUE;
    pMailRepMsg = pProcessedMailRepMsg;
    *pcbMsgSize = MAIL_REP_MSG_SIZE(pMailRepMsg);

    // Send message.
    IsmMsg.pbData = (BYTE *) pMailRepMsg;
    IsmMsg.cbData = *pcbMsgSize;
    IsmMsg.pszSubject = pszSubject;

    pszTransportAddress = THAllocEx(pTHS, pmtxDestDSA->mtx_namelen * sizeof(WCHAR));
    cch = MultiByteToWideChar(CP_UTF8,
                              0,
                              pmtxDestDSA->mtx_name,
                              pmtxDestDSA->mtx_namelen,
                              pszTransportAddress,
                              pmtxDestDSA->mtx_namelen);
    Assert(0 != cch);

    winErr = I_ISMSend(&IsmMsg,
                       DRA_ISM_SERVICE_NAME,
                       pszTransportDN,
                       pszTransportAddress);

    if (NO_ERROR != winErr) {
        DPRINT3(0, "Unable to send %ws message to %ls, error %d.\n",
                pszSubject, pszTransportAddress, winErr);
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_EXTENSIVE,
                          DIRLOG_DRA_MAIL_ISM_SEND_FAILURE,
                          szInsertWin32Msg( winErr ),
                          szInsertWC( pszTransportAddress ),
                          szInsertWC( pszTransportDN ),
                          szInsertWC( pszSubject ),
                          NULL, NULL, NULL, NULL,
                          sizeof( winErr ),
                          &winErr );
    }

    if (fProcessed) {
        THFreeEx(pTHS, pProcessedMailRepMsg);
    }

    if(pszTransportAddress != NULL) THFreeEx(pTHS, pszTransportAddress);

    return winErr;
}

ULONG
SendReqUpdateMsg(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pTransportDN,
    IN  MTX_ADDR *                  pmtxSrcDSA,
    IN  UUID *                      puuidSrcInvocId,
    IN  UUID *                      puuidSrcDsaObj,
    IN  MTX_ADDR *                  pmtxLocalDSA,
    IN  DWORD                       dwInMsgVersion,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq
    )
/*++

Routine Description:

    Send a GetNCChanges() request message.

Arguments:

    pTransportDN (IN) - Transport by which to send the message.

    pmtxSrcDSA (IN) - Transport-specific address of remote DSA.

    puuidSrcInvocId (IN) - Invocation ID of source DSA.

    puuidSrcDsaObj (IN) - objectGuid of source DSA's ntdsDsa object.

    pmtxLocalDSA (IN) - Transport-specific address of local DSA (to use as
        a return address).

    pMsgReq (IN) - The request.

Return Values:

    DRAERR_*

--*/
{
    char *                  pbPickledMsg;
    ULONG                   cbPickdSize;
    DWORD                   cbDataOffset;
    DWORD                   cbExtOffset;
    MAIL_REP_MSG *          pMailRepMsg = NULL;
    DWORD                   ret = DRAERR_Success;
    handle_t                hEncoding;
    RPC_STATUS              status;
    ULONG                   ulEncodedSize;
    ULONG                   ulMsgSize;
    DWORD                   ret2, len;
    LPWSTR                  pszSubject = NULL;
    DWORD                   cTickStart;
    DWORD                   cTickDiff;
    DRS_MSG_GETCHGREQ       OutboundReq;
    BOOL                    fExtendedDataAllowed = (4 != dwInMsgVersion);
    DRS_EXTENSIONS_INT *    pextLocal = gAnchor.pLocalDRSExtensions;

    Assert(pTransportDN && pmtxSrcDSA && pNativeReq);
    Assert(!fNullUuid(&pTransportDN->Guid));
    Assert(OWN_DRA_LOCK());
    Assert(pTHS->fSyncSet && (SYNC_WRITE == pTHS->transType));

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier.
    ret = DRAEnsureMailRunning();
    if (ret) {
        return ret;
    }

    cTickStart = GetTickCount();

    // Abort if outbound replication is disabled and this is not a forced sync.
    if (gAnchor.fDisableInboundRepl && !(pNativeReq->ulFlags & DRS_SYNC_FORCED)) {
        DRA_EXCEPT(DRAERR_SinkDisabled, 0);
    }

    if (fExtendedDataAllowed) {
        // Other DSA is > Win2k.
        cbExtOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        cbDataOffset = ROUND_UP_COUNT(cbExtOffset + DrsExtSize(pextLocal),
                                      MAIL_REP_MSG_DATA_ALIGN);
    } else {
        // Other DSA is Win2k.
        cbExtOffset = 0;
        cbDataOffset = MAIL_REP_MSG_W2K_HEADER_SIZE;
    }
    
    Assert(COUNT_IS_ALIGNED(cbExtOffset, MAIL_REP_MSG_EXT_ALIGN));
    Assert(COUNT_IS_ALIGNED(cbDataOffset, MAIL_REP_MSG_DATA_ALIGN));
    
    __try {
        draXlateNativeRequestToOutboundRequest(pTHS,
                                               pNativeReq,
                                               pmtxLocalDSA,
                                               &pTransportDN->Guid,
                                               dwInMsgVersion,
                                               &OutboundReq);

        // Encode the request, leaving room at the beginning of the buffer to
        // hold our MAIL_REP_MSG header and DRS_EXTENSIONS (if needed).
        ret = draEncodeRequest(pTHS,
                               dwInMsgVersion,
                               &OutboundReq,
                               cbDataOffset,
                               (BYTE **) &pMailRepMsg,
                               &ulMsgSize);
        if (ret) {
            // Event already logged
            __leave;
        }

        pMailRepMsg->cbDataSize = ulMsgSize - cbDataOffset;
        pMailRepMsg->cbDataOffset = cbDataOffset;
        pMailRepMsg->dwMsgType = MRM_REQUPDATE;
        pMailRepMsg->dwMsgVersion = dwInMsgVersion;

        if (fExtendedDataAllowed) {
            // Record the DRS extensions we support.
            
            // Consumed by Whistler Beta 1 and Beta 2 DCs.
            pMailRepMsg->dwExtFlags = gAnchor.pLocalDRSExtensions->dwFlags;

            // Consumed by > Whistler Beta 2 DCs.
            pMailRepMsg->cbExtOffset = cbExtOffset;
            memcpy((BYTE *)pMailRepMsg + pMailRepMsg->cbExtOffset,
                   pextLocal,
                   DrsExtSize(pextLocal));
        }

        len = (DWORD)(REQUEST_TEMPLATE_LEN +
            wcslen( pNativeReq->pNC->StringName ) +
            REQUEST_VARIABLE_CHARS);
        pszSubject = (LPWSTR) THAllocEx(pTHS, len * sizeof( WCHAR ) );
        swprintf( pszSubject, REQUEST_TEMPLATE,
                  pNativeReq->pNC->StringName,
                  pNativeReq->usnvecFrom.usnHighObjUpdate,
                  pNativeReq->usnvecFrom.usnHighPropUpdate,
                  pNativeReq->ulFlags );

        // Note: pextRemote may be NULL here, or may be non-NULL. As a
        // result, sometimes requests may use Xpress compression, and sometimes
        // they may not.
        ret = SendMailMsg(pTHS, pTransportDN->StringName, pmtxSrcDSA,
                          pszSubject, NULL, pMailRepMsg, &ulMsgSize);

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        ;
    }
    
    if (DRAERR_Success != ret) {
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_DRA_IDREQUEST_FAILED,
                          szInsertDN(pNativeReq->pNC),
                          szInsertMTX(pmtxSrcDSA),
                          szInsertWin32Msg( ret ),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof( ret ),
                          &ret );
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_MAIL_REQ_UPD_SENT,
                 szInsertUL(ulMsgSize),
                 szInsertDN(pNativeReq->pNC),
                 szInsertMTX(pmtxSrcDSA));
    }

    if (pMailRepMsg) {
        THFreeEx(pTHS, pMailRepMsg);
    }

    // Update Reps-From value to indicate we have sent our request (or attempted
    // to do so, anyway).
    ret2 = UpdateRepsFromRef(pTHS,
                             DRS_UPDATE_RESULT,
                             pNativeReq->pNC,
                             DRS_FIND_DSA_BY_UUID,
                             URFR_MUST_ALREADY_EXIST,
                             puuidSrcDsaObj,
                             puuidSrcInvocId,
                             &pNativeReq->usnvecFrom,
                             &pTransportDN->Guid,
                             pmtxSrcDSA,
                             pNativeReq->ulFlags,
                             NULL,
                             ret ? ret : ERROR_DS_DRA_REPL_PENDING,
                             NULL);
    Assert(!ret2);

    if(pszSubject != NULL) THFreeEx(pTHS, pszSubject);

    cTickDiff = GetTickCount() - cTickStart;
    if (cTickDiff > gcMaxTicksMailSendMsg) {
        Assert(!"Replication was blocked for an inordinate amount of time waiting for mail message send!");
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_MAIL_SEND_CONTENTION,
                 szInsertUL((cTickDiff/1000) / 60),
                 szInsertUL((cTickDiff/1000) % 60),
                 NULL);
    }

    return ret;
}


ULONG
SendUpdReplicaMsg(
    IN  THSTATE *                     pTHS,
    IN  DSNAME *                      pTransportDN,
    IN  MTX_ADDR *                    pmtxDstDSA,
    IN  DRA_CERT_HANDLE               hRecipientCert,
    IN  DWORD                         dwOutMsgVersion,
    IN  BOOL                          fExtendedDataAllowed,
    IN  DRS_MSG_GETCHGREPLY_NATIVE *  pNativeReply
    )
/*++

Routine Description:

    Send reply to DSA that sent us a GetNCChanges() request.

Arguments:

    pTransportDN (IN) - Transport by which to send the message.

    pmtxDstDSA (IN) - Transport-specific address of remote DSA.

    hRecipientCert (IN) - Handle to recipient's cert, to be used for encryption.

    dwOutMsgVersion (IN) - Desired version for reply message

    fExtendedDataAllowed (IN) - Whether the sender supports variable headers

    pmsgUpdReplica (IN) - The reply.

Return Values:

    DRAERR_*

--*/
{
    char *                  pPickdUpdReplicaMsg;
    ULONG                   cbPickdSize;
    DWORD                   cbDataOffset;
    DWORD                   cbExtOffset;
    MAIL_REP_MSG *          pMailRepMsg;
    BOOL                    ret = FALSE;
    handle_t                hEncoding;
    RPC_STATUS              status;
    ULONG                   ulEncodedSize;
    ULONG                   ulMsgSize, len;
    LPWSTR                  pszSubject = NULL;
    DRS_MSG_GETCHGREPLY     OutboundReply;
    DRS_EXTENSIONS_INT *    pextLocal = gAnchor.pLocalDRSExtensions;

    Assert(0 == ((ULONG_PTR) pmtxDstDSA) % sizeof(DWORD));
    Assert(NULL != pTHS->pextRemote);

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier.

    ret = DRAEnsureMailRunning();
    if (ret) {
        return ret;
    }

    if (fExtendedDataAllowed) {
        // Other DSA is > Win2k.
        cbExtOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        cbDataOffset = ROUND_UP_COUNT(cbExtOffset + DrsExtSize(pextLocal),
                                      MAIL_REP_MSG_DATA_ALIGN);
    } else {
        // Other DSA is Win2k.
        cbExtOffset = 0;
        cbDataOffset = MAIL_REP_MSG_W2K_HEADER_SIZE;
    }
    
    Assert(COUNT_IS_ALIGNED(cbExtOffset, MAIL_REP_MSG_EXT_ALIGN));
    Assert(COUNT_IS_ALIGNED(cbDataOffset, MAIL_REP_MSG_DATA_ALIGN));

    __try {
        draXlateNativeReplyToOutboundReply(pTHS,
                                           pNativeReply,
                                           0,  // xlate flags
                                           pTHS->pextRemote,
                                           &dwOutMsgVersion,
                                           &OutboundReply);

        // Encode the reply, leaving room at the beginning of the buffer to
        // hold our MAIL_REP_MSG header and at the end to hold our
        // DRS_EXTENSIONS (if needed).
        ret = draEncodeReply(pTHS,
                             dwOutMsgVersion,
                             &OutboundReply,
                             cbDataOffset,
                             (BYTE **) &pMailRepMsg,
                             &ulMsgSize);
        if (ret) {
            // Event already logged
            __leave;
        }

        pMailRepMsg->cbDataSize = ulMsgSize - cbDataOffset;
        pMailRepMsg->cbDataOffset = cbDataOffset;
        pMailRepMsg->dwMsgType = MRM_UPDATEREPLICA;
        pMailRepMsg->dwMsgVersion = dwOutMsgVersion;

        if (fExtendedDataAllowed) {
            // Record the DRS extensions we support.
            
            // Consumed by Whistler Beta 1 and Beta 2 DCs.
            pMailRepMsg->dwExtFlags = gAnchor.pLocalDRSExtensions->dwFlags;

            // Consumed by > Whistler Beta 2 DCs.
            pMailRepMsg->cbExtOffset = cbExtOffset;
            memcpy((BYTE *)pMailRepMsg + pMailRepMsg->cbExtOffset,
                   pextLocal,
                   DrsExtSize(pextLocal));
        }

        len = (ULONG)(REPLY_TEMPLATE_LEN +
            wcslen(pNativeReply->pNC->StringName) +
            REPLY_VARIABLE_CHARS);
        pszSubject = THAllocEx(pTHS, len * sizeof( WCHAR ) );
    
        swprintf(pszSubject,
                 REPLY_TEMPLATE,
                 pNativeReply->pNC->StringName,
                 pNativeReply->usnvecFrom.usnHighObjUpdate,
                 pNativeReply->usnvecFrom.usnHighPropUpdate,
                 pNativeReply->usnvecTo.usnHighObjUpdate,
                 pNativeReply->usnvecTo.usnHighPropUpdate);

        ret = SendMailMsg(pTHS, pTransportDN->StringName, pmtxDstDSA,
            pszSubject, hRecipientCert, pMailRepMsg, &ulMsgSize );

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        ;
    }

    if (DRAERR_Success != ret) {
        // There is no other way for the source to record that it could not send
        // the reply.  We are going to drop the reply on the floor at this point.
        // If we did not log this, the user would no way to know what the problem
        // is.
        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_IDUPDATE_FAILED,
                          szInsertDN(pNativeReply->pNC),
                          szInsertMTX(pmtxDstDSA),
                          szInsertWin32Msg( ret ),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof( ret ),
                          &ret );
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_MAIL_UPD_REP_SENT,
                 szInsertUL(ulMsgSize),
                 szInsertDN(pNativeReply->pNC),
                 szInsertMTX(pmtxDstDSA));
    }

    THFreeEx(pTHS, pMailRepMsg);
    if(pszSubject != NULL) THFreeEx(pTHS, pszSubject);

    return ret;
}


void
draXlateInboundMailRepMsg(
    IN  THSTATE *           pTHS,
    IN  BYTE *              pbInboundMsg,
    IN  DWORD               cbInboundMsgSize,
    OUT BOOL *              pfExtendedDataAllowed,
    OUT MAIL_REP_MSG *      pNativeMsgHeader,
    OUT BYTE **             ppbData
    )
{
    // DRS extensions supported by Win2k.
    static DWORD dwWin2kExtFlags
        = (1 << DRS_EXT_BASE)
          | (1 << DRS_EXT_ASYNCREPL)
          | (1 << DRS_EXT_REMOVEAPI)
          | (1 << DRS_EXT_MOVEREQ_V2)
          | (1 << DRS_EXT_GETCHG_COMPRESS)
          | (1 << DRS_EXT_DCINFO_V1)
          // | (1 << DRS_EXT_STRONG_ENCRYPTION) // not supported over mail!
          | (1 << DRS_EXT_ADDENTRY_V2)
          | (1 << DRS_EXT_KCC_EXECUTE)
          | (1 << DRS_EXT_DCINFO_V2)
          | (1 << DRS_EXT_DCINFO_VFFFFFFFF)
          | (1 << DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD)
          | (1 << DRS_EXT_CRYPTO_BIND)
          | (1 << DRS_EXT_GET_REPL_INFO)
          | (1 << DRS_EXT_TRANSITIVE_MEMBERSHIP)
          | (1 << DRS_EXT_ADD_SID_HISTORY)
          | (1 << DRS_EXT_POST_BETA3)
          | (1 << DRS_EXT_RESTORE_USN_OPTIMIZATION)
          | (1 << DRS_EXT_GETCHGREQ_V5);
    
    MAIL_REP_MSG *      pInboundMsg = (MAIL_REP_MSG *) pbInboundMsg;
    DWORD               cbInboundHeader;
    BYTE *              pbData;
    DRS_EXTENSIONS *    pextRemote;
    DWORD               dwMsgVersion;
    DRS_EXTENSIONS_INT  extRemoteFlagsOnly;

    if (cbInboundMsgSize < MAIL_REP_MSG_W2K_HEADER_SIZE) {
        // Header is too small -- invalid.
        DRA_EXCEPT(ERROR_BAD_LENGTH, cbInboundMsgSize);
    }
                
    if (pInboundMsg->ProtocolVersionCaller != CURRENT_PROTOCOL_VERSION) {
        // Message is incompatible with our protocol -- invalid.
        LogAndAlertEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_INCOMPAT_MAIL_MSG_P,
                         NULL,
                         NULL,
                         NULL);

        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, pInboundMsg->ProtocolVersionCaller);
    }

    if (0 == pInboundMsg->cbDataOffset) {
        // Sent by Win2k DC.
        *pfExtendedDataAllowed = FALSE;
        cbInboundHeader = MAIL_REP_MSG_W2K_HEADER_SIZE;
        pbData = (BYTE *) pInboundMsg + MAIL_REP_MSG_W2K_HEADER_SIZE;
        pextRemote = NULL;
        dwMsgVersion = (pInboundMsg->dwMsgType & MRM_REQUPDATE) ? 4 : 1;
    } else {
        // Sent by >= Whistler DC.
        *pfExtendedDataAllowed = TRUE;
        cbInboundHeader = MAIL_REP_MSG_HEADER_SIZE(pInboundMsg);
        pbData = MAIL_REP_MSG_DATA(pInboundMsg);
        pextRemote = MAIL_REP_MSG_DRS_EXT(pInboundMsg);
        dwMsgVersion = pInboundMsg->dwMsgVersion;
    }

    if (cbInboundHeader < MAIL_REP_MSG_W2K_HEADER_SIZE) {
        // Header is too small -- invalid.
        DRA_EXCEPT(ERROR_BAD_LENGTH, cbInboundMsgSize);
    }

    // Message data is required.
    // Message data must be 8-byte aligned relative to start of buffer.
    //      Note that due to ISM_MSG buffer alignment, pInboundMsg is *not*
    //      8-byte aligned -- it's 4-byte aligned.
    // Message data must occur at or after the end of the header,
    // End of message data must coincide with the end of the inbound message.
    if ((NULL == pbData)
        || !COUNT_IS_ALIGNED(pbData - (BYTE *) pInboundMsg, MAIL_REP_MSG_DATA_ALIGN)
        || (pbData < (BYTE *) pInboundMsg + cbInboundHeader)
        || ((BYTE *) pInboundMsg + cbInboundMsgSize != pbData + pInboundMsg->cbDataSize)) {
        // Message data is invalid.
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, 0);
    }

    *ppbData = pbData;
    
    // DRS_EXTENSIONS are optional.
    // DRS_EXTENSIONS must be 8-byte aligned relative to start of buffer.
    //      Note that due to ISM_MSG buffer alignment, pInboundMsg is *not*
    //      8-byte aligned -- it's 4-byte aligned.
    // DRS_EXTENSIONS must occur at or after the end of the header,
    // DRS_EXTENSIONS must precede message data.
    if ((NULL != pextRemote)
        && (!COUNT_IS_ALIGNED((BYTE *) pextRemote - (BYTE *) pInboundMsg, MAIL_REP_MSG_EXT_ALIGN)
            || ((BYTE *) pextRemote < (BYTE *) pInboundMsg + cbInboundHeader)
            || (pbData < (BYTE *) pextRemote + sizeof(pextRemote->cb))
            || (pbData < (BYTE *) pextRemote + DrsExtSize(pextRemote)))) {
        // DRS_EXTENSIONS structure is invalid.
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, 0);
    }	
    
    // Copy the header and convert it into the current native structure.
    memcpy(pNativeMsgHeader,
           pInboundMsg,
           min(cbInboundHeader, MAIL_REP_MSG_CURRENT_HEADER_SIZE));
    if (cbInboundHeader < MAIL_REP_MSG_CURRENT_HEADER_SIZE) {
        memset((BYTE *) pNativeMsgHeader + cbInboundHeader,
               0,
               MAIL_REP_MSG_CURRENT_HEADER_SIZE - cbInboundHeader);
    }
    pNativeMsgHeader->dwMsgVersion = dwMsgVersion;

    // DRS_EXTENSIONS and message data are not present in the translated
    // message.
    pNativeMsgHeader->cbExtOffset = 0;
    pNativeMsgHeader->cbDataOffset = 0;

    // Record DRS_EXTENSIONS on the thread state.
    if (NULL == pextRemote) {
        if (0 == pNativeMsgHeader->dwExtFlags) {
            // Sent from Win2k DC.
            extRemoteFlagsOnly.dwFlags = dwWin2kExtFlags;
        } else {
            // Win2k < DC version <= Whistler Beta 2.
            extRemoteFlagsOnly.dwFlags = pNativeMsgHeader->dwExtFlags;
        }

        extRemoteFlagsOnly.cb = sizeof(extRemoteFlagsOnly.dwFlags);
        
        pextRemote = (DRS_EXTENSIONS *) &extRemoteFlagsOnly;
    } else {
        // Sent from > Whistler Beta 2 DC.
        Assert(pNativeMsgHeader->dwExtFlags
               == ((DRS_EXTENSIONS_INT *)pextRemote)->dwFlags);
    }

    DraSetRemoteDsaExtensionsOnThreadState(pTHS, pextRemote);
}


void
ProcessMailMsg(
    IN  ISM_MSG *   pIsmMsg
    )
/*++

Routine Description:

    Dispatch a message received via ISM.

Arguments:

    pIsmMsg (IN) - The received message.

Return Values:

    None.

--*/
{
    THSTATE *       pTHS;
    MAIL_REP_MSG    NativeMsgHeader;
    MAIL_REP_MSG *  pNativeMsg;
    BOOL            fProcessed = FALSE;
    DRA_CERT_HANDLE hSenderCert = NULL;
    BOOL            fEncrypted, fExtendedDataAllowed;
    DWORD           cb;
    PCHAR           pbData;

    // Set up thread state
    InitDraThread(&pTHS);

    __try {
        draXlateInboundMailRepMsg(pTHS,
                                  pIsmMsg->pbData,
                                  pIsmMsg->cbData,
                                  &fExtendedDataAllowed,
                                  &NativeMsgHeader,
                                  &pbData);

        if (!(NativeMsgHeader.dwMsgType & MRM_MSG_SIGNED)) {
            // We don't accept unsigned messages.
            // Send constructed bad message? Forgery?
            DRA_EXCEPT(ERROR_BAD_IMPERSONATION_LEVEL, 0);
        }

        fEncrypted = (NativeMsgHeader.dwMsgType & MRM_MSG_SEALED);

        if (fEncrypted) {
            // Decrypt and verify message signature.
            draDecryptAndVerifyMessageSignature(pTHS,
                                                &NativeMsgHeader,
                                                pbData,
                                                &pNativeMsg,
                                                &hSenderCert);
        }
        else {
            // Verify message signature.
            draVerifyMessageSignature(pTHS,
                                      &NativeMsgHeader,
                                      pbData,
                                      &pNativeMsg,
                                      &hSenderCert);
        }

        if (pNativeMsg->dwMsgType & MRM_MSG_COMPRESSED) {
            // Uncompress message.
            MAIL_REP_MSG * pUncompressedNativeMsg;

            draUncompressMessage(pTHS, pNativeMsg, &pUncompressedNativeMsg);
            THFreeEx(pTHS, pNativeMsg);
            pNativeMsg = pUncompressedNativeMsg;
        }

        // Check for linked value replication promotion

        if (pTHS->fLinkedValueReplication) {
            // If we are in LVR mode

            // If remote does not support, then reject
            if (!IS_LINKED_VALUE_REPLICATION_SUPPORTED(pTHS->pextRemote)) {
                LogAndAlertEvent(DS_EVENT_CAT_REPLICATION,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_DRA_INCOMPAT_MAIL_MSG_P,
                                 NULL,
                                 NULL,
                                 NULL);

                DRA_EXCEPT(ERROR_DS_NOT_SUPPORTED, 0);
            }

        } else {
            // We are not in LVR mode

            // Remote supports it, upgrade
            if ( IS_LINKED_VALUE_REPLICATION_SUPPORTED(pTHS->pextRemote) ) {
                DsaEnableLinkedValueReplication( pTHS, TRUE );
            }
        }

        // Act on type of message.
        switch (pNativeMsg->dwMsgType) {
        case MRM_REQUPDATE:
            // Source-side:
            // We accept old requests regardless of lvr, and new request=>lvr

            ProcessReqUpdate(pTHS,
                             hSenderCert,
                             pNativeMsg,
                             fExtendedDataAllowed );
            break;

        case MRM_UPDATEREPLICA:
            if (!fEncrypted) {
                // Yikes -- updates can contain sensitive data (like passwords)!
                // These messages MUST be encrypted.
                // Sender constructed bad message?
                DPRINT(0, "Received unencrypted \"update replica\" message!\n");
                DRA_EXCEPT(ERROR_BAD_IMPERSONATION_LEVEL, 0);
            }

            ProcessUpdReplica(pTHS,
                              pNativeMsg,
                              fExtendedDataAllowed );
            break;

        default:
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_MAIL_BADMSGTYPE,
                     szInsertUL(pNativeMsg->dwMsgType),
                     NULL,
                     NULL );
            DPRINT1(0, "Ignoring unknown message type %u.\n",
                    pNativeMsg->dwMsgType);
        }
    }
    __finally {
        if (NULL != hSenderCert) {
            draFreeCertHandle(hSenderCert);
        }

        DraReturn(pTHS, 0);
        free_thread_state();
    }
}


void
CheckReqSource(
    IN  DBPOS *         pDB,
    IN  DSNAME *        pReqUpdateMsgNC,
    IN  MTX_ADDR *      pmtxFromDN
    )
/*++

Routine Description:

    Verify the remote DSA is authorized to make GetNCChanges() requests for
    this NC.

Arguments:

    pReqUpdateMsgNC (IN) - The NC to be replicated.

    pmtxFromDN (IN) - The transport-specific addres of the remote DSA.

Return Values:

    None.  Generates exception if access is denied.

--*/
{
    ULONG len;

    Assert(0 == ((ULONG_PTR) pmtxFromDN) % sizeof(DWORD));

    // Find object.
    if (DBFindDSName(pDB, pReqUpdateMsgNC)) {
        // Couldn't find the replica NC, discard request
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_REQUPD_BADNC,
                 szInsertDN(pReqUpdateMsgNC),
                 szInsertMTX(pmtxFromDN),
                 NULL);

        DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, 0);
    }
}

void
ProcessReqUpdate(
    IN  THSTATE *       pTHS,
    IN  DRA_CERT_HANDLE hSenderCert,
    IN  MAIL_REP_MSG   *pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed
    )
/*++

Routine Description:

    Service a GetNCChanges() request received via ISM.

Arguments:

    pTHS (IN) - Ye old thread state.

    hSenderCert (IN) - Handle to sender's certificate.

    pMailRepMsg (IN) - Mail message

    fExtendedDataAllowed (IN) - Whether the sender supports variable headers

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    DRS_MSG_GETCHGREQ           InboundRequest;
    DRS_MSG_GETCHGREQ_NATIVE *  pNativeRequest = &InboundRequest.V8;
    DRS_MSG_GETCHGREPLY_NATIVE  NativeReply;
    DSNAME *                    pTransportDN;
    DWORD                       cb;
    DBPOS *                     pDB;
    DWORD                       ret = 0;
    DWORD                       dwOutMsgVersion;
    MTX_ADDR *                  pmtxReturnAddress;
    UUID                        uuidTransportObj;
    
    ret = draDecodeRequest(pTHS,
                           pMailRepMsg->dwMsgVersion,
                           MAIL_REP_MSG_DATA(pMailRepMsg),
                           pMailRepMsg->cbDataSize,
                           &InboundRequest);
    if (ret) {
        DRA_EXCEPT(ret, 0);
    }

    draXlateInboundRequestToNativeRequest(pTHS,
                                          pMailRepMsg->dwMsgVersion,
                                          &InboundRequest,
                                          pTHS->pextRemote,
                                          pNativeRequest,
                                          &dwOutMsgVersion,
                                          &pmtxReturnAddress,
                                          &uuidTransportObj);

    BeginDraTransaction(SYNC_READ_ONLY);
    pDB = pTHS->pDB;

    __try {
        // Abort if outbound replication is disabled and this is not a forced
        // sync.
        if (gAnchor.fDisableOutboundRepl
            && !(pNativeRequest->ulFlags & DRS_SYNC_FORCED)) {
            DRA_EXCEPT(DRAERR_SourceDisabled, 0);
        }

        // Check that we are authorized to replicate out to caller
        CheckReqSource(pDB, pNativeRequest->pNC, pmtxReturnAddress);

        // Get DN of the transport object.
        pTransportDN = THAllocEx(pTHS, DSNameSizeFromLen(0));
        pTransportDN->structLen = DSNameSizeFromLen(0);
        pTransportDN->Guid = uuidTransportObj;

        if (DBFindDSName(pDB, pTransportDN)
            || DBIsObjDeleted(pDB)
            || DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                           DBGETATTVAL_fREALLOC,
                           pTransportDN->structLen, &cb,
                           (BYTE **) &pTransportDN)) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_MAIL_INTERSITE_TRANSPORT_MISSING,
                     szInsertDN(pTransportDN),
                     NULL,
                     NULL);

            DRA_EXCEPT(DRAERR_InvalidParameter, 0);
        }
    } __finally {
        EndDraTransaction (!AbnormalTermination());
    }

    // If the destination is not expecting notify, make sure we don't have any
    // TODO: Move this routine into common GetNcChanges processing so that
    // RPC links with notification disabled can take advantage of this.
    // Perhaps have the corresponding code (draserv.c:682) key off of
    // DRS_NEVER_NOTIFY too, and move code into common path as well?
    if (pNativeRequest->ulFlags & DRS_NEVER_NOTIFY) {
        DWORD ret;
        DSNAME DN;
        LPWSTR pszDsaAddr;

        memset(&DN, 0, sizeof(DN));
        DN.Guid = pNativeRequest->uuidDsaObjDest;
        DN.structLen = DSNameSizeFromLen(0);

        pszDsaAddr = DSaddrFromName(pTHS, &DN);

        ret = DirReplicaReferenceUpdate(
            pNativeRequest->pNC,
            pszDsaAddr,
            &pNativeRequest->uuidDsaObjDest,
            (pNativeRequest->ulFlags & DRS_WRIT_REP) |
                DRS_DEL_REF | DRS_ASYNC_OP | DRS_GETCHG_CHECK
            );
        if (ret) {
            DPRINT2( 0, "Failed to remove reps-to for nc %ws, error %d\n",
                     pNativeRequest->pNC->StringName, ret );
            LogUnhandledError(ret);
            // keep going
        }
    }

    // No FSMO operations over mail
    Assert( pNativeRequest->ulExtendedOp == 0 );

    // Get the changes
    __try {
        ret = DRA_GetNCChanges(pTHS,
                               NULL,  // No filter
                               0,     // No dwDirSyncControlFlags
                               pNativeRequest,
                               &NativeReply);
    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        NativeReply.dwDRSError = ret;
    }

    // The code should have updated this value in all cases
    Assert( ret == NativeReply.dwDRSError );

    // If we are shutting down, get out now.
    if (eServiceShutdown) {
        DRA_EXCEPT_NOLOG(DRAERR_Shutdown, 0);
    }

    // Add schemaInfo to prefix table. ProcessMailMsg has already checked
    // that protocol versions match between source and destination, so other
    // side will strip it
    if (!ret) {
        if (ret = AddSchInfoToPrefixTable(pTHS, &NativeReply.PrefixTableSrc)) {
            LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_MAIL_ADD_SCHEMA_INFO_FAILED,
                              szInsertDN(pNativeRequest->pNC),
                              szInsertMTX(pmtxReturnAddress),
                              szInsertWin32Msg( ret ),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof( ret ),
                              &ret );
            // Return error to the destination
            NativeReply.dwDRSError = ret;
        }
    }

    // Handle request errors
    if (ret) {
        DraLogGetChangesFailure( pNativeRequest->pNC,
                                 TransportAddrFromMtxAddrEx(pmtxReturnAddress),
                                 ret,
                                 0 );

        // If destination is not Whistler Beta 2 w/V6, do not send a reply
        if (!(IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_GETCHGREPLY_V6))) {
            DRA_EXCEPT(ret, 0);
        }

        Assert( dwOutMsgVersion >= 6 );

        DPRINT1( 1, "Mail: Sending Whistler error reply with error %d\n", ret );

        // sanity check minimal error reply
        // NativeReply.usnvecFrom could be zero
        Assert( NativeReply.pNC );
        Assert( memcmp( &NativeReply.uuidDsaObjSrc,
                        &gAnchor.pDSADN->Guid,
                        sizeof( GUID )) == 0 );
        Assert( memcmp( &NativeReply.uuidInvocIdSrc,
                        &pTHS->InvocationID,
                        sizeof( GUID)) == 0 );
        Assert( NativeReply.dwDRSError );
        // Be paranoid that packet error field is set
        if (!NativeReply.dwDRSError) {
            DRA_EXCEPT(ret, 0);
        }
    }

    // Got changes, send em. (DRA_GetNcChanges excepts on error)
    // Any failure is logged by called routine.
    SendUpdReplicaMsg(pTHS,
                      pTransportDN,
                      pmtxReturnAddress,
                      hSenderCert,
                      dwOutMsgVersion,
                      fExtendedDataAllowed,
                      &NativeReply );
}


void
CheckUpdateMailSource(
    IN  DBPOS *         pDB,
    IN  DSNAME *        pUpdReplicaMsgNC,
    IN  UUID *          puuidDsaObjSrc,
    OUT REPLICA_LINK ** ppRepLink
    )
/*++

Routine Description:

    Verify that we replicate this NC from the source DSA.

Arguments:

    pUpdReplicaMsgNC (IN) - The NC being replicated.

    puuidDsaObjSrc (IN) - The objectGuid of the sources DSA's ntdsDsa object.

    ppRepLink (OUT) - On retunr, holds a pointer to the corresponding repsFrom
        value.

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    ULONG len;

    // Find NC object. If it's not there, give up
    if (DBFindDSName(pDB, pUpdReplicaMsgNC)) {
        // Can't find NC, discard request
        DPRINT1( 0, "Discarding message because we no longer hold NC %ws\n",
                 pUpdReplicaMsgNC->StringName );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_UPDREP_BADNC,
                 szInsertDN(pUpdReplicaMsgNC),
                 szInsertUUID(puuidDsaObjSrc),
                 NULL);

        DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, 0);
    }

    // Validate source.

    // try and find the name of the DRA that sent us this message in the
    // repsfrom attribute.
    FindDSAinRepAtt(pDB, ATT_REPS_FROM, DRS_FIND_DSA_BY_UUID,
            puuidDsaObjSrc, NULL, NULL, ppRepLink, &len);

    if ( (!*ppRepLink) || (!((*ppRepLink)->V1.ulReplicaFlags & DRS_MAIL_REP)) )
    {
        CHAR szUuid[40];
        // Couldn't find source DRA as someone we replicate from.
        DPRINT1( 0, "Discarding message because we no longer replicate from source %s\n",
                 DsUuidToStructuredString( puuidDsaObjSrc, szUuid ) );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_UPDREP_BADSRC,
                 szInsertDN(pUpdReplicaMsgNC),
                 szInsertUUID(puuidDsaObjSrc),
                 NULL);
        DRA_EXCEPT (ERROR_DS_DRA_NO_REPLICA, 0);
    }
}


void
draSendMailRequest(
    IN THSTATE                      *pTHS,
    IN DSNAME                       *pNC,
    IN ULONG                        ulOptions,
    IN REPLICA_LINK                 *pRepLink,
    IN UPTODATE_VECTOR *            pUpToDateVecDest,
    IN PARTIAL_ATTR_VECTOR*         pPartialAttrSet,
    IN PARTIAL_ATTR_VECTOR*         pPartialAttrSetEx
    )

/*++

Routine Description:

Send a mail-based request for replication.

Arguments:

    pTHS - thread state
    pNC - naming context
    ulOptions - Additional options, if any
    pRepLink - replica link structure
    pUpToDateVecDest - local UTD vector for this NC
    pPartialAttrSet - the PAS stored on the NC head (GC/RO repl only)
    pPartialAttrSetEx - any additional attributes (PAS cycles only)

Return Value:

    None

--*/

{
    DRS_MSG_GETCHGREQ_NATIVE    msgReq;
    DSNAME *                    pTransportDN;
    DWORD                       cb;
    ATTRTYP                     attAddress;
    MTX_ADDR *                  pmtxOurAddress;
    DWORD                       dwInMsgVersion;
    DSNAME                      dsTarget;
    DWORD                       dwTargetBehavior;
    DWORD                       ulErr;

    // assert: ensure we have PAS data for PAS cycles
    Assert(!(pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ||
           pPartialAttrSet && pPartialAttrSetEx);

    // Get DN of the transport object.
    pTransportDN = THAllocEx(pTHS, DSNameSizeFromLen(0));
    pTransportDN->structLen = DSNameSizeFromLen(0);
    pTransportDN->Guid = pRepLink->V1.uuidTransportObj;

    if (DBFindDSName(pTHS->pDB, pTransportDN)
        || DBIsObjDeleted(pTHS->pDB)
        || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                       DBGETATTVAL_fREALLOC,
                       pTransportDN->structLen, &cb,
                       (BYTE **) &pTransportDN)) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_MAIL_INTERSITE_TRANSPORT_MISSING,
                     szInsertDN(pTransportDN),
                     NULL,
                     NULL);

        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    // What attribute of our server object holds our transport-
    // specific address for this transport?
    GetExpectedRepAtt(pTHS->pDB,
                      ATT_TRANSPORT_ADDRESS_ATTRIBUTE,
                      &attAddress,
                      sizeof(attAddress));

    // Get our transport-specific address.
    pmtxOurAddress = draGetTransportAddress(pTHS->pDB,
                                            gAnchor.pDSADN,
                                            attAddress);

    // Build our request message.
    draConstructGetChgReq(pTHS,
                          pNC,
                          pRepLink,
                          pUpToDateVecDest,
                          pPartialAttrSet,
                          pPartialAttrSetEx,
                          ulOptions,
                          &msgReq);

    //
    // Determine which version to send to the source.
    //

    // default: W2K compatible
    dwInMsgVersion = 4;

    if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS ) {
        // up version if forest is homogenious at whistler level
        dwInMsgVersion = 7; // whistler compatible
    }
    else {
        // Get target behavior version
        ZeroMemory(&dsTarget, sizeof(DSNAME));
        dsTarget.structLen = DSNameSizeFromLen(0);
        dsTarget.Guid = pRepLink->V1.uuidDsaObj;
        dwTargetBehavior = 0;

        ulErr = GetBehaviorVersion(pTHS->pDB, &dsTarget, &dwTargetBehavior);
        if ( ERROR_SUCCESS == ulErr &&
             dwTargetBehavior >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS ) {
            // up version since target dsa speaks our language.
            dwInMsgVersion = 7; // whistler compatible
        }
    }


    // And off it goes...
    SendReqUpdateMsg(pTHS,
                     pTransportDN,
                     RL_POTHERDRA(pRepLink),
                     &pRepLink->V1.uuidInvocId,
                     &pRepLink->V1.uuidDsaObj,
                     pmtxOurAddress,
                     dwInMsgVersion,
                     &msgReq);

    THFreeEx(pTHS, pmtxOurAddress);

    if (NULL != pUpToDateVecDest) {
        THFreeEx(pTHS, pUpToDateVecDest);
    }

    THFreeEx(pTHS, pTransportDN);
} /* draSendMailRequest */


void
sendNextMailRequestHelp(
    IN THSTATE *pTHS,
    IN DSNAME *pNC,
    IN UUID *puuidDsaObjSrc,
    IN BOOL fExtendedDataAllowed
    )

/*++

Routine Description:

    Helper routine for ProcessUpdReplica

    This point divides two separate phases: the reply processing phase above,
    and the request issuing phase below.  Note that the input parameters for the
    request, the USN from vector, the rep flags, and the UTD vector, are all
    re-read at this point.  They are not passed down through variables.  This
    makes the phase below stateless; it also means that any state going forward
    has to be written to the reps-from above in order to take effect.

    Send the next mail request

Arguments:

    pTHS - thread state
    pNC - DSNAME of naming context
    puuidDsaObjSrc - uuid of src dsa

Return Value:

    None

--*/

{
    BOOL                    fHasRepsFromValues;
    DWORD                   cb;
    DWORD                   dwRet;
    REPLICA_LINK *          pRepLink;
    UPTODATE_VECTOR *       pUpToDateVecDest = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    SYNTAX_INTEGER          it;

    BeginDraTransaction(SYNC_WRITE);
    Assert(OWN_DRA_LOCK());    // We better own it

    __try {
        dwRet = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it);
        if (dwRet) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, dwRet);
        }

        if (FindDSAinRepAtt(pTHS->pDB,
                            ATT_REPS_FROM,
                            DRS_FIND_DSA_BY_UUID,
                            puuidDsaObjSrc,
                            NULL,
                            &fHasRepsFromValues,
                            &pRepLink,
                            &cb)) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Make sure we still have a mail-based link
        if (!(pRepLink->V1.ulReplicaFlags & DRS_MAIL_REP)) {
            CHAR szUuid[40];
            // Couldn't find source DRA as someone we replicate from.
            DPRINT1( 0, "Discarding message because we no longer replicate from source %s over mail\n",
                     DsUuidToStructuredString( puuidDsaObjSrc, szUuid ) );
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_MAIL_UPDREP_BADSRC,
                     szInsertDN(pNC),
                     szInsertUUID(puuidDsaObjSrc),
                     NULL);
            DRA_EXCEPT (ERROR_DS_DRA_NO_REPLICA, 0);
        }

        UpToDateVec_Read(pTHS->pDB,
                         it,
                         UTODVEC_fUpdateLocalCursor,
                         DBGetHighestCommittedUSN(),
                         &pUpToDateVecDest);

        if (!(pRepLink->V1.ulReplicaFlags & DRS_WRIT_REP)){

            //
            // GC ReadOnly Replication
            //  - Partial-Attribute-Set setup:
            //      - For GC replication, ship over PAS from NC head
            //      - for PAS cycles, get also extended attrs from replink
            //

            GC_GetPartialAttrSets(
                pTHS,
                pNC,
                pRepLink,
                &pPartialAttrSet,
                &pPartialAttrSetEx);

                if (pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) {

                    //
                    // PAS cycle:
                    //  - ensure we have the extended set
                    //  - notify admin
                    //

                    Assert(pPartialAttrSet);
                    Assert(pPartialAttrSetEx);
                    // Log so the admin knows what's going on.
                    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GC_PAS_CYCLE,
                             szInsertWC(pNC->StringName),
                             szInsertMTX(RL_POTHERDRA(pRepLink)),
                             NULL
                             );
                }
        }


        Assert(OWN_DRA_LOCK());    // We better own it

        draSendMailRequest(
            pTHS,
            pNC,
            0,
            pRepLink,
            pUpToDateVecDest,
            pPartialAttrSet,
            pPartialAttrSetEx );
    }
    __finally {
        EndDraTransaction(!AbnormalTermination());
        Assert(OWN_DRA_LOCK());    // We better own it
    }

} /* sendNextMailRequestHelp */


DWORD
applyReplyPacket(
    IN THSTATE *pTHS,
    IN LPWSTR pszSourceServer,
    IN DRS_MSG_GETCHGREPLY_NATIVE *pUpdReplicaMsg,
    IN OUT ULONG *pulRepFlags,
    OUT PBYTE schemaInfo,
    OUT USN_VECTOR *pusnvecSyncPoint,
    OUT DWORD *pdwNCModified
    )

/*++

Routine Description:

    Apply one reply packet

Arguments:

    pTHS - thread state
    pszSourceServer - name of source server
    pUpdReplicaMsg - the reply message
    pulRepFlags - replication flags, may be updated
    schemaInfo - schema info, may be updated
    pusnvecSyncPoint - position, may be updated
    pdwNCModified - modified flag, may be updated

Return Value:

    DWORD - 

--*/

{
    ULONG ret;
    ULONG ulSyncFailure = 0;
    DRA_REPL_SESSION_STATISTICS replStats = {0};

    // Set the count of remaining entries to update.
    ISET(pcRemRepUpd, pUpdReplicaMsg->cNumObjects);

    // Strip out the schema info from the prefix table.
    // It is there, since current versions send it and
    // ProcessMailMsg checks that the version no.s are
    // compatible before doing anything

    StripSchInfoFromPrefixTable(&pUpdReplicaMsg->PrefixTableSrc, schemaInfo);

    ret = UpdateNC(pTHS,
                   pUpdReplicaMsg->pNC,
                   pUpdReplicaMsg,
                   pszSourceServer,
                   &ulSyncFailure,
                   (*pulRepFlags) | DRS_GET_ANC,
                   pdwNCModified,
                   &replStats.ObjectsCreated,
                   &replStats.ValuesCreated,
                   schemaInfo,
                   FALSE /*not preemptable, mail isn't anyway*/);

    Assert(OWN_DRA_LOCK());    // We better own it

    // If we had no sync failure...
    if ( (!ret) && (!ulSyncFailure) ) {

        replStats.ObjectsReceived = pUpdReplicaMsg->cNumObjects;
        replStats.ValuesReceived = pUpdReplicaMsg->cNumValues;
        replStats.SourceNCSizeObjects = pUpdReplicaMsg->cNumNcSizeObjects;
        replStats.SourceNCSizeValues = pUpdReplicaMsg->cNumNcSizeValues;

        // Report progress on any kind of "full sync"
        if (pUpdReplicaMsg->usnvecFrom.usnHighPropUpdate == 0) {
            // ISSUE wlees Aug 29, 2000. This reporting interface loses
            // information because we don't preserve the statistics across a
            // series of calls. The totals across a session (series of exchanges)
            // are not kept. Also, if updateNC creates some objects and then
            // returns an error, those objects are never counted.
            draReportSyncProgress(
                pTHS,
                pUpdReplicaMsg->pNC,
                pszSourceServer,
                &replStats );
        }

        // Leave "full sync packet" mode on successful packet
        (*pulRepFlags) &= ~DRS_FULL_SYNC_PACKET;

        // we are synced to the usn we received in the mail msg.
        (*pusnvecSyncPoint) = pUpdReplicaMsg->usnvecTo;

    } else if (ret == DRAERR_MissingObject) {
        // Not enough properties sent to create an object
        
        Assert((!((*pulRepFlags) & DRS_FULL_SYNC_PACKET)) &&
               (!((*pulRepFlags) & DRS_FULL_SYNC_NOW)) &&
               (!((*pulRepFlags) & DRS_FULL_SYNC_IN_PROGRESS)) );

        // Re-request all properties
        (*pulRepFlags) |= DRS_FULL_SYNC_PACKET;
    }

    // Incorporate warning status
    return ret ? ret : ulSyncFailure;
} /* applyOneReply */


BOOL
applyMailUpdateHelp(
    IN THSTATE *pTHS,
    IN ULONG ulRepFlags,
    IN LPWSTR pszSourceServer,
    IN REPLICA_LINK *pRepLink,
    IN DRS_MSG_GETCHGREPLY_NATIVE *pUpdReplicaMsg
    )

/*++

Routine Description:

    Description

Arguments:

    pTHS - thread state
    ulRepFlags - replication flags
    pszSourceServer - name of source server
    pRepLink - The replica link for this source
    pUpdReplicaMsg - The native reply

Return Value:

    BOOL - Whether another request should be sent

--*/

{
    ULONG                   ret = 0;
    ULONG                   ret2;
    ULONG                   ulResult;
    USN_VECTOR              usnvecSyncPoint;
    DWORD                   dwNCModified = MODIFIED_NOTHING;
    BOOL                    fSendNextRequest = FALSE;
    BYTE                    schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    BOOL                    fSchInfoChanged = FALSE;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    SYNTAX_INTEGER          it;

    // note how up to sync we are to start off with
    usnvecSyncPoint = pUpdReplicaMsg->usnvecFrom;

    if (!pUpdReplicaMsg->dwDRSError) {
        ulResult = applyReplyPacket(
            pTHS,
            pszSourceServer,
            pUpdReplicaMsg,
            &ulRepFlags,
            schemaInfo,
            &usnvecSyncPoint,
            &dwNCModified
            );
    } else {
        ulResult = pUpdReplicaMsg->dwDRSError;
        DPRINT3( 1, "Source %ls partition %ls returned mail-based sync reply with extended error %d\n",
                 pszSourceServer, pUpdReplicaMsg->pNC->StringName, ulResult );
    }

    // Update repsFrom.
    BeginDraTransaction(SYNC_WRITE);

    __try {
        // Note that the old RepsFrom might have disappeared -- this
        // is expected when we get our first packet for a read-only
        // NC, as at the outset we have a placeholder NC that is
        // destroyed and replaced with the real NC head in the first
        // packet.

        ret2 = UpdateRepsFromRef(pTHS,
                                 DRS_UPDATE_ALL,  // Modify whole repsfrom
                                 pUpdReplicaMsg->pNC,
                                 DRS_FIND_DSA_BY_UUID,
                                 URFR_NEED_NOT_ALREADY_EXIST,
                                 &pUpdReplicaMsg->uuidDsaObjSrc,
                                 &pUpdReplicaMsg->uuidInvocIdSrc,
                                 &usnvecSyncPoint,
                                 &pRepLink->V1.uuidTransportObj,
                                 RL_POTHERDRA(pRepLink),
                                 ulRepFlags,
                                 &pRepLink->V1.rtSchedule,
                                 ulResult,
                                 NULL);

        if ((0 == ulResult) && (0 == ret2)
            && !pUpdReplicaMsg->fMoreData) {
            // we're now up-to-date with respect to the source DSA, so
            // we're also now transitively up-to-date with respect to
            // other DSAs to at least the same point as the source DSA

            ret = FindNC(pTHS->pDB,
                         pUpdReplicaMsg->pNC,
                         FIND_MASTER_NC | FIND_REPLICA_NC,
                         &it);
            if (ret) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, ret);
            }

            if (it & IT_NC_COMING) {
                // The initial inbound replication of this NC is now
                // complete.
                ret = ChangeInstanceType(pTHS,
                                         pUpdReplicaMsg->pNC,
                                         it & ~IT_NC_COMING,
                                         DSID(FILENO,__LINE__));
                if (ret) {
                    DRA_EXCEPT(ret, 0);
                }
            }

            if ( ulRepFlags & DRS_SYNC_PAS ) {
                //
                // We've had completed a successful PAS cycle.
                // At this point we can only claim to be as up to date as our source.
                // Action:
                //  - Overwrite our UTD w/ the source's UTD.
                //  - complete PAS replication:
                //      - reset other links USN vectors
                //      - reset this source's flags
                //
                //
                UpToDateVec_Replace(
                    pTHS->pDB,
                    &pUpdReplicaMsg->uuidInvocIdSrc,
                    &pUpdReplicaMsg->usnvecTo,
                    pUpdReplicaMsg->pUpToDateVecSrc);

                // assert: must have PAS data for PAS cycles
                GC_GetPartialAttrSets(
                    pTHS,
                    pUpdReplicaMsg->pNC,
                    pRepLink,
                    &pPartialAttrSet,
                    &pPartialAttrSetEx);
                Assert(pPartialAttrSet && pPartialAttrSetEx);

                // do the rest: USN water marks & update repsFrom
                (void)GC_CompletePASReplication(
                    pTHS,
                    pUpdReplicaMsg->pNC,
                    &pRepLink->V1.uuidDsaObj,
                    pPartialAttrSet,
                    pPartialAttrSetEx);
                ulRepFlags &= ~DRS_SYNC_PAS;
            }
            else {
                // improve our up-to-date vector for this NC
                UpToDateVec_Improve(pTHS->pDB,
                                    &pUpdReplicaMsg->uuidInvocIdSrc,
                                    &pUpdReplicaMsg->usnvecTo,
                                    pUpdReplicaMsg->pUpToDateVecSrc);
            }

            ulRepFlags &= ~DRS_FULL_SYNC_IN_PROGRESS;

            // Notify replicas
            DBNotifyReplicasCurrDbObj(pTHS->pDB, FALSE /*!urgnt*/);
        }
    }
    __finally {
        EndDraTransaction(!(ret2 || AbnormalTermination()));
        Assert(OWN_DRA_LOCK());    // We better own it
    }

    // Determine if we request another packet
    // On error, we want to be careful not to re-request a packet that is
    // going to fail again.  Better to wait for next period.
    // Note that we do not retry on error since we want to avoid
    // an infinite retry loop.
    fSendNextRequest = ( (0 == ulResult) && (pUpdReplicaMsg->fMoreData) );

    // If the sync was successful and we have no more data to sync,
    // write the schema info in case of schema NC sync
    if (DsaIsRunning() && NameMatched(gAnchor.pDMD,pUpdReplicaMsg->pNC)) {
        if (!ulResult && !fSendNextRequest) {
            // Update the schema-info value only if the replication
            // is successful, and there is nothign more to sync

            fSchInfoChanged = FALSE;
            WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged);
        }

        // if any "real" schema changes happened, up the global
        // to keep track of schema changes since boot, so that
        // later schema replications can check if thy have an updated
        // schema cache. Do this even if the whole NC replication
        // failed, since this indicates at least one object has
        // been changed.

        if (MODIFIED_NCTREE_INTERIOR == dwNCModified) {
            IncrementSchChangeCount(pTHS);
        }

        // force a cache update if anything cached changed
        if ( (MODIFIED_NCTREE_INTERIOR == dwNCModified) || fSchInfoChanged) {

            if (!SCSignalSchemaUpdateImmediate()) {
                // couldn't signal a schema update
                // Event will be logged in the exception handler
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }
        }
    }

    return fSendNextRequest;

} /* applyMailUpdateHelp */

void
ProcessUpdReplica(
    IN  THSTATE *   pTHS,
    IN  MAIL_REP_MSG *pMailRepMsg,
    IN  BOOL         fExtendedDataAllowed
    )
/*++

Routine Description:

    Service a GetNCChanges() reply received via ISM.

Similar to the synchronous code, there are three ways that "full sync" may be
indicated in this code:
1. usnvecfrom was set to scratch.  UTD is valid. When a replica is added, this
   is the kind of full sync that happens the first time.  See the call to
   ReplicaSync in ReplicaAdd().
2. FULL_SYNC_NOW specified to ReplicaAdd. In draConstructGetChg, we set the
usn vec from to scratch, and the UTD to NULL.  In Replica Add, if FULL_SYNC_NOW
was specified, FULL_SYNC_IN_PROGRESS was written to the Reps-From. See case 3.
3. After we have received a packet, and we are constructing another request,
we check whether FULL_SYNC_IN_PROGRESS was saved in the reps-from flags. If so,
we leave the usn as is, and we set the UTD to NULL.

Arguments:

    pTHS (IN) - Ye old thread state.

    pMailRepMsg (IN) - Mail message

    fExtendedDataAllowed (IN) - Whether source allows variable headers

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    DRS_MSG_GETCHGREPLY             InboundReply;
    DRS_MSG_GETCHGREPLY_NATIVE *    pNativeReply = &InboundReply.V6;
    REPLICA_LINK *                  pRepLink;
    ULONG                           ret = 0;
    ULONG                           ulRepFlags;
    BOOL                            fSendNextRequest = FALSE;
    DSTIME                          timeStarted;
    LPWSTR                          pszSourceServer = NULL;

    // Get the DRA mutex before we check that we replicate this NC.
    GetDRASyncLock ();
    Assert(OWN_DRA_LOCK());    // We better own it
    timeStarted = GetSecondsSince1601();

    __try {
        BeginDraTransaction(SYNC_READ_ONLY);

        __try {
            // Decode according to proper version
            ret = draDecodeReply(pTHS,
                                 pMailRepMsg->dwMsgVersion,
                                 MAIL_REP_MSG_DATA(pMailRepMsg),
                                 pMailRepMsg->cbDataSize,
                                 &InboundReply);
            if (ret) {
                // Event already logged
                DRA_EXCEPT(ret, 0);
            }

            // Note that a Whistler source may send us a normal full reply
            // or a simple error reply.  An error reply has only the minimum
            // fields filled in. 

            draXlateInboundReplyToNativeReply(pTHS,
                                              pMailRepMsg->dwMsgVersion,
                                              &InboundReply,
                                              0,
                                              pNativeReply );

            // Abort if inbound replication is disabled.
            // Note that there is no accomodation for the DRS_SYNC_FORCED flag
            // (which is used solely as a test hook for RPC-based replication).
            if (gAnchor.fDisableInboundRepl) {
                DRA_EXCEPT(DRAERR_SinkDisabled, 0);
            }

            CheckUpdateMailSource(pTHS->pDB,
                              pNativeReply->pNC,
                              &pNativeReply->uuidDsaObjSrc,
                              &pRepLink);

            pszSourceServer = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepLink));

            VALIDATE_REPLICA_LINK_VERSION(pRepLink);

            // Save replica flags
            ulRepFlags = pRepLink->V1.ulReplicaFlags;
        }
        __finally {
            EndDraTransaction (!AbnormalTermination());
            Assert(OWN_DRA_LOCK());    // We better own it
        }

        // Check compatibility of source

        if (0 != memcmp(&pNativeReply->usnvecFrom,
                        &gusnvecFromScratch,
                        sizeof(gusnvecFromScratch))) {
            // Not the first packet of changes.
            if (0 != memcmp(&pNativeReply->usnvecFrom,
                            &pRepLink->V1.usnvec,
                            sizeof(pRepLink->V1.usnvec))) {
                // Out of sequence message, discard.
                DPRINT1(0, "Discarding out-of-sequence message from %ws.\n",
                        pszSourceServer );
                DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
            }
        }

        // Increment active threads to avoid sudden termination
        InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);

        __try {
            // Apply Updates phase
            fSendNextRequest = applyMailUpdateHelp(
                pTHS,
                ulRepFlags,
                pszSourceServer,
                pRepLink,
                pNativeReply );

            // Send next message phase

            Assert(OWN_DRA_LOCK());    // We better own it
            if (fSendNextRequest && !eServiceShutdown) {
                // Send request for next batch of changes.

                sendNextMailRequestHelp( pTHS,
                                         pNativeReply->pNC,
                                         &pNativeReply->uuidDsaObjSrc,
                                         fExtendedDataAllowed );

            } // if next request...
        }
        __finally {
            // No more remaining entries.
            ISET (pcRemRepUpd, 0);

            // Thread can be terminated now.
            InterlockedDecrement((ULONG *) &ulcActiveReplicationThreads);
            Assert(OWN_DRA_LOCK());    // We better own it
        }
    }
    __finally {
        DWORD cMinsDiff = (DWORD) ((GetSecondsSince1601() - timeStarted) / 60);

        FreeDRASyncLock();

        if ( (cMinsDiff > gcMaxMinsSlowReplWarning) &&
            IsDraOpWaiting() &&
            pNativeReply->pNC) {
            CHAR szUuid[40];

            DPRINT4( 0, "Perf warning: Mail update nc %ws, source %s, status %d took %d mins.\n",
                     pNativeReply->pNC->StringName,
                     DsUuidToStructuredString( &(pNativeReply->uuidDsaObjSrc), szUuid ),
                     ret, cMinsDiff );
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DRA_REPLICATION_FINISHED,
                      szInsertUL(cMinsDiff),
                      szInsertSz("Mail Synchronization Update"),
                      szInsertHex(0), // Options
                      szInsertUL(ret),
                      szInsertDN(pNativeReply->pNC),
                      szInsertUUID(&(pNativeReply->uuidDsaObjSrc)),
                      NULL,
                      NULL);
        }
    }
}

void
CheckForMail(void)
/*++

Routine Description:

    Receives and dispatches inbound intersite messages.  Terminates on shutdown
    or when ISM service is not running.

Arguments:

    None.

Return Values:

    None.

--*/
{
    MAIL_REP_MSG *  pMailRepMsg;
    ULONG           cbMsgSize;
    ULONG           ulRet;
    LPWSTR          pszTransportDN;
    ISM_MSG *       pIsmMsg;

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier. If running, or starts, check for messages.

    __try {

        if (DRAEnsureMailRunning() == DRAERR_Success) {

            // While we have mail messages, remove them from the queue.
            while (!eServiceShutdown) {
                ulRet = I_ISMReceive(DRA_ISM_SERVICE_NAME, INFINITE, &pIsmMsg);

                if (eServiceShutdown) {
                    // DS is shutting down; clear out.
                    break;
                }
                else if (NO_ERROR == ulRet) {
                    Assert(NULL != pIsmMsg);

                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_DRA_MAIL_RECEIVED,
                             szInsertUL( pIsmMsg->cbData ),
                             szInsertWC( pIsmMsg->pszSubject ),
                             NULL );

                    __try {
                        ProcessMailMsg(pIsmMsg);
                    }
                    __finally {
                        // Free memory allocated by I_ISMReceive().
                        I_ISMFree(pIsmMsg);
                    }
                }
                else if ( (RPC_S_SERVER_UNAVAILABLE == ulRet) ||
                          (ERROR_SHUTDOWN_IN_PROGRESS == ulRet) ) {
                    // ISM service has been stopped?
                    // Wait and then exit, calling thread will retry.
                    DPRINT(0, "ISM service stopped.\n");
                    gfDRAMailRunning = FALSE;
                    DRA_SLEEP(MAIL_START_RETRY_PAUSE_MSECS);
                    break;
                }
                else {
                    // Error retrieving message.
                    DPRINT1(0, "Error %d retrieving mail message.\n", ulRet);
                    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                                      DS_EVENT_SEV_EXTENSIVE,
                                      DIRLOG_DRA_MAIL_ISM_RECEIVE_RETRY,
                                      szInsertWin32Msg( ulRet ),
                                      szInsertUL( MAIL_RCVERR_RETRY_PAUSE_MINS ),
                                      NULL, NULL, NULL, NULL, NULL, NULL,
                                      sizeof( ulRet ),
                                      &ulRet );
                    DRA_SLEEP(MAIL_RCVERR_RETRY_PAUSE_MSECS);
                }
            }
        } else {
            // Ok, mail is not running for some reason, wait and then exit,
            // calling thread will retry
            DRA_SLEEP(MAIL_START_RETRY_PAUSE_MSECS);
        }
    } __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        // Handle error. Any error conditions are logged earlier.
        ;
    }
}


ULONG __stdcall
MailReceiveThread(
    IN  void *  pvIgnored
    )
/*++

Routine Description:

    Thread to retrieve and process inbound intersite messages.  Terminates on
    shutdown.

Arguments:

    pvIgnored (IN) - Ignored.

Return Values:

    None.

--*/
{
    while (!eServiceShutdown) {
        CheckForMail();
    }

    return 0;
}


ULONG
DRAEnsureMailRunning()
/*++

Routine Description:

    Determines whether the ISM service is running.

Arguments:

    None.

Return Values:

    DRAERR_Success - Running.

    DRAERR_MailProblem - Not running.

--*/
{
    SERVICE_STATUS  ServiceStatus;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hService = NULL;

    if (gfDRAMailRunning) {
        return DRAERR_Success;
    }

    // Is the ISM service running?
    __try {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (NULL == hSCM) {
            DPRINT1(1, "Unable to OpenSCManager(), error %d.\n", GetLastError());
            __leave;
        }

        hService = OpenService(hSCM, "ismserv", SERVICE_QUERY_STATUS);
        if (NULL == hService) {
            DPRINT1(1, "Unable to OpenService(), error %d.\n", GetLastError());
            __leave;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus)) {
            DPRINT1(1, "Unable to QueryServiceStatus(), error %d.\n", GetLastError());
            __leave;
        }

        if (SERVICE_RUNNING == ServiceStatus.dwCurrentState) {
            DPRINT(0, "ISMSERV is running.\n");
            gfDRAMailRunning = TRUE;
        }
    }
    __finally {
        if (hService != NULL) {
            CloseServiceHandle(hService);
        }

        if (hSCM != NULL) {
            CloseServiceHandle(hSCM);
        }
    }

    return gfDRAMailRunning ? DRAERR_Success : DRAERR_MailProblem;
}


ULONG
GetCompressionLevel( VOID )
/*++

Routine Description:

    Returns the level at which the blobs of data should be compressed. This value can
    be set with the registry key defined by DRA_REPL_COMPRESSION_LEVEL.

Arguments:

    None.

Return Values:

    A value between 0 and MAX_COMPRESSION_LEVEL.
    
--*/
{
    return DWORDMIN( gulDraCompressionLevel, MAX_COMPRESSION_LEVEL );
}


/*
 * Simple wrappers around THAlloc for use by the Xpress compression functions below.
 */
void * XPRESS_CALL xpressAlloc(void* context, int size) {
    return THAlloc(size);
}

void XPRESS_CALL xpressFree(void* context, void* address) {
    THFree(address);
}


ULONG
draUncompressBlobXpress(
    OUT BYTE *      pOutputBuffer,
    IN  ULONG       cbOutputBuffer,
    IN  BYTE *      pInputBuffer,
    IN  ULONG       cbInputBuffer
    )
/*++

Routine Description:

    Uncompress a buffer of blocks that was generated by draCompressBlobXpress().

    Blob Diagram:

    Block 0: <Uncomp. Len>   <Comp. Len>   <............ Data ............>
    Block 1: <Uncomp. Len>   <Comp. Len>   <............ Data ............>
    Block 2: <Uncomp. Len>   <Comp. Len>   <............ Data ............>

    Each block starts on a DWORD-aligned boundary and contains an uncompressed
    length, a compressed length, and a block of data. If the compressed length
    equals the uncompressed length, the data is not compressed. If the compressed
    length is less than the uncompressed length, the block is compressed. This means
    that a compressed blob may contain a mix of compressed and uncompressed
    blocks.
    
    The starting offset of each block is determined by finding the end of the
    data in the previous block and then rounding up to the nearest DWORD-aligned
    offset.

    Each block is stored as a MAIL_COMPRESS_BLOCK, just as a convenient way of
    stuffing the lengths into the byte stream. The MAIL_COMPRESS_BLOCK structure
    is never marshalled. Thus, their endianness is not properly adjusted to network
    endianness. This function will break if it is ever ported to big-endian machines.
 
Arguments:

    pOutputBuffer (OUT) - The output buffer for the uncompressed data.

    cbOutputBuffer (IN) - The size of the output buffer.

    pInputBuffer (IN)   - The input buffer which contains data blocks.

    cbInputBuffer (IN)  - The size of the input buffer.

Return Values:

    0 - Uncompression failed. The contents of pOutputBuffer are invalid and
        should be discarded.

   >0 - The size of the (successfully) uncompressed data.

--*/
{
    XpressDecodeStream      xpressStream;
    MAIL_COMPRESS_BLOCK    *pInputBlockHdr;
    BYTE                   *pOutputBlock;

    DWORD   cbInputProcessed;   /* Count of bytes from the input buffer that have been processed */
    DWORD   cbInputBlock;       /* The size of the current input block */

    DWORD   cbOutputBlock;      /* The uncompressed size of the current block */
    DWORD   cbOutputSize;       /* Amount of used space in the output buffer */
    int     result;             /* Return value of xpressDecode */

    DPRINT1(2,"XPRESS: Uncompress Start. Compressed blob size=%d\n",cbInputBuffer);

    /* Neither the input or output buffers have been touched yet. */
    cbInputProcessed = cbOutputSize = 0;

    /* Create the 'stream', which is a context for doing the uncompression */
    xpressStream = XpressDecodeCreate( NULL, xpressAlloc );
    if( !xpressStream ) {
        return 0;
    }
    
    while( cbInputProcessed<cbInputBuffer ) {
        
        /* Figure out where the next input block header will start (it must
         * be on a DWORD-aligned boundary. Check that we don't step out of
         * the input buffer. */
        cbInputProcessed = ROUND_UP_COUNT(cbInputProcessed, sizeof(DWORD));
        if( cbInputProcessed+sizeof(MAIL_COMPRESS_BLOCK) > cbInputBuffer ) {
            Assert( !"XPRESS: Stepped out of input buffer" );
            return 0;
        }
        pInputBlockHdr = (MAIL_COMPRESS_BLOCK*) &pInputBuffer[ cbInputProcessed ];
        cbInputProcessed += sizeof(MAIL_COMPRESS_BLOCK);
        cbInputBlock = pInputBlockHdr->cbCompressedSize;
        if( cbInputProcessed+cbInputBlock > cbInputBuffer ) {
            Assert( !"XPRESS: Stepped out of input buffer" );
            return 0;
        }

        /* Get a pointer to the current position in the output buffer and
         * check that we will not overflow the output buffer */
        pOutputBlock = &pOutputBuffer[ cbOutputSize ];
        cbOutputBlock = pInputBlockHdr->cbUncompressedSize;
        Assert( cbOutputBlock>=cbInputBlock );
        if( cbOutputSize+cbOutputBlock > cbOutputBuffer ) {
            Assert( !"XPRESS: Overflowed the output buffer" );
            return 0;
        }

        /* If the compressed size and uncompressed size of the input block are
         * the same, the data is not compressed. */
        if( cbInputBlock==cbOutputBlock ) {
            /* Input block is not compressed. Copy it to the output buffer as is. */
            memcpy( pOutputBlock, pInputBlockHdr->data, cbInputBlock );
        } else {
            /* Decode the current input block into the output buffer. */
            result = XpressDecode( xpressStream, pOutputBlock, cbOutputBlock,
                cbOutputBlock, pInputBlockHdr->data, cbInputBlock );
            if( result!=cbOutputBlock ) {
                Assert( !"XPRESS: XpressDecode failed" );
                return 0;
            }
        }

        cbInputProcessed += cbInputBlock;
        cbOutputSize += cbOutputBlock;
    }

    XpressDecodeClose( xpressStream, NULL, xpressFree );

    DPRINT2(2,"XPRESS: Uncompress End. Compressed blob size=%d, "
              "Uncompressed blob size=%d\n",cbInputBuffer,cbOutputSize);
    return cbOutputSize;
}


ULONG
draCompressBlobXpress(
    OUT BYTE *  pOutputBuffer,
    IN  ULONG   cbOutputBuffer,
    IN  BYTE *  pInputBuffer,
    IN  ULONG   cbInputBuffer
    )
/*++

Routine Description:

    Compress the data in pInputBuffer using the Xpress compression library.

    Divide the data in the pInputBuffer buffer into blocks.
    For each block
        Add a block-header header to the pOutputBuffer buffer
        Compress the block.
        If the compressed succeeded
            Add the compressed block to the pOutputBuffer buffer
        Else
            Add the uncompressed block to the pOutputBuffer buffer
    End For

    If the resulting compressed blob is larger than the uncompressed blob, the
    compressed blob is discarded and an uncompressed message is sent instead.

    For a description of the compressed blob, see draUncompressBlobXpress().

Arguments:

    pOutputBuffer (OUT) - The output buffer for output data blocks.

    cbOutputBuffer (IN) - The size of the output buffer.

    pInputBuffer (IN)   - The original, uncompressed input buffer.

    cbInputBuffer (IN)  - The size of the original, uncompressed data.

Return Values:

    0 - Either a catastrophic compression failure occurred, or the
        data didn't fit into the pOutputBuffer buffer. The contents
        of the pOutputBuffer are not valid and should be discarded.

   >0 - The size of the successfully compressed data, which is now
        stored in pOutputBuffer.

--*/
{
    XpressEncodeStream      xpressStream;
    MAIL_COMPRESS_BLOCK    *pOutputBlockHdr;
    BYTE*                   pInputBlock;

    DWORD   cbInputBlockMax;    /* The maximum size of a block of input data */
    DWORD   cbInputProcessed;   /* Count of bytes from the input buffer that have been processed */
    DWORD   cbInputBlock;       /* The size of the current input block */

    DWORD   cbOutputBlockMax;   /* The maximum available size for the current output block */
    DWORD   cbOutputSize;       /* Amount of used space in the output buffer */
    DWORD   cbCompBlock;        /* The size of the current compressed block */

    DPRINT1(2,"XPRESS: Compress Start. Uncompressed blob size=%d\n",cbInputBuffer);

    /* This is the maximum input block size that Xpress can handle */
    cbInputBlockMax = XPRESS_MAX_BLOCK;

    /* Neither the input or output buffers have been touched yet. */
    cbInputProcessed = cbOutputSize = 0;

    /* Create the 'stream', which is a context for doing the compression */
    xpressStream = XpressEncodeCreate( cbInputBlockMax, NULL, xpressAlloc, GetCompressionLevel() );
    if( !xpressStream ) {
        return 0;
    }

    while( cbInputProcessed<cbInputBuffer ) {

        /* Get a pointer to the current position in the input buffer and determine
         * the size of the current input block. */
        pInputBlock = &pInputBuffer[ cbInputProcessed ];
        cbInputBlock = DWORDMIN( cbInputBlockMax, cbInputBuffer-cbInputProcessed );

        /* Figure out where the next output block header will start (it must
         * be on a DWORD-aligned boundary). */
        cbOutputSize = ROUND_UP_COUNT(cbOutputSize, sizeof(DWORD));
        pOutputBlockHdr = (MAIL_COMPRESS_BLOCK*) &pOutputBuffer[ cbOutputSize ];

        /* Check that we have not exceeded the bounds of the buffer. */
        cbOutputSize += sizeof(MAIL_COMPRESS_BLOCK);
        if( cbOutputSize>cbOutputBuffer ) {
            return 0;
        }
        
        /* Determine the maximum space available for the the output block. */
        cbOutputBlockMax = cbOutputBuffer-cbOutputSize;

        /* Ensure buffers are DWORD-aligned */
        Assert( POINTER_IS_ALIGNED(pInputBlock,sizeof(DWORD)) );
        Assert( POINTER_IS_ALIGNED(pOutputBlockHdr->data,sizeof(DWORD)) );

        /* Encode a block of the input data into the output buffer. */
        cbCompBlock = XpressEncode( xpressStream, pOutputBlockHdr->data, cbOutputBlockMax,
            pInputBlock, cbInputBlock, NULL, NULL, 0 );
        if( !cbCompBlock ) {
            Assert( !"XPRESS: XpressEncode failed" );
            return 0;
        }

        if( cbCompBlock>=cbInputBlock ) {
            /* The size of the compressed block is no smaller than the size of
             * the uncompressed block (i.e. data was not compressed at all). We
             * copy the original, uncompressed data to the output buffer instead. */

            /* Check that we will not overflow the output buffer */
            if( cbInputBlock>cbOutputBlockMax ) {
                return 0;
            }
            memcpy( pOutputBlockHdr->data, pInputBlock, cbInputBlock );
            cbCompBlock = cbInputBlock;
        }
        cbInputProcessed += cbInputBlock;
        cbOutputSize += cbCompBlock;

        /* Update the fields in the output block header. */
        pOutputBlockHdr->cbUncompressedSize = cbInputBlock;
        pOutputBlockHdr->cbCompressedSize = cbCompBlock;
    }

    XpressEncodeClose( xpressStream, NULL, xpressFree );
    
    if( cbOutputSize < cbInputBuffer ) {
        /* Data successfully compressed and is smaller than input buffer */
        #ifdef DBG
        {
            ULONG result;
            BYTE* scratch;

            /* Decompress and check the data into a scratch buffer to check our code.
             * Decompression is about 4 times faster than compression so this shouldn't
             * be a big performance hit. */
            scratch = THAlloc(cbInputBuffer);
            result = draUncompressBlobXpress(scratch,cbInputBuffer,pOutputBuffer,cbOutputSize);
            Assert( result==cbInputBuffer );
            Assert( 0==memcmp(scratch,pInputBuffer,cbInputBuffer) );
            THFree(scratch);
        }
        #endif

        DPRINT2(2,"XPRESS: Compress End. Uncompressed blob size=%d, "
                  "Compressed blob size=%d\n",cbInputBuffer,cbOutputSize);
        return cbOutputSize;
    }

    /* Failure. The output data was bigger than the input data. */
    DPRINT1(0,"XPRESS: Failed to compress blob. Uncompressed blob size=%d\n",
            cbInputBuffer);
    return 0;
}

/*
 * Simple wrappers around THAlloc for use by Chunky[De]Compression below
 */

void * __cdecl zipAlloc(ULONG cb) {
    return THAlloc(cb);
}

void __cdecl zipFree(VOID *buff) {
    THFree(buff);
}

ULONG
draCompressBlobMszip(
    OUT BYTE *  pCompBuff,
    IN  ULONG   CompSize,
    IN  BYTE *  pUncompBuff,
    IN  ULONG   UncompSize
    )
/*++

Routine Description:

    Compress using mszip style compression.

    BUGBUG: Contains embedded ULONGS in the Data byte array.  Byte
    flipping will be a problem in other-endian machines.

Arguments:

    pCompBuff (OUT) - Buffer to hold compressed data.

    CompSize (IN) - Size of buffer to hold compressed data.

    pUncompBuff (IN) - Uncompressed data.

    UncompSize (IN) - Size of uncompressed data.

Return Values:

    0 - Buffer not compressed (compression failure or compressed buffer
        was bigger than original buffer).

    > 0 - Size of (successfully) compressed data.

--*/
{
    MCI_CONTEXT_HANDLE    mciHandle;
    MAIL_COMPRESS_BLOCK * pCompressedData;  // better data type for pCompBuff

    ULONG cbCompressed = 0; /* how much of pCompBuff used?             */
    ULONG cbInChunk;        /* how much to compress at a time.         */
    ULONG cbOutChunk;       /* how much it was compressed to.          */
    UINT  cbInChunkMax;     /* how big a chunk can we give?            */
    UINT  cbOutChunkMax;    /* how big a chunk can we get?             */
    ULONG OriginalSize = UncompSize;

    cbInChunkMax = MSZIP_MAX_BLOCK;

    if(MCICreateCompression(&cbInChunkMax,
                            zipAlloc,
                            zipFree,
                            &cbOutChunkMax,
                            &mciHandle)) {
        /* couldn't create a compression context.  bag it and go home */
        return 0;
    }

    /* pad the size of the max out chunk to be on a ULONG boundary, since
     * we will be padding the data stream below.
     */
    cbOutChunkMax = ROUND_UP_COUNT(cbOutChunkMax, sizeof(ULONG));

    pCompressedData = (MAIL_COMPRESS_BLOCK *) pCompBuff;

    while(UncompSize) {

        cbInChunk = min(UncompSize, cbInChunkMax);

        if((cbOutChunkMax +sizeof(MAIL_COMPRESS_BLOCK)) >  /* Max to write. */
           (CompSize - cbCompressed)) {                    /* Space left    */
            /* Space is tight.  While it is still technically possible that
             * compression could end up with smaller data, we are close
             * enough to filling our buffer that we MIGHT overfill it
             * during this chunk.  So, bag it and go home.
             */
            MCIDestroyCompression(mciHandle);
            return 0;
        }

        pCompressedData->cbUncompressedSize = cbInChunk;

        if(MCICompress(mciHandle,
                       pUncompBuff,
                       cbInChunk,
                       pCompressedData->data,
                       cbOutChunkMax,
                       &cbOutChunk)) {
            /* Something went wrong */
            MCIDestroyCompression(mciHandle);
            return 0;
        }


        pCompressedData->cbCompressedSize = cbOutChunk;


        /* Pad size to ULONG boundary, possibly making cbInChunk ==
         * cbOutChunk.  Oh well. We still have space to write it.
         */

        cbOutChunk = ROUND_UP_COUNT(cbOutChunk, sizeof(ULONG));

        cbCompressed += cbOutChunk + sizeof(MAIL_COMPRESS_BLOCK);
        pCompressedData =
            (MAIL_COMPRESS_BLOCK *) &pCompressedData->data[cbOutChunk];

        pUncompBuff = &pUncompBuff[cbInChunk];
        UncompSize -= cbInChunk;
    }

    MCIDestroyCompression(mciHandle);
    return ((cbCompressed < OriginalSize)? cbCompressed : 0);
}


ULONG
draUncompressBlobMszip(
    IN  THSTATE *   pTHS,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    )
/*++

Routine Description:

    Uncompress data previously compressed by draCompressBlobMszip().

Arguments:

    pUncompBuff (OUT) - Buffer to hold uncompressed data.

    cbUncomp (IN) - Size of buffer to hold uncompressed data.

    pCompBuff (IN) - Compressed data.

    cbCompBuff (IN) - Size of compressed data.

Return Values:

    0 - Uncompress failed.

    > 0 - Size of (successfully) uncompressed data.

--*/
{
    MDI_CONTEXT_HANDLE    mdiHandle;
    MAIL_COMPRESS_BLOCK * pCompressedData;  // better data type for pCompBuff

    ULONG cbUncompressed = 0; /* how much of pUncompBuff used?           */
    ULONG cbInChunk;          /* how much to decompress at a time.       */
    ULONG cbOutChunk;         /* how much it was decompressed to.        */
    UINT  cbInChunkMax;       /* how big a chunk can we give?            */
    UINT  cbOutChunkMax;      /* how big a chunk can we get?             */
    int   rc;
    BYTE  *pbDecompScratch;   /* decompression must be done into the same
                               * buffer for multiple block decompression,
                               * as state info is picked up out of the last
                               * decompression pass
                               */

    cbOutChunkMax = MSZIP_MAX_BLOCK;

    pCompressedData = (MAIL_COMPRESS_BLOCK *) pCompBuff;

    if(MDICreateDecompression(&cbOutChunkMax,
                              zipAlloc,
                              zipFree,
                              &cbInChunkMax,
                              &mdiHandle)) {
        /* couldn't create a compression context.  bag it and go home */
        return 0;
    }
    pbDecompScratch = THAllocEx(pTHS, MSZIP_MAX_BLOCK);

    while(cbCompBuff) {
        /* NOTE: remember we padded the compressed data to ULONG boundary,
         */

        cbOutChunk = pCompressedData->cbUncompressedSize;

        rc = MDIDecompress(mdiHandle,
                           pCompressedData->data,
                           pCompressedData->cbCompressedSize,
                           pbDecompScratch,
                           &cbOutChunk);

        if(rc || (cbOutChunk != pCompressedData->cbUncompressedSize)) {
            /* something went wrong */
            MDIDestroyDecompression(mdiHandle);
            THFreeEx(pTHS, pbDecompScratch);
            return 0;
        }


        memcpy(pUncompBuff, pbDecompScratch, cbOutChunk);

        /* move compressed data pointer forward to next data chunk,
         * which we do by taking the size of the compressed data and
         * rounding up to the nearest ULONG boundary and moving forward
         * that much (just like we did when we built this in
         * chunkycompressionZip above).
         */

        cbInChunk = ROUND_UP_COUNT(pCompressedData->cbCompressedSize,
                                   sizeof(ULONG));

        pCompressedData = (MAIL_COMPRESS_BLOCK *)
            &pCompressedData->data[cbInChunk];

        cbCompBuff -= cbInChunk + sizeof(MAIL_COMPRESS_BLOCK);

        pUncompBuff = &pUncompBuff[cbOutChunk];

        cbUncompressed += cbOutChunk;
    }

    THFreeEx(pTHS, pbDecompScratch);
    MDIDestroyDecompression(mdiHandle);

    return cbUncompressed;
}


ULONG
draCompressBlobDispatch(
    OUT BYTE               *pCompBuff,
    IN  ULONG               CompSize,
    IN  DRS_EXTENSIONS     *pExt,          OPTIONAL
    IN  BYTE               *pUncompBuff,
    IN  ULONG               UncompSize,
    OUT DRS_COMP_ALG_TYPE  *CompressionAlg
    )
/*++

Routine Description:

    Chooses a compression algorithm and uses it to compresses the reply message
    in the pUncompBuff buffer. The selected algorithm is returned in CompressionAlg.

    In debug mode, this function will randomly select an algorithm from the available
    algorithms.
    
Arguments:

    pCompBuff (OUT)      - Buffer to hold compressed data.

    CompSize (IN)        - Size of compressed data buffer.

    pExt (IN)            - Extension bits indicating the capabilities of the remote system.
                           This may be NULL if the extensions are unavailable.
    
    pUncompBuff (IN)     - Buffer containing the uncompressed data.

    UncompSize (IN)      - Size of uncompressed data.

    CompressionAlg (OUT) - The compression algorithm selected to compress this buffer.

Return Values:

    0 - Buffer not compressed (compression failure or compressed buffer
        was bigger than original buffer).

    > 0 - Size of (successfully) compressed data.

--*/
{
    DRS_COMP_ALG_TYPE   SelectedAlg = DRS_COMP_ALG_MSZIP;
    ULONG               cbCompressedReply;

    /* Choose the compression algorithm to use */
    if(   NULL!=pExt
       && IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V7)
       && IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_XPRESS_COMPRESSION) )
    {
        /* Note that SMTP-based replication using Xpress does not actually
         * require use of GETCHGREPLY_V7 packets since the SMTP mail format
         * provides a field to specify the compression type. In actuality
         * this is a moot point because all DCs that support Xpress will
         * also support the V7 packets. */
        SelectedAlg = DRS_COMP_ALG_XPRESS;

#ifdef DBG
        {
            /* On debug builds, randomly try different compression algorithms */
            int r=rand()%100;
            if( r<10 ) {
                SelectedAlg = DRS_COMP_ALG_NONE;
            } else if( r<25 ) {
                SelectedAlg = DRS_COMP_ALG_MSZIP;
            }
        }
#else
        /* On free builds, don't bother to compress small messages */
        if( UncompSize<MIN_COMPRESS_SIZE ) {
            SelectedAlg = DRS_COMP_ALG_NONE;
        }
#endif
    }

    /* Call the selected compression function */
    switch( SelectedAlg ) {
        case DRS_COMP_ALG_NONE:
            Assert( CompSize>=UncompSize );
            memcpy( pCompBuff, pUncompBuff, UncompSize );
            cbCompressedReply = UncompSize;
            break;
        case DRS_COMP_ALG_MSZIP:
            cbCompressedReply = draCompressBlobMszip(
                pCompBuff, CompSize,
                pUncompBuff, UncompSize);
            break;
        case DRS_COMP_ALG_XPRESS:
            cbCompressedReply = draCompressBlobXpress(
                pCompBuff, CompSize,
                pUncompBuff, UncompSize);
            break;
        default:
            Assert( !"Invalid algorithm selection in draCompressBlobDispatch" );
    }
    *CompressionAlg = SelectedAlg;

    return cbCompressedReply;
}


ULONG
draUncompressBlobDispatch(
    IN  THSTATE *   pTHS,
    IN  DRS_COMP_ALG_TYPE CompressionAlg,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    )
/*++

Routine Description:

    Uncompress data in pCompBuff using the algorithm specified by
    CompressionAlg. This function just acts as a dispatcher and calls
    the appropriate decompression function.

Arguments:

    pTHS - The thread-state structure.
    
    CompressionAlg - The algorithm used to compress the data.

    pUncompBuff (OUT) - Buffer to hold uncompressed data.

    cbUncomp (IN) - Size of buffer to hold uncompressed data.

    pCompBuff (IN) - Compressed data.

    cbCompBuff (IN) - Size of compressed data.
    
Return Values:

    0 - Uncompress failed.

    > 0 - Size of (successfully) uncompressed data.

--*/
{
    DWORD cbActualUncompressedSize;

    switch( CompressionAlg ) {
        case DRS_COMP_ALG_NONE:
        	Assert( cbUncomp>=cbCompBuff );
        	memcpy(pUncompBuff, pCompBuff, cbCompBuff);
            cbActualUncompressedSize = cbCompBuff;
            break;
        case DRS_COMP_ALG_MRCF:
            Assert( !"MRCF compression is obsolete and unsupported!" );
            return 0;
        case DRS_COMP_ALG_MSZIP:
            cbActualUncompressedSize = draUncompressBlobMszip(pTHS,
                pUncompBuff, cbUncomp,
                pCompBuff, cbCompBuff);
            break;
        case DRS_COMP_ALG_XPRESS:
            cbActualUncompressedSize = draUncompressBlobXpress(
                pUncompBuff, cbUncomp,
                pCompBuff, cbCompBuff);
            break;
        default:
            Assert( !"Unknown compression algorithm!" );
            DRA_EXCEPT(ERROR_INVALID_PARAMETER, CompressionAlg );
            return 0;
    }

    return cbActualUncompressedSize;
}


BOOL
draCompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppCmprsMailRepMsg,
    OUT DRS_COMP_ALG_TYPE *pCompressionAlg
    )
/*++

Routine Description:

    Try to compress the message in pMailRepMsg.
    
    If the message was successfully compressed
        ppCmprsMailRepMsg contains a pointer to the new, compressed message.
        pCompressionAlg indicates the compression algorithm used.
    Else
        ppCmpsMailRepMsg is set to NULL.
        pCompressionAlg is unmodified.

Arguments:

    pTHS - The thread-state structure.

Notes:
    
    This code is aware of variable length headers.

Return value:

    TRUE - Message was successfully compressed
    FALSE - Message was not compressed
    
--*/

{
    MAIL_REP_MSG *  pCmprsMailRepMsg = NULL;
    DWORD           cbCmprsMailRepMsg;
    ULONG           cbCompressedSize;
    PCHAR           pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pMailRepMsg));
    
    if( pMailRepMsg->cbDataSize > MIN_COMPRESS_SIZE ) {
        
        cbCmprsMailRepMsg = MAIL_REP_MSG_SIZE(pMailRepMsg) + sizeof(MAIL_COMPRESS_BLOCK);
        pCmprsMailRepMsg = THAllocEx(pTHS, cbCmprsMailRepMsg);

        // Copy all but message data.
        memcpy(pCmprsMailRepMsg, pMailRepMsg, pMailRepMsg->cbDataOffset);

    	pbDataIn = MAIL_REP_MSG_DATA(pMailRepMsg);
        pbDataOut = MAIL_REP_MSG_DATA(pCmprsMailRepMsg);

        /* Compress Message */
        cbCompressedSize = draCompressBlobDispatch(
            pbDataOut, sizeof(MAIL_COMPRESS_BLOCK)+pMailRepMsg->cbDataSize,
            pTHS->pextRemote,
            pbDataIn, pMailRepMsg->cbDataSize,
            pCompressionAlg);

        if (cbCompressedSize) {
            // Data is compressible and has been compressed.
            pCmprsMailRepMsg->cbDataSize = cbCompressedSize;
            pCmprsMailRepMsg->dwMsgType |= MRM_MSG_COMPRESSED;
            pCmprsMailRepMsg->cbUncompressedDataSize = pMailRepMsg->cbDataSize;

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_MAIL_COMPRESSED,
                     szInsertUL(pCmprsMailRepMsg->cbUncompressedDataSize),
                     szInsertUL(pCmprsMailRepMsg->cbDataSize),
                     NULL);
        }
        else {
            THFreeEx(pTHS, pCmprsMailRepMsg);
            pCmprsMailRepMsg = NULL;
        }
    }

    *ppCmprsMailRepMsg = pCmprsMailRepMsg;

    return (NULL != pCmprsMailRepMsg);
}


void
draUncompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppUncompressedMailRepMsg
    )
{
    MAIL_REP_MSG *  pUncompressedMailRepMsg = NULL;
    DWORD           cbUncompressedDataSize;

    Assert(pMailRepMsg->dwMsgType & MRM_MSG_COMPRESSED);
    Assert(NULL != MAIL_REP_MSG_DATA(pMailRepMsg));
    Assert(   pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_NONE
           || pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_MSZIP
           || pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_XPRESS );

    pUncompressedMailRepMsg = THAllocEx(pTHS,
                                        pMailRepMsg->cbDataOffset
                                        + pMailRepMsg->cbUncompressedDataSize);
    // Copy all but message data.
    memcpy(pUncompressedMailRepMsg, pMailRepMsg, pMailRepMsg->cbDataOffset);

    cbUncompressedDataSize =
        draUncompressBlobDispatch(pTHS,
                          (DRS_COMP_ALG_TYPE) pMailRepMsg->CompressionVersionCaller,
                          MAIL_REP_MSG_DATA(pUncompressedMailRepMsg),
                          pMailRepMsg->cbUncompressedDataSize,
                          MAIL_REP_MSG_DATA(pMailRepMsg),
                          pMailRepMsg->cbDataSize);

    if (cbUncompressedDataSize != pMailRepMsg->cbUncompressedDataSize) {
        // Decompression ended up with a different count of bytes. Log error and
        // discard message.
        LogAndAlertEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_DRA_INCOMPAT_MAIL_MSG_C,
                         NULL,
                         NULL,
                         NULL);
        DRA_EXCEPT(ERROR_BAD_LENGTH, 0);
    }

    // Message uncompressed successfully.  Substitute uncompressed message for
    // compressed message.
    pUncompressedMailRepMsg->dwMsgType &= ~MRM_MSG_COMPRESSED;
    pUncompressedMailRepMsg->cbDataSize = cbUncompressedDataSize;

    *ppUncompressedMailRepMsg = pUncompressedMailRepMsg;
}


MTX_ADDR *
draGetTransportAddress(
    IN OUT  DBPOS *   pDB,          OPTIONAL
    IN      DSNAME *  pDSADN,
    IN      ATTRTYP   attAddress
    )
/*++

Routine Description:

    Reads the transport-specific address associated with a particular ntdsDsa
    object.

Arguments:

    pDB (IN/OUT) - Required only if attAddress != ATT_DNS_HOST_NAME.

    pDSADN (IN) - ntdsDsa for which we want to get the address.

    attAddress (IN) - Attribute of the CLASS_SERVER object holding the address
        for the requested transport.

Return Values:

    A pointer to the thread-allocated MTX_ADDR for the given ntdsDsa.

    Throws a DRA exception if the transport-specific address
    attribute is not present on the ntdsDsa's parent server object.

    This can occur under normal circumstances when the ISM transport
    removes this attribute to indicate that the transport is no longer
    available.  The ISM removes the attribute to notify the KCC to not
    utilize this transport. Until the KCC runs again to remove the
    source over this transport, this attribute will be found missing.

--*/
{
    THSTATE *   pTHS = pDB ? pDB->pTHS : pTHStls;
    DWORD       cb;
    DWORD       cwchAddress;
    WCHAR *     pwchAddress;
    DWORD       cachAddress;
    MTX_ADDR *  pmtxAddress;

    Assert(!fNullUuid(&pDSADN->Guid));

    if (ATT_DNS_HOST_NAME == attAddress) {
        // No need to look this up -- we can derive it.
        pwchAddress = DSaddrFromName(pTHS, pDSADN);
        cwchAddress = wcslen(pwchAddress);
    }
    else {
        // Must derive from attribute of server object.

        // Find the server object.
        if (DBFindDSName(pDB, pDSADN) || DBFindDNT(pDB, pDB->PDNT)) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // And read the transport-specific address from it.
        if (DBGetAttVal(pDB, 1, attAddress, 0, 0, &cb, (BYTE **)&pwchAddress)) {
            DRA_EXCEPT_NOLOG (ERROR_DS_MISSING_REQUIRED_ATT, 0);
        }
        cwchAddress = cb / sizeof(WCHAR);
    }

    // Translate Unicode transport address into MTX_ADDR.
    Assert(0 != cwchAddress);
    Assert(NULL != pwchAddress);
    Assert(L'\0' != pwchAddress[cwchAddress - 1]);

    cachAddress = WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                                      NULL, 0, NULL, NULL);

    pmtxAddress = (MTX_ADDR *) THAllocEx(pTHS, MTX_TSIZE_FROM_LEN(cachAddress));
    pmtxAddress->mtx_namelen = cachAddress + 1; // includes null-term

    WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                        (CHAR *) &pmtxAddress->mtx_name[0],
                        cachAddress, NULL, NULL);
    pmtxAddress->mtx_name[cachAddress] = '\0';

    THFreeEx(pTHS, pwchAddress);

    return pmtxAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drainst.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drainst.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>			// MD local definition header
#include <dsatools.h>			// needed for output allocation
#include <dsconfig.h>

// Logging headers.
#include "dsevent.h"			/* header Audit\Alert logging */
#include "mdcodes.h"			/* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"		/* Defines for selected classes and atts*/
#include "msrpc.h"
#include <errno.h>
#include "direrr.h"        /* header for error codes */
#include "dstaskq.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAINST:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drsdra.h"
#include "drancrep.h"
#include "usn.h"


#include <fileno.h>
#define  FILENO FILENO_DRAINST

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

BOOL IsDSA(DBPOS *pDB){

   ULONG            len;
   SYNTAX_OBJECT_ID Class;
   SYNTAX_OBJECT_ID *pClass=&Class;
   ULONG            NthValIndex=0;

   DPRINT(1,"IsDSA entered\n");


   while(!DBGetAttVal(pDB,++NthValIndex, ATT_OBJECT_CLASS,
                      DBGETATTVAL_fCONSTANT, sizeof(Class),
                      &len, (UCHAR **)&pClass)){

       if (CLASS_NTDS_DSA == Class){

           DPRINT(4,"DSA Object\n");
           return TRUE;
       }
   }/*while*/

   DPRINT(4,"Not a DSA Object\n");
   return FALSE;

}/*IsDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Validate that this is an internal master DSA object. */

int ValidInternalMasterDSA(THSTATE *pTHS, DSNAME *pDSA){

   DBPOS *pDB = NULL;
   SYNTAX_INTEGER iType;
   BOOL  Deleted;

   DBOpen2(TRUE, &pDB);
   if (NULL == pDB) {
       return DB_ERR_DATABASE_ERROR;
   }
   __try {

        // make sure the object exists
        if (FindAliveDSName(pDB, pDSA)) {

            DPRINT(4,"***Couldn't locate the DSA object\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_DSA_OBJ,
                     NULL,
                     NULL,
                     NULL);
            __leave;
        }

        /* Validate that the instance type is an internal_master.  */
        
        if (DBGetSingleValue(pDB, ATT_INSTANCE_TYPE,  &iType, sizeof(iType),
                            NULL)) {
        
            DPRINT(4,"***Instance type  not found ERROR\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertDN(pDSA),
                     NULL,
                     NULL);
            pTHStls->errCode = 1;
            SetSvcError(SV_PROBLEM_DIR_ERROR,
                        DIRERR_CANT_RETRIEVE_INSTANCE);

            __leave;
        }
        else if (iType != INT_MASTER){
        
            SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                        DIRERR_DSA_MUST_BE_INT_MASTER);
            pTHStls->errCode = 1;
            __leave;
        
        }

        if (!IsDSA(pDB)){
        
            DPRINT(4,"***Object Class  not DSA\n");
            pTHStls->errCode = 1;
            SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                      DIRERR_CLASS_NOT_DSA);
            __leave;
        }

    }
    __finally
    {
        DBClose(pDB, !AbnormalTermination());
    }


    return pTHStls->errCode;

}/*Valid InternalMasterDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/* Change the DNs in all master NC's in the Anchor to reflect new DIT.
*/


int  UpdateMasterNCs(THSTATE *pTHS, DSNAME *pNewDSA)
{


   NAMING_CONTEXT_LIST       *pNCL;
   SYNTAX_DISTNAME_STRING   *pNewDSAAnchor;
   DWORD rtn = 0;
   BOOL fCommit = FALSE;

   DPRINT(1,"UpdateMasterNCs entered\n");


   /* Build new DSA name-address attribute */

   pNewDSAAnchor = malloc(DERIVE_NAME_DATA_SIZE(pNewDSA,
                                                DATAPTR(gAnchor.pDSA)));
   if(!pNewDSAAnchor) {
       SetSysErrorEx(ENOMEM, ERROR_OUTOFMEMORY,
                     DERIVE_NAME_DATA_SIZE(pNewDSA,
                                           DATAPTR(gAnchor.pDSA)));
       return ENOMEM;
   }

   BUILD_NAME_DATA(pNewDSAAnchor, pNewDSA, DATAPTR(gAnchor.pDSA));

   if (DBReplaceHiddenDSA(NAMEPTR(pNewDSAAnchor))) {

      DPRINT(4,"Hidden record not replaced...update failed\n");
      free(pNewDSAAnchor);
      LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CANT_REPLACE_HIDDEN_REC,
  	    NULL,
	    NULL,
  	    NULL);

      return SetSvcError(SV_PROBLEM_DIR_ERROR,
			 DIRERR_CANT_REPLACE_HIDDEN_REC);
   }
   free(pNewDSAAnchor);


   /* All updates are O.K. so rename the DSA in global memory */
   free(gAnchor.pDSA);
   free(gAnchor.pDSADN);
   free(gAnchor.pDomainDN);

   /* All the updates are so re-load the DSA information */
   if (rtn = InitDSAInfo()){

       LogUnhandledError(rtn);
   
       DPRINT(2,"Failed to locate and load DSA knowledge\n");
       return rtn;
   }
    
   return rtn;

}/*UpdateMasterNCs*/

int LocalRenameDSA(THSTATE *pTHS, DSNAME *pNewDSA)
		   
{
    int err = 0;
   
    /* The order of these validations are important */

    if ( (err=ValidInternalMasterDSA(pTHS, pNewDSA))
     ||  (err=UpdateMasterNCs(pTHS, pNewDSA))
     ||  (err=BuildRefCache()) ) {
    
      DPRINT1(4," DSA Rename failed (%u)\n", err);

    }

    if (!err)
        err = pTHS->errCode;

   return (err);  /*in case we have an attribute error*/

}/* LocalRenameDSA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drancadd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drancadd.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to add a replica of a naming context from a given source DSA.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>            // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation

#include <dnsapi.h>             // for dns validation routines

// Logging headers.
#include "dsevent.h"            /* header Audit\Alert logging */
#include "mdcodes.h"            /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"             /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include "debug.h"              /* standard debugging header */
#define DEBSUB "DRANCADD:"      /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drasch.h"
#include "drauptod.h"


#include <fileno.h>
#define  FILENO FILENO_DRANCADD


ULONG
DRA_ReplicaAdd(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  MTX_ADDR *  pmtx_addr,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Add inbound replication of an NC (which may or may not already exist
    locally) from a given source DSA.

Arguments:

    pTHS (IN) - Thread state.

    pNC (IN) - NC for which to add the replica.  The NC record must exist
        locally as either an object (instantiated or not) or a reference
        phantom (i.e., a phantom with a guid).

    pSourceDsaDN (IN, OPTIONAL) - DN of the source DSA's ntdsDsa object.
        Required if ulOptions includes DRS_ASYNC_REP; ignored otherwise.

    pTransportDN (IN, OPTIONAL) - DN of the interSiteTransport object
        representing the transport by which to communicate with the source
        server.  Required if ulOptions includes DRS_MAIL_REP; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pszSourceDsaDnsDomainName (IN, OPTIONAL) - DNS domain name of the source
        server.  If pszSourceDsaAddress is not a GUID-based DNS name for an
        ntdsDsa object that is present on the local machine, this parameter
        is required if the caller wants mutual authentication.

    preptimesSync (IN, OPTIONAL) - Schedule by which to replicate the NC from
        this source in the future.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_WRIT_REP
            Create a writeable replica.  Otherwise, read-only.
        DRS_MAIL_REP
            Sync from the source DSA via mail (i.e., an ISM transport) rather
            than RPC.
        DRS_ASYNC_REP
            Don't replicate the NC now -- just save enough state such that we
            know to replicate it later.
        DRS_INIT_SYNC
            Sync the NC from this source when the DSA is started.
        DRS_PER_SYNC
            Sync the NC from this source periodically, as defined by the
            schedule passed in the preptimesSync argument.
        DRS_CRITICAL_ONLY
            Sync only the critical objects now
        DRS_DISABLE_AUTO_SYNC
            Disable notification-based synchronization for the NC from this
            source.  (Synchronization can be forced by using the DRS_SYNC_FORCED
            bit in the sync request options.)
        DRS_DISABLE_PERIODIC_SYNC
            Disable periodic synchronization for the NC from this source.
            (Synchronization can be forced by using the DRS_SYNC_FORCED bit in
            the sync request options.)
        DRS_USE_COMPRESSION
            Replication messaged along this link should be compressed when
            possible.
        DRS_NEVER_NOTIFY
            Do not use notifications for this link.  Syncs must be triggered
            manually (i.e., by calling DsReplicaSync()) or by the periodic
            schedule.

Return Values:

    0 - Success.
    DRSERR_* - Failure.

--*/
{
    DBPOS *                 pDB;
    ULONG                   ret;
    SYNTAX_INTEGER          it;
    BOOL                    fHasRepsFrom = FALSE;
    REPLICA_LINK *          pVal;
    ULONG                   len;
    UUID                    uuidDsaObj;
    UUID                    uuidTransportObj;
    ULONG                   ulSyncFailure = 0;
    PARTIAL_ATTR_VECTOR *   pPartialAttrVec = NULL;
    DB_ERR                  dbFindErr;
    ATTCACHE *              pAC;
    CLASSCACHE *            pCC;
    ATTRTYP                 objClass;
    DSNAME *                pCat;
    ULONG                   dntNC = 0;
    SCHEMAPTR *             pSchema = NULL;
    UPTODATE_VECTOR *       pUpToDateVec = NULL;

    // Log parameters.
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_DRA_REPLICAADD_ENTRY,
             szInsertWC(pNC->StringName),
             szInsertSz(pmtx_addr->mtx_name),
             szInsertHex(ulOptions));

    // pmtx_addr must be aligned properly (just like everything else).
    Assert(0 == ((UINT_PTR) pmtx_addr) % sizeof(ULONG));

    // Code below assumes we don't add replicas asynchronously during install.
    Assert(!((ulOptions & DRS_ASYNC_REP) && DsaIsInstalling()));

    // Critical only is only allowed while installing
    if ( (ulOptions & DRS_CRITICAL_ONLY) && (!DsaIsInstalling()) ) {
        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    // Can't replicate from self!
    if ( (!DsaIsInstalling()) && (MtxSame( pmtx_addr, gAnchor.pmtxDSA )) ) {
        DRA_EXCEPT(ERROR_DS_CLIENT_LOOP, 0);
    }

    // Give initial values
    memset( &uuidDsaObj, 0, sizeof( UUID ) );
    memset( &uuidTransportObj, 0, sizeof( UUID ) );

    BeginDraTransaction(SYNC_WRITE);
    pDB = pTHS->pDB;

    __try {
        if (DRS_MAIL_REP & ulOptions) {
            // Verify the transport DN is valid.
            if ((NULL == pTransportDN)
                || DBFindDSName(pDB, pTransportDN)
                || DBIsObjDeleted(pDB)) {
                // Transport DN is invalid.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (fNullUuid(&pTransportDN->Guid)) {
                // Get the objectGuid of the transport object.
                GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &uuidTransportObj,
                                  sizeof(uuidTransportObj));
            }
            else {
                uuidTransportObj = pTransportDN->Guid;
            }
        }

        if (DRS_ASYNC_REP & ulOptions) {
            // Verify we already have a copy of the source DSA's ntdsDsa object.
            if ((NULL == pSourceDsaDN)
                || DBFindDSName(pDB, pSourceDsaDN)
                || DBIsObjDeleted(pDB)) {
                // Source DSA DN is invalid.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (fNullUuid(&pSourceDsaDN->Guid)) {
                // Get the objectGuid of the source DSA object.
                GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &uuidDsaObj,
                                  sizeof(uuidDsaObj));
            }
            else {
                uuidDsaObj = pSourceDsaDN->Guid;
            }
            if (memcmp( &uuidDsaObj, &(gAnchor.pDSADN->Guid), sizeof(UUID) ) == 0) {
                // Can't replicate from self!
                // Source DSA DN is invalid.
                DRA_EXCEPT(ERROR_DS_CLIENT_LOOP, 0);
            }
        }

        // Does the NC record exist?
        dbFindErr = DBFindDSName(pDB, pNC);

        switch (dbFindErr) {
        case DIRERR_OBJ_NOT_FOUND:
            // NC record exists neither as a phantom nor an object.  This
            // implies that we have no cross-ref for this NC.  Allowed only
            // during install.
            if (!DsaIsInstalling()) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
            Assert(NULL == pUpToDateVec);
            break;

        case DIRERR_NOT_AN_OBJECT:
            // NC record exists as a phantom.
            if (!DsaIsInstalling()) {
                if (!DBHasValues(pDB, ATT_OBJECT_GUID)) {
                    // But it's a structural phantom (i.e., it has no guid).
                    // Allowed only during install.
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                } else if ((DRS_WRIT_REP & ulOptions) && !fIsNDNC(pNC)) {
                    // You can add new writeable config/schema/domain NCs only
                    // during install.  (You can add new replication partners
                    // for a read-only or writeable NC anytime, but you can't
                    // make an installed DC a master replica of an NC that it
                    // didn't master before unless the NC is an NDNC.)
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                }
            }
            Assert(NULL == pUpToDateVec);
            break;

        case 0:
            // The NC prefix object already exists.  This is fine as long as:
            //
            // (1) the NC is not deleted (should never happen),
            // (2) the "writeable" flag in the options argument and the
            //     object's instance type are compatible,
            // (3) we don't already replicate this NC from the specified
            //     source, and
            // (4) the existing NC is not in the process of being removed
            //     (which would also imply it is a read-only replica).

            if (DBIsObjDeleted(pDB)) {
                // NC object is deleted.
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }

            GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

            if (!(it & IT_UNINSTANT)
                && (!(it & IT_WRITE) != !(ulOptions & DRS_WRIT_REP))) {
                // "Is writeable" option does not match the "is writeable" bit
                // in the pre-existing object's instance type.
                DRA_EXCEPT(DRAERR_BadInstanceType, it);
            }

            if (it & IT_UNINSTANT) {
                // NC is not yet instantiated.
                Assert(!(it & IT_NC_GOING));
                Assert(!DBHasValues(pDB, ATT_REPS_FROM));
                Assert(NULL == pUpToDateVec);

                if ((DRS_WRIT_REP & ulOptions)
                    && !DsaIsInstalling()
                    && !fIsNDNC(pNC)) {
                    // You can add new writeable config/schema/domain NCs only
                    // during install.  (You can add new replication partners
                    // for a read-only or writeable NC anytime, but you can't
                    // make an installed DC a master replica of an NC that it
                    // didn't master before unless the NC is an NDNC.)
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                }
            } else {
                // NC is already instantiated.

                if (it & IT_NC_GOING) {
                    // This NC has been partially removed (i.e., we
                    // encountered an error while removing the NC previously);
                    // can't readd it until it is completely removed.

                    // The primary reason this is here is to prevent weird
                    // interactions with the SD propagator.  If an NC is
                    // partially removed, it may well be that we have removed
                    // an object's parent but not the object itself, which would
                    // mean if the SD propagator were in the middle of a
                    // propagation it would not propagate ACL changes to this
                    // object.  If we allowed the parent to be re-added without
                    // first removing the child, an SD propagation would not be
                    // requeued, and the child would never inherit the proper
                    // ACLs.

                    // This is a rare case, but so is demoting and re-promoting
                    // a GC in quick succession (a prerequisite for this
                    // exception), and ACL discrepancies are Bad.
                    DRA_EXCEPT(DRAERR_NoReplica, 0);
                }

                if (!FindDSAinRepAtt(pDB, ATT_REPS_FROM, DRS_FIND_DSA_BY_ADDRESS,
                                     NULL, pmtx_addr, &fHasRepsFrom, &pVal,
                                     &len)) {
                    // We already have a replica from this source.
                    DRA_EXCEPT(DRAERR_DNExists, 0);
                }

                // Get current UTD vector.
                UpToDateVec_Read(pDB,
                                 it,
                                 UTODVEC_fUpdateLocalCursor,
                                 DBGetHighestCommittedUSN(),
                                 &pUpToDateVec);
            }
            break;

        default:
            // Poorly constructed pNC parameter?
            DRA_EXCEPT(DRAERR_InvalidParameter, dbFindErr);
        }

        if (DIRERR_OBJ_NOT_FOUND != dbFindErr) {
            dntNC = pDB->DNT;
            DBFillGuidAndSid(pDB, pNC);
        }

        if (!(ulOptions & DRS_WRIT_REP)) {
            // request is to add a read-only replica - need to send the partial
            // attribute vector

            // Add a reference to the current schema to ensure our partial
            // attribute vector remains valid until we're done with it.
            pSchema = (SCHEMAPTR *) pTHS->CurrSchemaPtr;
            InterlockedIncrement(&pSchema->RefCount);

            if (!GC_ReadPartialAttributeSet(pNC, &pPartialAttrVec) ||
                !pPartialAttrVec)
            {
                // Unable to read the partial attribute set on the NCHead.
                // Or it isn't there.
                // try to get it from the schema cache.
                pPartialAttrVec = pSchema->pPartialAttrVec;
            }

            // Assert: we should always have it at this point
            Assert(pPartialAttrVec);

            if (0 == dbFindErr) {
                GC_ProcessPartialAttributeSetChanges(pTHS, pNC, &uuidDsaObj);

                // Restore our cursor if it was moved.
                if ((0 != dntNC) && (pDB->DNT != dntNC)) {
                    DBFindDNT(pDB, dntNC);
                }
            }
        }

        if ((ulOptions & DRS_ASYNC_REP) && (ulOptions & DRS_MAIL_REP)) {
            // Don't replicate anything now -- just save enough state such that
            // we know to replicate it later.

            if (DIRERR_NOT_AN_OBJECT == dbFindErr) {
                // We're going to create a new NC.  Either there's no NC above
                // it or we haven't yet replicated the subref from that NC.
                // If we do indeed hold the NC above this one,
                // AddPlaceholderNC() will conveniently OR in the IT_NC_ABOVE
                // bit.
                it = (DRS_WRIT_REP & ulOptions) ? NC_MASTER : NC_FULL_REPLICA;
            }
            else {
                Assert(0 == dbFindErr);

                if (IT_UNINSTANT & it) {
                    // A pure subref already exists for this NC.  It could be an
                    // auto-generated subref (with a class of CLASS_TOP, etc.)
                    // or a snapshot of the real NC head at some point in time.
                    // We want to make sure that the placeholder NC is not valid
                    // for user modifications, which is ensured only if it's an
                    // auto-generated subref.
                    //
                    // For consistency, we'll phantomize whatever subref we have
                    // and create a fresh placeholder NC in its place.

                    // A side-effect is that here we're removing all repsFrom
                    // values.  If the KCC added multiple repsFroms for this as
                    // yet uninstantiated NC, when we're done there will be but
                    // one -- the one corresponding to the source we're using
                    // now.  The KCC will re-add the repsFroms in 15 minutes so
                    // this isn't really an issue.

                    Assert(pDB->DNT == dntNC);
                    ret = DeleteLocalObj(pTHS, pNC, TRUE, TRUE, NULL);
                    if (ret) {
                        DRA_EXCEPT(DRAERR_InternalError, ret);
                    }

                    dbFindErr = DIRERR_NOT_AN_OBJECT;

                    // Calculate the instance type we should place on the NC.
                    // We're going to instantiate it, so strip the
                    // uninstantiated bit and add the writeable bit if
                    // appropriate.
                    it &= ~IT_UNINSTANT;
                    if (DRS_WRIT_REP & ulOptions) {
                        it |= IT_WRITE;
                    }
                }
            }

            if (DIRERR_NOT_AN_OBJECT == dbFindErr) {
                // No object exists for us to add a repsFrom to -- we do
                // have a phantom for it, however.  This is typically the case
                // when we're adding a read-only NC for which we do not
                // currently hold the NC above it (or no such NC exists).

                // So, we need to create a placeholder to which we can add a
                // repsFrom value.  Note that we don't create an uninstantiated
                // NC, as that would preclude clients (KCC, repadmin, etc.) from
                // reading its repsFrom values.  We instead create a temporary
                // but instantiated NC head that will be replaced once we get
                // our first packet from the source DSA.
                Assert(!fNullUuid(&pNC->Guid));
                it |= IT_NC_COMING;
                AddPlaceholderNC(pDB, pNC, it);

                if (0 != pTHS->errCode) {
                    ret = RepErrorFromPTHS(pTHS);
                    DRA_EXCEPT(ret, 0);
                }
            }
            else {
                // We already have an instantiated NC to which to add a
                // repsFrom value.
                Assert(0 == dbFindErr);
                Assert(!(IT_UNINSTANT & it));
            }

            // We have an instantiated NC to which to add our new repsFrom.
            Assert(!(it & IT_UNINSTANT));
            Assert(!(it & IT_WRITE) == !(ulOptions & DRS_WRIT_REP));

            // This is for the asynchronous, mail-based case
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_NEW_REPLICA_FULL_SYNC,
                     szInsertWC(pNC->StringName),
                     szInsertSz(pmtx_addr->mtx_name),
                     szInsertHex(ulOptions));

            // Add a repsFrom for this source.
            ret = UpdateRepsFromRef(pTHS,
                                    DRS_UPDATE_ALL,
                                    pNC,
                                    DRS_FIND_DSA_BY_ADDRESS,
                                    URFR_NEED_NOT_ALREADY_EXIST,
                                    &uuidDsaObj,
                                    &gNullUuid,
                                    &gusnvecFromScratch,
                                    &uuidTransportObj,
                                    pmtx_addr,
                                    ulOptions & RFR_FLAGS,
                                    preptimesSync,
                                    DRAERR_Success,
                                    NULL);
            if (ret) {
                DRA_EXCEPT(ret, 0);
            }
        }
        else {
            // Replicate some or all of the NC contents now.  If the caller
            // asked for DRS_ASYNC_REP, we will replicate only the NC head now
            // (to verify connectivity and security).  Otherwise we will
            // attempt to replicate the whole NC.

            if (ulOptions & DRS_MAIL_REP) {
                // Mail-based replicas must be added asynchronously.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            // validate source name (fq dns name)
            VALIDATE_RAISE_FQ_DOT_DNS_NAME_UTF8( pmtx_addr->mtx_name );

            // New source we haven't completed a sync from yet.
            ulOptions |= DRS_NEVER_SYNCED;

            // RPC case, either synchronous or ASYNC_REP
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_NEW_REPLICA_FULL_SYNC,
                     szInsertWC(pNC->StringName),
                     szInsertSz(pmtx_addr->mtx_name),
                     szInsertHex(ulOptions));

            // Replicate the NC from the source DSA.
            ret = ReplicateNC(pTHS,
                              pNC,
                              pmtx_addr,
                              pszSourceDsaDnsDomainName,
                              &gusnvecFromScratch,
                              ulOptions & REPNC_FLAGS,
                              preptimesSync,
                              &uuidDsaObj,
                              NULL,
                              &ulSyncFailure,
                              TRUE,                 // New replica
                              pUpToDateVec,
                              pPartialAttrVec,      // GC: get pas based on schema cache
                              NULL);                // GC: no extended PAS attrs
            if (ret) {
                // If encountered error, (sync failure not included) fail
                // whole thing.

                // Note:- In this case, if we got DRAERR_SchemaMismatch, it
                // doesn't make sense to queue a schema sync and requeue the
                // request as DRA_ReplicaAdd() is synchronous.  When
                // DRS_ASYNC_REP is not set, DRA_ReplicaAdd() needs to tell if
                // it added the replica successfully or not to the caller, and
                // so we can't be doing an async handling for
                // DRAERR_SchemaMismatch.

                DRA_EXCEPT(ret, 0);
            }
        }

        Assert(!ret);
        if (!(ulOptions & DRS_WRIT_REP)
            && ((0 != dbFindErr) || (IT_UNINSTANT & it))) {
            // We have just added the first repsFrom for a read-only replica.
            // Write the partial attribute set to the NC head so that it can
            // keep track of partial set changes in the future.
            // ulSyncFailure may or may not imply a failure to create the NC
            // head.  If ReplicaAdd is going to succeed, we must try to add
            // the partial attribute set.
            GC_WritePartialAttributeSet(pNC, pPartialAttrVec);
        }
    }
    __finally {
        // If we had success, commit, else rollback
        EndDraTransaction(!(ret || AbnormalTermination()));

        // Can now free the schema cache we got the partial attr vec from if
        // it is obsolete.
        if (NULL != pSchema) {
            InterlockedDecrement(&pSchema->RefCount);
        }
    }

    // If not a mail-based replica, add the reps-to
    // Note we do this outside of the transaction
    if (!((ulOptions & DRS_ASYNC_REP) && (ulOptions & DRS_MAIL_REP))
        && !DsaIsInstalling()
        && !(ulOptions & DRS_NEVER_NOTIFY)) {
        // Update references on replica source. This call must be async to
        // avoid possible deadlock if the other DSA is doing the
        // same operation.

        // Note that in the install case this is explicitly done out-of-band
        // by NTDSETUP.

        // Also note that we pair DRS_ADD_REF and DRS_DEL_REF -- this
        // effectively tells the remote DSA to remove any Reps-To values it
        // has matching this UUID and/or network address and add a new one.

        I_DRSUpdateRefs(
            pTHS,
            TransportAddrFromMtxAddrEx(pmtx_addr),
            pNC,
            TransportAddrFromMtxAddrEx(gAnchor.pmtxDSA),
            &gAnchor.pDSADN->Guid,
            (ulOptions & DRS_WRIT_REP) | DRS_ADD_REF | DRS_DEL_REF
                | DRS_ASYNC_OP);
    }

    Assert(!ret);

    //
    // Queue async synchronize if we successfully added an async RPC replica.
    //
    // Exception:
    //   - If notifications are disabled on link (during this add)
    //     then we're either inter-site and/or mail based. Either way
    //     hold off w/ replication until the scheduled one fires.
    //
    if ( (ulOptions & DRS_ASYNC_REP)     &&
         !(ulOptions & DRS_NEVER_NOTIFY) &&
         !(ulOptions & DRS_MAIL_REP) ) {

        ULONG ulNewOptions =
            (ulOptions & AO_PRIORITY_FLAGS) | DRS_ASYNC_OP | DRS_ADD_REF;

        Assert( ulNewOptions & DRS_NEVER_SYNCED );

        DirReplicaSynchronize(pNC, NULL, &uuidDsaObj, ulNewOptions);
    }

    // If we had a sync failure but were otherwise successful,
    // return sync failure.
    Assert(!ret);
    if (ulSyncFailure) {
        ret = ulSyncFailure;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drancdel.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       drancdel.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                    // schema cache
#include <dbglobal.h>                  // The header for the directory database
#include <mdglobal.h>                  // MD global definition header
#include <mdlocal.h>                   // MD local definition header
#include <dsatools.h>                  // needed for output allocation

// Logging headers.
#include "dsevent.h"                   /* header Audit\Alert logging */
#include "mdcodes.h"                   /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                    /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRANCDEL:" /* define the subsystem for debugging */


// DRA headers
#include "dsaapi.h"
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "drsdra.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRANCDEL

ULONG
DRA_ReplicaDel(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pmtxaddr,
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Remove a replica of an NC from a given source.  If the source is the only
    source for this NC and it is read-only, the NC subtree is removed.
    Otherwise, only the sources list is affected.

Arguments:

    pTHS

    pNC - naming context for which replica should be removed.

    pmtxaddr - network address of server from which the local DS should no
        longer source this NC.

    ulOptions

Return Values:

    DRAERR_Success - success.

    DRAERR_ObjIsRepSource - cannot remove the last replica of a read-only NC
        (implying NC subtree deletion) when other DSAs use this machine as
        a source.

    DRAERR_InvalidParameter - DRS_NO_SOURCE specified in ulOptions but the NC
        either _does_ have one or more sources or it's a writeable replica.

    DRAERR_BadNC - local DSA does not replicate the NC from the given source.

    other DRAERR_* codes

--*/
{
    ULONG           ret;
    REPLICA_LINK *  pRepsFromRef = NULL;
    ULONG           len;
    BOOL            AttExists;
    SYNTAX_INTEGER  it;
    ULONG           ncdnt;
    LPWSTR          pszSource = NULL;
    BOOL            fBeginningTeardown = FALSE;
    CROSS_REF *     pCR;

    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_DRA_REPLICADEL_ENTRY,
             szInsertDN(pNC),
             szInsertMTX(pmtxaddr),
             szInsertHex(ulOptions));

    BeginDraTransaction(SYNC_WRITE);

    __try {
        if (ret = FindNC(pTHS->pDB, pNC, FIND_REPLICA_NC | FIND_MASTER_NC,
                         &it)) {
            DRA_EXCEPT_NOLOG(ret, 0);
        }

        ncdnt = pTHS->pDB->DNT;

        if (ulOptions & DRS_NO_SOURCE) {
            // Caller has instructed us to tear down this NC.
            
            if (DBHasValues(pTHS->pDB, ATT_REPS_FROM)) {
                // Must delete sources before tearing down the NC.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (!(ulOptions & DRS_REF_OK)) {
                if (DBHasValues(pTHS->pDB, ATT_REPS_TO)) {
                    // We're about to tear down the NC but it still has
                    // remaining repsTo's, which the caller did not explicitly
                    // tell us was okay.
                    DRA_EXCEPT_NOLOG(DRAERR_ObjIsRepSource, 0);
                }
            }

            if (!(it & IT_NC_GOING)) {
                if ((it & IT_WRITE)
                    && (NULL != (pCR = FindExactCrossRef(pNC, NULL)))
                    && !fIsNDNCCR(pCR)) {
                    // The only writeable NCs we allow to be torn down are
                    // NDNCs.
                    DRA_EXCEPT(DRAERR_InvalidParameter, 0);
                }
                
                // Change instance type to reflect that the NC is being torn
                // down.
                it = (it & ~IT_NC_COMING) | IT_NC_GOING;
                ret = ChangeInstanceType(pTHS, pNC, it, DSID(FILENO,__LINE__));
                if (ret) {
                    DRA_EXCEPT(ret, 0);
                }
            
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_NC_TEARDOWN_BEGIN,
                         szInsertDN(pNC),
                         szInsertUL(DBGetNCSizeEx(pTHS->pDB,
                                                  pTHS->pDB->JetObjTbl,
                                                  Idx_DraUsn,
                                                  ncdnt)),
                         NULL);

                // Log only one of DIRLOG_DRA_NC_TEARDOWN_BEGIN and
                // DIRLOG_DRA_NC_TEARDOWN_RESUME.
                fBeginningTeardown = TRUE;
            }
            
            if (DRS_ASYNC_REP & ulOptions) {
                // Caller instructed us to do the tree deletion later.
                DirReplicaDelete(pNC,
                                 NULL,
                                 (ulOptions & ~DRS_ASYNC_REP)
                                    | DRS_ASYNC_OP
                                    | DRS_NO_SOURCE);
            } else {
                // Log only one of DIRLOG_DRA_NC_TEARDOWN_BEGIN and
                // DIRLOG_DRA_NC_TEARDOWN_RESUME.
                if (!fBeginningTeardown) {
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_NC_TEARDOWN_RESUME,
                             szInsertDN(pNC),
                             szInsertUL(DBGetNCSizeEx(pTHS->pDB,
                                                      pTHS->pDB->JetObjTbl,
                                                      Idx_DraUsn,
                                                      ncdnt)),
                             NULL);
                }

                if (ret = DeleteRepTree(pTHS, pNC)) {
                    // Note that in this case we probably have a partially deleted
                    // NC with no Reps-From (not a good thing), but the KCC will
                    // try to cleanup the damage on its next pass.
                    BOOL fReenqueued = FALSE;
                    
                    if (DRAERR_Preempted == ret) {
                        // This is expected behavior when we're removing a large NC,
                        // as we will relinquish the replication lock if a higher
                        // priority operation is enqueued.
                        
                        if (DRS_ASYNC_OP & ulOptions) {
                            // Re-enqueue this task such that we pick back up where
                            // we left off once we have finished executing the
                            // higher priority operation(s).
                            DirReplicaDelete(pNC,
                                             NULL,
                                             ulOptions | DRS_NO_SOURCE);
                            fReenqueued = TRUE;
                        }
                    }

                    if (!fReenqueued) {
                        // Removal failed and we're not immediately rescheduling
                        // a retry.  Report our failure.
                        LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                                          DS_EVENT_SEV_ALWAYS,
                                          DIRLOG_DRA_NC_TEARDOWN_FAILURE,
                                          szInsertDN(pNC),
                                          szInsertWin32Msg(ret),
                                          NULL, NULL, NULL, NULL, NULL, NULL,
                                          sizeof(ret),
                                          &ret);
                    }
    
                    DRA_EXCEPT(ret, 0);
                }
            
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_NC_TEARDOWN_SUCCESS,
                         szInsertDN(pNC),
                         NULL,
                         NULL);
            }
        } else {
            // Caller has instructed us to remove a source for this NC.
            if (NULL == pmtxaddr) {
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (FindDSAinRepAtt(pTHS->pDB, ATT_REPS_FROM,
                                DRS_FIND_DSA_BY_ADDRESS | DRS_FIND_AND_REMOVE,
                                NULL, pmtxaddr, &AttExists, &pRepsFromRef,
                                &len)) {
                // NC is not currently replicated from the given source.
                DRA_EXCEPT_NOLOG(DRAERR_NoReplica, 0);
            }
    
            // Existing attribute value for this replica removed.
            VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
    
            // If this is an rpc (non-mail) replica and we have a source, inform
            // source DSA that we don't have a replica anymore.  This call must be
            // async to avoid possible deadlock if the other DSA is doing the same
            // operation.  Mail replicas don't do this because they are not
            // notified on change and so have no source side repsto reference.
            pszSource = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef));
    
            if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP)
                && !(ulOptions & DRS_LOCAL_ONLY)
                && (ret = I_DRSUpdateRefs(pTHS,
                                          pszSource,
                                          pNC,
                                          TransportAddrFromMtxAddr(gAnchor.pmtxDSA),
                                          &gAnchor.pDSADN->Guid,
                                          (pRepsFromRef->V1.ulReplicaFlags
                                                                & DRS_WRIT_REP)
                                          | DRS_DEL_REF | DRS_ASYNC_OP))) {
                // If we are ignoring these errors, clear error, else abort
    
                // Callers who specify DRS_IGNORE_ERROR rely on the source DSA
                // to eventually clean out its dangling Reps-To.  This reference
                // should be removed the next time the source server notifies us of
                // a change, as the local server should correctly inform it that we
                // no longer replicate from it, and the source should then remove
                // its Reps-To reference.
    
                if (ulOptions & DRS_IGNORE_ERROR) {
                    ret = 0;
                } else {
                    DRA_EXCEPT_NOLOG(ret, 0);
                }
            }
    
            // If all is ok so far, if this is a writeable replica remove
            // it from the count of unsynced sources.
            if (pRepsFromRef->V1.ulReplicaFlags & DRS_INIT_SYNC) {
                InitSyncAttemptComplete(pNC,
                                        pRepsFromRef->V1.ulReplicaFlags | DRS_INIT_SYNC_NOW,
                                        DRAERR_NoReplica,
                                        pszSource);
            }
    
            THFreeEx(pTHS, pszSource);
        }
    } __finally {
        // If we had success, commit, else rollback
        if (EndDraTransaction(!(ret || AbnormalTermination()))) {
            Assert (FALSE);
            ret = DRAERR_InternalError;
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drarpc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drarpc.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Defines DRS Rpc Test hooks and functions.

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <01/30/01>  gregjohn

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include "debug.h"              // standard debugging header
#define DEBSUB "DRARPC:"       // define the subsystem for debugging

#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <winsock2.h>
#include "drarpc.h"

#include <fileno.h>
#define  FILENO FILENO_DRARPC

#if DBG
// global barrier for rpcsync tests
BARRIER gbarRpcTest;

void
BarrierInit(
    IN BARRIER * pbarUse,
    IN ULONG    ulThreads,
    IN ULONG    ulTimeout
    )
/*++

Routine Description:

    Barrier Init function.  See BarrierSync

Arguments:
    
    pbarUse - The barrier to use for the threads.
    ulThreads - Number of threads to wait on
    ulTimeout - length of time in minutes to wait before giving up

Return Value:

    None

--*/
{
    pbarUse->heBarrierInUse = CreateEventW(NULL, TRUE, TRUE, L"BarrrierInUse");
    pbarUse->heBarrier = CreateEventW(NULL, TRUE, FALSE, L"Barrier");

    InitializeCriticalSection(&(pbarUse->csBarrier));
    pbarUse->ulThreads = ulThreads;
    pbarUse->ulTimeout = ulTimeout*1000*60;
    pbarUse->ulCount = 0;

    pbarUse->fBarrierInUse = FALSE;
    pbarUse->fBarrierInit = TRUE;
}

void
BarrierReset(
    IN BARRIER * pbarUse
    )
/*++

Routine Description:

    Barrier Reset function.  See BarrierSync

Arguments:
    
    pbarUse - The barrier struct to use

Return Value:

    None

--*/
{
    // enable all threads to leave	
    EnterCriticalSection(&pbarUse->csBarrier);
    __try { 
	pbarUse->fBarrierInUse = TRUE;
	ResetEvent(pbarUse->heBarrierInUse);
	SetEvent(pbarUse->heBarrier);
    }
    __finally { 
	LeaveCriticalSection(&pbarUse->csBarrier);
    }
}


void
BarrierSync(
    IN BARRIER * pbarUse
    )
/*++

Routine Description:

    Mostly generalized barrier function.  Threads wait in this function until
    #ulThreads# have entered, then all leave simultaneously

Arguments:
    
    pbarUse - The barrier struct to use

Return Value:

    None

--*/
{
    if (pbarUse->fBarrierInit) { 
	BOOL fInBarrier = FALSE;
	DWORD ret = 0;
	do {
	    ret = WaitForSingleObject(pbarUse->heBarrierInUse, pbarUse->ulTimeout); 
	    if (ret) {
		DPRINT(0,"Test Error, BarrierSync\n");
		BarrierReset(pbarUse);
		return;
	    }
	    EnterCriticalSection(&pbarUse->csBarrier);
	    __try { 
		if (!pbarUse->fBarrierInUse) {
		    fInBarrier=TRUE;
		    if (++pbarUse->ulCount==pbarUse->ulThreads) {
			DPRINT2(0,"Barrier (%d) contains %d threads\n", pbarUse, pbarUse->ulThreads);
			pbarUse->fBarrierInUse = TRUE;
			ResetEvent(pbarUse->heBarrierInUse);
			SetEvent(pbarUse->heBarrier);
		    }  
		}
	    }
	    __finally { 
		LeaveCriticalSection(&pbarUse->csBarrier);
	    }
	} while ( !fInBarrier );
	ret = WaitForSingleObject(pbarUse->heBarrier, pbarUse->ulTimeout);
	if (ret) {
	    DPRINT(0,"Test Error, BarrierSync\n");
	    BarrierReset(pbarUse); 
	}
	EnterCriticalSection(&pbarUse->csBarrier);
	__try { 
	    if (--pbarUse->ulCount==0) {
		DPRINT1(0,"Barrier (%d) contains 0 threads\n", pbarUse);
		ResetEvent(pbarUse->heBarrier);
		SetEvent(pbarUse->heBarrierInUse);
		pbarUse->fBarrierInUse = FALSE;
	    }
	}
	__finally { 
	    LeaveCriticalSection(&pbarUse->csBarrier);
	}
    }
}

RPCTIME_INFO grgRpcTimeInfo[MAX_RPCCALL];
ULONG        gRpcTimeIPAddr;
RPCSYNC_INFO grgRpcSyncInfo[MAX_RPCCALL];
ULONG        gRpcSyncIPAddr;

void
RpcTimeSet(ULONG IPAddr, RPCCALL rpcCall, ULONG ulRunTimeSecs) 
/*++

Routine Description:

    Enable a time test of DRA Rpc calls for the given client
    and the given Rpc call.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT3(1,"RpcTimeSet Called with IP = %s, RPCCALL = %d, and RunTime = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall,
	    ulRunTimeSecs);
    gRpcTimeIPAddr = IPAddr;
    grgRpcTimeInfo[rpcCall].fEnabled = TRUE;
    grgRpcTimeInfo[rpcCall].ulRunTimeSecs = ulRunTimeSecs;
}

void
RpcTimeReset() 
/*++

Routine Description:

    Reset all the set tests.  Do not explicitly wake threads.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    ULONG i = 0;
    gRpcTimeIPAddr = INADDR_NONE;
    for (i = MIN_RPCCALL; i < MAX_RPCCALL; i++) {
	grgRpcTimeInfo[i].fEnabled = FALSE;
	grgRpcTimeInfo[i].ulRunTimeSecs=0;
    }
}

void
RpcTimeTest(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Check to see if a test has been enabled for this IP and this
    rpc call, if so, sleep the allotted time, else nothing

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcTimeTest Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    if (grgRpcTimeInfo[rpcCall].fEnabled && (gRpcTimeIPAddr == IPAddr)) {
	DPRINT3(0,"RPCTIME TEST:  RPC Call (%d) from %s will sleep for %d secs!\n",
	       rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)), grgRpcTimeInfo[rpcCall].ulRunTimeSecs);
	Sleep(grgRpcTimeInfo[rpcCall].ulRunTimeSecs * 1000);
	DPRINT2(0,"RPCTIME TEST:  RPC Call (%d) from %s has awoken!\n",
		rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
    }
}

void
RpcSyncSet(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Enable a syncronized test of DRA Rpc calls for the given client
    and the given Rpc call.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcSyncSet Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    gRpcSyncIPAddr = IPAddr;
    grgRpcSyncInfo[rpcCall].fEnabled = TRUE;
    grgRpcSyncInfo[rpcCall].ulNumThreads = 2;
}

void
RpcSyncReset() 
/*++

Routine Description:

    Reset all the set tests, and free all waiting threads.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    ULONG i = 0;
    gRpcSyncIPAddr = INADDR_NONE;
    for (i = MIN_RPCCALL; i < MAX_RPCCALL; i++) {
	grgRpcSyncInfo[i].fEnabled = FALSE;
	grgRpcSyncInfo[i].ulNumThreads=2;
    }
    // free any waiting threads.
    BarrierReset(&gbarRpcTest);
}

void
RpcSyncTest(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Check to see if a test has been enabled for this IP and this
    rpc call, if so, call into a global barrier, else nothing

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcSyncTest Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    if (grgRpcSyncInfo[rpcCall].fEnabled && (gRpcSyncIPAddr == IPAddr)) {
       

	DPRINT2(0,"RPCSYNC TEST:  RPC Call (%d) from %s will enter barrier!\n",
	       rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
	BarrierSync(&gbarRpcTest);
	DPRINT2(0,"RPCSYNC TEST:  RPC Call (%d) from %s has left barrier!\n",
		rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
    }
}

void RpcTest(ULONG IPAddr, RPCCALL rpcCall) 
{
    RpcTimeTest(IPAddr, rpcCall);
    RpcSyncTest(IPAddr, rpcCall);
}

RPCCALL 
GetRpcCallA(LPSTR pszDsa)
{
    RPCCALL returnVal;
    if (!_stricmp(pszDsa,"bind")) {
	returnVal=IDL_DRSBIND;
    }
    else if (!_stricmp(pszDsa,"addentry")) {
	returnVal=IDL_DRSADDENTRY;
    }
    else if (!_stricmp(pszDsa,"addsidhistory")) {
	returnVal=IDL_DRSADDSIDHISTORY;
    }
    else if (!_stricmp(pszDsa,"cracknames")) {
	returnVal=IDL_DRSCRACKNAMES;
    }
    else if (!_stricmp(pszDsa,"domaincontrollerinfo")) {
	returnVal=IDL_DRSDOMAINCONTROLLERINFO;
    }
    else if (!_stricmp(pszDsa,"executekcc")) {
	returnVal=IDL_DRSEXECUTEKCC;
    }
    else if (!_stricmp(pszDsa,"getmemberships")) {
	returnVal=IDL_DRSGETMEMBERSHIPS;
    }
    else if (!_stricmp(pszDsa,"getmemberships2")) {
	returnVal=IDL_DRSGETMEMBERSHIPS2;
    }
    else if (!_stricmp(pszDsa,"getncchanges")) {
	returnVal=IDL_DRSGETNCCHANGES;
    }
    else if (!_stricmp(pszDsa,"getnt4changelog")) {
	returnVal=IDL_DRSGETNT4CHANGELOG;
    }
    else if (!_stricmp(pszDsa,"getreplinfo")) {
	returnVal=IDL_DRSGETREPLINFO;
    }
    else if (!_stricmp(pszDsa,"inheritsecurityidentity")) {
	returnVal=IDL_DRSINHERITSECURITYIDENTITY;
    }
    else if (!_stricmp(pszDsa,"interdomainmove")) {
	returnVal=IDL_DRSINTERDOMAINMOVE;
    }
    else if (!_stricmp(pszDsa,"removedsdomain")) {
	returnVal=IDL_DRSREMOVEDSDOMAIN;
    }
    else if (!_stricmp(pszDsa,"removedsserver")) {
	returnVal=IDL_DRSREMOVEDSSERVER;
    }
    else if (!_stricmp(pszDsa,"replicaadd")) {
	returnVal=IDL_DRSREPLICAADD;
    }
    else if (!_stricmp(pszDsa,"replicadel")) {
	returnVal=IDL_DRSREPLICADEL;
    }
    else if (!_stricmp(pszDsa,"replicamodify")) {
	returnVal=IDL_DRSREPLICAMODIFY;
    }
    else if (!_stricmp(pszDsa,"replicasync")) {
	returnVal=IDL_DRSREPLICASYNC;
    }
    else if (!_stricmp(pszDsa,"unbind")) {
	returnVal=IDL_DRSUNBIND;
    }
    else if (!_stricmp(pszDsa,"updaterefs")) {
	returnVal=IDL_DRSUPDATEREFS;
    }
    else if (!_stricmp(pszDsa,"verifynames")) {
	returnVal=IDL_DRSVERIFYNAMES;
    }
    else if (!_stricmp(pszDsa,"writespn")) {
	returnVal=IDL_DRSWRITESPN;
    }
    else if (!_stricmp(pszDsa,"replicaverifyobjects")) {
	returnVal=IDL_DRSREPLICAVERIFYOBJECTS;
    }
    else if (!_stricmp(pszDsa,"getobjectexistence")) {
	returnVal=IDL_DRSGETOBJECTEXISTENCE;
    }
    else {
	returnVal=MIN_RPCCALL;
    }
    return returnVal;
}

ULONG
GetIPAddrA(
    LPSTR pszDSA
    )
/*++

Routine Description:

    Given a string which contains either the hostname or an IP address, return
    the ULONG form of the IP address

Arguments:

    pszDSA - the input hostname or IP address

Return Value:

    IP Address

--*/
{

    ULONG err = 0;
    ULONG returnIPAddr = 0;
 
    THSTATE * pTHS = pTHStls;
    LPWSTR pszMachine = NULL;
    ULONG Length = 0;
    ULONG cbSize = 0;
    HOSTENT *lpHost=NULL;

    // see if the input is an ip address
    returnIPAddr = inet_addr(pszDSA);
    if (returnIPAddr!=INADDR_NONE) {
	// we found an IP address
	return returnIPAddr;
    }
    // else lookup the ip address from the hostname.
    // convert to wide char
    Length = MultiByteToWideChar( CP_ACP,
				  MB_PRECOMPOSED,
				  pszDSA,
				  -1,  
				  NULL,
				  0 );

    if ( Length > 0 ) {
	cbSize = (Length + 1) * sizeof( WCHAR );
	pszMachine = (LPWSTR) THAllocEx( pTHS, cbSize );
	RtlZeroMemory( pszMachine, cbSize );

	Length = MultiByteToWideChar( CP_ACP,
				      MB_PRECOMPOSED,
				      pszDSA,
				      -1,  
				      pszMachine,
				      Length + 1 );
    } 
    if ( 0 == Length ) {
	err = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!err) {
	lpHost = gethostbyname( pszDSA ); 

	if (lpHost) { 
	    memcpy(&returnIPAddr,lpHost->h_addr_list[0], lpHost->h_length);
	}
	else {
	    err = ERROR_OBJECT_NOT_FOUND;
	}
    }
    if (pszMachine) {
	THFreeEx(pTHS,pszMachine);
    }
    if (err) {
	DPRINT1(1,"RPCTEST:  Error getting the IP address (%d)\n", err);
	return INADDR_NONE;
    }
    return returnIPAddr;
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drancrep.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drancrep.c
//
//--------------------------------------------------------------------------
/*++

ABSTRACT:

    Worker routines to perform inbound replication.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <sdprop.h>                     // for SDP critical sections

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRANCREP:" /* define the subsystem for debugging */

// DRA headers
#include "drs.h"
#include "dsaapi.h"
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "draasync.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drasch.h"
#include "drsdra.h"  // for draReportSyncProgress
#include "samsrvp.h" // for SampAcquireReadLock
#include "xdommove.h"

#include <fileno.h>
#define  FILENO FILENO_DRANCREP

// Number of packets we process before updating our on-disk USN vector.  See
// comments in ReplicateNC().
#define UPDATE_REPSFROM_PACKET_INTERVAL (10)

// Prototypes

void  GetUSNForFSMO(DSNAME *pOwner, DSNAME *pNC, USN_VECTOR *usnvecFrom);

ENTINF*
GetNcPreservedAttrs(
    IN  THSTATE     *pTHS,
    IN  DSNAME      *pNC);

// These are counts of priority oeprations pending and are used to determine
// if we should abandon a synchronize operation.

extern ULONG gulAsyncPriorityOpsWaiting;
extern ULONG gulSyncPriorityOpsWaiting;

// This flag indicates whether the current operation is a priority
// operation or not.

extern BOOL gfCurrentThreadPriority;

// This is the maximum number of entries and bytes that we ask for at a time,
// set via a registry variable.
ULONG gcMaxIntraSiteObjects = 0;
ULONG gcMaxIntraSiteBytes = 0;
ULONG gcMaxInterSiteObjects = 0;
ULONG gcMaxInterSiteBytes = 0;

// Counts to calculate efficiency of pre-fetching packets in ReplicateNC().
DWORD gcNumPreFetchesTotal = 0;
DWORD gcNumPreFetchesDiscarded = 0;

// Maximum number of milliseconds we have to wait for the SDP lock before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxTicksToGetSDPLock = 0;

// Wait 15 to 30 seconds for the schema cache to be reloaded
DWORD gInboundCacheTimeoutInMs = 15000;

// This is purely for debugging purposes, and (if set) is the address of the
// last other server we attempted a ReplicaSync call to.

UNALIGNED MTX_ADDR * pLastReplicaMTX = NULL;
extern CRITICAL_SECTION csLastReplicaMTX;

#define VALUES_APPLIED_PER_TRANS 100

// Forward declarations

void
draHandleNameCollision(
    IN      THSTATE *                   pTHS,
    IN      SYNTAX_INTEGER              itInbound,
    IN      PROPERTY_META_DATA_VECTOR * pInboundMetaDataVec,
    IN      DSNAME *                    pPreviousDN,
    IN      DSNAME *                    pParentDN,
    IN      ATTRTYP                     RDNType,
    IN OUT  ATTR *                      pInboundRDN,
    IN OUT  DSNAME **                   ppInboundDN,
    OUT     BOOL *                      pfRetryUpdate
    );


/* AttrValFromPentinf - Given a ENTINF 'pent' extract the (first) value of
*       the attribute given by 'atype'. The value is returned (in external
*       form ) through 'pVal', a pointer to the ATTR structure that the
*       value was extracted from is also returned through 'ppAttr'.
*
*  Notes: It is the caller's responsibility to ensure that pVal points to an
*       area big enougth to accept the value.
*
*  Returns:
*       ATTR_PRESENT_VALUE_RETURNED if a value is extracted.
*       ATTR_PRESENT_NO_VALUES  if the attribute has no values.
*       ATTR_NOT_PRESENT if the attribute does not exist
*
*       The return values are chosen so that the function returns TRUE if
*       no values are returned.
*/
USHORT
AttrValFromAttrBlock(
    IN  ATTRBLOCK * pAttrBlock,
    IN  ATTRTYP     atype,
    OUT VOID *      pVal,       OPTIONAL
    OUT ATTR **     ppAttr      OPTIONAL
    )
{
    ULONG      i;

    if (ppAttr) {
        *ppAttr = NULL;
    }

    for(i = 0; i < pAttrBlock->attrCount; i++) {
        if (pAttrBlock->pAttr[i].attrTyp == atype) {
            if (pAttrBlock->pAttr[i].AttrVal.valCount == 0) {
                return ATTR_PRESENT_NO_VALUES;
            }

            if (NULL != pVal) {
                memcpy(pVal, pAttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                       pAttrBlock->pAttr[i].AttrVal.pAVal->valLen);
            }

            if (ppAttr) {
                *ppAttr = &(pAttrBlock->pAttr[i]);
            }

            return ATTR_PRESENT_VALUE_RETURNED;
        }
    }

    return ATTR_NOT_PRESENT;
}

USHORT
AttrDeletionStatusFromPentinf (
        ENTINF *pent
    )
/*++
Description:
    Given a ENTINF 'pent' (attribute update list), determine whether object
    is being deleted, having its deletion reversed, or that nothing is
    changing regarding its deletion.

Arguments:
    pent - attribute update list

Return Values:
    OBJECT_NO_DELETION_CHANGE - No change in deletion status
    OBJECT_BEING_DELETED - attribute IS_DELETED present and set to 1
    OBJECT_DELETION_REVERSED - attribute IS_DELETED present, either
        with no values, or set to 0

    The return values are chosen so that the function returns TRUE if
    if there was a status change
--*/
{
    SYNTAX_INTEGER isDeleted;
    USHORT result;

    switch (AttrValFromAttrBlock(&pent->AttrBlock, ATT_IS_DELETED, &isDeleted,
                                 NULL)) {

    case ATTR_PRESENT_VALUE_RETURNED:
        // Attribute present with a value.
        if (isDeleted == 0L) {
            return OBJECT_DELETION_REVERSED;
        } else {
            return OBJECT_BEING_DELETED;
        }

    case ATTR_PRESENT_NO_VALUES:
        // Attribute present with no value.
        return OBJECT_DELETION_REVERSED;

    default:
        Assert(!"Logic error!");
        // fall through...

    case ATTR_NOT_PRESENT:
        // Attribute not found.
        return OBJECT_DELETION_NOT_CHANGED;
    }
} /* AttrDeletionStatusFromAttrBlock */


/* RenameLocalObj - Rename the object given by dsname pName
*
*       It is assumed that the object to be renamed already exists
*       in the local DB, and the currency is on that object. We also
*       assume there is an open write transaction.
*
*       If fMoveToLostAndFound is TRUE then we will also set the LastKnownParent attribute
*
* pAttrRdn - RDN attribute containing new name
* pObjectGuid - GUID of the object to be renamed
* pParentGuid - Guid of the new parent
* pMetaDataVecRemote - remote meta data vector that came with the
*                      replication packet
* fMoveToLostAndFound - TRUE, if this operation is a special move to
*                       LostAndFound
* fDeleteLocalObj - Will object be deleted in applying this change?
*
* Note:
*       By using the DSA LocalModifyDN function we ensure appropriate system
*       attributes are not modified.
*
* Returns:
*       0 if the object is successfully renamed, an appropriate error if not.
*/
ULONG
RenameLocalObj(
    THSTATE                     *pTHS,
    ULONG                       dntNC,
    ATTR                        *pAttrRdn,
    GUID                        *pObjectGuid,
    GUID                        *pParentGuid,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )
{
    MODIFYDNARG modDNArg;
    MODIFYDNRES modDNRes;
    ULONG       cbReturned;
    DSNAME *    pNewDSName;
    DSNAME *    pLocalParent = NULL;
    DSNAME *    pLocalName = NULL;
    DSNAME *    pNewLocalParent = NULL;
    BOOL        bNewLocalParentAllocd = FALSE;
    BOOL        fLocalPhantomParent = FALSE;
    ULONG       dntObj = 0;
    DBPOS *     pDB = pTHS->pDB;
    BOOL        fNameCollisionHandled = FALSE;
    BOOL        fRetryUpdate;
    DWORD       err;
    BOOL        fIsObjAlreadyDeleted;
    BOOL        fIsMove;
    SYNTAX_INTEGER it;

    Assert( pAttrRdn->AttrVal.valCount == 1 );
    Assert( pAttrRdn->AttrVal.pAVal->valLen != 0 );
    Assert( pAttrRdn->AttrVal.pAVal->pVal != NULL );
    Assert( pAttrRdn->attrTyp == ATT_RDN );

    DPRINT3(2, "RenameLocalObj, new RDN = '%*.*ws'\n",
            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
            pAttrRdn->AttrVal.pAVal->pVal);

    // save the current DNT (so that we can restore currency quickly)
    dntObj = pTHS->pDB->DNT;

    // currency is on the local object - get its DSNAME
    if (DBGetAttVal(pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    DBGETATTVAL_fREALLOC,
                    0,
                    &cbReturned,
                    (LPBYTE *) &pLocalName)) {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // Get the instance type of the object
    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

    fIsObjAlreadyDeleted = DBIsObjDeleted(pDB);

    // When using ModDn, attrTyp must match the class-specific RDN attribute
    if (DBGetSingleValue(pDB,
                         FIXED_ATT_RDN_TYPE,
                         &(pAttrRdn->attrTyp),
                         sizeof(DWORD), NULL)) {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // get the local parents DSNAME
    pLocalParent = (DSNAME *) THAllocEx(pTHS, pLocalName->structLen);
    if (TrimDSNameBy(pLocalName, 1, pLocalParent)) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    if (FillGuidAndSid (pLocalParent)) {
        fLocalPhantomParent = TRUE;
        // We allow the replicator to move an object with a phantom parent
        // Note that in this code path, pLocalParent doesnt have a guid
    }

    // We do not allow moves of NC HEADs

    fIsMove = (0 == (it & IT_NC_HEAD))
        && (NULL != pParentGuid)
        && (0 != memcmp(&pLocalParent->Guid, pParentGuid, sizeof(GUID)));

    // initialize the modDNArg parameters with the appropriate values;
    memset(&modDNArg, 0, sizeof(modDNArg));
    memset(&modDNRes, 0, sizeof(modDNRes));
    modDNArg.pObject = pLocalName;
    modDNArg.pNewRDN = pAttrRdn;
    modDNArg.pNewParent = NULL;
    modDNArg.pMetaDataVecRemote = pMetaDataVecRemote;
    modDNArg.pDSAName = NULL;
    InitCommarg(&modDNArg.CommArg);

    if (fIsMove) {
        // Both the local and remote parents exist and are different
        // so this is a move
        pNewLocalParent = THAllocEx(pTHS, DSNameSizeFromLen(0));
        bNewLocalParentAllocd = TRUE;
        pNewLocalParent->Guid = *pParentGuid;
        pNewLocalParent->NameLen = 0;
        pNewLocalParent->structLen = DSNameSizeFromLen( 0 );

        if (DBFindDSName(pDB, pNewLocalParent)
            || (!fIsObjAlreadyDeleted
                && !fDeleteLocalObj
                && DBIsObjDeleted(pDB))) {
            // New parent doesn't exist *or* applying this change would result
            // in a live object underneath a deleted parent.  Re-request packet,
            // getting parent objects, too, in case the parent has been
            // resuscitated.  (Or if we have already done so, move this object
            // to the lost & found.)
            return DRAERR_MissingParent;
        }

        // currency is now on the new parent - get its DN
        if (DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME, DBGETATTVAL_fREALLOC,
                0, &cbReturned, (LPBYTE *) &modDNArg.pNewParent))
        {
            DRA_EXCEPT(DRAERR_DBError, 0);
        }

        if (NamePrefix(pLocalName, modDNArg.pNewParent)) {
            // New parent is a child of the object we're moving.  This can
            // occur when the parent object has also been moved on the source
            // DSA, but we haven't yet seen that rename in the replication
            // stream.  Re-request the packet, inserting the parent records
            // into the replication stream first.
            DPRINT2(1, "New parent %ls is a child of %ls!\n",
                    pLocalName->StringName, modDNArg.pNewParent->StringName);
            return DRAERR_MissingParent;
        }

        if ((INVALIDDNT != dntNC)
            && (pDB->NCDNT != dntNC)
            && (pDB->DNT != dntNC)) {
            // The new parent object is in the wrong NC; i.e., it has been
            // moved across domains, and the source (remote) and dest
            // (local) DSAs don't agree on which NC the object is
            // currently in.  This is a transient condition that will be
            // rectified by replicating in the  other direction and/or
            // by replicating the other NC involved.
            DPRINT2(0,
                    "Cannot move object %ls because its local parent to-be "
                        "%ls is in an NC other than the one being replicated "
                        "-- should be a transient condition.\n",
                    pLocalName->StringName,
                    modDNArg.pNewParent->StringName);
            DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
        }

        pNewLocalParent = modDNArg.pNewParent;
    }
    else {
        pNewLocalParent = pLocalParent;
        // set bNewLocalParentAllocd to FALSE at beginning of function.
    }

    do {
        fRetryUpdate = FALSE;

        DBFindDNT(pDB, dntObj);

        if (NULL == modDNArg.pResObj) {
            modDNArg.pResObj = CreateResObj(pDB, modDNArg.pObject);
        }

        __try {
            LocalModifyDN(pTHS, &modDNArg, &modDNRes);
            err = RepErrorFromPTHS(pTHS);
        }
        __except (GetDraNameException(GetExceptionInformation(), &err)) {
            // String name of the inbound object conflicts with that of a
            // pre-existing local object.
            if (!fNameCollisionHandled) {
                // Construct the DN of the post-renamed object.
                SpliceDN(pTHS,
                            pLocalName,
                            pNewLocalParent,
                            (WCHAR *) pAttrRdn->AttrVal.pAVal->pVal,
                            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
                            pAttrRdn->attrTyp,
                            &pNewDSName);

                draHandleNameCollision(pTHS,
                                       modDNArg.pResObj->InstanceType,
                                       pMetaDataVecRemote,
                                       modDNArg.pObject,
                                       pNewLocalParent,
                                       pAttrRdn->attrTyp,
                                       pAttrRdn,
                                       &pNewDSName,
                                       &fRetryUpdate);

                fNameCollisionHandled = TRUE;
            }
        }
    } while (fRetryUpdate);

    THFreeEx(pTHS, modDNArg.pResObj);

    // Currency when we entered this function was on the object that was
    // renamed. Reset the currency back to the same object upon return.
    DBFindDNT( pDB, dntObj );

    if (fMoveToLostAndFound)
    {
        ULONG retErr;

        // We have just moved an orphaned object to Lost and found - set its
        // last known parent value
        // Note that if fLocalPhantomParent is true, then this DSNAME names a phantom
        // and does not have a guid.
        if (retErr = DBReplaceAttVal(pDB, 1, ATT_LAST_KNOWN_PARENT,
                        pLocalParent->structLen, pLocalParent))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }

        if (retErr = DBRepl( pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING ))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    if(pLocalParent != NULL) THFreeEx(pTHS, pLocalParent);
    if(bNewLocalParentAllocd && pNewLocalParent != NULL) THFreeEx(pTHS, pNewLocalParent);

    return err;
}

/* ModifyLocalObj - Modify the object given by 'pDN' at the local DSA.
*       'pAttrBlock' gives this list of attributes to be modified and the
*       new value(s) to give them.
*       Only the attributes mentioned in 'pAttrBlock' are changed.
*
*       It is assumed that the object to be modifed already exists.
*
* Note:
*       By using the DSA LocalModify function we ensure appropriate system
*       attributes are not modified.
*
* Returns:
*       0 if the object is successfully modified, an appropriate error if not.
*/
ULONG
ModifyLocalObj(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    DSNAME *                    pName,
    ATTRBLOCK *                 pAttrBlock,
    GUID *                      pParentGuid,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )
{
    ULONG           ret;
    DBPOS *         pDB = pTHS->pDB;
    MODIFYARG       modarg;
    ATTRMODLIST *   pModList, *pModNext, *pModLast;
    ATTRMODLIST *   rgattrmodlist;
    ULONG           modCount = pAttrBlock->attrCount;
    ULONG           i;
    BOOL            fIsRename = FALSE;
    ATTR *          pAttrRdn;

    Assert(0 != modCount);
    if (modCount == 0)
        return 0;

    if (DBFindDSName(pDB, pName))
    {
        // We should not get here, the DRA should have previously
        // confirmed that this object does infact exist.
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    memset(&modarg, 0, sizeof(modarg));
    modarg.pObject = pName;
    modarg.pMetaDataVecRemote = pMetaDataVecRemote;
    modarg.count = 0;
    InitCommarg(&modarg.CommArg);
    // Allow removal of non-existant values and addition of already-present values.
    // This can happen, for example, when replicating in a deletion (with
    // attribute removals), and the local object is already deleted, or
    // does not hold all the attributes being removed.
    modarg.CommArg.Svccntl.fPermissiveModify = TRUE;
    modarg.pResObj = CreateResObj(pDB, modarg.pObject);

    // Allocate memory for Modify List - Note we do not use THAlloc here
    // so that we can clean it up immediately we are done with it.

    // Note that because the first ATTRMODLIST structure is actually embedded
    // in the MODIFYARG, we build the linked list of ATTRMODLIST structures
    // using three pointers:
    //
    //      pModList -  the next structure to fill in
    //      pModNext -  the next "free" structure (the next-next structure to
    //                  fill in)
    //      pModLast -  the last structure we filled in (the tail)

    rgattrmodlist = THAllocEx(pTHS, sizeof(ATTRMODLIST)*(modCount-1));
    pModNext = rgattrmodlist;
    pModList = &(modarg.FirstMod);
    pModLast = pModList;

    for ( i = 0; i < pAttrBlock->attrCount; i++ )
    {
        if (ATT_RDN == pAttrBlock->pAttr[i].attrTyp)
        {
            // Replicating a rename - need to go through LocalModifyDN
            fIsRename = TRUE;
            pAttrRdn = &(pAttrBlock->pAttr[i]);
        }
        else
        {
            if (!pAttrBlock->pAttr[i].AttrVal.valCount)
            {
                pModList->choice = AT_CHOICE_REMOVE_ATT;
            }
            else if(DBHasValues(pDB, pAttrBlock->pAttr[i].attrTyp))
            {
                pModList->choice = AT_CHOICE_REPLACE_ATT;
            }
            else
            {
                pModList->choice = AT_CHOICE_ADD_ATT;
            }

            pModList->AttrInf = pAttrBlock->pAttr[i];
            pModLast = pModList;
            pModList->pNextMod = pModNext;
            pModList = pModNext++;
            modarg.count++;
        }
    }

    pModLast->pNextMod = NULL;

    if (fIsRename) {
        // replicating a rename, and bad deletion case also
        ret = RenameLocalObj(pTHS,
                             dntNC,
                             pAttrRdn,
                             &(pName->Guid),
                             pParentGuid,
                             pMetaDataVecRemote,
                             fMoveToLostAndFound,
                             fDeleteLocalObj);
        if (ret) {
            return ret;
        }
    }

    Assert(modarg.count <= modCount);

    if (modarg.count) {
        LocalModify(pTHS, &modarg);
        ret = RepErrorFromPTHS(pTHS);
    }

    THFreeEx(pTHS, modarg.pResObj);
    THFreeEx(pTHS, rgattrmodlist);

    return ret;
}


ULONG
ModifyLocalObjRetry(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    DSNAME *                    pName,
    ATTRBLOCK *                 pAttrBlock,
    GUID *                      pParentGuid,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )

/*++

Routine Description:

    This routine extends the semantics of ModifyLocalObj() by wrapping it.
    The purpose of this routine is to catch record too big exceptions, modify
    the attribute list to apply fewer attributes, and to retry the operation.

Arguments:

    pTHS -
    pName -
    pAttrBlock -
    pParentGuid -
    pMetaDataVecRemote -
    fMoveToLostAndFound -
    fDeleteLocalObj -

Return Value:

    ULONG -

--*/

{
    BOOL fRetryUpdate = FALSE;
    DWORD err;
    DSTIME timeNow = 0;  // gets filled in the first time used
    USN usnLocal = 0;

    do {
        __try {
            err = ModifyLocalObj(
                pTHS,
                dntNC,
                pName,
                pAttrBlock,
                pParentGuid,
                pMetaDataVecRemote,
                fMoveToLostAndFound,
                fDeleteLocalObj
                );

            // If this a retry and we were successful...
            if ( (!err) && fRetryUpdate) {
                DPRINT1( 1, "ReplPrune: successfully modified RTB update for %ws\n",
                         pName->StringName );
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_RECORD_TOO_BIG_SUCCESS,
                          szInsertDN(pName),
                          szInsertUUID(&(pName->Guid)),
                          NULL);
            }
            fRetryUpdate = FALSE;
        }
        __except (GetDraRecTooBigException(GetExceptionInformation(), &err)) {
            // Modification causes record to exceed maximum size

            // We were in an update which failed, abort it
            DBCancelRec( pTHS->pDB );

            // Remove some attributes and try again
            fRetryUpdate = ReplPruneOverrideAttrForSize(
                pTHS,
                pName,
                &timeNow,
                &usnLocal,
                pAttrBlock,
                pMetaDataVecRemote
                );
        }
    } while (fRetryUpdate);

    return err;
} /* ModifyLocalObjRetry */

/* ModLocalAtt - Modify a single attribute (given by 'atype') on an object
*       (given by 'pDN) on the local DSA. Replaces the attribute's value(s)
*       with the single value specified by 'pVal', 'size'
*
*  Returns:
*       0 if successful an appropriate error code if not.
*/
ULONG
ModLocalAtt(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pName,
    IN  ATTRTYP     atype,
    IN  ULONG       size,
    IN  VOID *      pVal
    )
{
    ATTRBLOCK attrBlock;
    ATTR      attr;
    ATTRVAL   attrval;

    attrBlock.attrCount = 1;
    attrBlock.pAttr = &attr;
    attr.attrTyp = atype;
    attr.AttrVal.valCount = 1;
    attr.AttrVal.pAVal = &attrval;
    attrval.valLen=size;
    attrval.pVal=pVal;

    return ModifyLocalObj(pTHS, INVALIDDNT, pName, &attrBlock, NULL, NULL, FALSE, FALSE);
}


VOID
modifyLocalValue(
    IN  THSTATE *   pTHS,
    IN  ATTCACHE *  pAC,
    IN  BOOL        fPresent,
    IN  ATTRVAL *   pAVal,
    IN  DSNAME *    pdnValue,
    IN  VALUE_META_DATA *pRemoteValueMetaData
    )

/*++

Routine Description:

Apply the given attribute value locally.

Note that the calls below us are not set up to take pass-in
remote value metadata. We pass it down in the DBPOS.

Arguments:

    pTHS -
    pAC - ATTCACHE of attribute
    fPresent - Whether value is being made present or absent
    pAVal - ATTRVAL of actual value
    pdnValue - Pointer to the DSNAME inside the ATTRVAL, for logging
    pRemoteValueMetaData - remote metadata to be applied

Return Value:

   Exceptions raised

--*/

{
    ULONG ret;

    Assert( pTHS->fDRA );

    if (fPresent) {
        ret = DBAddAttValEx_AC(pTHS->pDB,
                               pAC,
                               pAVal->valLen,
                               pAVal->pVal,
                               pRemoteValueMetaData );
        switch (ret) {
        case DB_success:
        case DB_ERR_VALUE_EXISTS:
            ret = 0;
            break;
        default:
            DPRINT4( 0, "DRA DBAddAttVal_AC obj %s attr %s value %ls failed with db error %d\n",
                     GetExtDN( pTHS, pTHS->pDB), pAC->name, pdnValue->StringName, ret );
            DRA_EXCEPT (DRAERR_DBError, ret);
        }
    } else {
        ret = DBRemAttValEx_AC(pTHS->pDB,
                               pAC,
                               pAVal->valLen,
                               pAVal->pVal,
                               pRemoteValueMetaData );
        switch (ret) {
        case DB_success:
        case DB_ERR_VALUE_DOESNT_EXIST:
        case DB_ERR_NO_VALUE:
            ret = 0;
            break;
        default:
            DPRINT4( 0, "DRA DBRemAttVal_AC obj %s attr %s value %ls failed with db error %d\n",
                     GetExtDN( pTHS, pTHS->pDB), pAC->name, pdnValue->StringName, ret );
            DRA_EXCEPT (DRAERR_DBError, ret);
        }
    }

} /* modifyLocalValue */

/* ChangeInstanceType - change the instance type of object 'pDN' to 'it' on
*       the local DSA.
*
*  Returns:
*       0 if successful an error code if not.
*/
ULONG
ChangeInstanceType(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pName,
    IN  SYNTAX_INTEGER  it,
    IN  DWORD           dsid
    )
{
    DWORD ret;

    Assert(ISVALIDINSTANCETYPE(it));
    Assert(pTHS->fDRA);
    ret = ModLocalAtt(pTHS,
                      pName,
                      ATT_INSTANCE_TYPE,
                      sizeof(SYNTAX_INTEGER),
                      &it);
    if (!ret) {
        // Support for generating a change history of instance types
        DPRINT3( 1, "0x%x: %ls instanceType=0x%x\n",
                 dsid, pName->StringName, it );
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_SET_IT,
                 szInsertDN(pName),
                 szInsertHex(it),
                 szInsertHex(dsid));
    }
    return ret;
}

/* DeleteLocalObj - Delete the object given by 'pDN' on the local DSA.
*
*       If fGarbCollectASAP is TRUE, we convert the object into a phantom
*       and mark it for immediate garbage collection (which will be attempted
*       the next time garbage collection is run, which given the defaults
*       might be up to 12 hours from now).
*
*  Returns:
*       0 if successful, an error code otherwise.
*/
ULONG
DeleteLocalObj(
    THSTATE *                   pTHS,
    DSNAME *                    pDN,
    BOOL                        fPreserveRDN,
    BOOL                        fGarbCollectASAP,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )
{
    REMOVEARG removeArg;

    DPRINT1(1, "Deleting object (%S)\n", pDN->StringName);

    Assert(CheckCurrency(pDN));

    // Must never preserve RDN if we're converting the object into a tombstone
    // -- otherwise no live object may be created with this object's name.
    Assert(!(fPreserveRDN && !fGarbCollectASAP));

    // Must never mangle RDN if we're converting it into a phantom --
    // otherwise we will e.g. leave forward links to what appears to be a
    // tombstone name.
    Assert(!(!fPreserveRDN && fGarbCollectASAP));

    memset(&removeArg, 0, sizeof(removeArg));
    removeArg.pObject = pDN;
    removeArg.fGarbCollectASAP = fGarbCollectASAP;
    removeArg.pMetaDataVecRemote = pMetaDataVecRemote;
    removeArg.fPreserveRDN = fPreserveRDN || fNullUuid(&pDN->Guid);
    removeArg.pResObj = CreateResObj(pTHS->pDB, pDN);

    LocalRemove(pTHS, &removeArg);

    THFreeEx(pTHS, removeArg.pResObj);

    return RepErrorFromPTHS(pTHS);
}

/* DeleteRepObj - Removes replica of an object.
*
*       This routine handles the removal of a replicated object. The object
*       may be deleted, or its instance type may be modified to indicate
*       that we no longer have a replica of this object.
*
*       fNotRoot indicates if this object is the root of an NC
*
*       If fGarbCollectASAP is TRUE, we convert the object into a phantom
*       and mark it for immediate garbage collection (which will be attempted
*       the next time garbage collection is run, which given the defaults
*       might be up to 12 hours from now).
*/
ULONG
DeleteRepObj (
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pDN,
    IN  BOOL                        fPreserveRDN,
    IN  BOOL                        fGarbCollectASAP,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote  OPTIONAL
    )
/*++

Routine Description:

    Delete an interior node of an NC.  Converts the object into a tombstone
    or directly into a phantom, as directed by the caller.

Arguments:

    pTHS (IN)

    pDN (IN) - Name of the object to delete.

    fPreserveRDN (IN) - If true, don't delete-mangle the RDN.

    fGarbCollectASAP (IN) - If true, convert the object directly into a phantom
        without going through the usual interim tombstone state.  Typically used
        only during NC teardown.

    pMetaDataVecRemote (IN, OPTIONAL) - The meta data associated with the
        inbound object update that instructed us to delete the object (if any).

Return Values:

    0 or Win32 error.

--*/
{
    ULONG ret = 0;
    SYNTAX_INTEGER it;

    // Should always supply meta data if we're converting the object into a
    // tombstone (otherwise, this would be an originating delete -- we don't
    // currently do those).
    Assert(!(!fGarbCollectASAP && (NULL == pMetaDataVecRemote)));

    Assert(CheckCurrency(pDN));
    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

    Assert(ISVALIDINSTANCETYPE(it));

    switch (it) {

        // This is the scenario where we are deleting objects above
        // another NC.

    case NC_MASTER_SUBREF:
    case NC_MASTER_SUBREF_COMING:
    case NC_MASTER_SUBREF_GOING:
    case NC_FULL_REPLICA_SUBREF:
    case NC_FULL_REPLICA_SUBREF_COMING:
    case NC_FULL_REPLICA_SUBREF_GOING:
        ret = ChangeInstanceType(pTHS, pDN, it & ~IT_NC_ABOVE, DSID(FILENO,__LINE__));
        break;

        // We may get this in certain failure conditions such as when we
        // have partially deleted an NC above another NC, including modifying
        // a subordinate NC's instance type, and then on the
        // retry we find the subordinate NC again as part of the NC we're
        // deleting. We don't want to delete the NC master of the
        // subordinate NC, so ignore it.

        // JeffParh 2000-04-14 - We can and should avoid this situation by
        // ensuring that NCDNT == ROOTTAG on all NC heads without
        // IT_NC_ABOVE.

    case NC_MASTER:
    case NC_MASTER_COMING:
    case NC_MASTER_GOING:
    case NC_FULL_REPLICA:
    case NC_FULL_REPLICA_COMING:
    case NC_FULL_REPLICA_GOING:

        break;

    case INT_MASTER:
    case SUBREF:
    case INT_FULL_REPLICA:
        ret = DeleteLocalObj(pTHS,
                             pDN,
                             fPreserveRDN,
                             fGarbCollectASAP,
                             pMetaDataVecRemote);
        break;

    default:
        DRA_EXCEPT(DRAERR_InternalError, ERROR_DS_BAD_INSTANCE_TYPE);
        break;
    }

    return ret;
}

ULONG
DeleteNCRoot(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    )
/*++

Routine Description:

    Remove an NC root object as part of an NC teardown.  Removal of the object
    may consist of converting it into a subref, tombstone, and/or phantom,
    depending upon its context.

Arguments:

    pTHS (IN)

    pNC (IN) - Name of the NC root object.  Must not have remaining interior
        nodes.

Return Values:

    0 or Win32 error.

--*/
{
    ULONG ret = 0;
    SYNTAX_INTEGER it;

    Assert(CheckCurrency(pNC));
    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, (VOID *) &it, sizeof(it));

    Assert(ISVALIDINSTANCETYPE(it));
    Assert(it & IT_NC_GOING);

    if (NULL == FindExactCrossRef(pNC, NULL)) {
        // There is no cross-ref corresponding to the domain NC we're
        // removing.  This implies the domain has been removed from the
        // enterprise, and thus we should delete-mangle the RDN of the
        // NC head such that an admin can choose to install a new domain
        // by the same name.

        // By the same token, we must convert subrefs into tombstones
        // rather than phantoms.  This is esp. important in the case where
        // we hold the NC above this one, as machines with auto-generated
        // subrefs (as opposed to subrefs with the properties of the real
        // NC head, like this one) will convert their auto-generated subrefs
        // into tombstones in DelAutoSubRef() upon seeing the deletion of
        // the corresponding cross-ref.  That tombstone will then propagate
        // here, and we must still have the subref (live or dead, but not
        // phantomized) to which to apply those inbound changes.

        // Aren't subrefs fun?

        if (it & IT_NC_ABOVE) {
            // Make NC head a pure subref to reflect the fact that the
            // replica contents have been deleted.
            ret = ChangeInstanceType(pTHS, pNC, SUBREF, DSID(FILENO,__LINE__));
        }

        if (!ret) {
            ret = DeleteLocalObj(pTHS,
                                 pNC,
                                 FALSE, // fPreserveRDN
                                 FALSE, // fGarbCollectASAP
                                 NULL);
        }
    } else if (it & IT_NC_ABOVE) {
        // We hold the NC above this one AND there is a live cross-ref for
        // this NC, so we need to convert this NC head into a pure SUBREF.
        // (This typically occurs when we demote a GC.)

        ret = ChangeInstanceType(pTHS, pNC, SUBREF, DSID(FILENO,__LINE__));

    } else {
        // There is a live cross-ref for this NC but we don't hold an NC
        // above it.  In this case, there's no need to hang on to any sort
        // of subref object for this NC.

        // We bypass the tombstone state and convert the object directly into a
        // phantom.  This preserves any linked references to the NC had, which
        // are still perfectly valid (despite the fact that we will no longer
        // hold the referred-to object).  For similar reasons we preserve the
        // RDN.

        ret = DeleteLocalObj(pTHS,
                             pNC,
                             TRUE, // fPreserveRDN
                             TRUE, // fGarbCollectASAP
                             NULL);
    }

    return ret;
}

/* DeleteRepTree - Delete a subtree from a replica NC on the local DSA.
*
*       The root of the subtree is given by 'pDN'.
*
*       fNCPrefix specifies if 'pDN' is an NC prefix object (i.e. if
*       the entire NC is to be deleted).
*/
ULONG
DeleteRepTree(
    IN  THSTATE * pTHS,
    IN  DSNAME *  pNC
    )
{
    ULONG ret = 0;
    PDSNAME pDNTemp = NULL;
    ULONG ncdnt;
    USN usnSeekStart = USN_START;
    ULONG cbSize = 0;
    ULONG cbReturned;
    ULONG dbErr;
    DWORD cNumObjects = 0;
    SYNTAX_INTEGER it;
    ULONG lastError = 0;

    // FInd the NC master
    if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
        DRA_EXCEPT_NOLOG(DRAERR_BadDN, ret);
    }

    // Save the DNT of the NC object
    ncdnt = pTHS->pDB->DNT;

    Assert(FPrefixIt(it));
    Assert(it & IT_NC_GOING);

    // Mark heap such that we can periodically free thread heap allocations.
    TH_mark(pTHS);

    __try {
        // Search for all objects in this NC until we reach the end of the NC
        // or start finding objects we've modified already in this routine.
        while (!GetNextObjByUsn(pTHS->pDB,
                                ncdnt,
                                usnSeekStart,
                                &usnSeekStart)) {
            if (eServiceShutdown) {
                ret = DRAERR_Shutdown;
                break;
            }

            if (IsHigherPriorityDraOpWaiting()) {
                ret = DRAERR_Preempted;
                break;
            }

            // Next seek will be for the next USN after that of the object we
            // just found.
            usnSeekStart++;

            // We won't find the NC head on this index.
            Assert(pTHS->pDB->DNT != ncdnt);

            // Get object distinguished name
            dbErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                DBGETATTVAL_fREALLOC, cbSize, &cbReturned,
                                (PUCHAR *) &pDNTemp);

            if ( 0 != dbErr ) {
                ret = DRAERR_DBError;
            }
            else {
                cbSize = max(cbSize, cbReturned);

                // Delete object. TRUE preserve RDN,
                // TRUE garb collect ASAP.
                ret = DeleteRepObj (pTHS, pDNTemp, TRUE, TRUE, NULL);
            }

            if (ret != 0) {
                // Don't bail out of the loop yet, let's delete as many objects as we can.
                // Remember that we had an error though.
                lastError = ret;
                
                // Call DBCancelRec to make sure any cached metadata is freed.
                // If pDB->JetRetrieveBits == 0 then there are no DB side effects.
                // Doing this now rather than at transaction abort time ensures
                // that the meta data vector we have cached (if any) is correctly
                // freed off the marked heap, rather than off the "org" heap.
                DBCancelRec(pTHS->pDB);
            }

            DBTransOut (pTHS->pDB, !ret, TRUE);

            if (0 == (++cNumObjects % 500)) {
                // We've removed a lot of objects and consumed a lot of memory.
                // Release that memory and re-mark the heap.
                TH_free_to_mark(pTHS);
                TH_mark(pTHS);

                pDNTemp = NULL;
                cbSize = 0;

                // Inform interested parties we're making progress.
                gfDRABusy = TRUE;
            }

            DBTransIn (pTHS->pDB);
        }

        if (lastError != 0) {
            // we had an error during the loop, so we should not be deleting this NC...
            ret = lastError;
        }

        if (DRAERR_Success == ret) {
            // Successful so far -- delete the NC head object.

            // Restore currency to NC object
            if (DBFindDNT(pTHS->pDB, ncdnt)) {
                DRA_EXCEPT (DRAERR_InternalError, 0);
            }

            ret = DeleteNCRoot(pTHS, pNC);
            if (!ret) {
                // Do this in the same transaction so there is no opportunity
                // for any other object to get the name
                CheckNCRootNameOwnership( pTHS, pNC );
            }

            DBTransOut (pTHS->pDB, !ret, TRUE);
            DBTransIn (pTHS->pDB);

        }
    } __finally {
        // Call DBCancelRec to make sure any cached metadata is freed.
        // If pDB->JetRetrieveBits == 0 then there are no DB side effects.
        // Doing this now rather than at transaction abort time ensures
        // that the meta data vector we have cached (if any) is correctly
        // freed off the marked heap, rather than off the "org" heap.
        DBCancelRec(pTHS->pDB);

        TH_free_to_mark(pTHS);
    }

    return ret;
}


ULONG
AddLocalObj(
    IN      THSTATE *                   pTHS,
    IN      ULONG                       dntNC,
    IN      ENTINF *                    pent,
    IN      GUID *                      pParentGuid,
    IN      BOOL                        fIsNCHead,
    IN      BOOL                        fAddingDeleted,
    IN OUT  ATTRBLOCK *                 pAttrBlock,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    IN      BOOL                        fMoveToLostAndFound
    )
/*++

Routine Description:

    Add inbound object to the local database.

Arguments:

    pTHS (IN)

    dntNC (IN) - DNT of the NC being replicated, or INVALIDDNT if the NC head
        has not yet been created.

    pent (IN) - The object to add.

    pParentGuid (IN) - The objectGuid of the parent of the object to add.
        May be NULL only if fIsNCHead.

    fIsNCHead (IN) - TRUE if the inbound object is the head of the NC being
        replicated; FALSE otherwise.

    fAddingDeleted (IN) - TRUE if the inbound object object is deleted.

    pMetaDataVecRemote (IN) - Meta data for the inbound object's attributes.

    fMoveToLostAndFound (IN) - If TRUE, the object is locally being moved to the
        lost-and-found container (i.e., as a local originating write, not a
        replicated write).

Return Values:

    DRAERR_Success - Success.

    other DRAERR_* code - Failure.

--*/
{
    ULONG       draError;
    DWORD       dirError;
    ADDARG      addarg = {0};
    WCHAR       szRDN[ MAX_RDN_SIZE ];
    DWORD       cchRDN;
    ATTRTYP     attrtypRDN;
    DSNAME *    pdnLocalParent = NULL;
    DWORD       retErr;
    DBPOS *     pDB = pTHS->pDB;
    DSNAME *    pLastKnownParent = NULL;
    RESOBJ *    pResParent;
    SYNTAX_INTEGER  it;
    ATTR *      pAttrRDN, *pAttrClass, *pAttrSD = NULL;
    DSNAME *    pDN = pent->pName;

    // Check that enough attributes are present to do an object creation.  They
    // should be, but sometimes the bookmarks get skewed so that the source
    // thinks we have an object that we don't.
    // Must have IT, OBJECT_CLASS, RDN and SD for instantiated objects
    if (AttrValFromAttrBlock(pAttrBlock, ATT_INSTANCE_TYPE, &it, NULL)
        || AttrValFromAttrBlock(pAttrBlock, ATT_OBJECT_CLASS, NULL, &pAttrClass)
        || AttrValFromAttrBlock(pAttrBlock, ATT_RDN, NULL, &pAttrRDN)
        || ( (0 == (it & IT_UNINSTANT)) &&
             (AttrValFromAttrBlock(pAttrBlock, ATT_NT_SECURITY_DESCRIPTOR,
                                   NULL, &pAttrSD)) ) ) {
        DraErrMissingObject( pTHS, pent );
    }

    Assert(ISVALIDINSTANCETYPE(it));

    // Retrieve RDN of new object.
    dirError = GetRDNInfo(pTHS, pDN, szRDN, &cchRDN, &attrtypRDN);
    Assert( 0 == dirError );

    if(fIsNCHead){
        // BUGBUG
        // This is not exactly accurate yet, because in promotion we
        // replicate in the Config and Schema NCs as well.  However,
        // this will still work, because currently we treat all
        // NCs besides NDNCs the same way they used to be treated.
        addarg.pCreateNC = THAllocEx(pTHS, sizeof(CREATENCINFO));
        addarg.pCreateNC->iKind = CREATE_DOMAIN_NC;
    }


    // Derive local name of new object.  If the parent on the remote DS
    // has been renamed since it was last replicated here, we will have
    // a different string name for the parent than it does.  This presents
    // a problem, because we find the parent on LocalAdd()'s by string name,
    // and a failure to find the parent will result in failure of the add.
    // (And infinite replication failures.)

    // So, we take the transmitted parent GUID, map it to its local string
    // name, then substitute the local parent DN for the remote parent DN
    // in the DN of the object before passing it on to LocalAdd.  Simple, eh?

    if ( NULL == pParentGuid )
    {
        // No parent GUID; the only case where this is okay is if the new
        // object is the NC head for this NC.

        if ( fIsNCHead )
        {
            // Success!
            addarg.pObject = pDN;
            addarg.pResParent = CreateResObj(pDB, NULL);
        }
        else
        {
            // No parent GUID for internal node -- BAD!
            Assert( !"Parent GUID not supplied for replicated internal node creation!" );
            LogUnhandledError( DRAERR_InternalError );
        }
    }
    else
    {
        DWORD       dbError;
        BYTE        rgbParentGuidOnlyDN[ DSNameSizeFromLen( 0 ) ];
        DSNAME *    pdnParentGuidOnly = (DSNAME *) rgbParentGuidOnlyDN;
        DWORD       cbParentGuidOnlyDN = sizeof( rgbParentGuidOnlyDN );

        memset( pdnParentGuidOnly, 0, cbParentGuidOnlyDN );
        pdnParentGuidOnly->Guid = *pParentGuid;
        pdnParentGuidOnly->structLen = cbParentGuidOnlyDN;

        dbError = DBFindDSName(pDB, pdnParentGuidOnly);

        if ( 0 != dbError )
        {
            // Can't find parent object; the only case where this is
            // okay is if the new object is the NC head for this NC.

            if ( fIsNCHead )
            {
                // Success!
                addarg.pObject = pDN;
                addarg.pResParent = CreateResObj(pDB, NULL);
            }
            else
            {
                // Failed to find parent of internal node; fail with
                // "missing parent" below such that we retry, this time
                // explicitly requesting parent objects.
                ;
            }
        }
        else if (!fAddingDeleted && DBIsObjDeleted(pDB))
        {
            // Parent object is deleted.  Fall through to return
            // "missing parent."
            ;
        }
        else
        {
            // Found parent.
            DWORD cbLocalParentDN;

            // Retrieve parent's DSNAME and use it plus the RDN of the new
            // object to create its local name.

            // Get parent DSNAME.
            dbError = DBGetAttVal(
                            pDB,
                            1,
                            ATT_OBJ_DIST_NAME,
                            DBGETATTVAL_fREALLOC,
                            0,
                            &cbLocalParentDN,
                            (BYTE **) &pdnLocalParent
                            );

            if ( 0 != dbError )
            {
                // Found parent, but can't retrieve ATT_OBJ_DIST_NAME?
                LogUnhandledError( dbError );
            }
            else
            {
                if ((INVALIDDNT != dntNC)
                    && (pDB->NCDNT != dntNC)
                    && (pDB->DNT != dntNC)) {
                    // The parent object is in the wrong NC; i.e., it has been
                    // moved across domains, and the source (remote) and dest
                    // (local) DSAs don't agree on which NC the object is
                    // currently in.  This is a transient condition that will be
                    // rectified by replicating in the  other direction and/or
                    // by replicating the other NC involved.
                    DPRINT2(0,
                            "Cannot add inbound object %ls because its local "
                                "parent %ls is in an NC other than the one "
                                "being replicated -- should be a transient "
                                "condition.\n",
                            pDN->StringName,
                            pdnLocalParent->StringName);
                    DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                }

                // Construct the DN of the object to be added.
                SpliceDN(pTHS,
                            pDN,
                            pdnLocalParent,
                            szRDN,
                            cchRDN,
                            attrtypRDN,
                            &addarg.pObject);

                addarg.pResParent = CreateResObj(pDB, pdnLocalParent);
            }
        }
    }

    if ( NULL == addarg.pObject )
    {
        // Remote-to-local name translation failure.
        draError = DRAERR_MissingParent;
    }
    else
    {
        // Name translated; continue on to LocalAdd.

        BOOL fNameMorphed = FALSE;
        BOOL fNameCollision;
        BOOL fRetry;

        InitCommarg(&addarg.CommArg);

        addarg.AttrBlock = *pAttrBlock;
        addarg.pMetaDataVecRemote = pMetaDataVecRemote;

        do
        {
            fNameCollision = FALSE;
            fRetry = FALSE;

            __try
            {
                LocalAdd( pTHS, &addarg, fAddingDeleted );
                draError = RepErrorFromPTHS(pTHS);

                if (fMoveToLostAndFound)
                {
                    // we have added the object successfully under LostAndFound
                    // update the last known parent
                    if (retErr = DBFindDSName(pDB, addarg.pObject))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }
                    pLastKnownParent = THAllocEx(pTHS, pDN->structLen);
                    if (!pLastKnownParent)
                    {
                        DRA_EXCEPT(DRAERR_OutOfMem, 0);
                    }

                    if (TrimDSNameBy(pDN, 1, pLastKnownParent))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, 0);
                    }

                    if (retErr = DBReplaceAttVal(pDB, 1, ATT_LAST_KNOWN_PARENT,
                                    pLastKnownParent->structLen, pLastKnownParent))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }

                    if (retErr = DBRepl(pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }

                }
            }
            __except ( GetDraNameException( GetExceptionInformation(), &draError ) )
            {
                // Name collision -- handle it.
                if (!fNameMorphed) {
                    draHandleNameCollision(pTHS,
                                           it,
                                           pMetaDataVecRemote,
                                           NULL,
                                           pdnLocalParent,
                                           attrtypRDN,
                                           pAttrRDN,
                                           &addarg.pObject,
                                           &fRetry);
                    fNameMorphed = TRUE;
                }
            }
        } while ( fRetry );
    }

    if (addarg.pResParent) {
        THFreeEx(pTHS, addarg.pResParent);
    }

    if(pLastKnownParent != NULL) THFreeEx(pTHS, pLastKnownParent);

    return draError;
}

void
draHandleNameCollision(
    IN      THSTATE *                   pTHS,
    IN      SYNTAX_INTEGER              itInbound,
    IN      PROPERTY_META_DATA_VECTOR * pInboundMetaDataVec,
    IN      DSNAME *                    pCurrentDN,             OPTIONAL
    IN      DSNAME *                    pParentDN,
    IN      ATTRTYP                     RDNType,
    IN OUT  ATTR *                      pInboundRDN,
    IN OUT  DSNAME **                   ppInboundDN,
    OUT     BOOL *                      pfRetryUpdate
    )
/*++

Routine Description:

    Resolve a DN conflict encountered while applying an inbound change (object
    addition or rename).

    Applies a set of rules to determine which object gets to keep the original
    DN (the inbound object or the pre-existing local object), such that when
    replication has quiesced across all replicas one object will have retained
    the original DN.

    If the conflict is resolved (i.e., *pfRetryUpdate is TRUE on return), the
    name of one of the conflicting objects has been modified -- either the
    pre-existing local object (in which case the rename has been committed)
    or the inbound object (in which case pInboundRDN and ppInboundDN have been
    updated with the new name).

Arguments:

    pTHS (IN) - THSTATE.

    itInbound (IN) - Instance type of the inbound object.

    pInboundMetaDataVec (IN) - Inbound object's meta data vector.

    pCurrentDN (IN, OPTIONAL) - The DN of the inbound object as it currently
        appears in the local database.  NULL if the inbound object does not yet
        exist (i.e., is being added), non-NULL if it exists and is being
        renamed/moved.

    pParentDN (IN) - DN of the (new) parent object; i.e., the parent of
        *ppInboundDN.

    RDNType (IN) - Class-specific RDN of the inbound/local object.

    pInboundRDN (IN/OUT) - RDN attribute of the inbound object.  Updated with
        the new RDN if the inbound object is to be renamed.

    ppInboundDN (IN/OUT) - DN of the inbound object.  Updated with the new RDN
        if the inbound object is to be renamed.

    pfRetryUpdate (OUT) - On return, should the update operation (add or rename)
        be retried?  TRUE unless this the name conflict is a fatal problem
        (i.e., conflict with an NC head or an unhandled conflict between
        read-only interior nodes).

Return Values:

    None.

--*/
{
    DWORD                       err;
    DSNAME *                    pLocalDN;
    SYNTAX_INTEGER              itLocal;
    PROPERTY_META_DATA_VECTOR * pLocalMetaDataVec;
    DWORD                       cb;
    PROPERTY_META_DATA *        pLocalMetaData;
    PROPERTY_META_DATA *        pInboundMetaData;
    BOOL                        fRenameInboundObject;
    DSNAME *                    pLosingDN;
    ATTR *                      pNewRDN = NULL;
    BOOL                        bNewRDNAllocd = FALSE;
    DWORD                       LocalDNT;

    WCHAR                       szRDN[ MAX_RDN_SIZE ];
    DWORD                       cchRDN;
    ATTRTYP                     attrtypRDN;

    Assert(!fNullUuid(&(*ppInboundDN)->Guid));
    Assert((NULL == pCurrentDN) || !fNullUuid(&pCurrentDN->Guid));

    // Default to "don't retry the operation that evoked the collision."
    *pfRetryUpdate = FALSE;

    // Decide which object we want to rename.  We arbitrarily let the object
    // that last claimed the name hold onto that name, and modify the name of
    // the other.


    // Find the local object we conflict with and read its meta data vector and
    // objectGuid.
    // This is somewhat complex.
    // 1) We might be conflicting based on equal string names.
    // 2) Or, we might be conflicting based on equal RDN values and the same
    // parent, but not the same RDN type.
    // 3) Or, we could be conflicting based on having the same key in the
    // PDNT-RDN index.

    // Get the RDN value of the object we're adding.
    err = GetRDNInfo(pTHS,
                     (*ppInboundDN),
                     szRDN,
                     &cchRDN,
                     &attrtypRDN);
    if(err)  {
        DRA_EXCEPT(DRAERR_InternalError, err);
    }

    // Find the DNT of the parent.
    err = DBFindDSName(pTHS->pDB, pParentDN);
    if(err && err != DIRERR_NOT_AN_OBJECT) {
        // Huh?  We should have found something.  Instead we found nothing, not
        // even a phantom.
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    err = DBFindChildAnyRDNType(pTHS->pDB,
                                pTHS->pDB->DNT,
                                szRDN,
                                cchRDN);
    switch(err) {
    case 0:
        // We found an exact match, modulo Attribute Type, which we don't care
        // about.  This covers cases 1 and 2.
        break;
    case ERROR_DS_KEY_NOT_UNIQUE:
        // We didn't find a match, but we found the correct key.  This is case
        // 3.
        break;
    default:
        // Huh?  We should have found something.
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    // OK, we're positioned on the object we conflicted with.  Read the real DN,
    // the instance type, and the metadata.
    if (   (err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                              0, 0,
                              &cb, (BYTE **) &pLocalDN))
        || (err = DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &itLocal,
                              sizeof(itLocal), NULL))
        || (err = DBGetAttVal(pTHS->pDB, 1, ATT_REPL_PROPERTY_META_DATA, 0, 0,
                              &cb, (BYTE **) &pLocalMetaDataVec))) {
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    Assert(ISVALIDINSTANCETYPE(itLocal));

    if ((itInbound & IT_NC_HEAD) && (itLocal & IT_NC_HEAD)) {
        // Name collision on two NC heads (each either the head of the NC we're
        // replicating or a SUBREF thereof) -- Very Bad News.  This will require
        // some sort of admin intervention.
        // This may happen under the following conditions in the lab:
//[Jeff Parham]  This is mostly here to detect the case where a domain is created
//simultaneously on two different DCs, so we end up with two NC heads with the same
//name but different SIDs/GUIDs.  This is much less likely than it used to be, now
//that we have a domain naming FSMO, but might still be good to keep around.  The
//only pseudo-legitimate case where this can happen is when a child domain has been
//removed and recreated and the local machine has seen neither the crossRef removal
//from the config container nor the deletion of the subref.
//Replication of this NC from this source should not proceed until the NCs are
//properly sorted out.  Failing and replicating the config NC would likely allow the
//next replication cycle for this NC/source to succeed.

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_NC_HEAD_NAME_CONFLICT,
                 szInsertDN(*ppInboundDN),
                 szInsertUUID(&(*ppInboundDN)->Guid),
                 NULL);
        return;
    }

    LocalDNT = pTHS->pDB->DNT;

    // We have to rename one of the two objects -- which one?
    if (itInbound & IT_NC_HEAD) {
        // Local object is an interior node, inbound object is an NC head.
        // Give the name to the NC head.
        fRenameInboundObject = FALSE;
    }
    else if (itLocal & IT_NC_HEAD) {
        // Local object is an NC head, inbound object is an interior node.
        // Give the name to the NC head.
        fRenameInboundObject = TRUE;
    }
    else {
        // Both objects are interior nodes.  Let the object which assumed the
        // name last keep it.

        // This assertion only applies to interior nodes. Infrequently there may arise
        // collisions between an nc head if a domain has been deleted and recreated.
        Assert((itInbound & IT_WRITE) == (itLocal & IT_WRITE));

        // Get the meta data for the local object's RDN.
        pLocalMetaData = ReplLookupMetaData(ATT_RDN, pLocalMetaDataVec, NULL);
        Assert(NULL != pLocalMetaData);

        // Get the meta data for the inbound object's RDN.
        pInboundMetaData = ReplLookupMetaData(ATT_RDN, pInboundMetaDataVec, NULL);
        Assert(NULL != pInboundMetaData);

        if ((pLocalMetaData->timeChanged > pInboundMetaData->timeChanged)
            || ((pLocalMetaData->timeChanged == pInboundMetaData->timeChanged)
                && (memcmp(&pLocalDN->Guid, &(*ppInboundDN)->Guid, sizeof(GUID))
                    > 0))) {
            // Local object named last OR both objects named at the same time
            // and the local object has a higher objectGuid.  The local object
            // keeps the original name.
            fRenameInboundObject = TRUE;
        }
        else {
            // Otherwise the inbound object keeps the original name.
            fRenameInboundObject = FALSE;
        }
    }

    if (fRenameInboundObject) {
        pLosingDN = *ppInboundDN;

        // Note that we munge pInboundRDN in-place, since the caller may have
        // embedded references to it (e.g., in an ADDARG for the inbound object)
        // and we want those references to refer to the new RDN rather than to
        // the old one.
        pNewRDN = pInboundRDN;
    }
    else {
        pLosingDN = pLocalDN;

        // Note that we copy pInboundRDN first rather than munging it in-place,
        // since the caller may have embedded references to it (e.g., in an
        // ADDARG for the inbound object) and we want those references to remain
        // to the old RDN rather than to the new one.
        pNewRDN = THAllocEx(pTHS, sizeof(ATTR));
        bNewRDNAllocd = TRUE;
        DupAttr(pTHS, pInboundRDN, pNewRDN);
    }

    // Construct the new RDN.
    ReplMorphRDN(pTHS, pNewRDN, &pLosingDN->Guid);

    // Inform admins of the name change.
    if (NULL == pCurrentDN) {
        // Collision while adding an object that does not yet exist locally.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_NAME_CONFLICT_ON_ADD,
                  szInsertDN(*ppInboundDN),
                  szInsertUUID(&(*ppInboundDN)->Guid),
                  szInsertUUID(&pLocalDN->Guid),
                  szInsertWC2(pNewRDN->AttrVal.pAVal->pVal,
                              pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR)),
                  szInsertUUID(&pLosingDN->Guid),
                  NULL, NULL, NULL);
    }
    else {
        // Collision while renaming an object that already exists locally.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_NAME_CONFLICT_ON_RENAME,
                  szInsertDN(pCurrentDN),
                  szInsertUUID(&(*ppInboundDN)->Guid),
                  szInsertDN(*ppInboundDN),
                  szInsertUUID(&pLocalDN->Guid),
                  szInsertWC2(pNewRDN->AttrVal.pAVal->pVal,
                              pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR)),
                  szInsertUUID(&pLosingDN->Guid),
                  NULL, NULL);
    }

    // Clear the name collision error.
    THClearErrors();

    if (fRenameInboundObject) {
        // Change the name of the inbound object.
        SpliceDN(pTHS,
                    *ppInboundDN,
                    pParentDN,
                    (WCHAR *) pNewRDN->AttrVal.pAVal->pVal,
                    pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR),
                    RDNType,
                    ppInboundDN);

        if (itInbound & IT_WRITE) {
            // Writeable NC.  Flag the meta data such that the name change is
            // replicated back out to other DSAs.
            ReplOverrideMetaData(ATT_RDN, pInboundMetaDataVec);
        }
        else {
            // Read-only NC.  Flag the meta data such that our temporary rename
            // will unilaterally lose compared to a "real" rename from a
            // writeable source.
            ReplUnderrideMetaData(pTHS, ATT_RDN, &pInboundMetaDataVec, NULL);
        }
    }
    else {
        // Change the name of the pre-existing local object.
        MODIFYDNARG modDNArg;
        MODIFYDNRES modDNRes;

        memset(&modDNArg, 0, sizeof(modDNArg));
        memset(&modDNRes, 0, sizeof(modDNRes));

        // Pass class-specific RDN to LocalModifyDN().
        pNewRDN->attrTyp = RDNType;

        modDNArg.pObject = pLocalDN;
        modDNArg.pNewRDN = pNewRDN;
        InitCommarg(&modDNArg.CommArg);

        if (err = DBFindDNT(pTHS->pDB, LocalDNT)) {
            // The local object was there a second ago....
            DRA_EXCEPT(DRAERR_DBError, err);
        }

        modDNArg.pResObj = CreateResObj(pTHS->pDB, pLocalDN);

        if (!(itInbound & IT_WRITE)) {
            // Read-only NC.  Flag the meta data such that our temporary rename
            // will unilaterally lose compared to a "real" rename from a
            // writeable source.
            ReplUnderrideMetaData(pTHS,
                                  ATT_RDN,
                                  &modDNArg.pMetaDataVecRemote,
                                  NULL);
        }

        if (LocalModifyDN(pTHS, &modDNArg, &modDNRes)) {
            // Rename failed; bail.
            DRA_EXCEPT(RepErrorFromPTHS(pTHS), 0);
        }

        // Clean up allocations we no longer need.
        THFreeEx(pTHS, modDNArg.pResObj);
        THFreeEx(pTHS, pNewRDN->AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pNewRDN->AttrVal.pAVal);

        // Commit the rename.
        DBTransOut(pTHS->pDB, TRUE, TRUE);
        DBTransIn(pTHS->pDB);
    }

    if(bNewRDNAllocd && pNewRDN != NULL) THFreeEx(pTHS, pNewRDN);

    // Retry the operation that evoked the collision, which should succeed now
    // that we've altered the name of one of the conflicting objects.
    *pfRetryUpdate = TRUE;
} // end draHandleNameCollision()


void
SetRepIt(
    IN      THSTATE *           pTHS,
    IN OUT  ENTINF *            pent,
    IN      BOOL                fNCPrefix,
    IN      BOOL                writeable,
    IN      int                 FindAliveStatus,
    OUT     SYNTAX_INTEGER *    pitCurrent,
    OUT     SYNTAX_INTEGER *    pitOut,
    OUT     BOOL *              piTypeModified
    )
/*++

Routine Description:

    Translate inbound instance type into a local instance type.

Arguments:

    pTHS (IN)

    pent (IN OUT) - The inbound object.  If the calculated local instance type
        differs from the inbound remote instance type, the embedded remote value
        is replace with the local value.

    fNCPrefix (IN) - Is this the inbound object the head of the NC being
        replicated?

    writeable (IN) - Is the NC being replicated locally writeable?

    pitCurrent (OUT) - If the object already exists locally, on return holds the
        current instance type of the local object (i.e., as it existed prior to
        replicating in this update).

    pitOut (OUT) - On return holds the calculated instance type.

    piTypeModified (OUT) - On return holds TRUE if the object already exists
        locally and the calculated instance type differs from the pre-existing
        instance type.  Otherwise, holds FALSE.

Return Values:

    None.  Throws DRA exception on error.

--*/
{
    DBPOS *         pDB = pTHS->pDB;
    ATTR *          pAttr;
    SYNTAX_INTEGER  itHere;
    SYNTAX_INTEGER  itThere;
    SYNTAX_INTEGER  itHereInitial;
    ULONG           ret;
    ULONG           dntObj = pDB->DNT;
    BOOL            fIsLocalObjPresent;

    // Anticipate likeliest outcome.
    *piTypeModified = FALSE;

    fIsLocalObjPresent = (FindAliveStatus == FIND_ALIVE_FOUND)
                         || (FindAliveStatus == FIND_ALIVE_OBJ_DELETED);

    if (fIsLocalObjPresent) {
        // Read the current instance type for the local object.
        Assert(CheckCurrency(pent->pName));
        GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &itHere, sizeof(itHere));
        Assert(ISVALIDINSTANCETYPE(itHere));
        *pitCurrent = itHere;
    }

    // Get instance type of object on source DSA.
    if (AttrValFromAttrBlock(&pent->AttrBlock, ATT_INSTANCE_TYPE, &itThere,
                             &pAttr)) {
        // Instance type is not present in the inbound replication stream.
        if (fIsLocalObjPresent) {
            // 'Salright -- we have the instance type we calculated for this
            // object in the past.
            *pitOut = *pitCurrent;
            Assert(!*piTypeModified);
            return;
        } else {
            // We don't have enough data to create this object.
            DraErrMissingObject(pTHS, pent);
        }
    }

    // Ignore future inbound instance type bits our DSA version doesn't
    // understand.
    itThere &= IT_MASK_CURRENT;

    Assert(ISVALIDINSTANCETYPE(itThere));

    if (fNCPrefix && !FPrefixIt(itThere)) {
        // The NC root at the source does not have an NC root instance type.
        DraErrCannotFindNC(pent->pName);
    }

    if (fIsLocalObjPresent) {
        // Save initial instance type.
        itHereInitial = itHere;

        if (fNCPrefix) {
            // This is the head of the NC we're replicating, which already
            // exists locally.
            switch (itHere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // We're replicating in the NC head, but locally this object is
                // marked as an interior node.  This should never happen.
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;

            case NC_MASTER_GOING:
            case NC_FULL_REPLICA_GOING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF_GOING:
                // Local NC is in the process of being torn down.  We should
                // never get here, as an NC in this state should never have
                // repsFroms and DRA_ReplicaAdd() would have already bailed out.
                Assert(!"Inbound NC is being torn down locally!");
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;

            case SUBREF:
                // Local object is a pure subref; upgrade it to be instantiated.
                itHere = writeable ? NC_MASTER_SUBREF_COMING
                                   : NC_FULL_REPLICA_SUBREF_COMING;
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
                if (!writeable) {
                    // We're ostensibly populating a read-only NC but the
                    // instance type of the local NC head says it's writeable?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // Else current local instance type is fine; leave as-is.
                break;

            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
                if (writeable) {
                    // We're ostensibly populating a writeable NC but the
                    // instance type of the local NC head says it's read-only?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // Else current local instance type is fine; leave as-is.
                break;

            default:
                // Local instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;
            }
        } else {
            // This is an object other than the head of the NC we're currently
            // replicating and it already exists locally.
            switch (itHere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // The local object is a regular interior node.
                if (FExitIt(itThere)) {
                    // The source says this object is an exit point, but we
                    // believe it is an interior node.  This should never
                    // happen.
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                } else if ((INT_MASTER == itHere)
                           && (INT_FULL_REPLICA == itThere)) {
                    // The local object is writeable but the source is read-
                    // only.  This should never happen.
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                } else if (itHere != (writeable ? INT_MASTER : INT_FULL_REPLICA)) {
                    // One way this can occur if the source has the object in the
                    // current NC, but the destination has had the object cross domain
                    // moved to another NC on the machine of different writeability.
                    DPRINT1( 0, "Writeability of object %ls differs between that of the NC"
                             " and that of the object locally as found by GUID. Has object"
                             " been cross-domain moved?", pent->pName->StringName );
                    DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                }
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_GOING:
            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_GOING:
                // The local object is a child NC of the NC we're replicating
                // but its instance type does not yet reflect that (probably
                // because we are in the process of instantiating its parent NC
                // on the local DSA for the first time).  Add the "NC above"
                // bit.
                itHere |= IT_NC_ABOVE;
                // fall through...

            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
            case NC_FULL_REPLICA_SUBREF_GOING:
            case SUBREF:
                // The local object is an NC head of some sort (instantiated or
                // not).
                if (!FExitIt(itThere)) {
                    // The source DSA does not think this object corresponds to
                    // a different NC?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // Else value of itHere is fine.
                break;

            default:
                // Local instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;
            }
        }

        if (itHere != itHereInitial) {
            *piTypeModified = TRUE;
        }
    } else {
        // Object does not yet exist in the local DS.
        itHere = itThere;

        if (fNCPrefix)  {
            // This is the head of the NC we're replicating, and it does not
            // yet exist locally.  The local instance type of this object
            // depends on whether the parent NC has been instantiated on this
            // DSA.

            DSNAME * pParent = THAllocEx(pTHS, pent->pName->structLen);
            SYNTAX_INTEGER itParent;

            if (TrimDSNameBy(pent->pName, 1, pParent)
                || IsRoot(pParent)
                || DBFindDSName(pDB, pParent)
                || (GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &itParent,
                                      sizeof(itParent)),
                    (itParent & IT_UNINSTANT))) {
                // The parent NC is not instantiated on this DSA,
                itHere = writeable ? NC_MASTER_COMING : NC_FULL_REPLICA_COMING;
            } else {
                Assert(!DBIsObjDeleted(pDB)
                       && "Instantiated NCs can't be deleted!");
                itHere = writeable ? NC_MASTER_SUBREF_COMING
                                   : NC_FULL_REPLICA_SUBREF_COMING;
            }

            THFreeEx(pTHS, pParent);
        } else {
            // This is an object other than the head of the NC we're
            // replicating, and it does not yet exist locally.
            switch (itThere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // The inbound object is a regular interior node, as will be
                // the local instantiation of that object.
                if (writeable && (INT_FULL_REPLICA == itThere)) {
                    // We're performing writeable NC replication but the object
                    // on the source DSA is marked as read-only.  This should
                    // never happen.
                    DraErrInappropriateInstanceType(pent->pName, itThere);
                }
                itHere = writeable ? INT_MASTER : INT_FULL_REPLICA;
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_GOING:
            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_GOING:
                // The object on the source DSA is an NC head, but it should be
                // some sort of subref and is not flagged as such.
                DraErrInappropriateInstanceType(pent->pName, itThere);
                break;

            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
            case NC_FULL_REPLICA_SUBREF_GOING:
            case SUBREF:
                // The object on the source DSA is some sort of subref; locally
                // it will be a pure subref.
                itHere = SUBREF;
                break;

            default:
                // remote instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itThere);
                break;
            }
        }
    }

    Assert(ISVALIDINSTANCETYPE(itHere));
    *pitOut = itHere;

    memcpy(pAttr->AttrVal.pAVal->pVal, &itHere, sizeof(SYNTAX_INTEGER));

    // Currency should be on the local copy of this object, if any.
    Assert(!fIsLocalObjPresent || (pDB->DNT == dntObj));
}

/* CheckProxyStatus - Determines whether an object is a legitimate proxy
*  object and/or whether it just has an ATT_PROXIED_OBJECT_NAME property.
*
*       pent        - data for object
*       pfIsProxy   - return value indicating if full fledged proxy object
*       ppProxyVal  - return value indicating address of proxy value if present
*
*  Returns:
*       TRUE if the attribute is present, else FALSE.
*/
VOID
CheckProxyStatus(
    ENTINF                  *pent,
    USHORT                  DeletionStatus,
    BOOL                    *pfIsProxy,
    SYNTAX_DISTNAME_BINARY  **ppProxyVal
    )
{
    ATTRBLOCK   AttrBlock = pent->AttrBlock;
    ULONG       AttrCount = pent->AttrBlock.attrCount;
    ULONG       i;
    BOOL        fClass = FALSE;

    *pfIsProxy = FALSE;
    *ppProxyVal = NULL;

    for ( i = 0; i < AttrCount; i++ )
    {
        if ( ATT_PROXIED_OBJECT_NAME == AttrBlock.pAttr[i].attrTyp )
        {
            Assert(1 == AttrBlock.pAttr[i].AttrVal.valCount);
            *ppProxyVal = (SYNTAX_DISTNAME_BINARY *)
                                    AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            continue;
        }

        if (    (ATT_OBJECT_CLASS == AttrBlock.pAttr[i].attrTyp)
             && (CLASS_INFRASTRUCTURE_UPDATE ==
                        * (DWORD *) AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal) )
        {
            fClass = TRUE;
            continue;
        }
    }

    *pfIsProxy = (    fClass
                   && (NULL != *ppProxyVal)
                   && (OBJECT_BEING_DELETED == DeletionStatus) );
}

/* PreProcessProxyInfo - Resolve conflicts related to adding a cross
 *  domain moved object (identified by existence of ATT_PROXIED_OBJECT_NAME
 *  on add) when an object with the same GUID already exists on this machine.
 *
 *  This routine is checking whether the local object is some form of moved object:
 *  a) A live pre-move object           (no proxy nor moved object)
 *  b) A phantomized pre-move object    (proxy but no moved object)
 *  c) A live post-move object          (moved object arrived)
 *  d) A phantomized post-move object   (moved object arrived)
 *
 *  This routine is called when any object except a proxy object is about to
 *  to be updated during replication.  Whether or not the incoming object is
 *  a cross domain moved object (c) is determined by whether it has a proxy value
 *  or not.
 *
 *  Note that ATT_PROXIED_OBJECT_NAME is always shipped on objects which have this
 *  attribute when they are modified.  It becomes a form of secondary metadata
 *  containing the move-epoch for this object.  Thus any modifications of moved
 *  objects are guaranteed to compare correctly.
 *
 *  The update could be an creation, modification or deletion.
 */
ULONG
PreProcessProxyInfo(
    THSTATE                     *pTHS,
    ENTINF                      *pent,
    SYNTAX_DISTNAME_BINARY      *pProxyVal,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    PROPERTY_META_DATA_VECTOR   **ppMetaDataVecLocal,
    BOOL                        *pfContinue)
{
    DWORD                   dwErr;
    DWORD                   localEpoch;
    DWORD                   incomingEpoch;
    SYNTAX_DISTNAME_BINARY  *pLocalProxyVal;
    ULONG                   len;
    DSNAME                  *pLocalDN;
    int                     diff;
    PROPERTY_META_DATA      *pMetaLocal;
    PROPERTY_META_DATA      *pMetaRemote;
    DWORD                   verLocal;
    DWORD                   verRemote;
    DWORD                   proxyEpoch;
    BOOL                    fProxyFound;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!fNullUuid(&pent->pName->Guid));
    Assert(pMetaDataVecRemote && !*ppMetaDataVecLocal);

    *pfContinue = TRUE;

    // Get the epoch numbers of the local and incoming objects.

    incomingEpoch = (pProxyVal ? GetProxyEpoch(pProxyVal) : 0);

    switch ( dwErr = DBFindDSName(pTHS->pDB, pent->pName) )
    {
    case 0:

        // We have it as a real object - derive its epoch number.

        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pLocalProxyVal);
        switch ( dwErr )
        {
        case 0:
            localEpoch = GetProxyEpoch(pLocalProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            localEpoch = 0;
            break;
        default:
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }
        break;

    case DIRERR_NOT_AN_OBJECT:

        // We have it as a phantom.  It should not have a proxy value.
        // If the proxy object has not arrived yet, there is some ambiguity as
        // to whether the phantom is of the pre-move or post-move object.  The post-
        // move object might have been phantomized due to GC demotion or another
        // cross-domain move.  If we don't have a proxy object, there isn't enough
        // information on the phantom to divine what epoch it is from, so we don't try.
        // It is possible that the phantom may be in a different nc than the one
        // we are currently operating on.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pLocalProxyVal));

        // There are two reasons we might have a phantom for an object in
        // the domain we are authoritative for.
        //
        // 1) Consider 3 replicas of this domain A, B and C where we are B.
        //    Object X was cross domain moved off of A, A created a proxy for X,
        //    the proxy replicated to B, and B phantomized X.  Now C for some
        //    reason re-plays the add of X to B.  B needs to determine if
        //    X ever existed in the domain in order to know whether to accept
        //    the add of X.  C may also send modifications to X, which need
        //    to be suppressed.
        //
        // 2) Consider the case where we are authoritatively restored and thus
        //    re-introduce objects which were moved ex-domain after the backup.
        //    Our objects will be phantomized as we replicate in the proxies
        //    from other replicas.  But other replicas need to reject the
        //    re-introduced objects for all replicas to be consistent.
        //    See spec\nt5\ds\xdommove.doc for authoritative restore details.
        //
        // Except in the install case, where we take everything as gospel ...

        if ( !DsaIsInstalling() )
        {
            if ( dwErr = DBFindBestProxy(pTHS->pDB, &fProxyFound, &proxyEpoch) )
            {
                DRA_EXCEPT(DRAERR_InternalError, dwErr);
            }

            if ( fProxyFound )
            {
                // Proxy objects get the pre-move epoch number of the moved
                // object.  So the incoming object wins only if its epoch is
                // greater than the proxy's epoch.

                if ( proxyEpoch >= incomingEpoch )
                {
                    *pfContinue = FALSE;
                    return(0);
                }
            }

        }

        // Fall through ...

    case DIRERR_OBJ_NOT_FOUND:

        // Consider this an add - this should jive with what caller thought too.

        *pfContinue = TRUE;
        return(0);

    default:

        DRA_EXCEPT(DRAERR_InternalError, dwErr);
    }

    if ( localEpoch > incomingEpoch )
    {
        // Local object is a newer incarnation than incoming object - don't
        // apply incoming update.  One might think that metadata handling
        // would do the right thing, but consider that if the epochs are
        // different, then these represent two distinct object creations
        // whose metadata is not comparable.  We don't need to create a proxy
        // for the incoming domain/object since there must be one already
        // else we wouldn't already have a local object with a higher epoch
        // number.  I.e. The proxy exists - its just that the remote add in
        // the new domain got here before this modify.

        *pfContinue = FALSE;
        return(0);
    }
    else if ( incomingEpoch > localEpoch )
    {
        // Incoming object is a newer incarnation than the local object -
        // therefore we prefer it.  Turn the existing object into a phantom
        // and process the modify as an add instead.

        if ( dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                 0, 0, &len, (UCHAR **) &pLocalDN) )
        {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        if ( dwErr = PhantomizeObject(pLocalDN, pLocalDN, TRUE) )
        {
            return(Win32ErrorFromPTHS(pTHS));
        }

        *pfContinue = TRUE;
        return(0);
    }

    // Both local and incoming objects have the same epoch numbers - this
    // could occur for two reasons.
    //
    // 1)   Incoming data is a replay of data we already have locally and
    //      there is no duplicity of epoch numbers - see item (2).  In
    //      this case the two object's metadata are comparable and we let
    //      the modify proceed and regular metadata processing do its thing.
    //
    // 2)   The logic of GetProxyObjects() is not working.  Consider
    //      two replicas of domain A.  Let (guid,A,0) represent an object with
    //      GUID guid, in domain A, with epoch number 0.  If the FSMO logic
    //      is broken, then the two respective replicas of A could contrive
    //      to both move the object such that we might have (guid,B,1) and
    //      (guid,C,1) concurrently in the system.  This should not happen,
    //      but we don't want replication to stop if it does.  Indeed, there's
    //      no immediate problem if two DCs for two distinct domains which are
    //      not GCs have an object with the same GUID.  The problem is on
    //      GCs where we need to pick one of the objects.  In this case we
    //      prefer the object the normal conflict resolution would if
    //      the version info were the same.  I.e. We wish to base conflict
    //      resolution on time and originating DSA UUID alone.
    //
    // For both cases then, we need to check the ATT_PROXIED_OBJECT_NAME
    // metadata.  The one exception is the when the epoch numbers are zero
    // as this value is never written, and thus by definition, we're dealing
    // with identical objects.

    Assert(localEpoch == incomingEpoch);

    if ( 0 == localEpoch )
    {
        *pfContinue = TRUE;
        return(0);
    }

    // Dig out the respective metadata - we're still positioned on the
    // local object so can just read immediately.

    if (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_REPL_PROPERTY_META_DATA,
                                 0, 0, &len, (UCHAR **) ppMetaDataVecLocal))
         || !(pMetaLocal = ReplLookupMetaData(ATT_PROXIED_OBJECT_NAME,
                                              *ppMetaDataVecLocal, NULL))
         || !(pMetaRemote = ReplLookupMetaData(ATT_PROXIED_OBJECT_NAME,
                                               pMetaDataVecRemote, NULL)) )
    {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    // Temporarily whack the version info so that we can reconcile on
    // time and originating DSA UUID only.

    verLocal = pMetaLocal->dwVersion;
    verRemote = pMetaRemote->dwVersion;
    _try
    {
        pMetaLocal->dwVersion = 1;
        pMetaRemote->dwVersion = 1;
        diff = ReplCompareMetaData(pMetaLocal, pMetaRemote);
    }
    _finally
    {
        pMetaLocal->dwVersion = verLocal;
        pMetaRemote->dwVersion = verRemote;
    }

    switch ( diff )
    {
    case 1:

        // Local object won.
        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                0, 0, &len, (UCHAR **) &pLocalDN)) {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        *pfContinue = FALSE;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DUPLICATE_MOVED_OBJECT,
                 szInsertDN(pent->pName),
                 szInsertDN(pLocalDN),
                 szInsertUUID(&pLocalDN->Guid));
        break;

    case 0:

        // Local and remote are identical.
        *pfContinue = TRUE;
        break;

    case -1:

        // Remote object won - same as (incomingEpoch > localEpoch) case.

        if ( dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                 0, 0, &len, (UCHAR **) &pLocalDN) )
        {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        if ( dwErr = PhantomizeObject(pLocalDN, pLocalDN, TRUE) )
        {
            return(Win32ErrorFromPTHS(pTHS));
        }

        // We have now phantomized the existing local object, eliminating the
        // local meta data.
        THFreeEx(pTHS, *ppMetaDataVecLocal);
        *ppMetaDataVecLocal = NULL;

        *pfContinue = TRUE;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DUPLICATE_MOVED_OBJECT,
                 szInsertDN(pent->pName),
                 szInsertDN(pLocalDN),
                 szInsertUUID(&pLocalDN->Guid));
        break;

    default:

        Assert(!"Error in ReplCompareMetaData");
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    return(0);
}

/* ProcessProxyObject - Processes the ATT_PROXIED_OBJECT_NAME attribute
*  on a proxy object resulting from a cross domain move.  A proxy object
*  is a special deleted object in the Infrastructure container than indicates
*  where an object used to be.
*
*  Returns:
*       0 if successful, a DRAERR_* error otherwise.
*/
ULONG
ProcessProxyObject(
    THSTATE                 *pTHS,
    ENTINF                  *pent,
    SYNTAX_DISTNAME_BINARY  *pProxyVal
    )
{
    DSNAME                  *pGuidOnlyDN = NULL;
    DSNAME                  *pProxyDN = NULL;
    DSNAME                  *pProxiedDN = NULL;
    DWORD                   cb;
    DWORD                   dwErr;
    COMMARG                 commArg;
    CROSS_REF               *pProxyNcCr = NULL;
    BOOL                    fPhantomize = FALSE;
    ULONG                   i, j, len;
    DSNAME                  *pDN = NULL;
    DSNAME                  *pAccurateOldDN;
    CROSS_REF               *pCR;
    SYNTAX_DISTNAME_BINARY  *pLocalProxyVal;
    DWORD                   incomingEpoch;
    DWORD                   localEpoch;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    // First some clarification of what got us to this point.  A cross domain
    // move has been performed where an object was moved from domain 1 (our
    // domain) to domain 2.  The original operations which occured were:
    //
    // @Dst (some replica of domain 2): O(g1,sx,sn2) was added
    // @Src (some replica of domain 1): O(g1,s1,sn1) was morphed to
    //  P(g1,s1,sn2) where 'P' indicates a phantom.
    // @Src (some replica of domain 1): O(g2,sx,sn3) was added as a proxy
    //
    // The ATT_PROXIED_OBJECT_NAME in pent holds (g1,s1,sn2).

    pProxyDN = pent->pName;
    pProxiedDN = NAMEPTR(pProxyVal);

    // Proxy and proxied objects must both have string names.
    Assert(pProxyDN->NameLen);
    Assert(pProxiedDN->NameLen);

    // Proxy and proxied objects must both have guids.
    Assert(!fNullUuid(&pProxyDN->Guid));
    Assert(!fNullUuid(&pProxiedDN->Guid));

    // Proxy value should identify this as a proxy.
    Assert(PROXY_TYPE_PROXY == GetProxyType(pProxyVal));

    InitCommarg(&commArg);
    pProxyNcCr = FindBestCrossRef(pProxyDN, &commArg);
    Assert(pProxyNcCr);

    // Construct GUID-only DSNAME for g1 (the moved object) and see what
    // kind of object we already have for it.

    cb = DSNameSizeFromLen(0);
    pGuidOnlyDN = (DSNAME *) THAllocEx(pTHS, cb);
    memset(pGuidOnlyDN, 0, cb);
    memcpy(&pGuidOnlyDN->Guid, &pProxiedDN->Guid, sizeof(GUID));
    pGuidOnlyDN->structLen = cb;

    switch ( dwErr = DBFindDSName(pTHS->pDB, pGuidOnlyDN) )
    {
    case 0:

        // We have O(g1) as a real object.  Further action depends on
        // what domain (NC) this object is in - so get that now.
        // We also need a currently correct string name for PhantomizeObject.

        if (    DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                            0, 0, &len, (UCHAR **) &pAccurateOldDN)
             || !(pCR = FindBestCrossRef(pAccurateOldDN, &commArg))
             || !pProxyNcCr )
        {
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Get epoch values.

        incomingEpoch = GetProxyEpoch(pProxyVal);
        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pLocalProxyVal);
        switch ( dwErr )
        {
        case 0:
            localEpoch = GetProxyEpoch(pLocalProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            localEpoch = 0;
            break;
        default:
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // pCR represents the NC of the proxied object found by GUID.
        // pProxyNcCr represents the NC we are replicating

        if ( NameMatched(pCR->pNC, pProxyNcCr->pNC) )
        {
            // Object we found is in the same NC that we're replicating - thus
            // we're authoritive for it on this replication cycle and can
            // phantomize it if we feel that's warrannted.  Epoch value on
            // proxy is always the epoch value of the object before it was
            // moved, thus local phantomization is required if incoming epoch
            // is greater or equal the local epoch.

            if ( incomingEpoch >= localEpoch )
            {
                fPhantomize = TRUE;

                // If incoming epoch is actually greater than local epoch, then
                // it must mean that the object moved out of the NC and back
                // again, else the epochs would be equal.  In that case, then
                // the incoming epoch must be at least 2 greater than the
                // local epoch to account for the move out and move back in.

                Assert( (incomingEpoch > localEpoch)
                            ? (incomingEpoch - localEpoch) >= 2
                            : TRUE);
                break;
            }
            else
            {
                // Local object is newer with respect to cross domain moves
                // than the inbound proxy - nothing to do.

                return(0);
            }
        }
        else
        {
            // Object we found is not in the same NC that we're replicating -
            // thus we are not authoritive for it - nothing to do.  However,
            // we know it used to be in the NC we are replicating by virtue
            // of the fact that this NC has a proxy object for it.  So we can
            // assert that the epoch numbers must be different.

            if (incomingEpoch == localEpoch) {
                LogEvent8(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DUPLICATE_MOVED_OBJECT_CLEANUP,
                          szInsertUUID(&pProxiedDN->Guid),
                          szInsertDN(pAccurateOldDN),
                          szInsertDN(pProxiedDN),
                          szInsertUL(incomingEpoch),
                          NULL, NULL, NULL, NULL );
            }
            return(0);
        }

        break;

    case DIRERR_NOT_AN_OBJECT:

        // We have P(g1) as a phantom - should we fix its name?  We could,
        // but since phantoms don't have an ATT_PROXIED_OBJECT_NAME value,
        // we can't tell if the inbound name is any better than the local
        // name.  The stale phantom cleanup daemon should take care of it
        // eventually.  However, we can assert on the lack of a proxy value.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pLocalProxyVal));
        return(0);
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Don't have the object in any form - nothing to do.
        return(0);

    default:

        // Some kind of lookup error.
        DRA_EXCEPT(DRAERR_DBError, dwErr);
    }

    if ( fPhantomize )
    {
        // Construct string name only DSNAME of phantom we want.
        pDN = (DSNAME *) THAllocEx(pTHS, pProxiedDN->structLen);
        memset(pDN, 0, pProxiedDN->structLen);
        pDN->structLen = pProxiedDN->structLen;
        pDN->NameLen = pProxiedDN->NameLen;
        wcscpy(pDN->StringName, pProxiedDN->StringName);

        dwErr = PhantomizeObject(pAccurateOldDN, pDN, TRUE);
        Assert(dwErr == pTHS->errCode);
        return(RepErrorFromPTHS(pTHS));
    }

    if(pGuidOnlyDN != NULL) THFreeEx(pTHS, pGuidOnlyDN);
    if(pDN != NULL) THFreeEx(pTHS, pDN);

    return(0);
} // end ProcessProxyObject()


VOID
GcCleanupUniversalGroupDemotion(
    THSTATE *pTHS,
    DSNAME *pDN,
    ATTRBLOCK *pAttrBlock,
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal
    )

/*++

Routine Description:

GC Cleanup. Cleanup a group that is no longer universal by removing its
memberships.

Normally, group filtering occurs at the source (see dragtchg.c,
IsFilterGroupMember, and drameta.c, ReplFilterPropsToShip).  In the case of
a universal group demotion, filtering at the source will not be enough to allow
the GC destination to delete the unneeded memberships.

Arguments:

    THSTATE *pTHS,
    ATTRBLOCK *pAttrBlock,
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal

Return Value:

    None

--*/

{
    DWORD retErr;
    SYNTAX_INTEGER newGroupType, oldGroupType, class, it;
    ATTCACHE *pAC;

    Assert(VALID_THSTATE(pTHS));

    // We should still be positioned on the object
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pMetaDataVecLocal);

    // Current object class should be class GROUP
    // Current instance type should be INT_FULL_REPLICA
    // Member attr should NOT be present; it should have been filtered

    // Is this object of class group?
    // Is this a read-only internal object?
    // Is the group type being changed to non-universal?
    // Was the old value universal?
    if (
         (AttrValFromAttrBlock( pAttrBlock, ATT_GROUP_TYPE, &newGroupType, NULL ) != ATTR_PRESENT_VALUE_RETURNED ) ||
         (newGroupType & GROUP_TYPE_UNIVERSAL_GROUP) ||
         (DBGetSingleValue(pTHS->pDB, ATT_GROUP_TYPE, &oldGroupType,
                           sizeof(oldGroupType), NULL)) ||
         (!(oldGroupType & GROUP_TYPE_UNIVERSAL_GROUP))
        )
    {
        return;
    }

    pAC = SCGetAttById(pTHS, ATT_MEMBER);
    if (!pAC) {
        DRA_EXCEPT(DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }

    // Remove all links for the ATT_MEMBER attribute
    DBRemoveLinks_AC( pTHS->pDB, pAC );

    // GC cleanup of member metadata
    pTHS->fGCLocalCleanup = TRUE;
    __try {
        DBTouchMetaData( pTHS->pDB, pAC);
        DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);
    } __finally {
        pTHS->fGCLocalCleanup = FALSE;
    }

    DPRINT1( 1, "gcCleanupUniversalGroupDemotion: deleting memberships for group %ws\n", pDN->StringName );
}


DWORD
UpdateRepValue(
    THSTATE *pTHS,
    ULONG dntNC,
    ULONG RepFlags,
    BOOL fObjectCurrency,
    REPLVALINF *pReplValInf,
    DWORD *pdwUpdateValueStatus
    )

/*++

Routine Description:

Apply a single value

From the LVR spec, section on "Replication"

When you replicate the current state of an LVR row you send its name
(the object-guid of the containing object, the DSNAME of the target, and the
link ID), its isPresent value (where isPresent = (deletion-timestamp != 0)),
and its five metadata components. (Plus the value of "stuff" in an instance of
one of the "DN plus stuff" syntaxes.)

On a replicated write of a link-table row, the creation timestamp is used as
part of the normal metadata comparison. When comparing metadata, the items are
compared in order from left to right, with the left being most significant.
And there's an additional rule: legacy metadata always loses to LVR metadata.

The result of the metadata comparison is used just as it is today for attribute
updates: If the incoming row value's metadata loses the comparison the incoming
row value is discarded, otherwise the incoming row value completely replaces the
existing row value (including metadata.) If there's no existing row, no
comparison takes place and the incoming row value is used to initialize a new row.

When you replicate in a row with isPresent == false, you set the deletion timestamp
from the update timestamp of the incoming metadata. When you replicate in a row
with isPresent == true and the corresponding row is absent, that row becomes present:
its deletion timestamp is set to NULL.

Arguments:

    pTHS - thread state
    dntNC - dnt of NC of object and value
    pRepFlags - replication flags
    fObjectCurrency - Whether we still are positioned on object
    pReplValInf - Replication value to be applied
    pdwUpdateValueStutus - type of update performed
        UPDATE_NO_UPDATE, UPDATE_VALUE_UPDATE, UPDATE_VALUE_CREATION

Return Value:

   DWORD - success, or missing parent
   Exceptions raised

--*/

{
    DWORD ret, findAliveStatus, cchRDN, dntNCDNT;
    VALUE_META_DATA remoteValueMetaData;
    ATTCACHE *pAC;
    BOOL fPresent, fConflict;
    DSNAME *pdnValue;
    CHAR szTime1[SZDSTIME_LEN], szTime2[SZDSTIME_LEN];
    CHAR szUuid1[SZUUID_LEN], szUuid2[SZUUID_LEN];
    int iResult;
    WCHAR wchRDN[MAX_RDN_SIZE];
    GUID guidRDN;
    MANGLE_FOR mangleType;
    ATTRTYP attrtypRDN;

    *pdwUpdateValueStatus = UPDATE_NOT_UPDATED;

    // Get the attribute cache entry
    pAC = SCGetAttById(pTHS, pReplValInf->attrTyp);
    if (!pAC) {
        DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
    }

    // Get the DSNAME output of the ATTRVAL
    pdnValue = DSNameFromAttrVal( pAC, &(pReplValInf->Aval) );
    if (pdnValue == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }

    DPRINT4( 2, "UpdateRepValue, obj guid = %s, attr=%s, value = %ls, value guid=%s\n",
             DsUuidToStructuredString(&(pReplValInf->pObject->Guid), szUuid1),
             pAC->name,
             pdnValue->StringName,
             DsUuidToStructuredString(&(pdnValue->Guid), szUuid2),
             );

    // Convert metadata to internal form
    remoteValueMetaData.timeCreated = pReplValInf->MetaData.timeCreated;
    remoteValueMetaData.MetaData.attrType = pReplValInf->attrTyp;
    remoteValueMetaData.MetaData.dwVersion = pReplValInf->MetaData.MetaData.dwVersion;
    remoteValueMetaData.MetaData.timeChanged = pReplValInf->MetaData.MetaData.timeChanged;
    remoteValueMetaData.MetaData.uuidDsaOriginating =
        pReplValInf->MetaData.MetaData.uuidDsaOriginating;
    remoteValueMetaData.MetaData.usnOriginating =
        pReplValInf->MetaData.MetaData.usnOriginating;
    remoteValueMetaData.MetaData.usnProperty = 0; // not assigned yet

    Assert(!IsLegacyValueMetaData( &remoteValueMetaData ));

    //
    // Find containing object
    //

    if (!fObjectCurrency) {
        Assert( !fNullUuid( &(pReplValInf->pObject->Guid) ) );

        findAliveStatus = FindAliveDSName( pTHS->pDB, pReplValInf->pObject );
        switch (findAliveStatus) {
        case FIND_ALIVE_FOUND:
            break;
        case FIND_ALIVE_OBJ_DELETED:
            DPRINT( 2, "Object is already deleted, value not applied\n" );
            LogEvent( DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_EXTENSIVE,
                      DIRLOG_LVR_NOT_APPLIED_DELETED,
                      szInsertUUID( &(pReplValInf->pObject->Guid) ),
                      NULL, NULL );
            // nothing to do
            return ERROR_SUCCESS;
        case FIND_ALIVE_NOTFOUND:
            DPRINT( 2, "Object is not found, missing parent error\n" );
            // Missing parent, ie missing containing object

            if (RepFlags & DRS_GET_ANC) {
                // An object that has already been garbage collected?
                Assert( !"Value's containing obj is missing, even after get ancestors" );
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_LVR_NOT_APPLIED_MISSING2,
                          szInsertUUID( &(pReplValInf->pObject->Guid) ),
                          szInsertSz( pAC->name ),
                          szInsertDN( pdnValue ) );
                DRA_EXCEPT(DRAERR_InternalError, DRAERR_MissingParent);
            } else {
                // Containing object not included in same packet as value?
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_EXTENSIVE,
                          DIRLOG_LVR_NOT_APPLIED_MISSING,
                          szInsertUUID( &(pReplValInf->pObject->Guid) ),
                          szInsertSz( pAC->name ),
                          szInsertDN( pdnValue ) );
                // This is a "normal error" and not considered an exception
                return DRAERR_MissingParent;
            }
        default:
            Assert( !"Unexpected problem finding containing object" );
            DRA_EXCEPT(DRAERR_DBError, findAliveStatus);
        }

        // Make sure value's containing object is in the same NC
        if ((INVALIDDNT != dntNC)
            && (pTHS->pDB->NCDNT != dntNC)
            && (pTHS->pDB->DNT != dntNC)) {
            // The new parent object is in the wrong NC
            DPRINT1( 0, "Object %s is not in the NC being replicated. Value not applied.\n",
                     GetExtDN( pTHS, pTHS->pDB ) );
            DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
        }

    }

    //
    // We are now positioned on an object: we can use GetExtDN()
    //

    // Log remote metadata


    DPRINT5( 5, "{%s,%d,%s,%I64d,%s}\n",
             DSTimeToDisplayString(pReplValInf->MetaData.timeCreated, szTime1),
             pReplValInf->MetaData.MetaData.dwVersion,
             DsUuidToStructuredString(&pReplValInf->MetaData.MetaData.uuidDsaOriginating, szUuid1),
             pReplValInf->MetaData.MetaData.usnOriginating,
             DSTimeToDisplayString(pReplValInf->MetaData.MetaData.timeChanged, szTime2),
             );

    // Log the remote metadata
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               DIRLOG_LVR_REMOTE_META_INFO,
               szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
               szInsertUUID( &(pReplValInf->pObject->Guid) ),
               szInsertDN( pdnValue ),
               szInsertDSTIME(pReplValInf->MetaData.timeCreated, szTime1),
               szInsertUL(pReplValInf->MetaData.MetaData.dwVersion),
               szInsertUUID(&pReplValInf->MetaData.MetaData.uuidDsaOriginating),
               szInsertUSN(pReplValInf->MetaData.MetaData.usnOriginating),
               szInsertDSTIME(pReplValInf->MetaData.MetaData.timeChanged, szTime2)
        );

    // Check for tombstone name
    if (GetRDNInfo(pTHS, pdnValue, wchRDN, &cchRDN, &attrtypRDN)) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }
    if (IsMangledRDN( wchRDN, cchRDN, &guidRDN, &mangleType ) &&
        (mangleType == MANGLE_OBJECT_RDN_FOR_DELETION) ) {
        DPRINT1(0, "Value %ls has tombstone name, will not be applied\n",
                pdnValue->StringName );
        // Log that value references a tombstone
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_NOT_APPLIED_VALUE_DELETED,
                   szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                   szInsertUUID( &(pReplValInf->pObject->Guid) ),
                   szInsertSz( pAC->name ),
                   szInsertDN( pdnValue ),
                   szInsertUUID( &(pdnValue->Guid) ),
                   NULL, NULL, NULL );

        // nothing to do
        return ERROR_SUCCESS;
    }

    //
    // Position on value in order to check the local metadata
    //

    ret = DBFindAttLinkVal_AC(
        pTHS->pDB,
        pAC,
        pReplValInf->Aval.valLen,
        pReplValInf->Aval.pVal,
        &fPresent
        );
    if (DB_ERR_VALUE_DOESNT_EXIST == ret) {
        DPRINT3( 3, "Attribute %s value %ls present %d does not exist locally, will be applied\n",
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
        // Value does not exist in any form locally
        // The incoming value will be applied

        // It is ok for the incoming value to be absent. This just means the value
        // was added and removed remotely before we ever saw it.
        *pdwUpdateValueStatus = UPDATE_VALUE_CREATION;
    } else if (ERROR_DS_NO_DELETED_NAME == ret) {
        // The DN names an object that has been deleted locally. This can happen
        // since the incoming external form may have a GUID in it, thus allowing
        // a deleted DN to be found that way.  We should not receive an external
        // form stringname DN that is mangled.

        DPRINT1(3, "Value %ls is deleted locally, will not be applied\n",
                pdnValue->StringName );
        // Log that value references a tombstone
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_NOT_APPLIED_VALUE_DELETED,
                   szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                   szInsertUUID( &(pReplValInf->pObject->Guid) ),
                   szInsertSz( pAC->name ),
                   szInsertDN( pdnValue ),
                   szInsertUUID( &(pdnValue->Guid) ),
                   NULL, NULL, NULL );


        // nothing to do
        return ERROR_SUCCESS;
    } else if (ret) {
        // Error looking up value
        DRA_EXCEPT( DIRERR_DATABASE_ERROR, ret);
    } else {
        // Value exists locally, compare metadata to see if needed
        VALUE_META_DATA localValueMetaData;

        DPRINT4( 3, "Attribute %s value %ls present %d exist locally, fPresent=%d\n",
                 pAC->name, pdnValue->StringName,
                 pReplValInf->fIsPresent, fPresent );

        // Get value metadata
        DBGetLinkValueMetaData( pTHS->pDB, pAC, &localValueMetaData );

        // Do we need to apply this change?
        iResult = ReplCompareValueMetaData(
            &localValueMetaData,
            &remoteValueMetaData,
            &fConflict );

        if (fConflict) {
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_MINIMAL,
                       DIRLOG_LVR_CONFLICT,
                       szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                       szInsertUUID( &(pReplValInf->pObject->Guid) ),
                       szInsertSz( pAC->name ),
                       szInsertDN( pdnValue ),
                       szInsertUUID( &(pdnValue->Guid) ),
                       szInsertDSTIME(pReplValInf->MetaData.timeCreated, szTime1),
                       szInsertDSTIME(localValueMetaData.timeCreated, szTime2),
                       NULL
                );
        }

        if (iResult != -1) {

            DPRINT( 3, "Local value metadata is greater, value not applied\n" );

            // Log that value was not applied
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_EXTENSIVE,
                       DIRLOG_LVR_NOT_APPLIED_NOT_NEEDED,
                       szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                       szInsertUUID( &(pReplValInf->pObject->Guid) ),
                       szInsertSz( pAC->name ),
                       szInsertDN( pdnValue ),
                       szInsertUUID( &(pdnValue->Guid) ),
                       NULL, NULL, NULL );

            // Nothing to do
            IADJUST(pcDRASyncPropSame, 1 );
            return ERROR_SUCCESS;
        } else {
            DPRINT( 3, "Remote value metadata is greater, value applied\n" );
            *pdwUpdateValueStatus = UPDATE_VALUE_UPDATE;
        }

    } // end of if value exists locally

    //
    // We need to apply the change
    //

    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_LVR_APPLIED,
               szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
               szInsertUUID( &(pReplValInf->pObject->Guid) ),
               szInsertSz( pAC->name ),
               szInsertDN( pdnValue ),
               szInsertUUID( &(pdnValue->Guid) ),
               szInsertUL( pReplValInf->fIsPresent ),
               NULL, NULL );

    // Construct a call to modify
    modifyLocalValue(
        pTHS,
        pAC,
        pReplValInf->fIsPresent,
        &(pReplValInf->Aval),
        pdnValue,
        &remoteValueMetaData
        );

#if DBG
    if (*pdwUpdateValueStatus == UPDATE_VALUE_CREATION)
    {
        DPRINT4( 1, "Created object %s attr %s value %ws present %d\n",
                 GetExtDN( pTHS, pTHS->pDB ),
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
    }
    else if (*pdwUpdateValueStatus == UPDATE_VALUE_UPDATE) {
        DPRINT4( 1, "Updated object %s attr %s value %ws present %d\n",
                 GetExtDN( pTHS, pTHS->pDB ),
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
    }
#endif

    IADJUST(pcDRASyncPropUpdated, 1);
    // A DN-valued attribute.
    IADJUST(pcDRAInDNValues, 1);
    // DN-valued or not it gets added to the total.
    IADJUST(pcDRAInValues, 1);
    // Properties
    IADJUST(pcDRAInProps, 1);

    return ERROR_SUCCESS;
} /* UpdateRepValue */

ULONG
UpdateRepObj(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    ENTINF *                    pent,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    ULONG *                     pUpdateStatus,
    ULONG                       RepFlags,
    BOOL                        fNCPrefix,
    GUID *                      pParentGuid,
    BOOL                        fMoveToLostAndFound
    )
/*++

Routine Description:

    Perform any updates required to comply with the given inbound object data.

Arguments:

    pTHS

    dntNC (IN) - The DNT of the NC head of the NC being replicated, or
        INVALIDDNT if that object has not yet been created.

    pent (IN) - Inbound object attributes/values.

    pMetaDataVecRemote (IN) - Inbound object meta data.

    pUpdateStatus (OUT) - On successful return, holds one of the following:
        UPDATE_NOT_UPDATED - no update required
        UPDATE_INSTANCE_TYPE - instance type of the object was updated
        UPDATE_OBJECT_CREATION - new object created
        UPDATE_OBJECT_UPDATE - pre-exisiting object modified

    RepFlags (IN) - Bit field -- only DRS_WRIT_REP is inspected, which expresses
        whether the inbound object is in a read-only or writeable NC.

    fNCPrefix (IN) - Is this the head of the NC being replicated?

    pParentGuid (IN) - Pointer to the objectGuid of the parent object, or NULL
        if none was supplied by the source.

    fMoveToLostAndFound (IN) - In addition to inbound updates, the object is
        being moved to the LostAndFound container as an originating write.

Return Values:

    0 or ERROR_DS_DRA_*.

--*/
{
    ULONG                       ret;
    SYNTAX_INTEGER              itNew;
    BOOL                        iTypeModified;
    int                         FindAliveStatus;
    USHORT                      DeletionStatus;
    BOOL                        fBadDelete = FALSE;
    BOOL                        fIsProxyObject = FALSE;
    BOOL                        fContinue = TRUE;
    SYNTAX_DISTNAME_BINARY    * pProxyVal = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVecLocal = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVecToApply = NULL;
    ULONG                       cbReturned = 0;
    SYNTAX_INTEGER              itCurrent;
    PROPERTY_META_DATA *        pMetaDataLocal;
    PROPERTY_META_DATA *        pMetaDataRemote;
    DWORD                       i;
    SYNTAX_INTEGER              objectClassId = 0;
    BOOL                        fDeleteLocalObj = FALSE;
    ULONG                       dntObj = INVALIDDNT;
    ULONG                       dntObjNC = INVALIDDNT;
    ATTRBLOCK                   AttrBlockToApply;
    BOOL                        fIsAncestorOfLocalDsa = FALSE;
    ENTINF                      *pPreservedAttrs = NULL;

    ret = 0;
    *pUpdateStatus = UPDATE_NOT_UPDATED;       // Clear out any old values

    DPRINT1(1, "Updating (%ls)\n", pent->pName->StringName);

    // See if object on source server is deleted, or is undeleted,
    // or otherwise interesting requiring special handling.
    DeletionStatus = AttrDeletionStatusFromPentinf( pent );
    CheckProxyStatus(pent, DeletionStatus, &fIsProxyObject, &pProxyVal);

    // Handle the case where a cross domain moved object might
    // collide with an existing object.
    if ( !fIsProxyObject )
    {
        ret = PreProcessProxyInfo(pTHS,
                                  pent,
                                  pProxyVal,
                                  pMetaDataVecRemote,
                                  &pMetaDataVecLocal,
                                  &fContinue);
        if (ret || !fContinue) {
            return ret;
        }
    }

    // See if local object exists, doesn't exist, or exists and is deleted
    FindAliveStatus = FindAliveDSName(pTHS->pDB, pent->pName);

    if (    ( FIND_ALIVE_FOUND       == FindAliveStatus )
         || ( FIND_ALIVE_OBJ_DELETED == FindAliveStatus )
       )
    {
        dntObj = pTHS->pDB->DNT;
        dntObjNC = pTHS->pDB->NCDNT;

        // Get the meta-data vector of the object if required.
        if ( !pMetaDataVecLocal )
        {
            if (DBGetAttVal(pTHS->pDB, 1,  ATT_REPL_PROPERTY_META_DATA,
                    0, 0, &cbReturned, (LPBYTE *) &pMetaDataVecLocal))
            {
                DRA_EXCEPT (DRAERR_DBError, 0);
            }

            GetExpectedRepAtt(pTHS->pDB, ATT_OBJECT_CLASS, &objectClassId,
                              sizeof(objectClassId));
        }
    } else {
        Assert(NULL == pMetaDataVecLocal);
    }

    // Translate inbound instance type to local instance type.
    SetRepIt(pTHS,
             pent,
             fNCPrefix,
             RepFlags & DRS_WRIT_REP,
             FindAliveStatus,
             &itCurrent,
             &itNew,
             &iTypeModified);
    Assert(ISVALIDINSTANCETYPE(itNew));

    // If we need to modify the instance type on an existing object,
    // then we need to update the object.

    if (iTypeModified) {
        *pUpdateStatus = UPDATE_INSTANCE_TYPE;        // Object needs update
    }

    if ( !fNCPrefix && FPrefixIt(itNew) )
    {
        // The replicated object is not the head of the NC we're replicating,
        // but the instance type we calculated for the target object is that
        // of an instantiated NC head (which also serves as a SUBREF), which
        // implies that this replicated object is the head of an NC that is
        // already instantiated locally.
        //
        // In this case, we don't want to update the local object with the
        // replicated object's properties; we'll update that object when its
        // NC is synced.
        //
        // We do, however, want to take this opportunity to ensure that the
        // information on the local child NC head properly reflects the fact
        // that we hold a copy of the NC above it.  This is not necessary if
        // the IT_NC_ABOVE bit is already set.
        //
        // Both the instance type and the NCDNT of the child NC head are
        // affected, so:
        //
        // (1) update the instance type on the NC head to reflect that which
        //     we just calculated (which now includes IT_NC_ABOVE, if it
        //     didn't before), and
        // (2) change the NCDNT of the NC head to point to the (now
        //     instantiated) NC above it.

        ULONG ncdnt;

        *pUpdateStatus = UPDATE_NOT_UPDATED;

        if (itCurrent & IT_NC_ABOVE) {
            // Don't do the update if already set since this causes
            // excess replication traffic
            ret = DRAERR_Success;
        } else {

            if ( FindNcdntSlowly(
                pent->pName,
                FINDNCDNT_DISALLOW_DELETED_PARENT,
                FINDNCDNT_DISALLOW_PHANTOM_PARENT,
                &ncdnt
                )
                )
            {
                // Failed to derive the proper NCDNT.  More than likely the
                // local parent did not match the requirements we passed to
                // FindNcdnt().

                Assert( !"Cannot derive proper NCDNT to place on SUBREF!" );
                ret = DRAERR_InconsistentDIT;
            }
            else
            {
                //
                // Derived NCDNT;
                // Update the subref with the new NCDNT.
                //
                Assert(INVALIDDNT != dntObj);

                if (!DBFindDNT( pTHS->pDB, dntObj)) {
                    DBResetAtt(
                            pTHS->pDB,
                            FIXED_ATT_NCDNT,
                            sizeof( ncdnt ),
                            &ncdnt,
                            SYNTAX_INTEGER_TYPE
                            );

                    if(DBRepl(pTHS->pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING)) {
                        // Failed to update the object... ?
                        ret = DRAERR_Busy;
                    }
                    else {
                        //
                        // Updated subref NCDNT;
                        // Now change the instanceType.
                        //
                        ret = ChangeInstanceType(pTHS, pent->pName, itNew, DSID(FILENO,__LINE__));
                    }
                }
                else {
                    // Failed to find the object... ?
                    ret = DRAERR_Busy;
                }
            }
        }
    } else {

        /* Either add or modify the replica object.
        */

        Assert(!ret);

        if (fNCPrefix) {
            // This inbound object is the root of the NC we are currently
            // replicating.
            if ((FIND_ALIVE_FOUND == FindAliveStatus)
                && ((IT_UNINSTANT & itCurrent)
                    || (CLASS_TOP == objectClassId))) {
                // We're now instantiating the head of this NC, for which we
                // previously had only a placeholder NC (SUBREF or otherwise).
                // Strip all attributes from the local object and replace its
                // attributes en masse from those replicated from the source
                // DSA.

                //
                // Store attributes we wish to preserve for instantiated obj
                // Do not attempt for pure subref, only those created via
                // DRA_ReplicaAdd
                //
                if (!(IT_UNINSTANT & itCurrent)) {
                    pPreservedAttrs = GetNcPreservedAttrs( pTHS, pent->pName);
                }

                // Delete the object
                ret = DeleteLocalObj(
                            pTHS, pent->pName,
                            TRUE,           // preserve RDN
                            TRUE,           // Garbage Collection
                            NULL);          // Remote Metadata

                if (!ret) {
                    // Treat this operation as an add.
                    FindAliveStatus = FIND_ALIVE_NOTFOUND;

                    if (NULL != pMetaDataVecLocal) {
                        THFreeEx(pTHS, pMetaDataVecLocal);
                        pMetaDataVecLocal = NULL;
                    }
                }
            }

            if ((FIND_ALIVE_NOTFOUND == FindAliveStatus)
                && (RepFlags & DRS_WRIT_REP)
                && !DsaIsInstalling()) {
                // We are constructing this writeable NC via replication from
                // scratch.  Either the NC has never been instantiated on this
                // DSA or, if we did previously have a replica of this NC, we
                // have since removed it.
                //
                // If we did previously have a writeable replica of this NC,
                // we no longer have any of the updates we originated in the NC.
                // Thus, we cannot claim to be "up to date" with respect to our
                // invocation ID up to any USN.  While we can (and do) leave out
                // our invocation ID from the UTD vector we present while
                // re-populating this NC, that is not enough -- we may have
                // generated changes that reached DC1 but not DC2 (yet), and
                // have replicated from DC2 to reinstantiate our NC.  Thus, we
                // could never assert we had seen all of our past changes.
                //
                // At some point, however, we *must* claim to be up-to-date with
                // respect to our own changes -- otherwise, we would replicate
                // back in any and all changes we originated in this NC
                // following it's most recent re-instantiation.  That would
                // potentially result in a *lot* of extra replication traffic.
                //
                // To solve this problem, we create a new invocation ID to use
                // to replicate this NC (and others, since invocation IDs are
                // not NC-specific).  We claim only to be up-to-date with
                // respect to our new invocation ID -- not the invocation ID(s)
                // with which we may have originated changes during the previous
                // instantiation(s) of this NC.
                //
                // Unfortunately we can't currently differentiate between the
                // case where we have previously instantiated and torn down this
                // writeable NC and the case where we haven't, so we acquire a
                // new invocation ID even if this is the first time we are
                // instantiating this NC.
                //
                // We perform the retirement here rather than, say, when we
                // request the first packet so that we minimize the number of
                // invocation IDs we retire.  E.g., we wouldn't want to retire
                // an invcocation ID, send a request for the first packet, find
                // the source is unreachable, fail, try again later, needlessly
                // retire the new invcocation ID, etc.
                draRetireInvocationID(pTHS);
            }
        }

        if (!ret) {
            // Check that we aren't trying to delete a protected object
            // (e.g., the local DSA object, one of its ancestors, or a
            // cross-ref for a locally writeable NC).

            if ((OBJECT_BEING_DELETED == DeletionStatus)
                && (FindAliveStatus == FIND_ALIVE_FOUND)) {
                // Proxy objects are deleted at the outset -- we shouldn't find
                // a "live" proxy object that we need to delete.
                Assert(!fIsProxyObject);

                // Deleting an existing object, see if it's a protected one.
                // Note that we can flag a bad delete even if we wouldn't
                // otherwise apply the deletion -- this is important now that
                // deletion implies removal of many other attributes.  (The
                // "bad delete" detection will ensure that these attributes are
                // not removed.)
                fBadDelete = fDNTInProtectedList(dntObj, NULL)
                             || IsCrossRefProtectedFromDeletion(pent->pName);

                if (!fBadDelete) {
                    // The inbound data says the object should be deleted, and
                    // the object has no special protection locally against
                    // deletion; does the meta data imply we should accept this
                    // change?
                    pMetaDataLocal = ReplLookupMetaData(ATT_IS_DELETED,
                                                        pMetaDataVecLocal,
                                                        NULL);
                    pMetaDataRemote = ReplLookupMetaData(ATT_IS_DELETED,
                                                         pMetaDataVecRemote,
                                                         NULL);
                    Assert(NULL != pMetaDataRemote);

                    fDeleteLocalObj = (ReplCompareMetaData(pMetaDataRemote,
                                                           pMetaDataLocal)
                                       > 0);
                }
            }

            // Determine if this is an update to an ancestor of the local DSA
            // (or the local DSA object itself) in the config NC.
            if ((FIND_ALIVE_FOUND == FindAliveStatus)
                && (dntNC != INVALIDDNT)
                && (dntNC == gAnchor.ulDNTConfig)) {
                for (i = 0; i < gAnchor.AncestorsNum; i++) {
                    if (dntObj == gAnchor.pAncestors[i]) {
                        fIsAncestorOfLocalDsa = TRUE;
                        break;
                    }
                }
            }

            *pUpdateStatus = ReplReconcileRemoteMetaDataVec(
                                pTHS,
                                pMetaDataVecLocal,
                                fIsAncestorOfLocalDsa,
                                (FindAliveStatus == FIND_ALIVE_OBJ_DELETED),
                                fDeleteLocalObj,
                                fBadDelete,
                                DeletionStatus,
                                pent,
                                pMetaDataVecRemote,
                                &pParentGuid,
                                &AttrBlockToApply,
                                &pMetaDataVecToApply
                                );
            Assert(*pUpdateStatus || !fDeleteLocalObj);

            if (*pUpdateStatus)
            {
                if (fMoveToLostAndFound) {
                    if (itNew & IT_WRITE) {
                        // Writeable NC.  Flag the meta data such that the name
                        // change is replicated back out to other DSAs.
                        ReplOverrideMetaData(ATT_RDN, pMetaDataVecToApply);
                    } else {
                        // Read-only NC.  Flag the meta data such that our
                        // temporary rename will unilaterally lose compared to
                        // a "real" rename from a writeable source.
                        ReplUnderrideMetaData(pTHS,
                                              ATT_RDN,
                                              &pMetaDataVecToApply,
                                              NULL);
                    }
                }

                if (    ( FIND_ALIVE_FOUND       == FindAliveStatus )
                     || ( FIND_ALIVE_OBJ_DELETED == FindAliveStatus )
                   )
                {
                    Assert(INVALIDDNT != dntObj);
                    Assert(INVALIDDNT != dntObjNC);

                    if ((INVALIDDNT != dntNC)
                        && (dntObjNC != dntNC)
                        && (dntObj != dntNC)) {
                        // This object is in the wrong NC; i.e., it has been moved across
                        // domains, and the source (remote) and destination (local) DSAs
                        // don't agree on which NC the object is currently in.  This is a
                        // transient condition that will be rectified by replicating in the
                        // other direction and/or by replicating the other NC involved.
                        DPRINT1(0,
                                "Cannot update inbound object %ls because it exists "
                                    "locally in an NC other than the one being replicated "
                                    "-- should be a transient condition.\n",
                                pent->pName->StringName);
                        DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                    }

                    // Trim unneeded group memberships
                    if ( (FIND_ALIVE_FOUND == FindAliveStatus) &&
                         (CLASS_GROUP == objectClassId) &&
                         (itNew == INT_FULL_REPLICA) && /* readonly */
                         (!fMoveToLostAndFound) &&
                         (!fDeleteLocalObj) ) {

                        GcCleanupUniversalGroupDemotion(
                            pTHS,
                            pent->pName,
                            &AttrBlockToApply,
                            pMetaDataVecLocal
                            );
                    }
                    DPRINT2(4, "Modifying %d attrs on %ws\n",
                                pent->AttrBlock.attrCount, pent->pName->StringName);

                    ret = ModifyLocalObjRetry(pTHS,
                                              dntNC,
                                              pent->pName,
                                              &AttrBlockToApply,
                                              pParentGuid,
                                              pMetaDataVecToApply,
                                              fMoveToLostAndFound,
                                              fDeleteLocalObj);
                }
                else
                {
                    // Process proxy objects for their side effect before
                    // adding them.  Want side effect AND add so that proxy
                    // propagates to other replicas.

                    if ( fIsProxyObject )
                    {
                        Assert(OBJECT_BEING_DELETED == DeletionStatus);
                        Assert(pProxyVal);
                        ret = ProcessProxyObject(pTHS, pent, pProxyVal);
                    }

                    if (!ret)
                    {
                        ret = AddLocalObj(pTHS,
                                          dntNC,
                                          pent,
                                          pParentGuid,
                                          fNCPrefix,
                                          (OBJECT_BEING_DELETED == DeletionStatus),
                                          &AttrBlockToApply,
                                          pMetaDataVecToApply,
                                          fMoveToLostAndFound);

                        if (pPreservedAttrs && !ret) {
                            // we have some preserved non-replicated attrs to add here
                            Assert( NameMatchedStringNameOnly( pent->pName, pPreservedAttrs->pName ) );
                            ret = ModifyLocalObjRetry(pTHS,
                                                      dntNC,
                                                      pPreservedAttrs->pName,
                                                      &pPreservedAttrs->AttrBlock,
                                                      pParentGuid,
                                                      NULL,
                                                      FALSE,
                                                      FALSE);
                            if (ret) {
                                Assert(!"Error: Failed to add new PreservedAttrs to new source");
                                DRA_EXCEPT(ret, 0);
                            }
                            // we don't need the mem any longer.
                            THFreeEx(pTHS, pPreservedAttrs);
                        }
                    }
                }

                THFreeEx(pTHS, AttrBlockToApply.pAttr);

                PERFINC(pcRepl);
            }
            else {
                // No updates to apply for this object.
                PERFINC(pcDRAInObjsFiltered);
                DPRINT2(4, "Skipped update for %d attrs in %ws\n",
                        pent->AttrBlock.attrCount, pent->pName->StringName);
            }
        }

        // If all Ok so far, see if master object was deleted and we
        // need to update.

        if (!ret && fDeleteLocalObj) {
            Assert(*pUpdateStatus);
            Assert(!fNCPrefix);

            // make sure the currency is on the object to be removed
            if (DBFindDNT(pTHS->pDB, dntObj)) {
                // Unable to set currency.
                DRA_EXCEPT (DRAERR_DBError, 0);
            }

            // Object is alive here and was deleted remotely, so delete it here.
            // Don't preserve its RDN or force it to be immediately garbage
            // collected.
            ret = DeleteRepObj(pTHS,
                               pent->pName,
                               FALSE,
                               FALSE,
                               pMetaDataVecToApply);
        }

        // If an object was revived, revive its link values
        if (!ret && fBadDelete) {
            CHAR szTime1[SZDSTIME_LEN];

            ReplOverrideLinks( pTHS );

            // The scene of the crime
            pMetaDataRemote = ReplLookupMetaData(ATT_IS_DELETED,
                                                 pMetaDataVecRemote,
                                                 NULL);
            Assert(NULL != pMetaDataRemote);

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_OBJECT_REVIVED,
                     szInsertDN(pent->pName),
                     szInsertDN(
                         draGetServerDsNameFromGuid(
                             pTHS,
                             Idx_InvocationId,
                             &(pMetaDataRemote->uuidDsaOriginating) ) ),
                     szInsertDSTIME(pMetaDataRemote->timeChanged, szTime1) );
        }

        if (0 == ret) {
            // Success -- update attrs applied/discarded performance counters.
            DWORD cPropsApplied = pMetaDataVecToApply
                                    ? pMetaDataVecToApply->V1.cNumProps
                                    : 0;
            Assert(pMetaDataVecRemote->V1.cNumProps >= cPropsApplied);

            // Applied and discarded inbound attributes.
            IADJUST(pcDRASyncPropUpdated, cPropsApplied);
            IADJUST(pcDRASyncPropSame,
                    pMetaDataVecRemote->V1.cNumProps - cPropsApplied);

#if DBG
            ReplCheckMetadataWasApplied(
                pTHS,
                pMetaDataVecToApply
                );
#endif
        }

        if (NULL != pMetaDataVecToApply) {
            THFreeEx(pTHS, pMetaDataVecToApply);
        }
    }

    if (NULL != pMetaDataVecLocal) {
        THFreeEx(pTHS, pMetaDataVecLocal);
    }

    if (0 == ret) {
        // Success -- update inbound props/values/DN values counters.
        ATTR * pAttr = &pent->AttrBlock.pAttr[0];
        for (i = 0; i < pent->AttrBlock.attrCount; i++, pAttr++) {
            ATTCACHE * pAC = SCGetAttById(pTHS, pAttr->attrTyp);
            Assert((NULL != pAC) && "We just found this att moments ago...?");
            if (IS_DN_VALUED_ATTR(pAC)) {
                // A DN-valued attribute.
                IADJUST(pcDRAInDNValues, pAttr->AttrVal.valCount);
            }

            // DN-valued or not it gets added to the total.
            IADJUST(pcDRAInValues, pAttr->AttrVal.valCount);
        }

        IADJUST(pcDRAInProps, pMetaDataVecRemote->V1.cNumProps);
    }

    return ret;
}


/* LogUpdateFailure - Log a replication update failure.
 * Note, this is called when the error is DRAERR_BUSY
 * This is a warning.  The operation will be retried.
 *
 */
void
LogUpdateFailure(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName
    )
{
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DRA_UPDATE_FAILURE,
             szInsertDN(pDistName),
             szInsertWC(pszServerName),
             NULL);
}

/* LogUpdateFailureNB - Log a non busy replication update failure.
 * This is for non-transient errors.
 */
void
LogUpdateFailureNB(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName,
    IN  GUID *      puuidObject,
    IN  ULONG       ulError
    )
{
    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DRA_UPDATE_FAILURE_NOT_BUSY,
                      szInsertDN(pDistName),
                      szInsertUUID(puuidObject),
                      szInsertWC(pszServerName),
                      szInsertWin32Msg(ulError),
                      NULL, NULL, NULL, NULL,
                      sizeof(ulError),
                      &ulError );
}

/* LogUpdateValueFailureNB - Log a non busy replication update failure.
 * This is for non-transient errors.
 */
void
LogUpdateValueFailureNB(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName,
    IN  REPLVALINF *pReplValInf,
    IN  ULONG       ulError
    )
{
    ATTCACHE *pAC;
    DSNAME dnDummy;
    DSNAME *pdnValue;

    // Get the attribute cache entry
    if ((NULL == (pAC = SCGetAttById(pTHS, pReplValInf->attrTyp)))
        || (NULL == (pdnValue = DSNameFromAttrVal(pAC, &pReplValInf->Aval)))) {
        // Try to keep going even if errors occur
        pdnValue = &dnDummy;
        memset( pdnValue, 0, sizeof( DSNAME ) );
    }

    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DRA_UPDATE_VALUE_FAILURE_NOT_BUSY,
                      szInsertDN(pDistName),
                      szInsertUUID(&(pReplValInf->pObject->Guid)),
                      szInsertWC(pszServerName),
                      szInsertWin32Msg(ulError),
                      szInsertSz( pAC ? pAC->name : "bad attribute type" ),
                      szInsertDN( pdnValue ),
                      szInsertUUID( &(pdnValue->Guid) ),
                      szInsertUL( pReplValInf->fIsPresent ),
                      sizeof(ulError),
                      &ulError );
}

/* ReplicateNC - Replicate the NC specified by pNC on the local DSA.
*
*  Notes:
*       We expect to enter this routine with a READ lock set. We exit the
*       routine with a WRITE lock set, unless an error occurs in which case
*       there may or may not be a write lock set.
*
* When the DRS_CRITICAL_ONLY option is set, this routine is modified in the
* following ways.  First, this option is passed to GetChanges so that only
* critical objects are returned.  Second, since this operation does not get
* all changed objects, the bookmarks are not updated.
*
* There are atleast three ways to indicate a "full sync" in this routine:
* 1. pusnvecLast set to gusnvecfromScratch.  The UTD is used in this case,
*    and may or may not have a filter for the source.  This case is done
*    by Replica Add.
* 2. Caller specified FULL_SYNC_NOW.  In this case, we set the usn vec from to
*    scratch, and we don't load the UTD, making it NULL. This flag is NOT
*    preserved in the reps-from. We also set the reps-from flag
*    FULL_SYNC_IN_PROGRESS, so we can remember on reboot that we are in this
*    mode.
* 3. RepFlags has FULL_SYNC_IN_PROGRESS set.  This indicates we crashed or
*    failed to finish a FULL_SYNC_NOW.  We take whatever usn from vec we last
*    saved.  We force the UTD to be NULL.
*
*  Results:
*       0 if successfull, an error code otherwise.
*/

ULONG
ReplicateNC(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN      MTX_ADDR *              pmtx_addr,
    IN      LPWSTR                  pszSourceDsaDnsDomainName,
    IN      USN_VECTOR *            pusnvecLast,
    IN      ULONG                   RepFlags,
    IN      REPLTIMES *             prtSchedule,
    IN OUT  UUID *                  puuidDsaObjSrc,
    IN      UUID *                  puuidInvocIdSrc,
    IN      ULONG *                 pulSyncFailure,
    IN      BOOL                    fNewReplica,
    IN      UPTODATE_VECTOR *       pUpToDateVec,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx
    )
{
    ULONG                       ret = 0, err = 0, retNextPkt = 0;
    ULONG                       ulFlags;
    DWORD                       dwNCModified = MODIFIED_NOTHING;
    DRS_MSG_GETCHGREQ_NATIVE    msgReqUpdate = {0};
    DRS_MSG_GETCHGREQ_NATIVE    msgReqUpdateNextPkt;
    DRS_MSG_GETCHGREPLY_NATIVE  msgUpdReplica = {0};
    ULONG                       ulResult, len;
    ULONG                       dntNC = INVALIDDNT;
    ULONG                       ret2 = DRAERR_Generic;
    UUID                        uuidDsaObjSrc;
    UUID                        uuidInvocIdSrc;
    DWORD                       sourceNCSize;
    DWORD                       sourceNcSizeObjects, sourceNcSizeValues;
    DWORD                       totalObjectsReceived, totalObjectsCreated;
    DWORD                       objectsCreated;
    DWORD                       totalValuesReceived;
    LPWSTR                      pszSourceServer;
    BYTE                        schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    DWORD                       cNumPackets = 0;
    BOOL                        fSchInfoChanged = FALSE;
    DRS_ASYNC_RPC_STATE         AsyncState = {0};
    SYNTAX_INTEGER              it;
    DRA_REPL_SESSION_STATISTICS replStats = {0};
    BOOL                        fIsPreemptable = FALSE;

#if DBG
// Debugging variables:
    ULONG           iobjs = 0;
#endif

    // if this a PAS cycle, we better have PAS data.
    Assert(!(RepFlags & DRS_SYNC_PAS) ||
           (pPartialAttrSet && pPartialAttrSetEx) );

    pszSourceServer = TransportAddrFromMtxAddrEx(pmtx_addr);

    DPRINT2(3, "ReplicateNC, NC='%ws', options=%x\n", pNC->StringName, RepFlags );

    // Critical only is only allowed with new replicas...
    Assert( !(RepFlags & DRS_CRITICAL_ONLY) || fNewReplica );
    // Critical only requires get ancestors since parents may not be critical
    if (RepFlags & DRS_CRITICAL_ONLY) {
        RepFlags |= DRS_GET_ANC;
    }

    // Find the NC object, get and save its DNT.
    // This may not succeed if the NC head has not be replicated in yet
    if (0 == FindNC(pTHS->pDB, pNC,
                     FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
        dntNC = pTHS->pDB->DNT;
    }

    *pulSyncFailure = 0;

    msgReqUpdate.uuidDsaObjDest = gAnchor.pDSADN->Guid;
    msgReqUpdate.uuidInvocIdSrc = puuidInvocIdSrc ? *puuidInvocIdSrc : gNullUuid;
    msgReqUpdate.pNC            = pNC;
    msgReqUpdate.ulFlags        = RepFlags;

    // Packet size will be filled in by I_DRSGetNCChanges().
    Assert(0 == msgReqUpdate.cMaxObjects);
    Assert(0 == msgReqUpdate.cMaxBytes);

    // Save the UUIDs we will set in the Reps-From property should we add or
    // modify it.
    if (fNewReplica) {
        uuidDsaObjSrc = uuidInvocIdSrc = gNullUuid;
    }
    else {
        uuidDsaObjSrc  = *puuidDsaObjSrc;
        uuidInvocIdSrc = *puuidInvocIdSrc;
    }

    // If we want to sync from scratch, set sync to usn start point
    if (msgReqUpdate.ulFlags & DRS_FULL_SYNC_NOW) {
        msgReqUpdate.usnvecFrom = gusnvecFromScratch;
        msgReqUpdate.ulFlags |= DRS_FULL_SYNC_IN_PROGRESS | DRS_NEVER_SYNCED;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_USER_REQ_FULL_SYNC,
                 szInsertWC(pNC->StringName),
                 szInsertSz(pmtx_addr->mtx_name),
                 szInsertHex(RepFlags));
    }
    else {
        msgReqUpdate.usnvecFrom = *pusnvecLast;
    }

    // partial attr set
    msgReqUpdate.pPartialAttrSet   = (PARTIAL_ATTR_VECTOR_V1_EXT*)pPartialAttrSet;
    msgReqUpdate.pPartialAttrSetEx = (PARTIAL_ATTR_VECTOR_V1_EXT*)pPartialAttrSetEx;

    if ( msgReqUpdate.pPartialAttrSet ||
         msgReqUpdate.pPartialAttrSetEx ) {
        // send mapping table if we send any attr list.
        msgReqUpdate.PrefixTableDest = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
        ret = AddSchInfoToPrefixTable(pTHS, &msgReqUpdate.PrefixTableDest);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }
    }


    // There are three "restartable modes", DRS_FULL_SYNC_IN_PROGRESS, and
    // DRS_FULL_SYNC_PACKET & DRS_SYNC_PAS.  We keep a flag in
    // the replica link while they are active.  If we crash and restart, we
    // detect that we are still in the mode, and enable them again

    if (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) {
        // Send source our current up-to-date vector to use as a filter.
        msgReqUpdate.pUpToDateVecDest = pUpToDateVec;
    }

    // Request source NC size on first packet of a full sync
    if (msgReqUpdate.usnvecFrom.usnHighPropUpdate == 0) {
        msgReqUpdate.ulFlags |= DRS_GET_NC_SIZE;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_FULL_SYNC_CONTINUED,
                 szInsertWC(pNC->StringName),
                 szInsertSz(pmtx_addr->mtx_name),
                 szInsertHex(RepFlags));

        // Determine initial count of objects if NC already exists
        if (dntNC != INVALIDDNT) {
            replStats.ulTotalObjectsCreated = DraGetNcSize(pTHS, 
                                                           (RepFlags & DRS_CRITICAL_ONLY),
                                                           dntNC);
            if (pTHS->fLinkedValueReplication) {
                // Only values in the database after LVR mode enabled
                replStats.ulTotalValuesCreated = DBGetNCSizeEx(
                    pTHS->pDB,
                    pTHS->pDB->JetLinkTbl,
                    Idx_LinkDraUsn,
                    dntNC );
            }
        }
        // currency is lost after this, but ok, since reestablished below
    }

    // We entered this routine with a READ_ONLY transaction which
    // we don't need anymore.
    EndDraTransaction(TRUE);

    __try {


        // Mark the heap so that we can discard heap allocated memory after
        // each getnccchanges call.
        TH_mark(pTHS);

        EnterCriticalSection(&csLastReplicaMTX);
        pLastReplicaMTX = pmtx_addr;
        LeaveCriticalSection(&csLastReplicaMTX);

        if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
            goto LABORT;
        }

        if (IsHigherPriorityDraOpWaiting()) {
            // Mark sync as flawed so it will be retried.
            *pulSyncFailure = DRAERR_Preempted;
            goto LABORT;
        }

        // Abort if inbound replication is disabled and this is not a forced
        // sync.
        if (gAnchor.fDisableInboundRepl && !(RepFlags & DRS_SYNC_FORCED)) {
            *pulSyncFailure = DRAERR_SinkDisabled;
            goto LABORT;
        }

        PERFINC(pcDRASyncRequestMade);

        ret = I_DRSGetNCChanges(pTHS,
                                pszSourceServer,
                                pszSourceDsaDnsDomainName,
                                &msgReqUpdate,
                                &msgUpdReplica,
                                schemaInfo,
                                NULL);
        if (ret) {
            goto LABORT;
        }

        if (0 == memcmp(&msgUpdReplica.uuidDsaObjSrc,
                        &gAnchor.pDSADN->Guid,
                        sizeof(GUID))) {
            // Can't replicate from self!
            ret = ERROR_DS_CLIENT_LOOP;
            goto LABORT;
        }

        // If this is not a new replica, verify that we contacted the correct
        // source server.
        if (!fNewReplica
            && memcmp(&msgUpdReplica.uuidDsaObjSrc, puuidDsaObjSrc,
                      sizeof(UUID))) {
            // This not a new replica, but the DSA object guid mentioned by
            // the source is different from that recorded in the Reps-From.
            // Since the network name that we associate with the source is
            // derived from its GUID-based DNS name, this usually indicates
            // stale entries in DNS; i.e., the IP address given us by DNS no
            // longer corresponds to the right server.
            ret = DRAERR_NoReplica;
            goto LABORT;
        }

        uuidDsaObjSrc  = msgUpdReplica.uuidDsaObjSrc;
        uuidInvocIdSrc = msgUpdReplica.uuidInvocIdSrc;

        msgReqUpdate.ulFlags &= ~DRS_GET_NC_SIZE; // Clear bit for next call

        msgUpdReplica.ulExtendedRet = 0;

        replStats.SourceNCSizeObjects = msgUpdReplica.cNumNcSizeObjects;
        replStats.SourceNCSizeValues = msgUpdReplica.cNumNcSizeValues;

        // We have done our initial read of the other DSA and are about
        // to start updating this DSA.

        ulFlags = msgReqUpdate.ulFlags;

        do {
            Assert( msgUpdReplica.dwDRSError == ERROR_SUCCESS );

            if ((0 != memcmp(&uuidDsaObjSrc,
                             &msgUpdReplica.uuidDsaObjSrc,
                             sizeof(UUID)))
                || (0 != memcmp(&uuidInvocIdSrc,
                                &msgUpdReplica.uuidInvocIdSrc,
                                sizeof(UUID)))) {
                // Source changed identities between packets?
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }

            // if we are here, we have made one successful GetNCChanges() and
            // are about to process the results.
            PERFINC(pcDRASyncRequestSuccessful);

            if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
                *pulSyncFailure = DRAERR_Preempted;
                break;
            }

            if (msgUpdReplica.fMoreData) {
                // Send async request to source to begin compiling the next
                // packet of changes for us.
                msgReqUpdateNextPkt            = msgReqUpdate;
                // Usnvec and Invocation id must be updated together
                msgReqUpdateNextPkt.uuidInvocIdSrc = msgUpdReplica.uuidInvocIdSrc;
                msgReqUpdateNextPkt.usnvecFrom = msgUpdReplica.usnvecTo;
                msgReqUpdateNextPkt.ulFlags    = ulFlags;

                gcNumPreFetchesTotal++;
                retNextPkt = I_DRSGetNCChanges(pTHS,
                                               pszSourceServer,
                                               pszSourceDsaDnsDomainName,
                                               &msgReqUpdateNextPkt,
                                               &msgUpdReplica,
                                               schemaInfo,
                                               &AsyncState);
            }

            // Indicate we're busy (for dead thread check)
            gfDRABusy = TRUE;

            // Set the count of remaining entries to update.
            ISET (pcRemRepUpd, msgUpdReplica.cNumObjects);
	    ISET (pcDRARemReplUpdLnk, msgUpdReplica.cNumValues);
	    ISET (pcDRARemReplUpdTot, msgUpdReplica.cNumValues+msgUpdReplica.cNumObjects);  

            // set the cumulative count of objects received
            IADJUST(pcDRASyncObjReceived, ((LONG) msgUpdReplica.cNumObjects));

            replStats.ObjectsReceived += msgUpdReplica.cNumObjects;
            replStats.ValuesReceived += msgUpdReplica.cNumValues;
#if DBG
            iobjs += msgUpdReplica.cNumObjects;
#endif
            ret = UpdateNC(pTHS,
                           pNC,
                           &msgUpdReplica,
                           pszSourceServer,
                           pulSyncFailure,
                           msgReqUpdate.ulFlags,
                           &dwNCModified,
                           &replStats.ObjectsCreated,
                           &replStats.ValuesCreated,
                           schemaInfo,
                           fIsPreemptable);

            // Make final updates.
            // Do the following if we succeed and there is no more data.
            // We do these final operations here instead of at the end of the
            // routine because we release the RPC results in this loop.

            if (    !ret
                 && !*pulSyncFailure
                 && !msgUpdReplica.fMoreData
                 && !(RepFlags & DRS_ASYNC_REP)
                 && (!(RepFlags & DRS_CRITICAL_ONLY)) )
            {
                // we're now up-to-date with respect to the source DSA, so
                // we're also now transitively up-to-date with respect to
                // other DSAs to at least the same point as the source DSA

                // if this is the schema NC, trigger a schema cache update,
                // except when it is installing, since during install, any
                // new schema object is added to the cache immediately anyway

                if ((MODIFIED_NCTREE_INTERIOR == dwNCModified)
                    && NameMatched(gAnchor.pDMD, pNC)
                    && DsaIsRunning() )
                {
                    // we just synced a schema NC successfully and atleast one
                    // modification is made to the schema. Trigger a schema cache update
                    if (!SCSignalSchemaUpdateImmediate())
                    {
                        // couldn't even signal a schema update
                        DRA_EXCEPT (DRAERR_InternalError, 0);
                    }
                }

                BeginDraTransaction(SYNC_WRITE);
                __try {
                    ret = FindNC(pTHS->pDB,
                                 pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC,
                                 &it);
                    if (ret) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ret);
                    }

                    if (it & IT_NC_COMING) {
                        // The initial inbound replication of this NC is now
                        // complete.
                        ret = ChangeInstanceType(pTHS, pNC, it & ~IT_NC_COMING, DSID(FILENO,__LINE__));
                        if (ret) {
                            DRA_EXCEPT(ret, 0);
                        }
                        Assert(CheckCurrency(pNC));
                    }

                    if (RepFlags & DRS_SYNC_PAS) {
                        //
                        // We've had completed a successful PAS cycle.
                        // At this point we can only claim to be as up to date as our source.
                        // Action:
                        //  - Overwrite our UTD w/ the source's UTD.
                        //  - complete PAS replication:
                        //      - reset other links USN vectors
                        //      - reset this source's flags
                        //
                        UpToDateVec_Replace(pTHS->pDB,
                                            &msgUpdReplica.uuidInvocIdSrc,
                                            &msgUpdReplica.usnvecTo,
                                            msgUpdReplica.pUpToDateVecSrc);

                        // asset: must have PAS data for PAS cycles
                        Assert(pPartialAttrSet && pPartialAttrSetEx);

                        // do the rest: USN water marks & update repsFrom
                        (void)GC_CompletePASReplication(
                                pTHS,
                                pNC,
                                &uuidDsaObjSrc,
                                pPartialAttrSet,
                                pPartialAttrSetEx);
                        msgReqUpdate.ulFlags &= ~DRS_SYNC_PAS;
                    } else {
                        // improve our up-to-date vector for this NC
                        UpToDateVec_Improve(pTHS->pDB,
                                            &msgUpdReplica.uuidInvocIdSrc,
                                            &msgUpdReplica.usnvecTo,
                                            msgUpdReplica.pUpToDateVecSrc);
                    }

                    // Since we have just completed a replication session,
                    // Notify other replicas if there has been at least one
                    // modification to the NC tree.
                    if (MODIFIED_NOTHING != dwNCModified) {
                        DBNotifyReplicas(pNC,
                                         RepFlags & DRS_SYNC_URGENT);
                    }

                    // If we were full-syncing, we're done.
                    msgReqUpdate.ulFlags &= ~DRS_FULL_SYNC_IN_PROGRESS;

                    // And we've completed at least one sync now.
                    msgReqUpdate.ulFlags &= ~DRS_NEVER_SYNCED;
                } __finally {
                    EndDraTransaction(!AbnormalTermination());
                }
            }

            // Release results now that we've tried to apply them.
            TH_free_to_mark(pTHS);
            TH_mark(pTHS);

            if (ret == DRAERR_MissingParent) {
                // Ok we failed to apply the update becuase we had a
                // missing parent, so ask again for that packet with
                // ancestors.

                Assert (!(msgReqUpdate.ulFlags & DRS_GET_ANC));

                msgReqUpdate.ulFlags |= DRS_GET_ANC;

                goto NEXTPKT;
            }

            if (ret == DRAERR_MissingObject) {

                // Ok we failed to apply the update becuase we had a
                // missing object, so ask again for that packet with all
                // properties

                Assert((!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_PACKET)) &&
                       (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_NOW)) &&
                       (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) );

                msgReqUpdate.ulFlags |= DRS_FULL_SYNC_PACKET;

                goto NEXTPKT;
            }

            if (!ret) {

                if ( *pulSyncFailure ) {

                    // Give up at sync failure.
                    break;
                } else {
                    // Request was successful

                    // Report progress of full sync at installation time
                    if (msgReqUpdate.usnvecFrom.usnHighPropUpdate == 0) {
                        draReportSyncProgress(
                            pTHS,
                            pNC,
                            pszSourceServer,
                            &replStats );
                    }

                    // Clear "full sync packet" mode
                    msgReqUpdate.ulFlags &= ~DRS_FULL_SYNC_PACKET;

                    // successfully received and applied these changes
                    // Usnvec and Invocation id must be updated together
                    msgReqUpdate.uuidInvocIdSrc = uuidInvocIdSrc;
                    msgReqUpdate.usnvecFrom = msgUpdReplica.usnvecTo;

                    // We've made some progress. Allow further work to be preempted
                    fIsPreemptable = TRUE;

                    if ((0 == (++cNumPackets % UPDATE_REPSFROM_PACKET_INTERVAL))
                        && msgUpdReplica.fMoreData
                        && !(msgReqUpdate.ulFlags & DRS_CRITICAL_ONLY)
                        && !(msgReqUpdate.ulFlags & DRS_ASYNC_REP)
                        && (!fNewReplica
                            || memcmp(&gusnvecFromScratch,
                                      &msgReqUpdate.usnvecFrom,
                                      sizeof(USN_VECTOR)))) {
                        // Every N packets, update our USN vector & other state
                        // for this source in the database.  This is so that if
                        // we're hard reset (e.g., lose power) we won't have to
                        // restart really long syncs from the beginning.

                        BeginDraTransaction(SYNC_WRITE);
                        __try {
                            ret2 = UpdateRepsFromRef(pTHS,
                                                     DRS_UPDATE_ALL,
                                                     pNC,
                                                     DRS_FIND_DSA_BY_ADDRESS,
                                                     URFR_NEED_NOT_ALREADY_EXIST,
                                                     &uuidDsaObjSrc,
                                                     &uuidInvocIdSrc,
                                                     &msgReqUpdate.usnvecFrom,
                                                     &gNullUuid, // transport objectGuid n/a
                                                     pmtx_addr,
                                                     msgReqUpdate.ulFlags,
                                                     prtSchedule,
                                                     ERROR_DS_DRA_REPL_PENDING,
                                                     NULL);
                        } __finally {
                            EndDraTransaction(!(ret2 || AbnormalTermination()));
                        }
                    }
                }
            }

            // If we got an error, or all the objects, quit loop

            if (ret || !msgUpdReplica.fMoreData) {
                break;
            }

            // If we're init syncing and we have a continuation, and we didn't
            // apply any objects and we haven't abandoned before, give up on
            // this init sync. This will allow us to attempt another init
            // sync from another server that should make more progress.

            if (    ( msgReqUpdate.ulFlags & DRS_INIT_SYNC_NOW )
                 && (MODIFIED_NOTHING == dwNCModified)
                 && msgUpdReplica.fMoreData
                 && ( msgReqUpdate.ulFlags & DRS_ASYNC_OP )
                 && !( msgReqUpdate.ulFlags & DRS_ABAN_SYNC ) )
            {
                *pulSyncFailure = DRAERR_AbandonSync;
                break;
            }

            // Reset the flags in case we set ancestors previously
            msgReqUpdate.ulFlags = ulFlags;

NEXTPKT:
            if (eServiceShutdown) {
                break;
            }

            if (0 != memcmp(&msgReqUpdate,
                            &msgReqUpdateNextPkt,
                            sizeof(msgReqUpdate))) {
                // The request we sent asynchronously is not what we want now.
                // Cancel previous request and post a new one.
                DPRINT(0, "Throwing away pre-fetched next packet and re-requesting.\n");
                gcNumPreFetchesDiscarded++;
                gcNumPreFetchesTotal++;
                DPRINT3(0, "Pre-fetch efficiency: %d of %d (%d%%).\n",
                        gcNumPreFetchesTotal - gcNumPreFetchesDiscarded,
                        gcNumPreFetchesTotal,
                        100 * (gcNumPreFetchesTotal - gcNumPreFetchesDiscarded)
                            / gcNumPreFetchesTotal);

                DRSDestroyAsyncRpcState(pTHS, &AsyncState);
                retNextPkt = I_DRSGetNCChanges(pTHS,
                                               pszSourceServer,
                                               pszSourceDsaDnsDomainName,
                                               &msgReqUpdate,
                                               &msgUpdReplica,
                                               schemaInfo,
                                               &AsyncState);
            }

            ret = retNextPkt;
            if (!ret && !eServiceShutdown) {
                PERFINC(pcDRASyncRequestMade);
                ret = I_DRSGetNCChangesComplete(pTHS, &AsyncState);
            }
        } while (!eServiceShutdown && !ret);

        // Is the service trying to shutdown? if so, return failure.
        if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
        }

        // We're assuming that DRS_ASYNC_REP is only set on a new
        // replica, not sync, so check for this.
        if ((!fNewReplica) && (msgReqUpdate.ulFlags & DRS_ASYNC_REP)) {
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

LABORT:;

#if DBG
        DPRINT1(3, "Received %d objects\n", iobjs);
#endif
        // Update Reps-From with result of this sync attempt.
        // If this is a new async replica, we set usn so that
        // we completely sync the replica next sync.
        // Ditto for a "critical only" replica
        //
        // NOTE: We now update Reps-From at the end of most ReplicateNC()
        // calls in order to properly set the (new) last-try-result,
        // last-try-time, and last-success-time fields.

        ulResult = ret ? ret : *pulSyncFailure;

        // Save bookmarks unless we totally failed to add a new replica (i.e.,
        // unless we tried to add a new replica but couldn't complete the first
        // packet).
        //
        // This is a little confiusing, since we might be returning "failure"
        // on an add replica operation even though we did really add a RepsFrom.

        if ((DRAERR_Success == ulResult)
            || !fNewReplica
            || memcmp(&gusnvecFromScratch, &msgReqUpdate.usnvecFrom,
                      sizeof(USN_VECTOR))) {
            BeginDraTransaction (SYNC_WRITE);
            __try {
                USN_VECTOR *pusnvec;

                if ( (fNewReplica && (msgReqUpdate.ulFlags & DRS_ASYNC_REP)) ||
                     (msgReqUpdate.ulFlags & DRS_CRITICAL_ONLY) ) {
                    pusnvec = &gusnvecFromScratch;
                } else {
                    pusnvec = &msgReqUpdate.usnvecFrom;
                }

                ret2 = UpdateRepsFromRef( pTHS,
                                          DRS_UPDATE_ALL,     // Modify whole repsfrom
                                          pNC,
                                          DRS_FIND_DSA_BY_ADDRESS,
                                          URFR_NEED_NOT_ALREADY_EXIST,
                                          &uuidDsaObjSrc,
                                          &msgReqUpdate.uuidInvocIdSrc,
                                          pusnvec,
                                          &gNullUuid, // transport objectGuid n/a
                                          pmtx_addr,
                                          msgReqUpdate.ulFlags,
                                          prtSchedule,
                                          ulResult,
                                          NULL);
            } __finally {
                EndDraTransaction (!(ret2 || AbnormalTermination()));
            }
        }

        if (!ret) {

            // Return invocation id if new replica and caller wants it.
            Assert( NULL != puuidDsaObjSrc );

            if ( fNewReplica ) {
                *puuidDsaObjSrc = msgUpdReplica.uuidDsaObjSrc;
            }
        }

        // if this is a schema NC sync, and we are successful so far,
        // write the schemaInfo on the schema container if the other
        // side sent it. Don't write during install, when it will be
        // writen normally during schema container replication

        if (DsaIsRunning() && NameMatched(gAnchor.pDMD,pNC) ) {

             fSchInfoChanged = FALSE;
             if (!ret && !(*pulSyncFailure)) {
                 // Update the schema-info value only if the replication
                 // is successful
                 if ( err = WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged) ) {
                     // failed to write Schema Info. May not be harmful
                     // depending on schema change history. Always
                     // log a warning so that admin can manually resync
                     // again to force writing it if the version is indeed
                     // different

                     LogEvent(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_DRA_SCHEMA_INFO_WRITE_FAILED,
                              szInsertUL(err), NULL, NULL);
                 }
             }

            // if any "real" schema changes happened, up the global
            // to keep track of schema changes since boot, so that
            // later schema replications can check if thy have an updated
            // schema cache. Do this even if the whole NC replication
            // failed, since this indicates at least one object has
            // been changed.

            if (MODIFIED_NCTREE_INTERIOR == dwNCModified) {
                IncrementSchChangeCount(pTHS);
            }

            // signal a schema cache update either if any real schema change
            // occurred or if the schemaInfo value is changed

            if ( (MODIFIED_NCTREE_INTERIOR == dwNCModified) || fSchInfoChanged ) {
                if (!SCSignalSchemaUpdateImmediate()) {
                     // couldn't even signal a schema update
                     DRA_EXCEPT (DRAERR_InternalError, 0);
                }
            }
        }

    } __finally {
        // Destroy oustanding async RPC state, if any.
        DRSDestroyAsyncRpcState(pTHS, &AsyncState);

        // No more remaining entries.
        ISET (pcRemRepUpd, 0);
	ISET (pcDRARemReplUpdLnk, 0);
	ISET (pcDRARemReplUpdTot, 0);

        // Clear RPC call details
        EnterCriticalSection(&csLastReplicaMTX);
        pLastReplicaMTX = NULL;
        LeaveCriticalSection(&csLastReplicaMTX);

        TH_free_to_mark(pTHS);

        if (NULL != msgReqUpdate.pUpToDateVecDest) {
            // free allocated up-to-date vector
            THFreeEx(pTHS, msgReqUpdate.pUpToDateVecDest);
        }

        // Entered with transaction, so exit with transaction.
        BeginDraTransaction(SYNC_WRITE);
    }

    return ret;
}



DWORD
UpdateNCValuesHelp(
    IN  THSTATE *pTHS,
    IN  ULONG dntNC,
    IN  SCHEMA_PREFIX_MAP_HANDLE hPrefixMap,
    IN  DWORD cNumValues,
    IN  REPLVALINF *rgValues,
    IN  LPWSTR pszServerName,
    IN  ULONG RepFlags,
    IN  BOOL fIsPreemptable,
    OUT ULONG *pulSyncFailure,
    OUT DWORD *pdwValueCreationCount,
    OUT DWORD *pdwNCModified
    )

/*++

Routine Description:

    Apply an array of value updates.

    This routine is currently designed to be run from inside UpdateNC.
    1. Schema checks have been made
    2. Prefix map is open
    3. Schema critical section is held if necessary
    4. A DRA Transaction has already been started

    Periodic transaction commitment: We commit every n values, same object or not.
    We don't explicitly commit the last n since that will be done when the trans
    ends.  Committing causes a loss of currency.

    Object currency optimization: If we are not committing, and the next object is
    the same as the current object, we note that we are current.

    Object notification:  We notify everytime we lose currency and we haven't
    encountered any errors. Thus we notify every time we switch objects, and
    when we commit. Notifying every commit is a feature since this way we don't have
    to keep track when we hit an error whether there were previously committed
    changes that need to be notified.

Arguments:

    pTHS -
    hPrefixMap - Schema cache prefix map, to convert attrtyp's
    cNumValues - Number of values to apply
    rgValues - Array of values
    pszServerName - Name of source server
    RepFlags - Replication flags
    pulSyncFailure - Set for warnings, preempted and schema mismatch
    pdwNCModified - Whether nc was modified

Return Value:

    DWORD -

--*/

{
    DWORD count, ret = 0;
    REPLVALINF *pReplValInf;
    BOOL fObjectCurrency = FALSE;
    DWORD cCommits = 0, cNotifies = 0;
    LONG cAppliedThisTrans = 0; // signed quantity
    DWORD cTickStart, cTickDiff;
    DWORD dwUpdateValueStatus;

    // We better be in LVR mode
    if (!(pTHS->fLinkedValueReplication)) {
        Assert( !"Can't apply value metadata when not in proper mode!" );
        DRA_EXCEPT(DRAERR_InternalError, ERROR_REVISION_MISMATCH);
    }

    cTickStart = GetTickCount();

    // Values are already sorted, count is 1-based
    for( count = 1, pReplValInf = rgValues;
         count <= cNumValues;
         count++, pReplValInf++ ) {

        __try {
            // Convert attr type to local
            if (!PrefixMapTypes( hPrefixMap, 1, &(pReplValInf->attrTyp) )) {
                DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
            }

            // Apply a single value change
            ret = UpdateRepValue(
                pTHS,
                dntNC,
                RepFlags,
                fObjectCurrency,  // Are we already on the object?
                pReplValInf,
                &dwUpdateValueStatus
                );
        } __except (GetDraException((GetExceptionInformation()), &ret)) {
            ;
        }

        Assert( ret != DRAERR_Preempted );

        // If we are shutting down, abandon this update.
        if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
        }

        // If we have waiting priority threads, stop here
        if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
            ret = DRAERR_Preempted;
        }

        // There are three interesting things going on here: periodic transaction
        // commitment, object notification, and object currency optimization.

        if ( (!ret) || (ret == DRAERR_Preempted) )
        {
            cAppliedThisTrans++;
            if (dwUpdateValueStatus == UPDATE_VALUE_CREATION) {
                (*pdwValueCreationCount)++;
            }

            // See if we need to close off the current batch
            if ( ( ( count % VALUES_APPLIED_PER_TRANS ) == 0) ||
                 (count == cNumValues) ||
                 (ret == DRAERR_Preempted) ||
                 (memcmp( &(pReplValInf->pObject->Guid),
                          &((pReplValInf+1)->pObject->Guid),
                          sizeof( GUID ) ) != 0) )
            {
                ULONG ret2; // don't clobber ret

                // Indicate that a linked value was updated
                ret2 = DBRepl( pTHS->pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING );
                cNotifies++;  
		// TODO: detect nc head only modification
                // at least one interior node modified
                *pdwNCModified = MODIFIED_NCTREE_INTERIOR;

                __try {
                    DBTransOut (pTHS->pDB, !ret2, TRUE);
                } __except(GetDraBusyException(GetExceptionInformation(), &ret2)) {
                    Assert(DRAERR_Busy == ret2);
                }
                
		if (!ret2) {  
                    // Note that the link counters are decremented by the chunks that
                    // are applied in one transaction. Thus they will tend to decrease
                    // in a stairstep rather than a smooth slope.
		    IADJUST(pcDRARemReplUpdLnk, (-cAppliedThisTrans));
		    IADJUST(pcDRARemReplUpdTot, (-cAppliedThisTrans));
                }
		
		DBTransIn (pTHS->pDB);

                cAppliedThisTrans = 0;
		cCommits++;
		
                if (ret2) {
                    ret = ret2;  // only clobber ret if update failed
                }
		

                // Currency lost after DBTransOut
                fObjectCurrency = FALSE;
            } else {
                // Still positioned on same object
                fObjectCurrency = TRUE;
            }

        } else {
            // Abort the last batch if one was in progress
            if (pTHS->pDB->JetRetrieveBits) {
                DBCancelRec(pTHS->pDB);
            }
        }

        // Finish loop on error or preempted
        if (ret) {
            break; // exit for loop
        }
    } // end for

    // This switch statement is intended to mirror the error handling
    // in UpdateNC().
    if (ret) {
        switch (ret) {
        case DRAERR_Shutdown:
        case DRAERR_MissingParent:
            // Don't log for these errors
            break;
        case DRAERR_Busy:
            LogUpdateFailure (pTHS,
                              pszServerName,
                              GetExtDSName( pTHS->pDB ) );
            pTHS->errCode = 0;
            // fall through
        case DRAERR_Preempted:
        case DRAERR_SchemaMismatch:
            *pulSyncFailure = ret;
            ret = 0;
            break;
        default:
            LogUpdateValueFailureNB (pTHS,
                                     pszServerName,
                                     GetExtDSName( pTHS->pDB ),
                                     pReplValInf,
                                     ret);
        }
    }

    cTickDiff = GetTickCount() - cTickStart;

    DPRINT3( 1, "cNumValues = %d, cCommits = %d, cNotifies = %d\n",
             cNumValues, cCommits, cNotifies );
    DPRINT2( 1, "apply time = %d:%d\n",
             ((cTickDiff/1000) / 60),
             ((cTickDiff/1000) % 60) );

    // Make sure that we don't have an update open if we are going to commit...
    Assert( ret || (pTHS->pDB->JetRetrieveBits == 0) );

    return ret;
} /* UpdateNCValuesHelp */

// Note:- When UpdateNC() returns successfully, contents of pdwNCModified tells if
//          the NC has been modified or not.
//          MODIFIED_NOTHING, if nothing in the NC has been modified;
//          MODIFIED_NCHEAD_ONLY, if nc head is the only object that has been modified;
//          MODIFIED_NCTREE_INTERIOR, if at least one object in the NC other than the NC head has been modified;
//
ULONG
UpdateNC(
    IN  THSTATE *                       pTHS,
    IN  DSNAME *                        pNC,
    IN  DRS_MSG_GETCHGREPLY_NATIVE *    pmsgReply,
    IN  LPWSTR                          pszServerName,
    OUT ULONG *                         pulSyncFailure,
    IN  ULONG                           RepFlags,
    OUT DWORD *                         pdwNCModified,
    OUT DWORD *                         pdwObjectCreationCount,
    OUT DWORD *                         pdwValueCreationCount,
    IN  BYTE  *                         pSchemaInfo,
    IN  BOOL                            fIsPreemptable
    )
{
#define MAX_WRITE_CONFLICT_RETRIES (5)

    REPLENTINFLIST *        pentinflist;
    BOOL                    fMoveToLostAndFound = FALSE;
    ULONG                   UpdateStatus = UPDATE_NOT_UPDATED;
    ULONG                   ret = 0;
    SCHEMA_PREFIX_TABLE *     pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap = NULL;
    GUID                    objGuidLostAndFound = {0};
    REPLENTINFLIST *        pentinflistLookAhead = NULL;
    BOOL                    fSDPLocked = FALSE, fSchemaConflict = FALSE;
    BOOL                    fSchemaSync = FALSE;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec = NULL;
    DWORD                       cNumMDVEntriesAlloced = 0;
    BOOL                    fMatch = FALSE;
    ULONG                   dntNC = INVALIDDNT;
    DWORD                   cTickStart;
    DWORD                   cTickDiff;
    DWORD                   NewSchemaIsBetter;
    int                     nOrigThreadPriority;
    BOOL                    fResetThreadPriority = FALSE;
    DWORD                   cNumWriteConflictRetries = 0;
    BOOL                    fRetry = FALSE;
    ULONG                   retTransOut = 0;
    REPLENTINFLIST *        pResults = pmsgReply->pObjects;
    SCHEMA_PREFIX_TABLE *   pRemotePrefixTable = &pmsgReply->PrefixTableSrc;
    USN_VECTOR *            pusnvecSyncPoint = &pmsgReply->usnvecFrom;
    BOOL                    fBypassUpdatesEnabledCheck = FALSE;
    DRS_EXTENSIONS *        pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    // assume no modification
    *pdwNCModified = MODIFIED_NOTHING;

    if (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
        != REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)) {
        // The replication epoch has changed (usually as the result of a domain
        // rename).  We are not supposed to communicate with DCs of other
        // epochs.
        DSNAME *pdnRemoteDsa = draGetServerDsNameFromGuid(pTHS,
                                                          Idx_ObjectGuid,
                                                          &pmsgReply->uuidDsaObjSrc);

        DPRINT3(0, "GetChanges request from %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                pdnRemoteDsa->StringName,
                REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote),
                REPL_EPOCH_FROM_DRS_EXT(pextLocal));

        LogEvent(DS_EVENT_CAT_RPC_SERVER,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                 szInsertDN(pdnRemoteDsa),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));

        THFreeEx(pTHS, pdnRemoteDsa);

        return ERROR_DS_DIFFERENT_REPL_EPOCHS;
    }

    // In the normal running case, check if the schema versions match.
    // If not, fail the call now before doing anything more for
    // domain and config NC

    if (DsaIsRunning()) {
        if ( !NameMatched(gAnchor.pDMD, pNC) ) {
            // Not schema NC. Check schema-info for mismatch
            SCReplReloadCache(pTHS, gInboundCacheTimeoutInMs);

            fMatch = CompareSchemaInfo(pTHS, pSchemaInfo, &NewSchemaIsBetter);
            if (!fMatch) {
                // Set schema mismatch code so that a schema NC
                // sync will be requeued if it is not a new
                // replica add
                LogEvent(
                    DS_EVENT_CAT_REPLICATION,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_DRA_SCHEMA_INFO_MISMATCH,
                    szInsertDN(pNC),
                    szInsertWC(pszServerName),
                    0 );
                if (NewSchemaIsBetter) {
                    // sync the schemaNC and retry syncing the triggering NC
                    *pulSyncFailure = DRAERR_SchemaMismatch;
                    return 0;
                } else {
                    // Don't attempt schemaNC sync
                    return DRAERR_SchemaMismatch;
                }
            }
        }
    }


    // Incorporate any new remote prefixes into our own prefix table.
    if (!PrefixTableAddPrefixes(pRemotePrefixTable)) {
        return DRAERR_SchemaMismatch;
    }

    // Open prefix mapping handle to map remote ATTRTYPs to local ATTRTYPs.
    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
    hPrefixMap = PrefixMapOpenHandle(pRemotePrefixTable, pLocalPrefixTable);

    // Lock the SDP as a reader before entering transaction (bug # 170459) if needed
    pentinflistLookAhead = pResults;
    if ( pentinflistLookAhead && pentinflistLookAhead->pParentGuid)
    {
        // replicated-addition or a rename
        cTickStart = GetTickCount();
        if (!SDP_EnterAddAsReader())
        {
            // Only possible reason for failure here is shutdown
            Assert(eServiceShutdown);

            PrefixMapCloseHandle(&hPrefixMap);

            return DRAERR_Shutdown;
        }

        fSDPLocked = TRUE;

        cTickDiff = GetTickCount() - cTickStart;
        if (cTickDiff > gcMaxTicksToGetSDPLock) {
            Assert(!"Replication was blocked for an inordinate amount of time waiting for the SDP lock!");
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_SDP_LOCK_CONTENTION,
                     szInsertUL((cTickDiff/1000) / 60),
                     szInsertUL((cTickDiff/1000) % 60),
                     NULL);
        }
    }

    // Allocate buffer for meta data vector.
    cNumMDVEntriesAlloced = 50;
    pMetaDataVec = THAllocEx(pTHS, MetaDataVecV1SizeFromLen(cNumMDVEntriesAlloced));

    // if this is a schema NC sync, serialize this with any originating schema
    // change or schema cache load in progress. We use the global no. of schema
    // changes since boot to ascertain if we have a uptodate schema cache or
    // not, since we will be validating against this cache

    if (DsaIsRunning() && NameMatched(gAnchor.pDMD, pNC) ) {
        // Before we acquire the lock, make sure the cache is up-to-date
        SCReplReloadCache(pTHS, gInboundCacheTimeoutInMs);
        SCHEMASTATS_INC(SchemaRepl);
        EnterCriticalSection(&csNoOfSchChangeUpdate);
        fSchemaSync = TRUE;
    }

    __try {
        // If updates are disabled, it's okay to generate writes iff we're
        // demoting this DC and this is us completing a FSMO transfer we
        // initiated as part of the demotion.
        fBypassUpdatesEnabledCheck = draIsCompletionOfDemoteFsmoTransfer(NULL);

        BeginDraTransactionEx(SYNC_WRITE, fBypassUpdatesEnabledCheck);

        // Force all updates to ignore values with metadata
        // This is how we guarantee that old updates are applied with old
        // semantics, even when operating in the new value mode.
        pTHS->pDB->fScopeLegacyLinks = TRUE;

        if ( fSchemaSync &&
                  (((SCHEMAPTR *) pTHS->CurrSchemaPtr)->lastChangeCached < gNoOfSchChangeSinceBoot) ) {

             // The schema cache has gone stale or couldn't be reloaded.
             // Kick off a cache reload and tell our caller to reschedule
             // the resync (ret = 0 and *pulSyncFailure = SchemaMismatch).
             SCHEMASTATS_INC(StaleRepl);
             ret = 0;
             *pulSyncFailure = DRAERR_SchemaMismatch;
             if (!SCSignalSchemaUpdateImmediate()) {
                // couldn't even signal a schema update
                DRA_EXCEPT (DRAERR_InternalError, 0);
             }
             __leave;
        }

        for (pentinflist = pResults;
             pentinflist != NULL;
             pentinflist = fRetry ? pentinflist : pentinflist->pNextEntInf) {

            // fMoveToLostAndFound implies fRetry.
            Assert(!(fMoveToLostAndFound && !fRetry));

            __try {

                // If we haven't yet determined the DNT of the NC head, try to
                // do so now.  Note that this may fail e.g. when performing a
                // replica-add and we have not yet created the NC head.
                if ((INVALIDDNT == dntNC)
                    && !DBFindDSName(pTHS->pDB, pNC)) {
                    dntNC = pTHS->pDB->DNT;
                }

                if (!fRetry) {
                    // This is our first time to visit this particular REPLENTINF.
                    // Convert its embedded remote ATTRTYPs to the corresponding
                    // local values.
                    PROPERTY_META_DATA_EXT_VECTOR * pMetaDataVecExt;
                    PROPERTY_META_DATA_EXT *        pMetaDataExt;
                    PROPERTY_META_DATA *            pMetaData;
                    ATTR *                          pAttr;
                    ENTINF *                        pent;
                    DWORD                           i;

                    pMetaDataVecExt = pentinflist->pMetaDataExt;
                    pent = &pentinflist->Entinf;

                    if (!PrefixMapAttrBlock(hPrefixMap, &pent->AttrBlock)) {
                        DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
                    }

                    // Convert remote meta data vector from wire format.
                    if (cNumMDVEntriesAlloced < pMetaDataVecExt->cNumProps) {
                        DWORD cb = MetaDataVecV1SizeFromLen(pMetaDataVecExt->cNumProps);
                        pMetaDataVec = THReAllocEx(pTHS, pMetaDataVec, cb);
                        cNumMDVEntriesAlloced = pMetaDataVecExt->cNumProps;
                    }

                    pMetaDataVec->dwVersion = VERSION_V1;
                    pMetaDataVec->V1.cNumProps = pMetaDataVecExt->cNumProps;

                    pMetaData = &pMetaDataVec->V1.rgMetaData[0];
                    pMetaDataExt = &pMetaDataVecExt->rgMetaData[0];
                    pAttr = &pent->AttrBlock.pAttr[0];
                    for (i = 0;
                         i < pMetaDataVecExt->cNumProps;
                         i++, pMetaData++, pMetaDataExt++, pAttr++) {
                        pMetaData->attrType           = pAttr->attrTyp;
                        pMetaData->dwVersion          = pMetaDataExt->dwVersion;
                        pMetaData->timeChanged        = pMetaDataExt->timeChanged;
                        pMetaData->uuidDsaOriginating = pMetaDataExt->uuidDsaOriginating;
                        pMetaData->usnOriginating     = pMetaDataExt->usnOriginating;
                    }

                    // Remote-to-local ATTRTYP conversion may have munged our
                    // sort order; re-sort.
                    Assert(0 == offsetof(PROPERTY_META_DATA, attrType));
                    Assert(0 == offsetof(ATTR, attrTyp));
                    qsort(pent->AttrBlock.pAttr,
                          pent->AttrBlock.attrCount,
                          sizeof(pent->AttrBlock.pAttr[0]),
                          &CompareAttrtyp);
                    qsort(pMetaDataVec->V1.rgMetaData,
                          pMetaDataVec->V1.cNumProps,
                          sizeof(pMetaDataVec->V1.rgMetaData[0]),
                          &CompareAttrtyp);

                    // First attempt to commit this update.
                    cNumWriteConflictRetries = 0;
                }
                else if (fMoveToLostAndFound) {
                    // if it is a move to LostAndFound, set the
                    // peninflist->pParentGuid to LostAndFound container's
                    // object guid.
                    if (fNullUuid(&objGuidLostAndFound)) {
                        draGetLostAndFoundGuid(pTHS, pNC, &objGuidLostAndFound);
                        Assert(!fNullUuid(&objGuidLostAndFound));
                    }

                    pentinflist->pParentGuid = &objGuidLostAndFound;
                }

                // Apply any necessary updates.
                ret = UpdateRepObj(pTHS,
                                   dntNC,
                                   &pentinflist->Entinf,
                                   pMetaDataVec,
                                   &UpdateStatus,
                                   RepFlags,
                                   pentinflist->fIsNCPrefix,
                                   pentinflist->pParentGuid,
                                   fMoveToLostAndFound);

                // If we are shutting down, abandon this update.
                if (eServiceShutdown) {
                    ret = DRAERR_Shutdown;
                }
            } __except (GetDraException((GetExceptionInformation()), &ret)) {
                ;
            }
            // One less entry to update.

            // reset MoveToLostAndFound after each iteration so that it
            // will be done only if set explicitly in the switch statement below
            fMoveToLostAndFound = FALSE;
            fRetry = FALSE;

            // Commit or abort the transaction.  Catch only "busy" exceptions;
            // allow all other exceptions to be caught by the outside exception
            // handler.
            //
            // Note that we differentiate between "busy" errors during
            // transaction commit and "busy" errors during the UpdateRepObj()
            // call.  We want to retry only in the specific case where the
            // escrowed update fails.
            __try {
                DBTransOut (pTHS->pDB, !ret, TRUE);
                retTransOut = 0;
            } __except(GetDraBusyException(GetExceptionInformation(), &retTransOut)) {
                Assert(DRAERR_Busy == retTransOut);
            }

            ret = ret ? ret : retTransOut;

            // Just came out of the outer transaction - unlock SDP if needed
            if (fSDPLocked)
            {
                SDP_LeaveAddAsReader();
                fSDPLocked = FALSE;
            }

            if (!ret && !pmsgReply->ulExtendedRet) {
                // Replication operation (as opposed to FSMO op) successfully
                // applied update -- dec the number of outstanding updates.
                PERFDEC(pcRemRepUpd); 
		PERFDEC(pcDRARemReplUpdTot); 
            }

            // About to enter a outer transaction again
            // Lock SDP if the next change to be processed is an addition or rename
            pentinflistLookAhead = pentinflist->pNextEntInf;
            if ((DRAERR_MissingParent == ret) ||
                ((DRAERR_Busy == retTransOut) && pentinflist->pParentGuid) ||
                (pentinflistLookAhead && pentinflistLookAhead->pParentGuid))
            {
                // if UpdateRepObj() returned Missing Parent, we are likely to process
                // the same object again and move it into lostandfound . In this case
                // LockSDP before opening the transaction anyways.
                // Same goes for "busy" on transaction commit of an op that had
                // the lock -- we are likely going to try it again.
                // Otherwise, LockSDP only if the next entry to be processed is an addition or move.
                cTickStart = GetTickCount();
                if (!SDP_EnterAddAsReader())
                {
                    // Only possible reason for failure here is shutdown
                    Assert(eServiceShutdown);
                    ret = DRAERR_Shutdown;
                    __leave;
                }

                fSDPLocked = TRUE;

                cTickDiff = GetTickCount() - cTickStart;
                if (cTickDiff > gcMaxTicksToGetSDPLock) {
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_SDP_LOCK_CONTENTION,
                             szInsertUL((cTickDiff/1000) / 60),
                             szInsertUL((cTickDiff/1000) % 60),
                             NULL);
                }
            }

            DBTransIn (pTHS->pDB);

            // If a higher priority operation is pending, stop here.
            if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
                ret = DRAERR_Preempted;
            }

            if (ret) {

                // Update failed. Try to figure out the cause of failure.

                switch (ret) {

                case DRAERR_Shutdown:
                    // System is shutting down, not an error, don't log
                    break;
                case DRAERR_MissingObject:
                     // An update came in, to an object which does not exist.

                     // Log a specific error
                     LogEvent8(
                         DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_MISSING_OBJECT,
                         szInsertDN( pentinflist->Entinf.pName ),
                         szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                         szInsertDN( pNC ),
                         szInsertWC( pszServerName ),
                         szInsertUSN(pusnvecSyncPoint->usnHighPropUpdate),
                         NULL, NULL, NULL
                     );

                    break;

                case DRAERR_MissingParent:

                    // The parent of the object we tried to add is missing.
                    // We need to determine if this is because we haven't yet
                    // received the parent (in which case we return the error
                    // and the caller will request the ancestors and retry).

                    if (RepFlags & DRS_GET_ANC) {
                        // We already asked for the parent, so the parent object
                        // must also be deleted on the source DSA.  This can
                        // occur in scenarios where an object is deleted on one
                        // replica and a child is added to that object on
                        // another replica within a replication latency.

                        // Move the object to the LostAndFound.  For writeable
                        // replicas, this move will replicate back out to other
                        // DSAs; for read-only replicas, it will not be applied
                        // elsewhere (unless replicating to another GC that has
                        // no better information re the "true" name of this
                        // object than we do).
                        fMoveToLostAndFound = TRUE;
                        fRetry = TRUE;
                        ret = 0;
                        continue;
                    }

                    break;

                case DRAERR_SchemaConflict:
                case DRAERR_EarlierSchemaConflict:
                     // failed because we are replicating in a schema change
                     // that is conflicting with existing schema, or such
                     // a conflict has occured earlier. Go on for now so
                     // that we find other conflicts (but will not commit
                     // anything), but remember for later to return correct
                     // error code.
                     // Clear out thstate error info so that we can continue

                     fSchemaConflict = TRUE;
                     // continue wiith the next object
                     Assert(pTHS->fSchemaConflict);
                     THClearErrors();
                     ret = 0;
                     continue;

                // The following errors are sync failure type errors,
                // we move the error into sync failure and return
                // ret = 0. This allows caller to report general
                // success, save sync point, and return sync
                // failure warning to user.


                case DRAERR_Busy:
                    if ((DRAERR_Busy == retTransOut)
                        && (cNumWriteConflictRetries++ < MAX_WRITE_CONFLICT_RETRIES)) {
                        // We failed to commit the transaction due to a write
                        // conflict during escrowed update.  This indicates e.g.
                        // that one or more members of a group we're adding were
                        // modified between the start of our transaction and the
                        // escrowed update.  This is not unlikely in the case of
                        // a large group, which may take on the order of a
                        // minute to update.
                        //
                        // Bump priority to try to run our update through ahead
                        // of contending clients and try again.

                        if (!fResetThreadPriority) {
                            fResetThreadPriority = TRUE;
                            nOrigThreadPriority = GetThreadPriority(GetCurrentThread());
                            SetThreadPriority(GetCurrentThread(),
                                              THREAD_PRIORITY_ABOVE_NORMAL);
                        }

                        fRetry = TRUE;
                        ret = 0;
                        continue;
                    }

                    // Log busy error.
                    LogUpdateFailure (pTHS, pszServerName,
                                      pentinflist->Entinf.pName);
                    pTHS->errCode = 0;

                // Warning, fAll through

                case DRAERR_Preempted:

                    *pulSyncFailure = ret;
                    ret = 0;
                    break;

                // This is an unexpected error case, which we return to
                // user.

                case DRAERR_SchemaMismatch:
                    // Log Schema mismatch error, abort updating and return
                    *pulSyncFailure = ret;
                    ret = 0;

                    // Increment the perfmon counter
                    PERFINC(pcDRASyncRequestFailedSchemaMismatch);

                    LogEvent(
                        DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_DRA_SCHEMA_MISMATCH,
                        szInsertDN(pentinflist->Entinf.pName),
                        szInsertWC(pszServerName),
                        szInsertDN(pNC)
                        );
                    return ret;
                    break;

                case ERROR_DISK_FULL:
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_UPDATE_FAILURE_DISK_FULL,
                             szInsertDN(pentinflist->Entinf.pName),
                         szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                             szInsertWC(pszServerName) );
                    break;

                case ERROR_DS_OUT_OF_VERSION_STORE:  // Jet out of version store
                    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_DRA_UPDATE_FAILURE_TOO_LARGE,
                                      szInsertDN(pentinflist->Entinf.pName),
                         szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                                      szInsertWC(pszServerName),
                                      szInsertWin32Msg(ret),
                                      NULL, NULL, NULL, NULL,
                                      sizeof(ret),
                                      &ret );
                    break;

                case ERROR_DS_DRA_OBJ_NC_MISMATCH:
                    LogEvent8(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_DRA_OBJ_NC_MISMATCH,
                              szInsertDN(pNC),
                              szInsertDN(pentinflist->Entinf.pName),
                              szInsertUUID(&pentinflist->Entinf.pName->Guid),
                              pentinflist->pParentGuid
                                    ? szInsertUUID(&pentinflist->pParentGuid)
                                    : szInsertSz(""),
                              szInsertWC(pszServerName),
                              NULL, NULL, NULL);

                default:

                    // General error.

                    LogUpdateFailureNB (pTHS,
                                        pszServerName,
                                        pentinflist->Entinf.pName,
                                        &(pentinflist->Entinf.pName->Guid),
                                        ret);
                    break;
                }

                break;          // Exit for(each object) loop

            } else {

                // If we modified an object, record NC as modified
                if (UpdateStatus)
                {
                    if (!pentinflist->fIsNCPrefix)
                    {
                        // at least one interior node modified
                        *pdwNCModified = MODIFIED_NCTREE_INTERIOR;
                    }
                    else if (MODIFIED_NOTHING == *pdwNCModified)
                    {
                        // nc head is the only thing that has been modified so far
                        *pdwNCModified = MODIFIED_NCHEAD_ONLY;
                    }
                    // Count object creations and updates
                    if (UpdateStatus == UPDATE_OBJECT_CREATION)
                    {
                        (*pdwObjectCreationCount)++;
                        DPRINT1( 1, "Created: %ws\n", pentinflist->Entinf.pName->StringName );
                    }
                    else {
                        DPRINT1( 1, "Modified: %ws\n", pentinflist->Entinf.pName->StringName );
                    }
                }

            }
        } // for ()

        // One more try in case no objects applied
        if ((INVALIDDNT == dntNC)
            && !DBFindDSName(pTHS->pDB, pNC)) {
            dntNC = pTHS->pDB->DNT;
        }

        // If there are values, we better be in lvr mode
        Assert( (pmsgReply->cNumValues == 0) || pTHS->fLinkedValueReplication);
        // Should not have been cleared prematurely
        Assert( pTHS->pDB->fScopeLegacyLinks );

        // Apply value changes
        if (!ret && !*pulSyncFailure && pmsgReply->cNumValues) {
            pTHS->pDB->fScopeLegacyLinks = FALSE;

            ret = UpdateNCValuesHelp(
                pTHS,
                dntNC,
                hPrefixMap,
                pmsgReply->cNumValues,
                pmsgReply->rgValues,
                pszServerName,
                RepFlags,
                fIsPreemptable,
                pulSyncFailure,
                pdwValueCreationCount,
                pdwNCModified
                );
        }

    } __finally {

        if (NULL != pTHS->pDB) {
            pTHS->pDB->fScopeLegacyLinks = FALSE;
        }

        EndDraTransaction (!(ret || AbnormalTermination()));

        if (fSchemaSync) {
            LeaveCriticalSection(&csNoOfSchChangeUpdate);
        }

        if (fSDPLocked)
        {
            SDP_LeaveAddAsReader();
            fSDPLocked = FALSE;
        }

        if (fResetThreadPriority) {
            SetThreadPriority(GetCurrentThread(), nOrigThreadPriority);
        }

        THFreeEx(pTHS, pMetaDataVec);

        PrefixMapCloseHandle(&hPrefixMap);
    }

    if (fSchemaConflict) {
        // detected at least one schema conflict. Override all other
        // errors?
        ret = DRAERR_SchemaConflict;
    }
    return ret;
} // end UpdateNC()


LPWSTR
DSaddrFromName(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pdnServer
    )
/*++

Routine Description:

    Derive the network name of a server from its DSNAME.  The returned name is
    thread-allocated and is of the form

    c330a94f-e814-11d0-8207-a69f0923a217._msdcs.CLIFFVDOM.NTDEV.MICROSOFT.COM

    where "CLIFFVDOM.NTDEV.MICROSOFT.COM" is the DNS name of the root domain of
    the DS enterprise (not necessarily the DNS name of the _local_ domain of the
    target server) and "c330a94f-e814-11d0-8207-a69f0923a217" is the stringized
    object guid of the server's NTDS-DSA object.

Arguments:

    pdnServer - DSNAME of the NTDS-DSA object of the server for which the
        network name is desired.  Must have filled-in GUID.

Return Values:

    The corresponding network name, or NULL on failure.

--*/
{
    RPC_STATUS  rpcStatus;
    DWORD       cch;
    LPWSTR      pszServerGuid;
    LPWSTR      pszNetName = NULL;

    Assert( !fNullUuid( &pdnServer->Guid ) );
    Assert( NULL != gAnchor.pwszRootDomainDnsName );

    if ( !gfRunningInsideLsa )
    {
        // Replication is only supported between like configurations.
        // I.e. Either dsamain to dsamain or real DC to real DC.  Thus
        // if we're !gfRunningInsideLsa then so is our partner and netlogon
        // is not registering his GUID names in DNS.  So we revert
        // to netbios machine names and extract it from the NTDS-DSA DN.

        DSNAME  *pdnToCrack;
        DSNAME  *pdnTmp;
        ULONG   len;
        WCHAR   *rdnVal;
        ULONG   rdnLen = MAX_RDN_SIZE;
        ATTRTYP rdnTyp;
        LPWSTR  pszErr;
        LPWSTR  errText = L"DSaddrFromName_ERROR";
        BOOL    fDbOpen = FALSE;

        if ( !pdnServer->NameLen )
        {
            // GUID only name - get the full DN - which we should have!

            if ( !pTHS->pDB )
            {
                DBOpen2(TRUE, &pTHS->pDB);
                fDbOpen = TRUE;
            }

            __try
            {
                if (    DBFindDSName(pTHS->pDB, pdnServer)
                     || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                    0, 0, &len, (UCHAR **) &pdnToCrack ) )
                {
                    LogUnhandledError(ERROR_DS_INTERNAL_FAILURE);
                    pszErr = (LPWSTR) THAllocEx(pTHS,
                                                sizeof(WCHAR)
                                                * (wcslen(errText) + 1));
                    wcscpy(pszErr, errText);
                    return(pszErr);
                }
            }
            __finally
            {
                if ( fDbOpen )
                {
                    DBClose(pTHS->pDB, TRUE);
                }
            }
        }
        else
        {
            pdnToCrack = pdnServer;
        }

        pdnTmp = (DSNAME *) THAllocEx(pTHS, pdnToCrack->structLen);
        rdnVal = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);
        if (    TrimDSNameBy(pdnToCrack, 1, pdnTmp)
             || GetRDNInfo(pTHS, pdnTmp, rdnVal, &rdnLen, &rdnTyp) )
        {
            LogUnhandledError(ERROR_DS_INTERNAL_FAILURE);
            pszErr = (LPWSTR) THAllocEx(pTHS,
                                        sizeof(WCHAR) * (wcslen(errText) + 1));
            wcscpy(pszErr, errText);
            return(pszErr);
        }

        return rdnVal;
    }

    // Stringize the server's GUID.
    rpcStatus = UuidToStringW(&pdnServer->Guid, &pszServerGuid);
    Assert( RPC_S_OK == rpcStatus );

    if ( RPC_S_OK == rpcStatus )
    {
        __try
        {
            Assert(36 == wcslen(pszServerGuid));

            cch = 36 /* guid */ + 8 /* "._msdcs." */
                  + wcslen(gAnchor.pwszRootDomainDnsName) + 1 /* \0 */;

            pszNetName = THAllocEx(pTHS, cch * sizeof(WCHAR));

            swprintf(pszNetName, L"%ls._msdcs.%ls",
                     pszServerGuid, gAnchor.pwszRootDomainDnsName);
        }
        __finally
        {
            RpcStringFreeW(&pszServerGuid);
        }
    }
    else
    {
        // Failed to convert server GUID to string.
        LogUnhandledError( rpcStatus );
    }

    return pszNetName;
}

ULONG
ReqFsmoOpAux(THSTATE *        pTHS,
             DSNAME  *        pFSMO,
             DSNAME  *        pTarget,
             ULONG            RepFlags,
             ULONG            ulOp,
             ULARGE_INTEGER * pliInfo,
             ULONG   *        pulRet)
{
    DRS_MSG_GETCHGREQ_NATIVE msgReq = {0};
    DRS_MSG_GETCHGREPLY_NATIVE msgUpd = {0};
    DSNAME *pNC;
    ULONG ulSyncFailure = 0;
    DWORD dwNCModified = MODIFIED_NOTHING;
    LPWSTR pszServerAddr;
    ULONG err, err1 = 0;
    ULONG stringLen, objectsCreated, valuesCreated;
    BOOL  fSamLock = FALSE;
    BYTE  schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    BOOL  fSchInfoChanged = FALSE;
    SYNTAX_INTEGER it;

    msgReq.uuidDsaObjDest = gAnchor.pDSADN->Guid;
    msgReq.pNC = pFSMO;
    msgReq.ulFlags = RepFlags;
    msgReq.ulExtendedOp = ulOp;
    if ( pliInfo ) {
        msgReq.liFsmoInfo = *pliInfo;
    }

    pNC = FindNCParentDSName(pFSMO, FALSE, FALSE);

    // If the current owner is in the reps-from list of this NC,
    // get the usn vector (else, the usn vector is already set to 0)
    GetUSNForFSMO(pTarget, pNC, &msgReq.usnvecFrom);

    err = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC, &it);
    if (err) {
        return err;
    }

    // Get current UTD vector.
    UpToDateVec_Read(pTHS->pDB,
                     it,
                     UTODVEC_fUpdateLocalCursor,
                     DBGetHighestCommittedUSN(),
                     &msgReq.pUpToDateVecDest);

    /* get address for server represented by pTarget */

    pszServerAddr = DSaddrFromName(pTHS, pTarget);
    if ( NULL == pszServerAddr ) {
        // Translation failed.
        DRA_EXCEPT( DRAERR_InternalError, 0 );
    }


    /* We came in with a transaction, which we ought to close before
     * we go galavanting off to some other server.
     */
    SyncTransEnd(pTHS, TRUE);



    if ( I_DRSIsIntraSiteServer(pTHS, pszServerAddr) ) {
        //
        // Set Fsmo operation to use compression for intra-site operations.
        // If src & dest are both in the same site, we'll take advantage
        // of repl compression.
        //
        msgReq.ulFlags |= DRS_USE_COMPRESSION;
    }

    err = I_DRSGetNCChanges(pTHS,
                            pszServerAddr,
                            NULL,
                            &msgReq,
                            &msgUpd,
                            schemaInfo,
                            NULL);
    if (err) {
        return err;
    }

    if ( ulOp == FSMO_REQ_RID_ALLOC )
    {
        //
        // Grab the SAM lock to avoid write conflicts
        // on the rid set objects - write conflicts
        // could mean a loss of rid pool.
        // Don't start any  "SAM" style transactions
        //
        SampAcquireWriteLock();
        fSamLock = TRUE;
        Assert( pTHS->fSAM == FALSE );
        Assert( pTHS->fSamDoCommit == FALSE );
    }

    _try
    {
        if (msgUpd.cNumObjects) {

            BOOL oldfDRA;
            PVOID oldNewPrefix;
            ULONG oldcNewPrefix;


            // Set the fDRA flag so that schema update, if necessary, can
            // go through

            oldfDRA = pTHS->fDRA;
            pTHS->fDRA = 1;

            // The caller may depend on pTHS->NewPrefix retaining its
            // state across the fsmo transfer. Eg, SampRequestRidPool
            // will use this same thread state and update other attrs
            // after returning from this call. Unfortunately, the update
            // fails in LocalModify if UpdateNC has set pTHS->NewPrefix.
            //
            // Save and restore the state of NewPrefix.

            oldNewPrefix = pTHS->NewPrefix;
            oldcNewPrefix = pTHS->cNewPrefix;

            // Do the way the FSMO protocol rides on top of the replication calls,
            // msgUpd.pNC does not contain the NC DN, but the FSMO object DN, when
            // performing an extended FSMO operation.
            // Pass the true NC in explicitly as the second argument.
            err = UpdateNC(pTHS,
                           pNC,
                           &msgUpd,
                           pszServerAddr,       /* used for logging only */
                           &ulSyncFailure,
                           msgReq.ulFlags,
                           &dwNCModified,
                           &objectsCreated,
                           &valuesCreated,
                           schemaInfo,
                           FALSE /*not preemptable*/);
            pTHS->fDRA = oldfDRA;
            pTHS->NewPrefix = oldNewPrefix;
            pTHS->cNewPrefix = oldcNewPrefix;

            if (!err &&
                !ulSyncFailure) {
                BeginDraTransaction( SYNC_READ_ONLY );
                __try {
                    DBNotifyReplicas(pFSMO, FALSE /* not urgent */ );
                }
                __finally {
                    EndDraTransaction( !AbnormalTermination() );
                }
            }
        }

        // if this is a schema FSMO transfer, and we are successful so far,
        // write the schemaInfo on the schema container if the other
        // side sent it.

        if ( DsaIsRunning() && NameMatched(gAnchor.pDMD,pNC)
               && (msgUpd.ulExtendedRet == FSMO_ERR_SUCCESS) && !err && !ulSyncFailure ) {

            // Since this is schema fsmo transfer, write always irrespective
            // of whether any actual schema changes were done or not; the
            // current fsmo owner should always have the most uptodate
            // schema-info value

            if ( err1 = WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged) ) {

                 // failed to write Schema Info. May not be harmful
                 // depending on schema change history. Always
                 // log a warning so that admin can manually resync
                 // again to force writing it if the version is indeed
                 // different

                 LogEvent(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_SCHEMA_INFO_WRITE_FAILED,
                          szInsertUL(err1), NULL, NULL);
            }

            // if any "real" schema changes happened, up the global
            // to keep track of schema changes since boot, so that
            // later schema replications can check if they have an updated
            // schema cache

            if ( msgUpd.cNumObjects > 1 ) {
                // at least something other than the schema container itself
                // has come in

                IncrementSchChangeCount(pTHS);

            }

            // request a schema cache update if anything worthwhile changed

            if ( (msgUpd.cNumObjects > 1) || fSchInfoChanged ) {

                if (!SCSignalSchemaUpdateImmediate()) {
                     // couldn't even signal a schema update
                     DRA_EXCEPT (DRAERR_InternalError, 0);
                }
            }
        }

    }
    _finally
    {

        if ( fSamLock )
        {
            // Release the sam lock
            Assert( pTHS->fSAM == FALSE );
            Assert( pTHS->fSamDoCommit == FALSE );
            SampReleaseWriteLock( TRUE );  // Commit the non existent changes
            fSamLock = FALSE;
        }

    }

    *pulRet = msgUpd.ulExtendedRet;

    return err;
}
/*++ ReqFSMOOp
 *
 * The client side of a FSMO operation, roughly parallel to ReplicateNC
 *
 * INPUT:
 *  pTHS     - THSTATE pointer
 *  pFSMO    - name of FSMO object
 *  RepFlags - passthrough to replication routines
 *  ulOp     - FSMO operation code (FSMO_REQ_* from mdglobal.h)
 *  pllInfo  - Some extra info to pass to the server
 * OUTPUT:
 *  ulRet    - FSMO result code (FSMO_ERR_* from mdglobal.h)
 * RETURN VALUE:
 *  0        - operation performed, ulRet contains results
 *  non-0    - operation failed, ulRet is not set
 *
 * Note: This routine must be entered with a valid read transaction,
 *       but exits with no transaction open.
 *
 */
ULONG ReqFSMOOp(THSTATE *        pTHS,
                DSNAME  *        pFSMO,
                ULONG            RepFlags,
                ULONG            ulOp,
                ULARGE_INTEGER * pliInfo,
                ULONG   *        pulRet)
{
    DSNAME *pOwner;
    ULONG cbRet;
    ULONG err;
    DWORD isDeleted = FALSE;

    *pulRet = 0; /* set an invalid code */
    
        
    /* Find the relevant FSMO object */
    err = DBFindDSName(pTHS->pDB, pFSMO);
    if (err) {
        return err;
    }

    /* Find the role-owner */
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_FSMO_ROLE_OWNER,
                      0,
                      0,
                      &cbRet,
                      (UCHAR **)&pOwner);
    if (err) {
        return err;
    }

    if (NameMatched(pOwner, gAnchor.pDSADN))
    {
        // It says we are the FSMO owner. The only reason
        // we could have entered here is if IsFSMOSelfOwnershipValid()
        // was FALSE; Fail it with DRAERR_Busy in that case, so that the
        // caller can retry the operation at a later point
        return DRAERR_Busy;
    }

    do {
    
        /*
         * Make sure the owner is still alive
         */
        err = DBFindDSName(pTHS->pDB, pOwner);
        if (err) {
            *pulRet = FSMO_ERR_OWNER_DELETED;
            err = 0;
            break;
        }
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DELETED,
                         &isDeleted, sizeof(DWORD),NULL);
    
        if ( DB_ERR_NO_VALUE == err )
        {
            // Because DBGetSingleValue seems to overwrite isDeleted
            // with trash in the no value case.
            isDeleted = FALSE;
        }
        else if ( DB_success != err )
        {
            *pulRet = FSMO_ERR_EXCEPTION;
            err = 0;
            break;
        }
    
        if (isDeleted) {
            *pulRet = FSMO_ERR_OWNER_DELETED;
            err = 0;
            break;
        }
    
        err = ReqFsmoOpAux(pTHS,
                           pFSMO,
                           pOwner,
                           RepFlags,
                           ulOp,
                           pliInfo,
                           pulRet);
    } while(0);

    if(    ulOp == FSMO_REQ_ROLE
        || ulOp == FSMO_RID_REQ_ROLE
        || ulOp == FSMO_REQ_PDC ){
        // only log when requesting for a role

        if ( err || (*pulRet) != FSMO_ERR_SUCCESS )  {
           LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_FSMO_XFER_FAILURE,
                     szInsertDN(pFSMO),          
                     szInsertDN(pOwner),
                     szInsertDN(gAnchor.pDSADN)    
                     );
        }
        else {
    
            LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_FSMO_XFER,
                      szInsertDN(pFSMO),          
                      szInsertDN(gAnchor.pDSADN),          
                      szInsertDN(pOwner)
                      );
        }
    }
    return err;
}


ULONG
ReqFsmoGiveaway(THSTATE *pTHS,
                DSNAME  *pFSMO,
                DSNAME  *pTarget,
                ULONG   *pExtendedRet)
{
    ULONG err;

    err = ReqFsmoOpAux(pTHS,
                       pFSMO,
                       pTarget,
                       DRS_WRIT_REP,
                       FSMO_ABANDON_ROLE,
                       0,
                       pExtendedRet);

    return err;
}


/*++GetUSNForFSMO
 *
 * If the current FSMO role owner is in the reps-from list of this NC,
 * get the usn vector
 *
 * INPUT: pOwner     : current FSMO Role Owner
 *        pNC        : NC containing the FSMO object
 *        usnvecFrom : place to put the usn vecor in
 *
 * Note: On an error in this routine, we simply exit without setting the
 *       usn vector
*/

void GetUSNForFSMO(DSNAME *pOwner, DSNAME *pNC, USN_VECTOR *usnvecFrom)
{
    REPLICA_LINK *pRepsFromRef;
    ULONG NthValIndex=0;
    UCHAR *pVal = NULL;
    ULONG bufsize = 0, len, err = 0;
    BOOL fFound = FALSE;
    THSTATE *pTHS=pTHStls;

    if ( (pNC == NULL) || (pOwner == NULL) ) {
       return;
    }

    // Assert that the owner's guid is non-null
    Assert(!fNullUuid(&pOwner->Guid));

    // Check if the owner is in our reps-from list

    if (err = DBFindDSName(pTHS->pDB, pNC)) {
        return;
    }

    while (!(DBGetAttVal(pTHS->pDB,++NthValIndex,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        bufsize = max(bufsize,len);

        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        // recalc size if fixed.
        Assert(bufsize >= pRepsFromRef->V1.cb);

        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

        if (!memcmp(&pOwner->Guid, &(pRepsFromRef->V1.uuidDsaObj), sizeof(UUID))) {
            fFound = TRUE;
            break;
        }
    }
    if (fFound) {
        *usnvecFrom = pRepsFromRef->V1.usnvec;
    }
    if ( pVal )
    {
        THFreeEx(pTHS, pVal );
    }
    return;
}


ENTINF*
GetNcPreservedAttrs(
    IN  THSTATE     *pTHS,
    IN  DSNAME      *pNC)
/*++

Routine Description:

    We're now instantiating the head of this NC, for which we previously had only
    an instantiated placeholder NC (with object class CLASS_TOP). An instantiated
    placeholder NC is created during DRA_ReplicaAdd when a mail-based replica is
    added. In the mail-based path, the placeholder NC is created, a reps-from is
    added, but the first synchronization of the NC head does not occur until the
    next scheduled replication.  In the time before the first sync occurs, the KCC
    may have added other mail-based reps-from which we wish to preserve.

    This code is called from in-bound replication, either rpc-based or mail-based.
    It is possible that since the placeholder NC was added, the KCC may have decided
    to remove the mail-based reps-from. Alternately, the KCC may have decided to start
    the addition of an rpc-based replica.  In the rpc case the reps-from is not
    added until after the replication of the NC head. Thus there may or may not be any
    reps-from here to preserve.
    
    Read attributes we wish to preserve from NC head that will be restored
    upon instantiation.
    Note: Only non-replicated attributes are handled here.

Arguments:

    pTHS -- thread state
    pName -- NC object


Return Value:

    Error: NULL
    Success: read list of attrvals

Remarks:
None.


--*/
{
    ENTINFSEL sel;
    // Non-replicated attribute list we wish to preserve
    ATTR      attrSel[] =
    {//   ATTRTYP         ATTRVALBLOCK{valCount, ATTRVAL*}
        { ATT_REPS_TO,               {0, NULL} },
        { ATT_REPS_FROM,             {0, NULL} },
        { ATT_PARTIAL_ATTRIBUTE_SET, {0, NULL} }
    };
    DWORD   cAttrs = sizeof(attrSel) / sizeof(ATTR);
    ENTINF  *pent;
    DWORD   dwErr;

    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = EN_ATTSET_LIST;

    sel.AttrTypBlock.pAttr = attrSel;
    sel.AttrTypBlock.attrCount = cAttrs;

    // we should be on the object
    Assert(CheckCurrency(pNC));

    // alloc entinf to pass GetEntInf & eventually return
    pent = THAllocEx(pTHS, sizeof(ENTINF));
    // ThAlloc zero's out everything. Sanity here.
    Assert(!pent->AttrBlock.attrCount);

    //
    // Get persistent attributes if there are any.
    //
    if (dwErr = GetEntInf(pTHS->pDB, &sel, NULL, pent, NULL, 0, NULL,
                           GETENTINF_NO_SECURITY,
                           NULL, NULL))
    {
        Assert(!"Failed to GetEntInf in GetNcPreservedAttrs");
        DRA_EXCEPT(dwErr, 0);
    }

    if (!pent->AttrBlock.attrCount)
    {
        // attribute doesn't exist locally -
        THFree(pent);
        pent = NULL;
    }

    return pent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drasync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drasync.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop


#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRASYNC:" /* define the subsystem for debugging */


// DRA headers
#include "drsuapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "usn.h"
#include "drauptod.h"
#include "drasch.h"

#include <fileno.h>
#define  FILENO FILENO_DRASYNC


/* LogSyncFailure - Log a replication synchronization failure.
*
*/
void
LogSyncFailure(
    THSTATE *pTHS,
    MTX_ADDR *pmtx_addr,
    DSNAME *pDistName,
    DWORD FailureCode
    )
{
    LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DRA_SYNC_FAILURE,
                      szInsertDN(pDistName),
                      szInsertMTX(pmtx_addr),
                      szInsertWin32Msg(FailureCode),
                      NULL, NULL, NULL, NULL, NULL,
                      sizeof(FailureCode),
                      &FailureCode );
}

ULONG DRA_ReplicaSync(
    THSTATE *       pTHS,
    DSNAME *        pNC,
    UUID *          puuidDsaObj,
    LPWSTR          pszDSA,
    ULONG           ulOptions
    )
{
    ULONG                   ret;
    USN_VECTOR              usnvecLastSync;
    REPLICA_LINK *          pRepsFromRef = 0;
    ULONG                   len;
    ULONG                   dntNC;
    BOOL                    AttExists;
    ULONG                   RepFlags = 0;
    ULONG                   ulSyncFailure = 0;
    SYNTAX_INTEGER          it;
    BOOL                    fDoTwoWaySync = FALSE;
    UPTODATE_VECTOR *       pUpToDateVec;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    BOOL                    fAsyncStarted = FALSE;

    // Log parameters
    LogAndTraceEvent(TRUE,
             DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_DRA_REPLICASYNC_ENTRY,
             EVENT_TRACE_TYPE_START,
             DsGuidReplicaSync,
             szInsertDN(pNC),
             ulOptions & DRS_SYNC_BYNAME
                 ? szInsertWC(pszDSA)
                 : szInsertUUID(puuidDsaObj),
             szInsertHex(ulOptions),NULL,NULL,NULL,NULL,NULL);

    BeginDraTransaction(SYNC_WRITE);

    __try {


        if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                         &it)) {
            DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, ret);
        }

        // Save the DNT of the NC Head
        dntNC = pTHS->pDB->DNT;
        
        // Future maintainers: note the subtle difference 
        // ulOptions - what the caller requested. MAY NOT BE ACCURATE.
        // ulReplicaFlags - persistant flags. Definitive of what state we're in.
        // RepFlags - persistant flags plus subset of caller flags

        if (FPartialReplicaIt(it)) {

            // process any partial attribute set changes - if no change below doesn't
            // do anything; if change, it triggers the necessary actions.
            GC_ProcessPartialAttributeSetChanges(pTHS, pNC, puuidDsaObj);

                // restore in case we'd changed it
            if (pTHS->pDB->DNT != dntNC) {
                if (ret = DBFindDNT(pTHS->pDB, dntNC)) {
                    DRA_EXCEPT (DRAERR_DBError, ret);
                }
            }

            //
            // We have munged repsFrom to initiate PAS cycle, full sync
            // or just let go (in case of all stale). And we had potentially
            // placed a repl AO task which will follow this one if this
            // executes below. Either way, we're ok to continue here.
            //
        }

        // If we are syncing all, find each replica link and queue a
        // sync from each DRA from which we replicate.

        if (ulOptions & DRS_SYNC_ALL) {

            ULONG NthValIndex=0;
            UCHAR *pVal;
            ULONG bufsize = 0;

            // We only do this synchronously, so check that's what the
            // caller wants.

            if (!(ulOptions & DRS_ASYNC_OP)) {
                DRA_EXCEPT_NOLOG (DRAERR_InvalidParameter, 0);
            }

            // Get the repsfrom attribute

            while (!(DBGetAttVal(pTHS->pDB,++NthValIndex,
                                 ATT_REPS_FROM,
                                 DBGETATTVAL_fREALLOC, bufsize, &len,
                                 &pVal))) {
                bufsize = max(bufsize,len);

                VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

                pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
                //note: we preserve pVal for DBGetAttVal realloc
                pVal = (PUCHAR)pRepsFromRef;
                Assert(bufsize >= pRepsFromRef->V1.cb);

                Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

                if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_AUTO_SYNC) ||
                    (ulOptions & DRS_SYNC_FORCED)) {

                    // Ignore persistant flags except for writeability
                    RepFlags = pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP;

                    // Or in any special flags from caller such as
                    // sync mods made by anyone or sync from scratch.
                    // Also pass in no discard flag if set by caller.

                    RepFlags |= (ulOptions & REPSYNC_SYNC_ALL_FLAGS );

                    DirReplicaSynchronize(pNC,
                                          NULL,
                                          &pRepsFromRef->V1.uuidDsaObj,
                                          RepFlags | DRS_ASYNC_OP);
                }
            }
            if(bufsize)
                THFree(pVal);
            ret = 0;

        } else {

            // Find the DSA from which we sync. This is either by name or
            // UUID.

            MTX_ADDR * pmtxDSA = NULL;

            if (ulOptions & DRS_SYNC_BYNAME) {
                pmtxDSA = MtxAddrFromTransportAddrEx(pTHS, pszDSA);
            }

            if ( FindDSAinRepAtt(
                        pTHS->pDB,
                        ATT_REPS_FROM,
                        ( ulOptions & DRS_SYNC_BYNAME )
                            ? DRS_FIND_DSA_BY_ADDRESS
                            : DRS_FIND_DSA_BY_UUID,
                        puuidDsaObj,
                        pmtxDSA,
                        &AttExists,
                        &pRepsFromRef,
                        &len
                        )
               ) {

                // Failed to find replication reference on replica.

                // First ensure that if we are trying to initially sync
                // from this source and it's writeable, we don't anymore.

                if (ulOptions & DRS_SYNC_BYNAME) {
                    InitSyncAttemptComplete (pNC, ulOptions, DRAERR_NoReplica, pszDSA);
                }

                // Then error out.
                DRA_EXCEPT_NOLOG (DRAERR_NoReplica, 0);

            }

            // If found, sync up replica from caller.
            VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

            // Get current UTD vector.
            UpToDateVec_Read(pTHS->pDB,
                             it,
                             UTODVEC_fUpdateLocalCursor,
                             DBGetHighestCommittedUSN(),
                             &pUpToDateVec);

            if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP)){
                //
                // GC ReadOnly cycle
                //  - get partial attr sets
                //

                GC_GetPartialAttrSets(
                    pTHS,
                    pNC,
                    pRepsFromRef,
                    &pPartialAttrSet,
                    &pPartialAttrSetEx);

                Assert(pPartialAttrSet);

                if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS) {
                    // PAS cycle: Ensure consitency: we must have the extended set and
                    // notify admin (event log).
                    // Note the difference between ulOptions and ulReplicaFlags. ulReplicaFlags
                    // is the definitive, persistant state of the pas cycle. PAS is indicated in
                    // ulOptions on a best effort basis and may not always match. It may still be set
                    // on a lingering sync, or may not be set on a periodic sync. PAS gets set/cleared
                    // on ulReplicaFlags through UpdateRepsFromRep, it does NOT passed through here
                    // from ulOptions to ulReplicaFlags (see REPSYNC_REPLICATE_FLAGS).

                    Assert(pPartialAttrSetEx);

                    // Log so the admin knows what's going on.
                    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GC_PAS_CYCLE,
                             szInsertWC(pNC->StringName),
                             szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                             NULL
                             );
                }

            }

            // Sync up only if it is not controlled
            if ((pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_AUTO_SYNC) &&
                !(ulOptions & (DRS_SYNC_FORCED | DRS_PER_SYNC))) {
                 // auto-sync is disabled for this link and sync op didn't
                 // explicitly force it nor is it a periodic sync.
                 ret = DRAERR_SinkDisabled;
                 InitSyncAttemptComplete(pNC, ulOptions, DRAERR_SinkDisabled,
                               TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef)));
            }
            else if (pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP) {

                // If mail replica, send request update message to source.
                draSendMailRequest(
                    pTHS,
                    pNC,
                    ulOptions,
                    pRepsFromRef,
                    pUpToDateVec,
                    pPartialAttrSet,
                    pPartialAttrSetEx
                    );
                
                // By it's very definition mail based replication is 
                // asynchronous, so we should return that the replication is 
                // pending if the ASYNC flag wasn't specified.
                if( !(ulOptions & DRS_ASYNC_OP) ){
                    fAsyncStarted = TRUE;
                }

            } else if ( ( (pRepsFromRef->V1.ulReplicaFlags & AO_PRIORITY_FLAGS) !=
                          (ulOptions & AO_PRIORITY_FLAGS) )
                       && (ulOptions & DRS_ASYNC_OP)) {
                // We have never completed a sync from this RPC source,
                // but this tidbit was unknown to the replication queue.
                // The result?  We've been enqueued at a higher priority
                // than we should have been.  Re-enqueue ourselves at
                // the proper priority and bail.
                ret = DirReplicaSynchronize(
                            pNC,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                            | (pRepsFromRef->V1.ulReplicaFlags &
                               AO_PRIORITY_FLAGS)
                            | (ulOptions &
                               REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED &
                                ~AO_PRIORITY_FLAGS ));
            } else {

                BOOL fRequeueOfInitSync = FALSE;

                // If RPC replica, sync now.

                usnvecLastSync = pRepsFromRef->V1.usnvec;

                RepFlags = pRepsFromRef->V1.ulReplicaFlags;

                // When the sync is complete, we will do a two-way sync
                // if we've been configured for two-way syncs from this
                // source *and* the inbound sync was not enqueued as a
                // result of a two-way sync at the other end.  (The latter
                // to avoid circular syncs.)
                fDoTwoWaySync = (RepFlags & DRS_TWOWAY_SYNC)
                                && !(ulOptions & DRS_TWOWAY_SYNC);

                // Or in any special flags from caller such as
                // sync mods made by anyone or sync from scratch.
                // See note about ulOptions vs RepFlags above

                RepFlags |= (ulOptions & REPSYNC_REPLICATE_FLAGS);

                // If we're in the midst of a TH_mark / TH_free_to_mark, we
                // need to copy the parameters we're passing to
                // ReplicateNC().
                Assert(NULL == pTHS->hHeapOrg);

                // Replicate from source.
                ret = ReplicateNC( pTHS,
                                   pNC,
                                   RL_POTHERDRA(pRepsFromRef),
                                   NULL,
                                   &usnvecLastSync,
                                   RepFlags,
                                   &pRepsFromRef->V1.rtSchedule,
                                   &pRepsFromRef->V1.uuidDsaObj,
                                   &pRepsFromRef->V1.uuidInvocId,
                                   &ulSyncFailure,
                                   FALSE,               // Not new replica
                                   pUpToDateVec,
                                   pPartialAttrSet,
                                   pPartialAttrSetEx);

                // Comment on urgent replication.  If replication failed, do not propagate
                // urgent flag on subsequent attempts.  If failure was congestion related,
                // urgency will only compound the problem.

                if (!ret) {

                    // Retry on flawed sync.  Note, if you add more retriable conditions,
                    // please update the list in drautil.c as well.

                    switch (ulSyncFailure) {

                    case 0:
                        // Success.

                        break;

                    case DRAERR_SourceDisabled:
                    case DRAERR_SinkDisabled:
                        // Replication disabled on one or both ends.
                        // Log failure and don't retry.
                        LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ulSyncFailure);
                        break;

                    case DRAERR_SchemaMismatch:
                        // no need to log event - already logged as soon as we hit the mismatch
                        // in UpdateNC()

                        // Sync of this NC failed because of schema mismatch - so queue a
                        // schema sync from the same source and requeue a sync for
                        // the current NC.

                        // queue a schema sync -- will be executed first
                        DirReplicaSynchronize(
                            gAnchor.pDMD,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                              | (ulOptions
                                 & (DRS_SYNC_BYNAME
                                     | DRS_SYNC_FORCED)));

                        if ( ulOptions & DRS_SYNC_REQUEUE ) {
                            //
                            // We had already requeued this request.
                            // Do not allow yet another requeue cause in some cases
                            // we can get into a tight requeue loop.
                            //
                            // For instance, consider what happens when the schema sync
                            // keeps failing due to, say, missing links in repsFrom due to
                            // bad admin intervention:
                            //   :loop
                            //      - sync NC <x> --> fail w/ DRAERR_SchemaMismatch
                            //      - sync schema here followed by sync NC <x>
                            //      - schema sync failed w/ DRAERR_NoReplica
                            //      - requeued sync of NC <x> fails here, i.e. goto loop...
                            //
                            // Thus, we break the loop here by just notifying the admin
                            // that they need to take action to correct the critical failure to
                            // sync the schema.

                            // Log so the admin knows what's going on.
                            LogEvent8(DS_EVENT_CAT_REPLICATION,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_REPLICATION_SKIP_REQUEUE,
                                      szInsertWC(pNC->StringName),
                                      szInsertUUID(puuidDsaObj),
                                      szInsertUL(ulSyncFailure),
                                      szInsertWin32Msg(ulSyncFailure),
                                      NULL, NULL, NULL, NULL
                                      );

                        }
                        else {
                            //
                            // requeue sync for the NC for which we aborted the sync due to schema mismatch
                            //
                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_ASYNC_OP |
                                DRS_SYNC_REQUEUE |
                                (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }

                        break;

                    default:

                        // Unexpected error, log it.

                        LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ulSyncFailure);

                        // Warning! Fall through to resync NC

                    case DRAERR_Busy:

                        // No need to log these.

                        // If this is an asynchronous synchronize, and not retried,
                        // requeue the operation to run again. (If the
                        // synchronize is sychronous, it's the caller's
                        // responsibility to try again)

                        if ( (ulOptions & DRS_ASYNC_OP)
                             && !(ulOptions & DRS_SYNC_REQUEUE)) {

                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_SYNC_REQUEUE
                                | DRS_ASYNC_OP
                                | (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }
                        break;

                    case DRAERR_Preempted:

                        // No need to log these.

                        // If this is an asynchronous synchronize,
                        // requeue the operation to run again. (If the
                        // synchronize is sychronous, it's the caller's
                        // responsibility to try again)

                        if (ulOptions & DRS_ASYNC_OP) {

                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_ASYNC_OP
                                  | DRS_PREEMPTED
                                  | (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }
                        break;

                    case DRAERR_AbandonSync:

                        // We abandoned an initial sync because we
                        // weren't making progress, so reschedule it.
                        // Note that because of the special flag mask used here, the
                        // DRS_INIT_SYNC_NOW flag is preserved, where it generally
                        // isn't preserved in the other requeues.
                        Assert( ulOptions & DRS_ASYNC_OP );
                        Assert( ulOptions & DRS_INIT_SYNC_NOW );

                        DirReplicaSynchronize(
                            pNC,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                            | DRS_ABAN_SYNC
                            | (ulOptions &
                               REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED));

                        // The purpose of this flag is to detect when we are truely
                        // continuing an init sync (and preserving the INIT_SYNC_NOW
                        // flag), instead of terminating the init sync (throwing away
                        // the flag) and requeuing a normal sync.
                        fRequeueOfInitSync = TRUE;
                        // Don't trigger opposite sync until our sync is
                        // complete or we've given up.
                        fDoTwoWaySync = FALSE;

                        break;
                    }
                } else {
                    // General error, log it. If async and not retried
                    // before, retry
                    LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ret);

                    if ((ulOptions & DRS_ASYNC_OP)
                        && !(ulOptions & DRS_SYNC_REQUEUE)) {

                        DirReplicaSynchronize(
                            pNC,
                            pszDSA,
                            puuidDsaObj,
                            DRS_SYNC_REQUEUE
                              | DRS_ASYNC_OP
                              | (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                        // Don't trigger opposite sync until our sync is
                        // complete or we've given up.
                        fDoTwoWaySync = FALSE;
                    }
                }

                // During initial synchronizations, record whether we synced
                // successfully or encountered an error (such as RPC failure)
                // that means we should give up on this source.
                // We can tell whether this sync is actually an init sync because
                // the DRS_INIT_SYNC_NOW mode flag will be present.

                if (!fRequeueOfInitSync)
                {
                    InitSyncAttemptComplete(pNC, ulOptions,
                             ret ? ret : ulSyncFailure,
                             TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef))
                        );
                }

            } // end of else RPC based replica, sync now.

            if (NULL != pmtxDSA) {
                THFreeEx(pTHS, pmtxDSA);
            }
        }

    } __finally {

        // If we had success, commit, else rollback

        if (pTHS->transactionlevel)
        {
            EndDraTransaction(!(ret || AbnormalTermination()));
        }
    }

    if (fDoTwoWaySync && !eServiceShutdown) {
        // Ask source to now replicate from us.  This is essentially an
        // immediate notification to one specific machine, where that machine
        // generally does not otherwise receive notifications from us (i.e.,
        // because it's in another site).  This functionality is to handle
        // the branch office connecting through the Internet -- see bug 292860.
        DWORD err;
        LPWSTR pszServerName = TransportAddrFromMtxAddrEx(
                                    RL_POTHERDRA(pRepsFromRef));

        Assert(!(ulOptions & DRS_SYNC_ALL));
        Assert(!(ulOptions & DRS_MAIL_REP));
        Assert(NULL != pRepsFromRef);

        err = I_DRSReplicaSync(pTHS,
                               pszServerName,
                               pNC,
                               NULL,
                               &gAnchor.pDSADN->Guid,
                               (DRS_ASYNC_OP
                                | DRS_TWOWAY_SYNC
                                | DRS_UPDATE_NOTIFICATION
                                | (RepFlags & DRS_WRIT_REP)));
        if (err) {
            // If a readonly replica gets the TWOWAY_SYNC flag, it may notify a
            // readonly source.  Ignore resulting errors.
            if ( (err != DRAERR_NoReplica) || (ulOptions & DRS_WRIT_REP) ) {
                // Log notification failure.
                LogEvent8WithData(DS_EVENT_CAT_REPLICATION,
                                  DS_EVENT_SEV_BASIC,
                                  DIRLOG_DRA_NOTIFY_FAILED,
                                  szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                                  szInsertDN(pNC),
                                  szInsertWin32Msg(err),
                                  NULL, NULL, NULL, NULL, NULL,
                                  sizeof(err),
                                  &err);
            }
        }
    }

    // If we had a sync failure but were otherwise successful,
    // return sync failure.

    if ((!ret) && ulSyncFailure) {
        ret = ulSyncFailure;
    }
    if ((!ret) && fAsyncStarted) {
        // Not this fAsyncStarted flag and thus this error is only
        // returned if the ASYNC flag is _not_ specified and the
        // operation was inheriantly asynchronous, such as mail
        // based replication.
        ret = ERROR_DS_DRA_REPL_PENDING;
    }

    LogAndTraceEvent(TRUE,
             DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_DRA_REPLICASYNC_EXIT,
             EVENT_TRACE_TYPE_END,
             DsGuidReplicaSync,
             szInsertUL(ret),NULL,NULL,NULL,NULL,NULL,NULL,NULL);

    return ret;
} // DRA_ReplicaSync


void
draConstructGetChgReq(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pNC,
    IN  REPLICA_LINK *              pRepsFrom,
    IN  UPTODATE_VECTOR *           pUtdVec             OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSet     OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSetEx   OPTIONAL,
    IN  ULONG                       ulOptions,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pMsgReq
    )
/*++

Routine Description:

    Construct a "GetNCChanges" request from the current replication state.

    Common pre-processing or setup for sending a get changes request.

    This code serves asynchonous mail replicas only at present, but could be
    combined in the future with the RPC-based path.

    This code performs similar setup to what happens for the RPC case, see
    line 340-360, and the setup in ReplicateNC.

Arguments:

    pNC (IN) - NC to replicate.

    pRepsFrom (IN) - repsFrom state corresponding to the source DSA.

    pUtdVec (IN) - Current UTD vector for this NC.

    ulOptions (IN) - Caller-supplied options to supplement those embedded in
        the repsFrom.

    pMsgReq (OUT) - The constructed request message.

Return Values:

    None.

--*/
{
    Assert(NULL != pNC);
    Assert(NULL != pRepsFrom);
    Assert(NULL != pMsgReq);

    memset(pMsgReq, 0, sizeof(*pMsgReq));

    VALIDATE_REPLICA_LINK_VERSION(pRepsFrom);

    pMsgReq->ulFlags = pRepsFrom->V1.ulReplicaFlags;

    // Or in any special flags from caller.
    pMsgReq->ulFlags |= ulOptions & GETCHG_REQUEST_FLAGS;

    // Note, ulFlags and ulOptions contain different sets, as follows:
    // ulOptions - What the caller requested, may be >= GETCHG_REQUEST_FLAGS
    // ulFlags - Persistant replica flags, <= RFR_FLAGS,
    //    plus Options, only GETCHG_REQUEST_FLAGS

    if (pMsgReq->ulFlags & DRS_MAIL_REP) {
        // Use ISM transport for replication.
        pMsgReq->cMaxObjects = gcMaxAsyncInterSiteObjects;
        pMsgReq->cMaxBytes   = gcMaxAsyncInterSiteBytes;

        // Note that we currently always request ancestors for
        // mail-based replication, just as Exchange did.  We should be able to
        // eliminate this requirement, though, by properly handling the "missing
        // parent" case in the mail-based code.  The easiest way to do this
        // would be to better integrate the mail- and RPC-based processing of
        // inbound replication messages, in which case the mail-based code would
        // acquire the same handling for this case as the RPC-based code.
        pMsgReq->ulFlags |= DRS_GET_ANC;
        // Tell the source to check for a reps-to, and if so, remove it
        Assert( pMsgReq->ulFlags & DRS_NEVER_NOTIFY );
    }
    else {
        // Use RPC transport for replication.
        Assert( !"This routine is not shared with the RPC path yet" );

        // Packet size will be filled in by I_DRSGetNCChanges().
        Assert(0 == pMsgReq->cMaxObjects);
        Assert(0 == pMsgReq->cMaxBytes);

        // Check reps-to's if caller wants us to, only for non-mail
        pMsgReq->ulFlags |= (ulOptions & DRS_ADD_REF);
    }

    // If we want to sync from scratch, set sync to usn start point.
    if (pMsgReq->ulFlags & DRS_FULL_SYNC_NOW) {
        // Sync from scratch.
        pMsgReq->usnvecFrom = gusnvecFromScratch;
        pMsgReq->ulFlags |= DRS_FULL_SYNC_IN_PROGRESS;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_USER_REQ_FULL_SYNC,
                 szInsertDN(pNC),
                 szInsertUUID(&(pRepsFrom->V1.uuidDsaObj)),
                 szInsertHex(pMsgReq->ulFlags));
    }
    else {
        // Sync picking back up where we left off.
        pMsgReq->usnvecFrom = pRepsFrom->V1.usnvec;

        if (!(pMsgReq->ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) {
            // Send source our current up-to-date vector to use as a filter.
            pMsgReq->pUpToDateVecDest = pUtdVec;
        } else {
            // UTDVEC is null
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_DRA_FULL_SYNC_CONTINUED,
                     szInsertDN(pNC),
                     szInsertUUID(&(pRepsFrom->V1.uuidDsaObj)),
                     szInsertHex(pMsgReq->ulFlags));
        }
    }

    // Request the nc size on the first packet of a full sync series
    if (0 == memcmp( &pMsgReq->usnvecFrom, &gusnvecFromScratch,
                     sizeof(USN_VECTOR) )) {
        pMsgReq->ulFlags |= DRS_GET_NC_SIZE;
    }

    pMsgReq->uuidDsaObjDest    = gAnchor.pDSADN->Guid;
    pMsgReq->uuidInvocIdSrc    = pRepsFrom->V1.uuidInvocId;
    pMsgReq->pNC               = pNC;
    pMsgReq->pPartialAttrSet   = (PARTIAL_ATTR_VECTOR_V1_EXT *) pPartialAttrSet;
    pMsgReq->pPartialAttrSetEx = (PARTIAL_ATTR_VECTOR_V1_EXT *) pPartialAttrSetEx;

    if ((NULL != pMsgReq->pPartialAttrSet)
         || (NULL != pMsgReq->pPartialAttrSetEx)) {
        // send mapping table if we send any attr list.
        pMsgReq->PrefixTableDest = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
        if (AddSchInfoToPrefixTable(pTHS, &pMsgReq->PrefixTableDest)) {
            DRA_EXCEPT(DRAERR_SchemaInfoShip, 0);
        }
    }
}


void
draReportSyncProgress(
    THSTATE *pTHS,
    DSNAME *pNC,
    LPWSTR pszSourceServer,
    DRA_REPL_SESSION_STATISTICS *pReplStats
    )

/*++

Routine Description:

Report on the progress of the sync.

This routine may be called from either the mail-based code (dramail/
ProcessUpdReplica), or the rpc-based code (drancrep/ReplicateNC).

This routine also updates the performance counter variable
DRASyncFullRemaining, which is the number of remaining objects until the
completion of the full sync.

The caller of this function may or may not know the context in which the
latest batch of objects was received.  Incremental or full sync?  First
message, middle or last message?  The mail-based code is organized more like
a asynchonrous completion routine and doesn't have alot of context about
the messages that preceeded it.

Note that the count of objects returned includes both creations and updates.
In the case of a full sync, we should only count the creations when calculating
how many objecs we have received toward the total nc size.

Note, we do not use draGetNCSize to calculate the number of objects received
in this NC because that call does not scale well.

Arguments:

    pNC - Naming context
    pSourceServer - transport server name of source
    pReplStats - Replication session statistics


Return Value:

    None

--*/

{
    ULONG remaining;

    // If no objects received, don't bother
    if ( (pReplStats->ObjectsReceived == 0) &&
         (pReplStats->ValuesReceived == 0) ) {
        return;
    }

    pReplStats->ulTotalObjectsReceived += pReplStats->ObjectsReceived;
    pReplStats->ulTotalObjectsCreated += pReplStats->ObjectsCreated;
    pReplStats->ulTotalValuesReceived += pReplStats->ValuesReceived;
    pReplStats->ulTotalValuesCreated += pReplStats->ValuesCreated;

    // If we have no estimate for number of objects at source, use received
    if (pReplStats->SourceNCSizeObjects == 0) {
        pReplStats->SourceNCSizeObjects = pReplStats->ObjectsReceived;
    }
    if (pReplStats->SourceNCSizeValues == 0) {
        pReplStats->SourceNCSizeValues = pReplStats->ValuesReceived;
    }

    // Log event
    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_DRA_UPDATENC_PROGRESS,
               szInsertDN(pNC),
               szInsertWC(pszSourceServer),
               szInsertUL(pReplStats->ulTotalObjectsReceived),
               szInsertUL(pReplStats->ulTotalObjectsCreated),
               szInsertUL(pReplStats->SourceNCSizeObjects),
               szInsertUL(pReplStats->ulTotalValuesReceived),
               szInsertUL(pReplStats->SourceNCSizeValues),
               szInsertUL(pReplStats->ulTotalValuesCreated)
               );

    // DCPROMO progress reporting hook
    // Do we want to report objects created or objects received here?
    // The source nc size is the maximum objects created
    // We could receive 100 objects, but create none because they are redundant
    if ( gpfnInstallCallBack ) {
        WCHAR numbuf1[20], numbuf2[20];
        WCHAR numbuf3[20], numbuf4[20];
        _itow( pReplStats->ulTotalObjectsCreated, numbuf1, 10 );
        _itow( pReplStats->SourceNCSizeObjects, numbuf2, 10 );
        _itow( pReplStats->ulTotalValuesCreated, numbuf3, 10 );
        _itow( pReplStats->SourceNCSizeValues, numbuf4, 10 );

        if ( (pTHS->fLinkedValueReplication) &&
             (pReplStats->SourceNCSizeValues) ) {
            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATE_PROGRESS_VALUES,
                                     pNC->StringName,
                                     numbuf1,
                                     numbuf2,
                                     numbuf3,
                                     numbuf4 );
        } else {
            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATE_PROGRESS,
                                     pNC->StringName,
                                     numbuf1,
                                     numbuf2,
                                     NULL,
                                     NULL );
        }
    }

    // How many objects are left?
    if (pReplStats->SourceNCSizeObjects > pReplStats->ulTotalObjectsReceived) {
        remaining = pReplStats->SourceNCSizeObjects -
            pReplStats->ulTotalObjectsReceived;
    } else {
        remaining = 0;
    }

    // Performance counter hook
    ISET(pcDRASyncFullRemaining, remaining);

    // Debug output hook
    DPRINT8( 0, "DS FullSync: nc:%ws from:%ws\n"
             "Objects received:%d applied:%d source:%d\n"
             "Values received:%d applied:%d source:%d\n",
             pNC->StringName, pszSourceServer,
             pReplStats->ulTotalObjectsReceived,
             pReplStats->ulTotalObjectsCreated,
             pReplStats->SourceNCSizeObjects,
             pReplStats->ulTotalValuesReceived,
             pReplStats->ulTotalValuesCreated,
             pReplStats->SourceNCSizeValues );

    // Counts for this pass has been reported. Clear them for the next pass.

    pReplStats->ObjectsReceived = 0;
    pReplStats->ObjectsCreated = 0;
    pReplStats->ValuesReceived = 0;
    pReplStats->ValuesCreated = 0;

} /* draReportSyncProgress */

DWORD
ReplicateCrossRefBack(
    DSNAME *                 pdnCR,
    WCHAR *                  wszNamingFsmoDns
    )
/*++

Routine Description:

    This routine is just basically supposed to sync/get the 
    crossRef that we just created (pdnCR) on the Domain 
    Naming FSMO (wszNamingFsmoDns).  NOTE: THIS CODE MUST
    WORK DURING INSTALL TOO.  Therefore you can't just say
    sync the gAnchor.pConfigNC.
        
    It'd be a great improvement if we had the ability to 
    sync/get only the one object we wanted to sync, but for
    now we have to sync the whole config container, which
    we calculate by trimming two DNs off crossRef DN.

Arguments:

    pdnCR [IN] - DN of the crossRef we just created.
    wszNamingFsmoDns [IN] - The name of the DNS name of the
        Domain Naming Master.
        
        BUGBUG: Right now, we've got two different kinds of
        names being provided. NDNCs provide a normal server
        name like server.domain.com, but the install process
        I think provides a name like serverguid._msdcs.dom-
        ain.com.  Ideally we'd like all routines to provide
        the GUID based DNS name.  To do this the BUGBUG in
        GetFsmoDnsAddress() needs to be fixed up to return
        a GUID based DNS name, and NDNC creation needs to be
        tested.  Anyway, this different format of names 
        causes slightly different and odd behaviour:
        1. A guid-based dns name is passed in during dcpromo.
           Replica Add may fail with dn exists. If it does, 
           do a replica sync.
        2. A non-guid based dns name was passed in. Replica 
           Add (actually the ReplicateNC in ReplicaAdd) will
           map the non-guid based dns name into a guid-based
           name. If a reps-from already exists, it will use
           it. If one does not exist, it will be created 
           until the KCC runs again. The Replica Add call
           will have done the sync if it returns success.  
           Calling Replica Sync for a non-guid based name 
           will return NO_REPLICA, because this code DOES
           NOT map the non-guid based name to a guid-based 
           name.  We should not call Replica Sync for the 
           non-guid based dns name.


Return Value:

    Win32 Error, as returned by the various DRA APIs.

--*/
{
    DSNAME *                 pdnConfigNC;
    THSTATE *                pSaveTHS;
    DWORD                    dwErr = ERROR_SUCCESS;
    REPLTIMES                repltimes;
    ULONG                    i;
    ULONG                    iTry = 1;
    ULONG                    nTries = 8;

    memset(&repltimes, 0, sizeof(repltimes));
    for (i=0;i< 84;i++){
        repltimes.rgTimes[i] = 0xff;        // Every 15 minutes
    }

    // This must work at dcpromo, so we can't just use gAnchor.pConfigDN
    pdnConfigNC = THAllocEx(pTHStls, pdnCR->structLen);
    TrimDSNameBy(pdnCR, 2, pdnConfigNC);

    // ---------------------------------------------------------------
    // First, try to add the replica.
    pSaveTHS = THSave();
    __try{

        dwErr = DirReplicaAdd(pdnConfigNC,
                              NULL,
                              NULL,
                              wszNamingFsmoDns,
                              NULL,
                              &repltimes,
                              DRS_DISABLE_AUTO_SYNC | DRS_WRIT_REP);

        DPRINT2(2, "Adding replica to '%S' returned %u\n",
                wszNamingFsmoDns,
                dwErr);

    } __finally {

        THDestroy();
        THRestore(pSaveTHS);

    }

    if(dwErr != DRAERR_DNExists){
        // Whether error or success return, as long as it wasn't 
        // DNExists.
        // If it was an error, we couldn't add the replica.
        // If it was success, we did a ReplicateNC in DirReplicaAdd().
        // If it was DNExists, the repsFrom exists, but we didn't
        //   sync, so fall through and sync.
        return(dwErr);
    }
    // Fall through and do a sync, because the DirReplicaAdd()
    // didn't do the sync if it returned DRAERR_DNExists().

    // ---------------------------------------------------------------
    // Second, try to do a sync
    pSaveTHS = THSave();
    __try{

        dwErr = DirReplicaSynchronize(pdnConfigNC,
                                      wszNamingFsmoDns,
                                      NULL,
                                      DRS_SYNC_BYNAME);

        DPRINT3(2, "Synchronizing NC '%S' from server '%S' returned %u\n",
                pdnConfigNC->StringName,
                wszNamingFsmoDns,
                dwErr);

        // We set up the DirReplicaAdd() just so we wouldn't be able
        // to get this mail based replica error.
        Assert(dwErr != ERROR_DS_DRA_REPL_PENDING);

    } __finally {

        THDestroy();
        THRestore(pSaveTHS);

    }

    Assert(dwErr != ERROR_DS_DRA_NO_REPLICA && "If this happens too often we'll need retry logic, email dsrepl");

    // Should be successful.
    Assert(dwErr == ERROR_SUCCESS);
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\draserv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       draserv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

Server-side RPC entrypoints for the DRS functions


Author:

    DS group

Environment:

Notes:

Context handle is defined in ds\src\dsamain\include\drautil.h

Our context handles are not serialized (see drs.acf), but we must synchronize
concurrent accesses to the context in order to free it.  This is done in 
IDL_DRSUnBind.

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <filtypes.h>
#include <winsock2.h>
#include <lmaccess.h>                   // UF_* constants
#include <crypt.h>                      // password encryption routines
#include <cracknam.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsconfig.h>
#include <gcverify.h>
#include <ntdskcc.h>

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "drauptod.h"
#include "dramail.h"
#include "mappings.h"
#include <samsrvp.h>                    // for SampAcquireWriteLock()
#include "sspi.h"                       // SECPKG_CRED_INBOUND
#include "kerberos.h"                   // MICROSOFT_KERBEROS_NAME_A
#include "pek.h"
#include <xdommove.h>                   // cross domain move helpers
#include <drameta.h>                    // META_STANDARD_PROCESSING
#include <taskq.h>
#include "drarpc.h"

#include <fileno.h>
#define  FILENO FILENO_DRASERV

const GUID g_guidNtdsapi = NtdsapiClientGuid;

// enable X forest version without being in Whistler mode
DWORD gEnableXForest = 0;

extern HANDLE hsemDRAGetChg;

// Wait 15 to 30 seconds for the schema cache to reloaded.
DWORD gOutboundCacheTimeoutInMs = 15000;

// Wait for thread slot in get changes. 5 minutes.

#if DBG
#define DRAGETCHG_WAIT (1000*60*1)
#else
#define DRAGETCHG_WAIT (1000*60*5)
#endif

/* Macro to force alignment of a buffer.  Asumes that it may move pointer
 * forward up to 7 bytes.
 */
#define ALIGN_BUFF(pb)  pb += (8 - ((DWORD)(pb) % 8)) % 8
#define ALIGN_PAD(x) (x * 8)

// List of all outstanding client contexts (and a critsec to serialize access).
LIST_ENTRY gDrsuapiClientCtxList;
CRITICAL_SECTION gcsDrsuapiClientCtxList;
BOOL gfDrsuapiClientCtxListInitialized = FALSE;
DWORD gcNumDrsuapiClientCtxEntries = 0;

VOID
drsReferenceContext(
    IN DRS_HANDLE hDrs,
    IN RPCCALL    rpcCall
    )

/*++

Routine Description:

    Add a reference to the context

Arguments:

    hDrs - context handle

Return Value:

    VOID

--*/

{
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    DRS_EXTENSIONS * pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;
    BOOL fIsNtdsapiClient;
    // Security: check that client did not pass a null context	
    if (NULL == pCtx) {
        // Raise as exception code ERROR_INVALID_HANDLE rather than
        // DSA_EXCEPTION, etc. as the exception code gets propagated to the
        // client side.
        RaiseDsaException(ERROR_INVALID_HANDLE, 0, 0, FILENO, __LINE__,
                          DS_EVENT_SEV_MINIMAL);
    }

    fIsNtdsapiClient = (0 == memcmp(&pCtx->uuidDsa,
                                    &g_guidNtdsapi,
                                    sizeof(GUID)));

    if (   // Not an NTDSAPI client.
           !fIsNtdsapiClient
        && // Our local DRS extensions have changed since the client DC bound.
           ((pCtx->extLocal.cb != pextLocal->cb)
            || (0 != memcmp(pCtx->extLocal.rgb,
                            pextLocal->rgb,
                            pCtx->extLocal.cb)))) {
        // Force the client DC to rebind so that it picks up our recent DRS
        // extension changes.  Note that we don't force NTDSAPI clients to
        // re-bind since they're usually not very interested in our extensions
        // bits and we don't control their rebind logic (i.e., they might just
        // error out on this error rather than attempt to rebind).
        //
        // Note that it's important that we raise an exception that reaches the
        // RPC exception handler (outside of our code) so that an exception is
        // raised on the client side.  This causes this condition to be seen as
        // a communications error (which it is, more or less).  Simply
        // returning an error would be seen by the client as a failure in the
        // DRS RPC function being invoked by the client and would not result in
        // a rebind.
        //
        // Raise as exception code ERROR_DS_DRS_EXTENSIONS_CHANGED rather than
        // DSA_EXCEPTION, etc. as the exception code gets propagated to the
        // client side.
        DPRINT1(0, "Forcing rebind from %s because our DRS_EXTENSIONS have changed.\n",
                inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr)));
        
        RaiseDsaException(ERROR_DS_DRS_EXTENSIONS_CHANGED, 0, 0, FILENO,
                          __LINE__, DS_EVENT_SEV_MINIMAL);
    }

    if (!fIsNtdsapiClient
        && (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
            != REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote))) {
        // The replication epoch has changed (usually as the result of a domain
        // rename).  We are not supposed to communicate with DCs of other
        // epochs.
        DPRINT3(0, "RPC from %s denied - replication epoch mismatch (remote %d, local %d).\n",
                inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr)),
                REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote),
                REPL_EPOCH_FROM_DRS_EXT(pextLocal));

        LogEvent(DS_EVENT_CAT_RPC_SERVER,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                 szInsertSz(inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr))),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote)),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));

        RaiseDsaException(ERROR_DS_DIFFERENT_REPL_EPOCHS,
                          REPL_EPOCH_FROM_DRS_EXT(pextLocal)
                            - REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote),
                          0, FILENO, __LINE__, DS_EVENT_SEV_MINIMAL);
    }

    // Account for another caller using the context
    InterlockedIncrement( &(pCtx->lReferenceCount) );

    DPRINT2( 3, "drsReferenceContext 0x%p, after = %d\n",
             pCtx, pCtx->lReferenceCount );

    pCtx->timeLastUsed = GetSecondsSince1601();

    // Move this context to the end of the list (thereby maintaining ascending
    // sort by last use).
    EnterCriticalSection(&gcsDrsuapiClientCtxList);
    __try {
        RemoveEntryList(&pCtx->ListEntry);
        InsertTailList(&gDrsuapiClientCtxList, &pCtx->ListEntry);
    }
    __finally {
        LeaveCriticalSection(&gcsDrsuapiClientCtxList);
    }

    RPC_TEST(pCtx->IPAddr, rpcCall); 
} /* drsReferenceContext */

VOID
drsDereferenceContext(
    IN DRS_HANDLE hDrs,
    IN RPCCALL rpcCall
    )

/*++

Routine Description:

Remove a reference to a context.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    LONG lNewValue;

    lNewValue = InterlockedDecrement( &(pCtx->lReferenceCount) );
    Assert( lNewValue >= 0 );

    DPRINT2( 3, "drsDereferenceContext 0x%p, after = %d\n", pCtx, lNewValue );
} /* drsDereferenceContext */

BOOL
IsEnterpriseDC(
              IN THSTATE *        pTHS,
              OUT DWORD *         pdwError )
/*++

Routine Description:

    Verify if the caller is an enterprise DC.

Arguments:

    pTHS (IN) - Thread state;

    pdwError (OUT) - The error code if access is denied.

Return Values:

    TRUE - Access granted.

    FALSE - Access denied.

--*/

{

    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pEnterpriseControllersSid = NULL;
    BOOL                        fFound = FALSE;
    NTSTATUS                    NtStatus;

    DPRINT(3,"IsEnterpriseDC entered.\n");

    *pdwError = 0;

    //make SID from RID
    NtStatus = RtlAllocateAndInitializeSid( &ntAuthority,
                                            1,
                                            SECURITY_ENTERPRISE_CONTROLLERS_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &pEnterpriseControllersSid );

    if ( NtStatus != ERROR_SUCCESS )
    {
        *pdwError = RtlNtStatusToDosError(NtStatus);
        goto finished;
    }

    // check group membership
    *pdwError = CheckGroupMembershipAnyClient(pTHS, pEnterpriseControllersSid, &fFound);

finished:
    //
    // if not found, and no error code is set,
    // set it to ERROR_ACCESS_DENIED
    //

    if (!fFound && (0 == *pdwError) ) 
    {
        *pdwError = ERROR_ACCESS_DENIED;
    }

    //
    // clean up
    //

    if (pEnterpriseControllersSid)
    {
        RtlFreeSid(pEnterpriseControllersSid);
    }

    DPRINT1(3,"IsEnterpriseDC returns %s.\n", fFound?"TRUE":"FALSE");

    return fFound;
}



BOOL
IsDraAccessGranted(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pNC,
    IN  const GUID *    pControlAccessRequired,
    OUT DWORD *         pdwError
    )
/*++

Routine Description:

    Verify the caller has the required control access rights for a given
    replication operation.

Arguments:

    pNC (IN) - The NC the operation is being made against.

    pControlAccessRequired (IN) - The GUID of the control access right required
        to perform this operation.

Return Values:

    TRUE - Access granted.

    FALSE - Access denied.

--*/
{
    BOOL                    fAccessGranted;
    ULONG                   err;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    ULONG                   cbSD = 0;
    CLASSCACHE *            pCC;
    BOOL                    fDRA;
    SYNTAX_INTEGER          it;
    BOOL                    bCachedSD = FALSE;

    Assert(!pTHS->fDSA && "Shouldn't perform access checks for trusted clients");

    __try {
        // open dbpos, transaction etc.
        BeginDraTransaction(SYNC_READ_ONLY);
        fDRA = pTHS->fDRA;

        __try {
            // Check Access.  This is a check of the control access right
            // RIGHT_DS_REPLICATION on the NC object.

            // We have three valid cases:
            // (1) The NC is an instantiated object on this machine.
            // (2) The NC is an uninstantiated subref object on this machine.
            // (3) The NC is a phantom on this machine.

            // Cases (2) and (3) cover, e.g., when we're being asked to add a
            // replica of an NC we haven't yet instantiated on this machine.

            // In case (1), we check access against the SD on the object.
            // In cases (2) and (3), we check access against the default SD (the
            // default SD for Domain-DNS objects).

            // There is a special (and frequent) sub-case of (1), which is that
            // the NC in question is our domain NC, whose SD is already
            // cached on the anchor.

            if (NULL == pNC) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
            else if (NameMatched(pNC, gAnchor.pDomainDN) && gAnchor.pDomainSD) {
                pNC = gAnchor.pDomainDN; // Make sure we have a GUID & SID
                pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
                pSD = gAnchor.pDomainSD;
                bCachedSD = TRUE;
            }
            else {

                err = DBFindDSName(pTHS->pDB, pNC);
                if (0 == err) {
                    // pNC is an instantiated object.

                    // Get the instance type.
                    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it,
                                      sizeof(it));
                    if (!(it & IT_NC_HEAD)) {
                        // Not the head of an NC.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_DRA_BAD_INSTANCE_TYPE);
                    }
                    else if (!(it & IT_UNINSTANT)) {
                        // Case (1).  The NC head is instantiated on this
                        // machine; check access against its SD.
                        err = DBGetAttVal(pTHS->pDB,
                                          1,
                                          ATT_NT_SECURITY_DESCRIPTOR,
                                          0,
                                          0,
                                          &cbSD,
                                          (UCHAR **) &pSD);
                        if(err) {
                            Assert(!err);
                            DRA_EXCEPT(DRAERR_BadNC,
                                       ERROR_DS_MISSING_REQUIRED_ATT);
                        }

                        // Get its object class while we're at it.
                        GetObjSchema(pTHS->pDB,&pCC);
                    }
                    // Else case (2) (handled below).
                }
                else if (DIRERR_NOT_AN_OBJECT == err) {
                    // The supposed NC is a phantom on this machine.  Make sure
                    // it really is an NC somewhere by scanning our crossRefs.
                    CROSS_REF * pCR;
                    COMMARG     CommArg;

                    InitCommarg(&CommArg);
                    Assert(!CommArg.Svccntl.dontUseCopy); // read-only is okay

                    pCR = FindExactCrossRef(pNC, &CommArg);
                    if (NULL == pCR) {
                        // Not the head of an NC.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_NO_CROSSREF_FOR_NC);
                    }
                    // Else case (3) (handled below).
                }
                else {
                    // pNC is neither a phantom nor an instantiated object --
                    // we've never heard of it.
                    DRA_EXCEPT(DRAERR_BadNC, err);
                }

                // The DN must have a GUID (required by the access check).
                // If the caller didn't supply it, retrieve it now.
                if (fNullUuid(&pNC->Guid)) {
                    err = DBFillGuidAndSid(pTHS->pDB, pNC);

                    if (err) {
                        LogUnhandledError(err);
                        DRA_EXCEPT(DRAERR_DBError, err);
                    }

                    if (fNullUuid(&pNC->Guid)) {
                        // This is the case where we have a local crossRef that
                        // was created with no guid for the object referred to
                        // by the ncName attribute.  Treat this the same as the
                        // case where the crossRef could not be found, since as
                        // far as this machine is concerned it doesn't really
                        // exist yet.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_NOT_AN_OBJECT);
                    }
                }

                if (NULL == pSD) {
                    // Case (2) or (3).  Check access against the default SD
                    // for Domain-DNS objects.
                    pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
                    Assert(NULL != pCC);

                    err = GetPlaceholderNCSD(pTHS, &pSD, &cbSD);
                    if (err) {
                        LogUnhandledError(err);
                        DRA_EXCEPT(err, 0);
                    }
                }
            }

            Assert(NULL != pCC);
            Assert(NULL != pSD);

            pTHS->fDRA = FALSE;
            fAccessGranted = IsControlAccessGranted(pSD,
                                                    pNC,
                                                    pCC,
                                                    *pControlAccessRequired,
                                                    FALSE);
            if (!fAccessGranted) {
                DPRINT1(0, "Replication client access to %ls was denied.\n",
                        pNC->StringName);
                err = DRAERR_AccessDenied;
            } else {
                err = ERROR_SUCCESS;
            }
        }
        __finally {
            pTHS->fDRA = fDRA;
            EndDraTransaction(TRUE);
        }
    }
    __except(GetDraException(GetExceptionInformation(), &err)) {
        Assert( err );
        fAccessGranted = FALSE;
    }

    if (!bCachedSD) {
        THFreeEx(pTHS, pSD);
    }

    *pdwError = err;

    return fAccessGranted;
}


ULONG
drsGetClientIPAddr(
    IN  RPC_BINDING_HANDLE  hClientBinding,
    OUT ULONG *             pIPAddr
    )
{
    RPC_BINDING_HANDLE hServerBinding;
    unsigned char * pszStringBinding = NULL;
    unsigned char * pszNetworkAddr = NULL;
    ULONG err;

    // Derive a partially bound handle with the client's network address.
    err = RpcBindingServerFromClient(hClientBinding, &hServerBinding);
    if (err) {
        DPRINT1(0, "RpcBindingServerFromClient() failed, error %d!\n", err);
        return err;
    }

    __try {
        // Convert binding handle into string form, which contains, amongst
        // other things, the network address of the client.
        err = RpcBindingToStringBinding(hServerBinding, &pszStringBinding);
        if (err) {
            DPRINT1(0, "RpcBindingToStringBinding() failed, error %d!\n", err);
            __leave;
        }

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_RPC_CONNECTION,
                 szInsertSz(pszStringBinding),
                 NULL,
                 NULL);

        // Parse out the network address.
        err = RpcStringBindingParse(pszStringBinding,
                                    NULL,
                                    NULL,
                                    &pszNetworkAddr,
                                    NULL,
                                    NULL);
        if (err) {
            DPRINT1(0, "RpcBindingToStringBinding() failed, error %d!\n", err);
            __leave;
        }

        *pIPAddr = inet_addr(pszNetworkAddr);
        Assert((0 != *pIPAddr) && "Has bind via LPC been re-enabled?");
    }
    __finally {
        RpcBindingFree(&hServerBinding);

        if (NULL != pszStringBinding) {
            RpcStringFree(&pszStringBinding);
        }

        if (NULL != pszNetworkAddr) {
            RpcStringFree(&pszNetworkAddr);
        }
    }

    return err;
}


ULONG
IDL_DRSBind(
    IN  RPC_BINDING_HANDLE  rpc_handle,
    IN  UUID *              puuidClientDsa,
    IN  DRS_EXTENSIONS *    pextClient,
    OUT PDRS_EXTENSIONS *   ppextServer,
    OUT DRS_HANDLE *        phDrs
    )
{
    ULONG                   ret = DRAERR_Success;
    DRS_CLIENT_CONTEXT *    pCtx;
    DWORD                   cb;
    RPC_AUTHZ_HANDLE        hAuthz;
    ULONG                   authnLevel;
    BOOL                    fIsNtDsApiClient;
    ULONG                   IPAddr;
    RPC_STATUS              rpcStatus;
    DRS_EXTENSIONS *        pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    // This routine does not create a thread state nor open the DB
    // as the routines that it calls, including event logging, do not
    // require a thread state.

    // This routine does double duty for true DRS (aka replication)
    // activities as well as NTDSAPI.DLL activities.  We tell the two
    // apart by the puuidClientDsa GUID - for which the NTDSAPI.DLL
    // client uses a fixed, known value.

    fIsNtDsApiClient = (NULL != puuidClientDsa)
                       && (0 == memcmp(&g_guidNtdsapi, puuidClientDsa,
                                       sizeof(GUID)));

    // All code paths until the NtdsapiMapping label should set
    // DRAERR_* codes.  The are mapped later to WIN32 error codes
    // if the client is NTDSAPI.DLL.

    __try {
        if (DsaIsInstalling()) {
            ret = RPC_S_SERVER_UNAVAILABLE;
            __leave;
        }

        if (NULL == phDrs) {
            ret = DRAERR_InvalidParameter;
            __leave;
        }

        // Initialize the context handle to NULL in case of error.
        *phDrs = NULL;

        ret = drsGetClientIPAddr(rpc_handle, &IPAddr);
        if (ret) {
            __leave;
        } 
	
        // Verify caller used integrity and privacy.  RPC considers privacy
        // a superset of integrity, so if we have privacy we have integrity
        // as well.  NULL binding handle tells RPC you're interested in
        // this thread's info - i.e. current RPC handle.
        rpcStatus = RpcBindingInqAuthClient(
                        NULL, &hAuthz, NULL,
                        &authnLevel, NULL, NULL);
        if ( RPC_S_OK != rpcStatus ||
             authnLevel < RPC_C_PROTECT_LEVEL_PKT_PRIVACY ) {
            // notify debugger, but no event logging to prevent
            // denial of service vulnerability.
            DPRINT1(0, "Warning <%l>: Unable to get appropriate RPC"
                       " privacy level. Rejecting request.\n",
                    rpcStatus);
            // Also, let us know where it is coming from & in
            // what level.
            DPRINT2(0, "IDL_DRSBind - (%s:%d) - no privacy!\n",
                         inet_ntoa(*((IN_ADDR *) &IPAddr)), authnLevel);
            ret = ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION;
            __leave;
        }

#if DBG
        // For NTDSAPI.DLL clients, verify that this is an authenticated user.
        // This should be redundant given what we do in DraIfCallbackFn.
        {
            BYTE * pSid = GetCurrentUserSid();

            if (NULL == pSid) {
                DPRINT1(0, "DraIfCallbackFn did not prevent unauthenticated DsBind from %s!\n",
                        inet_ntoa(*((IN_ADDR *) &IPAddr)));
                Assert(!"DraIfCallbackFn did not prevent unauthenticated DsBind!");
            }
            else {
                free(pSid);
            }
        }
#endif

        if (fIsNtDsApiClient) {
            PERFINC(pcDsClientBind);
        }
        else {
            PERFINC(pcDsServerBind);
        }

        pCtx = malloc(sizeof(*pCtx));
        if (NULL == pCtx) {
            // Could not allocate client context.
            ret = DRAERR_OutOfMem;
            __leave;
        }

        // Client context allocated; initialize it.
        memset(pCtx, 0, sizeof(DRS_CLIENT_CONTEXT));
	pCtx->lReferenceCount = 1;  // +1 for the bind
        pCtx->uuidDsa = puuidClientDsa ? *puuidClientDsa : gNullUuid;
        pCtx->IPAddr = IPAddr;
        pCtx->timeLastUsed = GetSecondsSince1601();
        pCtx->extLocal.cb = min(pextLocal->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
        memcpy(pCtx->extLocal.rgb, pextLocal->rgb, pCtx->extLocal.cb);
	RPC_TEST(IPAddr,IDL_DRSBIND);

        if (NULL != pextClient) {
            pCtx->extRemote.cb = min(pextClient->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
            memcpy(pCtx->extRemote.rgb, pextClient->rgb, pCtx->extRemote.cb);

            // Handle linked value mode protocol extensions
            // Note, we have to check the anchor because we haven't a thread state
            if (!fIsNtDsApiClient) {
                if (IS_LINKED_VALUE_REPLICATION_SUPPORTED(pextLocal)) {
                    // We are already in LVR mode

                    // If client is Whistler build or greater, that is capable of going
                    // to lvr mode, indicate that we have it and assume they will upgrade.
                    // Otherwise, reject
                    if (!IS_DRS_GETCHGREQ_V8_SUPPORTED( pextClient )) {
                        ret = ERROR_REVISION_MISMATCH;
                        __leave;
                    }
                    // Remember that client supports it now
                    SET_DRS_EXT_SUPPORTED( &(pCtx->extRemote),
                                           DRS_EXT_LINKED_VALUE_REPLICATION );
                } else {
                    // We are not in LVR mode

                    // Client supports it, so promote ourselves
                    if (IS_LINKED_VALUE_REPLICATION_SUPPORTED( pextClient )) {
                        DsaEnableLinkedValueReplication( NULL /*nothreadstate*/, TRUE );
                    }
                }
            }
        }
        else {
            pCtx->extRemote.cb = 0;
        }

        // The following can legitimately fail if the connection is
        // over LPC (which implies RPC_C_AUTHN_WINNT authentication)
        // or if the client explicitly asked for or got negotiated
        // down to RPC_C_AUTHN_WINNT authentication.  Rather than fail
        // the connect, we just ignore the error.  Any server side
        // code which expects to have session keys in the client context
        // should explicitly check and return an appropriate error
        // if the session key is missing.

        PEKGetSessionKey2(&pCtx->sessionKey,
                          I_RpcGetCurrentCallHandle());

        // Return context handle to client.
        DPRINT2(3, "DRSBIND from client %s, context = 0x%p\n",
                inet_ntoa(*((IN_ADDR *) &IPAddr)), pCtx);
        *phDrs = pCtx;

        // Save context handle in list.
        EnterCriticalSection(&gcsDrsuapiClientCtxList);
        __try {
            if (!gfDrsuapiClientCtxListInitialized) {
                InitializeListHead(&gDrsuapiClientCtxList);
                Assert(0 == gcNumDrsuapiClientCtxEntries);
                gfDrsuapiClientCtxListInitialized = TRUE;
            }
            InsertTailList(&gDrsuapiClientCtxList, &pCtx->ListEntry);
            ++gcNumDrsuapiClientCtxEntries;
        }
        __finally {
            LeaveCriticalSection(&gcsDrsuapiClientCtxList);
        }

        if (NULL != ppextServer) {
            // Return server extensions to client.

            // NOTE: We don't need to copy the server extension string because
            // we've explicitly defined PDRS_EXTENSIONS in the DRS ACF as
            // allocate(dont_free), which prevents RPC from attempting to
            // free it.
            *ppextServer = pextLocal;
        }
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        ret = DRAERR_InternalError;
    }

    if (fIsNtDsApiClient) {
        // Massage error codes for NTDSAPI.DLL clients.
        switch (ret) {
        case DRAERR_OutOfMem:
            ret = ERROR_NOT_ENOUGH_MEMORY;
            break;

        case DRAERR_AccessDenied:
            ret = ERROR_NOT_AUTHENTICATED;
            break;

        default:
            // Leave return code unchanged.
            break;
        }
    }

    return ret;
}


VOID
drsReleaseContext(
    DRS_CLIENT_CONTEXT *pCtx
    )

/*++

Routine Description:

Do the actual work of freeing the context handle.

This routine should only be called when no other calls are active using
the same context.

May also be called by the context rundown routine if necessary.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{

    DPRINT1( 3, "drsReleaseContext 0x%p\n", pCtx );

    if (NULL != pCtx) {
	pCtx->lReferenceCount = 0; 

	// Free RPC session encryption keys if present.
	if ( pCtx->sessionKey.SessionKeyLength ) {
	    Assert(pCtx->sessionKey.SessionKey);
	    memset(pCtx->sessionKey.SessionKey,
		   0,
		   pCtx->sessionKey.SessionKeyLength);
	    free(pCtx->sessionKey.SessionKey);
	}

	// Remove ctx from list.
	EnterCriticalSection(&gcsDrsuapiClientCtxList);
	__try {
	    RemoveEntryList(&pCtx->ListEntry);
	    --gcNumDrsuapiClientCtxEntries;
	}
	__finally {
	    LeaveCriticalSection(&gcsDrsuapiClientCtxList);
	}
	// Free client context.
	free(pCtx);
    }
} /* drsReleaseContext */

ULONG
IDL_DRSUnbind(
    IN OUT  DRS_HANDLE *phDrs
    )

/*++

Routine Description:

Indicate that the client is finished with the handle.

Mark the handle as no longer valid.

    // I am assuming that execution of this function (and all idl entries)
    // is atomic wrt the rundown routine.  The rundown routine should not run
    // while any call is in progress, and will never ever be run once this
    // routine is entered and does its work.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{
    DRS_CLIENT_CONTEXT *pCtx;
    RPC_STATUS rpcstatus = RPC_S_OK;
    LONG lNewValue;

    if (*phDrs==NULL) {
	RaiseDsaException(ERROR_INVALID_HANDLE, 0, 0, FILENO, __LINE__,
                          DS_EVENT_SEV_MINIMAL);
    }

    DPRINT1(3, "DRSUNBIND, context = 0x%p\n", *phDrs );

    // This routine does not create a thread state nor open the DB
    // as the routines that it calls, including event logging, do not
    // require a thread state.


    RPC_TEST(((DRS_CLIENT_CONTEXT *)*phDrs)->IPAddr,IDL_DRSUNBIND);
    drsDereferenceContext( *phDrs, IDL_DRSUNBIND );

    rpcstatus = RpcSsContextLockExclusive(NULL, *phDrs);
    if (RPC_S_OK == rpcstatus) {
	// if another thread was in this function simultaneous with the current thread,
	// it could have deleted the handle and yet rpcstatus is still 0 (we don't necessarily get
	// ERROR_MORE_WRITES)
	pCtx = (DRS_CLIENT_CONTEXT *) *phDrs;       
	drsReleaseContext(pCtx);
	*phDrs = NULL;
    }
    else if (ERROR_MORE_WRITES != rpcstatus) {
	DPRINT1(0,"RPC Exception (%d) trying to serialize execution.\n", rpcstatus);
	RpcRaiseException(rpcstatus);
    }

    return DRAERR_Success;
}

void
__RPC_USER
DRS_HANDLE_rundown(
    IN  DRS_HANDLE  hDrs
    )
/*++

Routine Description:

    Called by RPC.  Frees RPC client context as a result of client connection
    failure.

    This is also called in general when a client bound, never unbound
    explicitly, and now the client is going away.

    The RPC runtime guarantees that we are serialized wrt other calls

    // I am assuming that execution of this function (and all idl entries)
    // is atomic wrt the rundown routine.  The rundown routine should not run
    // while any call is in progress, and will never ever be run once the
    // unbind routine is entered and does its work.

Arguments:

    hDrs (IN) - the client's context handle.

Return Values:

    None.

--*/
{
    CHAR szUuidDsa[SZUUID_LEN];
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;

    DPRINT2(0, "Running down replication handle 0x%x for server %s.\n",
            hDrs, UuidToStr(&(pCtx->uuidDsa), szUuidDsa));
   
    // count <=0 means rundown called after unbind, which is bad
    // count >1 means rundown called when other calls still active, bad
    Assert( (pCtx->lReferenceCount == 1) && "error: rundown invoked when it should not have been" );

    // Ignore reference count and release the context
    drsReleaseContext( pCtx );
}


ULONG
IDL_DRSReplicaSync(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_REPSYNC *   pmsgSync
    )
{
    THSTATE *   pTHS = NULL;
    ULONG       ret;
    LPWSTR      pwszSourceServer = NULL;

    drsReferenceContext( hDrs, IDL_DRSREPLICASYNC );
    INC( pcThread  );   // Perfmon hook

    __try {

	if (    ( NULL == pmsgSync )
	     || ( 1 != dwMsgVersion )
	   )
	{
	    return DRAERR_InvalidParameter;
	}

	__try
	    {
	    InitDraThread(&pTHS);

	    Assert(1 == dwMsgVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_REPLICA_SYNC_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsReplicaSync,
			     szInsertDN(pmsgSync->V1.pNC),
			     pmsgSync->V1.pszDsaSrc
			     ? szInsertSz(pmsgSync->V1.pszDsaSrc)
			     : szInsertSz(""),
		szInsertUUID(&pmsgSync->V1.uuidDsaSrc),
		szInsertUL(pmsgSync->V1.ulOptions),
		NULL, NULL, NULL, NULL);

	    if (!IsDraAccessGranted(pTHS, pmsgSync->V1.pNC, &RIGHT_DS_REPL_SYNC, &ret)) {
		DRA_EXCEPT_NOLOG(ret, 0);
	    }

	    if (NULL != pmsgSync->V1.pszDsaSrc) {
		pwszSourceServer = UnicodeStringFromString8(CP_UTF8,
							    pmsgSync->V1.pszDsaSrc,
							    -1);
	    }

	    // Restrict out of process callers from setting reserved flags
	    if (pmsgSync->V1.ulOptions & (~REPSYNC_RPC_OPTIONS)) {
		Assert( !"Unexpected replica sync rpc options" );
		ret = DRAERR_InvalidParameter;
		DRA_EXCEPT(ret, 0);
	    }


	    ret = DirReplicaSynchronize(
		pmsgSync->V1.pNC,
		pwszSourceServer,
		&pmsgSync->V1.uuidDsaSrc,
		pmsgSync->V1.ulOptions
		);
	}
	__except( GetDraException( GetExceptionInformation(), &ret ) )
	{
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_REPLICA_SYNC_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsReplicaSync,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
    }
    __finally {
	DEC( pcThread  );   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSREPLICASYNC );
    }
    return ret;
}

ULONG
IDL_DRSGetNCChanges(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_GETCHGREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_GETCHGREPLY *   pmsgOut
    )
{
    ULONG ret;
    THSTATE *pTHS=NULL;
    RPC_STATUS RpcStatus;
    DWORD dwret;
    DSNAME *pNC;
    DRS_MSG_GETCHGREPLY * pmsgOutNew = NULL;
    DRS_CLIENT_CONTEXT * pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    DRS_MSG_GETCHGREQ_NATIVE NativeReq;
    DRS_MSG_GETCHGREPLY_NATIVE NativeReply;
    DWORD cbCompressedBytes=0;

    drsReferenceContext( hDrs, IDL_DRSGETNCCHANGES ); 
    INC(pcThread);                      // PerfMon hook
    INC(pcDRATdsInGetChngs);

    __try {
	
	PERFINC(pcRepl);                                // PerfMon hook		
	
	__try {
	    // Default to old-style reply.  It is important that we set some valid
	    // value before we exit this routine, particulalry in the case where we
	    // generate an exception.
	    *pdwMsgOutVersion = 1;    

	    // Discard request if we're not installed
	    if (DsaIsInstalling()) {
		DRA_EXCEPT_NOLOG(DRAERR_Busy, 0);
	    }

	    InitDraThread(&pTHS);

	    // If the schema cache is stale, reload it
	    SCReplReloadCache(pTHS, gOutboundCacheTimeoutInMs);

	    draXlateInboundRequestToNativeRequest(pTHS,
						  dwMsgInVersion,
						  pmsgIn,
						  &pCtx->extRemote,
						  &NativeReq,
						  pdwMsgOutVersion,
						  NULL,
						  NULL);

	    UpToDateVec_Validate(NativeReq.pUpToDateVecDest);
	    UsnVec_Validate(&NativeReq.usnvecFrom);

	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GETCHG_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsReplicaGetChg,
			     szInsertUUID(&NativeReq.uuidDsaObjDest),
			     szInsertDN(NativeReq.pNC),
			     szInsertUSN(NativeReq.usnvecFrom.usnHighObjUpdate),
			     szInsertUSN(NativeReq.usnvecFrom.usnHighPropUpdate),
			     szInsertUL(NativeReq.ulFlags),
			     szInsertUL(NativeReq.cMaxObjects),
			     szInsertUL(NativeReq.cMaxBytes),
			     szInsertUL(NativeReq.ulExtendedOp));

	    //
	    // Set the set of extensions specified in the context handle into
	    // the thread state.
	    //

	    pTHS->pextRemote = THAllocEx(pTHS, DrsExtSize(&pCtx->extRemote));
	    CopyExtensions(&pCtx->extRemote, pTHS->pextRemote);

	    //
	    // Assure that the LVR levels are compatible
	    // LVR level is negotiated at bind time. Make sure the server state doesn't
	    // change while a binding handle is cached.
	    // This existing cached context is now incompatible. Return an error to
	    // force the client to rebind. The client will do so transparently because
	    // this error is included in drsIsCallComplete (see drsuapi.c).
	    //
	    if ( (pTHS->fLinkedValueReplication != 0) !=
		 (IS_LINKED_VALUE_REPLICATION_SUPPORTED(pTHS->pextRemote) != 0) ) {
		DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
	    }

	    //
	    // Retreive the security context and session key from RPC and set it
	    // on the thread state
	    //

	    PEKGetSessionKey(pTHS, I_RpcGetCurrentCallHandle());

	    // Note that FSMO transfers send the FSMO object name in the "pNC"
	    // field, which is not necessarily the name of the NC.
	    pNC = FindNCParentDSName(NativeReq.pNC, FALSE, FALSE);

	    // Note pNC may be NULL, in which case IsDraAccessGranted will fail with
	    // the correct error code.
	    if (!IsDraAccessGranted(pTHS, pNC, &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
		DRA_EXCEPT_NOLOG(ret, 0);
	    }

	    // One try to get a thread slot
	    dwret = WaitForSingleObject (hsemDRAGetChg, DRAGETCHG_WAIT);
	    if (dwret != WAIT_OBJECT_0) {
		// WAIT_TIMEOUT, WAIT_FAILED, unexpected WAIT codes, ...
		DRA_EXCEPT_NOLOG(ERROR_DS_THREAD_LIMIT_EXCEEDED, dwret);
	    }

	    INC(pcDRATdsInGetChngsWSem);

	    __try {
		// Got a slot, check if we have been cancelled
		RpcStatus = RpcTestCancel();
		if (RpcStatus == RPC_S_OK) {
		    // We've been cancelled, free semaphore and exit.
		    DRA_EXCEPT_NOLOG(DRAERR_RPCCancelled, 0);
		}

		ret = DRA_GetNCChanges(pTHS,
				       NULL,  // Search filter, not used
				       0, // Not the DirSync Control
				       &NativeReq,
				       &NativeReply);

		// The code should have updated this value in all cases
		Assert( ret == NativeReply.dwDRSError );

		if (ret) {
		    __leave;
		}

		UpToDateVec_Validate(NativeReply.pUpToDateVecSrc);
		UsnVec_Validate(&NativeReply.usnvecTo);

		// Add the schemaInfo to the prefix table if client supports it
		if (IS_DRS_SCHEMA_INFO_SUPPORTED(pTHS->pextRemote)) {
		    if (AddSchInfoToPrefixTable(pTHS, &NativeReply.PrefixTableSrc)) {
			ret = DRAERR_SchemaInfoShip;
			__leave;
		    }
		}

		// Convert reply into desired format.
		// Note that we perform compression while still holding the
		// semaphore to avoid saturating the CPU with compression.
        cbCompressedBytes =
		draXlateNativeReplyToOutboundReply(pTHS,
            &NativeReply,
            (NativeReq.ulFlags & DRS_USE_COMPRESSION) ? DRA_XLATE_COMPRESS : 0,
		    &pCtx->extRemote,
		    pdwMsgOutVersion,
		    pmsgOut);
	    } __finally {
		ReleaseSemaphore (hsemDRAGetChg, 1, NULL);
		DEC(pcDRATdsInGetChngsWSem);
	    }

	    if ((NativeReq.ulFlags & DRS_ADD_REF)
		&& !fNullUuid(&NativeReq.uuidDsaObjDest)) {
		// Add a Reps-To the target server if one does not already exist.
		DSNAME DN;
		LPWSTR pszDsaAddr;

		memset(&DN, 0, sizeof(DN));
		DN.Guid = NativeReq.uuidDsaObjDest;
		DN.structLen = DSNameSizeFromLen(0);

		pszDsaAddr = DSaddrFromName(pTHS, &DN);

		DirReplicaReferenceUpdate(
		    NativeReq.pNC,
		    pszDsaAddr,
		    &NativeReq.uuidDsaObjDest,
		    (NativeReq.ulFlags & DRS_WRIT_REP) | DRS_ADD_REF | DRS_ASYNC_OP
		    | DRS_GETCHG_CHECK
		    );
	    }
	}
	__except (GetDraException((GetExceptionInformation()), &ret)) {
	    ;
	}

	// Because we have an except directly before this statement, we don't
	// need to worry about bypassing the following statements.

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GETCHG_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsReplicaGetChg,
			     szInsertUSN(NativeReply.usnvecTo.usnHighObjUpdate),
			     szInsertUSN(NativeReply.usnvecTo.usnHighPropUpdate),
			     szInsertUL(NativeReply.cNumObjects),
			     szInsertUL(NativeReply.cNumBytes),
			     szInsertUL(NativeReply.ulExtendedRet),
			     szInsertUL(ret),
                 szInsertUL(cbCompressedBytes),
                 NULL);
	}

	if (ret)
	    {
	    if (pTHS && pmsgIn) {
		DSNAME DN;
		LPWSTR pszDsaAddr;

		memset(&DN, 0, sizeof(DN));
		DN.Guid = NativeReq.uuidDsaObjDest;
		DN.structLen = DSNameSizeFromLen(0);

		pszDsaAddr = DSaddrFromName(pTHS, &DN);

		DraLogGetChangesFailure( NativeReq.pNC,
					 pszDsaAddr,
					 ret,
					 NativeReq.ulExtendedOp );
	    } else {
		LogEvent(DS_EVENT_CAT_REPLICATION,
			 DS_EVENT_SEV_BASIC,
			 DIRLOG_DRA_CALL_EXIT_BAD,
			 szInsertUL(ret),
			 NULL,
			 NULL);
	    }
	}

	if (pTHS) {
	    ret = DraReturn(pTHS, ret);
	}
    }
    __finally {
	DEC(pcThread);
	DEC(pcDRATdsInGetChngs);
	drsDereferenceContext( hDrs, IDL_DRSGETNCCHANGES );
    }
    return ret;
}


ULONG
IDL_DRSUpdateRefs(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_UPDREFS *   pmsgUpdRefs
    )
{
    ULONG       ret;
    THSTATE *   pTHS = NULL;
    LPWSTR      pwszDestServer = NULL;
    
    drsReferenceContext( hDrs, IDL_DRSUPDATEREFS );
    INC( pcThread  );   // Perfmon hook	

    __try {

	if (    ( NULL == pmsgUpdRefs )
		|| ( 1 != dwMsgVersion )
		)
	    {
	    return DRAERR_InvalidParameter;
	}
        __try
        {
            InitDraThread(&pTHS);

            Assert(1 == dwMsgVersion);
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_UPDREFS_ENTRY,
                             EVENT_TRACE_TYPE_START,
                             DsGuidDrsUpdateRefs,
                             szInsertDN(pmsgUpdRefs->V1.pNC),
                             pmsgUpdRefs->V1.pszDsaDest
                                ? szInsertSz(pmsgUpdRefs->V1.pszDsaDest)
                                : szInsertSz(""),
                             szInsertUUID(&pmsgUpdRefs->V1.uuidDsaObjDest),
                             szInsertUL(pmsgUpdRefs->V1.ulOptions),
                             NULL, NULL, NULL, NULL);

            if (!IsDraAccessGranted(pTHS, pmsgUpdRefs->V1.pNC,
                                    &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
                DRA_EXCEPT_NOLOG(ret, 0);
            }

            if (NULL != pmsgUpdRefs->V1.pszDsaDest) {
                pwszDestServer
                    = UnicodeStringFromString8(CP_UTF8,
                                               pmsgUpdRefs->V1.pszDsaDest,
                                               -1);
            }

            ret = DirReplicaReferenceUpdate(
                        pmsgUpdRefs->V1.pNC,
                        pwszDestServer,
                        &pmsgUpdRefs->V1.uuidDsaObjDest,
                        pmsgUpdRefs->V1.ulOptions
                        );
        }
        __except( GetDraException( GetExceptionInformation(), &ret ) )
        {
            ;
        }

        if (NULL != pTHS) {
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_UPDREFS_EXIT,
                             EVENT_TRACE_TYPE_END,
                             DsGuidDrsUpdateRefs,
                             szInsertUL(ret),
                             NULL, NULL, NULL, NULL,
                             NULL, NULL, NULL);
        }


    }
    __finally {
	DEC( pcThread  );   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSUPDATEREFS );
    }
    return ret;
}


ULONG
IDL_DRSReplicaAdd(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_REPADD *    pmsgAdd
    )
{
    THSTATE *   pTHS = NULL;
    ULONG       ret;
    LPWSTR      pwszSourceServer = NULL;

    drsReferenceContext( hDrs, IDL_DRSREPLICAADD );
    INC( pcThread  );   // Perfmon hook
    __try {
	
	if (!gfInitSyncsFinished) {
	    return DRAERR_Busy;
	}

	if (NULL == pmsgAdd) {
	    return DRAERR_InvalidParameter;
	}

	__try
	    {
	    InitDraThread(&pTHS);

	    switch (dwMsgVersion) {
	    case 1:
		LogAndTraceEvent(TRUE,
				 DS_EVENT_CAT_RPC_SERVER,
				 DS_EVENT_SEV_EXTENSIVE,
				 DIRLOG_IDL_DRS_REPLICA_ADD_ENTRY,
				 EVENT_TRACE_TYPE_START,
				 DsGuidDrsReplicaAdd,
				 szInsertDN(pmsgAdd->V1.pNC),
				 szInsertSz(""),
				 szInsertSz(""),
				 pmsgAdd->V1.pszDsaSrc
				 ? szInsertSz(pmsgAdd->V1.pszDsaSrc)
				 : szInsertSz(""),
		    szInsertUL(pmsgAdd->V1.ulOptions),
		    NULL, NULL, NULL);

		if (!IsDraAccessGranted(pTHS,
					pmsgAdd->V1.pNC,
					&RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
		    DRA_EXCEPT_NOLOG(ret, 0);
		}

		if (NULL != pmsgAdd->V1.pszDsaSrc) {
		    pwszSourceServer
			= UnicodeStringFromString8(CP_UTF8,
						   pmsgAdd->V1.pszDsaSrc,
						   -1);
		}
		ret = DirReplicaAdd(
		    pmsgAdd->V1.pNC,
		    NULL,
		    NULL,
		    pwszSourceServer,
		    NULL,
		    &pmsgAdd->V1.rtSchedule,
		    pmsgAdd->V1.ulOptions
		    );
		break;

	    case 2:
		LogAndTraceEvent(TRUE,
				 DS_EVENT_CAT_RPC_SERVER,
				 DS_EVENT_SEV_EXTENSIVE,
				 DIRLOG_IDL_DRS_REPLICA_ADD_ENTRY,
				 EVENT_TRACE_TYPE_START,
				 DsGuidDrsReplicaAdd,
				 szInsertDN(pmsgAdd->V2.pNC),
				 pmsgAdd->V2.pSourceDsaDN
				 ? szInsertDN(pmsgAdd->V2.pSourceDsaDN)
				 : szInsertSz(""),
		    pmsgAdd->V2.pTransportDN
		    ? szInsertDN(pmsgAdd->V2.pTransportDN)
		: szInsertSz(""),
		    pmsgAdd->V2.pszSourceDsaAddress
		    ? szInsertSz(pmsgAdd->V2.pszSourceDsaAddress)
		: szInsertSz(""),
				     szInsertUL(pmsgAdd->V2.ulOptions),
				     NULL, NULL, NULL);

		if (!IsDraAccessGranted(pTHS,
					pmsgAdd->V2.pNC,
					&RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
		    DRA_EXCEPT_NOLOG(ret, 0);
		}

		if (NULL != pmsgAdd->V2.pszSourceDsaAddress) {
		    pwszSourceServer
			= UnicodeStringFromString8(CP_UTF8,
						   pmsgAdd->V2.pszSourceDsaAddress,
						   -1);
		}

		ret = DirReplicaAdd(
		    pmsgAdd->V2.pNC,
		    pmsgAdd->V2.pSourceDsaDN,
		    pmsgAdd->V2.pTransportDN,
		    pwszSourceServer,
		    NULL,
		    &pmsgAdd->V2.rtSchedule,
		    pmsgAdd->V2.ulOptions
		    );
		break;

	    default:
		Assert(!"Logic error!");
		ret = DRAERR_InvalidParameter;
	    }
	}
	__except( GetDraException( GetExceptionInformation(), &ret ) )
	{
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_REPLICA_ADD_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsReplicaAdd,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}
    }
    __finally {
	DEC( pcThread  );   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSREPLICAADD );
    }
    return ret;
}


ULONG
IDL_DRSReplicaModify(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPMOD *    pmsgMod
    )
{
    THSTATE *   pTHS = NULL;
    ULONG       draError = DRAERR_InternalError;
    LPWSTR      pwszSourceServer = NULL;
    
    drsReferenceContext( hDrs, IDL_DRSREPLICAMODIFY);
    INC( pcThread  );   // Perfmon hook

    __try {
	
	if (    ( NULL == pmsgMod )
		|| ( 1 != dwMsgVersion )
		)
	    {
	    return DRAERR_InvalidParameter;
	}
	
	__try
        {
            InitDraThread(&pTHS);

            Assert(1 == dwMsgVersion);
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_REPLICA_MODIFY_ENTRY,
                             EVENT_TRACE_TYPE_START,
                             DsGuidDrsReplicaModify,
                             szInsertDN(pmsgMod->V1.pNC),
                             szInsertUUID(&pmsgMod->V1.uuidSourceDRA),
                             pmsgMod->V1.pszSourceDRA
                                ? szInsertSz(pmsgMod->V1.pszSourceDRA)
                                : szInsertSz(""),
                             szInsertUL(pmsgMod->V1.ulReplicaFlags),
                             szInsertUL(pmsgMod->V1.ulModifyFields),
                             szInsertUL(pmsgMod->V1.ulOptions),
                             NULL, NULL);

            if (!IsDraAccessGranted(pTHS,
                                    pmsgMod->V1.pNC,
                                    &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &draError)) {
                DRA_EXCEPT_NOLOG(draError, 0);
            }

            if (NULL != pmsgMod->V1.pszSourceDRA) {
                pwszSourceServer
                    = UnicodeStringFromString8(CP_UTF8,
                                               pmsgMod->V1.pszSourceDRA,
                                               -1);
            }

            draError = DirReplicaModify(
                            pmsgMod->V1.pNC,
                            &pmsgMod->V1.uuidSourceDRA,
                            NULL, // puuidTransportObj
                            pwszSourceServer,
                            &pmsgMod->V1.rtSchedule,
                            pmsgMod->V1.ulReplicaFlags,
                            pmsgMod->V1.ulModifyFields,
                            pmsgMod->V1.ulOptions
                            );
        }
        __except ( GetDraException( GetExceptionInformation(), &draError ) )
        {
            ;
        }

        if (NULL != pTHS) {
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_REPLICA_MODIFY_EXIT,
                             EVENT_TRACE_TYPE_END,
                             DsGuidDrsReplicaModify,
                             szInsertUL(draError),
                             NULL, NULL, NULL, NULL,
                             NULL, NULL, NULL);
        }

    }
    __finally {
	DEC( pcThread  );   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSREPLICAMODIFY );
    }
    return draError;
}


ULONG
IDL_DRSReplicaDel(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPDEL *    pmsgDel
    )
{
    THSTATE *   pTHS = NULL;
    ULONG       ret;
    LPWSTR      pwszSourceServer = NULL;

    drsReferenceContext( hDrs, IDL_DRSREPLICADEL);
    INC( pcThread );    // Perfmon hook

    __try {
       	 
	if (    ( NULL == pmsgDel )
		|| ( 1 != dwMsgVersion )
		)
	    {
	    return DRAERR_InvalidParameter;
	}
        
	__try
        {
            InitDraThread(&pTHS);

            Assert(1 == dwMsgVersion);
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_REPLICA_DEL_ENTRY,
                             EVENT_TRACE_TYPE_START,
                             DsGuidDrsReplicaDel,
                             szInsertDN(pmsgDel->V1.pNC),
                             pmsgDel->V1.pszDsaSrc
                                ? szInsertSz(pmsgDel->V1.pszDsaSrc)
                                : szInsertSz(""),
                             szInsertUL(pmsgDel->V1.ulOptions),
                             NULL, NULL, NULL, NULL, NULL);

            if (!IsDraAccessGranted(pTHS,
                                    pmsgDel->V1.pNC,
                                    &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
                DRA_EXCEPT_NOLOG(ret, 0);
            }

            if (NULL != pmsgDel->V1.pszDsaSrc) {
                pwszSourceServer
                    = UnicodeStringFromString8(CP_UTF8,
                                               pmsgDel->V1.pszDsaSrc,
                                               -1);
            }

            ret = DirReplicaDelete(
                     pmsgDel->V1.pNC,
                     pwszSourceServer,
                     pmsgDel->V1.ulOptions
                     );
        }
        __except( GetDraException( GetExceptionInformation(), &ret ) )
        {
            ;
        }

        if (NULL != pTHS) {
            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_REPLICA_DEL_EXIT,
                             EVENT_TRACE_TYPE_END,
                             DsGuidDrsReplicaDel,
                             szInsertUL(ret),
                             NULL, NULL, NULL, NULL,
                             NULL, NULL, NULL);
        }

    }
    __finally {
	DEC( pcThread  );   // Perfmon hook
	drsDereferenceContext( hDrs, IDL_DRSREPLICADEL );
    }
    return ret;
}

VOID
SplitSamAccountName(
    IN  WCHAR *AccountName,
    OUT WCHAR **DomainName,
    OUT WCHAR **UserName,
    OUT WCHAR **Separator
    )
//
// This simple routine breaks up a nt4 style composite name
// Note: the in arg AccountName is modified; Separator can be
// used to reset
//
{
    Assert( AccountName );
    Assert( DomainName );
    Assert( UserName );
    Assert( Separator );

    (*Separator) = wcschr( AccountName, L'\\' );
    if ( (*Separator) ) {
        *(*Separator) = L'\0';
        (*UserName) = (*Separator) + 1;
        (*DomainName) = AccountName;
    } else {
        (*UserName)  = AccountName;
        (*DomainName) = NULL;
    }

    return;
}

VOID
VerifySingleSamAccountNameWorker(
    IN THSTATE *    pTHS,
    IN PVOID        FilterValue,
    IN ULONG        FilterValueSize,
    IN ULONG        AttrType,
    IN DSNAME *     pSearchRoot,
    IN ULONG        Scope,
    IN BOOL         fSearchEnterprise,
    IN ATTRBLOCK    RequiredAttrs,
    OUT SEARCHRES **pSearchRes
)
/*++

    Routine Description

        This routine does a SearchBody() call on the parameters passed in.

    Parameters:

        pTHS              -- thread state
        UserName          -- the single name to lookup
        AttrType          -- sam account name or UPN
        pSearchRoot       -- the base of the search (domain or enterprise)
        fSearchEnterprise -- boolean on whether to span NC's
        RequiredAttrs     -- the attributes to return to the caller
        pSearchRes        -- the results of the search (allocated in this routine)

    Return Values:

        None --  the results of the search contain the desired information

--*/
{
    FILTER          filter;
    SEARCHARG       searchArg;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;

    // Set up the search arg
    attrValFilter.valLen = FilterValueSize;
    attrValFilter.pVal = (UCHAR *) FilterValue;

    memset(&filter, 0, sizeof(filter));
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = AttrType;
    filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    // We just want one result
    searchArg.CommArg.ulSizeLimit = 1;

    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = (UCHAR) Scope;
    searchArg.bOneNC = !fSearchEnterprise;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;

    (*pSearchRes) = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    (*pSearchRes)->CommRes.aliasDeref = FALSE;
    (*pSearchRes)->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, (*pSearchRes),0);

    return;

}


VOID
VerifySingleSamAccountName(
    IN THSTATE * pTHS,
    IN WCHAR*    AccountName,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine verifies a Single sam account name, by issuing a Search.
        If the name does not have a domain component, then we first try to
        search by UPN.

    Parameters:

        AccountName   -- The name to search
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf       -- Pointer to enfinf structure returning the
                         DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
        The error is in the thread state.

--*/
{
    NTSTATUS        NtStatus;
    DSNAME          *pSearchRoot = NULL;
    BOOL            fFreeSearchRoot = FALSE;
    SEARCHRES       *pSearchRes = NULL;
    BOOL            fSearchEnterprise = FALSE;
    ULONG           len;
    ULONG           AttrType;
    BOOL            fCheckXForest = FALSE;

    WCHAR           *DomainName = NULL, *UserName = NULL, *Separator = NULL;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    _try
    {
        ULONG cNamesCracked = 0;
        CrackedName *pCrackedNames = NULL;
        PVOID pData = NULL;
        ULONG cbData = 0;
        ULONG Scope = 0;

        //
        // First, split the name so we can determine what domain to search
        // for; if no domain then search the entire catalog.  Since sam account
        // name is indexed this isn't a bad as it sounds.
        //
        SplitSamAccountName( AccountName, &DomainName, &UserName, &Separator );

        Assert( UserName );
        if ( !UserName ) {
            // No user name? -- this is a bad parameter
            DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
        }

        if ( DomainName ) {

            len = 0;
            NtStatus = MatchDomainDnByNetbiosName( DomainName,
                                                   NULL,
                                                   &len );
            if ( NT_SUCCESS( NtStatus ) ) {

                pSearchRoot = (DSNAME*) THAllocEx(pTHS,len);
                fFreeSearchRoot = TRUE;
                NtStatus = MatchDomainDnByNetbiosName( DomainName,
                                                       pSearchRoot,
                                                       &len );
            }

            if ( !NT_SUCCESS( NtStatus)  ) {
                //
                // Try by dns name
                //
                len = 0;
                NtStatus = MatchDomainDnByDnsName( DomainName,
                                                   NULL,
                                                  &len );
                if ( NT_SUCCESS( NtStatus ) ) {

                    if (fFreeSearchRoot) {
                        THFreeEx(pTHS,pSearchRoot);
                        fFreeSearchRoot = FALSE;
                    }
                    pSearchRoot = (DSNAME*) THAllocEx(pTHS,len);
                    fFreeSearchRoot = TRUE;
                    NtStatus = MatchDomainDnByDnsName( DomainName,
                                                       pSearchRoot,
                                                       &len );
                }
            }

            if ( !NT_SUCCESS( NtStatus ) ) {

                //
                // Hmm. The domain can't be found.  Could it be
                // a cross-forest name? Will verify outside the _try block.
                //
                
                fCheckXForest = TRUE;
                _leave;
            }

            //
            // Set up parameters to the worker function
            //
            Scope = SE_CHOICE_WHOLE_SUBTREE;
            fSearchEnterprise = FALSE;
            AttrType = ATT_SAM_ACCOUNT_NAME;
            pData = UserName;
            cbData = wcslen(UserName) * sizeof(WCHAR);
            Assert( pSearchRoot );


        } else {

            //
            // Crack the name as a UPN.
            // N.B. If there are duplicate UPN's then crack name will
            // fail with
            //
            CrackNames( (gEnableXForest||(gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WHISTLER))?
                                DS_NAME_FLAG_TRUST_REFERRAL
                               :DS_NAME_NO_FLAGS,
                        GetACP(),  // what is the right value here?
                        GetSystemDefaultLangID(),
                        DS_USER_PRINCIPAL_NAME,
                        DS_NT4_ACCOUNT_NAME,
                        1,
                        &AccountName,
                        &cNamesCracked,
                        &pCrackedNames );

            // The function definition of CrackNames is such that the count
            // returned should always be the count given
            Assert( cNamesCracked == 1 );
            Assert( pCrackedNames );

            // Parse the results
            if ( CrackNameStatusSuccess(pCrackedNames[0].status)
             &&  (pCrackedNames[0].pDSName)
             &&  (pCrackedNames[0].pDSName->SidLen > 0) )
             {
                 //
                 // This is a UPN
                 //
                 Scope = SE_CHOICE_BASE_ONLY;
                 fSearchEnterprise = FALSE;
                 AttrType = ATT_OBJECT_SID;
                 pData = &pCrackedNames[0].pDSName->Sid;
                 cbData = pCrackedNames[0].pDSName->SidLen;
                 pSearchRoot = pCrackedNames[0].pDSName;

             } 
            else if ( DS_NAME_ERROR_TRUST_REFERRAL == pCrackedNames[0].status ) {
               
                // A hint is only returned to the caller if the whole forest
                // is in Whistler mode.

                Assert(gEnableXForest||gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WHISTLER);

                Assert(pCrackedNames[0].pDnsDomain);
                
                //
                // fabricate ENTINF data structure
                //

                pEntinf->pName = NULL;          
                pEntinf->ulFlags = 0;        
                pEntinf->AttrBlock.attrCount = 1;
                pEntinf->AttrBlock.pAttr = THAllocEx(pTHS, sizeof(ATTR));
                

                // Attribute FIXED_ATT_EX_FOREST is used as a hint
                pEntinf->AttrBlock.pAttr[0].attrTyp = FIXED_ATT_EX_FOREST;
                
                pEntinf->AttrBlock.pAttr[0].AttrVal.valCount = 1;
                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal = THAllocEx(pTHS,sizeof(ATTRVAL));
                
                //  pCrackedNames[0].pDnsDomain stores the DNS name of the trust forest
                // return this as part of the hint

                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen = sizeof(WCHAR)*(wcslen(pCrackedNames[0].pDnsDomain)+1);
                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal = (UCHAR*)pCrackedNames[0].pDnsDomain;

                _leave;
                  
            }
            else if ( DS_NAME_ERROR_NOT_UNIQUE == pCrackedNames[0].status) {

                 //
                 // Duplicate UPN -- don't resolve
                 //
                 _leave;


             } else {

                 //
                 // Didn't crack as UPN -- try isolated name
                 //

                 // No domain name given -- use the root of the enterprise
                 // Note:  the "root" of the enterprise here means the top
                 // of the directory, which is represented by a DSNAME with
                 // with a NULL guid, 0 sid len and 0 name len.
                 Scope = SE_CHOICE_WHOLE_SUBTREE;
                 fSearchEnterprise = TRUE;
                 AttrType = ATT_SAM_ACCOUNT_NAME;
                 pData = UserName;
                 cbData = wcslen(UserName) * sizeof(WCHAR);

                 pSearchRoot = (DSNAME*) THAllocEx(pTHS,DSNameSizeFromLen( 0 ));
                 fFreeSearchRoot = TRUE;
                 pSearchRoot->structLen = DSNameSizeFromLen( 0 );

                 fCheckXForest = TRUE;
                 
             }
        }
        // Get the attributes
        Assert( pSearchRoot );
        Assert( pData );
        Assert( 0 != cbData );

        VerifySingleSamAccountNameWorker( pTHS,
                                          pData,
                                          cbData,
                                          AttrType,
                                          pSearchRoot,
                                          Scope,
                                          fSearchEnterprise,
                                          RequiredAttrs,
                                          &pSearchRes );

        //
        // Note that there may be more that one value returned (especially
        // in the case of searching for an unadorned sam account name. Return
        // the first one
        //
        Assert( pSearchRes );
        if ( pSearchRes->count >= 1 ) {
            *pEntinf = pSearchRes->FirstEntInf.Entinf;
        }

    }
    finally
    {
        if (fFreeSearchRoot) {
            THFreeEx(pTHS,pSearchRoot); 
        }
    }

    // OK, there are two cases we need to check if the name is a Xforet
    // domain name. 
    // 1. DomainName != NULL, but DomainName can be found locally;
    // 2. DomainName == NULL, but UserName can not be cracked as a UPN 
    // or a local samAccountName.
        
    if (fCheckXForest 
        && ( 0==pEntinf->AttrBlock.attrCount && NULL==pEntinf->pName )
        && ( gEnableXForest || gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WHISTLER )) {
                        
        LSA_UNICODE_STRING Destination;
        LSA_UNICODE_STRING Domain;
        
        //
        // The cross-forest authorization feature is only for Whistler forest.
        // If the client DC is a win2k, the virtual attribute FIXED_ATT_EX_FOREST
        // may break the client.  So skip if the forest version is not at least whistler.
        //
        
              
        Domain.Buffer = (DomainName)?(DomainName):(UserName);
        Domain.Length = Domain.MaximumLength = (USHORT)(sizeof(WCHAR)*wcslen(Domain.Buffer));

        //
        // Try to find the NT4 domain name in the forest trust info.
        //

        NtStatus = LsaIForestTrustFindMatch( RoutingMatchDomainName,
                                             &Domain,
                                             &Destination );

        if( NT_SUCCESS(NtStatus) ){

            //
            // construct an ENTINF
            //
            pEntinf->pName = NULL;          
            pEntinf->ulFlags = 0;        
            pEntinf->AttrBlock.attrCount = 1;
            pEntinf->AttrBlock.pAttr = THAllocEx(pTHS, sizeof(ATTR));


            // Attribute FIXED_ATT_EX_FOREST is used as a hint
            pEntinf->AttrBlock.pAttr[0].attrTyp = FIXED_ATT_EX_FOREST;

            pEntinf->AttrBlock.pAttr[0].AttrVal.valCount = 1;
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal = THAllocEx(pTHS,sizeof(ATTRVAL));

            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen = Destination.Length+sizeof(WCHAR);
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal = THAllocEx(pTHS, Destination.Length+sizeof(WCHAR));
            memcpy(pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal, Destination.Buffer, Destination.Length);                
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal[Destination.Length/sizeof(WCHAR)] = 0;
            LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&Destination );
        }
    }


    // Reset the in arg
    if ( Separator ) {
        *Separator = L'\\';
    }
    
    return;
}

VOID
VerifySingleSid(
    IN THSTATE * pTHS,
    IN PSID pSid,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine verifies a Single Sid, by issuing a Search.

    Parameters:
        pSid -- The SID to verify.
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf -- Pointer to enfinf structure returning the
                   DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
--*/
{
    DSNAME          *pSearchRoot;
    FILTER          filter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;
    ATTRBLOCK       *pAttrBlock;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    if (!FindNcForSid(pSid,&pSearchRoot))
    {
        // Could not find, continue cracking other Sids
        return;
    }

    attrValFilter.valLen = RtlLengthSid(pSid);
    attrValFilter.pVal = (UCHAR *) pSid;

    memset(&filter, 0, sizeof(filter));
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    // Search for multiples so as to verify uniqueness.
    searchArg.CommArg.ulSizeLimit = 2;


    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    // Do not Cross NC boundaries.
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;

    pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;
    pSearchRes->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, pSearchRes,0);

    if (1 == pSearchRes->count)
    {
        *pEntinf = pSearchRes->FirstEntInf.Entinf;
    }

    return;
}


VOID
VerifySingleFPO(
    IN THSTATE * pTHS,
    IN PSID pSid,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine tries to find the Non FPO object, corresponding to
        the SID, by issuing a Search.

    Parameters:
        pSid -- The SID to verify.
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf -- Pointer to enfinf structure returning the
                   DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
--*/
{
    DSNAME          *pSearchRoot;
    FILTER          SidFilter;
    FILTER          FpoFilter;
    FILTER          AndFilter;
    FILTER          NotFilter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRBLOCK       *pAttrBlock;
    ULONG           ObjectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    if (!FindNcForSid(pSid,&pSearchRoot))
    {
        // Could not find, continue cracking other Sids
        return;
    }


    memset(&SidFilter, 0, sizeof(SidFilter));
    SidFilter.choice = FILTER_CHOICE_ITEM;
    SidFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    SidFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = RtlLengthSid(pSid);
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) pSid;

    memset(&FpoFilter, 0, sizeof(FILTER));
    FpoFilter.choice = FILTER_CHOICE_ITEM;
    FpoFilter.pNextFilter = NULL;
    FpoFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FpoFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) &ObjectClass;

    memset(&NotFilter, 0, sizeof(FILTER));
    NotFilter.choice = FILTER_CHOICE_NOT;
    NotFilter.FilterTypes.pNot = &FpoFilter;

    memset(&AndFilter, 0, sizeof(FILTER));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.pNextFilter = NULL;
    AndFilter.FilterTypes.And.count = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &SidFilter;
    SidFilter.pNextFilter = &NotFilter;


    //
    // Build search arguement.
    // Note: set makeDeletionsAvail since we want to
    //       get TombStones
    //
    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    searchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    // Search for multiples so as to verify uniqueness.
    searchArg.CommArg.ulSizeLimit = 2;


    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    // Do not Cross NC boundaries.
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &AndFilter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;
    searchArg.pSelectionRange = NULL;

    pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;
    pSearchRes->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, pSearchRes,0);

    if (1 == pSearchRes->count)
    {
        *pEntinf = pSearchRes->FirstEntInf.Entinf;
    }

    return;
}







VOID
VerifyDSNAMEs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
{
    DWORD       i, dwErr;
    ULONG       len;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    // Verify each name via simple database lookup.
    // If name found, read ATT_OBJ_DIST_NAME property.

    for ( i = 0; i < pmsgIn->cNames; i++ )
    {
        memset(&(pmsgOut->rpEntInf[i]),0,sizeof(ENTINF));

        if ((fNullUuid(&pmsgIn->rpNames[i]->Guid))
            && (0==pmsgIn->rpNames[i]->NameLen)
            && (pmsgIn->rpNames[i]->SidLen>0))
        {
            //
            // For the special case of a SID only DS Name
            // do a VerifySingleSid
            //

            VerifySingleSid(
                pTHS,
                &(pmsgIn->rpNames[i]->Sid),
                pmsgIn->RequiredAttrs,
                &(pmsgOut->rpEntInf[i])
                );
        }
        else
        {
            __try
            {
                dwErr = DBFindDSName(pTHS->pDB,
                                     pmsgIn->rpNames[i]);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( !dwErr )
            {
                ENTINFSEL EntInfSel;

                EntInfSel.attSel =  EN_ATTSET_LIST;
                EntInfSel.AttrTypBlock = pmsgIn->RequiredAttrs;
                EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

                dwErr = GetEntInf(
                    pTHS->pDB,
                    &EntInfSel,
                    NULL,
                    &(pmsgOut->rpEntInf[i]),
                    NULL,
                    0,      // sd flags
                    NULL,
                    GETENTINF_NO_SECURITY,
                    NULL,
                    NULL
                    );

                if ( dwErr )
                {
                    // Be safe.
                    memset(&(pmsgOut->rpEntInf[i]),0,sizeof(ENTINF));
                }
            }
        }
    }

    pmsgOut->cNames = pmsgIn->cNames;
}



VOID
VerifySamAccountNames_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
/*++

Routine Description

    This routine iterates through the passed in sam account names trying
    to resolve each one.  The sam account names are hidden in the StringName
    field of the dsname!

Parameters:

    pTHS    -- thread state
    pmsgIn  -- struct containing the sam account names
    psgmOut -- struct containing the entinf's of each resolved name

Return Values:

    None -- Any errors are set in the thread state

--*/

{
    DWORD           i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for ( i = 0; i < pmsgIn->cNames; i++ ) {

        //
        // Note the DSNAME is checked for to be valid in our
        // calling function -- this includes the StringName
        // being NULL terminated.
        //

        VerifySingleSamAccountName(pTHS,
                                   pmsgIn->rpNames[i]->StringName,
                                   pmsgIn->RequiredAttrs,
                                  &(pmsgOut->rpEntInf[i])
                                  );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}

VOID
VerifySIDs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
{
    DWORD           i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for ( i = 0; i < pmsgIn->cNames; i++ ) {

        VerifySingleSid(pTHS,
                       &pmsgIn->rpNames[i]->Sid,
                        pmsgIn->RequiredAttrs,
                       &(pmsgOut->rpEntInf[i])
                                  );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}


VOID
VerifyFPOs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut
    )
{
    DWORD   i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for (i = 0; i < pmsgIn->cNames; i++)
    {
        VerifySingleFPO(pTHS,
                        &pmsgIn->rpNames[i]->Sid,
                         pmsgIn->RequiredAttrs,
                        &(pmsgOut->rpEntInf[i])
                        );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}

ULONG
IDL_DRSVerifyNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY *   pmsgOut
    )
{
    THSTATE *                   pTHS = NULL;
    ULONG                       ret = 0;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    DWORD                       i, cc;
    CALLERTYPE                  callerType;
     
    drsReferenceContext( hDrs, IDL_DRSVERIFYNAMES );
    INC(pcThread);          // PerfMon hook
    
    __try {
	__try
	    {
	    // We currently support just one output message version.
	    *pdwMsgOutVersion = 1;

	    // Discard request if we're not installed.

	    if ( DsaIsInstalling() )
		{
		DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
	    }

	    if (    ( NULL == pmsgIn )
		    || ( 1 != dwMsgInVersion )
		    || ( pmsgIn->V1.cNames && !pmsgIn->V1.rpNames )
		    || ( NULL == pmsgOut )
		    || (    !(DRS_VERIFY_DSNAMES == pmsgIn->V1.dwFlags)
			    && !(DRS_VERIFY_SAM_ACCOUNT_NAMES == pmsgIn->V1.dwFlags)
			    && !(DRS_VERIFY_SIDS == pmsgIn->V1.dwFlags)
			    && !(DRS_VERIFY_FPOS == pmsgIn->V1.dwFlags) ) )
		{
		DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
	    }

	    for ( i = 0; i < pmsgIn->V1.cNames; i++ )
		{
		if (    !pmsgIn->V1.rpNames[i]
			|| (pmsgIn->V1.rpNames[i]->structLen
			    < DSNameSizeFromLen(pmsgIn->V1.rpNames[i]->NameLen))
			|| ( pmsgIn->V1.rpNames[i]->NameLen > 0
			     && (cc = wcslen(pmsgIn->V1.rpNames[i]->StringName),
				 pmsgIn->V1.rpNames[i]->NameLen != cc ) )  )
		    {
		    DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
		}
	    }

	    // Initialize thread state and open data base.
	    if (pmsgIn->V1.dwFlags==DRS_VERIFY_DSNAMES) {
		callerType=CALLERTYPE_INTERNAL;
	    }
	    else {
		callerType=CALLERTYPE_SAM;
	    }
	    if(!(pTHS = InitTHSTATE(callerType))) {
		// Failed to initialize a THSTATE.
		DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0);
	    }

	    Assert(1 == dwMsgInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_VERIFY_NAMES_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsVerifyNames,
			     szInsertUL(pmsgIn->V1.cNames),
			     szInsertUL(pmsgIn->V1.dwFlags),
			     NULL, NULL, NULL, NULL, NULL, NULL);

	    if (!IsDraAccessGranted(pTHS,
				    gAnchor.pDomainDN,
				    &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
		DRA_EXCEPT_NOLOG(ret, 0);
	    }

	    // Map ATTRTYPs from remote to local values.
	    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
	    hPrefixMap = PrefixMapOpenHandle(&pmsgIn->V1.PrefixTable,
					     pLocalPrefixTable);

	    if (!PrefixMapAttrBlock(hPrefixMap, &pmsgIn->V1.RequiredAttrs)) {
		DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
	    }
	    PrefixMapCloseHandle(&hPrefixMap);

	    pTHS->fDSA = TRUE;
	    DBOpen2(TRUE, &pTHS->pDB);

	    __try
		{
		memset(pmsgOut, 0, sizeof(DRS_MSG_VERIFYREPLY));
		pmsgOut->V1.rpEntInf = (ENTINF *) THAllocEx(pTHS,
							    pmsgIn->V1.cNames * sizeof(ENTINF));
		pmsgOut->V1.PrefixTable = *pLocalPrefixTable;


		switch ( pmsgIn->V1.dwFlags )
		    {
		case DRS_VERIFY_DSNAMES:

		    VerifyDSNAMEs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
		    break;

		case DRS_VERIFY_SIDS:

		    VerifySIDs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
		    break;

		case DRS_VERIFY_SAM_ACCOUNT_NAMES:

		    VerifySamAccountNames_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
		    break;

		case DRS_VERIFY_FPOS:

		    VerifyFPOs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
		    break;

		default:

		    DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
		    break;
		}
	    }
	    __finally
		{
		// End the transaction.  Faster to commit a read only
		// transaction than abort it - so set commit to TRUE.

		DBClose(pTHS->pDB, TRUE);
	    }
	}
	__except (GetDraException((GetExceptionInformation()), &ret)) {
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_VERIFY_NAMES_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsVerifyNames,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	} 

	if ( ret ) {
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_BASIC,
		     DIRLOG_DRA_CALL_EXIT_BAD,
		     szInsertUL(ret),
		     NULL,
		     NULL);
	}
    }
    __finally {
	DEC(pcThread);
	drsDereferenceContext( hDrs, IDL_DRSVERIFYNAMES );
    }
    return(ret);
}

BOOL
VerifyNCForMove(
    IN  DSNAME          *pSrcObject,
    IN  DSNAME          *pDstObject,
    IN  DSNAME          *pExpectedTargetNC,
    OUT NAMING_CONTEXT  **ppSrcNC,
    OUT DWORD           *pErr
    )
/*++

  Routine Description:

    Determines whether the NC which will hold the cross-domain-moved
    object is writeable at this replica and that various other cross
    domain move constraints are met.

  Parameters:

    pSrcObject - DSNAME pointer of the source object.

    pDstObject - DSNAME pointer identifying the new/destination object.

    pExpectedTargetNC - DSNAME pointer identifying the NC the source
        thinks should contain the target object.

    ppSrcNC - Receives naming context of source object on return.

    pErr = Receives DIRERR_* error code on return.

  Return Values:

    TRUE or FALSE as appropriate.

--*/
{
    CROSS_REF       *pCR;
    NAMING_CONTEXT  *pNC;
    COMMARG         commArg;
    ATTRBLOCK       *pBN;
    NTSTATUS        status;
    BOOLEAN         fMixedMode = TRUE;

    *ppSrcNC = NULL;
    *pErr = DIRERR_INTERNAL_FAILURE;
    InitCommarg(&commArg);

    // We may or may not have the source object depending on if we're
    // a GC or not.  Had we the source object, then we'd expect our
    // cross ref cache to be correct, thus FindBestCrossRef should be
    // accurate.  Had we not the source object, then FindBestCrossRef
    // is still the best we can do to determine the source object's NC,
    // though it may not be accurate due to replication latency, etc.

    if ( NULL == (pCR = FindBestCrossRef(pSrcObject, &commArg)) )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    *ppSrcNC = pCR->pNC;

    // Check destination values.

    if ( NULL == (pCR = FindBestCrossRef(pDstObject, &commArg)) )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    if ( !NameMatched(pCR->pNC, pExpectedTargetNC) )
    {
        // Source and destination are not in synch with respect
        // to the NCs in the enterprise.
        *pErr = DIRERR_DST_NC_MISMATCH;
        return(FALSE);
    }

    if ( NameMatched(*ppSrcNC, pCR->pNC) )
    {
        // Intra-domain move masquerading as inter-domain move.
        *pErr = DIRERR_SRC_AND_DST_NC_IDENTICAL;
        return(FALSE);
    }

    if (    NameMatched(pCR->pNC, gAnchor.pConfigDN)
         || NameMatched(pCR->pNC, gAnchor.pDMD) )
    {
        // Attempt to move into config or schema NC.
        *pErr = ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION;
        return(FALSE);
    }

    if ( DSNameToBlockName(pTHStls, pDstObject, &pBN, DN2BN_LOWER_CASE) )
    {
        *pErr = DIRERR_INTERNAL_FAILURE;
        return(FALSE);
    }

    commArg.Svccntl.dontUseCopy = TRUE;
    pNC = FindNamingContext(pBN, &commArg);
    FreeBlockName(pBN);

    if ( !pNC )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    if ( !NameMatched(pNC, pCR->pNC) )
    {
        *pErr = DIRERR_NOT_AUTHORITIVE_FOR_DST_NC;
        return(FALSE);
    }

    // Disallow move into mixed-mode domains.  This is because the downlevel
    // DCs don't understand SID-History, and thus clients will have different
    // tokens depending on whether an uplevel or downlevel DC authenticated
    // them.  The effect of this is deemed undesirable - especially considering
    // the possibility of deny ACEs.  Its also a difficult scenario to
    // identify in the field, so we disallow it.

    Assert(RtlValidSid(&pNC->Sid));
    status = SamIMixedDomain2((PSID) &pNC->Sid, &fMixedMode);

    if ( !NT_SUCCESS(status) )
    {
        *pErr = RtlNtStatusToDosError(status);
        return(FALSE);
    }

    if ( fMixedMode )
    {
        *pErr = ERROR_DS_DST_DOMAIN_NOT_NATIVE;
        return(FALSE);
    }

    *pErr = 0;
    return(TRUE);
}

ULONG
PrepareForInterDomainMove(
    IN THSTATE                  *pTHS,
    IN PDSNAME                  pOldDN,
    IN PDSNAME                  pNewDN,
    IN SYNTAX_DISTNAME_BINARY   *pSrcProxyVal
    )
/*++

  Routine Description:

    Determines if it is legal to to perform the remote add and if
    necessary, converts an existing object to a phantom in preparation.

  Parameters:

    pTHS - pointer to THSTATE with open DBPOS.

    pOldDN - Pointer to DSNAME of object we wish to replace.

    pNewDN - Pointer to DSNAME of object we wish to add.

    pSrcProxyVal - NULL or pointer to value for ATT_PROXIED_OBJECT_NAME
        for the source object.

  Return Values:

     pTHS->errCode

--*/
{
    // Let's use a notation like O(g1,s1,sn1) where:
    //
    //      g1  - indicates GUID of value 1 (pre-move GUID)
    //      s1  - indicates SID of value 1 (pre-move SID)
    //      sn1 - indicates StringName of value 1 (pre-move StringName)
    //
    // and 'X' will mean don't care and '!' means negation..
    //
    // The source is asking us to add O(g1,s2,sn2) where g1 is
    // the GUID from the source domain, s2 is the SID we will
    // assign in the destination domain and sn2 is a StringName
    // in the destination domain (us) chosen by the original caller
    // in the source domain.  We further assume that VerifyNCForMove
    // has passed - thus we are authoritive for sn2's domain.
    //
    // We don't have to make any checks on SID under the assumption
    // that we're not providing a SID on the add - we'll be assigning
    // a new one of our own.

    DSNAME                  *pGuidDN;
    DSNAME                  *pOldStringDN;
    DSNAME                  *pNewStringDN;
    DWORD                   cb;
    DWORD                   fPhantomConversionRequired = FALSE;
    DWORD                   dwErr;
    DSNAME                  *pXDN;
    DSNAME                  *pAccurateOldDN;
    ULONG                   len;
    GUID                    *pGuid;
    CROSS_REF               *pCR, *pSrcCR, *pDstCR;
    COMMARG                 commArg;
    NAMING_CONTEXT          *pNC;
    DWORD                   srcEpoch;
    DWORD                   dstEpoch;
    SYNTAX_DISTNAME_BINARY  *pDstProxyVal;
    SYNTAX_BOOLEAN          fIsDeleted;
    UCHAR                   *pfIsDeleted = (UCHAR *) &fIsDeleted;

    if (    fNullUuid(&pOldDN->Guid)
         || fNullUuid(&pNewDN->Guid)
         || !pOldDN->NameLen
         || !pNewDN->NameLen
         || memcmp(&pOldDN->Guid, &pNewDN->Guid, sizeof(GUID)) )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
    }

    // GUID only DSNAME checks:

    cb = DSNameSizeFromLen(0);
    pGuidDN = (DSNAME *) THAllocEx(pTHS,cb);
    pGuidDN->structLen = cb;
    memcpy(&pGuidDN->Guid, &pOldDN->Guid, sizeof(GUID));

    dwErr = DBFindDSName(pTHS->pDB, pGuidDN);

    THFreeEx(pTHS,pGuidDN);

    switch ( dwErr )
    {
    case 0:

        // O(g1,SX,snX) exists as a real object.  Check its string name.

        if ( DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                         0, 0, &len, (UCHAR **) &pAccurateOldDN) )
        {
            return(SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_INTERNAL_FAILURE));
        }

        if ( !NameMatchedStringNameOnly(pAccurateOldDN, pOldDN) )
        {
            // Source and destination do not agree on current string name
            // of object.  Reject the call as this implies they don't have
            // a consistent view of O(g1,SX,snX) at this time.

            // DaveStr - 10/29/98 - Weaken this condition for the move tree
            // utility which renames objects at the source before moving them.
            // In this case, the destination won't have the proper name.  But
            // its OK as long as source and destination agree on the NC.

            InitCommarg(&commArg);
            if (    !(pSrcCR = FindBestCrossRef(pOldDN, &commArg))
                 || !(pDstCR = FindBestCrossRef(pAccurateOldDN, &commArg))
                 || !NameMatched(pSrcCR->pNC, pDstCR->pNC) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_SRC_NAME_MISMATCH));
            }
        }

        // N.B. Its really only now that we can trust VerifyNCForMove's
        // decisions about the source NC as it based its tests on what
        // the source claimed was the source NC.  Since the string
        // names matched in the above test, we now know that source and
        // destination are truly in agreement regarding the source NC.

        // Check deletion status.

        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_IS_DELETED,
                            DBGETATTVAL_fCONSTANT, sizeof(fIsDeleted),
                            &len, &pfIsDeleted);
        switch ( dwErr )
        {
        case 0:
            if ( fIsDeleted )
            {
                // The object is deleted but source doesn't know it yet.
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOVE_DELETED_OBJECT));
            }
            break;
        case DB_ERR_NO_VALUE:
            break;
        default:
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE));
            break;
        }

        // Check respective epoch numbers.

        srcEpoch = (pSrcProxyVal ? GetProxyEpoch(pSrcProxyVal) : 0);
        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pDstProxyVal);
        switch ( dwErr )
        {
        case 0:
            dstEpoch = GetProxyEpoch(pDstProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            dstEpoch = 0;
            break;
        default:
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE));
        }

        if ( srcEpoch != dstEpoch )
        {
            // Source and destination do not agree on current epoch number
            // of object.  Reject the call as this implies they don't have
            // a consistent view of O(g1,SX,snX) at this time.

            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                DIRERR_EPOCH_MISMATCH));
        }

        // All tests passed.

        fPhantomConversionRequired = TRUE;
        break;

    case DIRERR_NOT_AN_OBJECT:

        // O(g1,sX,snX) exists as a phantom.  We don't particularly care
        // if the string names match as we know phantom string names converge
        // with the real name of the object with much higher latency due
        // to the scheduling of the phantom cleanup daemon.  This phantom
        // will get the new name when promoted during the add.  However, we
        // can assert that the phantom doesn't have an ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // Old StringName only DSNAME checks:

    if ( pNewDN->structLen > pOldDN->structLen )
        cb = pNewDN->structLen;
    else
        cb = pOldDN->structLen;
    pOldStringDN = (DSNAME *) THAllocEx(pTHS, cb);
    pOldStringDN->structLen = cb;
    pOldStringDN->NameLen = pOldDN->NameLen;
    wcscpy(pOldStringDN->StringName, pOldDN->StringName);

    dwErr = DBFindDSName(pTHS->pDB, pOldStringDN);

    switch ( dwErr )
    {
    case 0:

        // O(gX,sX,sn1) exists as an object. Check its GUID.

        if (    DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID,
                            0, 0, &len, (UCHAR **) &pGuid)
             || memcmp(pGuid, &pOldDN->Guid, sizeof(GUID)) )
        {
            // Source and destination do not agree on GUID of object.
            // Reject the call as this implies they don't have a consistent
            // view of O(gX,SX,sn1) at this time.

            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                DIRERR_SRC_GUID_MISMATCH));
        }

        // No need to check epoch numbers or deletion status as we now know
        // this is the same object that was tested above and which already
        // passed those tests.

        fPhantomConversionRequired = TRUE;
        break;

    case DIRERR_NOT_AN_OBJECT:

        // O(gX,sX,sn1) exists as a phantom.  If its GUID matches the object
        // being added, then we're covered as described in the pGuidDN case
        // above.  If its GUID doesn't match the object being added, then
        // this must be a stale phantom whose string name the phantom cleanup
        // daemon will improve over time.  However, we can still assert
        // that the phantom doesn't have an ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:

        return(SetNamError( NA_PROBLEM_BAD_ATT_SYNTAX,
                            pOldStringDN,
                            DIRERR_BAD_NAME_SYNTAX));
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // New StringName only DSNAME checks.  Note that VerifyNCForMove already
    // verified that the new string name is in an NC we are authoritive for.

    pNewStringDN = pOldStringDN;
    memset(pNewStringDN, 0, cb);
    pNewStringDN->structLen = cb;
    pNewStringDN->NameLen = pNewDN->NameLen;
    wcscpy(pNewStringDN->StringName, pNewDN->StringName);

    dwErr = DBFindDSName(pTHS->pDB, pNewStringDN);

    switch ( dwErr )
    {
    case 0:

	//
	// Object already exists.  Just fall through and let LocalAdd
	// handle this problem since it has logic for figuring out whether
	// the client is allowed to know the existence of this object.
	//
	break;

    case DIRERR_NOT_AN_OBJECT:

        // O(gX,sX,sn2) exists as a phantom.  If this phantom's GUID
        // matches that of the object being added, then its name won't
        // need to change during promotion.  If its GUID does not match
        // the object being added, then CheckNameForAdd will kindly mangle
        // its name such that our add proceeds as desired.  However,
        // we can still assert that the phantom doesn't have an
        // ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:

        return(SetNamError( NA_PROBLEM_BAD_ATT_SYNTAX,
                            pNewStringDN,
                            DIRERR_BAD_NAME_SYNTAX));
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // All checks pass - create phantom if required.

    if ( fPhantomConversionRequired )
    {
        if ( dwErr = PhantomizeObject(pAccurateOldDN, pOldStringDN, TRUE) )
        {
            Assert(dwErr == pTHS->errCode);
            return(dwErr);
        }

        Assert(DIRERR_NOT_AN_OBJECT == DBFindDSName(
                                            pTHS->pDB,
                                            pOldStringDN));
    }

    return(pTHS->errCode);
}

VOID
DupAttr(
    THSTATE *pTHS,
    ATTR    *pInAttr,
    ATTR    *pOutAttr
    )
/*++

  Routine Description:

    Reallocate a single ATTR.

  Parameters:

    pInAttr = Pointer to IN ATTR to dup.

    pOutAttr - Pointer to OUT ATTR which receives dup'd value.

  Return Values:

    None.

--*/
{
    ULONG   valCount;
    ULONG   valLen;
    ULONG   i;

    pOutAttr->attrTyp = pInAttr->attrTyp;
    valCount = pInAttr->AttrVal.valCount;
    pOutAttr->AttrVal.valCount = valCount;
    pOutAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                                    sizeof(ATTRVAL) * valCount);
    memset(pOutAttr->AttrVal.pAVal, 0, sizeof(ATTRVAL) * valCount);

    for ( i = 0; i < valCount; i++ )
    {
        valLen = pInAttr->AttrVal.pAVal[i].valLen;
        pOutAttr->AttrVal.pAVal[i].valLen = valLen;
        pOutAttr->AttrVal.pAVal[i].pVal = (UCHAR *) THAllocEx(pTHS, valLen);
        memcpy( pOutAttr->AttrVal.pAVal[i].pVal,
                pInAttr->AttrVal.pAVal[i].pVal,
                valLen);
    }
}

ULONG
DupAndFilterRemoteAttr(
    THSTATE     *pTHS,
    ATTR        *pInAttr,
    CLASSCACHE  *pCC,
    BOOL        *pfKeep,
    ATTR        *pOutAttr,
    BOOL        fSamClass,
    ULONG       iSamClass
    )
/*++

  Routine Description:

    Filter and morph remote add ATTR to a form the destination (us)
    will find acceptable.  For example, we don't want the original SD,
    we don't want the full class hierarchy in ATT_OBJECT_CLASS, etc.

  Parameters:

    pInAttr - Pointer to IN ATTR to dup/filter.

    pCC - Pointer to CLASS_CACHE for this object.

    pfKeep - Pointer to BOOL set to TRUE if this attribute is to be kept.

    pOutAttr - Pointer to OUT ATTR to receive dup/filter data.

    fSamClass - BOOL indicating whether this is a SAM class of object.

    iSamClass - Index into ClassMappingTable if this is a SAM class of object.

  Return Values:

    pTHS->errCode

--*/
{
    ATTCACHE                *pAC;
    DWORD                   control;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;
    LARGE_INTEGER           li;

    *pfKeep = FALSE;

    if (!(pAC = SCGetAttById(pTHS, pInAttr->attrTyp)))
    {
        return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                            DIRERR_OBJ_CLASS_NOT_DEFINED));
    }

    // Pre-emptively drop all backlink attributes as they are
    // constructed by the DB layer, not written explicitly.
    // Ditto for non-replicated attributes, system add reserved
    // attributes, secret data attributes which require special
    // decryption/encryption, and attributes identifying the RDN
    // as they are reverse engineered by LocalAdd.  See ATT_RDN
    // below as well.
    //
    // A crossDomainMove is treated as an originating add at the
    // target (us). LocalAdd will determine which attr is the
    // rdnType and will insure that the column is set correctly.
    // Or it will fail if the needed values are not present.
    // For now, ignore the rdnattid of the object's class because
    // that class may have been superceded.

    if (    FIsBacklink(pAC->ulLinkID)
         || pAC->bIsNotReplicated
         || SysAddReservedAtt(pAC)
         || DBIsSecretData(pAC->id) )
    {
        return(0);
    }

    // Now strip out those things that SAM doesn't allow write for.
    // This logic is similar to that of SampAddLoopbackRequired.

    if ( fSamClass )
    {
        cAttrMapTable = *ClassMappingTable[iSamClass].pcSamAttributeMap;
        rAttrMapTable = ClassMappingTable[iSamClass].rSamAttributeMap;

        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( pInAttr->attrTyp == rAttrMapTable[samAttr].DsAttributeId )
            {
                switch ( rAttrMapTable[samAttr].writeRule )
                {
                case SamReadOnly:           return(0);                  break;
                case SamWriteRequired:      NULL;                       break;
                case NonSamWriteAllowed:    NULL;                       break;
                default:                    Assert(!"Missing case");    break;
                }
            }
        }
    }

    // Finish up with some attribute-specific filtering.

    switch ( pInAttr->attrTyp )
    {
    case ATT_OBJECT_CLASS:

        // The object-class attribute is multivalued, containing the
        // hierarchy of class values for this object. Only use the most
        // specific class ID, the one in the first value, and do this by
        // just resetting the value count to 1, Don't bother resizing
        // the memory block.

        DupAttr(pTHS, pInAttr, pOutAttr);
        pOutAttr->AttrVal.valCount = 1;
        *pfKeep = TRUE;
        return(0);

    case ATT_USER_ACCOUNT_CONTROL:

        // Note that the DS persists UF_* values as per lmaccess.h,
        // not USER_* values as per ntsam.h.  Restrict moves of DCs
        // and trust objects.  WKSTA and server can move.

        if (    (1 != pInAttr->AttrVal.valCount)
             || (NULL == pInAttr->AttrVal.pAVal)
             || (sizeof(DWORD) != pInAttr->AttrVal.pAVal->valLen)
                // Abort on things that we refuse to move.
             || (control = * (DWORD *) pInAttr->AttrVal.pAVal->pVal,
                 (control & UF_SERVER_TRUST_ACCOUNT))       // DC
             || (control & UF_INTERDOMAIN_TRUST_ACCOUNT) )  // SAM trust
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
        }

        DupAttr(pTHS, pInAttr, pOutAttr);

        // Murli claims that since we're creating a new account it
        // should not be locked by default.  Note that other state
        // comes over as is - eg: account disabled or password
        // change required on next logon.

        control = * (DWORD *) pOutAttr->AttrVal.pAVal->pVal;
        control &= ~UF_LOCKOUT;
        * (DWORD *) pOutAttr->AttrVal.pAVal->pVal = control;
        *pfKeep = TRUE;
        return(0);

    case ATT_PWD_LAST_SET:

        // Carry forward zero value as zero, non-zero as 0xffff...
        // See _SampWriteUserPasswordExpires for more info.

        if (    (1 != pInAttr->AttrVal.valCount)
             || (NULL == pInAttr->AttrVal.pAVal)
             || (sizeof(LARGE_INTEGER) != pInAttr->AttrVal.pAVal->valLen) )
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
        }

        DupAttr(pTHS, pInAttr, pOutAttr);
        li = * (LARGE_INTEGER *) pOutAttr->AttrVal.pAVal->pVal;
        if ( (0 != li.LowPart) || (0 != li.HighPart) )
        {
            li.LowPart = li.HighPart = 0xffffffff;
            * (LARGE_INTEGER *) pOutAttr->AttrVal.pAVal->pVal = li;
        }
        *pfKeep = TRUE;
        return(0);

    // NOTE - FOLLOWING ARE FALL-THROUGH FALSE CASES.

    case ATT_PROXIED_OBJECT_NAME:
        // Cross domain move code sets this explicitly itself.
    case ATT_RDN:
        // Core will create RDN from the DN automatically.  We strip it
        // here in case this is a rename (as well as move) as the ATT_RDN
        // sent over from the source doesn't match the last component
        // of the DN any more.
    case ATT_OBJECT_CATEGORY:
        // We assign our own based on the defaulting mechanism.
    case ATT_OBJECT_GUID:
        // Don't need this as the GUID should have been in the DSNAME.
    case ATT_OBJ_DIST_NAME:
        // This will be recreated locally by DirAddEntry.
    case ATT_OBJECT_SID:
        // SAM will assign one of its own.
    case ATT_SID_HISTORY:
        // We'll treat this one specially later on so skip it.
    case ATT_NT_SECURITY_DESCRIPTOR:
        // Core will assign a new one based on local defaults so skip it.
    case ATT_ADMIN_COUNT:
    case ATT_OPERATOR_COUNT:
    case ATT_PRIMARY_GROUP_ID:
        // SAM will reset to domain users.
    case ATT_REPL_PROPERTY_META_DATA:
    case ATT_WHEN_CREATED:
    case ATT_WHEN_CHANGED:
    case ATT_USN_CREATED:
    case ATT_USN_CHANGED:
        // Misc. attributes that should not move across domains or we
        // will generate outselves.

    case ATT_SYSTEM_FLAGS:
    case ATT_INSTANCE_TYPE:
        // Destination will set this.

        return(0);


    default:

        DupAttr(pTHS, pInAttr, pOutAttr);
        *pfKeep = TRUE;
        return(0);
    }

    Assert(!"Should never get here");
    return(0);
}

ULONG
DupAndMassageInterDomainMoveArgs(
    THSTATE                     *pTHS,
    ATTRBLOCK                   *pIn,
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap,
    ATTRBLOCK                   **ppOut,
    BOOL                        *pfSamClass,
    SYNTAX_DISTNAME_BINARY      **ppProxyValue,
    ULONG                       *pSrcRid
    )
/*++

  Routine Description:

    The incoming attribute buffer may not have been allocated with
    MIDL_user_allocate, since RPC may unmarshall the arguments in place
    in the RPC transmit buffer. If the attribute buffer does not contain
    a security descriptor, DirAddEntry will reallocate the attributes,
    adding in a descriptor. If the buffer was unmarshalled in place,
    the reallocation will fail with an invalid memory address
    (because the block was not allocated via THAlloc (or HeapAlloc).
    To avoid this problem, the attributes are explicitly reallocated
    with the DS allocator, and then passed into DirAddEntry.  Also
    performs ATTRTYP mapping.  Also filters attributes and values so
    they conform to what we want to add at destination.

  Parameters:

    pIn - Pointer to original ATTRBLOCK.

    hPrefixMap - Handle for mapping ATTRTYPs.

    ppOut - Pointer to pointer to out ATTRBLOCK.

    pSrcRid - Pointer to receive value of source RID if present.

  Return Values:

    pTHS->errCode

--*/
{
    ATTR            *pInAttr, *pOutAttr;
    ATTR            *pSid = NULL;
    ATTR            *pSidHistory = NULL;
    ATTR            *pNewSidHistory = NULL;
    ATTR            *pObjectClass = NULL;
    ULONG           i, j, valCount, valLen;
    CROSS_REF_LIST  *pCRL;
    NT4SID          domainSid;
    CLASSCACHE      *pCC;
    ULONG           iSamClass;
    BOOL            fKeep;
    DWORD           dwErr;

    Assert(VALID_THSTATE(pTHS));

    *ppProxyValue = NULL;
    *pSrcRid = 0;

    // Grab the object class right away as we need it as an argument for
    // subsequent helper routines.  Map attrTyps while we're there.
    // Identify a few other special attributes as well.

    for ( i = 0; i < pIn->attrCount; i++ )
    {
        pInAttr = &pIn->pAttr[i];

        // Map ATTRTYPs in the inbound ATTR to their local equivalents.

        if ( !PrefixMapAttr(hPrefixMap, pInAttr) )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_DRA_SCHEMA_MISMATCH));
        }

        switch ( pInAttr->attrTyp )
        {
        case ATT_OBJECT_SID:            pSid = pInAttr;             break;
        case ATT_SID_HISTORY:           pSidHistory = pInAttr;      break;
        case ATT_OBJECT_CLASS:          pObjectClass = pInAttr;     break;
        case ATT_PROXIED_OBJECT_NAME:
            Assert(1 == pInAttr->AttrVal.valCount);
            Assert(pInAttr->AttrVal.pAVal[0].valLen > sizeof(DSNAME));
            Assert(NULL != pInAttr->AttrVal.pAVal[0].pVal);
            *ppProxyValue = (SYNTAX_DISTNAME_BINARY *)
                                            pInAttr->AttrVal.pAVal[0].pVal;
            break;
        }
    }

    if (    !pObjectClass
         || (0 == pObjectClass->AttrVal.valCount)
         || (!pObjectClass->AttrVal.pAVal)
         || (pObjectClass->AttrVal.pAVal[0].valLen != sizeof(DWORD))
         || (!pObjectClass->AttrVal.pAVal[0].pVal)
         || (NULL == (pCC = SCGetClassById(pTHS,
                        * (ATTRTYP *) pObjectClass->AttrVal.pAVal[0].pVal))))
    {
        return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                            DIRERR_OBJ_CLASS_NOT_DEFINED));
    }

    // A crossDomainMove is treated as an originating add at the
    // target (us). LocalAdd will determine which attr is the
    // rdnType and will insure that the column is set correctly.
    // Or it will fail if the needed values are not present.
    // For now, ignore the rdnattid of the object's class because
    // that class may have been superceded.

    // See if this is a SAM class.

    *pfSamClass = SampSamClassReferenced(pCC, &iSamClass);

    // Dup/filter attributes appropriately.

    *ppOut = (ATTRBLOCK *) THAllocEx(pTHS, sizeof(ATTRBLOCK));
    memset(*ppOut, 0, sizeof(ATTRBLOCK));
    // Allocate one extra for ATT_SID_HISTORY if we need it.
    (*ppOut)->pAttr = (ATTR *) THAllocEx(pTHS, sizeof(ATTR) * (pIn->attrCount+1));
    memset((*ppOut)->pAttr, 0, sizeof(ATTR) * (pIn->attrCount+1));
    pOutAttr = &(*ppOut)->pAttr[0];

    for ( i = 0; i < pIn->attrCount; i++ )
    {
        pInAttr = &pIn->pAttr[i];

        if ( dwErr = DupAndFilterRemoteAttr(pTHS,
                                            pInAttr,
                                            pCC,
                                            &fKeep,
                                            pOutAttr,
                                            *pfSamClass,
                                            iSamClass) )
        {
            Assert(dwErr == pTHS->errCode);
            return(dwErr);
        }
        else if ( !fKeep )
        {
            // This attribute is not to be retained.
            continue;
        }

        pOutAttr = &(*ppOut)->pAttr[++((*ppOut)->attrCount)];
    }

    // Handle SID and SID history.  We're assuming the source DC sent us
    // the object as-is without any munging.  General plan is to place
    // current SID into the SID history.  Perform sanity checks as we go.
    // Test for both existing SID and whether we think this is a SAM class.

    if ( pSid && *pfSamClass )
    {
        Assert(ATT_OBJECT_SID == pSid->attrTyp);

        // Abort if SID is malformed or doesn't represent a domain we
        // know about.  Shouldn't happen if we trust our peer DC, but
        // caution is in order when dealing with security principals.

        if (    (1 != pSid->AttrVal.valCount)
             || (pSid->AttrVal.pAVal[0].valLen > sizeof(NT4SID))
             || !RtlValidSid((PSID) pSid->AttrVal.pAVal[0].pVal) )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC));
        }

        SampSplitNT4SID(
                    (PSID) pSid->AttrVal.pAVal[0].pVal,
                    &domainSid,
                    pSrcRid);

        for ( pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR )
        {
            if (    (pCRL->CR.flags & FLAG_CR_NTDS_NC)
                 && (pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN)
                 && (RtlEqualSid(&domainSid, &pCRL->CR.pNC->Sid) ) )
            {
                break;
            }
        }

        if ( !pCRL )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC));
        }

        // pOutAttr points at next free attr in array - use it to construct
        // a new SID history.  Note that we're inside a test on pSid.  This
        // means we won't carry forward a SID history for an object which
        // itself has no SID.

        pNewSidHistory = pOutAttr;

        if ( !pSidHistory )
        {
            // No old SID history, build a new, 1-element SID history.
            *pNewSidHistory = *pSid;
            pNewSidHistory->attrTyp = ATT_SID_HISTORY;
        }
        else
        {
            // There is an old SID history.   Build a new one which is
            // stretched to include both old SID and old history.

            Assert(ATT_SID_HISTORY == pSidHistory->attrTyp);

            pNewSidHistory->attrTyp = ATT_SID_HISTORY;
            pNewSidHistory->AttrVal.valCount = 0;
            pNewSidHistory->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                    (pSidHistory->AttrVal.valCount + 1) * sizeof(ATTRVAL));
            pNewSidHistory->AttrVal.valCount = 1;
            pNewSidHistory->AttrVal.pAVal[0] = pSid->AttrVal.pAVal[0];

            for ( i = 0, j = 1; i < pSidHistory->AttrVal.valCount; i++ )
            {
                // Filter out of the SID history any mal-formed SIDs.  Do not
                // check whether we can map the SIDs in the history to existing
                // domains as there may be legitimate reason for that domaain
                // to no longer exist.

                if (    (pSidHistory->AttrVal.pAVal[i].valLen <= sizeof(NT4SID))
                     && RtlValidSid((PSID) pSidHistory->AttrVal.pAVal[i].pVal) )
                {
                    pNewSidHistory->AttrVal.pAVal[j++] =
                                                pSidHistory->AttrVal.pAVal[i];
                    pNewSidHistory->AttrVal.valCount++;
                }
            }
        }

        ((*ppOut)->attrCount)++;
    }

    return(pTHS->errCode);
}

ULONG
PrepareSecretData(
    DRS_HANDLE  hDrs,
    THSTATE     *pTHS,
    DSNAME      *pObj,
    ATTRTYP     attrTyp,
    ATTRVAL     *pAttrVal,
    DWORD       srcRid,
    DWORD       dstRid
    )
/*++

  Description:

    We used to think that all cross domain move had to do was perform RPC
    session encryption to insure that DBIsSecretData wasn't visible during
    transit.  It turns out that not all DBIsSecretData is encrypted the
    same.  Some items are additionally encrypted with the RID, and different
    encryption is used as well.  This routine undoes session and source
    RID encryption, and further adds destination RID encrption where needed,
    such that the data can be considered clear text and ready for DB layer
    encryption during the subsequent write to the database.

  Arguments:

    hDrs - DRS context handle.

    pTHS - Valid THSTATE.

    pObj - DSNAME of object being modified.

    attrTyp - ATTRTYP of value to be munged.

    pAttrVal - ATTRVAL which needs to be munged.  We may realloc it.

    srcRid - RID of source object.

    dstRid - RID of destination object.

  Return Values:

    pTHS->errCode

--*/
{
    DRS_CLIENT_CONTEXT  *pCtx = (DRS_CLIENT_CONTEXT * ) hDrs;
    ULONG               cb1 = 0, cb2 = 0;
    VOID                *pv1 = NULL, *pv2 = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    NT_OWF_PASSWORD     ntOwfPassword;
    LM_OWF_PASSWORD     lmOwfPassword;
    DWORD               i, cPwd = 1;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!pTHS->fDRA);
    Assert(DBIsSecretData(attrTyp));

    // Verify that IDL_DRSBind successfully set up session keys required
    // for encryption.

    if (    !pCtx->sessionKey.SessionKeyLength
         || !pCtx->sessionKey.SessionKey )
    {
        // See comments in IDL_DRSBind.  We assume the lack of keys is
        // not an error condition per se, but rather an invalid pre-condition
        // with respect to the authentication protocol, etc.

        return(SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_ENCRYPTION_FAILED));
    }

    // Set extensions in the thread state.
    Assert(!pTHS->pextRemote);
    pTHS->pextRemote = &pCtx->extRemote;

    // Set RPC session key in the thread state.
    Assert(    !pTHS->SessionKey.SessionKeyLength
            && !pTHS->SessionKey.SessionKey);
    pTHS->SessionKey = pCtx->sessionKey;

    // Turn on fDRA so as to get RPC session encryption.  Call PEKEncrypt
    // which decrypts the session level encryption and adds database layer
    // encryption.

    pTHS->fDRA = TRUE;
    __try
    {
        PEKEncrypt(pTHS, pAttrVal->pVal, pAttrVal->valLen, NULL, &cb1);
        pv1 = THAllocEx(pTHS, cb1);
        PEKEncrypt(pTHS, pAttrVal->pVal, pAttrVal->valLen, pv1, &cb1);
    }
    __finally
    {
        pTHS->fDRA = FALSE;
        pTHS->pextRemote = NULL;
        memset(&pTHS->SessionKey, 0, sizeof(pTHS->SessionKey));
    }

    // Data is now DB layer encrypted.  Get back to clear text for data which
    // is not source RID encrypted, or source RID encrypted for data which is.

    PEKDecrypt(pTHS, pv1, cb1, NULL, &cb2);
    pv2 = THAllocEx(pTHS, cb2);
    PEKDecrypt(pTHS, pv1, cb1, pv2, &cb2);
    THFreeEx(pTHS, pv1);

    // Now undo source RID encryption and apply destination RID encryption
    // depending on the ATTRTYP.

    Assert(sizeof(srcRid) == sizeof(CRYPT_INDEX));
    Assert(sizeof(dstRid) == sizeof(CRYPT_INDEX));

    switch ( attrTyp )
    {
    case ATT_NT_PWD_HISTORY:

        if ( 0 != (cb2 % sizeof(ENCRYPTED_NT_OWF_PASSWORD)) )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        cPwd = cb2 / sizeof(ENCRYPTED_NT_OWF_PASSWORD);

        // Intentional fall through.

    case ATT_UNICODE_PWD:

        if ( !srcRid || !dstRid )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        pAttrVal->valLen = cPwd * sizeof(ENCRYPTED_NT_OWF_PASSWORD);
        pAttrVal->pVal = THReAllocEx(pTHS, pAttrVal->pVal,
                                     cPwd * sizeof(ENCRYPTED_NT_OWF_PASSWORD));

        for ( i = 0; i < cPwd; i++ )
        {
            status = RtlDecryptNtOwfPwdWithIndex(
                                    &((PENCRYPTED_NT_OWF_PASSWORD) pv2)[i],
                                    (PCRYPT_INDEX) &srcRid,
                                    &ntOwfPassword);

            if ( NT_SUCCESS(status) )
            {
                status = RtlEncryptNtOwfPwdWithIndex(
                            &ntOwfPassword, (PCRYPT_INDEX) &dstRid,
                            &((PENCRYPTED_NT_OWF_PASSWORD) pAttrVal->pVal)[i]);
            }

            if ( !NT_SUCCESS(status) )
            {
                break;
            }
        }

        THFreeEx(pTHS, pv2);
        break;

    case ATT_LM_PWD_HISTORY:

        if ( 0 != (cb2 % sizeof(ENCRYPTED_LM_OWF_PASSWORD)) )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        cPwd = cb2 / sizeof(ENCRYPTED_LM_OWF_PASSWORD);

        // Intentional fall through.

    case ATT_DBCS_PWD:

        if ( !srcRid || !dstRid )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        pAttrVal->valLen = cPwd * sizeof(ENCRYPTED_LM_OWF_PASSWORD);
        pAttrVal->pVal = THReAllocEx(pTHS, pAttrVal->pVal,
                                     cPwd * sizeof(ENCRYPTED_LM_OWF_PASSWORD));

        for ( i = 0; i < cPwd; i++ )
        {
            status = RtlDecryptLmOwfPwdWithIndex(
                                    &((PENCRYPTED_LM_OWF_PASSWORD) pv2)[i],
                                    (PCRYPT_INDEX) &srcRid,
                                    &lmOwfPassword);


            if ( NT_SUCCESS(status) )
            {
                status = RtlEncryptLmOwfPwdWithIndex(
                            &lmOwfPassword, (PCRYPT_INDEX) &dstRid,
                            &((PENCRYPTED_LM_OWF_PASSWORD) pAttrVal->pVal)[i]);
            }

            if ( !NT_SUCCESS(status) )
            {
                break;
            }
        }

        THFreeEx(pTHS, pv2);
        break;

    default:

        THFreeEx(pTHS, pAttrVal->pVal);
        pAttrVal->pVal = (UCHAR *) pv2;
        pAttrVal->valLen = cb2;
        break;
    }

    // Assuming no errors, data is now either in the clear or destination
    // RID encrypted and ready for write to the DB layer - eg: DirModifyEntry.

    if ( !NT_SUCCESS(status) )
    {
        SetAttError(pObj, attrTyp, PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL, RtlNtStatusToDosError(status));
    }

    return(pTHS->errCode);
}

ULONG
WriteSecretData(
    DRS_HANDLE  hDrs,
    THSTATE     *pTHS,
    ULONG       srcRid,
    ADDARG      *pAddArg,
    ATTRBLOCK   *pAttrBlock
    )
/*++

  Description:

    The add we did for the inter domain move had all its DBIsSecretData attrs
    stripped because we didn't want to perform the add with fDRA set, which is
    required in order to handle sesison encryption correctly.  So we now
    find all DBIsSecretData attrs in the original ATTRBLOCK, and write them
    as fDRA.

  Arguments:

    hDrs - DRS context handle.

    pTHS - Active THSTATE.

    srcRid - RID of source object if present.

    pAddArg - Same ADDARG as was used for the original add.

    pAttrBlock - Original ATTRBLOCK sent by peer DC which contains the
        session-encrypted DBIsSecretData attributes.

  Return Values:

    pTHS->errCode

--*/
{
    ULONG               i, j, cBytes, ret;
    USHORT              cSecret;
    MODIFYARG           modifyArg;
    ATTRMODLIST         *pMod = NULL;
    ULONG               dstRid = 0;
    NT4SID              domainSid;
    NT4SID              fullSid;
    NT4SID              *pFullSid = &fullSid;
    DWORD               dwErr;
    ULONG               cbSid;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!pTHS->fDRA);

    // First see if there is any secret data to handle at all.

    for ( i = 0, cSecret = 0; i < pAttrBlock->attrCount; i++ )
    {
        if ( DBIsSecretData(pAttrBlock->pAttr[i].attrTyp) )
        {
            cSecret++;
        }
    }

    if ( !cSecret )
    {
        return(0);
    }

    // Prepare MODIFYARG.  First position for subsequent CreateResObj
    // and read of SID if present.

    if (    DBFindDSName(pTHS->pDB, pAddArg->pObject)
         || (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID,
                                      DBGETATTVAL_fCONSTANT, sizeof(fullSid),
                                      &cbSid, (PUCHAR *) &pFullSid))
              && (DB_ERR_NO_VALUE != dwErr)) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR));
    }

    if ( !dwErr )
    {
        SampSplitNT4SID(&fullSid, &domainSid, &dstRid);
    }

    memset(&modifyArg, 0, sizeof(modifyArg));
    memcpy(&modifyArg.CommArg, &pAddArg->CommArg, sizeof(COMMARG));
    modifyArg.pObject = pAddArg->pObject;
    modifyArg.pResObj = CreateResObj(pTHS->pDB, pAddArg->pObject);
    modifyArg.count = cSecret;
    pMod = &modifyArg.FirstMod;

    for ( i = 0; i < pAttrBlock->attrCount; i++ )
    {
        if ( DBIsSecretData(pAttrBlock->pAttr[i].attrTyp) )
        {
            pMod->pNextMod = NULL;
            pMod->choice = AT_CHOICE_REPLACE_ATT;

            // We must duplicate the attr as pAttrBlock is one of the
            // original IDL_DRSInterDomainMove arguments which was
            // unmarshalled by RPC, and thus we are not guaranteed that
            // it was allocated from the thread heap - which we need in
            // order for THReAlloc and other core routines to work properly.

            DupAttr(pTHS, &pAttrBlock->pAttr[i], &pMod->AttrInf);

            for ( j = 0; j < pMod->AttrInf.AttrVal.valCount; j++ )
            {
                if ( ret = PrepareSecretData(hDrs, pTHS,
                                             modifyArg.pResObj->pObj,
                                             pMod->AttrInf.attrTyp,
                                             &pMod->AttrInf.AttrVal.pAVal[j],
                                             srcRid, dstRid) )
                {
                    Assert(pTHS->errCode);
                    return(ret);
                }
            }

            if ( --cSecret )
            {
                cBytes = sizeof(ATTRMODLIST);
                pMod->pNextMod = (ATTRMODLIST *) THAllocEx(pTHS, cBytes);
                pMod = pMod->pNextMod;
            }
        }
    }

    // MODIFYARG is ready.  Write as fDSA to avoid security checks.  fDRA
    // should not be set else we'll get RPC session decryption again which
    // PrepareSecretData already took care of.

    Assert(!pTHS->fDRA);
    pTHS->fDSA = TRUE;

    __try
    {
        ret = LocalModify(pTHS, &modifyArg);
        Assert(ret ? ret == pTHS->errCode : TRUE);
    }
    __finally
    {
        pTHS->fDSA = FALSE;
    }

    return(ret);
}

VOID
LogRemoteAddStatus(
    IN DWORD Severity,
    IN DWORD Mid,
    IN PSTR  String1,
    IN PSTR  String2,
    IN DWORD ErrCode
    )
{
    LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
             Severity,
             Mid,
             szInsertSz(String1),
             szInsertSz(String2),
             (ErrCode == 0) ? NULL : szInsertInt(ErrCode));
}

ULONG
IDL_DRSInterDomainMove(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    IN  DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    )
{
    THSTATE                 *pTHS = NULL;
    ULONG                   draErr = DRAERR_Success;
    ULONG                   dwErr = 0;
    SCHEMA_PREFIX_TABLE     *pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE hPrefixMap = NULL;
    ATTRBLOCK               *pAttrBlock;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    BOOL                    fSamClass = FALSE;
    BOOL                    fTransaction = FALSE;
    DSNAME                  dsName;
    DSNAME                  *pParentObj;
    ULONG                   len;
    ULONG                   ulCrossDomainMove;
    BOOL                    fContinue;
    SYNTAX_DISTNAME_BINARY  *pSrcProxy;
    SYNTAX_DISTNAME_BINARY  *pDstProxy;
    NAMING_CONTEXT          *pSrcNC;
    DWORD                   proxyType;
    DWORD                   proxyEpoch;
    ATTCACHE                *pAC;
    DWORD                   srcRid;
    BYTE                    SchemaInfo[SCHEMA_INFO_LENGTH] = {0};

    drsReferenceContext( hDrs, IDL_DRSINTERDOMAINMOVE );
    INC( pcThread );    // Perfmon hook

    __try {
	__try   // outer try/except
	    {
	    // We currently support just one output message version.
	    // All IDL_* routines should return DRAERR_* values.
	    // Ideally the routine returns DRAERR_Success and actual error
	    // info is returned in pmsgOut->V2.win32Error.  This way the
	    // caller can distinguish between connectivity/RPC errors and
	    // processing errors.  But we still throw the usual DRA exceptions
	    // for busy and such for compatability with other IDL_* calls.

	    *pdwMsgOutVersion = 2;
	    pmsgOut->V2.win32Error = DIRERR_GENERIC_ERROR;

	    // Discard request if the DS is not yet installed.

	    if ( DsaIsInstalling() )
		{
		DRA_EXCEPT_NOLOG(DRAERR_Busy, 0);
	    }

	    if ((NULL == pmsgIn) ||
		(2 != dwMsgInVersion) ||
		(NULL == pmsgOut))
		{
		DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, 0);
	    }

	    // Get a thread state.

	    if (!(pTHS = InitTHSTATE(CALLERTYPE_INTERNAL)) )
		{
		// Failed to initialize a THSTATE.
		DRA_EXCEPT_NOLOG(DRAERR_OutOfMem, 0);
	    }

	    Assert(VALID_THSTATE(pTHS));
	    //
	    // PREFIX: PREFIX complains that there is the possibility
	    // of pTHS->CurrSchemaPtr being NULL at this point.  However,
	    // the only time that CurrSchemaPtr could be NULL is at the
	    // system start up.  By the time that the RPC interfaces
	    // of the DS are enabled and this function could be called,
	    // CurrSchemaPtr will no longer be NULL.
	    //
	    Assert(NULL != pTHS->CurrSchemaPtr);

	    Assert(2 == dwMsgInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsInterDomainMove,
			     szInsertDN(pmsgIn->V2.pSrcDSA),
			     szInsertDN(pmsgIn->V2.pSrcObject->pName),
			     szInsertDN(pmsgIn->V2.pDstName),
			     szInsertDN(pmsgIn->V2.pExpectedTargetNC),
			     NULL, NULL, NULL, NULL);

	    // The security model for a remote add is that we want to impersonate
	    // the caller who requested a cross domain move at the source DC - but
	    // only while we're doing the actual add call.  For other operations
	    // like phantomization, we want to be running as the replicator.  At
	    // the same time, we need to insure that the remote add call indeed
	    // came from a peer DC, else any client could send a remote add call to
	    // this interface directly, thereby providing a back door means of
	    // generating security principals with a SID history of their choice.

	    if (!IsEnterpriseDC(pTHS, &dwErr))
		{
		DRA_EXCEPT_NOLOG(dwErr, 0);
	    }

	    // Check if the schema-infos match if both sides support it
	    // We know Dsa is running at this point, so no need to check
	    // for that

	    if (IS_DRS_SCHEMA_INFO_SUPPORTED(&((DRS_CLIENT_CONTEXT * )hDrs)->extRemote)) {
		StripSchInfoFromPrefixTable(&(pmsgIn->V2.PrefixTable), SchemaInfo);
		if (!CompareSchemaInfo(pTHS, SchemaInfo, NULL)) {
		    // doesn't match. Fail, but signal a schema cache update first

		    if (!SCSignalSchemaUpdateImmediate()) {
			// couldn't even signal a schema update
			DRA_EXCEPT (DRAERR_InternalError, 0);
		    }
		    DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
		}
	    }

	    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
	    hPrefixMap = PrefixMapOpenHandle(&pmsgIn->V2.PrefixTable,
					     pLocalPrefixTable);

	    // All errors after here should not throw DRA_EXCEPT and instead
	    // set pTHStls->errCode.

	    __try   // misc and transaction cleanup try/finally
		{
		// Make sure we're authoritive for the destination and that
		// we are consistent on which naming context the desired object
		// falls in.

		if ( !VerifyNCForMove(  pmsgIn->V2.pSrcObject->pName,
					pmsgIn->V2.pDstName,
					pmsgIn->V2.pExpectedTargetNC,
					&pSrcNC,
					&dwErr) )
		    {
		    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, dwErr);
		    _leave;
		}

		Assert(!dwErr);

		// Verify we can authenticate the credentials blob.
		// Do this before acquiring SAM lock as SAM doesn't
		// expect/want locks held during authentication.

		if ( dwErr = AuthenticateSecBufferDesc(pmsgIn->V2.pClientCreds) )
		    {
		    SetSecError(SE_PROBLEM_INVALID_CREDENTS, dwErr);
		    _leave;
		}

		// Work around RPC allocation issues, map ATTRTYPs, and
		// morph/strip attrs as required by DirAddEntry.

		if ( dwErr = DupAndMassageInterDomainMoveArgs(
		    pTHS,
		    &pmsgIn->V2.pSrcObject->AttrBlock,
		    hPrefixMap,
		    &pAttrBlock,
		    &fSamClass,
		    &pSrcProxy,
		    &srcRid) )
		    {
		    Assert(pTHS->errCode && (dwErr == pTHS->errCode));
		    _leave;
		}

		//
		// SAM lock is no longer a require ment
		//
		Assert(!pTHS->fSamWriteLockHeld);


		// Start a multi-call transaction.
		SYNC_TRANS_WRITE();
		fTransaction = TRUE;

		// Phantomize old object if required.

		pTHS->fDRA = TRUE;
		_try
		    {
		    dwErr = PrepareForInterDomainMove(
			pTHS,
			pmsgIn->V2.pSrcObject->pName,
			pmsgIn->V2.pDstName,
			pSrcProxy);
		}
		_finally
		    {
		    pTHS->fDRA = FALSE;
		}

		if ( dwErr )
		    {
		    Assert(pTHS->errCode && (dwErr == pTHS->errCode));
		    _leave; // misc and transaction cleanup try/finally
		}

		pTHS->fCrossDomainMove = TRUE;
		_try    // fCrossDomainMove try/finally
		    {
		    memset(&addArg, 0, sizeof(ADDARG));
		    InitCommarg(&addArg.CommArg);

		    // Clear destination name SID, prime GUID with that
		    // of old object.
		    pmsgIn->V2.pDstName->SidLen = 0;
		    memset(&pmsgIn->V2.pDstName->Sid, 0, sizeof(NT4SID));
		    memcpy(&pmsgIn->V2.pDstName->Guid,
			   &pmsgIn->V2.pSrcObject->pName->Guid,
			   sizeof(GUID));

		    addArg.pObject = pmsgIn->V2.pDstName;
		    addArg.AttrBlock = *pAttrBlock;
		    addArg.pMetaDataVecRemote = NULL;

		    // Assert this is 100% access controlled - no flags set.
		    Assert(    !pTHS->fDSA
			       && !pTHS->fDRA
			       && !pTHS->fSAM
			       && !pTHS->fLsa );

		    pParentObj = (DSNAME *) THAllocEx(pTHS,
						      addArg.pObject->structLen);
		    if ( TrimDSNameBy(addArg.pObject, 1, pParentObj) )
			{
			dwErr = SetNamError(NA_PROBLEM_BAD_NAME,
					    addArg.pObject,
					    DIRERR_BAD_NAME_SYNTAX);
			_leave; // fCrossDomainMove try/finally
		    }

		    if ( dwErr = DBFindDSName(pTHS->pDB, pParentObj) )
			{
			dwErr = SetNamError(NA_PROBLEM_BAD_NAME,
					    pParentObj,
					    ERROR_DS_NO_PARENT_OBJECT);
			_leave; // fCrossDomainMove try/finally
		    }

		    addArg.pResParent = CreateResObj(pTHS->pDB, pParentObj);

		    // Subsequent calls will NOT validate ex-machine references
		    // against the GC because GC verification is bypassed when
		    // pTHS->fCrossDomainMove is set.  I.e. We are trusting our
		    // peer DC to have given us DSNAME-valued attributes which
		    // refer to real things in the enterprise.  See also
		    // VerifyDsnameAtts.

		    if (    !(dwErr = SampAddLoopbackCheck(&addArg, &fContinue))
			    && fContinue )
			{
			dwErr = LocalAdd(pTHS, &addArg, FALSE);
		    }

		    if ( !dwErr )
			{
			// Prior calls added everything except DBIsSecretData
			// attributes which were filtered out earlier.  Now
			// write those attributes, if present, as fDRA so
			// that session encrypted data is decrypted correctly.

			dwErr = WriteSecretData(
			    hDrs, pTHS, srcRid, &addArg,
			    &pmsgIn->V2.pSrcObject->AttrBlock);
		    }

		    if ( dwErr )
			{
			_leave; // fCrossDomainMove try/finally
		    }

		    // Now read the added object so as to get the parent
		    // name with the proper casing and new SID so that phantom
		    // at source is case and SID correct.

		    Assert(pTHS->transactionlevel);
		    memset(&dsName, 0, sizeof(DSNAME));
		    dsName.structLen = sizeof(DSNAME);
		    memcpy( &dsName.Guid,
			    &pmsgIn->V2.pSrcObject->pName->Guid,
			    sizeof(GUID));

		    if (    (dwErr = DBFindDSName(pTHS->pDB, &dsName))
			    || (dwErr = DBGetAttVal(pTHS->pDB,
						    1,                  // get 1 value
						    ATT_OBJ_DIST_NAME,
						    0,                  // allocate return data
						    0,                  // supplied buffer size
						    &len,               // output data size
						    (UCHAR **) &pmsgOut->V2.pAddedName)) )
			{
			SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
			_leave; // misc and transaction cleanup try/finally
		    }

		    // Every cross-domain-moved object is given an
		    // ATT_PROXIED_OBJECT_NAME attribute which 1) points back
		    // at the domain it was last moved from, and 2) advances the
		    // epoch number.  If the attribute is missing from the inbound
		    // object, then it has never been moved yet and needs an
		    // initial value with (1 == epoch).

		    Assert(pSrcNC);
		    Assert(pSrcProxy
			   ? PROXY_TYPE_MOVED_OBJECT == GetProxyType(pSrcProxy)
			   : TRUE);
		    proxyType = PROXY_TYPE_MOVED_OBJECT;
		    proxyEpoch = (pSrcProxy
				  ? GetProxyEpoch(pSrcProxy) + 1
				  : 1);
		    MakeProxy(pTHS, pSrcNC, proxyType,
			      proxyEpoch, &len, &pDstProxy);
		    pAC = SCGetAttById(pTHS, ATT_PROXIED_OBJECT_NAME);

		    // We should still be positioned on the object from prior read
		    // and it should not have an ATT_PROXIED_OBJECT_NAME since we
		    // stripped that from the incoming data in DupAndMassage...

		    if (    (dwErr = DBAddAttVal_AC(pTHS->pDB, pAC,
						    len, pDstProxy))
			    || (dwErr = DBRepl(pTHS->pDB, FALSE, 0, NULL,
					       META_STANDARD_PROCESSING)) )
			{
			SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
			_leave; // misc and transaction cleanup try/finally
		    }
		}
		_finally
		    {
		    pTHS->fCrossDomainMove = FALSE;
		}

		Assert(dwErr == pTHS->errCode);
	    }
	    __finally   // misc and transaction cleanup try/finally
		{
		if ( hPrefixMap )
		    PrefixMapCloseHandle(&hPrefixMap);

		// Grab error code from above operations before failure
		// to commit (possibly) overwrites pTHS->errCode and
		// pTHS->pErrInfo.

		pmsgOut->V2.win32Error = Win32ErrorFromPTHS(pTHS);

		if ( fTransaction )
		    {
		    CLEAN_BEFORE_RETURN(pTHS->errCode);
		}
		else if ( pTHS->fSamWriteLockHeld )
		    {
		    Assert(FALSE && "We should not fall into this because we don't acquire SAM lock any more");
		    SampReleaseWriteLock(FALSE);
		    pTHS->fSamWriteLockHeld = FALSE;
		}

		// Log what happened - security errors are logged separately.

		if ( pTHS->errCode != securityError )
		    {
		    UCHAR *pszSrcDN, *pszDstDN;

		    pszSrcDN = MakeDNPrintable(pmsgIn->V2.pSrcObject->pName);
		    pszDstDN = MakeDNPrintable(pmsgIn->V2.pDstName);

		    if ( pTHS->errCode || AbnormalTermination() )
			{
			LogRemoteAddStatus(
			    DS_EVENT_SEV_EXTENSIVE,
			    DIRLOG_REMOTE_ADD_FAILED,
			    pszSrcDN,
			    pszDstDN,
			    pmsgOut->V2.win32Error);
		    }
		    else
			{
			LogRemoteAddStatus(
			    DS_EVENT_SEV_INTERNAL,
			    DIRLOG_REMOTE_ADD_SUCCEEDED,
			    pszSrcDN,
			    pszDstDN,
			    0);
		    }
		}
	    }
	}
	__except(GetDraException(GetExceptionInformation(), &draErr))
	{
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsInterDomainMove,
			     szInsertUL(draErr),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	} 

	if ( draErr )
	    {
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_BASIC,
		     DIRLOG_DRA_CALL_EXIT_BAD,
		     szInsertUL(dwErr),
		     NULL,
		     NULL);
	}
    }
    __finally {
	DEC(pcThread);      // Perfmon hook
        drsDereferenceContext( hDrs, IDL_DRSINTERDOMAINMOVE );
    }
    return(draErr);
}


ULONG AddNewNtdsDsa(IN  THSTATE *pTHS,
                    IN  DRS_HANDLE hDrs,
                    IN  DWORD dwInVersion,
                    IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                    IN  ENTINF *pEntInf,
                    IN  DSNAME *pDomain,
                    IN  DSNAME *pServerReference,
                    OUT GUID* objGuid,
                    OUT NT4SID* objSid  )
/*++

  Routine Description:

    This routine creates an ntdsa object

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for the ntdsa object
    pDomain     - DN of the domain this ntdsa object will host
    ulSysFlags  - flags that the caller wants placed on the CR
    objGuid     - the guid of the object
    objSid      - the sid of the object

  Return Values:

    embedded in output message

--*/
{

    COMMARG CommArg;
    ATTRVAL AVal;
    COMMRES CommRes;
    CROSS_REF *pCR = NULL;
    ULONG err;
    ADDARG AddArg;
    DSNAME *pParent = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG  ulLen;
    ULONG  AccessGranted = 0;
    ULONG  sysflags = 0;
    CLASSCACHE *pCC;
    ULONG  cbSD;
    BOOL   fAccessAllowed = FALSE;
    WCHAR  *pszServerGuid = NULL;
    ATTR   *AttrArray;
    ATTRBLOCK AttrBlock;
    ULONG i, j;
    LONG lDsaVersion;

    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pDomain, &CommArg);
    CommArg.Svccntl.dontUseCopy = TRUE;

    __try {

        //
        // Make sure the cross ref exists
        //
        if (NULL == pCR) {
            // Couldnt find the cross ref normally.  Look in the transactional
            // view.
            OBJCACHE_DATA *pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;

            while(pTemp) {
                switch(pTemp->type) {
                case OBJCACHE_ADD:
                    if(NameMatched(pTemp->pCRL->CR.pNC, pDomain)) {
                        Assert(!pCR);
                        pCR = &pTemp->pCRL->CR;
                    }
                    pTemp = pTemp->pNext;
                    break;
                case OBJCACHE_DEL:
                    if(pCR && NameMatched( pTemp->pDN, pCR->pObj)) {
                        pCR = NULL;
                    }
                    pTemp = pTemp->pNext;
                    break;
                default:
                    LogUnhandledError(pTemp->type);
                    pCR = NULL;
                    pTemp = NULL;
                }
            }
        }
        if (NULL == pCR) {
            // Still coulndt find the correct cross ref.
            err = ERROR_DS_NO_CROSSREF_FOR_NC;
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_CROSSREF_FOR_NC,
                          err);
            __leave;
        }

        //
        // Make sure it is a NTDS cross ref
        //
        err = DBFindDSName(pTHS->pDB, pCR->pObj);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_OBJ_NOT_FOUND,
                          err);
            __leave;
        }
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_SYSTEM_FLAGS,
                               &sysflags,
                               sizeof(sysflags),
                               NULL);
        if ( err
          || !(FLAG_CR_NTDS_DOMAIN & sysflags) ) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_CROSSREF_FOR_NC,
                          err);
            __leave;
        }

        //
        // Ok, perform the security check
        //

        // Read the domain object
        err = DBFindDSName(pTHS->pDB, pDomain);
        if ( 0 == err )
        {
            // The domain object exists
            DBFillGuidAndSid( pTHS->pDB, pDomain );

            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_NT_SECURITY_DESCRIPTOR,
                              0,
                              0,
                              &cbSD,
                              (UCHAR **) &pSD);

            // Get it's object class while we're at it.
            if ( 0 == err )
            {
                GetObjSchema(pTHS->pDB, &pCC);

                // Domain exists
                fAccessAllowed = IsControlAccessGranted( pSD,
                                                         pDomain,
                                                         pCC,
                                                         RIGHT_DS_REPL_MANAGE_REPLICAS,
                                                         FALSE );
            }
        }

        // N.B err means error access either the domain object or reading
        // the security descriptor
        if ( err )
        {
            // Check to see if we added the domain in this AddEntry call

            ENTINFLIST *pCur = &pmsgIn->V2.EntInfList;
            while ( pCur ) {

                ATTRBLOCK *pAttrBlock;
                ATTR      *pAttr;
                ULONG      class = CLASS_TOP;
                DSNAME    *pNCName = NULL;
                ULONG      i;

                if ( &(pCur->Entinf) == pEntInf ) {
                    // we're reached the current ntdsa object and not found the
                    // cross-ref
                    Assert( FALSE == fAccessAllowed );
                    break;
                }

                // Dissect the object
                pAttrBlock = &pCur->Entinf.AttrBlock;
                for (i=0; i< pAttrBlock->attrCount; i++) {
                    pAttr = &(pAttrBlock->pAttr[i]);
                    switch (pAttr->attrTyp) {
                      case ATT_OBJECT_CLASS:
                        class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
                      break;

                      case ATT_NC_NAME:
                        pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
                        break;

                      default:
                        ;
                    }
                }

                // Is this the object we are looking for?
                if (   (CLASS_CROSS_REF == class)
                   &&  NameMatched( pNCName, pDomain ) ) {

                    fAccessAllowed = TRUE;
                    break;
                }

                // Try the next object
                pCur = pCur->pNextEntInf;
            }
        }

        if ( !fAccessAllowed ) {

            err = ERROR_ACCESS_DENIED;
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_ACCESS_DENIED,
                          err);
           _leave;
        }


        //check if the DSA binary version is too low
        //this is only for win2k candidate DC
        //Whistler and later version should have already performed a verification
        //locally, and is never supposed to submit such a request
        lDsaVersion = 0;

        for ( i = 0; i < pEntInf->AttrBlock.attrCount; i++) {

            if ( pEntInf->AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_BEHAVIOR_VERSION ) {

                lDsaVersion = (LONG) *(pEntInf->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);

                break;

            }
        }
        if (  lDsaVersion < gAnchor.ForestBehaviorVersion ) {

            DPRINT(2, "AddNewNtdsDsa: too low version number(forest).\n");

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_DRA_TOO_LOW_VERSION,
                     szInsertInt(lDsaVersion),
                     szInsertInt(gAnchor.ForestBehaviorVersion),
                     NULL);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_INCOMPATIBLE_VERSION );
            __leave;

        }
        if (     NameMatched(pDomain,gAnchor.pDomainDN)
             &&  lDsaVersion < gAnchor.DomainBehaviorVersion ) {

            DPRINT(2, "AddNewNtdsDsa: too low version number(domain).\n");
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_DRA_TOO_LOW_VERSION,
                     szInsertInt(lDsaVersion),
                     szInsertInt(gAnchor.DomainBehaviorVersion),
                     NULL);

            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_INCOMPATIBLE_VERSION );
            __leave;

        }


        //
        // We've made it this far, it is time to create the object
        //
        pTHS->fDSA = TRUE;

        //
        // For this release, we aren't writing the server reference
        // on the ntds-settings object, so remove it from
        // the AttrBlock.  In case we decide to set it at some point
        // only remove the first one we see.
        //
        AttrArray = THAllocEx(pTHS, sizeof(ATTR) * pEntInf->AttrBlock.attrCount );
        j = 0;
        for ( i = 0; i < pEntInf->AttrBlock.attrCount; i++) {

            BOOL FoundIt = FALSE;

            if (   FoundIt
                || pEntInf->AttrBlock.pAttr[i].attrTyp != ATT_SERVER_REFERENCE ) {

                AttrArray[j] = pEntInf->AttrBlock.pAttr[i];
                j++;
            } else {
                FoundIt = TRUE;
            }
        }
        memset( &AttrBlock, 0, sizeof(AttrBlock) );
        AttrBlock.attrCount = j;
        AttrBlock.pAttr = AttrArray;


        // Prepare the add arg
        memset(&AddArg, 0, sizeof(AddArg));
        AddArg.pObject = pEntInf->pName;
        AddArg.AttrBlock = AttrBlock;
        AddArg.CommArg = CommArg;
        InitCommarg(&CommArg);

        pParent = THAllocEx(pTHS, AddArg.pObject->structLen);
        TrimDSNameBy(AddArg.pObject, 1, pParent);

        // Find the parent
        err = DoNameRes(pTHS,
                        0,
                        pParent,
                        &AddArg.CommArg,
                        &CommRes,
                        &AddArg.pResParent);

        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_PARENT_OBJECT,
                          err);
            __leave;
        }

        //
        // Make the object replicate urgently
        //
        CommArg.Svccntl.fUrgentReplication = TRUE;

        // Do the add!
        err = LocalAdd(pTHS, &AddArg, FALSE);
        if (err) {
            __leave;
        }

        //
        // Return the guid and sid of the object created
        //
        *objGuid = AddArg.pObject->Guid;
        *objSid  = AddArg.pObject->Sid;

        // Give the server reference, write an SPN so other servers can
        // replicate with this new server
        if ( pServerReference ) {

            MODIFYARG ModArg;
            MODIFYRES ModRes;
            ATTRVAL  AttrVal;
            LPWSTR   DnsDomainName;

            Assert( pCR );
            Assert( pCR->DnsName );
            if ( !pCR->DnsName) {

                //
                // No dns name?
                //
                err = ERROR_DS_INTERNAL_FAILURE;
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
               _leave;

            }

            //
            // First construct the SPN and put it into a ATTRVAL
            //
            memset( &AttrVal, 0, sizeof(AttrVal));
            err = UuidToStringW( objGuid, &pszServerGuid );
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;
            }

            //
            // Magic steps to make replication SPN
            // N.B.  This should be the same SPN as written in
            // WriteServerInfo().
            //
            if(err = WrappedMakeSpnW(pTHS,
                                     DRS_IDL_UUID_W, // RPC idl guid
                                     pCR->DnsName,   // dns name of the domain
                                     pszServerGuid,  // guid of the server
                                     0,
                                     NULL,
                                     &AttrVal.valLen,
                                     (WCHAR **)&AttrVal.pVal)) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;

            }

            memset(&ModArg, 0, sizeof(ModArg));
            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pServerReference;
            ModArg.count = 1;

            ModArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;

            ModArg.CommArg = CommArg;
            InitCommarg(&CommArg);
            memset( &CommRes, 0, sizeof(CommRes) );
            if (0 == DoNameRes(pTHS,
                               0,
                               ModArg.pObject,
                               &ModArg.CommArg,
                               &CommRes,
                               &ModArg.pResObj) ){

                // Do the modify!
                err = LocalModify(pTHS, &ModArg);

            } else {

                //
                // Couldn't find the server object?  Indicate this.
                //
                err = ERROR_NO_TRUST_SAM_ACCOUNT;
                SetSvcError(SV_PROBLEM_DIR_ERROR, err);

            }

            if (err) {
                __leave;
            }
        }

    } __finally {

        pTHS->fDSA = FALSE;

        // N.B. the calling routine handles the transactioning

        THFreeEx(pTHS, pParent);

        if (pszServerGuid) {
            RpcStringFreeW( &pszServerGuid );
        }

    }


    return pTHS->errCode;

}

ULONG AddNewDomainCrossRef(IN  THSTATE *pTHS,
                           IN  DRS_HANDLE hDrs,
                           IN  DWORD dwInVersion,
                           IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                           IN  ENTINF *pEntInf,
                           IN  DSNAME *pNCName,
                           IN  ULONG ulSysFlags,
                           IN  ADDCROSSREFINFO *pCRInfo,
                           OUT GUID* objGuid,
                           OUT NT4SID* objSid  )
/*++

  Routine Description:

    This routine creates a cross ref object for a new child domain.  The CR
    may already be in place in a disabled state, in which case we will
    enable it.  See childdom.doc for a full description.

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for the cross ref
    pNCName     - DN of the new child domain
    ulSysFlags  - flags that the caller wants placed on the CR
    pdwOutVersion - version of output message
    pmsgOut     - output message


  Return Values:

    embedded in output message

--*/
{
    COMMARG CommArg;
    MODIFYARG ModArg;
    ATTRVAL AVal;
    COMMRES CommRes;
    CROSS_REF *pCR;
    ULONG err;
    ATTR *   pAttr = NULL;
    ENTINF *pEI = NULL;

    // We're trying to add a cross-ref, but we may already have a CR
    // for the NC that we're adding a CR for.  Check with the in-memory
    // knowledge to see what we know.
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pNCName, &CommArg);
    CommArg.Svccntl.dontUseCopy = TRUE;

    // As of about 10/25/98, clients should not be giving either GUID or
    // SID for the NC-Name value.  Error out accordingly.
    if ( !fNullUuid(&pNCName->Guid) || pNCName->SidLen ) {
        return(SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_PARAM_ERROR));
    }

    // Add NC-Name value to GC verify cache else VerifyDSNameAtts will
    // claim this DN doesn't correspond to an existing object.
    pEI = THAllocEx(pTHS, sizeof(ENTINF));
    pEI->pName = pNCName;
    GCVerifyCacheAdd(NULL,pEI);

    if (NULL == pCR ||
        !(ulSysFlags & FLAG_CR_NTDS_DOMAIN) ) {

        // We don't already have a CR for this hunk-o-namespace, (or if
        // the CR we're trying to add is already a NDNC CR) so we can 
        // just try to create one, as requested.  We don't even have to
        // check for permissions, FSMO-hood, or anything else, as those 
        // checks are done in the add.  We do have to manually perform 
        // name resolution so that we can call LocalAdd and LocalModify,
        // so that we can wrap them up in one transaction. Doing so 
        // seemed simpler than trying to recover from errors after we 
        // had committed part of the update.  If this is a pre-existing
        // NDNC CR we will try to add it anyway, but this will generate
        // an error, but this is what the requester expects.  If it finds
        // that we've already got a CR, it just schedules a sync in
        // GetCrossRefForNDNC().

        ADDARG AddArg;
        DSNAME *pParent = NULL;

        __try {

            // First, add the object, using the user's credentials

            memset(&AddArg, 0, sizeof(AddArg));
            AddArg.pObject = pEntInf->pName;
            AddArg.AttrBlock = pEntInf->AttrBlock;
            AddArg.pCRInfo = pCRInfo;
            Assert(AddArg.pCRInfo);

            // BUGBUG This horrible hack brought to you by CheckAddSecurity(),
            // which assumes that the AttrBlock.pAttr array is THAlloc'd and  so
            // it can THReAlloc's the pAttr array to fit the security descriptor.
            // Should one fix this here, or fix CheckAddSecurity().
            pAttr = AddArg.AttrBlock.pAttr;
            AddArg.AttrBlock.pAttr = THAllocEx(pTHS,
                                               (AddArg.AttrBlock.attrCount *
                                                sizeof(ATTR)));
            memcpy(AddArg.AttrBlock.pAttr, pAttr, (AddArg.AttrBlock.attrCount *
                                                sizeof(ATTR)));


            AddArg.CommArg = CommArg;

            pParent = THAllocEx(pTHS, AddArg.pObject->structLen);
            TrimDSNameBy(AddArg.pObject, 1, pParent);

            err = DoNameRes(pTHS,
                            0,
                            pParent,
                            &AddArg.CommArg,
                            &CommRes,
                            &AddArg.pResParent);
            if (err) {
                __leave;
            }

            //
            // Make the object replicate urgently
            //
            CommArg.Svccntl.fUrgentReplication = TRUE;

            err = LocalAdd(pTHS, &AddArg, FALSE);
            if (err) {
                __leave;
            }


            // Ok, now become the DSA and adjust the system flags
            // on the object we just created.

            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pEntInf->pName;
            ModArg.CommArg = CommArg;
            ModArg.count = 1;
            ModArg.FirstMod.pNextMod = NULL;
            ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
            AVal.valLen = sizeof(ulSysFlags);
            AVal.pVal = (PUCHAR)&ulSysFlags;
            Assert(ulSysFlags & FLAG_CR_NTDS_NC);
            if(!(ulSysFlags & FLAG_CR_NTDS_NC)){
                // I am going to make the assertion that it is invalid to try
                // to create a non NT DS cross-ref object through the remote
                // add entry API.
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_MISSING_EXPECTED_ATT);
                err = pTHS->errCode;
                Assert(err);
                __leave;
            }

            // We used to set the systemFlags here, but the system flags on the
            // cross-ref should be set by the client, so that we can change what
            // get's set.

            err = DoNameRes(pTHS,
                            0,
                            ModArg.pObject,
                            &ModArg.CommArg,
                            &CommRes,
                            &ModArg.pResObj);
            if (err) {
                __leave;
            }

            pTHS->fDSA = TRUE;
            err = LocalModify(pTHS,
                              &ModArg);
        } __finally {

            pTHS->fDSA = FALSE;

            // N.B. The calling function handles the transaction
            THFreeEx(pTHS, pParent);
        }

    } else {
#define MAXCRMODS 5
        // This is the case where a disabled version of the CR already
        // exists in the partitions container.  What we have to do now
        // is find the CR object, read the dns-root from it, and compare
        // the IP address it describes with the IP address of our caller.
        // If they match, we touch up the CR with whatever we need to.
        WCHAR *pwDNS = NULL;
        char *pszDNS = NULL;
        ULONG cb;
        struct hostent *pHostAllowed;
        RPC_BINDING_HANDLE hServerBinding;
        char *pStringBinding, *pAddressActual, *pCur;
        int i;
        unsigned u;
        BOOLEAN fPermitted;
        ATTRMODLIST OtherMod[MAXCRMODS];
        BOOLEAN fGotDNSAddr;
        char b;
        ULONG enabled = FALSE;

        // read dns-root from object
            
        // If we're adding a domain, then we need to patch up
        // the domain promotion to Enable the CR, and check
        // that the machine requesting this to instantiate this
        // Domain NC is the machine in the dNSRoot of this CR.

        __try {
            err = DBFindDSName(pTHS->pDB, pCR->pObj);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_OBJ_NOT_FOUND,
                              err);
                __leave;
            }
            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_ENABLED,
                                   &enabled,
                                   sizeof(enabled),
                                   NULL);
            if (err || enabled) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DUP_DOMAINNAME,
                              err);
                __leave;
            }

            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_DNS_ROOT,
                              0,
                              0,
                              &cb,
                              (UCHAR **)&pwDNS);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_MISSING_REQUIRED_ATT,
                              err);
                __leave;
            }

            // compute allowed ip address of caller via gethostbyname++
            pszDNS = THAllocEx(pTHS, cb);
            WideCharToMultiByte(CP_UTF8,
                                0,
                                pwDNS,
                                cb/sizeof(WCHAR),
                                pszDNS,
                                cb,
                                NULL,
                                NULL);

            pHostAllowed = gethostbyname(pszDNS);
            if (!pHostAllowed) {
                SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH,
                            ERROR_DS_DNS_LOOKUP_FAILURE);
                __leave;
            }


            DPRINT5(1, "CR promotion allowed by %s (%u.%u.%u.%u) only\n",
                    pszDNS,
                    (unsigned char)(pHostAllowed->h_addr_list[0][0]),
                    (unsigned char)(pHostAllowed->h_addr_list[0][1]),
                    (unsigned char)(pHostAllowed->h_addr_list[0][2]),
                    (unsigned char)(pHostAllowed->h_addr_list[0][3]));

            // compute actual ip address of caller via RpcXxx
            hServerBinding = 0;
            pStringBinding = NULL;
            if ((RPC_S_OK != (err =
                              RpcBindingServerFromClient(NULL,
                                                         &hServerBinding)))
                || (RPC_S_OK != (err =
                                 RpcBindingToStringBinding(hServerBinding,
                                                           &pStringBinding)))
                || (RPC_S_OK != (err =
                                 RpcStringBindingParse(pStringBinding,
                                                     NULL,         // ObjUuid
                                                     NULL,         // ProtSeq
                                                     &pAddressActual, // NetworkAddr
                                                     NULL,         // Endpoint
                                                     NULL)))) {    // NetOptions
                DPRINT3(0,
                        "Error %u from Rpc, hServer = 0x%x, pString = 0x%x\n",
                        err,
                        hServerBinding,
                        pStringBinding);
                DebugBreak();
                if (pStringBinding) {
                    RpcStringFree(&pStringBinding);
                }
                SetSecErrorEx(SE_PROBLEM_INAPPROPRIATE_AUTH,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;
            }

            DPRINT1(1, "Caller is from address %s\n", pAddressActual);

            // if not identical, reject and go to done
            fPermitted = TRUE;
            pCur = pAddressActual;
            for (i=0; i<=3; i++) {
                b = 0;
                if (*pCur == '.') {
                    ++pCur;
                }
                while (*pCur && (*pCur != '.')) {
                    b = b*10 + (*pCur - '0');
                    ++pCur;
                }
                if (b != pHostAllowed->h_addr_list[0][i]) {
                    DPRINT3(1, "Byte %u, allowed = %u, actual = %u\n",
                            i, pHostAllowed->h_addr_list[0][i], b);
                    fPermitted = FALSE;
                    break;
                }
            }

            if (pStringBinding) {
                RpcStringFree(&pStringBinding);
            }
            if (pAddressActual) {
                RpcStringFree(&pAddressActual);
            }

            if (!fPermitted) {
                SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                            ERROR_DS_INSUFF_ACCESS_RIGHTS);
                DPRINT(0,"Refusing child domain creation\n");
                __leave;
            }

            DPRINT(0,"Allowing child domain creation\n");

            // modify CR object: set sys flags, clear Enabled.
            if (DBGetSingleValue(pTHS->pDB,
                                 ATT_SYSTEM_FLAGS,
                                 &ulSysFlags,
                                 sizeof(ulSysFlags),
                                 NULL)) {
                ulSysFlags = 0;
            }

            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pCR->pObj;
            ModArg.CommArg = CommArg;

            ModArg.FirstMod.pNextMod = &OtherMod[0];
            ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
            AVal.valLen = sizeof(ulSysFlags);
            AVal.pVal = (PUCHAR)&ulSysFlags;
            ulSysFlags |= (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);

            memset(&OtherMod, 0, sizeof(OtherMod));
            OtherMod[0].choice = AT_CHOICE_REMOVE_ATT;
            OtherMod[0].AttrInf.attrTyp = ATT_ENABLED;
            OtherMod[0].AttrInf.AttrVal.valCount = 0;

            i = 1;
            fGotDNSAddr = FALSE;

            for (u=0; u<pEntInf->AttrBlock.attrCount; u++) {
                ATTR *pAttr = &(pEntInf->AttrBlock.pAttr[u]);
                switch (pAttr->attrTyp) {
                  case ATT_DNS_ROOT:
                    fGotDNSAddr = TRUE;
                  case ATT_TRUST_PARENT:
                  case ATT_ROOT_TRUST:
                    Assert(i < MAXCRMODS);
                    OtherMod[i-1].pNextMod = &OtherMod[i];
                    OtherMod[i].choice = AT_CHOICE_REPLACE_ATT;
                    OtherMod[i].AttrInf.attrTyp = pAttr->attrTyp;
                    OtherMod[i].AttrInf.AttrVal = pAttr->AttrVal;
                    ++i;
                    break;

                  default:
                    ;
                }
            }

            if (!fGotDNSAddr) {
                SetAttError(ModArg.pObject,
                            ATT_DNS_ROOT,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                            NULL,
                            DIRERR_MISSING_REQUIRED_ATT);
                __leave;
            }

            ModArg.count = i+1;


            err = DoNameRes(pTHS,
                            0,
                            ModArg.pObject,
                            &ModArg.CommArg,
                            &CommRes,
                            &ModArg.pResObj);
            if (err) {
                __leave;
            }

            pTHS->fDSA = TRUE;
            LocalModify(pTHS,
                        &ModArg);

            DPRINT1(1,
                    "Modify completed with error 0x%x\n",
                    pTHS->errCode);

        } __finally {
            pTHS->fDSA = FALSE;

            // N.B. The calling function handles the transaction
        }
#undef MAXCRMODS
    }

    if (0 == pTHS->errCode) {
        *objGuid = ModArg.pResObj->pObj->Guid;
        *objSid = ModArg.pResObj->pObj->Sid;
    }

    return pTHS->errCode;
}


ULONG
ProcessSingleAddEntry(
    IN  THSTATE             *pTHS,
    IN  DRS_HANDLE           hDrs,
    IN  DWORD                dwInVersion,
    IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
    IN  ENTINF              *pEntInf,
    IN  ADDCROSSREFINFO     *pCRInfo,
    OUT GUID                *objGuid,
    OUT NT4SID              *objSid
    )
/*++

  Routine Description:

    This routine adds a single object (pEntInf) that came from the input args
    (pmsgIn).

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for object to add
    objGuid:    - guid of the object created
    objSid:     - sid of the object created

  Return Values:

    0 = success

--*/
{
    ULONG err = 0;

    ULONG i, j;

    ULONG ulSysFlags = 0;
    ATTRBLOCK *pAttrBlock;
    ATTR      *pAttr;
    ATTRTYP class = CLASS_TOP;

    DSNAME *pNCName = NULL;
    DSNAME *pDomain = NULL;
    DSNAME *pSchema = NULL;
    DSNAME *pConfig = NULL;
    DSNAME *pServerReference = NULL;


    // Parameter check
    Assert( pEntInf );
    Assert( objGuid );
    Assert( objSid );

    pAttrBlock = &pEntInf->AttrBlock;

    // Look through the arguments to the add to see what it is we're
    // being asked to add.  Also note that we strip out the system flags
    // attribute, so that we can deal with it separately.
    for (i=0; i< pAttrBlock->attrCount; i++) {
        pAttr = &(pAttrBlock->pAttr[i]);
        switch (pAttr->attrTyp) {
        case ATT_SYSTEM_FLAGS:
            // We now throw this in the LocalAdd(), AND the LocalModify(),
            // the reason, being that we create this thing without an
            // Enabled attr equal to FALSE.  We need a way in VerifyNcName()
            // to differentiate between an external and internal crossRef.
            // In the LocalAdd() this attr will be set to 0, because it's
            // protected.
            ulSysFlags = *(ULONG *)(pAttr->AttrVal.pAVal[0].pVal);
            break;
        case ATT_NC_NAME:
            pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;

        case ATT_OBJECT_CLASS:
            class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
            break;

        case ATT_HAS_MASTER_NCS:
             // This is multi-valued property
            for (j=0;j<pAttr->AttrVal.valCount;j++) {
                if (  NameMatched( gAnchor.pDMD, (DSNAME*)pAttr->AttrVal.pAVal[j].pVal ) ) {
                    pSchema = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                } else if ( NameMatched( gAnchor.pConfigDN, (DSNAME*)pAttr->AttrVal.pAVal[j].pVal ) ) {
                    pConfig = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                } else {
                    pDomain = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                }
            }
            break;

        case ATT_SERVER_REFERENCE:
            pServerReference = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;

        default:
            ;
        }
    }

    //
    // Call a particular function based on the class type
    //
    switch ( class )
    {
        case CLASS_CROSS_REF:

            // Make sure the parameters look good
            if (pNCName == NULL) {
                DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );
            }

            AddNewDomainCrossRef(pTHS,
                                 hDrs,
                                 dwInVersion,
                                 pmsgIn,
                                 pEntInf,
                                 pNCName,
                                 ulSysFlags,
                                 pCRInfo,
                                 objGuid,
                                 objSid );

            break;

        case CLASS_NTDS_DSA:

            // Make sure the parameters look good
            if ((pDomain == NULL) || (pSchema == NULL) || (pConfig == NULL)) {
                DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );
            }

            AddNewNtdsDsa(pTHS,
                          hDrs,
                          dwInVersion,
                          pmsgIn,
                          pEntInf,
                          pDomain,
                          pServerReference,
                          objGuid,
                          objSid );
            break;

        default:

            DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );

    }

    return pTHS->errCode;
}


ADDCROSSREFINFO *
PreTransGetCRInfo(
    THSTATE *     pTHS,
    ENTINF *      pEntInf
    )
{
    ULONG               i, j;
    ULONG               ulSysFlags = 0;
    ATTRBLOCK *         pAttrBlock;
    ATTR *              pAttr;
    ATTRTYP             class = CLASS_TOP;
    DSNAME *            pNCName = NULL;
    BOOL                bEnabled = TRUE;
    ADDCROSSREFINFO *   pCRInfo;

    // Parameter check
    Assert( pTHS && pEntInf );

    pAttrBlock = &pEntInf->AttrBlock;

    // Look through the arguments to the add to see what it is we're
    // being asked to add.  Also note that we strip out the system flags
    // attribute, so that we can deal with it separately.
    for (i=0; i< pAttrBlock->attrCount; i++) {
        pAttr = &(pAttrBlock->pAttr[i]);

        switch (pAttr->attrTyp) {
        case ATT_OBJECT_CLASS:
            class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
            if(class != CLASS_CROSS_REF){
                // We're not adding a crossRef bail early.
                return(NULL);
            }
            break;
        case ATT_NC_NAME:
            pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;
        case ATT_SYSTEM_FLAGS:
            ulSysFlags = *(ULONG *)(pAttr->AttrVal.pAVal[0].pVal);
            break;
        case ATT_ENABLED:
            bEnabled = *((BOOL *)(pAttr->AttrVal.pAVal[0].pVal));
            break;
        default:
            ;
        }
    }

    // Verify params.

    if(class != CLASS_CROSS_REF){
        // This is some other object, so return NULL w/o setting an error.
        return(NULL);
    }

    if(pNCName == NULL){
        // We didn't get all the needed parameters, bail.
        SetAttError(pEntInf->pName,
                    (pNCName) ? ATT_OBJECT_CLASS : ATT_NC_NAME,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_MISSING_REQUIRED_ATT);
        return(NULL);
    }

    //
    // OK, marshal the parameters, call the pre-transactional
    // nCName verification routine, and check for an error.
    //

    pCRInfo = THAllocEx(pTHS, sizeof(ADDCROSSREFINFO));
    pCRInfo->pdnNcName = pNCName;
    pCRInfo->bEnabled = bEnabled;
    pCRInfo->ulSysFlags = ulSysFlags;
    
    PreTransVerifyNcName(pTHS, pCRInfo);

    if(pTHS->errCode){
        THFreeEx(pTHS, pCRInfo);
        return(NULL);
    }

    return(pCRInfo);
}

void
DRS_AddEntry_SetErrorData(
             OUT DRS_MSG_ADDENTRYREPLY *    pmsgOut,   // Out Message
    OPTIONAL IN  PDSNAME                    pdsObject, // Object causing error
    OPTIONAL IN  THSTATE *                  pTHS,      // For Dir* error info
    OPTIONAL IN  DWORD                      ulRepErr,  // DRS error
             IN  DWORD                      dwVersion  // Version of out message
){

    if(dwVersion == 2){

        if (ulRepErr || (pTHS && pTHS->errCode)) {

            // Set the old version error.
            pmsgOut->V2.pErrorObject = pdsObject;

            Assert(pTHS->errCode == 0 || pTHS->pErrInfo);
            if(pTHS && pTHS->errCode && pTHS->pErrInfo){

                // This is the old code, preserved, it makes me a little nervous
                // because it presumes everything is a SvcErr, though it could
                // not be then the structs are a little different.
                pmsgOut->V2.errCode = pTHS->errCode;
                pmsgOut->V2.dsid    = pTHS->pErrInfo->SvcErr.dsid;
                pmsgOut->V2.extendedErr = pTHS->pErrInfo->SvcErr.extendedErr;
                pmsgOut->V2.extendedData = pTHS->pErrInfo->SvcErr.extendedData;
                pmsgOut->V2.problem = pTHS->pErrInfo->SvcErr.problem;

            } else {

                // Previously we used to do nothing (except sometimes AV) here,
                // but this is obviously the wrong behaviour, we should setup 
                // some kind of error.  ulRepErr is probably set, so we'll use
                // it if set.
                Assert(ulRepErr);
                pmsgOut->V2.dsid = DSID(FILENO, __LINE__);
                pmsgOut->V2.extendedErr = (ulRepErr) ? ulRepErr : ERROR_DS_DRA_INTERNAL_ERROR;
                pmsgOut->V2.extendedData = 0;
                pmsgOut->V2.problem = SV_PROBLEM_BUSY;

            }

        } else {

            // Success do nothing.
            ;

        }
        
    } else if(dwVersion == 3){
        
        // Set the new version error reply, 

        if (ulRepErr || (pTHS && pTHS->errCode)) {
            // Set this only on an error.
            // Note: Not deep copied, not needed.
            pmsgOut->V3.pdsErrObject = pdsObject;
        }

        // Yeah! New advanced error returning capabilities.
        // Currently only version 1 of the error data is supported.
        draEncodeError( pTHS, ulRepErr,
                        & (pmsgOut->V3.dwErrVer),
                        & (pmsgOut->V3.pErrData) );
       
    } else {

        DPRINT1(0, "Version is %ul", dwVersion);
        Assert(!"What version were we passed?  Huh?  Confused!");

    }       

    DPRINT1(1, "AddEntry Reply Version = %ul\n", dwVersion);
}



ULONG
IDL_DRSAddEntry (
                 IN  DRS_HANDLE hDrs,
                 IN  DWORD dwInVersion,
                 IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                 OUT DWORD *pdwOutVersion,
                 OUT DRS_MSG_ADDENTRYREPLY *pmsgOut)
/*++

  Routine Description:

    Remoted AddEntry interface.  Examines the input argument to determine the
    objclass of the object being added, and calls an appropriate worker
    function (only one right now) to do the dirty work.

  Parameters:

    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pNCName     - DN of the new child domain
    ulSysFlags  - flags that the caller wants placed on the CR
    pdwOutVersion - version of output message
    pmsgOut     - output message

  Return Values:

    0 = success

--*/
{
    THSTATE *pTHS = NULL;
    DSNAME *pNCName = NULL;
    unsigned i;
    ULONG err;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ATTR *pAttr;

    ULONG  cObjects = 0;
    ADDENTRY_REPLY_INFO *infoList = NULL;
    GUID   *guidList = NULL;
    NT4SID *sidList  = NULL;
    ENTINFLIST *pNextEntInfList = NULL;
    ENTINF *pEntInf;
    ENTINFLIST *pEntInfList;
    DRS_SecBufferDesc *pClientCreds;
    ADDCROSSREFINFO **  paCRInfo = NULL;

    drsReferenceContext( hDrs, IDL_DRSADDENTRY );
    INC(pcThread);      // Perfmon hook

    __try {

        __try {

            // This (InitTHSTATE) must happen before we start throwing 
            // excpetions so the error state can be allocated.
            // Initialize thread state and open data base.
            if(!(pTHS = InitTHSTATE(CALLERTYPE_INTERNAL))) {
                // Failed to initialize a THSTATE.
                DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0);
            }

            // Set the out version, if DC understands new WinXP reply 
            // format use that.
            if( IS_DRS_EXT_SUPPORTED(&(((DRS_CLIENT_CONTEXT * )hDrs)->extRemote), 
                                     DRS_EXT_ADDENTRYREPLY_V3) ){
                // WinXP/Whistler
                *pdwOutVersion = 3;
            } else {
                // Legacy Win2k request
                *pdwOutVersion = 2;
            }

            // Discard request if we're not installed.
            if ( DsaIsInstalling()) {
                DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
            }

            if (    ( NULL == pmsgIn )
                || ( NULL == pmsgOut )) {
                DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
            }

            switch (dwInVersion) {
            case 2:
                // Win2k-compatible request.
                pEntInfList = &pmsgIn->V2.EntInfList;
                pClientCreds = NULL;
                break;

            case 3:
                // >= Whistler request that supplies client credentials.
                pEntInfList = &pmsgIn->V3.EntInfList;
                pClientCreds = pmsgIn->V3.pClientCreds;
                break;

            default:
                DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, dwInVersion);
            }

            // How many objects are being passed in?
            pNextEntInfList = pEntInfList;
            while ( pNextEntInfList ) {
                cObjects++;
                pNextEntInfList = pNextEntInfList->pNextEntInf;
            }

            LogAndTraceEvent(TRUE,
                             DS_EVENT_CAT_RPC_SERVER,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_IDL_DRS_ADD_ENTRY_ENTRY,
                             EVENT_TRACE_TYPE_START,
                             DsGuidDrsAddEntry,
                             szInsertUL(cObjects),
                             (cObjects > 0)
                                 ? szInsertDN(pEntInfList->Entinf.pName)
                                 : szInsertSz(""),
                             (cObjects > 1) 
                                 ? szInsertDN(pEntInfList->pNextEntInf->Entinf.pName)
                                 : szInsertSz(""),
                             NULL, NULL, NULL, NULL, NULL);

            // Allocate space for the return buffer
            infoList = THAllocEx( pTHS, (sizeof(ADDENTRY_REPLY_INFO) * cObjects) );

            // We walk and call PreTransGetCRInfo() for each object.
            paCRInfo = THAllocEx( pTHS, (sizeof(ADDCROSSREFINFO) * cObjects));
            for ( pNextEntInfList = pEntInfList, i = 0;
                  NULL != pNextEntInfList;
                  pNextEntInfList = pNextEntInfList->pNextEntInf, i++ ) {
                Assert(i <= cObjects);
                paCRInfo[i] = PreTransGetCRInfo(pTHS, &pNextEntInfList->Entinf);
                if(pTHS->errCode){
                    // Uh oh, there was an error in the pre transactional 
                    // crossRef processing.
                    break;
                }
            }

            // Start a transaction that will embody the all object additions
            SYNC_TRANS_WRITE();
            __try {

                if(pTHS->errCode){
                    // Set an error from PreTransGetCRInfo() so just __leave; to
                    // the __finally, where we'll pack up the error to ship.
                    Assert(pNextEntInfList != NULL); // Not critical, but we 
                    // should have a pNextEntInf struct that broke 
                    // PreTransGetCRInfo()
                    __leave;
                }

                if (NULL != pClientCreds) {
                    // Authenticate the credentials blob.  This saves state
                    // information for future impersonation calls on our thread
                    // state.  Must do this before acquiring SAM lock as SAM doesn't
                    // expect/want locks held during authentication.
                    Assert(pNextEntInfList == NULL); // Not really critical, but
                    // we should completely PreTransGetCRInfo() on every object
                    // before we check the Creds are OK.
                    if (err = AuthenticateSecBufferDesc(pClientCreds)) {
                        SetSecError(SE_PROBLEM_INVALID_CREDENTS, err);
                        __leave;
                    }
                }

                for ( pNextEntInfList = pEntInfList, cObjects = 0;
                     NULL != pNextEntInfList;
                     pNextEntInfList = pNextEntInfList->pNextEntInf, cObjects++ ) {

                    pEntInf = &(pNextEntInfList->Entinf);

                    // Add this one object
                    err = ProcessSingleAddEntry(pTHS,
                                hDrs,
                                dwInVersion,
                                pmsgIn,
                                pEntInf,
                                paCRInfo[cObjects],
                                &infoList[cObjects].objGuid,
                                &infoList[cObjects].objSid );

                    if ( err ) {
                        // The thread state error should have been set
                        Assert( 0 != pTHS->errCode );
                        break;
                    }
                }

                // If an error occurred during the addition of the objects, bail now
                if ( err )  {
                    __leave;
                }

            } __finally {

                CLEAN_BEFORE_RETURN(pTHS->errCode);

                RtlZeroMemory( pmsgOut, sizeof( DRS_MSG_ADDENTRYREPLY ) );

                if(err || (pTHS && pTHS->errCode)){
                    
                    // Set the error out parameters
                    DRS_AddEntry_SetErrorData(pmsgOut,
                                     (pNextEntInfList) ? pNextEntInfList->Entinf.pName : NULL,
                                     pTHS, err,   // Error info
                                     *pdwOutVersion);

                } else {
                    
                    // Set the success out parameters
                    if(*pdwOutVersion == 3){
                        // WinXP/Whistler out, version 3
                        Assert(pTHS->errCode == 0);
                        pmsgOut->V3.cObjectsAdded  = cObjects;
                        pmsgOut->V3.infoList = infoList;
                        DRS_AddEntry_SetErrorData(pmsgOut,
                                                  NULL, pTHS, 0,
                                                  *pdwOutVersion);
                        // Assert the return error data was set to success.
                        Assert(pmsgOut->V3.pErrData && pmsgOut->V3.pErrData->V1.dwRepError == 0 && pmsgOut->V3.pErrData->V1.errCode == 0);

                    } else {
                        // Win2k out, version 2
                        Assert(*pdwOutVersion == 2);
                        pmsgOut->V2.cObjectsAdded  = cObjects;
                        pmsgOut->V2.infoList = infoList;
                    } // end if/else (version 3 reply) as oppoesed to version 2

                } // end if/else (error) 

                DPRINT5(1, "err = %u, errCode = %u, dsid = %x, exErr = %u, exData = %u\n",
                        err,
                        pTHS->errCode,
                        GetTHErrorDSID(pTHS),
                        Win32ErrorFromPTHS(pTHS),
                        GetTHErrorExtData(pTHS));

            }

        }__except(GetExceptionData(GetExceptionInformation(), &dwException,
                       &dwEA, &ulErrorCode, &dsid)) {
             HandleDirExceptions(dwException, ulErrorCode, dsid);

             // There should be some kind of error!
             Assert(ulErrorCode || (pTHS && pTHS->errCode)); 
             // Exception, set the error in the out message.
             DRS_AddEntry_SetErrorData(pmsgOut,
                              (pNextEntInfList) ? pNextEntInfList->Entinf.pName : NULL,
                              pTHS, ulErrorCode,  // Error Info.
                              *pdwOutVersion);
        }

        Assert( (*pdwOutVersion == 3) ? pmsgOut->V3.pErrData != NULL : 1 );

        if (NULL != pTHS) {
            LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_RPC_SERVER,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_IDL_DRS_ADD_ENTRY_EXIT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidDrsAddEntry,
                     szInsertUL( ((*pdwOutVersion == 2) ? pmsgOut->V2.cObjectsAdded : pmsgOut->V3.cObjectsAdded) ),
                     szInsertUL(err),
                     NULL, NULL, NULL, NULL, NULL, NULL);
        }


    } __finally {

        DEC(pcThread);      // Perfmon hook
        drsDereferenceContext( hDrs, IDL_DRSADDENTRY );

    }

    // We always return success, any error is in out message.
    return ERROR_SUCCESS;
}


ULONG
IDL_DRSExecuteKCC(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsg
    )
/*++

Routine Description:

    Poke the KCC and tell it to run a given task (e.g., update the replication
    topology).

Arguments:

    hDrs (IN) - DRS context handle returned by a prior call to IDL_DRSBind().

    dwMsgVersion (IN) - Version of the structure (union discriminator) embedded
        in pMsg.

    pMsg (IN) - Message containing the KCC parameters.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    THSTATE *   pTHS = NULL;
    DWORD       ret;

    drsReferenceContext( hDrs, IDL_DRSEXECUTEKCC );
    INC(pcThread);
    __try {
        __try {
            if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
                // Failed to initialize a THSTATE.
                DRA_EXCEPT_NOLOG(DRAERR_OutOfMem, 0);
            }

            Assert(1 == dwMsgVersion);
            LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_RPC_SERVER,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_IDL_DRS_EXECUTE_KCC_ENTRY,
                     EVENT_TRACE_TYPE_START,
                     DsGuidDrsExecuteKcc,
                     szInsertUL(pMsg->V1.dwTaskID),
                     szInsertUL(pMsg->V1.dwFlags),
                     NULL, NULL, NULL, NULL, NULL, NULL);

            if (!IsDraAccessGranted(pTHS, gAnchor.pConfigDN,
                        &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
                // No right to perform this operation.
                DRA_EXCEPT_NOLOG(ret, 0);
            }

            ret = KccExecuteTask(dwMsgVersion, pMsg);
        }__except(GetDraException(GetExceptionInformation(), &ret)) {
            ;
        }

        if (NULL != pTHS) {
            LogAndTraceEvent(TRUE,
                     DS_EVENT_CAT_RPC_SERVER,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_IDL_DRS_EXECUTE_KCC_EXIT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidDrsExecuteKcc,
                     szInsertUL(ret),
                     NULL, NULL, NULL, NULL,
                     NULL, NULL, NULL);
        }
    } __finally {
        DEC(pcThread);
        drsDereferenceContext( hDrs, IDL_DRSEXECUTEKCC );
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drasch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drasch.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines the structures and
    functions to manipulate partial attribute set

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dsconfig.h>                   // defines such as HOURS_IN_SECS

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRASCH:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drancrep.h"
#include "dsaapi.h"
#include "drasch.h"

#include <fileno.h>
#define  FILENO FILENO_DRASCH

// Global pointer to the in-memory deletion list that is being processed currently
// and the critical section that guards access to this list
GCDeletionListProcessed *gpGCDListProcessed = NULL;
CRITICAL_SECTION csGCDListProcessed;

// This is the number purges each time we are scheduled, if more purgest to be done
// we will reschedule ourselves immediately (this is to avoid holding up the taskQ
// for too long and to let other overdue tasks to proceed)
#define MAX_PURGES_PER_TASK_SESSION (20)

// We update the usnLastProcessed marker on the NCHead only infrequently to avoid
// frequent writes to the NCHead.
#define MAX_PURGES_WITHOUT_UPDATING_NCHEAD (200)


// PAS defaults
#define DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE       (32)
#define DEFAULT_PAS_TIME_TOLERANCE                 (2 * HOURS_IN_SECS)  // Seconds.

//
// global variables
//
// (local to this file)
DWORD gPASFailureTolerance = DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE;
DWORD gPASTimeTolerance    = DEFAULT_PAS_TIME_TOLERANCE;

////
// Local prototypes
//
VOID
GC_DbgValidatePASLinks(
    DSNAME*      pNC                  // [in]
    );

VOID
GC_ReadRegistryThresholds( VOID  );

//
// Local Definitions
//
#if DBG
#define DBG_VALIDATE_PAS_LINKS(nc)      GC_DbgValidatePASLinks(nc)
#else
#define DBG_VALIDATE_PAS_LINKS(nc)
#endif


BOOL
GC_IsMemberOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in]
    ATTRTYP                     attid,              // [in]
    OUT DWORD                   *pdwAttidPosition)  // [out, optional]

/*************************************************************************************
Routine Description:

    This routine tells if a given attribute is a member of the given partial attribute
    set.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids)
    attid - attribute id of the attribute to be located in the partial set.
    pdwAttidPosition -  returns the index where the attid is located in the
                        vector;
                        if the given attid is NOT a member of partial set,
                        the appropriate index at which this attribute
                        should be inserted to preserve the sort order is
                        returned.
Return Value:

    TRUE, if the given attribute is a member of the default partial
        attribute set, or in the given partial attribute vec;
    FALSE, otherwise.
**************************************************************************************/
{
    int i,nStart, nEnd, nMid;

    if (!pPartialAttrVec || !pPartialAttrVec->V1.cAttrs)
    {
        // vector is empty or zero-lengthed
        if (pdwAttidPosition)
            *pdwAttidPosition = 0;

        return FALSE;
    }

    // Do a binary search for attid
    nStart = 0;
    nEnd = (int) pPartialAttrVec->V1.cAttrs - 1;

    do
    {
        nMid = (nStart + nEnd) /2;

        if (pPartialAttrVec->V1.rgPartialAttr[nMid] < attid)
        {
            // no need to search the lower portion of the array
            nStart = nMid + 1;
        }
        else if (pPartialAttrVec->V1.rgPartialAttr[nMid] > attid)
        {
            // no need to search the upper portion of the array
            nEnd = nMid - 1;
        }
        else
        {
            // found a match
            if (pdwAttidPosition)
            {
                *pdwAttidPosition = nMid;
            }

            return TRUE;
        }
    }
    while (nStart <= nEnd);

    // we didn't find the attid
    if (pdwAttidPosition)
    {
        // need to fill-up the potential position if this attid were to be inserted
        *pdwAttidPosition = (DWORD) nStart;
    }

    return FALSE;
}

BOOL
GC_AddAttributeToPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in, out]
    ATTRTYP                     attid)              // [in]
/*************************************************************************************
Routine Description:

    This routine adds the given attribute to the given partial attribute vector
    at the right place. We assume the caller has already allocated enough space in
    the vector to accommodate the addition.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids and
                        there is enough space to add one more attid)
    attid - attribute id of the attribute to be added to the partial set.

Return Value:

    TRUE, if the given attribute is really added to the partial set;
    FALSE, if we couldn't add or there was no need to add the attribute (i.e. the
            attribute was already part of the given partial set)
**************************************************************************************/
{
    DWORD dwPosition;
    ATTRTYP *pAttr;

    if (!pPartialAttrVec)
    {
        return FALSE;
    }

    if (GC_IsMemberOfPartialSet(pPartialAttrVec, attid, &dwPosition))
    {
        // already a member - no need to add it again
        return FALSE;
    }

    // dwPosition now holds the index for inserting the new attid
    pAttr = & pPartialAttrVec->V1.rgPartialAttr[dwPosition];

    // shift all attributes >= to the given position to the right by 1 position
    // Note:- we assume enough memory is allocated by the caller to shift right
    //          by 1 position
    MoveMemory(pAttr + 1, pAttr,
        sizeof(ATTRTYP) * (pPartialAttrVec->V1.cAttrs - dwPosition));

    // insert the new attid
    *pAttr = attid;

    pPartialAttrVec->V1.cAttrs++;

    return TRUE;
}

BOOL
GC_IsSamePartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec1,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec2)        // [in]
/*************************************************************************************
Routine Description:

    This routine tells if the give two partial sets are same are not.

Arguments:
    pPartialAttrVec1 - pointer to the first partial set
    pPartialAttrVec2 - pointer to the second partial set

Return Value:

    TRUE, if the partial sets are the same;
    FALSE, if they are different.
**************************************************************************************/
{
    if (pPartialAttrVec1 && pPartialAttrVec2 &&
        (pPartialAttrVec1->V1.cAttrs == pPartialAttrVec2->V1.cAttrs) &&
        !memcmp(&pPartialAttrVec1->V1.rgPartialAttr[0],
                &pPartialAttrVec2->V1.rgPartialAttr[0],
                pPartialAttrVec1->V1.cAttrs * sizeof(ATTRTYP)))
    {
        // both partial sets are non-empty and identical
        return TRUE;
    }

    if ((!pPartialAttrVec1 || !pPartialAttrVec1->V1.cAttrs)
        && (!pPartialAttrVec2 || !pPartialAttrVec2->V1.cAttrs))
    {
        // both partial sets are empty - and by definition they are identical
        return TRUE;
    }

    return FALSE;
}


BOOL
GC_GetDiffOfPartialSets(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecOld,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecNew,        // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecAdded,    // [out]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecDeleted)  // [out]
/*************************************************************************************
Routine Description:

    This routine computes the difference between two partial attribute sets.

Arguments:
    pPartialAttrVecOld - pointer to the old partial attribute vector
    pPartialAttrVecNew - pointer to the new partial attribute vector
    ppPartialAttrVecAdded - pointer to receive the set of partial attributes
            that are in the new vector but not in the old; NULL is returned if
            new vector doesn't have any attr that is not present in the old.
            Memory for this has been using THAlloc() and the caller doesn't need
            to explicitly free it.
    ppPartialAttrVecDeleted - pointer to receive the set of partial attributes
            that are in the old vector but not in the new. Again memory for this
            is allocated using THAlloc() and NULL is returned if there are no such
            attributes


Return Value:

    TRUE, if the diff is successfully computed and returned to through the out params
    FALSE, if we couldn't return the diff successfully.
**************************************************************************************/
{
    DWORD i;

    if (!ppPartialAttrVecAdded ||  !ppPartialAttrVecDeleted)
        return FALSE;

    *ppPartialAttrVecAdded = NULL;
    *ppPartialAttrVecDeleted = NULL;

    // compute the additions
    if (pPartialAttrVecNew)
    {
        for (i = 0; i < pPartialAttrVecNew->V1.cAttrs; i++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecOld, pPartialAttrVecNew->V1.rgPartialAttr[i], NULL))
            {
                // this attribute is present only in the new parial set
                if (!*ppPartialAttrVecAdded)
                {
                    // this is the first new attribute detected - allocate space for the
                    // maximum possible new attributes at this stage
                    *ppPartialAttrVecAdded = THAlloc(PartialAttrVecV1SizeFromLen(pPartialAttrVecNew->V1.cAttrs - i));
                    if (!*ppPartialAttrVecAdded)
                        return FALSE;   // unable to alloc memory - can't return the diff successfully.

                    (*ppPartialAttrVecAdded)->dwVersion = VERSION_V1;
                    (*ppPartialAttrVecAdded)->V1.cAttrs = 0;
                }

                // memory is allocated just now or enough memory has been allocated in a previous iteration
                // in any case, we can just add the attribute
                GC_AddAttributeToPartialSet(*ppPartialAttrVecAdded, pPartialAttrVecNew->V1.rgPartialAttr[i]);
            }
        } // end of 1st for loop
    }

    // compute the deletions
    if (pPartialAttrVecOld)
    {
        for (i =0; i < pPartialAttrVecOld->V1.cAttrs; i++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecNew, pPartialAttrVecOld->V1.rgPartialAttr[i], NULL))
            {
                // this attribute is present only in the old partial set
                if (!*ppPartialAttrVecDeleted)
                {
                    // this is the first deleted attribute detected - allocate space for the
                    // maximum possible deleted attributes at this stage
                    *ppPartialAttrVecDeleted = THAlloc(PartialAttrVecV1SizeFromLen(pPartialAttrVecOld->V1.cAttrs - i));
                    if (!*ppPartialAttrVecDeleted)
                        return FALSE; //unable to alloc memory - can't return the diff successfully

                    (*ppPartialAttrVecDeleted)->dwVersion = VERSION_V1;
                    (*ppPartialAttrVecDeleted)->V1.cAttrs = 0;
                }

                // memory is allocated just now or enough memory has been allocated in a previous iteration
                // just add the attribute to deleted set
                GC_AddAttributeToPartialSet(*ppPartialAttrVecDeleted, pPartialAttrVecOld->V1.rgPartialAttr[i]);
            }
        } // end of 2nd for loop
    }

    // successfully computed the difference and returned them through the out params.
    return TRUE;
}

BOOL
GC_IsSubsetOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,           // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecSuper)      // [in]
/*************************************************************************************
Routine Description:

    This routine tells if a partial set is a subset ofmember of the given partial set.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids)
    pPartialAttrVecSuper - pointer to the partial attribute vector that is supposed
                        to be superset

Return Value:

    TRUE, if pPartialAttrVec is a subset of pPartialAttrVecSuper
    FALSE, otherwise.
**************************************************************************************/
{

    if (GC_IsSamePartialSet(pPartialAttrVec, pPartialAttrVecSuper))
    {
        // if they are they same, return TRUE  (given that partial attribute set changes
        // are rare, this would be the typical case)
        return TRUE;
    }

    if (pPartialAttrVec)
    {
        DWORD i;

        for (i = 0; i < pPartialAttrVec->V1.cAttrs; i ++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecSuper, pPartialAttrVec->V1.rgPartialAttr[i], NULL))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL
GC_ReadPartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVec) // [out]
/*************************************************************************************
Routine Description:

    This routine reads and returns the partial attribute set stored in the NCHead
    of the given NC. Assume we already have an open read transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    ppPartialAttrVec - pointer to receive the partial attribute vector;
                        memory allocated from thread memory; will contain NULL
                        if there is no partial attribute vector
                        Caller can free the allocated memory with THFree() or it will
                        be automatically free as part of thread cleanup.

Return Value:

    TRUE, if pPartialAttrVec is successfully read
    FALSE, otherwise.
**************************************************************************************/
{
    THSTATE * pTHS = pTHStls;
    DWORD cb;
    DWORD retErr;

    *ppPartialAttrVec = NULL;

    if (DRAERR_Success == FindNC(pTHS->pDB, pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC, NULL))
    {
        // NC found successfully
        if (!(retErr = DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_SET,
                                0, 0, &cb, (LPBYTE *) ppPartialAttrVec))
                                || (DB_ERR_NO_VALUE == retErr))
        {
            // either we got the value or no value exists
            // both means the read was successful
            if (*ppPartialAttrVec)
            {
                VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(*ppPartialAttrVec);
            }

            return TRUE;
        }
    }
    else
    {
        // FindNC() failed -- this NC must be a subref, and therefore has no
        // partial set.
        return TRUE;
    }

    // unable to read the attribute set
    return FALSE;
}

VOID
GC_WritePartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec)   // [in]
/*************************************************************************************
Routine Description:

    This routine writes the given partial attribute set on the NCHead
    of the given NC. Assume we already have an open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    pPartialAttrVec - pointer to the partial attribute vector to be written

Return Value:
    None. Exception raised on error.
**************************************************************************************/
{
    DWORD retErr = 0;
    THSTATE *pTHS = pTHStls;

    // set currency on the NC
    if (retErr = DBFindDSName(pTHS->pDB, pNC))
    {
        // Tolerate the NC still being a phantom. This can occur when
        // DRA_ReplicaAdd/Sync fails to bring in the NC head because of a
        // sync failure.
        if (retErr == DIRERR_NOT_AN_OBJECT) {
            return;
        }
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }

    if (pPartialAttrVec)
    {
        VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(pPartialAttrVec);

        // write the given set on the NC
        if (retErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_SET,
                        PartialAttrVecV1Size(pPartialAttrVec), pPartialAttrVec))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }
    else
    {
        // remove the current set
        retErr = DBRemAtt(pTHS->pDB, ATT_PARTIAL_ATTRIBUTE_SET);
        if ( (retErr != DB_success) && (retErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) )
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    // Update the object, but mark it not to wake up ds_waits
    if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                    NULL, META_STANDARD_PROCESSING))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }
}

VOID
GC_TriggerSyncFromScratchOnAllLinks(
    DSNAME                      *pNC)               // [in]
/*************************************************************************************
Routine Description:

    This routine triggers sync from scratch from all replication links
    by resetting the watermarks on all replica links and nuking the UtoD vector.
    Assumes an Open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC that should be triggered for sync from scratch

Return Value:
    None; Exception raised on error.
**************************************************************************************/
{
    DWORD           retErr = DRAERR_Success;
    DWORD           dbErr = DB_success;
    THSTATE         *pTHS = pTHStls;
    REPLICA_LINK    *pLink = NULL;
    DWORD           cbAllocated = 0;
    DWORD           cbReturned = 0;
    ATTCACHE        *pAC = NULL;
    DWORD           i;

    retErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL);

    if (DRAERR_Success == retErr)
    {
        // currency is on the NC Head

        // Nuke UtoD vector
        dbErr = DBRemAtt(pTHS->pDB, ATT_REPL_UPTODATE_VECTOR);
        if (dbErr) {
            if (dbErr == DB_ERR_ATTRIBUTE_DOESNT_EXIST) {
                dbErr = DB_success;
            }
            else {
                // remove attribute failed
                DRA_EXCEPT(DRAERR_InternalError, dbErr);

            }
        }

        pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
        if (NULL == pAC)
        {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ATT_REPS_FROM);
        }

        // reset watermarks on all replica links of this NC
        for (i = 1; (DB_success == dbErr); i++)
        {
            dbErr = DBGetAttVal_AC(pTHS->pDB, i, pAC,
                                DBGETATTVAL_fREALLOC, cbAllocated,
                                &cbReturned, (PBYTE *) &pLink);

            if ((DB_success != dbErr) && (DB_ERR_NO_VALUE != dbErr))
            {
                // hit some unexpected error
                DRA_EXCEPT(DRAERR_DBError, dbErr);
            }


            if (DB_success == dbErr)
            {
                VALIDATE_REPLICA_LINK_VERSION(pLink);

                Assert(pLink->V1.cb == cbReturned);

                cbAllocated = max(cbAllocated, cbReturned);
                pLink = FixupRepsFrom(pLink, &cbAllocated);

                // fixup could realloc larger buffer
                Assert(cbAllocated >= pLink->V1.cb);

                // sanity checks
                Assert(pLink->V1.cbOtherDra == MTX_TSIZE(RL_POTHERDRA(pLink)));

                // reset watermark on this replica link and rewrite
                pLink->V1.usnvec = gusnvecFromScratch;
                pLink->V1.ulReplicaFlags |= DRS_NEVER_SYNCED;
                dbErr = DBReplaceAttVal_AC(pTHS->pDB, i, pAC,
                                           pLink->V1.cb, pLink);

                // Log so the admin knows what's going on.
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_PARTIAL_ATTR_ADD_FULL_SYNC,
                         szInsertDN(pNC),
                         szInsertMTX(RL_POTHERDRA(pLink)),
                         NULL );
            }
        }

        if (DB_ERR_NO_VALUE == dbErr)
        {
            // Update the object, but mark it not to wake up ds_waits
            if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                                    NULL, META_STANDARD_PROCESSING))
            {
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }

            // we successfully nuked the UtoD vector and reset water marks on all replica links
        }
        else
        {
            // above for loop terminated with an unexpected error code (only way
            // we will be here is if DBReplaceAttVal_AC() failed above).
            DRA_EXCEPT(DRAERR_DBError, dbErr);
        }

    }
}

BOOL
GC_ReadGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              **ppGCDList)        // [out]
/*************************************************************************************
Routine Description:

    This routine reads and returns the GCDeletionList stored in the NCHead
    of the given NC. Assume we already have an open read transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    ppGCDList - pointer to receive the GCDeletionList;
                        memory allocated from thread memory; will contain NULL
                        if there is no GCDeletion list on the NCHead
                        Caller can free the allocated memory with THFree() or it will
                        be automatically free as part of thread cleanup.

Return Value:

    TRUE, if GCDeletionList is successfully read
    FALSE, otherwise.
**************************************************************************************/
{
    THSTATE * pTHS = pTHStls;
    DWORD cb;
    DWORD retErr;

    *ppGCDList = NULL;

    if (DRAERR_Success == FindNC(pTHS->pDB, pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC, NULL))
    {
        // NC found successfully
        if (!(retErr = DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                                0, 0, &cb, (LPBYTE *) ppGCDList))
                                || (DB_ERR_NO_VALUE == retErr))
        {
            // either we got the value or no value exists
            // both means the read was successful
            if (*ppGCDList)
            {
                VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&(*ppGCDList)->PartialAttrVecDel)
            }

            return TRUE;
        }
    }
    else
    {
        // FindNC() failed -- this NC must be a subref, and therefore has no
        // deletion list.
        return TRUE;
    }

    // unable to read the DeletionList set
    return FALSE;
}

VOID
GC_WriteGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              *pGCDList)          // [in]
/*************************************************************************************
Routine Description:

    This routine writes the given GCDeletionList set on the NCHead
    of the given NC.
    if pGCDList is NULL, it removes the deletion list from the NCHead.

    Assume we already have an open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    pGCDList - pointer to the Deletin List to be written; if pGCDList is NULL,
                we would remove the attr from the object.

Return Value:
    None; Raises exception on error.
**************************************************************************************/
{
    DWORD retErr = 0;
    THSTATE *pTHS = pTHStls;

    // set currency on the NC
    if (retErr = DBFindDSName(pTHS->pDB, pNC))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }

    if (pGCDList)
    {
        VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&pGCDList->PartialAttrVecDel);

        // write the given deletion list on the NC
        if (retErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                        GCDeletionListSize(pGCDList), pGCDList))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }
    else
    {
        // remove the current deletion list
        retErr = DBRemAtt(pTHS->pDB, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST);
        if ( (retErr != DB_success) && (retErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) )
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    // Update the object, but mark it not to wake up ds_waits
    if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                            NULL, META_STANDARD_PROCESSING))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }
}


BOOL
GC_GetGCDListToProcess(
    DSNAME **ppNC,                  // [out]
    GCDeletionList **ppGCDList)     // [out]
/*************************************************************************************
Routine Description:

    This routine walks through the values of hasPartialReplicaNCs on the local
    msft-dsa object and finds the first NC in the list that has a non-empty
    GCDeletionList. If one such partial replica NC is found the DSNAME and GCDeletionList
    are return through the out parameters (allocation in thread memory).

    Assumes a open read transaction.


Arguments:
    ppNC - pointer to the DSName to receive dsname of partial replica nc head that has
            a non-empty GCDeletionList. NULL, if there are no partial replica NCs with
            non-empty GCDeletionList.
    ppGCDList - pointer to receive the corresponding GCDeletionList.

Return Value:
    TRUE, if a partial replica NC with non-empty deletion list is found;
    FALSE, if no such NC found.
**************************************************************************************/
{
    THSTATE *pTHS = pTHStls;
    ULONG ulRet;
    ULONG len;
    DBPOS *pDBDSAObj;
    ULONG bufSize = 0;
    BOOL  fRet = FALSE;

    *ppNC = NULL;
    *ppGCDList = NULL;

    // have a separate DBPOS to iterate through the values on the local msft-dsa so that
    // we can avoid switching currencies back-and-forth between msft-dsa object and NC Heads
    DBOpen(&pDBDSAObj);

    __try
    {
        // Find the local msft-dsa object
        if (ulRet = DBFindDSName(pDBDSAObj, gAnchor.pDSADN))
        {
            DRA_EXCEPT(DRAERR_InternalError, ulRet);
        }

        if (DBHasValues(pDBDSAObj, ATT_HAS_PARTIAL_REPLICA_NCS))
        {
            ULONG i = 1;

            // the dsa has partial replicas - iterate through the NC names and check their
            // deletion lists
            while (!fRet && !DBGetAttVal(pDBDSAObj, i++, ATT_HAS_PARTIAL_REPLICA_NCS,
                                DBGETATTVAL_fREALLOC, bufSize, &len, (PBYTE *) ppNC))
            {
                bufSize = max(bufSize, len);

                if (ulRet = DBFindDSName(pTHS->pDB, *ppNC))
                {
                    DRA_EXCEPT(DRAERR_InternalError, ulRet);
                }

                // pTHS->pDB currency is on the NCHead
                if (!DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                            DBGETATTVAL_fREALLOC, 0, &len, (PBYTE *) ppGCDList))
                {
                    // found a partial replica NC with a non-empty deletion list
                    // *ppGCDList and *ppNC are already pointing to the correct stuff
                    // to be returned

                    VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&(*ppGCDList)->PartialAttrVecDel);

                    fRet = TRUE;
                }
            }
        }
    }
    __finally
    {
        DBClose(pDBDSAObj, fRet || !AbnormalTermination());
    }

    if (!fRet && (*ppNC))
    {
        // No partial replica NC with non-empty deletion list available
        THFreeEx(pTHS, *ppNC);
        *ppNC = NULL;
    }

    return fRet;
}

BOOL
GC_ReinitializeGCDListProcessed(
    BOOL fCompletedPrevious,     // [in]
    BOOL *pfMorePurging)         // [out]
/*************************************************************************************
Routine Description:

    This routine updates the in-memory global GCDListProcessed pointer with appropriate
    values so that the purge task can proceed. If the
    GDListProcessed pointer was pointing a valid NC/Deletion list pair, it removes the
    DeletionList from this previous NC which is already processed if fCompletedPrevious
    flag is set to TRUE.

Arguments:
    fCompletedCurrent - tells if the processing of the previous NC's deletion list is
                            completed.
    pfMorePurging - if non-NULL it would receive the a TRUE if there is a Deletion List
                            to process at the end of reinitialization;

Return Value:
    TRUE, if successfully updated;
    FALSE, if there was an error.
**************************************************************************************/
{
    DSNAME *pNC;
    GCDeletionList *pGCDList;
    BOOL fRet = FALSE;

    if (pfMorePurging)
        *pfMorePurging = FALSE; // assume no more purging by default

    EnterCriticalSection(&csGCDListProcessed);

    __try
    {
        if (!gpGCDListProcessed)
        {
            // this will be done only when the UpdateGCDListProcessed() is called for the
            // first time.
            gpGCDListProcessed = (GCDeletionListProcessed *) malloc(sizeof(GCDeletionListProcessed));
            if (!gpGCDListProcessed)
            {
                __leave; // memory allocation failed
            }

            gpGCDListProcessed->pNC = NULL;
            gpGCDListProcessed->pGCDList = NULL;
        }

        if (gpGCDListProcessed->pNC)
        {
            // cleanup the contents of old list and update the NCHead whose purging is
            // already completed
            if (fCompletedPrevious)
            {
                GC_WriteGCDeletionList(gpGCDListProcessed->pNC, NULL);
            }

            free(gpGCDListProcessed->pNC);
            gpGCDListProcessed->pNC = NULL;

            if (gpGCDListProcessed->pGCDList)
            {
                free(gpGCDListProcessed->pGCDList);
                gpGCDListProcessed->pGCDList = NULL;
            }

        }


        // reset the purgeCount & reload flag
        gpGCDListProcessed->purgeCount = 0;
        gpGCDListProcessed->fReload = FALSE;
        gpGCDListProcessed->fNCHeadPurged = FALSE;

        if (GC_GetGCDListToProcess(&pNC, &pGCDList))
        {
            // got a deletion list to process - returned values are in thread memory
            // make a permanent copy
            gpGCDListProcessed->pNC = (DSNAME *) malloc(DSNameSizeFromLen(pNC->NameLen));
            if (!gpGCDListProcessed->pNC)
            {
                __leave;   // memory allocation failed
            }

            memcpy(gpGCDListProcessed->pNC, pNC, DSNameSizeFromLen(pNC->NameLen));

            gpGCDListProcessed->pGCDList = (GCDeletionList *) malloc(GCDeletionListSize(pGCDList));
            if (!gpGCDListProcessed->pGCDList)
            {
                // memory allocation failed
                free(gpGCDListProcessed->pNC);
                gpGCDListProcessed->pNC = NULL;
                __leave;
            }

            memcpy(gpGCDListProcessed->pGCDList, pGCDList, GCDeletionListSize(pGCDList));

            if (pfMorePurging)
                *pfMorePurging = TRUE;

            // No need keep around the thread-allocated memory
            THFree(pNC);
            THFree(pGCDList);
        }

        fRet = TRUE;
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    return fRet;
}

BOOL
GC_UpdateLastUsnProcessedAndPurgeCount(
    USN     usnLastProcessed,       // [in]
    ULONG   cPurged)                // [in]
/*************************************************************************************
Routine Description:

    This routine usnLastProcessed marker & purgeCount on the global in-memory GCDListProcessed.
    It also updates the copy on the NC Head if MAX_PURGES_WITHOUT_UPDATING_NCHEAD
    limit is hit.

Arguments:
    usnLastProcessed - create usn of the object that was last processed
    cPurged - number of objects purged since the last time this function was called

Return Value:
    None.
**************************************************************************************/
{
    BOOL fRet = FALSE;

    EnterCriticalSection(&csGCDListProcessed);

    __try
    {
        if (cPurged > 0)
        {
            // NCHead is the first thing to get purged - and we have a
            // positive purge count
            gpGCDListProcessed->fNCHeadPurged = TRUE;
        }

        gpGCDListProcessed->purgeCount += cPurged;
        gpGCDListProcessed->pGCDList->usnLastProcessed = usnLastProcessed;

        if (!(gpGCDListProcessed->purgeCount % MAX_PURGES_WITHOUT_UPDATING_NCHEAD))
        {
            // time to update the copy on the NC Head
            GC_WriteGCDeletionList(gpGCDListProcessed->pNC, gpGCDListProcessed->pGCDList);
        }

        fRet = TRUE;
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    return fRet;
}

VOID
PurgePartialReplica(
    void * pv,                  // [in]
    void ** ppvNext,            // [out]
    DWORD * pcSecsUntilNextIteration ) // [out]
/*************************************************************************************
Routine Description:

    This routine is called by the taskq to purge attributes deleted from partial set.

Arguments:
    pv - parameter passed
    ppvNext - parameter to be passed for the next instance of this task
    pTimeNext - time when this function should be invoked again.

Return Value:
    None.
**************************************************************************************/
{
    THSTATE         *pTHS = pTHStls;
    USN             usnLast;
    USN             usnHighestToBeProcessed;
    DSNAME          *pNC = NULL;
    ULONG           cb;
    ULONG           cPurged = 0;
    ULONG           dntNC;
    ULONG           retErr = 0;
    BOOL            fDone = FALSE;
    BOOL            fReload = FALSE;
    BOOL            fMorePurging = FALSE;
    BOOL            fNCHeadPurged;
    PARTIAL_ATTR_VECTOR *pvecDel = NULL;
    ULONG i;
    BOOL            fDRASave;

    Assert(ppvNext);
    Assert(pcSecsUntilNextIteration);

    *ppvNext = NULL;

    // Check to see if the in-memory struct has anything to purge
    EnterCriticalSection(&csGCDListProcessed);
    __try
    {
        BeginDraTransaction(SYNC_WRITE);
        __try
        {
            if (!gpGCDListProcessed              // gloabl-struct not built yet
                || !gpGCDListProcessed->pNC      // no pending stuff to process, should confirm w/ NCHeads
                || gpGCDListProcessed->fReload)  // currently processed deletion list has changed and we are asked to reload
            {
                // in-memory deletion list is empty or someone explicitly asked us to reload
                if (!GC_ReinitializeGCDListProcessed(FALSE, NULL))
                {
                    // unable to reinitialize
                    DRA_EXCEPT(DRAERR_InternalError, 0);
                }
            }

            if (gpGCDListProcessed->pNC)
            {
                // have purging to do
                fNCHeadPurged = gpGCDListProcessed->fNCHeadPurged;
                usnLast = gpGCDListProcessed->pGCDList->usnLastProcessed;  
                cb = PartialAttrVecV1SizeFromLen(gpGCDListProcessed->pGCDList->PartialAttrVecDel.V1.cAttrs);
                pvecDel = (PARTIAL_ATTR_VECTOR *) THAllocEx(pTHS, cb);
                memcpy(pvecDel, &gpGCDListProcessed->pGCDList->PartialAttrVecDel, cb);

                // Make a copy of the pNC from the gloabl deletion list
                cb = DSNameSizeFromLen(gpGCDListProcessed->pNC->NameLen);
                pNC = (DSNAME *) THAllocEx(pTHS, cb);
                memcpy(pNC, gpGCDListProcessed->pNC, cb);
            }

        }
        __finally
        {
            EndDraTransaction(!AbnormalTermination());
        }
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    if (!pvecDel || !pNC)
    {
        // nothing to process now - recheck later (this should be the case 99% of the times)
        // by default set timer for next check
        *pcSecsUntilNextIteration = PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS;

        return;
    }

    // If we are here we have things to purge - begin a transaction
    // set ourselves to be the repl thread (to bypass security)
    fDRASave = pTHS->fDRA;
    pTHS->fDRA = TRUE;
    BeginDraTransaction(SYNC_WRITE);
    __try
    {
        // set currency on the NC Head
        if (retErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                            NULL)) {
            DRA_EXCEPT_NOLOG(DRAERR_BadDN, retErr);
        }

        // Save the DNT of the NC Head
        dntNC = pTHS->pDB->DNT;

        // reset retErr so that we know if we should commit or rollback during the iteration
        retErr = 0;

        // iterate through and start purging
        while ((cPurged < MAX_PURGES_PER_TASK_SESSION) && !fDone)
        {
            // don't hold transaction for long - do a lazy commit (NCHead holds a reasonably
            // recent status on usnLastProcessed, so even if the system crashes before the
            // lazy commit gets to flush things out to the disk we will restart iterations
            // reasonably closer to where we left it)
            DBTransOut(pTHS->pDB, TRUE, TRUE);
            DBTransIn(pTHS->pDB);

            if (!fNCHeadPurged)
            {
                // NC Head is not purged yet, NCDNT of the NCHead
                // will have the DNT of its parents NC's NCHead (if instantiated).
                // => we won't find it in the indexed search below, so process it
                // as a special case
                if (retErr = DBFindDNT(pTHS->pDB, dntNC))
                {
                    DRA_EXCEPT(DRAERR_DBError, retErr);
                }

                // GC_UpdateLastUsnProcessedAndPurgeCount() will take care of
                // setting fNCHeadPurged to TRUE in the global struct for future
                // task sessions. Set the local BOOL to take care of iterations
                // in this task session.
                fNCHeadPurged = TRUE;
            }
            else if (GetNextObjByUsn(pTHS->pDB, dntNC, usnLast + 1,
				     NULL))
            {
                // no more objects - done purging this NC
                fDone = TRUE;
            }
            else
            {
		SYNTAX_INTEGER it;
		// got to the object through indexed search
                // get it's usnChanged for using in the next iteration.
                if (retErr = DBGetSingleValue(pTHS->pDB, ATT_USN_CHANGED, &usnLast,
                    sizeof(usnLast), NULL))
                {
                    DRA_EXCEPT(DRAERR_DBError, retErr);
                }
		// If this is the head of a subordinate NC, skip it. 
		GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it,
				  sizeof(it));
		if (it & IT_NC_HEAD) {
		    // Is the head of a subordinate NC -- move on to the
		    // next object.
		    continue;
                }
            }

            if (!fDone)
            {  
                // positioned on the object to be purged
                // Loop through all attrs to be removed and remove them from the object
                // Set thread state appropriately so that DBTouchMetaData() will remove
                // the meta data for this cleanup
                pTHS->fGCLocalCleanup = TRUE;

                for (i = 0; i < pvecDel->V1.cAttrs; i++)
                {
                    retErr = DBRemAtt(pTHS->pDB, pvecDel->V1.rgPartialAttr[i]);  
                    if (retErr) {
                        if (retErr == DB_ERR_ATTRIBUTE_DOESNT_EXIST) {
                            retErr = DB_success;
                        }
                        else {
                            DRA_EXCEPT(DRAERR_DBError, retErr);
                        }
		    }
		}

                DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);

                pTHS->fGCLocalCleanup = FALSE;

                cPurged++;

                // Check to see if the last modification should be committed or rolledback
                EnterCriticalSection(&csGCDListProcessed);
                if (gpGCDListProcessed->fReload)
                {
                    // the in-memory deletion list has been updated while we were
                    // purging the object in this iteration - shouldn't rollback the last purging
                    fReload = TRUE;
                }
                LeaveCriticalSection(&csGCDListProcessed);

                if (fReload)
                {
                    // go to the finally block and rollback the last purge & reschedule immediately
                    fMorePurging = TRUE;
                    __leave;
                }

            }

        } // while()

        if (!fDone)
        {
            // more purging to be done
            // write back the usn marker and purge count
            if (!GC_UpdateLastUsnProcessedAndPurgeCount(usnLast, cPurged))
            {
                // unable to update - raise exception
                retErr = DB_ERR_DATABASE_ERROR;
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }

            // schedule ourselves to run as soon as possible; this would give taskQ a
            // chance to run other tasks that are overdue. Be a good taskQ citizen!
            fMorePurging = TRUE;
        }
        else
        {
            // we are done purging this NC
            if (!GC_ReinitializeGCDListProcessed(TRUE, &fMorePurging))
            {
                // unable to re-initialize - except
                retErr = DB_ERR_DATABASE_ERROR;
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }
        }
    }
    __finally
    {
        // commit if there are no errors and no reloads
        EndDraTransaction(!(retErr || fReload || AbnormalTermination()));
        pTHS->fDRA = fDRASave;

        // if more purging to be done schedule ourselves immediately
        // otherwise, schedule for the next purge check interval

        *pcSecsUntilNextIteration = fMorePurging
                                    ? 0
                                    : PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS;
    }
}



PARTIAL_ATTR_VECTOR     *
GC_RemoveOverlappedAttrs(
    PARTIAL_ATTR_VECTOR     *pAttrVec1,              // [in, out]
    PARTIAL_ATTR_VECTOR     *pAttrVec2,              // [in]
    BOOL                    *pfRemovedOverlaps)      // [out]
/*************************************************************************************
Routine Description:

    This routine removes any attribute in pAttrVec2 from the given pAttrVec1.

Note:
    Similar to string processing convention-- remove all items in param1 that exist
    in param2, return result & a flag if changes occured.

Arguments:
    pAttrVec1 - points to vector that should be updated
    pAttrVec2 - points to vector containing attrs we want to remove from the deletion
                list.
    pfRemovedOverlaps - pointer to a BOOL that would receive TRUE if there was really
                a overlap and at least one attr was removed from the deletion list

Return Value:
    pointer to the updated vector, or NULL if all attrs are removed from the vector
**************************************************************************************/
{
    ULONG i;
    ULONG iLocated;
    ATTRTYP *pAttr;

    *pfRemovedOverlaps = FALSE;     // assume no removal by default

    for (i = 0;
         0 != pAttrVec1->V1.cAttrs &&           // while there's still attrs in the dest vector
         i < pAttrVec2->V1.cAttrs;              // & we haven't consumed all attrs in the list of removables
         i++)
    {
        if (GC_IsMemberOfPartialSet(pAttrVec1, pAttrVec2->V1.rgPartialAttr[i], &iLocated))
        {
            if (iLocated != (pAttrVec1->V1.cAttrs - 1))
            {
                // element to be removed is not the last one
                // - left shift all attrs to the right of iLocated by 1 position
                pAttr = &(pAttrVec1->V1.rgPartialAttr[iLocated]);

                MoveMemory(pAttr, pAttr + 1,
                    sizeof(ATTRTYP) * ((pAttrVec1->V1.cAttrs - 1) - iLocated));
            }

            pAttrVec1->V1.cAttrs--;

            *pfRemovedOverlaps = TRUE;
        }
    }

    return (pAttrVec1->V1.cAttrs ? pAttrVec1 : NULL);
}


GCDeletionList *
GC_AddMoreAttrs(
    GCDeletionList           *pGCDList,             // [in]
    PARTIAL_ATTR_VECTOR     *pAttrVec)              // [in]
/*************************************************************************************
Routine Description:

    This routine adds the attrs in the given vector to the deletion list, and returns
    pointer to the new deletion list
    Memory for the new deletion list is allocated from thread-memory, and THFree()
    should be used to free it, or it will automatically be deleted when thread heap
    is freed.

Arguments:
    pGCDList - points to DeletionList that should be updated
    pAttrVec - points to vector containing attrs we want to add.

Return Value:
    pointer to the new deletion list, or NULL if couldn't allocate memory
**************************************************************************************/
{
    ULONG           cbNew;
    GCDeletionList  *pGCDListNew = NULL;
    ULONG           i;
    ULONG           cAttrs;

    // Sanity assert If there is no vector of attrs to add, we shouldn't have
    // been inside this function at all.
    Assert(pAttrVec);

    // Calculate the total possible attrs in the new deletion list
    cAttrs = pAttrVec->V1.cAttrs;
    if (pGCDList)
    {
        cAttrs += pGCDList->PartialAttrVecDel.V1.cAttrs;
    }

    cbNew = GCDeletionListSizeFromLen(cAttrs);

    pGCDListNew = (GCDeletionList *) THAlloc(cbNew);

    if (pGCDListNew)
    {
        if (pGCDList)
        {
            // copy the existing deletion list first
            memcpy(pGCDListNew, pGCDList, GCDeletionListSize(pGCDList));
        }
        else
        {
            // there is no existing deletion list - start with zero attrs in the new deletion list
            pGCDListNew->PartialAttrVecDel.dwVersion = VERSION_V1;
            pGCDListNew->PartialAttrVecDel.V1.cAttrs = 0;
        }

        for (i = 0; i < pAttrVec->V1.cAttrs; i++)
        {
            GC_AddAttributeToPartialSet(&pGCDListNew->PartialAttrVecDel, pAttrVec->V1.rgPartialAttr[i]);
        }

        // we have added new attrs to the deletion list - so purging process should restart from
        // scratch - update the usnLastProcessed also
        pGCDListNew->usnLastProcessed = USN_START - 1;
    }

    return pGCDListNew;
}


PARTIAL_ATTR_VECTOR*
GC_ExtendPartialAttributeSet(
    THSTATE                     *pTHS,                       // [in]
    PARTIAL_ATTR_VECTOR         *poldPAS,                    // [in, out]
    PARTIAL_ATTR_VECTOR         *paddedPAS )                 // [in]
/*++

Routine Description:

    Extends poldPAS to contain attributes in paddedPAS & return it.


Arguments:
    poldPAS -- old PAS to extend
    paddedPAS -- added attributes

Return Value:

    Success: new PAS ptr
    Error: NULL

Remarks:
None.


--*/

{
    SIZE_T cbNew;
    PARTIAL_ATTR_VECTOR         *pnewPAS;
    UINT                         i;

    // must either have old, or new
    if (poldPAS && (!paddedPAS || 0 == paddedPAS->V1.cAttrs) ) {
        // Only poldPAS--> return old
        return poldPAS;
    } else if ( !poldPAS && (paddedPAS && 0 != paddedPAS->V1.cAttrs) ) {
        // only new PAS--> return added
        return paddedPAS;
    } else if ( !poldPAS && (!paddedPAS || (paddedPAS &&  0 == paddedPAS->V1.cAttrs)) ){
        Assert(poldPAS || (paddedPAS && paddedPAS->V1.cAttrs) );
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    //
    // re-alloc & extend
    //

    cbNew = PartialAttrVecV1SizeFromLen(poldPAS->V1.cAttrs +
                                        paddedPAS->V1.cAttrs);
    pnewPAS = (PARTIAL_ATTR_VECTOR*)THReAllocEx(
                                        pTHS,
                                        (PVOID)poldPAS,
                                        (ULONG)cbNew);
    if (!pnewPAS) {
        DRA_EXCEPT(DRAERR_OutOfMem, 0);
    }

    // add in sorted order.
    for (i=0; i<paddedPAS->V1.cAttrs; i++) {
        GC_AddAttributeToPartialSet(pnewPAS, paddedPAS->V1.rgPartialAttr[i]);
    }

    return pnewPAS;
}



PARTIAL_ATTR_VECTOR*
GC_CombinePartialAttributeSet(
    THSTATE                     *pTHS,                     // [in]
    PARTIAL_ATTR_VECTOR         *pPAS1,                    // [in]
    PARTIAL_ATTR_VECTOR         *pPAS2 )                   // [in]
/*++

Routine Description:

    allocates mem & return pPAS1+pPAS2

Arguments:
    pPAS1 -- partial attribute set 1
    pPAS2 -- partial attribute set 2

Return Value:

    combined partial attribute set
    NULL if both are empty




Remarks:
None.


--*/
{

    PARTIAL_ATTR_VECTOR     *pPAS;
    DWORD                   cbPAS;
    UINT                    i;

    if (!pPAS1 && !pPAS2) {
        // we know of no condition that can have both NULL
        Assert(pPAS1 || pPAS2);
        return NULL;
    }
    else if (!pPAS1) {
        // return a copy of pas2
        cbPAS = PartialAttrVecV1Size(pPAS2);
        pPAS = THAllocEx(pTHS, cbPAS);
        CopyMemory(pPAS, pPAS2, cbPAS);
    }
    else if (!pPAS2) {
        // return a copy of pas1
        cbPAS = PartialAttrVecV1Size(pPAS1);
        pPAS = THAllocEx(pTHS, cbPAS);
        CopyMemory(pPAS, pPAS1, cbPAS);
    }
    else {
        // combine both & return a copy of the sum.
         cbPAS = PartialAttrVecV1SizeFromLen(pPAS1->V1.cAttrs + pPAS2->V1.cAttrs);
         pPAS = THAllocEx(pTHS, cbPAS);
         // copy first
         CopyMemory(pPAS, pPAS1, PartialAttrVecV1Size(pPAS1));
         Assert(pPAS->V1.cAttrs == pPAS1->V1.cAttrs);
         // append second in sorted order.
         for (i=0; i<pPAS2->V1.cAttrs; i++) {
             GC_AddAttributeToPartialSet(pPAS, pPAS2->V1.rgPartialAttr[i]);
         }
    }
    return pPAS;
}





VOID
GC_ProcessPartialAttributeSetChanges(
    THSTATE     *pTHS,               // [in]
    DSNAME*      pNC,                // [in]
    UUID*        pActiveSource       // [optional, in]
    )
/*************************************************************************************
Routine Description:

    This routine processes all partial attribute set changes - compares the copy in
    the NC Head with one on the schema cache, triggers necessary actions, and updates
    the NC Head copy.

    Assume we enter the function with a WRITE transaction.

    If there is failure, we raise exception which is expected to be handled by the
    caller. In the replication sync case, the exception will be handled by the
    try/except block in ReplicaSync() and replication will be failed. This is the
    correct course of action as we can't allow replication to proceed without
    processing the partial attribute set changes successfully.

Arguments:
    pTHS - current thread state
    pNC - points to the DSName of the NCHead that needs to be processed for partial
                set changes.
    pActiveSource - Replication engine is initiating a cycle from this one at the moement.

Return Value:
    None.
**************************************************************************************/
{

    PARTIAL_ATTR_VECTOR     *pPartialAttrVecNew;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecOld = NULL;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecAdded;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecDeleted;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecCommit;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecTmp;
    GCDeletionList          *pGCDListOld;
    GCDeletionList          *pGCDListNew;
    ULONG                   cb;
    BOOL                    fRemovedOverlaps = FALSE;
    BOOL                    fAddedMore = FALSE;
    ULONG                   retErr = DRAERR_DBError;


    //
    // Get old partial attribute set from NC head.
    //  - Note that w/out it, there's nothing we can do.
    //

    if (!GC_ReadPartialAttributeSet(pNC, &pPartialAttrVecOld))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // is it realy there?
    if ( !pPartialAttrVecOld ) {
        //
        // This NC has just been added now & there is no partialAttrVec on
        // it. Thus, there's nothing to compare for PAS changes. Let
        // DRA_ReplicaAdd finish initial sync first.
        //
        DPRINT1(0, "GC_ProcessPartialAttributeSetChanges: No PAS on partition %ws\n",
                   pNC->StringName);
        return;
    }

    //
    // Ok, it's there, see if there's a discrepancy w/ the schema cache--
    // if so, process changes.
    //
    pPartialAttrVecNew = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->pPartialAttrVec;

    if (GC_IsSamePartialSet(pPartialAttrVecOld, pPartialAttrVecNew))
    {
        // - No changes to process
        return;
    }

    // The partial set has changed - get the difference
    if (!GC_GetDiffOfPartialSets(pPartialAttrVecOld,
                                 pPartialAttrVecNew,
                                 &pPartialAttrVecAdded,
                                 &pPartialAttrVecDeleted))
    {
        // Unable to get the diff - something is wrong
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }


    // First see if we have a deletion list on the NCHead
    if (!GC_ReadGCDeletionList(pNC, &pGCDListOld))
    {
        // unable to read deletion list - error
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    if (!pGCDListOld && pPartialAttrVecDeleted)
    {
        // some attributes have been deleted from the partial attribute set
        // - create a deletion list & put it on the NCHead
        cb = GCDeletionListSizeFromLen(pPartialAttrVecDeleted->V1.cAttrs);
        pGCDListNew = (GCDeletionList *) THAllocEx(pTHS, cb);
        pGCDListNew->usnLastProcessed = USN_START - 1; // start purging from scratch

        memcpy(&pGCDListNew->PartialAttrVecDel,
                pPartialAttrVecDeleted,
                PartialAttrVecV1Size(pPartialAttrVecDeleted));

        GC_WriteGCDeletionList(pNC, pGCDListNew);
    }
    else
    {
        // start with the assumption that the new DeletionList is same as the old DeletionList
        pGCDListNew = pGCDListOld;

        // there is an existing deletion list on the NCHead
        // - we might have to update that deletion list
        if (pPartialAttrVecAdded && pGCDListNew)
        {
            // new attributes have been added - first remove if they appear in the deletion list
            pPartialAttrVecTmp = GC_RemoveOverlappedAttrs(&(pGCDListNew->PartialAttrVecDel), pPartialAttrVecAdded, &fRemovedOverlaps);
            if ( !pPartialAttrVecTmp )
            {
                // nothing's left in deletion list. Null it out.
                pGCDListNew = NULL;
            }
        }

        if (pPartialAttrVecDeleted)
        {
            // some attributes have been deleted
            pGCDListNew = GC_AddMoreAttrs(pGCDListNew, pPartialAttrVecDeleted);

            if (!pGCDListNew)
            {
                // running out of memory - can't finish operation
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }

            fAddedMore = TRUE;
        }

        // if deletion list changed write it back on the NCHead
        if (fRemovedOverlaps || fAddedMore)
        {
            EnterCriticalSection(&csGCDListProcessed);
            __try
            {
                GC_WriteGCDeletionList(pNC, pGCDListNew);

                if (   (NULL != gpGCDListProcessed)
                    && (NULL != gpGCDListProcessed->pNC)
                    && NameMatched(pNC, gpGCDListProcessed->pNC))
                {
                    // This NC is being currently purged and we have changed deletion list,
                    // mark the in-memory struct for reload & repurging of NCHead.
                    gpGCDListProcessed->fReload = TRUE;
                    gpGCDListProcessed->fNCHeadPurged = FALSE;
                }

                // GCDeletion List is successful
                retErr = DRAERR_Success;
            }
            __finally
            {
                DBTransOut(pTHS->pDB, !retErr, TRUE);
                LeaveCriticalSection(&csGCDListProcessed);

                DBTransIn(pTHS->pDB);

                if (retErr != DRAERR_Success)
                {
                    // Hit an exception in the above __try block,
                    // Pass on the exception up to the caller
                    DRA_EXCEPT(retErr, 0);
                }
            }

        }
    }

    //
    // Action:
    //  - write old_PAS minus deleted_PAS
    //  - process added_PAS:
    //     if DRS_SYNC_PAS --> backfill else trigger sync all.
    //
    if ( pPartialAttrVecDeleted )
    {
        // the list to commit now is old_PAS minus deleted_PAS
        pPartialAttrVecCommit = GC_RemoveOverlappedAttrs(pPartialAttrVecOld, pPartialAttrVecDeleted, &fRemovedOverlaps);
        // Write the new partial attr vec on the NCHead
        GC_WritePartialAttributeSet(pNC, pPartialAttrVecCommit);
    }


    // new attributes have been added to partial attribute set
    // Assess & launch PAS replication cycle.
    if (pPartialAttrVecAdded)
    {
        // process & setup for PAS cycle.
        GC_LaunchSyncPAS(
            pTHS,
            pNC,
            pActiveSource,
            pPartialAttrVecAdded);
    }


    // Commit everything upto this point
    DBTransOut(pTHS->pDB, TRUE, FALSE);
    DBTransIn(pTHS->pDB);
}





//
// Efficient PAS replication (see design doc GcPASRepl-New.doc) (PAS-- Partial Attribute Set)
//


void
GC_LaunchSyncPAS (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    UUID*                   pActiveSource,       // [optional, in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS)
/*++

Routine Description:

    This routine is the entry point for testing & launching PAS replication.
    Steps:
        - Process RepsFrom to potentially find & continue an interrupted PAS cycle.
        - If this is a new PAS cycle or an interrupted cycle that indicates a need for
          a fail over to a new source, get & switch to the preferred source.
          Also, in case of failure, test for no compatible sources for launching
          of Win2K procedure.
        - Prepare args & launch DirReplicaSynchronize to queue a PAS pao.

Arguments:
    pTHS -- active Thread state
    pNC -- the active NC we're working on.
    pActiveSource -- if given, replication engine is currently is initiating replication
                     from this source. Thus we don't need to enqueue repl item if PAS cycle
                     is needed.
    pAddedPAS -- the set of attrs, extending the old PAS



Return Value:
    raises exception on invalid state.

Remarks:
    None.


--*/
{

    UUID currUuidDsa;
    UUID *pCurrentDsa = NULL;           // current DSA
    UUID *pPrefDsa = NULL;              // preferred DSA
    ULONG ulErr = DRAERR_Success;
    BOOL fNewSource;                    // identify need for getting a new source
    BOOL fResetUsn = FALSE;             // reset usn upon registration of new active

    // Assert: We must have a valid added PAS vector.
    Assert(pAddedPAS && pAddedPAS->V1.cAttrs);

    DPRINT2(1,"GC_LaunchSyncPAS: setting PAS replication in %ws for %d attributes\n",
              pNC->StringName, pAddedPAS->V1.cAttrs);

    // Read & set global threshold variables (see comment in function header)
    // It's done here in order to minimize consecutive calls into the registry.
    GC_ReadRegistryThresholds();

    //
    // Find current PAS source
    // (by looking at PAS flags on repsfrom)
    //
    currUuidDsa = gNullUuid;
    ulErr = GC_FindValidPASSource(pTHS, pNC, &currUuidDsa);

    if ( DRAERR_BadNC == ulErr ) {
        //
        // This NC has just got added ==> let DRA_ReplicaAdd finish it's
        // operation, there's nothing to process at the moment.
        //
        // Assert: when do we reach this?
        DPRINT1(0, "GC_LaunchSyncPAS: Attempt to launch PAS replication on an bad NC %ws\n",
                pNC->StringName);
        Assert(!"Bad NC in GC_LaunchSyncPAS");
        // but it is recoverable
        return;
    }

    // set convinience ptr
    pCurrentDsa = fNullUuid(&currUuidDsa) ? NULL : &currUuidDsa;


    if ( DRAERR_Success != ulErr ) {
        //
        // Either we had found an interrupted one (re-start again)
        // Or no valid PAS source at all
        // -- try to find a new preferred source.
        // -- If none, revert to win2k full sync.
        //

        // get preferred source
        ulErr = GC_GetPreferredSource(pTHS, pNC, &pPrefDsa );

        if ( ulErr == DRAERR_Success ) {
            //
            // Found new preferred source
            //  - reset usn so as to start traversing objects
            //    on the source from time 0. Note-- this is
            //    the only time we reset usn. For restartable cases
            //    we'll continue from wherever we left.
            //
            fResetUsn = TRUE;
        }
        else if ( ulErr == DRAERR_NoReplica && pCurrentDsa ) {
            //
            // couldn't find better then previously set one--
            // try it again (restart state, no reset of usn).
            //
            pPrefDsa = pCurrentDsa;
        }
        else if ( ulErr ==  ERROR_REVISION_MISMATCH ) {
            //
            // Best one we have is win2k--
            //   do win2k full sync
            //

            GC_TriggerFullSync(pTHS, pNC, pAddedPAS);
            return;
        }
        else {
            //
            // No sources at all (& no previously set one).
            // Try again later, abort now.
            // Note that this could be due to all being stale (bad net connectivity
            // for instance), so we should just retry later.
            //

            // Log debug event
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_GC_NO_SOURCES,
                     szInsertDN(pNC),
                     szInsertInt(ulErr),
                     NULL );


            return;
        }

        //
        // Got new (or re-new'ed) source to use.
        //
        // clean prev (most likely failing) PAS entries & (re)register this one.
        Assert(pPrefDsa);
        (void)GC_RegisterPAS(
                pTHS,
                pNC,
                NULL,
                NULL,
                PAS_RESET,
                FALSE);
        ulErr = GC_RegisterPAS(
                    pTHS,
                    pNC,
                    pPrefDsa,
                    pAddedPAS,
                    PAS_ACTIVE,
                    fResetUsn);
        if ( ulErr ) {
            DRA_EXCEPT(ulErr, 0);
        }
    }
    else {
        //
        // We have a previously good  PAS partner to continue
        //
        pPrefDsa = pCurrentDsa;
    }

    if ( !pActiveSource ||
         (pActiveSource &&
         !DsIsEqualGUID(pPrefDsa, pActiveSource)) ) {

        //
        // Either no active source, or source is diff then the one we prefer to
        // do the PAS dance with. Therefore, queue repl item
        //
        DPRINT(1, "GC_LaunchSyncPAS: adding a PAS item to repl queue\n");
        //
        // We have either an old or a new source to replicate from.
        // Throw another queue item over there. Rely on task queue mgmt
        // to drop dup items.
        //
        ulErr = DirReplicaSynchronize(
                    pNC,
                    NULL,
                    pPrefDsa,
                    DRS_SYNC_PAS | DRS_ASYNC_OP);
        if ( ulErr ) {
            // we should always be able to enqueue this request.
            Assert(!ulErr);
            DRA_EXCEPT(ulErr, 0);
        }
    }
    else{
        // No need to queue item (basically what DirReplicaSynchronize would have done).
        // current replication is using our source, it will get diverted into
        // PAS replication due to us modifying repsFrom repl flags.
        Assert(pActiveSource);
        DPRINT(1, "GC_LaunchSyncPAS: Skipped enqueue of PAS repl item\n");
        // Log debug event
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_GC_SKIP_ENQUEUE,
                 szInsertUUID(pActiveSource),
                 szInsertDN(pNC),
                 NULL );

    }

    // Assert: no failure code paths exist at this point
    Assert(DRAERR_Success == ulErr);
}


ULONG
GC_FindValidPASSource(
    THSTATE*     pTHS,                // [in]
    DSNAME*      pNC,                 // [in]
    UUID*        pUuidDsa             // [optional, out]
    )
/*++

Routine Description:

    Finds a PAS DSA in RepsFrom's sources list.

Arguments:

    pNC: active NC we're working on
    pUuidDsa: the dsa's uuid we had found.

Return Value:

    DRAERR_RefNotFound:
        if dsa wasn't found. *pUuidDsa is set to gNullUuid;

    DRAERR_InternalError:
        if link isn't in consistent state. pUuidDsa is set.

    DRAERR_Success:
        valid entry was found & placed in *pUuidDsa (if avail)


Remarks:

    May raise exception with error in DRAERR error space.

--*/
{

    DWORD           iTag=0;
    UCHAR           *pVal = NULL;
    ULONG           bufsize = 0, len;
    REPLICA_LINK *  pRepsFromRef = NULL;
    BOOL            fFoundSource = FALSE;
    ULONG           ulErr;                  // all paths asign value.

    // sanity on PAS storage consistency (DBG only)
    DBG_VALIDATE_PAS_LINKS(pNC);


    // position on NC
    if (ulErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                       NULL)) {
        DPRINT1(0, "GC_FindValidPASSource: FindNC returned %d\n", ulErr);
        return (ulErr);
    }

    //
    // Find PAS entry in RepsFrom
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);

        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        // note: we preserve pVal for DBGetAttVal realloc above.
        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);


        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS)
        {
            // Got it.
            fFoundSource = TRUE;
            break;
        }
    }

    if (fFoundSource) {
        //
        // See if the source is valid & prepare return values
        //

        // we have a source, return it.

        if ( pUuidDsa ) {
            CopyMemory(pUuidDsa, &pRepsFromRef->V1.uuidDsaObj, sizeof(UUID));;
        }

        // is it in valid state?
        ulErr = GC_ValidatePASLink(pRepsFromRef) ?
                    DRAERR_Success :
                    DRAERR_InternalError;

        // Log debug event
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_EXTENSIVE,
                 ulErr ?
                    DIRLOG_GC_FOUND_INVALID_PAS_SOURCE :
                    DIRLOG_GC_FOUND_PAS_SOURCE,
                 szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                 szInsertDN(pNC),
                 NULL );
    }
    else {
        // set return to not found
        if ( pUuidDsa ) {
            *pUuidDsa = gNullUuid;
        }
        ulErr = DRAERR_RefNotFound;

        // Log debug event
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_GC_PAS_SOURCE_NOT_FOUND,
                 szInsertDN(pNC),
                 NULL,
                 NULL );
    }

    THFreeEx(pTHS, pVal);

    return ulErr;
}


BOOL
GC_ValidatePASLink(
    REPLICA_LINK *  pPASLink          // [in]
    )
/*++

Routine Description :

    Tests the validity of a given replica link for PAS replication

Arguments:

    pPASLink: The link to validate


Return Value:

    TRUE: this link is good
    FALSE: it isn't, will require to revert to another source.



Remarks:
    Note that this function assumes that the link evaluated is in PAS state!
    Why? cause we're testing PAS flags, consecutive failures for PAS repl, and
    time lapse since last success which for non-PAS replication can be very
    different.



--*/
{
    PPAS_DATA pPasData;
    //
    // Consistency validity
    //
    //

    if (!pPASLink->V1.cbPASDataOffset) {
        // must point to valid PAS data
        return FALSE;
    }
    pPasData = RL_PPAS_DATA(pPASLink);
    Assert(pPasData->size);

    if ( !PAS_IS_VALID(pPasData->flag) ) {
        DPRINT1(1, "GC_ValidatePASLink: Invalid PASData flag 0x%x\n",
                pPasData->flag);
        Assert(FALSE);
        return FALSE;
    }

    // see if the link is stale
    if ( GC_StaleLink(pPASLink) ) {
        return FALSE;
    }
    else {
        return TRUE;
    }

}

VOID
GC_DbgValidatePASLinks(
    DSNAME*      pNC                  // [in]
    )
/*++

Routine Description:

    Cycles thru RepsFrom & does sanity on PAS consistency:
    1. Only a single PAS entry
    2. entry contains a valid flag

Arguments:

    NC: active NC


Return Value:
    Success: DRAERR_Success
    Error: DRAERR_InternalError if anything went wrong.

Remarks:
    - Should be called in DBG only builds.
    - Defined only local to this file.


--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           iTag=0;
    UCHAR           *pVal = NULL;
    ULONG           bufsize = 0, len=0;
    REPLICA_LINK *  pRepsFromRef = NULL;
    INT             iPASSources=0;
    ULONG           ulRet = DRAERR_Success;
    PPAS_DATA       pPasData = NULL;


    // position on NC
    if (ulRet = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                       NULL)) {
        DPRINT1(0, "GC_DbgValidatePASLinks: FindNC returned %d\n", ulRet);
        return;
    }

    //
    // Find PAS entry in RepsFrom
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);

        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        // Note: the following assertion isn't necessarily true post FixupRepsFrom.
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        Assert(bufsize >= pRepsFromRef->V1.cb);

        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS)
        {
            // got one.
            iPASSources++;

            //
            // Consistency Asserts
            //

            // We should have PAS data
            Assert(pRepsFromRef->V1.cbPASDataOffset);
            // PAS data should always have a valid size, & contains some attrs.
            pPasData = RL_PPAS_DATA(pRepsFromRef);
            Assert(pPasData->size);
            Assert(pPasData->PAS.V1.cAttrs != 0);
            Assert(PAS_IS_VALID(pPasData->flag));

        }
    }


    if ( iPASSources > 1) {
        DPRINT2(0, "DRA PAS Inconsistency: %d PAS entries in repsFrom in NC %S\n",
                iPASSources, pNC->StringName);
        // this will break
        Assert(iPASSources==0 || iPASSources==1);
    }
    THFreeEx(pTHS, pVal);
}



VOID
GC_TriggerFullSync (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS)
/*++

Routine Description:

    Similarly to Win2k full sync setup, we'll reset water marks to initiate
    a full sync

Arguments:
    pNC -- the active NC we're working on.
    pAddedPAS -- the set of attrs, extending the old PAS

Return Value:
    Success:  DRAERR_Success.
    Error: Error value in DRAERR error space.

Remarks:
    None.


--*/
{
    PARTIAL_ATTR_VECTOR     *poldPAS;
    PARTIAL_ATTR_VECTOR     *pnewPAS;
    ULONG                    ulErr = ERROR_SUCCESS;

    //
    // Procedure:
    // a) Reset watermarks
    // b) get PAS from NC head, add to it addedPAS, write to NC head
    //

    DPRINT1(1,"GC_TriggerFullSync: Scratching watermarks for %ws\n",
            pNC->StringName);

    GC_TriggerSyncFromScratchOnAllLinks(pNC);

    if (!GC_ReadPartialAttributeSet(pNC, &poldPAS))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT(DRAERR_DBError, 0);
    }
    pnewPAS = GC_ExtendPartialAttributeSet(pTHS, poldPAS, pAddedPAS);
    GC_WritePartialAttributeSet(pNC, pnewPAS);

    //
    // reset PAS flag, there's no PAS cycle anywhere anymore.
    //
    ulErr = GC_RegisterPAS(pTHS, pNC, NULL, NULL, PAS_RESET, FALSE);
    if ( ulErr ) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    // Log so the admin knows what's going on.
    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_GC_TRIGGER_FULL_SYNC,
             szInsertDN(pNC),
             NULL, NULL
             );

#if DBG
    //
    // Consistency sanity.
    // this must happen in order not to trigger yet another PAS cycle.
    // When called from Replica_Add for instance pnewPAS can be NULL, thus
    // the check.
    //
    if (GC_ReadPartialAttributeSet(pNC, &pnewPAS) &&
        pnewPAS &&
        !GC_IsSamePartialSet(pnewPAS, ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->pPartialAttrVec)){
        Assert(FALSE);
    }
#endif
}



ULONG
GC_GetPreferredSource(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    UUID        **ppPrefUuid         // [ptr in, out]
    )
/*++

Routine Description:

    Finds the best suitable source for the given NC. If given, exclude pUUidDsa
    from potential sources list.
    Variations:
        - If all are stale/excluded, return the last one in the list.
        - If none are version compatible, return none in order to trigger
          a full sync.

Arguments:
    pNC -- The NC on which to operate

Return Value:

    DRAERR_SUccess: found a compatible PAS replication partent. ppPrefUuid != NULL.
    DRAERR_NoReplica: No preferred source was found (stale links?). ppPrefUuid == NULL.
    ERROR_REVISION_MISMATCH: Found a Win2K partner (doesn't understand PAS cycles). ppPrefUuid != NULL.
    Other Errors: DRAERR error space & potentially Raises an exception

Remarks:
    Side effect: Allocates memory for returned UUID!

--*/
{

    DWORD           iTag=0;
    UCHAR           *pVal=NULL;
    ULONG ulErr;
    DWORD bufsize=0, len=0;
    REPLICA_LINK *pRepsFromRef = NULL;
    ATTCACHE *pAC;
    struct _DSACRITERIA{
        INT iTag;               // relative location in repsFrom
        UUID uuidDsa;           // DSA id
        DWORD dwFlag;           // store DSA attributes
        DWORD dwWeight;         // to determine preference
    } *rgDsaCriteria, *pPrefDsa;
    INT DsaCount;
    INT iDsa=0;
    ULONG dnt;

    Assert(ppPrefUuid);
    Assert(CheckCurrency(pNC));

    //
    // Get attr count
    //
    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
    if (!pAC) {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }
    DsaCount = (INT)DBGetValueCount_AC( pTHS->pDB, pAC );
    if (!DsaCount) {
        //
        // No sources in repsFrom, thus cannot select
        // a preferred one.
        //
        return DRAERR_NoReplica;
    }

    // alloc dsa data
    rgDsaCriteria = THAllocEx(pTHS, sizeof(struct _DSACRITERIA)*DsaCount);
    // note that mem is allocated & zero'ed out.

    //
    // Traverse RepsFrom to find a candidate source.
    //   - filter undesired DSAs.
    //   - Collect information about potential candidates.
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, (ULONG)bufsize, (PULONG)&len,
                         (UCHAR**)&pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, (PDWORD)&bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);

        // debug validations
        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        // store current dnt
        dnt = pTHS->pDB->DNT;


        //
        // Filter out stale DSA's
        //
        if ( GC_StaleLink(pRepsFromRef) ) {
            DPRINT(1, "GC_GetPreferredSource: Skipped Stale link Dsa\n");
            // restore dnt in case we change it above (in the future)
            if (pTHS->pDB->DNT != dnt) {
                // seek back to NC dnt
                if (ulErr = DBFindDNT(pTHS->pDB, dnt)) {
                    DRA_EXCEPT (DRAERR_DBError, ulErr);
                }
            }
            continue;
        }

        //
        // Collect DSA data
        //

        // init flags data
        rgDsaCriteria[iDsa].iTag = iTag;
        CopyMemory(&rgDsaCriteria[iDsa].uuidDsa, &pRepsFromRef->V1.uuidDsaObj, sizeof(UUID) );

        // get DSA data
        GC_GetDsaPreferenceCriteria(
            pTHS,
            pNC,
            pRepsFromRef,
            &(rgDsaCriteria[iDsa].dwFlag));

        //
        // Assign weight to DSA preference criteria
        //
        // we're interested in the following preference criteria:
        // (x>Y means x preferred over Y)
        //    Criteria                  Weight for being in preferred criteria
        //  A - Post Win2k > win2k        +10
        //  B - intra-site > inter-site   +7
        //  C - RW > RO                   +5
        //  D - IP > SMTP                 +1
        // Permutations:
        // Category Value     location         Characteristics
        // ABC      = 22          1  -  post-w2k intra   rw    --
        // AB       = 17          2  -  post-w2k intra   ro    --
        // ACD      = 16          3  -  post-w2k inter   rw    ip
        // AC       = 15          4  -  post-w2k inter   rw    smtp
        // BC       = 12          5  -  w2k      intra   rw    --
        // AD       = 11          6  -  post-w2k inter   ro    ip
        // A        = 10          7  -  post-w2k inter   ro    smtp
        // B        = 7           8  -  w2k      intra   ro    --
        // CD       = 6           9  -  w2k      inter   rw    ip
        // C        = 5           10 -  w2k      inter   rw    smtp
        // D        = 1           11 -  w2k      inter   ro    ip
        // Nill     = 0           12 -  w2k      inter   ro    smtp
        // Invalid combinations: ABCD, BCD, BD, ABD, thus total of 2^4.
        // Interpretation:
        //   Generally, post w2k is preferred except if it has no other preference criteria
        //   and another source has all the rest. If category A is irrelevant, (all or none have it)
        //   then, intra is preferred (except if there's ip rw), then RW, then IP (relevant for inter only).
        // Justification:
        // This is a convinient way to select a data point while analyzing the global problem
        // space. (assign weights & pick the heaviest one...).
        // Next, The reason we'll be using numbers rather then #defines below is to maintain locality
        // between the weight value & the algorithm. Had we assigned a #define somewhere else,
        // it would be easy to get someone twicking the numbers resulting with undesired algorithm.

        rgDsaCriteria[iDsa].dwWeight  = (rgDsaCriteria[iDsa].dwFlag & DSA_PREF_VER) ? 10 : 0;
        rgDsaCriteria[iDsa].dwWeight += (rgDsaCriteria[iDsa].dwFlag & DSA_PREF_INTRA) ? 7 : 0;
        rgDsaCriteria[iDsa].dwWeight += (rgDsaCriteria[iDsa].dwFlag & DSA_PREF_RW) ? 5 : 0;
        rgDsaCriteria[iDsa].dwWeight += (rgDsaCriteria[iDsa].dwFlag & DSA_PREF_IP) ? 1 : 0;

        iDsa++;
        // restore dnt
        if (pTHS->pDB->DNT != dnt) {
            // seek back to NC dnt
            if (ulErr = DBFindDNT(pTHS->pDB, dnt)) {
                DRA_EXCEPT (DRAERR_DBError, ulErr);
            }
        }
    }

    // we must have traversed all of them at the most, most likely fewer
    Assert(iDsa <= DsaCount );

    //
    // Determine which do we return.
    //


    if ( iDsa == 0 ) {
        //
        // There are no valid sources at the moment.
        //
        // Either, all are stale and maybe one is excluded.
        // If we return none, we would trigger a full sync.
        // If the machine was off line for a while, we should
        // avoid that. We should give it another chance
        // Action: Return the last one in our list (Convinience: just because
        // we should already have it in repsfrom var)
        //
        DPRINT(1, "GC_GetPreferredSource: No valid PAS sources found.\n");
        Assert(!*ppPrefUuid);
         ulErr = DRAERR_NoReplica;
    } else {
        //
        // We had found at least one potential preferred source
        //
        DPRINT1(1, "GC_GetPreferredSource: found %d candidates.\n", iDsa);
        for (iDsa = 0, pPrefDsa = &(rgDsaCriteria[0]);
             iDsa<DsaCount;
             iDsa++) {
            if (pPrefDsa->dwWeight < rgDsaCriteria[iDsa].dwWeight) {
                pPrefDsa = &(rgDsaCriteria[iDsa]);
            }
        }

        // copy over
        *ppPrefUuid = THAllocEx(pTHS, sizeof(UUID));
        CopyMemory(*ppPrefUuid, &pPrefDsa->uuidDsa, sizeof(UUID));

        //
        // Test version compatibility
        //

        if ( (pPrefDsa->dwFlag & DSA_PREF_VER) ) {
            // we're happy: got a good PAS partner
            DPRINT(1, "GC_GetPreferredSource: Found good PAS replica partner.\n");
            ulErr = DRAERR_Success;
        }
        else {
            //
            // We'd settled on win2k-- this means full sync. Return None!
            //
            DPRINT(1, "GC_GetPreferredSource: Found Win2K non-PAS replica partner.\n");
            ulErr = ERROR_REVISION_MISMATCH;
        }
    }

    //
    // Cleanup temps
    //
    THFreeEx(pTHS, rgDsaCriteria);
    THFreeEx(pTHS, pRepsFromRef);

    return ulErr;
}


VOID
GC_GetDsaPreferenceCriteria(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    REPLICA_LINK *pRepsFrom,         // [in]
    PDWORD      pdwFlag)             // [out]
/*++

Routine Description:

    Query the dsa object for information as follows:
    -- is it RW or RO (for given NC)? DSA_PREF_RW
    -- is it intra or inter-site relative to us? DSA_PREF_INTRA
    -- is it's version is win2k or post win2k? DSA_PREF_VER
    -- can we talk to it IP? DSA_PREF_IP


    All is retrieved locally via the info stored in the config container.

Arguments:

    pNC-- the NC we're working on.
    pRepsFrom -- the Dsa RL entry we query about
    pdwFlag-- returned info


Return Value:
    none.

Remarks:
    Throws exception on error (justification: should be called only when valid data
    can be returned on the local query).

--*/
{

    DSNAME          OtherDsa, *pRwNc = NULL;
    INT             iTag=0;
    ULONG           ulErr;
    DWORD           cb = 0, bufsize=0;
    DWORD           cbOtherAncestors = 0;
    DWORD           cNumMyAncestors = 0, cNumOtherAncestors = 0;
    DWORD           *pMyAncestors = NULL, *pOtherAncestors = NULL;
    DWORD            dwDsaVersion = 0;

    Assert(pNC);
    Assert(pdwFlag && *pdwFlag == 0);   // caller supplied flag &&
                                        // caller should initialize
    //
    // Local DSA object info
    // set convinience ptrs
    //
    pMyAncestors = gAnchor.pAncestors;
    cNumMyAncestors = gAnchor.AncestorsNum;

    //
    // Get source DSA object
    //


    // set dsname of destination dsa
    ZeroMemory(&OtherDsa, sizeof(DSNAME));
    OtherDsa.structLen = DSNameSizeFromLen(0);
    CopyMemory(&(OtherDsa.Guid),&(pRepsFrom->V1.uuidDsaObj), sizeof(UUID));

    // Seek to other DSA object
    if (ulErr = DBFindDSName(pTHS->pDB, &OtherDsa)) {
        DRA_EXCEPT (DRAERR_DBError, ulErr);
    }

    // get RW info
    bufsize = cb = 0;
    while(!DBGetAttVal(
               pTHS->pDB,
               ++iTag,
               ATT_HAS_MASTER_NCS,
               DBGETATTVAL_fREALLOC,
               bufsize,
               &cb,
               (UCHAR**)&pRwNc))
    {
        if (DsIsEqualGUID(&(pRwNc->Guid), &(pNC->Guid))) {
            // found dsa is RW replica
            *pdwFlag |= DSA_PREF_RW;
            break;
        }
        bufsize = max(bufsize, cb);
    }
    THFreeEx(pTHS, pRwNc);

    // Get behavior version number.
    // If our enterprise version is >= Whistler (homogeneous) we're ok.
    // Otherwise, decide based on read source DS behavior version

    if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS ) {
        // enterprise is whistler+.
        *pdwFlag |= DSA_PREF_VER;
    }
    else {
        // read it off & evaluate.
        ulErr = DBGetSingleValue(
                    pTHS->pDB,
                    ATT_MS_DS_BEHAVIOR_VERSION,
                    &dwDsaVersion,
                    sizeof(DWORD),
                    NULL);
        if (ERROR_SUCCESS == ulErr &&
            dwDsaVersion >= DS_BEHAVIOR_WHISTLER_WITH_MIXED_DOMAINS ) {
            // version is set & preferred.
            *pdwFlag |= DSA_PREF_VER;
        }
    }

    // get ancestors
    DBGetAncestors(
        pTHS->pDB,
        &cbOtherAncestors,
        &pOtherAncestors,
        &cNumOtherAncestors
        );

    //
    // Intra or Inter site
    //

    //
    // They're in the same site if their site container is
    // the same object.
    // Objectclass hierarchy:
    //  site          << next up (Num-3)          // within the same site
    //   Servers      << next up (Num-2)
    //    server      << last ancestor (Num-1)
    //     nTDSDSA    << this object
    //
    Assert(cNumMyAncestors-3 > 0 &&
           cNumOtherAncestors-3 > 0 );
    if ( pOtherAncestors[cNumOtherAncestors-3] ==
         pMyAncestors[cNumMyAncestors-3] ) {
        *pdwFlag |= DSA_PREF_INTRA;
    }

    //
    // IP Connectivity
    //

    if ( !(*pdwFlag & DSA_PREF_INTRA) ) {
        // if it's intra-site, no need to care about mail
        if (!(pRepsFrom->V1.ulReplicaFlags & DRS_MAIL_REP) ) {
            *pdwFlag |= DSA_PREF_IP;
        }
    }

    //
    // Cleanup
    // note: we're relying on THFree ignoring NULLs
    //
    THFreeEx(pTHS, pOtherAncestors);
}



ULONG
GC_RegisterPAS(
    THSTATE               *pTHS,        // [in]
    DSNAME                *pNC,         // [in]
    UUID                  *pUuidDsa,    // [optional, in]
    PARTIAL_ATTR_VECTOR   *pPAS,        // [optional, in]
    DWORD                 dwOp,         // [in]
    BOOL                  fResetUsn     // [in]
    )
/*++

Routine Description:

    Resets PAS state by:
    a) writing RepsFrom values

Arguments:

    pNC -- active NC
    pUuidDsa -- the dsa (source) entry we wish to modify
                optional: if none specified, applied to all
    pPAS -- partial attribute set to register
    dwOp -- what operation should we do here.
        Values:
         PAS_RESET - Reset to 0. No PAS is running
         PAS_ACTIVE - Set to given state based on in params.
    fResetusn - rest usn watermark


Return Value:

    Success: DRAERR_Success
    Error: in Dra error space, or exception raised.

Remarks:
None.


--*/
{

    int             iTag= 0;
    UCHAR           *pVal=NULL;
    DWORD           bufsize=0, len=0;
    REPLICA_LINK    *pRepsFromRef=NULL;
    ULONG           ulErr = DRAERR_Success;
    ULONG           ulModifyFields;
    PPAS_DATA       pPasData = NULL;
    BOOL            fNoOp;

    // position on NC
    // set currency on the NC
    if (ulErr = DBFindDSName(pTHS->pDB, pNC))
    {
        // Tolerate the NC still being a phantom. This can occur when
        // DRA_ReplicaAdd/Sync fails to bring in the NC head because of a
        // sync failure.
        if (ulErr == DIRERR_NOT_AN_OBJECT) {
            return (ulErr);
        }
        DRA_EXCEPT(DRAERR_InternalError, ulErr);
    }

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);

        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (!pUuidDsa ||
            ( pUuidDsa &&
              DsIsEqualGUID(pUuidDsa, &(pRepsFromRef->V1.uuidDsaObj)) )) {
            //
            // Setup state
            //
            fNoOp = FALSE;
            switch ( dwOp ) {
                case PAS_RESET:
                    //
                    // Reset repsFrom PAS flags
                    //
                    if ( !(pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS) ) {
                        // it's already reset. no op.
                        fNoOp = TRUE;
                    }
                    else{
                        // reset an existing PAS cycle (most likely upon completion or
                        // failover to another source):
                        //  - reset flag
                        //  - reset PAS usn info (to zero). If we don't, following PAS cycles on new attrs
                        //    are in the risk of continuing from older water marks.
                        //
                        pRepsFromRef->V1.ulReplicaFlags &= ~DRS_SYNC_PAS;
                    }
                    Assert(!pPAS);
                    break;

                case PAS_ACTIVE:
                    pRepsFromRef->V1.ulReplicaFlags |= DRS_SYNC_PAS;
                    // the only valid operation on ALL is RESET
                    // if op is active, a uuiddsa must have been specified
                    // And a PAS must have been specified
                    Assert(pPAS);
                    Assert(pUuidDsa);
                    break;

                default:
                    Assert(FALSE);
                    DRA_EXCEPT(DRAERR_InternalError, 0);
            }

            // see if we can bail out early
            if ( fNoOp && pUuidDsa ) {
                // dsa specified & it's a no op. we're done
                break;
            }
            else if ( fNoOp ) {
                // this is apply to all entries, but this specific one is a no op.
                continue;
            }

            //
            // prepare pas info & commit
            //

            // if we're here we must update flags & pas data.
            ulModifyFields = DRS_UPDATE_SYSTEM_FLAGS| DRS_UPDATE_PAS;

            if (pPAS) {
                //
                // set PAS data
                //
                len = sizeof(PAS_DATA) + PartialAttrVecV1Size(pPAS);
                pPasData = THAllocEx(pTHS, len);
                pPasData->version = PAS_DATA_VER;
                pPasData->size = (USHORT)len;
                pPasData->flag = dwOp;
                CopyMemory(&(pPasData->PAS), pPAS, PartialAttrVecV1Size(pPAS));
            }
            // otherwise, we're reseting pas data & NULL is fine

            if ( fResetUsn ) {
                //
                // Reset USN vector
                //
                pRepsFromRef->V1.usnvec.usnHighObjUpdate = 0;
                ulModifyFields |= DRS_UPDATE_USN;
            }

            // Log debug event
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_EXTENSIVE,
                     dwOp == PAS_ACTIVE ?
                        DIRLOG_GC_REGISTER_ACTIVE_PAS :
                        DIRLOG_GC_REGISTER_RESET_PAS,
                     szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                     szInsertDN(pNC),
                     NULL );

            //
            // Commit changes to repsFrom
            //
            ulErr = UpdateRepsFromRef(
                        pTHS,
                        ulModifyFields,
                        pNC,
                        DRS_FIND_DSA_BY_UUID,
                        URFR_MUST_ALREADY_EXIST,
                        &(pRepsFromRef->V1.uuidDsaObj),
                        &(pRepsFromRef->V1.uuidInvocId),
                        &(pRepsFromRef->V1.usnvec),
                        &(pRepsFromRef->V1.uuidTransportObj),
                        RL_POTHERDRA(pRepsFromRef),
                        pRepsFromRef->V1.ulReplicaFlags,
                        &(pRepsFromRef->V1.rtSchedule),
                        DRAERR_Success,
                        pPasData );

            if ( pPasData ) {
                THFreeEx(pTHS, pPasData);
            }

            if ( ulErr ) {
                DRA_EXCEPT(DRAERR_InternalError, ulErr);
            }

            if ( pUuidDsa ) {
                //
                // Handle only specified one. done.
                //
                break;
            }

            // we'll potentially set more then one dsa.
            // only valid for a RESET op.
            Assert(dwOp == PAS_RESET);
        }

        // Next cycle: continue searching for next pUuidDsa

    }

    //
    // Cleanup
    //
    THFreeEx(pTHS, pRepsFromRef);

    return ulErr;
}


ULONG
GC_CompletePASReplication(
    THSTATE               *pTHS,                    // [in]
    DSNAME                *pNC,                     // [in]
    UUID                  *pUuidDsa,                // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSet,           // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSetEx          // [in]
    )
/*++

Routine Description:

    Executes tasks upon successfull completion of PAS replication:
        - Resets all USN vectors in repsFrom except for current PAS replica
        - replaces UTD vector w/ PAS replica's UTD vector
        - write new PAS onto NC head
        - remove PAS flag & data from NC head

Arguments:

    pNC-- active NC
    pUuidDsa -- uuid of peer dsa for which we'd completed a successful
                PAS repl cycle.


Return Value:

    Success: DRAERR_Success;
    Error: in DRAERR error space

Remarks:
    Raises DRA exception


--*/
{

    ULONG ulErr = DRAERR_Success;
    REPLICA_LINK *pRepsFromRef;
    PARTIAL_ATTR_VECTOR     *pNewPAS;
    ULONG len=0, bufsize=0;
    DWORD iTag=0;
    PUCHAR pVal=NULL;
    ATTCACHE* pAC=NULL;
    ULONG DsaCount;
    UUID* rgSrc;
    BOOL fExist=FALSE;

    // sanity on params.
    Assert(pNC && pUuidDsa);
    Assert(CheckCurrency(pNC));

    DPRINT1(1, "GC_CompletePASReplication: for NC %ws\n", pNC->StringName);

    //
    // Get attr count
    //
    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
    if (!pAC) {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }
    DsaCount = (INT)DBGetValueCount_AC( pTHS->pDB, pAC );
    // we should never get here if there are no sources.
    if (!DsaCount) {
        Assert(DsaCount != 0);
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // alloc dsa data
    rgSrc = THAllocEx(pTHS, sizeof(UUID)*DsaCount);
    // note that mem is allocated & zero'ed out.

    //
    // Traverse RepsFrom & collect all source's UUID
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         (PUCHAR*)&pRepsFromRef ))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
        Assert( pRepsFromRef->V1.cb == len );

        rgSrc[iTag-1] = pRepsFromRef->V1.uuidDsaObj;
    }
    Assert(iTag-1 == DsaCount);


    //
    // For each found
    //   - reset USN for all peers but PAS source
    //

    for (iTag=0; iTag<DsaCount; iTag++) {


        //
        // Filter out known undesired DSA.
        //
        if (DsIsEqualGUID(pUuidDsa, &(rgSrc[iTag])) ) {
            // skip this dsa, we don't want it. This is our successful peer
            continue;
        }

        //
        // Reset USN vector
        //
        ulErr = UpdateRepsFromRef(
                    pTHS,
                    DRS_UPDATE_USN,
                    pNC,
                    DRS_FIND_DSA_BY_UUID,
                    URFR_MUST_ALREADY_EXIST,
                    &rgSrc[iTag],
                    NULL,
                    &gusnvecFromScratch,
                    NULL, NULL, 0, NULL, 0, NULL );
    }


    //
    // Write new PAS on NC head
    //

    // combine into new one
    pNewPAS = GC_CombinePartialAttributeSet(pTHS, pPartialAttrSetEx, pPartialAttrSet);
    Assert(pNewPAS);
    GC_WritePartialAttributeSet(pNC, pNewPAS);

    //
    // Last, remove PAS registration on repsFrom
    //
    ulErr = GC_RegisterPAS(pTHS, pNC, pUuidDsa, NULL, PAS_RESET, FALSE);
    if ( ulErr ) {
        DRA_EXCEPT(DRAERR_InternalError, ulErr);
    }

    // Log so the admin knows what's going on.
    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_GC_PAS_COMPLETED,
             szInsertDN(pNC),
             szInsertUUID(pUuidDsa),
             NULL
             );

    THFreeEx(pTHS, rgSrc);
    return ulErr;
}


BOOL
GC_StaleLink(
    REPLICA_LINK *prl           // [in]
    )
/*++

Routine Description:

    Determines whether the input link is stale.

Arguments:

    prl -- the link in question

Return Value:

    TRUE: it is stale according to our guidelines (see code below)
    FALSE: it's ok

--*/
{

    if ( DRAERR_Shutdown != prl->V1.ulResultLastAttempt &&
         DRAERR_AbandonSync != prl->V1.ulResultLastAttempt &&
         DRAERR_Preempted != prl->V1.ulResultLastAttempt &&
         DRAERR_Success != prl->V1.ulResultLastAttempt) {
        //
        // Last attempt was failure, see how long ago & how many in sequence
        //
        DSTIME  diff;

        // consecutive failures
        if ( prl->V1.cConsecutiveFailures > gPASFailureTolerance ) {
            DPRINT1(1, "GC_StaleLink: Too many consecutive failures: %d\n",
                    prl->V1.cConsecutiveFailures);
            // stale due to too many failures
            return TRUE;
        }
        // time since last success
        diff = DBTime() - prl->V1.timeLastSuccess;
        if ( diff > gPASTimeTolerance ) {
            DPRINT1(1, "GC_StaleLink: too long since last success: %i64d\n",
                    diff);
            // stale due to too much time since last success
            return TRUE;
        }
    }

    // it isn't stale
    return FALSE;
}



VOID
GC_ReadRegistryThresholds( VOID  )
/*++

Routine Description:

    Reads Registry thresholds for GC Partial Attribute Set
    replication (preferred source stale criteria)

Return:

    Sets global variables: gdwMaxConsecFailures, gdwTimeToleranceThreshold

Remark:
    BUGBUG: This function is part of a temprorary solution.
    Permanent solution should be using the KCC criteria when determining
    server validity.
--*/
{
    DWORD dwErr;

    dwErr = GetConfigParam(KCC_CRIT_FAILOVER_TRIES, &gPASFailureTolerance, sizeof(DWORD));
    if ( dwErr ) {
        // report error to debugger, continue w/ defaults
        DPRINT1(3, "GC_StaleLink: Failed to get KCC_CRIT_FAILOVER_TRIES. Error %lu.\n",
                dwErr);
        Assert(gPASFailureTolerance == DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE);
    }
    dwErr = GetConfigParam(KCC_CRIT_FAILOVER_TIME, &gPASTimeTolerance, sizeof(DWORD));
    if ( dwErr ) {
        // report error to debugger, continue w/ defaults
        DPRINT1(3, "GC_StaleLink: Failed to get KCC_RIT_FAILOVER_TIME. Error %lu.\n",
                dwErr);
        Assert(gPASTimeTolerance == DEFAULT_PAS_TIME_TOLERANCE);
    }
}


void
GC_GetPartialAttrSets(
    THSTATE                     *pTHS,              // [in]
    DSNAME                      *pNC,               // [in]
    REPLICA_LINK                *pRepLink,          // [in]
    PARTIAL_ATTR_VECTOR         **ppPas,            // [out]
    PARTIAL_ATTR_VECTOR         **ppPasEx           // [out, optional]
    )
/*++

Routine Description:

    Extract partial attribute sets

Arguments:

    pNC - active naming context
    pRepLink - source repsfrom link
    ppPas - base partial attribute set
    ppPasEx - extended partial attribute set

Return Value:

    fill in out params

Remarks:
    raise exception on error


--*/
{

    // param sanity
    Assert(ppPas && pRepLink && pNC);

    //
    // Get base PAS
    // caller must have intended for us to have it
    //
    if (!GC_ReadPartialAttributeSet(pNC, ppPas))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    if (NULL == *ppPas) {
        //
        // No PAS on NC head, take it from schema cache
        //
        *ppPas = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec;
    }

    // if called, we must at least supply the main PAS vector.
    Assert(NULL != *ppPas);

    if ( ppPasEx &&
         (pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ) {
        //
        // Requested extended PAS
        //
        if ( 0 == pRepLink->V1.cbPASDataOffset ) {
            //
            // Inconsistency: There is no PAS data to process. Abort
            //
            DPRINT(0, "Error: GC_GetPartialAttrSets failed to get required PAS.\n");
            Assert(!(pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ||
                   pRepLink->V1.cbPASDataOffset);
            LogUnhandledError(DRAERR_InternalError);
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }
        *ppPasEx =  &(RL_PPAS_DATA(pRepLink)->PAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drarfmod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drarfmod.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Routines to update ATT_REPS_FROM values on NC heads.

DETAILS:

CREATED:

    03/06/97    Jeff Parham (jeffparh)
                UpdateRepsFromRef() moved from drancrep.c.

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // DRS_MSG_*

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include "debug.h"                      /* standard debugging header */
#define DEBSUB "DRARFMOD:"              /* define the subsystem for debugging */

// DRA headers
#include "dsaapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "drancrep.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRARFMOD


ULONG
DRA_ReplicaModify(
    THSTATE *   pTHS,
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    MTX_ADDR *  pmtxSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    )
{
    ULONG           draError;

    // Validate parameters.
    // fNullUuid(puuidTransportObj) may be true
    if (    ( NULL == pNC )
         || ( ( NULL == puuidSourceDRA ) && ( NULL == pmtxSourceDRA ) )
         || ( ( NULL == pmtxSourceDRA  ) && ( DRS_UPDATE_ADDRESS  & ulModifyFields ) )
         || ( ( NULL == prtSchedule    ) && ( DRS_UPDATE_SCHEDULE & ulModifyFields ) )
         || ( ( NULL == puuidTransportObj) && (DRS_UPDATE_TRANSPORT & ulModifyFields) )
         || ( 0 == ulModifyFields )
         || (    ulModifyFields
              != (   ulModifyFields
                   & ( DRS_UPDATE_ADDRESS | DRS_UPDATE_SCHEDULE | DRS_UPDATE_FLAGS
                       | DRS_UPDATE_TRANSPORT
                     )
                 )
            )
       )
    {
        DRA_EXCEPT( DRAERR_InvalidParameter, 0 );
    }

    // Log parameters.
    LogEvent8(
        DS_EVENT_CAT_REPLICATION,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_DRA_REPLICAMODIFY_ENTRY,
        szInsertDN(   pNC            ),
        puuidSourceDRA ? szInsertUUID( puuidSourceDRA ) : szInsertSz( "" ),
        pmtxSourceDRA  ? szInsertMTX(  pmtxSourceDRA  ) : szInsertSz( "" ),
        szInsertHex(  ulReplicaFlags ),
        szInsertHex(  ulModifyFields ),
        szInsertHex(  ulOptions      ),
        0,
        0
        );

    BeginDraTransaction( SYNC_WRITE );

    __try
    {
        DWORD dwFindFlags = ((NULL != puuidSourceDRA) && !fNullUuid(puuidSourceDRA))
                                ? DRS_FIND_DSA_BY_UUID
                                : DRS_FIND_DSA_BY_ADDRESS;

        draError = UpdateRepsFromRef(
                        pTHStls,
                        ulModifyFields,
                        pNC,
                        dwFindFlags,
                        URFR_MUST_ALREADY_EXIST,
                        puuidSourceDRA,
                        NULL,
                        NULL,
                        puuidTransportObj,
                        pmtxSourceDRA,
                        ulReplicaFlags,
                        prtSchedule,
                        0, NULL );
    }
    __finally
    {
        BOOL fCommit = ( DRAERR_Success == draError ) && !AbnormalTermination();

        EndDraTransaction( fCommit );
    }

    return draError;
}


DWORD
draCalculateConsecutiveFailures(
    IN  REPLICA_LINK *  pRepsFromRef            OPTIONAL,
    IN  ULONG           ulResultThisAttempt
    )
/*++

Routine Description:

    Determine the number of consecutive failures to set on a replica link given
    its previous state (if not a new replica) and the result of the most recent
    replication attempt.

Arguments:

    pReplicaLink (IN, OPTIONAL) - Previous repsFrom state.  May be NULL if the
        most recent attempt was the first attempt to replicate this (NC, source)
        pair.

    ulResultThisAttempt (IN) - Win32 error code describing success/failure of
        most recent replication attempt.

Return Values:

    The number of consecutive failures that should be recorded on the new
    repsFrom.

--*/
{
    DWORD cConsecutiveFailures;
    BOOL fIsMailBasedRepl;

    if (0 == ulResultThisAttempt) {
        // Success!  Forget any previous failures.
        return 0;
    }

    // Start with the number of failures prior to the most recent attempt.
    cConsecutiveFailures = pRepsFromRef ? pRepsFromRef->V1.cConsecutiveFailures
                                        : 0;

    // Is this mail-based replication?  We know that if there was an error and
    // we have no repsFrom that this cannot be mail-based repl, as the first
    // thing we do when configuring a mail-based link is add it with no
    // error.  (We don't try to perform any replication from it until we have
    // a repsFrom, unlike RPC-based repl.)
    fIsMailBasedRepl = pRepsFromRef
                       && (pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP);

    switch (ulResultThisAttempt) {
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
        // We get this only during RPC-based replication, since the error is
        // detected on the source rather than the destination.  Mail-based
        // replication sends no reply when an error is detected in the source,
        // ergo the destination can't differentiate errors found by the source
        // from each other or from basic mail delivery problems.  This is
        // somewhat unfortunate, as it reduces the amount of information we
        // have to deduce when we should fail over to another source.
        Assert(!fIsMailBasedRepl);
        // fall through...
    
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
        // A schema mismatch has been detected.  The most likely cause is that
        // we (the destination DSA) found a schema signature in the reply that
        // is different from our own.  This in turn is expected when the schema
        // is extended -- either the source or destination has the most recent
        // schema changes, but the other does not.
        //
        // The cases where this is not a transient failure due to recent schema
        // changes are due to either code errors (shouldn't happen) or second-
        // order failure modes (e.g., one DC can't sync the recent schema
        // changes because its disk is full).  For the latter case, we don't
        // route around servers when their disk is full and the schema has
        // *not* been extended, so we do not endeavor to do so here, either.
        //
        // Thus we assume schema mismatch is a transient failure and do not
        // include them in the failure count (which otherwise would cause us
        // to fail-over to another source, which is not desirable on schema
        // changes).
        //
        // Leave the failure count as-is, as we do e.g. on preemption.

        // fall through...
    
    case ERROR_DS_OBJECT_BEING_REMOVED:
        // We are attempting to add an object for which a dirty phantom already exists.
        // We cannot re-add the same object until the link cleaner has had a chance
        // to run. This is strictly a local phenomena, and adding a new source won't help.
        // Don't route around.
        // Fall through...

    case ERROR_DISK_FULL:
    case ERROR_DS_OUT_OF_VERSION_STORE:
        // Local resource shortage. Failover will not help.

    case ERROR_DS_THREAD_LIMIT_EXCEEDED:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_ABANDON_SYNC:
    case ERROR_DS_DRA_SHUTDOWN:
        // Replication was interrupted, but did not specifically fail.  Leave
        // the failure count at whatever it was previously (which may or may not
        // be 0).
        break;
    
    case ERROR_DS_DRA_REPL_PENDING:
        if (fIsMailBasedRepl) {
            // Mail-based replication.  This state indicates we have just
            // successfully enqueued an SMTP message containing our replication
            // request.
            Assert(pRepsFromRef);

            if (ERROR_DS_DRA_REPL_PENDING
                == pRepsFromRef->V1.ulResultLastAttempt) {
                // This is the second time we requested this same packet over
                // mail -- we never received a reply from our previous request.
                // Perhaps the mail message was lost, or the source DSA
                // encountered an error (ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET,
                // perhaps) processing the request.  In any case, treat this
                // lack of response as an error by incrementing the failure
                // count.
                cConsecutiveFailures++;
            } else {
                // We received a reply to our previous request and at least
                // attempted to apply it.  That attempt may have been successful
                // or unsuccessful.  In either case, leave the failure count
                // alone.
                break;
            }
        } else {
            // RPC-based replication.  This "error" code indicates we have
            // successfully applied packets from this source since any previous
            // failure(s) (if any) but have not yet completed the replication
            // cycle.  Treat this state as success.  This is analogous to mail-
            // based replication, where we clear the last error on a single
            // successful packet.  (Just in the RPC-based case we do this only
            // once every N packets for performance.)
            cConsecutiveFailures = 0;
        }
        break;

    case 0:
        Assert(!"Logic error -- we filtered out the success case already");
    default:
        // The most recent attempt resulted in an error.  Add one to the
        // previous failure count.
        cConsecutiveFailures++;
        break;
    }

    return cConsecutiveFailures;
}

DWORD
UpdateRepsFromRef(
    THSTATE *               pTHS,
    ULONG                   ulModifyFields,
    DSNAME *                pNC,
    DWORD                   dwFindFlags,
    BOOL                    fMustAlreadyExist,
    UUID *                  puuidDsaObj,
    UUID *                  puuidInvocId,
    USN_VECTOR *            pusnvecTo,
    UUID *                  puuidTransportObj,
    UNALIGNED MTX_ADDR *    pmtx_addr,
    ULONG                   RepFlags,
    REPLTIMES *             prtSchedule,
    ULONG                   ulResultThisAttempt,
    PPAS_DATA               pPasData
    )
//
// Add or update a Reps-From attribute value with the given state information.
//
// A note regarding the permission to update flags. Some flags are safe for the user
// to modify and other flags are "owned by the system".
//
// We may be called in the following situations:
// dramail.c - update after mail-based replication
// drancadd.c - ReplicaAdd()Creation of a reps-from on add of a replica
// drancrep.c - update after rpc-based replication
// drasch.c - update after gc partial attribute synchronization
// drarfmod.c - ReplicaModify
// 
// Regarding flags, we need to enforce that extra flags are not passed in, and that
// the caller is allowed to clear flags that are set. The former is accomplished in
// dradir at the DirApi level. For the latter, we only need to worry about the cases
// of explicit updating of an existing set of flags, which is cases 4 and 5 above.
// We distinguish between the system caller in case 4 and the user caller in case 5
// by the DRS_UPDATE_SYSTEM_FLAGS modify field.
//
// Note that we do not have to check for modification of system flags when
// DRS_UPDATE_ALL is specified.  We cannot reach this path on a DirReplicaModify,
// since DRS_UPDATE_ALL may not be specified. If this is a DirReplicaAdd, we will
// have already enforced that a reps-from does not already exist, and that the
// incoming flags are correct. Otherwise, we are here on behalf of the system, and
// updating system flags is permitted.
//
{
    ULONG                   ret = 0;
    BOOL                    AttExists;
    ULONG                   len;
    LONG                    diff;
    REPLICA_LINK *          pRepsFromRef = NULL;
    ULONG                   ulModifyFieldsUsed;
    DSTIME                  timeLastAttempt;
    DSTIME                  timeLastSuccess;
    ATTCACHE *              pAC;
    DWORD                   iExistingRef = 0;
    DWORD                   cbExistingAlloced = 0;
    DWORD                   cbExistingRet;
    REPLICA_LINK *          pExistingRef = NULL;
    DWORD                   cConsecutiveFailures;
    BOOL                    fNewRefHasDsaGuid;
    BOOL                    fNewRefHasInvocId;
    PPAS_DATA               pTmpPasData = NULL;

    Assert(0 == (dwFindFlags & DRS_FIND_AND_REMOVE));
    Assert(pPasData ? pPasData->size : TRUE);

    if (DBFindDSName(pTHS->pDB, pNC)) {
        // NOTE: This code is commonly hit when we're attempting to add a
        // new replica (e.g., at install time) and for whatever reason
        // the replication attempt failed completely (e.g., access denied)
        // and the NC head was not replicated.

        return DRAERR_BadNC;
    }

    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);

    // Mask the flags down to the ones we save

    RepFlags &= RFR_FLAGS;


    // Try and find this name in the repsfrom attribute.

    if ( !FindDSAinRepAtt( pTHS->pDB,
                           ATT_REPS_FROM,
                           dwFindFlags | DRS_FIND_AND_REMOVE,
                           puuidDsaObj,
                           pmtx_addr,
                           &AttExists,
                           &pRepsFromRef,
                           &len ) ) {

        // Existing att val for this DSA found and removed.
        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
        VALIDATE_REPLICA_LINK_SIZE(pRepsFromRef);
    }
    else if ( fMustAlreadyExist ) {
        return DRAERR_NoReplica;
    }

    timeLastAttempt = DBTime();

    // Determine the time of the last successful completion of a replication
    // cycle.
    if (ERROR_SUCCESS == ulResultThisAttempt) {
        if ((NULL != pusnvecTo)
            && (0 == memcmp(&gusnvecFromScratch, pusnvecTo, sizeof(USN_VECTOR)))
            && (NULL == pRepsFromRef)) {
            // Brand new source from whom we haven't yet completed a replication
            // cycle.
            timeLastSuccess = 0;
        }
        else {
            // This attempt resulted in successful completion of a replication
            // cycle.
            timeLastSuccess = timeLastAttempt;
        }
    }
    else if (NULL != pRepsFromRef) {
        // This attempt was incomplete or unsuccessful; our last success remains
        // unchanged.
        timeLastSuccess = pRepsFromRef->V1.timeLastSuccess;
    }
    else {
        // This is our first attempt and it was incomplete or unsuccessful.
        timeLastSuccess = 0;
    }

    // Determine the number of consecutive failures since the last successful
    // completion of a replication cycle.
    cConsecutiveFailures = draCalculateConsecutiveFailures(pRepsFromRef,
                                                           ulResultThisAttempt);

    // Now add new attribute value.

#ifdef CACHE_UUID
    if (!(RepFlags & DRS_MAIL_REP)) {
        if ( pmtx_addr ) {
            CacheUuid (puuidDsaObj, pmtx_addr->mtx_name);
        }
    }
#endif

    if (DRS_UPDATE_ALL != ulModifyFields) {

        // This check enforces that the reps-from already exists
        if (!pRepsFromRef || !len) {
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

        ulModifyFieldsUsed = ulModifyFields & DRS_UPDATE_MASK;

        if (    ( 0 == ulModifyFieldsUsed )
             || ( ulModifyFields != ulModifyFieldsUsed )
           )
        {
            DRA_EXCEPT( DRAERR_InternalError, ulModifyFields );
        }

        if (ulModifyFields & DRS_UPDATE_ADDRESS) {

            // Only want to update source name.
            // Determine new attribute value size.

            // offset new size by mtx difference
            diff = MTX_TSIZE(pmtx_addr) - MTX_TSIZE(RL_POTHERDRA(pRepsFromRef));
            if (diff) {
                //
                // size change
                //  - allocate & copy to new location
                //  - fix offsets
                //  - conditionally, fix PAS data offset & location
                //

                REPLICA_LINK *pOldRepsFrom = pRepsFromRef;

                // calc new RepsFrom size
                pOldRepsFrom->V1.cb += diff;
                // alloc new size & allow for alignment fixing
                pRepsFromRef = THAllocEx(pTHS, pOldRepsFrom->V1.cb+sizeof(DWORD));
                // copy all fixed fields
                memcpy (pRepsFromRef, pOldRepsFrom, offsetof(REPLICA_LINK, V1.rgb));

                // set other DRA new size
                pRepsFromRef->V1.cbOtherDra = MTX_TSIZE(pmtx_addr);

                //
                // PAS Data: Fix offsets & copy over
                //
                if ( pRepsFromRef->V1.cbPASDataOffset ) {
                    //
                    // we have PAS data:
                    //  - fix offset
                    //  - handle alignment fixup
                    //  - copy to new location
                    //
                    pTmpPasData = RL_PPAS_DATA(pOldRepsFrom);
                    // if offset is valid, there must be something there
                    Assert(pTmpPasData->size != 0);
                    // offset by mtx change, fix alignment & copy over
                    pRepsFromRef->V1.cbPASDataOffset += diff;
                    RL_ALIGN_PAS_DATA(pRepsFromRef);
                    memcpy(RL_PPAS_DATA(pRepsFromRef), pTmpPasData, pTmpPasData->size);
                }       // PAS data
            }           // diff != 0

            // regardless of size change copy new mtx address data
            memcpy (RL_POTHERDRA(pRepsFromRef), pmtx_addr, MTX_TSIZE(pmtx_addr));
        }

        if ( ulModifyFields & DRS_UPDATE_SYSTEM_FLAGS ) {

            pRepsFromRef->V1.ulReplicaFlags = RepFlags;

        } else if ( ulModifyFields & DRS_UPDATE_FLAGS ) {

            DWORD dwFlagsSet = RepFlags & (~pRepsFromRef->V1.ulReplicaFlags);
            DWORD dwFlagsClear = (~RepFlags) & pRepsFromRef->V1.ulReplicaFlags;

            if ((dwFlagsSet | dwFlagsClear) & RFR_SYSTEM_FLAGS) {
                return ERROR_INVALID_PARAMETER;
            }

            pRepsFromRef->V1.ulReplicaFlags = RepFlags;
        }

        if ( ulModifyFields & DRS_UPDATE_SCHEDULE )
        {
            if ( NULL == prtSchedule )
            {
                DRA_EXCEPT( DRAERR_InternalError, ulModifyFields );
            }

            memcpy( &pRepsFromRef->V1.rtSchedule, prtSchedule, sizeof( REPLTIMES ) );
        }

        if ( ulModifyFields & DRS_UPDATE_RESULT )
        {
            pRepsFromRef->V1.ulResultLastAttempt = ulResultThisAttempt;
            pRepsFromRef->V1.timeLastAttempt  = timeLastAttempt;
            pRepsFromRef->V1.timeLastSuccess  = timeLastSuccess;
            pRepsFromRef->V1.cConsecutiveFailures    = cConsecutiveFailures;
        }

        if (ulModifyFields & DRS_UPDATE_TRANSPORT) {
            // It is permissible for the transport uuid to be null
            pRepsFromRef->V1.uuidTransportObj = *puuidTransportObj;
        }

        //
        // update PAS state
        //
        if (ulModifyFields & DRS_UPDATE_PAS) {
            //
            // Update PAS data
            // if none given, we need to reset fields, otherwise write new data
            //
            if ( pPasData ) {
                // can't have reference to pas data w/ no info
                Assert(pPasData->size != 0);

                if (pRepsFromRef->V1.cbPASDataOffset) {
                    // we had previous data, see if we need to realloc
                    diff = pPasData->size - RL_PPAS_DATA(pRepsFromRef)->size;
                    // adjust blob size (regardless)
                    pRepsFromRef->V1.cb += diff;
                    // realloc if needed
                    if (diff>0) {
                        // note we preserve old ref ptr as well, allow for alignment fixup
                        pRepsFromRef = THReAllocEx(pTHS, pRepsFromRef, pRepsFromRef->V1.cb + sizeof(DWORD));
                    }
                }               // previous data
                else{
                    // no prev PAS data. adjust size, realloc, & set offsets
                    pRepsFromRef->V1.cb += pPasData->size;
                    // note we preserve old ref ptr as well
                    // just in case add alignment space (sizeof(DWORD))
                    pRepsFromRef = THReAllocEx(pTHS, pRepsFromRef, pRepsFromRef->V1.cb+sizeof(DWORD));
                    pRepsFromRef->V1.cbPASDataOffset = pRepsFromRef->V1.cbOtherDraOffset +
                                                       pRepsFromRef->V1.cbOtherDra;
                    // ensure alignment offsets
                    RL_ALIGN_PAS_DATA(pRepsFromRef);
                }               // no previous data
                // copy over
                memcpy(RL_PPAS_DATA(pRepsFromRef), pPasData, pPasData->size);
            }                   // we're given data to set
            else {
                //
                // we're reseting PAS info.
                //
                if ( pRepsFromRef->V1.cbPASDataOffset ) {
                    // we had previous PAS data.
                    // Eliminate it (no need to alloc, just set offsets & counts).
                    Assert(RL_PPAS_DATA(pRepsFromRef)->size);
                    pRepsFromRef->V1.cb = sizeof(REPLICA_LINK) + pRepsFromRef->V1.cbOtherDra;
                    pRepsFromRef->V1.cbPASDataOffset = 0;
                }
                // else, we had none, nothing to do.
            }   // reseting pas data
        }       // update PAS data

        //
        // update USN vector
        //
        if (ulModifyFields & DRS_UPDATE_USN) {
            pRepsFromRef->V1.usnvec = *pusnvecTo;
        }

    } else {

        //
        // DRS_UPDATE_ALL: Update all flags from function params
        //
        DWORD cbRepsFromRef;

        if ((NULL != pRepsFromRef)
            && (0 != memcmp(&pRepsFromRef->V1.usnvec, pusnvecTo,
                            sizeof(USN_VECTOR)))) {
            // We're improving the USN vector for this source; log it.
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_IMPROVING_USN_VECTOR,
                      szInsertUUID(puuidDsaObj),
                      szInsertUSN(pRepsFromRef->V1.usnvec.usnHighObjUpdate),
                      szInsertUSN(pRepsFromRef->V1.usnvec.usnHighPropUpdate),
                      szInsertUSN(pusnvecTo->usnHighObjUpdate),
                      szInsertUSN(pusnvecTo->usnHighPropUpdate),
                      szInsertDN(pNC),
                      NULL,
                      NULL);
        }

        // Making whole value, allocate and set up

        // PAS data: See if we need to allocate mem for PAS data
        // & preserve content in tmp variable. (see comment below about PAS data)
        Assert(pTmpPasData == NULL);                // don't overwrite anything
        if ( pPasData && pPasData->PAS.V1.cAttrs ) {
            // explicit data specified
            pTmpPasData = pPasData;
        }
        else if ( !pPasData &&
                  pRepsFromRef && pRepsFromRef->V1.cbPASDataOffset ){
            // if no explicit erase specified, use old data
            pTmpPasData = RL_PPAS_DATA(pRepsFromRef);
        }
        // else either no PasData passed  and no PasData in old ref.
        // or explicit erase request. Either way, leave empty.
        Assert(!pTmpPasData ||
               (pTmpPasData && pTmpPasData->size) );              // no such thing as empty PAS data.

        // If we're setting PAS cycle, we have to have PAS data.
        Assert((RepFlags & DRS_SYNC_PAS)? (NULL != pTmpPasData) : TRUE);

        // calculate new size:
        //  - structure size
        //  - variable fields:
        //      - mtx address
        //      - pas data.
        // regardless, in allocation we will add sizeof(DWORD) in case of
        // alignmnet adjustments
        cbRepsFromRef = sizeof(REPLICA_LINK) +
                        MTX_TSIZE(pmtx_addr) +
                        (pTmpPasData ? pTmpPasData->size : 0);

        pRepsFromRef = THAllocEx(pTHS, cbRepsFromRef + sizeof(DWORD));

        pRepsFromRef->dwVersion = VERSION_V1;

        pRepsFromRef->V1.cb = cbRepsFromRef;
        pRepsFromRef->V1.usnvec = *pusnvecTo;
        pRepsFromRef->V1.uuidDsaObj = *puuidDsaObj;
        pRepsFromRef->V1.uuidInvocId = *puuidInvocId;
        pRepsFromRef->V1.uuidTransportObj = *puuidTransportObj;
        pRepsFromRef->V1.ulReplicaFlags = RepFlags;

        pRepsFromRef->V1.cbOtherDraOffset = offsetof( REPLICA_LINK, V1.rgb );
        pRepsFromRef->V1.cbOtherDra = MTX_TSIZE(pmtx_addr);
        memcpy (RL_POTHERDRA(pRepsFromRef), pmtx_addr, MTX_TSIZE(pmtx_addr));

        if ( NULL != prtSchedule ) {
            memcpy( &pRepsFromRef->V1.rtSchedule, prtSchedule, sizeof( REPLTIMES ) );
        }

        pRepsFromRef->V1.ulResultLastAttempt = ulResultThisAttempt;
        pRepsFromRef->V1.timeLastAttempt     = timeLastAttempt;
        pRepsFromRef->V1.timeLastSuccess     = timeLastSuccess;
        pRepsFromRef->V1.cConsecutiveFailures= cConsecutiveFailures;

        pRepsFromRef->V1.dwReserved1 = 0;   // cleanup old uses
        //
        // PAS data:
        // If data was passed, use it. Note that to erase PAS data on a
        // DRS_UPDATE_ALL call, the request must be explicit-- i.e. pass in
        // PasData w/ 0 cAttrs (though size != 0).
        // This is done in order to prevent uninterested callers from erasing PAS data.
        //
        if ( pTmpPasData ) {
                // can't have reference to pas data w/ no info
                pRepsFromRef->V1.cbPASDataOffset = pRepsFromRef->V1.cbOtherDraOffset +
                                                   pRepsFromRef->V1.cbOtherDra;
                // ensure alignment and copy over
                RL_ALIGN_PAS_DATA(pRepsFromRef);
                Assert(pTmpPasData->size);
                memcpy(RL_PPAS_DATA(pRepsFromRef), pTmpPasData, pTmpPasData->size);
        }
    }


    Assert( !IsBadReadPtr( pRepsFromRef, pRepsFromRef->V1.cb ) );
    Assert( pRepsFromRef->V1.cbOtherDraOffset == offsetof( REPLICA_LINK, V1.rgb ) );
    Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );
    VALIDATE_REPLICA_LINK_SIZE(pRepsFromRef);
    Assert( 0 == pRepsFromRef->V1.cbPASDataOffset ||
            ( COUNT_IS_ALIGNED(pRepsFromRef->V1.cbPASDataOffset, ALIGN_DWORD) &&
              POINTER_IS_ALIGNED(RL_PPAS_DATA(pRepsFromRef), ALIGN_DWORD)) );

    // Make sure we don't already have a Reps-From for this Invocation-ID,
    // network address, or DSA object.

    fNewRefHasDsaGuid = !fNullUuid(&pRepsFromRef->V1.uuidDsaObj);
    fNewRefHasInvocId = !fNullUuid(&pRepsFromRef->V1.uuidInvocId);

    while (!DBGetAttVal_AC(pTHS->pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsFromRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsFromRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fNewRefHasDsaGuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsFromRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) )
             || (    fNewRefHasInvocId
                  && !memcmp( &pExistingRef->V1.uuidInvocId,
                              &pRepsFromRef->V1.uuidInvocId,
                              sizeof(UUID ) ) ) )
        {
            ret = DRAERR_RefAlreadyExists;
            goto Cleanup;
        }
    }


    // Add the new Reps-From.

    ret = DBAddAttVal( pTHS->pDB, ATT_REPS_FROM, pRepsFromRef->V1.cb, pRepsFromRef );
    if (ret){
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // Update object, but indicate that we don't want to
    // awaken any ds_waits on this object (since we're only updating
    // repsfrom).

    if (DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                    NULL, META_STANDARD_PROCESSING)) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // current code path does not permit reaching this point
    // on non-success. trap changes.
    Assert(DRAERR_Success == ret);

Cleanup:
    //
    // Do whatever cleanup we can
    //

    if ( pExistingRef ) {
        THFree(pExistingRef);
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\draupdrr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draupdrr.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAUPDRR:" /* define the subsystem for debugging */




// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRAUPDRR

DWORD AddDSARefToAtt(DBPOS *pDB, REPLICA_LINK *pRepsToRef)
{
    BOOL            fFound = FALSE;
    ATTCACHE *      pAC;
    DWORD           iExistingRef = 0;
    DWORD           cbExistingAlloced = 0;
    DWORD           cbExistingRet;
    REPLICA_LINK *  pExistingRef;
    BOOL            fRefHasUuid;
    DWORD           err;
    NAMING_CONTEXT_LIST *pncl;
    DWORD           ncdnt;

    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    //
    // PREFIX: PREFIX complains that pAC hasn't been checked to
    // make sure that it is not NULL.  This is not a bug.  Since
    // a predefined constant was passed to SCGetAttById, pAC will
    // never be NULL.
    //
    
    Assert(NULL != pAC);

    VALIDATE_REPLICA_LINK_VERSION(pRepsToRef);

    fRefHasUuid = !fNullUuid(&pRepsToRef->V1.uuidDsaObj);

    while (!DBGetAttVal_AC(pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        // If either the network addresses or UUIDs match...
        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsToRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsToRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fRefHasUuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsToRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) ) )
        {
            // Reference already exists!
            return DRAERR_RefAlreadyExists;
        }
    }

    err = DBAddAttVal_AC(pDB, pAC, pRepsToRef->V1.cb, pRepsToRef);

    switch (err) {
      case DB_success:
        err = DBGetSingleValue(pDB,
                               FIXED_ATT_DNT,
                               &ncdnt,
                               sizeof(ncdnt),
                               NULL);
        Assert(err == DB_success);
        pncl = FindNCLFromNCDNT(ncdnt, FALSE);
        pncl->fReplNotify = TRUE;
        break;
        
      case DB_ERR_VALUE_EXISTS:
        err = DRAERR_RefAlreadyExists;
        break;

      default:
        RAISE_DRAERR_INCONSISTENT( err );
    }
    return err;
}

DWORD DelDSARefToAtt(DBPOS *pDB, REPLICA_LINK *pRepsToRef)
{
    BOOL            fFound = FALSE;
    ATTCACHE *      pAC;
    DWORD           iExistingRef = 0;
    DWORD           cbExistingAlloced = 0;
    DWORD           cbExistingRet;
    REPLICA_LINK *  pExistingRef;
    BOOL            fRefHasUuid;
    ULONG           err;
    NAMING_CONTEXT_LIST *pncl;
    DWORD           ncdnt;

    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    //
    // PREFIX: PREFIX complains that pAC hasn't been checked to
    // make sure that it is not NULL.  This is not a bug.  Since
    // a predefined constant was passed to SCGetAttById, pAC will
    // never be NULL.
    //

    Assert(NULL != pAC);

    VALIDATE_REPLICA_LINK_VERSION(pRepsToRef);

    fRefHasUuid = !fNullUuid(&pRepsToRef->V1.uuidDsaObj);

    while (!DBGetAttVal_AC(pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        // If either the network addresses or UUIDs match...
        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsToRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsToRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fRefHasUuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsToRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) ) )
        {
            // Found matching Reps-To; remove it.
            fFound = TRUE;

            err = DBRemAttVal_AC(pDB, pAC, cbExistingRet, pExistingRef);

            if (err)
            {
                // Attribute removal failed!
                DRA_EXCEPT(DRAERR_DBError, err);
            }
        }
    }

    if (   (iExistingRef == 1)
        && fFound
        && DBHasValues(pDB, ATT_REPS_TO)) {
        
        err = DBGetSingleValue(pDB,
                               FIXED_ATT_DNT,
                               &ncdnt,
                               sizeof(ncdnt),
                               NULL);
        pncl = FindNCLFromNCDNT(ncdnt, FALSE);
        pncl->fReplNotify = FALSE;
    }

    return fFound ? 0 : DRAERR_RefNotFound;
}

ULONG DRA_UpdateRefs(
    THSTATE *pTHS,
    DSNAME *pNC,
    MTX_ADDR *pDSAMtx_addr,
    UUID * puuidDSA,
    ULONG ulOptions)
{
    DWORD ret = 0;
    REPLICA_LINK *pRepsToRef;
    ULONG cbRepsToRef;

    // Log parameters

    LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_EXTENSIVE,
                        DIRLOG_DRA_UPDATEREFS_ENTRY,
                        szInsertWC(pNC->StringName),
                        szInsertSz(pDSAMtx_addr->mtx_name),
                        szInsertHex(ulOptions));

    if (!(ulOptions & (DRS_ADD_REF | DRS_DEL_REF))) {
        return DRAERR_InvalidParameter;
    }


    BeginDraTransaction(SYNC_WRITE);

    __try {

        // Find the NC.  The setting of DRS_WRIT_REP reflects writeability of
        // the destination's NC. The source's NC writeability should be
        // compatible for sourcing the destination NC.
        //

        if (FindNC(pTHS->pDB,
                   pNC,
                   ((ulOptions & DRS_WRIT_REP)
                    ? FIND_MASTER_NC
                    : FIND_MASTER_NC | FIND_REPLICA_NC),
                   NULL)) {
            ret = DRAERR_BadNC;
            __leave;
        }

        cbRepsToRef = (sizeof(REPLICA_LINK) + MTX_TSIZE(pDSAMtx_addr));
        pRepsToRef = (REPLICA_LINK*)THAllocEx(pTHS, cbRepsToRef);

        pRepsToRef->dwVersion           = VERSION_V1;
        pRepsToRef->V1.cb               = cbRepsToRef;
        pRepsToRef->V1.ulReplicaFlags   = ulOptions & DRS_WRIT_REP;
        pRepsToRef->V1.cbOtherDraOffset = (DWORD)(pRepsToRef->V1.rgb - (char *)pRepsToRef);
        pRepsToRef->V1.cbOtherDra       = MTX_TSIZE(pDSAMtx_addr);
        pRepsToRef->V1.timeLastSuccess  = DBTime();
        
        if (puuidDSA) {
            pRepsToRef->V1.uuidDsaObj = *puuidDSA;
        }

        memcpy(RL_POTHERDRA(pRepsToRef), pDSAMtx_addr, MTX_TSIZE(pDSAMtx_addr));

        if (ulOptions & DRS_DEL_REF) {
            ret = DelDSARefToAtt (pTHS->pDB, pRepsToRef);
        }

        if (ulOptions & DRS_ADD_REF) {
            ret = AddDSARefToAtt (pTHS->pDB, pRepsToRef);
        }


        if (!ret) {
            DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);
        }

    } __finally {

        // If we had success, commit, else rollback

        if (EndDraTransaction(!(ret || AbnormalTermination()))) {
            Assert (FALSE);
            ret = DRAERR_InternalError;
        }
    }

    // DelDSARefToAtt can return RefNotFound.  If this is returned, it will be logged
    // by draasync.c:DispatchPao.  When this routine is called by GetNCChanges for a
    // reps-to verification (DRS_GETCHG_CHECK), we can ignore these errors.
    if ( (ulOptions & DRS_GETCHG_CHECK) &&
         ( (ret == DRAERR_RefNotFound) ||
           (ret == DRAERR_RefAlreadyExists) ) ) {
        ret = ERROR_SUCCESS;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drautil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drautil.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Miscellaneous replication support routines.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// SAM headers
#include <samsrvp.h>                    /* for SampInvalidateRidRange() */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>
#include <winsock.h>                    /* htonl, ntohl */
#include <filtypes.h>                   // For filter construction
#include <winldap.h>                    // for DN parsing

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAUTIL:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drauptod.h"
#include "draasync.h"
#include "drameta.h"
#include "drauptod.h"

#include <fileno.h>
#define  FILENO FILENO_DRAUTIL

extern BOOL gfRestoring;
// Count of restores done on this DC so far
ULONG gulRestoreCount = 0;
BOOL gfJustRestored = FALSE;

ULONG gulReplLatencyCheckInterval;

void DbgPrintErrorInfo(); // mddebug.c


BOOL
IsFSMOSelfOwnershipValid(
    DSNAME *pFSMO
    )

/*++

Routine Description:

Determine whether we are ready to hold the given FSMO.
We require that the partition in which the FSMO resides be synchronized.

If the partition in which the role resides is supplied, we use it to check
the less restrictive condition that only that partition is synchronized.

Murlis wrote:
So the question is , can IsFSMOSelfOwnershipValid be a little smarter and
see that  this DC hosts the sole authoritative copy of the naming context
in which the given FSMO role resides ?


Arguments:

    pNC - FSMO object being checked

Return Value:

    BOOL -

--*/

{
    CROSS_REF * pCR;
    COMMARG commArg;

    Assert( pFSMO );

    // If installing, ownership is valid
    if (DsaIsInstalling()) {
        return TRUE;
    }

    // If all partitions already synchronized, ownership is valid
    if (gfIsSynchronized) {
        return TRUE;
    }

    // We want the partition that holds this FSMO object. The object
    // may or may not be a NC head.  Find the NC head.

    memset( &commArg, 0, sizeof( COMMARG ) );  // not used
    pCR = FindBestCrossRef( pFSMO, &commArg );
    if (NULL == pCR) {
        DPRINT1(0, "Can't find cross ref for %ws.\n", pFSMO->StringName );
        DRA_EXCEPT(ERROR_DS_NO_CROSSREF_FOR_NC, DRAERR_InternalError);
    }

    // See if the holding partition is synchronized
    // In the sole-domain-owner scenario, this will always return true
    // which is an optimization

    return DraIsPartitionSynchronized( pCR->pNC );

} /* IsFSMOSelfOwnershipValid */

void *
dramallocex(
    size_t size
)

/*++

Routine Description:

// Memory allocation routine for the DRA. Some return exceptions, some
// return aligned memory for use in pickling\unpickling. These routines
// have routines in \ds\linnaeus\src\dxa\drax400\maildra.cxx with
// which they work, so if they are changed here, they must be changed
// there also.

// dramallocex
// mallocs, but raises exception if out of memory

Arguments:

    size -

Return Value:

    void * -

--*/

{
    void *pv;
//  if (!(pv = ExchAlloc (size))) {
    if (!(pv = HeapAlloc (GetProcessHeap(), 0, size))) {
        DRA_EXCEPT (DRAERR_OutOfMem, 0);
    }
    return pv;
} /* dramallocex */

void *
draalnmallocex(
    size_t size
    )

/*++

Routine Description:

// draalnmallocex
// mallocs, but raises exception if out of memory
// returns memory allocated as required by pickling

Arguments:

    size -

Return Value:

    void * -

--*/

{
    void *pv;
//  if (!(pv = ExchAlloc (size))) {
    if (!(pv = HeapAlloc (GetProcessHeap(), 0, size))) {
        DRA_EXCEPT (DRAERR_OutOfMem, 0);
    }
    return pv;
} /* draalnmallocex */

void
draalnfree (
    void * pv
    )

/*++

Routine Description:

// draalnfree
// frees aligned memory allocated with above routine

Arguments:

    pv -

Return Value:

    None

--*/

{
//  ExchFree (pv);
    HeapFree (GetProcessHeap(), 0, pv);

} /* draalnfree  */

// draalnreallocex
// reallocs, but raises exception if out of memory
// Frees previous allocation if out of memory
// takes and returns aligned memory.

void *
draalnreallocex (
    void * pv,
    size_t size
    )

/*++

Routine Description:

    Description

Arguments:

    pv -
    size -

Return Value:

    void * -

--*/

{
    void *pvsaved = pv;

//  if (!(pv = ExchReAlloc (pv, size))) {
    if (!(pv = HeapReAlloc (GetProcessHeap(), 0, pv, size))) {
//      ExchFree (pvsaved);
        HeapFree (GetProcessHeap(), 0, pvsaved);
        DRA_EXCEPT (DRAERR_OutOfMem, 0);
    }
    return pv;
} /* draalnreallocex  */


BOOL
MtxSame(
    UNALIGNED MTX_ADDR *pmtx1,
    UNALIGNED MTX_ADDR *pmtx2
    )

/*++

Routine Description:

// MtxSame. Returns TRUE if passed MTX are the
// same (case insensitive comparision)

Arguments:

    pmtx1 -
    pmtx2 -

Return Value:

    BOOL -

--*/

{
    if (   (pmtx1->mtx_namelen == pmtx2->mtx_namelen)
        && (!(_memicmp(pmtx1->mtx_name,
                       pmtx2->mtx_name,
                       pmtx1->mtx_namelen)))) {
        // Names are obviously the same
        return TRUE;
    }
    else if (   (pmtx1->mtx_namelen == pmtx2->mtx_namelen + 1)
             && ('.'  == pmtx1->mtx_name[pmtx2->mtx_namelen - 1])
             && ('\0' == pmtx1->mtx_name[pmtx2->mtx_namelen])
             && ('\0' == pmtx2->mtx_name[pmtx2->mtx_namelen - 1])
             && (!(_memicmp(pmtx1->mtx_name,
                            pmtx2->mtx_name,
                            pmtx2->mtx_namelen - 1)))) {
        // Names are the same, except pmtx1 is absolute (it ends in . NULL,
        // while pmtx2 ends in NULL)
        return TRUE;
    }
    else if (   (pmtx1->mtx_namelen + 1 == pmtx2->mtx_namelen)
             && ('.'  == pmtx2->mtx_name[pmtx1->mtx_namelen - 1])
             && ('\0' == pmtx2->mtx_name[pmtx1->mtx_namelen])
             && ('\0' == pmtx1->mtx_name[pmtx1->mtx_namelen - 1])
             && (!(_memicmp(pmtx1->mtx_name,
                            pmtx2->mtx_name,
                            pmtx1->mtx_namelen - 1)))) {
        // Names are the same, except pmtx2 is absolute (it ends in . NULL,
        // while pmtx1 ends in NULL)
        return TRUE;
    }
    return FALSE;

} /* MtxSame */


DWORD
InitDRA(
    THSTATE *pTHS
    )

/*++

Routine Description:

    Start the replication subsystem.

Arguments:

    None.

Return Values:

    0 (success) or Win32 error.

--*/

{
    // Determine periodic, startup, and mail requirements for this DSA
    return InitDRATasks( pTHS );
}

USHORT
InitFreeDRAThread (
    THSTATE *pTHS,
    USHORT transType
    )

/*++

Routine Description:

// InitFreeDRAThread
//
// Sets up a DRA thread so that it has a thread state and a heap. This is
// called by threads in the DRA that do not come from RPC.

Arguments:

    pTHS -
    transType -

Return Value:

    USHORT -

--*/

{
    pTHS->fDRA = TRUE;
    BeginDraTransaction(transType);
    return 0;
} /* InitFreeDRAThread  */

void
CloseFreeDRAThread(
    THSTATE *pTHS,
    BOOL fCommit
    )

/*++

Routine Description:

// CloseFreeDRAThread
//
// This function undoes the actions of InitFreeDRAThread.
// Called by threads that do not come from RPC

Arguments:

    pTHS -
    fCommit -

Return Value:

    None

--*/

{
    EndDraTransaction(fCommit);

    DraReturn(pTHS, 0);
} /* CloseFreeDRAThread */

void
InitDraThreadEx(
    THSTATE **ppTHS,
    DWORD dsid
    )

/*++

Routine Description:

// InitDraThread - Initialize a thread for the replicator.
//
// Sets thread up for DB transactions, Calls DSAs InitTHSTATE for memory
// management and DB access
//
//  Returns: void
//
//  Notes: If a successful call to InitDraThread is made, then a call to
//  DraReturn should also be made before the thread is exited.

Arguments:

    ppTHS -
    dsid -

Return Value:

    None

--*/

{
    // InitTHSTATE gets or allocates a thread state and then sets up
    // for DB access via DBInitThread.

    // Pass NULL to InitTHSTATE so that it uses THSTATE's internal
    // ppoutBuf

    if ((*ppTHS = _InitTHSTATE_(CALLERTYPE_DRA, dsid)) == NULL) {
        DraErrOutOfMem();
    }
    (*ppTHS)->fDRA = TRUE;
} /* InitDraThreadEx */


DWORD
DraReturn(
    THSTATE *pTHS,
    DWORD status
    )

/*++

Routine Description:

// DraReturn - Clean up THSTATE before exiting thread.
//
// Zero the pointer to the DBlayer structure DBPOS, although this
// should be zero if everything is working correctly.

Arguments:

    pTHS -
    status -

Return Value:

    DWORD -

--*/

{

    pTHS->pDB = NULL;

    return status;
} /* DraReturn */

void
BeginDraTransactionEx(
    USHORT transType,
    BOOL fBypassUpdatesEnabledCheck
    )

/*++

Routine Description:

BeginDraTransaction - start a DRA transaction.

Arguments:

    transType -

Return Value:

    None

--*/

{
    if (pTHStls->fSyncSet) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    if (transType == SYNC_WRITE) {
        // Inhibit update operations if the schema hasn't been loaded
        // yet or if we had a problem loading

        if (!fBypassUpdatesEnabledCheck && !gUpdatesEnabled) {
            DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
        }
    }

    SyncTransSet(transType);
} /* BeginDraTransactionEx */


USHORT
EndDraTransaction(
    BOOL fCommit
    )

/*++

Routine Description:

EndDraTransaction - End a DRA transaction. If fCommit is TRUE
      the transaction is committed to the database.

Arguments:

    None

Return Value:

    None

--*/

{
    SyncTransEnd(pTHStls, fCommit);

    return 0;
}

BOOL
IsSameSite(
    THSTATE *         pTHS,
    DSNAME *          pServerName1,
    DSNAME *          pServerName2
    )
/*++

Routine Description:

IsSameSite - if pServerName1 and pServerName2 are in the same site then return TRUE, else FALSE

Arguments:

    pServerName1 -
    pServerName2 -
    pTHS -

Return Value:

    TRUE or FALSE;

--*/
{
    DSNAME *          pSiteName = NULL;
    DWORD             err = 0;
    BOOL              fIsSameSite = FALSE;

    if ((!pServerName1) || (!pServerName2)) {
    return FALSE; //either null means they aren't in the same site!
    }

    pSiteName = THAllocEx(pTHS,pServerName1->structLen); 
    err = TrimDSNameBy(pServerName1, 2, pSiteName);
    if (err) {
    if (pSiteName) {
        THFreeEx(pTHS,pSiteName);
    }
    return FALSE; //can't match sites
    }

    if (NamePrefix(pSiteName, pServerName2)) {
    fIsSameSite = TRUE;
    }
    
    THFreeEx(pTHS,pSiteName);
    return fIsSameSite;
}

BOOL
IsMasterForNC(
    DBPOS *           pDB,
    DSNAME *          pServer,
    DSNAME *          pNC
    )
/*++

Routine Description:

IsMasterForNC - If pServer is a master for pNC, return TRUE, else FALSE

Arguments:

    pServer - 
    pNC -

Return Value:

    TRUE or FALSE;

--*/
{
    DWORD err = 0;
    BOOL      fIsMasterForNC = FALSE; 
    void *    pVal;
    DSNAME *  pMasterNC = NULL;
    ULONG     cLenVal;
    ULONG     ulAttValNum = 1;

    if (!pServer){
    return FALSE;  //Null is not a Master for any NC
    }

    err = DBFindDSName(pDB, pServer);

    while (err==ERROR_SUCCESS) { 
    
    err = DBGetAttVal(pDB, ulAttValNum++, ATT_HAS_MASTER_NCS, 0, 0, &cLenVal, (UCHAR **)&pVal); 
    //err - DBGetNextLinkVal_AC(pDB, 
    if (err==ERROR_SUCCESS) {
        if (NameMatched(pVal,pNC)) {
        fIsMasterForNC=TRUE;
        THFreeEx(pDB->pTHS,pVal);
        break;
        }
        THFreeEx(pDB->pTHS,pVal);
    }
    }
    return fIsMasterForNC;
}

DWORD
CheckReplicationLatencyForNC(
    DBPOS *           pDB,
    DSNAME *          pNC,
    BOOL              fMasterNC
    )

/*++

Routine Description:

CheckReplicationLatencyForNC - check's the UTD for pNC on this server and logs events if latency 
        exceeds limits.  

Arguments:

    pNC - NC for which to check latency
    pDB - 
    pTHS -
    fMasterNC - if this server (the one executing the code) is a Master for this NC.  (whether or not
                this server is a master for this NC affects the UTD data)

Return Value:

    Win32 Error Codes

--*/

{   
    DWORD                   dwNumRequested = 0xFFFFFFFF;
    ULONG                   dsThresholdTwoMonth = DAYS_IN_SECS*56; //these are coarse warnings and
    ULONG                   dsThresholdMonth = DAYS_IN_SECS*28; //do not need to be exactly a month for all months.
    ULONG                   dsThresholdWeek = DAYS_IN_SECS*7;
    ULONG                   dsThresholdDay = DAYS_IN_SECS;
    ULONG                   cOverThresholdTombstoneLifetime = 0;
    ULONG                   cOverThresholdMonth = 0;
    ULONG                   cOverThresholdTwoMonth = 0;
    ULONG                   cOverThresholdWeek = 0;
    ULONG                   cOverThresholdDay = 0;
    ULONG                   cOverThresholdDaySameSite = 0;
    DWORD                   ret = 0;
    DS_REPL_CURSORS_3W *    pCursors3;
    DWORD                   iCursor;
    DWORD                   dbErr = 0;
    DSTIME                  dsTimeSync;
    DSTIME                  dsTimeNow;
    LONG                    dsElapsed;
    ULONG                   ulTombstoneLifetime;
    BOOL                    fLogAsError = FALSE;
    DSNAME *                pServerDN;
    void *                  pVal;
    ULONG                   cLenVal;
    BOOL                    fIsServerMasterForNC = FALSE;

    //get the tombstone lifetime so we can report how many
    //dc's haven't replicated with us in over that value.
    ret = DBFindDSName(pDB, gAnchor.pDsSvcConfigDN);
    if (!ret) { 
    ret = DBGetAttVal(pDB, 1, ATT_TOMBSTONE_LIFETIME, 0, 0, &cLenVal,(UCHAR **) &pVal);
    }
    
    if (ret || !pVal) {
    ulTombstoneLifetime = DEFAULT_TOMBSTONE_LIFETIME*DAYS_IN_SECS;
    }
    else
    {
    ulTombstoneLifetime = (*(ULONG *)pVal)*DAYS_IN_SECS;
    }
    
    ret = draGetCursors(pDB->pTHS,
            pDB,
            pNC,
            DS_REPL_INFO_CURSORS_3_FOR_NC,
            0,
            &dwNumRequested,
            &pCursors3);

    if (!ret) {
    for (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {    

        if (pCursors3->rgCursor[iCursor].pszSourceDsaDN) {
        // calculate times to check latency
        FileTimeToDSTime(pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess, &dsTimeSync);
        dsTimeNow = GetSecondsSince1601();
        dsElapsed = (LONG) (dsTimeNow - dsTimeSync); 

        // check latency
        if (dsElapsed>(LONG)dsThresholdDay) {
            // this server is latent at least 1 day
            pServerDN = DSNameFromStringW(pDB->pTHS, pCursors3->rgCursor[iCursor].pszSourceDsaDN);      
            if (!fMasterNC) {   
            fIsServerMasterForNC = IsMasterForNC(pDB, pServerDN, pNC);   
            }    
            
             // if this DC is not a master for this NC, then only report latencies for
             // DC's in the cursor which are masters for the NC , since GC copies are
             // not guarenteed to be kept updated in the vector
            if (  
            (!fMasterNC && 
             fIsServerMasterForNC)
             ||
             (fMasterNC)
             ) {
            
            //day checks
            cOverThresholdDay++;   
            if (IsSameSite(pDB->pTHS, gAnchor.pDSADN, pServerDN)) {
                cOverThresholdDaySameSite++;
                fLogAsError=TRUE;
            }

            //week checks
            if (dsElapsed>(LONG)dsThresholdWeek) {
                cOverThresholdWeek++;
                fLogAsError=TRUE;
            }

            //month checks
            if (dsElapsed>(LONG)dsThresholdMonth) {
                cOverThresholdMonth++;
            }   

            //two month checks
            if (dsElapsed>(LONG)dsThresholdTwoMonth) { 
                cOverThresholdTwoMonth++;
            }

            //tombstone lifetime checks
            if (dsElapsed>(LONG)ulTombstoneLifetime) {
                cOverThresholdTombstoneLifetime++;   
                fLogAsError=TRUE;
            }  
            }
            THFreeEx(pDB->pTHS, pServerDN);
        }
        }
        else {
        // retired invocationID, do not track
        }
    } //for  (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {    

    if (cOverThresholdTombstoneLifetime+
        cOverThresholdTwoMonth+
        cOverThresholdMonth+
        cOverThresholdWeek+
        cOverThresholdDay) {
        if (fLogAsError) {
        if (cOverThresholdTombstoneLifetime+
            cOverThresholdTwoMonth+
            cOverThresholdMonth+
            cOverThresholdWeek) {
            // Serious latency problem, log as an error!
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_REPLICATION_LATENCY_ERRORS_FULL,
                  szInsertDN(pNC),
                  szInsertUL(cOverThresholdDay),
                  szInsertUL(cOverThresholdWeek),
                  szInsertUL(cOverThresholdMonth),
                  szInsertUL(cOverThresholdTwoMonth),
                  szInsertUL(cOverThresholdTombstoneLifetime),
                  szInsertUL((ULONG)ulTombstoneLifetime/(DAYS_IN_SECS)),
                  NULL);
        }
        else {  
            // Serious latency problem, cOverThresholdDay in the same site.
            // log as error!
            LogEvent(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_REPLICATION_LATENCY_ERRORS,
                  szInsertDN(pNC),
                  szInsertUL(cOverThresholdDay),   
                  szInsertUL(cOverThresholdDaySameSite));
        }
        }
        else { 
        // Warning
        LogEvent(DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_REPLICATION_LATENCY_WARNINGS,
              szInsertDN(pNC),
              szInsertUL(cOverThresholdDay),   
              NULL);
        }
    }
    draFreeCursors(pDB->pTHS,DS_REPL_INFO_CURSORS_3_FOR_NC,(void *)pCursors3);
    }
    return ret;
}

DWORD
CheckReplicationLatencyHelper() 
/*++

Routine Description:

Check the latency for all naming contexts and log overlimit latencies (called by CheckREplicationLatency
which is a task queue function)

Arguments:

    None

Return Value:

    Win32 Error Codes

--*/
{
    DWORD                   ret = 0;
    DWORD                   ret2 = 0;
    DWORD                   dbErr = 0;
    DSNAME *                pNC;
    NCL_ENUMERATOR          nclMaster, nclReplica;
    NAMING_CONTEXT_LIST *   pNCL;
    THSTATE *               pTHS=pTHStls;
    DBPOS *                 pDB = NULL;  


    InitDraThread(&pTHS);
    //for each NC, check the status of our replication with all masters.
    NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC);
    NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC);
    
    DBOpen2(TRUE, &pDB);
    if (!pDB)
    {
        DPRINT(1, "Failed to create a new data base pointer \n"); 
        DRA_EXCEPT(DRAERR_InternalError, 0); 
    }
    __try {
     
    //check latencies for all NC's
    //master NC's
    while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
        pNC = pNCL->pNC;
        ret = CheckReplicationLatencyForNC(pDB, pNC, TRUE); 
        ret2 = ret2 ? ret2 : ret;
    }
    //and replica NC's
    while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
        pNC = pNCL->pNC; 
        ret = CheckReplicationLatencyForNC(pDB, pNC, FALSE);   
        ret2 = ret2 ? ret2 : ret;
    }
    } __finally {
        DBClose(pDB, TRUE);
    }

    DraReturn(pTHS, 0);
    return ret2;

} /* CheckReplicationLatencyHelper */

void
CheckReplicationLatency(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration) {
    DWORD err;
    __try {
    err = CheckReplicationLatencyHelper();
    if (err) { 
        DPRINT1(1,"A replication status query failed with status %d!\n", err);
    }
    }
    __finally {
    /* Set task to run again */
    if(!eServiceShutdown) {
        *ppvNext = NULL;
        *pcSecsUntilNextIteration = gulReplLatencyCheckInterval;
    }
    }
    (void) pv;   // unused
}

DWORD
FindNC(
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  ULONG               ulOptions,
    OUT SYNTAX_INTEGER *    pInstanceType   OPTIONAL
    )
/*++

Routine Description:

    Position on the given object and verify it is an NC of the correct type.

Arguments:

    pTHS (IN)

    pNC (IN) - Name of the NC.

    ulOptions (IN) - One or more of the following bits:
        FIND_MASTER_NC - Writeable NCs are acceptable.
        FIND_REPLICA_NC - Read-only NCs are acceptable.

Return Value:

    0 - success
    DRAERR_BadDN - object does not exist
    DRAERR_BadNC - Instance type does not match

--*/
{
    SYNTAX_INTEGER it;

    // Check that the object exists
    if (FindAliveDSName(pDB, pNC)) {
        return DRAERR_BadDN;
    }

    // See if it is the required instance type
    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
    Assert(ISVALIDINSTANCETYPE(it));

    if (NULL != pInstanceType) {
        *pInstanceType = it;
    }

    if (FPrefixIt(it)
        && (((ulOptions & FIND_MASTER_NC) && (it & IT_WRITE))
            || ((ulOptions & FIND_REPLICA_NC) && !(it & IT_WRITE)))) {
        return 0;
    }

    return DRAERR_BadNC;
} /* FindNC */


void
GetExpectedRepAtt(
    IN  DBPOS * pDB,
    IN  ATTRTYP type,
    OUT VOID *  pOutBuf,
    IN  ULONG   size
    )

/*++

Routine Description:

 GetExpectedRepAtt - Get the external form of the value of the attribute
*       specified by 'type' in the current record. If it is a multi-valued
*       attribute we only get the first value. The value is stored at
*       'pOutBuf'. If the attribute is not present (or has no value) make
*       an error log entry and generate an exception.

Arguments:

    pDB -
    type -
    pOutBuf -
    size -

Return Value:

    None

--*/

{
    ULONG len;
    if (DBGetAttVal(pDB, 1, type,
                    DBGETATTVAL_fCONSTANT, size, &len,
                    (PUCHAR *)&pOutBuf)) {
        DraErrMissingAtt(GetExtDSName(pDB), type);
    }
} /* GetExpectedRepAtt */


REPLICA_LINK *
FixupRepsFrom(
    REPLICA_LINK *prl,
    PDWORD       pcbPrl
    )
/*++

Routine Description:

    Converts REPLICA_LINK structures as read from disk (in repsFrom attribute)
    to current version.

Arguments:

    prl-- In repsFrom as read from disk to convert
    pcbPrl -- IN: size of pre-allocated memory of prl
              OUT: if changed, new size

Return Value:
    Success: modified (& possible re-allocated) RL
    Error: Raises exception

Remarks:
    Must sync changes w/ KCC_LINK::Init.
      Todo-- make available to KCC as well.

--*/
{

    THSTATE *pTHS=pTHStls;
    DWORD dwCurrSize;

    if (prl->V1.cbOtherDraOffset < offsetof(REPLICA_LINK, V1.rgb)) {
        // The REPLICA_LINK structure has been extended since this value
        // was created.  Specifically, it's possible to add new fields to
        // the structure before the dynamically sized rgb field.  In this
        // case, we shift the contents of what was the rgb field to the
        // new offset of the rgb field, then zero out the intervening
        // elements.
        DWORD cbNewFieldsSize = offsetof(REPLICA_LINK, V1.rgb) - prl->V1.cbOtherDraOffset;

        // old formats:
        //  -  missing the uuidTransportObj field (realy old).
        //  -  w/out what used to be dwDrsExt (now dwReserved1)
        Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.uuidTransportObj) ||
               prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.dwReserved1) );

        DPRINT2(0, "Converting repsFrom %s on %s from old REPLICA_LINK format.\n",
                RL_POTHERDRA(prl)->mtx_name, GetExtDN(pTHS, pTHS->pDB));

        // Expand the structure and shift the contents of what was the
        // rgb field in the old format to where the rgb field is in the new
        // format.
        dwCurrSize = prl->V1.cb + cbNewFieldsSize;
        if (*pcbPrl < dwCurrSize) {
            //
            // re-alloc only if we don't have enough buffer space
            // already
            //
            prl = THReAllocEx(pTHS, prl, dwCurrSize);
            // changed current buffer size
            *pcbPrl = dwCurrSize;
        }
        MoveMemory(prl->V1.rgb, prl->V1.rgb - cbNewFieldsSize,
                   prl->V1.cb - prl->V1.cbOtherDraOffset);

        // Zero out the new fields.
        memset(((BYTE *)prl) + prl->V1.cbOtherDraOffset, 0, cbNewFieldsSize);

        // And reset the embedded offsets and structure size.
        prl->V1.cbOtherDraOffset = offsetof(REPLICA_LINK, V1.rgb);
        prl->V1.cb += cbNewFieldsSize;
        if ( 0 != prl->V1.cbPASDataOffset ) {
            // struct was extended while there's PAS data in it.
            Assert(COUNT_IS_ALIGNED(cbNewFieldsSize, ALIGN_DWORD));
            prl->V1.cbPASDataOffset += cbNewFieldsSize;
        }
    }
    else if ( prl->V1.cbOtherDraOffset != offsetof(REPLICA_LINK, V1.rgb) ) {
            Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.rgb));
            DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    VALIDATE_REPLICA_LINK_VERSION(prl);
    VALIDATE_REPLICA_LINK_SIZE(prl);

    return prl;
}






ULONG
FindDSAinRepAtt(
    DBPOS *                 pDB,
    ATTRTYP                 attid,
    DWORD                   dwFindFlags,
    UUID *                  puuidDsaObj,
    UNALIGNED MTX_ADDR *    pmtxDRA,
    BOOL *                  pfAttExists,
    REPLICA_LINK **         pprl,
    DWORD *                 pcbRL
    )

/*++

Routine Description:

//
// Find the REPLICA_LINK corresponding to the given DRA in the specified
// attribute of the current object (presumably an NC head).
//

Arguments:

    pDB -
    attid -
    dwFindFlags -
    puuidDsaObj -
    pmtxDRA -
    pfAttExists -
    pprl -
    pcbRL -

Return Value:

    ULONG -

--*/

{
    THSTATE        *pTHS=pDB->pTHS;
    ULONG           draError;
    ULONG           dbError;
    DWORD           iVal;
    REPLICA_LINK *  prl;
    DWORD           cbRLSizeAllocated;
    DWORD           cbRLSizeUsed;
    BOOL            fFound;
    BOOL            fAttExists;
    BOOL            fFindByUUID = dwFindFlags & DRS_FIND_DSA_BY_UUID;

    // Does pmtxDRA really need to be UNALIGNED?
    Assert( 0 == ( (DWORD_PTR) pmtxDRA ) % 4 );

    // Validate parameters.
    if ((NULL == pprl)
        || (NULL == pcbRL)
        || (!fFindByUUID && (NULL == pmtxDRA))
        || (fFindByUUID && fNullUuid(puuidDsaObj))) {
        DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, 0);
    }

    // Find the matching REPLICA_LINK.
    iVal = 1;

    prl               = NULL;
    cbRLSizeUsed      = 0;
    cbRLSizeAllocated = 0;

    fAttExists = FALSE;

    fFound = FALSE;

    do
    {
        // Find the next candidate.
        dbError = DBGetAttVal(
                        pDB,
                        iVal++,
                        attid,
                        DBGETATTVAL_fREALLOC,
                        cbRLSizeAllocated,
                        &cbRLSizeUsed,
                        (BYTE **) &prl
                        );

        if ( 0 == dbError )
        {
            fAttExists = TRUE;

            VALIDATE_REPLICA_LINK_VERSION(prl);

            cbRLSizeAllocated = max( cbRLSizeAllocated, cbRLSizeUsed );

            Assert( prl->V1.cb == cbRLSizeUsed );
            Assert( prl->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( prl ) ) );

            // Does this link match?
            if ( fFindByUUID )
            {
                fFound = !memcmp(puuidDsaObj, &prl->V1.uuidDsaObj, sizeof(UUID));
            }
            else
            {
                fFound = MtxSame( pmtxDRA, RL_POTHERDRA( prl ) );
            }
        }
    } while ( ( 0 == dbError ) && !fFound );

    if (fFound) {
        if (DRS_FIND_AND_REMOVE & dwFindFlags) {
            // Remove this value.
            dbError = DBRemAttVal(pDB, attid, cbRLSizeUsed, prl);

            if (0 == dbError) {
                Assert(pTHS->fDRA);
                dbError = DBRepl(pDB, TRUE, DBREPL_fKEEP_WAIT, NULL,
                                 META_STANDARD_PROCESSING);
            }

            if (0 != dbError) {
                DRA_EXCEPT(DRAERR_DBError, dbError);
            }
        }

        prl = FixupRepsFrom(prl, &cbRLSizeAllocated);
        Assert(cbRLSizeAllocated >= prl->V1.cb);
    }
    else if (NULL != prl) {
        THFree( prl );
        prl = NULL;
        cbRLSizeUsed = 0;
    }

    *pprl  = prl;
    *pcbRL = cbRLSizeUsed;

    if ( NULL != pfAttExists )
    {
        *pfAttExists = fAttExists;
    }

    return fFound ? DRAERR_Success : DRAERR_NoReplica;
}     /* FindDSAinRepAtt */



ULONG
RepErrorFromPTHS(
    THSTATE *pTHS
    )

/*++

Routine Description:

RepErrorFromPTHS - Map a DSA error code into an appropriate DRA error code.
*       The error code is found in pTHS->errCode (which is left unchanged).
*       Note: Many DSA error codes should not occur when DSA routines are used
*       by the DRA, these all return DRAERR_InternalError.
*
*  Note:
*       No Alerts/Audit or Error Log entries are made as it is assumed this
*       has already been done by the appropriate DSA routine.

Arguments:

    pTHS -

Return Value:

    ULONG - The DRA error code.

--*/

{
    UCHAR *pString=NULL;
    DWORD cbString=0;

    // Log the full error details (the error string) in the log if requested
    // The goal is to capture which attribute failed
    // Internal errors are hard to debug so log the info all the time
    if (pTHS->errCode) {
        if(CreateErrorString(&pString, &cbString)) {
            LogEvent( DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DSA_OBJECT_FAILURE,
                      szInsertSz(pString),
                      NULL, NULL );
            THFree(pString);
        }
        DbgPrintErrorInfo();
    }

    switch (pTHS->errCode)
    {
    case 0:
        return 0;

    case attributeError:
        /*  schemas between two dsa dont match. */
        return DRAERR_InconsistentDIT;

    case serviceError:

        switch (pTHS->pErrInfo->SvcErr.problem)
        {
            case SV_PROBLEM_ADMIN_LIMIT_EXCEEDED:
                return DRAERR_OutOfMem;

            case SV_PROBLEM_BUSY:
                switch (pTHS->pErrInfo->SvcErr.extendedErr) {
                case ERROR_DS_OBJECT_BEING_REMOVED:
                    return ERROR_DS_OBJECT_BEING_REMOVED;
                case DIRERR_DATABASE_ERROR:
                    return ERROR_DS_DATABASE_ERROR;
                case ERROR_DS_SCHEMA_NOT_LOADED:
                    return ERROR_DS_SCHEMA_NOT_LOADED;
                default:
                    return DRAERR_Busy;
                };
                break;

            case SV_PROBLEM_WILL_NOT_PERFORM:
               // possible only if this is a schema NC sync and
               // a schema conflict is detected while validating
                switch (pTHS->pErrInfo->SvcErr.extendedErr) {
                   case ERROR_DS_DRA_SCHEMA_CONFLICT:
                       return DRAERR_SchemaConflict;
                   case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
                       return DRAERR_EarlierSchemaConflict;
                   default:
                       break;
               };
               break;

            default:
                break;
                /* fall through to DRAERR_InternalError */
        }

    }

    /* default */
    /* nameError */
    /* referalError */
    /* securityError */
    /* updError */
    /* None of these should happen to replicator */

    RAISE_DRAERR_INCONSISTENT( pTHS->errCode );

    return 0;
} /* RepErrorFromPTHS */


void
HandleRestore(
    void
    )

/*++

Routine Description:

If DSA has been restored from backup we need to do some
special processing, like changing it's replication identity.
This is required so that the changes made by this DC since
it was backedup can be replicated back.

Arguments:

    void -

Return Value:

    None

--*/

{

    LONG      lret;
    HKEY      hk;
    NTSTATUS  NtStatus;
    THSTATE * pTHS = pTHStls;

    if ( !DsaIsInstallingFromMedia() && DsaIsInstalling() )
    {
        // Nothing to do if not installed.
        gUpdatesEnabled = TRUE;
        return;
    }

    if (gfRestoring) {
        if (GetConfigParam(DSA_RESTORE_COUNT_KEY, &gulRestoreCount, sizeof(gulRestoreCount)))
        {
            // registry entry for restore count doesn't exist
            // set it to 1
            gulRestoreCount = 1;
        }
        else
        {
            // restore count successfully read from registry - increment it to signify the curren restore
            gulRestoreCount++;
        }

        // write the new restore count into the registry
        if (lret = SetConfigParam(DSA_RESTORE_COUNT_KEY, REG_DWORD, &gulRestoreCount, sizeof(gulRestoreCount)))
        {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }

        draRetireInvocationID(pTHS);
        DPRINT(0, "DS has been restored from a backup.\n");

        // At this point we have loaded the schema successfully and have given the DS a new
        // replication identity. We can enable updates now
        gUpdatesEnabled = TRUE;

        if ( !DsaIsInstallingFromMedia() ) {

            // Invalidate the RID range that came from backup to avoid possible duplicate account
            // creation
            NtStatus = SampInvalidateRidRange(TRUE);
            if (!NT_SUCCESS(NtStatus))
            {
                DRA_EXCEPT (DRAERR_InternalError, NtStatus);
            }
        }

        // Note: rsraghav We don't treat restore any different from a system
        // being down and rebooted for FSMO handling. When rebooted, if we hold
        // the FSMO role ownership, we will refuse to assume role ownership until
        // gfIsSynchronized is set to true (i.e. we have had the chance
        // to sync with at least one neighbor for each writeable NC)
        // Only exception is FSMO role ownership for PDCness. As MurliS
        // pointed out, incorrect FSMO role ownership for PDCness is self-healing
        // when replication kicks-in and is not necessarily damaging. So, we
        // don't do anything special to avoid PDCness until gfIsSynchronized
        // is set to TRUE.

        // Clear restore key value
        lret = RegCreateKey(HKEY_LOCAL_MACHINE,
                            DSA_CONFIG_SECTION,
                            &hk);

        if (lret != ERROR_SUCCESS) {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }
        // Clear key value

        lret = RegDeleteValue(hk, DSA_RESTORED_DB_KEY);
        if (lret != ERROR_SUCCESS) {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }

        lret = RegFlushKey (hk);
        if (lret != ERROR_SUCCESS) {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }

        // Close key

        lret = RegCloseKey(hk);
        if (lret != ERROR_SUCCESS) {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }

        // Finished handling restore
        gfRestoring = FALSE;
        gfJustRestored = TRUE;
    }
    else
    {
        gUpdatesEnabled = TRUE;
    }
} /* HandleRestore */


void
draRetireInvocationID(
    IN OUT  THSTATE *   pTHS
    )
/*++

Routine Description:

    Retire our current invocation ID and allocate a new one.

Arguments:

    pTHS (IN/OUT) - On return, pTHS->InvocationID holds the new invocation ID.

Return Values:

    None.  Throws exception on catastrophic failure.

--*/
{
    DWORD                   err;
    DBPOS *                 pDBTmp;
    NAMING_CONTEXT_LIST *   pNCL;
    USN_VECTOR              usnvec = {0};
    UUID                    invocationIdOld = pTHS->InvocationID;
    USN                     usnAtBackup;
    SYNTAX_INTEGER          it;
#if DBG
    CHAR                    szUuid[40];
#endif
    NCL_ENUMERATOR          nclEnum;

    // Reinitialize the REPL DSA Signature (i.e. the invocation id)
    InitInvocationId(pTHS, TRUE, &usnAtBackup);

    DPRINT1(0, "Retired previous invocation ID %s.\n",
            DsUuidToStructuredString(&invocationIdOld, szUuid));
    DPRINT1(0, "New invocation ID is %s.\n",
            DsUuidToStructuredString(&pTHS->InvocationID, szUuid));

    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DRA_INVOCATION_ID_CHANGED,
             szInsertUUID(&invocationIdOld),
             szInsertUUID(&pTHS->InvocationID),
             szInsertUSN(usnAtBackup));

    // Update our UTD vectors to show that we're in sync with changes we
    // made using our old invocation ID up through our highest USN at the
    // time we were backed up.
    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
#if DBG == 1
    Assert(NCLEnumeratorGetNext(&nclEnum));
    NCLEnumeratorReset(&nclEnum);
#endif

    usnvec.usnHighPropUpdate = usnvec.usnHighObjUpdate = usnAtBackup;

    DBOpen(&pDBTmp);
    __try {
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_MASTER_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                UpToDateVec_Improve(pDBTmp, &invocationIdOld, &usnvec, NULL);
            }
        }

        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_REPLICA_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                UpToDateVec_Improve(pDBTmp, &invocationIdOld, &usnvec, NULL);
            }
        }
    } __finally {
        DBClose(pDBTmp, !AbnormalTermination());
    }
}


DWORD
DirReplicaSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength
    )

/*++

Routine Description:

    Description

Arguments:

    ClientToken - the caller who presented the user/domain/password set
    User -
    Domain -
    Password -
    PasswordLength -

Return Value:

    DWORD -

--*/

{
    return DRSSetCredentials(ClientToken,
                             User, 
                             Domain, 
                             Password, 
                             PasswordLength);
} /* DirReplicaSetCredentials */

#if 0
void
DraDumpAcl (
            char *name,
            PACL input
            )
/*++
Description:

    Dump the contents of an acl (sacl or dacl) to the kernel debugger.
    This is a utility debug routine that might be of use in the future.

Arguments:

Return Values:

--*/
{
    ULONG i;
    ACL *acl = input;

    if (acl == NULL) {
        KdPrint(( "%s Acl is null\n", name ));
        return;
    } else {
        KdPrint(( "%s Acl:\n", name ));
    }

    KdPrint(( "\tRevision: %d\n", acl->AclRevision ));
    KdPrint(( "\tSbz1: %d\n", acl->Sbz1 ));
    KdPrint(( "\tSize: %d\n", acl->AclSize ));
    KdPrint(( "\tNo of Aces: %d\n", acl->AceCount ));
    KdPrint(( "\tSbz2: %d\n", acl->Sbz2 ));
    if (acl->AclSize == 0) {
        return;
    }
    if (acl->AceCount > 10) {
        KdPrint(("Ace Count illegal - returning\n"));
        return;
    }

    for( i = 0; i < acl->AceCount; i++ ) {
        ACE_HEADER *ace;
        KdPrint(( "\tAce %d:\n", i ));
        if (GetAce( input, i, &ace )) {
            KdPrint(( "\t\tType: %d\n", ace->AceType ));
            KdPrint(( "\t\tSize: %d\n", ace->AceSize ));
            KdPrint(( "\t\tFlags: %x\n", ace->AceFlags ));
            if (ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE) {
                ACCESS_ALLOWED_ACE *ace_to_dump = (ACCESS_ALLOWED_ACE *) ace;
                KdPrint(( "\t\tAccess Allowed Ace\n" ));
                KdPrint(( "\t\t\tMask: %x\n", ace_to_dump->Mask ));
                KdPrint(( "\t\t\tSid: %x\n", IsValidSid((PSID) &(ace_to_dump->SidStart)) ));
            } else {
                ACCESS_ALLOWED_OBJECT_ACE *ace_to_dump = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                PBYTE ptr = (PBYTE) &(ace_to_dump->ObjectType);
                KdPrint(( "\t\tAccess Allowed Object Ace\n" ));
                KdPrint(( "\t\t\tMask: %x\n", ace_to_dump->Mask ));
                KdPrint(( "\t\t\tFlags: %x\n", ace_to_dump->Flags ));

                if (ace_to_dump->Flags & ACE_OBJECT_TYPE_PRESENT)
                {
                    ptr += sizeof(GUID);
                }

                if (ace_to_dump->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    ptr += sizeof(GUID);
                }
                KdPrint(( "\t\t\tSid: %x\n", IsValidSid( (PSID)ptr ) ));
            }
        }
    }
} /* DumpAcl */
#endif


MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    )
/*++

Routine Description:

    Convert Unicode string to an MTX_ADDR.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    psz (IN) - String to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR, or NULL on failure.

--*/
{
    THSTATE *  pTHS = pTHStls;
    MTX_ADDR * pmtx;

    Assert(NULL != pTHS);

    __try {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, psz);
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        pmtx = NULL;
    }

    return pmtx;
}


MTX_ADDR *
MtxAddrFromTransportAddrEx(
    IN  THSTATE * pTHS,
    IN  LPWSTR    psz
    )
/*++

Routine Description:

    Convert Unicode string to an MTX_ADDR.

Arguments:

    pTHS (IN)

    psz (IN) - String to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR.  Throws exception on failure.

--*/
{
    DWORD       cch;
    MTX_ADDR *  pmtx;

    Assert(NULL != psz);

    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, NULL, 0, NULL, NULL);
    if (0 == cch) {
        DRA_EXCEPT(DRAERR_InternalError, GetLastError());
    }

    // Note that cch includes the null terminator, whereas MTX_TSIZE_FROM_LEN
    // expects a count that does *not* include the null terminator.

    pmtx = (MTX_ADDR *) THAllocEx(pTHS, MTX_TSIZE_FROM_LEN(cch - 1));
    pmtx->mtx_namelen = cch;

    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, pmtx->mtx_name, cch, NULL,
                              NULL);
    if (0 == cch) {
        DRA_EXCEPT(DRAERR_InternalError, GetLastError());
    }

    Assert(cch == pmtx->mtx_namelen);
    Assert(L'\0' == pmtx->mtx_name[cch - 1]);

    return pmtx;
}


LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    )
/*++

Routine Description:

    Convert MTX_ADDR to a Unicode string.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    pmtx (IN) - MTX_ADDR to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR, or NULL on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    LPWSTR    psz;

    Assert(NULL != pTHS);

    __try {
        psz = UnicodeStringFromString8(CP_UTF8, pmtx->mtx_name, -1);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        psz = NULL;
    }

    return psz;
}


LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    )
/*++

Routine Description:

    Convert DSNAME of ntdsDsa object to its GUID-based DNS name.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    pDN (IN) - DSNAME to convert.

Return Values:

    A pointer to the DNS name, or NULL on failure.

--*/
{
    LPWSTR psz;

    __try {
        psz = DSaddrFromName(pTHStls, pDN);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        psz = NULL;
    }

    return psz;
}


DSNAME *
DSNameFromStringW(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszDN
    )
{
    DWORD     cch;
    DWORD     cb;
    DSNAME *  pDSName;

    Assert(NULL != pszDN);

    cch = wcslen(pszDN);
    cb = DSNameSizeFromLen(cch);

    pDSName = THAllocEx(pTHS, cb);
    pDSName->structLen = cb;
    pDSName->NameLen = cch;
    memcpy(pDSName->StringName, pszDN, cch * sizeof(WCHAR));

    return pDSName;
}

DWORD
AddSchInfoToPrefixTable(
    IN THSTATE *pTHS,
    IN OUT SCHEMA_PREFIX_TABLE *pPrefixTable
    )
/*++
    Routine Description:
       Read the schemaInfo property on the schema container and add it
       to the end of the prefix table as an extra prefix

       NOTE: This is called from the rpc routines to piggyback the
             schema info on to the prefix table. However, the prefix table
             is passed to these routine from the dra code by value, and not
             by var (that is, the structure is passed itself, not a pointer
             to it). The structure is picked up from the thread state's
             schema pointer. So, when we add the new prefix, we have to
             make sure it affects only this routine, and doesn't mess up
             memory pointed to by global pointers accessed by this structure.
             In short, do not allocate the SCHEMA_PREFIX_TABLE structure
             itself (since the function has a copy of the global structure and
             not the global structure itself), but fresh-alloc and copy
             any other pointer in it

    Arguments:
       pTHS: pointer to thread state to get schema pointer (to get schema info
             from
       pPrefixTable: pointer the SCHEMA_PREFIX_TABLE to modify

   Return Value:
       0 on success, non-0 on error
--*/
{
    DWORD err=0, i;
    DBPOS *pDB;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    ULONG cLen, cBuffLen = SCHEMA_INFO_LENGTH;
    UCHAR *pBuf = THAllocEx(pTHS,SCHEMA_INFO_LENGTH);
    PrefixTableEntry *pNewEntry, *pSrcEntry;

    // Read the schema info property from the schema container
    // Since we are sending changes from the dit, send the schemaInfo
    // value from the dit even though we have a cached copy in schemaptr

    DBOpen2(TRUE, &pDB);

    __try  {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
            // Read the current version no., if any
            err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fCONSTANT,
                                 cBuffLen, &cLen, (UCHAR **) &pBuf);

            switch (err) {
                case DB_ERR_NO_VALUE:
                   // we will send a special string starting with
                   // value 0xFF, no valid schemainfo value can be
                   // this (since they start with 00)
                   memcpy(pBuf, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH);
                   cLen = SCHEMA_INFO_LENGTH;
                   err = 0;
                   break;
                case 0:
                   // success! we got the value in Buffer
                   Assert(cLen == SCHEMA_INFO_LENGTH);
                   //
                   // Compare DIT & cache schema info. Reject if no match
                   // schema mismatch (see bug Q452022)
                   //
                   if (memcmp(pBuf, ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo, SCHEMA_INFO_LENGTH)) {
                       // mismatch
                       err = DRAERR_SchemaInfoShip;
                       __leave;
                   }
                   break;
                default:
                   // Some other error!
                   __leave;
            } /* switch */
       }
    }
    __finally {
        if (err == 0) {
           fCommit = TRUE;
        }
        DBClose(pDB,fCommit);
    }

    if (err) {

       THFreeEx(pTHS,pBuf);
       return err;
    }

    // No error. Add the schemainfo as an extra prefix
    // First, save off the pointer to the existing prefixes so that it is
    // still accessible to copy from

    pSrcEntry = pPrefixTable->pPrefixEntry;


    // Now allocate space for new prefix entries, which is old ones plus 1
    pPrefixTable->pPrefixEntry =
         (PrefixTableEntry *) THAllocEx(pTHS, (pPrefixTable->PrefixCount + 1)*(sizeof(PrefixTableEntry)) );
    if (!pPrefixTable->pPrefixEntry) {
        MemoryPanic((pPrefixTable->PrefixCount + 1)*sizeof(PrefixTableEntry));
        return ERROR_OUTOFMEMORY;
    }

    pNewEntry = pPrefixTable->pPrefixEntry;

    // Copy the existing prefixes, if any
    if (pPrefixTable->PrefixCount > 0) {
        for (i=0; i<pPrefixTable->PrefixCount; i++) {
            pNewEntry->ndx = pSrcEntry->ndx;
            pNewEntry->prefix.length = pSrcEntry->prefix.length;
            pNewEntry->prefix.elements = THAllocEx(pTHS, pNewEntry->prefix.length);
            if (!pNewEntry->prefix.elements) {
                MemoryPanic(pNewEntry->prefix.length);
                return ERROR_OUTOFMEMORY;
            }
            memcpy(pNewEntry->prefix.elements, pSrcEntry->prefix.elements, pNewEntry->prefix.length);
            pNewEntry++;
            pSrcEntry++;
        }
    }

    // copy schema info as the extra prefix. ndx field is not important
    pNewEntry->prefix.length = SCHEMA_INFO_LENGTH;
    pNewEntry->prefix.elements = THAllocEx(pTHS, SCHEMA_INFO_LENGTH);
    if (!pNewEntry->prefix.elements) {
        MemoryPanic(SCHEMA_INFO_LENGTH);
        return ERROR_OUTOFMEMORY;
    }
    Assert(cLen == SCHEMA_INFO_LENGTH);
    memcpy(pNewEntry->prefix.elements, pBuf, SCHEMA_INFO_LENGTH);
    pPrefixTable->PrefixCount++;

    THFreeEx(pTHS,pBuf);
    return 0;
}

VOID
StripSchInfoFromPrefixTable(
    IN SCHEMA_PREFIX_TABLE *pPrefixTable,
    OUT PBYTE pSchemaInfo
    )
/*++
    Routine Description:
       Strip the last prefix from the prefix table and copy it to
       the schema info pointer

    Arguments:
       pPrefixTable: pointer the SCHEMA_PREFIX_TABLE to modify
       pSchemaInfo: Buffer to hold the schema info. Must be pre-allocated
                     for SCHEMA_INFO_LEN bytes

   Return Value:
       None
--*/
{

    // Must be at least one prefix (the schemaInfo itself)
    Assert(pPrefixTable && pPrefixTable->PrefixCount > 0);

    memcpy(pSchemaInfo, (pPrefixTable->pPrefixEntry)[pPrefixTable->PrefixCount-1].prefix.elements, SCHEMA_INFO_LENGTH);
    pPrefixTable->PrefixCount--;

    // no need to actually take the prefix out, the decrement in prefix count
    // will cause it to be ignored.
}

#define ZeroString "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

// DO NOT CHANGE THE ORDER OF THE PARAMS TO memcmp!
#define NEW_SCHEMA_IS_BETTER(_newver, _curver, _newinfo, _curinfo) \
    (   (_newver > _curver) \
     || ((_newver == _curver) && (memcmp(_curinfo, _newinfo, SCHEMA_INFO_LENGTH) > 0)) )

BOOL
CompareSchemaInfo(
    IN THSTATE *pTHS,
    IN PBYTE pSchemaInfo,
    OUT BOOL *pNewSchemaIsBetter OPTIONAL
    )
/*++
    Routine Description:
       Compares the passed in schema info blob with the schema info on
       the schema container

    Arguments:
       pTHS: pointer to thread state to get schema pointer (to get schema info
             from
       pSchemaInfo: pointer the schema info blob of size SCHEMA_INFO_LENGTH
       pNewSchemaIsBetter - If not NULL, then if this function returns
           FALSE then *pNewSchemaIsBetter is set to
               TRUE  - New schema is "better" than current schema
               FALSE - New schema is not better than current schema
           If NULL, it is ignored.
           If this funtion returns TRUE, it is ignored.

    Return Value:
       TRUE if matches, FALSE if not

       If FALSE and pNewSchemaIsBetter is not NULL then *pNewSchemaIsBetter is set to
           TRUE  - New schema is "better" than current schema
           FALSE - New schema is not better than current schema
--*/
{
    DWORD err=0;
    DWORD currentVersion, newVersion;
    BOOL fNoVal = FALSE;

    DPRINT(1,"Comparing SchemaInfo values\n");

    // must have a schema info passed in
    Assert(pSchemaInfo);

    if ( memcmp(pSchemaInfo, ZeroString, SCHEMA_INFO_LENGTH) == 0 ) {
       // no schema info value. The other side probably doesn't support
       // sending the schemaInfo value
       return TRUE;
    }

    // Compare the schemaInfo with the schemaInfo cached in the schema pointer
    // Note that if schemaInfo attribute is not present on the schema container
    // the default invalid info is already cached.
    // It is probably more accurate to read the schemaInfo off the dit
    // and compare, but we save a database access here. The only bad effect
    // of using the one in the cache is that if schema changes are going
    // on, this may be stale, giving false failures. Since schema changes
    // are rare, most of the time this will be uptodate.

    if (memcmp(pSchemaInfo, ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo, SCHEMA_INFO_LENGTH)) {
        // mismatch

        // If requested, determine if new schema is better (greater
        // version or versions match but new guid is lesser) than the
        // current schema.
        if (pNewSchemaIsBetter) {
            // Must be DWORD aligned for ntohl
            memcpy(&newVersion, &pSchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(newVersion));
            newVersion = ntohl(newVersion);
            memcpy(&currentVersion, &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(currentVersion));
            currentVersion = ntohl(currentVersion);
            *pNewSchemaIsBetter = NEW_SCHEMA_IS_BETTER(newVersion,
                                                       currentVersion,
                                                       pSchemaInfo,
                                                       ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo);
        }
        return FALSE;
    }

    // matches
    return TRUE;
}


DWORD
WriteSchInfoToSchema(
    IN PBYTE pSchemaInfo,
    OUT BOOL *fSchInfoChanged
    )
{
    DBPOS *pDB;
    DWORD err=0, cLen=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    UCHAR *pBuf=NULL;
    DWORD currentVersion, newVersion;
    THSTATE *pTHS;
    BOOL fChanging = FALSE;

    // must have a schema info passed in
    Assert(pSchemaInfo);

    (*fSchInfoChanged) = FALSE;

    if ( (memcmp(pSchemaInfo, ZeroString, SCHEMA_INFO_LENGTH) == 0)
           || (memcmp(pSchemaInfo, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH) == 0) ) {
       // no schema info value, or invalid schema info value. The other side
       // probably doesn't support sending the schemaInfo value, or doesn't
       // have a schema info value
       return 0;
    }


    DBOpen2(TRUE, &pDB);
    pTHS=pDB->pTHS;

    __try  {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }

            // Get the current schema-info value

            currentVersion = 0;
            err = DBGetAttVal_AC(pDB, 1, ac, 0, 0, &cLen, (UCHAR **) &pBuf);

            switch (err) {
                case DB_ERR_NO_VALUE:
                   // no current version, nothing to do
                   break;
                case 0:
                   // success! we got the value in Buffer
                   Assert(cLen == SCHEMA_INFO_LENGTH);
                   // Read the version no. Remember that the version is stored
                   // in network data format (ntohl requires DWORD alignment)
                   memcpy(&currentVersion, &pBuf[SCHEMA_INFO_PREFIX_LEN], sizeof(currentVersion));
                   currentVersion = ntohl(currentVersion);
                   break;
                default:
                   // Some other error!
                   __leave;
            } /* switch */

            memcpy(&newVersion, &pSchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(newVersion));
            newVersion = ntohl(newVersion);
            DPRINT2(1, "WriteSchInfo: CurrVer %d, new ver %d\n", currentVersion, newVersion);

            if ( NEW_SCHEMA_IS_BETTER(newVersion,
                                      currentVersion,
                                      pSchemaInfo,
                                      pBuf) ) {
               // Either we are backdated, or the versions are the same, but
               // the whole value is defferent (this second case is possible
               // under bad FSMO whacking scenarios only). Write the value,
               // the higher guid being the tiebreaker

               fChanging = TRUE;

               if ((err= DBRemAtt_AC(pDB, ac)) != DB_ERR_SYSERROR) {
                   err = DBAddAttVal_AC(pDB, ac, SCHEMA_INFO_LENGTH, pSchemaInfo);
               }
               if (!err) {
                  err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
               }
            }

       }
       if (0 == err) {
         fCommit = TRUE;
       }
    }
    __finally {
        DBClose(pDB,fCommit);
    }

    if (fChanging && !err) {
       // We attempted to change the schInfo value and succeeded
       (*fSchInfoChanged) = TRUE;
    }
    else {
       (*fSchInfoChanged) = FALSE;
    }

    return err;
}

REPL_DSA_SIGNATURE_VECTOR *
DraReadRetiredDsaSignatureVector(
    IN  THSTATE *   pTHS,
    IN  DBPOS *     pDB
    )
/*++

Routine Description:

    Reads the retiredReplDsaSignatures attribute from the local ntdsDsa object,
    converting it into the most current structure format if necessary.

Arguments:

    pTHS (IN)

    pDB (IN) - Must be positioned on local ntdsDsa object.

Return Values:

    The current retired DSA signature list, or NULL if none.

    Throws DRA exception on catastrophic failures.

--*/
{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec = NULL;
    REPL_DSA_SIGNATURE_V1 *     pEntry;
    DWORD                       cb;
    DWORD                       i;
    DWORD                       err;

    // Should be positioned on our own ntdsDsa object.
    Assert(NameMatched(GetExtDSName(pDB), gAnchor.pDSADN));

    err = DBGetAttVal(pDB, 1, ATT_RETIRED_REPL_DSA_SIGNATURES,
                      0, 0, &cb, (BYTE **) &pSigVec);

    if (DB_ERR_NO_VALUE == err) {
        // No signatures retired yet.
        pSigVec = NULL;
    }
    else if (err) {
        // Read failed.
        Assert(!"Unable to read the retired DSA Signatures");
        LogUnhandledError(err);
        DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
    }
    else {
        Assert(pSigVec);

        if ((1 == pSigVec->dwVersion)
            && (cb == ReplDsaSignatureVecV1Size(pSigVec))) {
            // Current format -- no conversion required.
            ;
        }
        else {
            REPL_DSA_SIGNATURE_VECTOR_OLD * pOldVec;

            pOldVec = (REPL_DSA_SIGNATURE_VECTOR_OLD *) pSigVec;

            if (cb == ReplDsaSignatureVecOldSize(pOldVec)) {
                // Old (pre Win2k RTM RC1) format.  Convert it.
                cb = ReplDsaSignatureVecV1SizeFromLen(pOldVec->cNumSignatures);

                pSigVec = (REPL_DSA_SIGNATURE_VECTOR *) THAllocEx(pTHS, cb);
                pSigVec->dwVersion = 1;
                pSigVec->V1.cNumSignatures = pOldVec->cNumSignatures;

                for (i = 0; i < pOldVec->cNumSignatures; i++) {
                    pSigVec->V1.rgSignature[i].uuidDsaSignature
                        = pOldVec->rgSignature[i].uuidDsaSignature;
                    pSigVec->V1.rgSignature[i].timeRetired
                        = pOldVec->rgSignature[i].timeRetired;
                    Assert(0 == pSigVec->V1.rgSignature[i].usnRetired);
                }

                THFreeEx(pTHS, pOldVec);
            }
            else {
                Assert(!"Unknown retired DSA signature vector format!");
                LogUnhandledError(0);
                DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
            }
        }

#if DBG
        {
            USN usnCurrent = DBGetHighestCommittedUSN();

            Assert(pSigVec);
            Assert(1 == pSigVec->dwVersion);
            Assert(pSigVec->V1.cNumSignatures);
            Assert(cb == ReplDsaSignatureVecV1Size(pSigVec));

            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                Assert(0 != memcmp(&pTHS->InvocationID,
                                   &pEntry->uuidDsaSignature,
                                   sizeof(UUID)));
                Assert(usnCurrent >= pEntry->usnRetired);
            }
        }
#endif
    }

    return pSigVec;
}

VOID
draGetLostAndFoundGuid(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    OUT GUID *      pguidLostAndFound
    )
/*++

Routine Description:

    Retrieves the objectGuid of the LostAndFound container for the given NC.

Arguments:

    pTHS (IN)

    pNC (IN) - NC for which to retrieve LostAndFound container.

    pguidLostAndFound (OUT) - On return, holds the objectGuid of the
        appropriate LostAndFound container.

Return Values:

    None.  Throws DRA exception on catastrophic failure.

--*/
{
    DSNAME *  pLostAndFound;
    BOOL      fConfig;
    ULONG     ret;
    DWORD     cb;
    DBPOS *   pDBTmp;

    // Is this the config NC or a domain NC?
    // (Note that lost-and-found moves are not possible in
    // the schema NC, as it's (floating) single-mastered.)
    if (DsaIsRunning()) {
        fConfig = NameMatched(gAnchor.pConfigDN, pNC);
    }
    else {
        // Get the config DN from the registry
        DSNAME * pConfigDN = GetConfigDsName(CONFIGNCDNNAME_W);

        if (!pConfigDN) {
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        fConfig = NameMatched(pConfigDN, pNC);
        THFreeEx(pTHS, pConfigDN);
    }

    cb = DSNameSizeFromLen(pNC->NameLen
                           + MAX_RDN_SIZE
                           + MAX_RDN_KEY_SIZE
                           + 4);
    pLostAndFound = (DSNAME *) THAllocEx(pTHS, cb);

    // create the DSNAME of lost and found in this NC
    if (AppendRDN(pNC,
                  pLostAndFound,
                  cb,
                  fConfig ? LOST_AND_FOUND_CONFIG : LOST_AND_FOUND_DOMAIN,
                  fConfig ? LOST_AND_FOUND_CONFIG_LEN : LOST_AND_FOUND_DOMAIN_LEN,
                  ATT_COMMON_NAME)) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    DBOpen(&pDBTmp);
    __try {
        // set currency on the lost and found in this NC
        ret = DBFindDSName(pDBTmp, pLostAndFound);
        if (ret) {
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }

        // get the GUID of lost and found
        ret = DBGetSingleValue(pDBTmp,
                               ATT_OBJECT_GUID,
                               pguidLostAndFound,
                               sizeof(*pguidLostAndFound),
                               NULL);
        if (ret) {
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }
    }
    __finally {
        DBClose(pDBTmp, TRUE);
    }

    THFreeEx(pTHS, pLostAndFound);
}



DSNAME *
draGetServerDsNameFromGuid(
    IN THSTATE *pTHS,
    IN eIndexId idx,
    IN UUID *puuid
    )

/*++

Routine Description:

    Return the dsname of the object identified by the given invocation id
    or objectGuid.  The object is searched on the local configuration NC.
    It is possible that the invocation id or objectGuid refers to an
    unknown server, either because we haven't yet heard of it or the
    knowledge of the guid has since been lost.  In this case a guid-only
    dsname is returned.

    The DSNAME returned is suitable for use by szInsertDN(). If you're logging
    a DSNAME and the DSNAME has only a guid, szInsertDN() will insert the
    stringized guid.  

Arguments:

    pTHS - thread state
    idx - index on which to look for guid (Idx_InvocationId or Idx_ObjectGuid)
    puuid - invocation id or objectGuid

Return Value:

    Pointer to thread allocated storage containing a dsname.  On success,
    the dsname contains a guid and a string. On error, the dsname contains
    only the guid.
--*/

{
    DBPOS *pDBTmp;
    ULONG ret, cb;
    INDEX_VALUE IV;
    DSNAME *pDN = NULL;
    LPWSTR pszServerName;

    Assert(!fNullUuid(puuid));

    DBOpen(&pDBTmp);
    __try {
        ret = DBSetCurrentIndex(pDBTmp, idx, NULL, FALSE);
        if (ret) {
            __leave;
        }
        IV.pvData = puuid;
        IV.cbData = sizeof(UUID);
        
        ret = DBSeek(pDBTmp, &IV, 1, DB_SeekEQ);
        if (ret) {
            __leave;
        }
        ret = DBGetAttVal(pDBTmp, 1, ATT_OBJ_DIST_NAME,
                          0, 0,
                          &cb, (BYTE **) &pDN);
        if (ret) {
            __leave;
        }
    }
    __finally {
        DBClose(pDBTmp, TRUE);
    }

    if (!pDN) {
        DWORD cbGuidOnlyDN = DSNameSizeFromLen( 0 );
        pDN = THAllocEx( pTHS, cbGuidOnlyDN );
        pDN->Guid = *puuid;
        pDN->structLen = cbGuidOnlyDN;
    }

    return pDN;
}


void
DraSetRemoteDsaExtensionsOnThreadState(
    IN  THSTATE *           pTHS,
    IN  DRS_EXTENSIONS *    pextRemote
    )
{
    // Free prior extensions, if any.
    if (NULL != pTHS->pextRemote) {
        THFreeOrg(pTHS, pTHS->pextRemote);
        pTHS->pextRemote = NULL;
    }

    // Set the extensions on the thread state.
    if (pextRemote) {
        pTHS->pextRemote = THAllocOrgEx(pTHS, DrsExtSize(pextRemote));
        CopyExtensions(pextRemote, pTHS->pextRemote);
    }
}

LPWSTR
DraGUIDFromStringW(
    THSTATE *      pTHS,
    GUID *         pguid
    )
{
    LPWSTR pszName = NULL;
    LPWSTR pszGuid = NULL;
    RPC_STATUS rpcStatus = RPC_S_OK;
    rpcStatus = UuidToStringW(pguid, &pszName);
    if (rpcStatus!=RPC_S_OK) {
	Assert(rpcStatus);
	return NULL;
    }
    pszGuid = THAllocEx(pTHS, (wcslen(pszName) + 1) * sizeof(WCHAR));
    wcscpy(pszGuid, pszName);
    RpcStringFreeW(&pszName);
    return pszGuid;
}


LPWSTR
GetNtdsDsaDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidNtdsDsaObj
    )

/*++

Routine Description:

    Given a string DN of an NTDSDSA server object, return a
    user friendly display-able name 

Arguments:

    pTHS -
    pszDsaDN - DN string

Return Value:

    Display Name
   
--*/
{
    LPWSTR      pszDisplayName = NULL;
    LPWSTR      pszSite = NULL;
    LPWSTR      pszServer = NULL;
    LPWSTR *    ppszRDNs = NULL;
    DSNAME *    pDsa = NULL;
    LPWSTR      pszName = NULL;

    if (fNullUuid(pguidNtdsDsaObj)) {
	pszDisplayName = NULL;
    }
    else {
	pDsa = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, pguidNtdsDsaObj);
	if ((NULL == pDsa) || (pDsa->StringName == NULL)) {
	    // guid is better than nada
	    pszDisplayName = DraGUIDFromStringW(pTHS, pguidNtdsDsaObj);
	}
	else {
	    ppszRDNs = ldap_explode_dnW(pDsa->StringName, 1);
	    if ((NULL == ppszRDNs) || (2 > ldap_count_valuesW(ppszRDNs))) {
		// give them everything we have
		pszDisplayName = THAllocEx(pTHS, (wcslen(pDsa->StringName)+1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, pDsa->StringName);
	    }
	    else { 
		// return site\servername
		pszSite = ppszRDNs[3];
		pszServer = ppszRDNs[1];
		pszDisplayName = THAllocEx(pTHS, (wcslen(pszSite) + wcslen(pszServer) + 2) * sizeof(WCHAR)); 
		wcscpy(pszDisplayName, pszSite);
		wcscat(pszDisplayName, L"\\");
		wcscat(pszDisplayName, pszServer);
	    }  
	}
    }
    if (ppszRDNs) {
	ldap_value_freeW(ppszRDNs);
    }
    if (pDsa) {
	THFreeEx(pTHS, pDsa);
    }

    return pszDisplayName;
}

LPWSTR
GetTransportDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidTransportObj
    )
{
    LPWSTR        pszDisplayName = NULL;
    LPWSTR *      ppszRDNs = NULL;
    DSNAME *      pTransport = NULL;

    if (fNullUuid(pguidTransportObj)) {
	pszDisplayName = NULL;
    }
    else {
	pTransport = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, pguidTransportObj);
	if ((NULL == pTransport) || (pTransport->StringName == NULL)) {
	    pszDisplayName = DraGUIDFromStringW(pTHS, pguidTransportObj);
	}
	else {
	    ppszRDNs = ldap_explode_dnW(pTransport->StringName, 1);
	    if (NULL == ppszRDNs) {
		pszDisplayName = THAllocEx(pTHS, (wcslen(pTransport->StringName) + 1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, pTransport->StringName);
	    }
	    else { 
		pszDisplayName = THAllocEx(pTHS, (wcslen(ppszRDNs[0]) + 1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, ppszRDNs[0]); 
	    }
	}
    }
    if (ppszRDNs) {
	ldap_value_freeW(ppszRDNs);
    }
    if (pTransport) {
	THFreeEx(pTHS, pTransport);
    }

    return pszDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\drauptod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       drauptod.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Manages the per-NC up-to-date vectors, which record the highest originating
    writes we've seen from a set of DSAs.  This vector, in turn, is used in
    GetNCChanges() calls to filter out redundant property changes before they
    hit the wire.

DETAILS:

CREATED:

    08/01/96    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include "debug.h"                      /* standard debugging header */
#define DEBSUB     "DRAUPTOD:"          /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"   // META_STANDARD_PROCESSING

#include <fileno.h>
#define  FILENO FILENO_DRAUPTOD

#ifndef MIN
#define MIN(a,b)    ( ( (a) < (b) ) ? (a) : (b) )
#endif

VOID l_VectorGrow(THSTATE *pTHS,
                     UPTODATE_VECTOR **,
                     DWORD );

VOID
l_CursorImprove(
    IN  DBPOS *                   pDB,
    IN  BOOL                      fReplace,
    IN  UPTODATE_CURSOR_NATIVE *  puptodcur,
    OUT UPTODATE_VECTOR **        pputodvec
    );

VOID
l_Write(
    IN  DBPOS *             pDB,
    IN  UPTODATE_VECTOR *   putodvec
    );

BOOL    l_CursorFind(       UPTODATE_VECTOR *, UUID *, DWORD * );
VOID    l_CursorInsert(THSTATE *pTHS,
                       UPTODATE_VECTOR **,
                       UPTODATE_CURSOR_NATIVE *);
VOID    l_CursorRemove(THSTATE *pTHS,
                       UPTODATE_VECTOR **pputodvec,
                       UUID *pUuid);


#if DBG
BOOL gfCheckForInvalidUSNs = TRUE;
#define IS_VALID_USN(x) (!gfCheckForInvalidUSNs || ((x) < 1024*1024*1024))

void
UpToDateVec_Validate(
    IN  UPTODATE_VECTOR * pvec
    )
{
    DWORD i;

    if (NULL != pvec) {
        Assert(IS_VALID_UPTODATE_VECTOR(pvec));
        if (UPTODATE_VECTOR_NATIVE_VERSION == pvec->dwVersion) {
            UPTODATE_VECTOR_NATIVE * pNativeUTD = &pvec->V2;

            for (i = 0; i < pNativeUTD->cNumCursors; i++) {
                if (!IS_VALID_USN(pNativeUTD->rgCursors[i].usnHighPropUpdate)) {
                    CHAR szMessage[512];
    
                    sprintf(szMessage,
                            "Cursor %d of UTDVEC @ %p has an invalid USN!"
                            "  Please notify JeffParh.\n", i, pvec);
                    OutputDebugString(szMessage);
    
                    DRA_EXCEPT(DRAERR_InternalError, 0);
                }
            }
        }
    }
}


void
UsnVec_Validate(
    IN  USN_VECTOR * pusnvec
    )
{
    if (NULL != pusnvec) {
        if (!IS_VALID_USN(pusnvec->usnHighObjUpdate)
            || !IS_VALID_USN(pusnvec->usnHighPropUpdate)) {
            CHAR szMessage[512];

            sprintf(szMessage,
                    "USNVEC @ %p has an invalid USN!"
                    "  Please notify JeffParh.\n", pusnvec);
            OutputDebugString(szMessage);

            DRA_EXCEPT(DRAERR_InternalError, 0);
        }
    }
}


BOOL
l_PositionedOnNC(IN DBPOS *pDB)
{
    SYNTAX_INTEGER it;
    
    return !DBGetSingleValue(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)
           && FPrefixIt(it);
}

#endif


VOID
UpToDateVec_Read(
    IN  DBPOS *             pDB,
    IN  SYNTAX_INTEGER      InstanceType,
    IN  DWORD               dwFlags,
    IN  USN                 usnLocalDsa,
    OUT UPTODATE_VECTOR **  pputodvec
    )
//
//  Read the local up-to-date vector associated with the given NC, and
//  optionally add a cursor for the local DSA to show that we're up-to-date
//  with respect to ourselves.
//
//  Caller is repsonsible for freeing the allocated vector if
//  NULL != *pputodvec with THFree().
//
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD cbUpToDateVecDest;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    Assert(!(IT_UNINSTANT & InstanceType));
    Assert(!(IT_NC_GOING & InstanceType));

    if (IT_NC_COMING & InstanceType) {
        // We can't really claim to be up-to-date with respect to any DSA's
        // changes (even our own, if we perhaps generated changes in the NC,
        // the NC was removed, and now it's being added back again).
        Assert(!DBHasValues(pDB, ATT_REPL_UPTODATE_VECTOR));
        
        *pputodvec = NULL;
    } else {
        if (DBGetAttVal(pDB,
                        1,
                        ATT_REPL_UPTODATE_VECTOR,
                        0,
                        0,
                        &cbUpToDateVecDest,
                        (BYTE **) pputodvec)) {
            // couldn't retrieve current uptodate vector; default to no filter
            *pputodvec = NULL;
        }
    
        Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(*pputodvec));

        if ((NULL != *pputodvec)
            && (UPTODATE_VECTOR_NATIVE_VERSION != (*pputodvec)->dwVersion)) {
            // Convert to native version.
            UPTODATE_VECTOR * pUTDTmp;

            pUTDTmp = UpToDateVec_Convert(pTHS,
                                          UPTODATE_VECTOR_NATIVE_VERSION,
                                          *pputodvec);
            THFreeEx(pTHS, *pputodvec);
            *pputodvec = pUTDTmp;
        }
    
        if ((UTODVEC_fUpdateLocalCursor & dwFlags)
            && !fNullUuid(&pTHS->InvocationID)) {
            UPTODATE_CURSOR_NATIVE cursorLocal;
    
            // update the cursor corresponding to the local DSA to indicate
            // we've seen all our own changes up 'til now
    
            cursorLocal.uuidDsa             = pTHS->InvocationID;
            cursorLocal.usnHighPropUpdate   = usnLocalDsa;
            cursorLocal.timeLastSyncSuccess = GetSecondsSince1601();
    
            l_CursorImprove(pDB, FALSE, &cursorLocal, pputodvec);
            UpToDateVec_Validate(*pputodvec);
        }
    }
    
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
}


VOID
UpToDateVec_Improve(
    IN      DBPOS *             pDB,
    IN      UUID *              puuidDsaRemote,
    IN      USN_VECTOR *        pusnvec,
    IN OUT  UPTODATE_VECTOR *   putodvecRemote
    )
//
//  Given the replication state and up-to-date vector from a remote DSA
//  and the NC to which it corresponds, improve the local up-to-date
//  vector to show that we've seen all the originating writes seen by
//  the remote DSA.
//
//  The UTD vector came from the source machine, where it was build using
//  UpToDateVec_Read using the LocalCursor option.  This UTD contains a cursor
//  for the source DSA (describing itself) formulated using the highest
//  committed USN at the start of the GetNC transaction (see dragtchg.c).
//
//  Note that the cursor for the remote DSA is improved during step 1 and
//  step 2 below.
//
// [Jeff Parham]  The only time we improve the UTD is when we have successfully
// finished a complete replication cycle -- i.e., no more changes are available
// from the source, and all the changes we have received have been successfully
// applied.  I expect the USN in the UTD vec to be higher than the USN in the
// USN vec.  The highest committed USN is not NC-specific, so, for example,
// even when no changes are being generated in the NC the USN in the UTD vector
// will steadily crawl upwards (as changes are made to other NCs).  This is
// intended (or was intended, when I wrote this code two years ago).
//
{
    THSTATE *           pTHS = pDB->pTHS;
    UPTODATE_VECTOR *   putodvecLocal;
    DWORD               iCursorRemote;
    SYNTAX_INTEGER      it;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));

    UpToDateVec_Validate(putodvecRemote);

    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
    
    UpToDateVec_Read(pDB, it, 0, 0, &putodvecLocal);
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(putodvecLocal));
    UpToDateVec_Validate(putodvecLocal);

    // merge each remote cursor into the local vector
    if ( NULL != putodvecRemote )
    {
        UPTODATE_VECTOR_NATIVE * pNativeRemoteUTD = &putodvecRemote->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(putodvecRemote));
        
        // puptodvecRemote should already contain an entry for the source DSA.
        Assert(l_CursorFind(putodvecRemote, puuidDsaRemote, &iCursorRemote)
               && (pNativeRemoteUTD->rgCursors[iCursorRemote].usnHighPropUpdate
                   >= pusnvec->usnHighPropUpdate));
        
        for ( iCursorRemote = 0; iCursorRemote < pNativeRemoteUTD->cNumCursors; iCursorRemote++ )
        {
            // don't bother maintaining a cursor for ourselves
            if ( (0 != memcmp(&pNativeRemoteUTD->rgCursors[ iCursorRemote ].uuidDsa,
                              &pTHS->InvocationID,
                              sizeof( UUID ) )) )
            {
                l_CursorImprove(pDB,
                                FALSE,
                                &pNativeRemoteUTD->rgCursors[ iCursorRemote ],
                                &putodvecLocal);
            }
        }
    }

    UpToDateVec_Validate(putodvecLocal);

    // save the uptodate vector back to disk
    // (if we have anything to save)
    if ( NULL != putodvecLocal )
    {
        l_Write(pDB, putodvecLocal);

        THFree( putodvecLocal );
    }
}

VOID
UpToDateVec_Replace(
    IN      DBPOS *             pDB,
    IN      UUID *              pRemoteDsa,
    IN      USN_VECTOR *        pUsnVec,
    IN OUT  UPTODATE_VECTOR *   pUTD
    )
/*++

Routine Description:

    Overwrites stored UTD w/ given remote one

Arguments:
    pTHS -- Thread state
    pRemoteDsa -- The remote dsa we'll from which we incorporate the new UTD
    pUsnVec -- the usn vec we'll have for that dsa entry
    pUTD -- the UTD to apply locally

Return Value:
    None.

Remark:
    Beware-- we don't preserve pUTD and it will be modified
    in place. Only then it will get written down.
--*/
{
    THSTATE * pTHS = pDB->pTHS;
#if DBG
    UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUTD->V2;
    DWORD iCursor;
#endif

    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUTD));
    UpToDateVec_Validate(pUTD);

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    // pUTD should already contain an entry for the source DSA.
    Assert(l_CursorFind(pUTD, pRemoteDsa, &iCursor)
           && (pNativeUTD->rgCursors[iCursor].usnHighPropUpdate
               >= pUsnVec->usnHighPropUpdate));
    
    //
    // remove ourselves from remote UTD
    //
    l_CursorRemove(pTHS, &pUTD, &pTHS->InvocationID);

    //
    // commit
    //
    l_Write(pDB, pUTD);
}

BOOL
UpToDateVec_IsChangeNeeded(
    IN  UPTODATE_VECTOR *   pUpToDateVec,
    IN  UUID *              puuidDsaOrig,
    IN  USN                 usnOrig
    )
//
//  Given a DSA's up-to-date vector, determine whether that DSA has already
//  seen a specific originating write.
//
{
    BOOL                fChangeNeeded;
    DWORD               iCursor;

    UpToDateVec_Validate(pUpToDateVec);

    if (NULL == pUpToDateVec) {
        fChangeNeeded = TRUE;
    } else {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUpToDateVec->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUpToDateVec));

        if (    fNullUuid( puuidDsaOrig )
                || !l_CursorFind( pUpToDateVec, puuidDsaOrig, &iCursor ) )
        {
            // the DSA signature has not been set, or the destination DSA has no
            // cursor for the originating DSA; ship the change
            fChangeNeeded = TRUE;
        }
        else
        {
            // ship change iff the change has not yet been seen by the source
            fChangeNeeded = ( usnOrig > pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate );
        }
    }

    return fChangeNeeded;
}


VOID
l_CursorImprove(
    IN  DBPOS *                   pDB,
    IN  BOOL                      fReplace,
    IN  UPTODATE_CURSOR_NATIVE *  puptodcur,
    OUT UPTODATE_VECTOR **        pputodvec
    )
/*++

Routine Description:

  Add a cursor to the given up-to-date vector, or, if a cursor for the
  corresponding DSA already exists, improve the existing cursor.

Arguments:

    pTHS-- thread state
    pputodvec-- UTD vector to improve
    puptodcur-- the cursor to improve to
    fReplace-- if TRUE a mandatory replace, rather then conditional improve

Return Value:

    none.

--*/
{
    THSTATE * pTHS = pDB->pTHS;
    DWORD     iCursor;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    UpToDateVec_Validate(*pputodvec);

    Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(*pputodvec));

    if ( !l_CursorFind( *pputodvec, &puptodcur->uuidDsa, &iCursor ) )
    {
        // cursor for the given DSA does not exist; add it
        l_CursorInsert(pTHS, pputodvec, puptodcur );
        UpToDateVec_Validate(*pputodvec);
    }
    else
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &(*pputodvec)->V2;
        
        // cursor for given DSA exists; improve it if necessary
        if ( pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate <= puptodcur->usnHighPropUpdate ||
             fReplace ) {
            Assert(0 != memcmp(&pTHS->InvocationID, &puptodcur->uuidDsa, sizeof(UUID)));

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_IMPROVING_UPTODATE_VECTOR,
                      szInsertUUID(&puptodcur->uuidDsa),
                      szInsertUSN(pNativeUTD->rgCursors[iCursor].usnHighPropUpdate),
                      szInsertUSN(puptodcur->usnHighPropUpdate),
                      szInsertDN(GetExtDSName(pDB)),
                      NULL, NULL, NULL, NULL);

            if (pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate
                < puptodcur->usnHighPropUpdate) {
                // New cursor has higher USN -- copy the timestamp.
                
                // Note that the cursor with the higher USN is more recent, even
                // if the timestamp is smaller (as might happen if the time on
                // the DC were temporarily set into the future and set back, for
                // example).
                pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess
                    = puptodcur->timeLastSyncSuccess;
            } else {
                // new cursor has same USN -- keep higher of the two timestamps.
                pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess
                    = max(pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess,
                          puptodcur->timeLastSyncSuccess);
            }
            
            pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate = puptodcur->usnHighPropUpdate;
            UpToDateVec_Validate(*pputodvec);
        }
    }
}

VOID
l_Write(
    IN  DBPOS *             pDB,
    IN  UPTODATE_VECTOR *   putodvec
    )
//
//  Create/modify the up-to-date vector associated with a given NC.
//
{
    ULONG   replStatus;
    DWORD   cbUpToDateVecSize;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    UpToDateVec_Validate(putodvec);
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(putodvec));

    cbUpToDateVecSize = UpToDateVecSize(putodvec);

    // Replace the attribute. DBReset succeeds or excepts.
    DBResetAtt(pDB,
               ATT_REPL_UPTODATE_VECTOR,
               cbUpToDateVecSize,
               putodvec,
               SYNTAX_OCTET_STRING_TYPE /* ignored */ );

    // Update the object
    replStatus = DBRepl(pDB,
                        TRUE,               // fDRA
                        DBREPL_fKEEP_WAIT,  // Don't notify
                        NULL,               // pMetaDataVecRemote
                        META_STANDARD_PROCESSING);
    if (replStatus) {
        DRA_EXCEPT(DRAERR_DBError, replStatus);
    }
}


BOOL
l_CursorFind(
    UPTODATE_VECTOR *   putodvec,
    UUID *              puuidDsa,
    DWORD *             piCursor )
//
//  Determine if a cursor for the given DSA is defined in the specified
//  up-to-date vector.  If so, return its index.  If not, return the
//  index at which the cursor should be inserted into the vector to
//  maintain proper sort order.
//
{
    BOOL                fFound;
    LONG                iCursorBegin;
    LONG                iCursorEnd;
    LONG                iCursorCurrent;
    RPC_STATUS          rpcStatus;
    int                 nDiff;

    UpToDateVec_Validate(putodvec);

    fFound = FALSE;
    iCursorCurrent = 0;

    if ( NULL != putodvec )
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &putodvec->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(putodvec));

        iCursorBegin = 0;
        iCursorEnd   = pNativeUTD->cNumCursors - 1;

        // find DSA up-to-date cursor corresponding to the given DSA
        while ( !fFound && ( iCursorEnd >= iCursorBegin ) )
        {
            iCursorCurrent = ( iCursorBegin + iCursorEnd ) / 2;

            nDiff = UuidCompare( puuidDsa,
                                 &pNativeUTD->rgCursors[ iCursorCurrent ].uuidDsa,
                                 &rpcStatus );
            Assert( RPC_S_OK == rpcStatus );

            if ( nDiff < 0 )
            {
                if ( iCursorEnd != iCursorBegin )
                {
                    // further narrow search
                    iCursorEnd = iCursorCurrent - 1;
                }
                else
                {
                    // cursor not found; it should be inserted before this cursor
                    break;
                }
            }
            else if ( nDiff > 0 )
            {
                if ( iCursorEnd != iCursorBegin )
                {
                    // further narrow search
                    iCursorBegin = iCursorCurrent + 1;
                }
                else
                {
                    // cursor not found; it should be inserted after this cursor
                    iCursorCurrent++;
                    break;
                }
            }
            else
            {
                // found it
                fFound = TRUE;
            }
        }
    }

    *piCursor = iCursorCurrent;

    return fFound;
}


VOID
l_CursorInsert(
    THSTATE *                 pTHS,
    UPTODATE_VECTOR **        pputodvec,
    UPTODATE_CURSOR_NATIVE *  puptodcur
    )
//
//  Insert a new cursor into the given up-to-date vector.
//
{
    BOOL                      fFound;
    DWORD                     iCursor;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;

    UpToDateVec_Validate(*pputodvec);

    l_VectorGrow(pTHS, pputodvec, 1 );

    fFound = l_CursorFind( *pputodvec, &puptodcur->uuidDsa, &iCursor );
    if ( fFound )
    {
        DRA_EXCEPT( DRAERR_InternalError, iCursor );
    }


    // insert new cursor at iCursor
    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
    pNativeUTD = &(*pputodvec)->V2;
    
    MoveMemory( &pNativeUTD->rgCursors[ iCursor+1 ],
                &pNativeUTD->rgCursors[ iCursor   ],
                (   sizeof( UPTODATE_CURSOR_NATIVE )
                  * ( pNativeUTD->cNumCursors - iCursor ) ) );

    pNativeUTD->rgCursors[ iCursor ] = *puptodcur;
    pNativeUTD->cNumCursors++;

    UpToDateVec_Validate(*pputodvec);
}

VOID
l_CursorRemove(
    THSTATE         *   pTHS,
    UPTODATE_VECTOR **  pputodvec,
    UUID            *pUuid )
/*++

Routine Description:

    Removes a dsa entry's cursor from a given UTD.
    Doesn't touch memory image taken (doesn't shrink / realloc mem);

Arguments:

    pTHS -- thread state
    pputodvec -- UTD to process
    pUuid -- cursor to remove from UTD

Return Value:
    None.

Remark:
    Raises DRA exception


--*/
{
    BOOL                      fFound;
    DWORD                     iCursor;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;

    UpToDateVec_Validate(*pputodvec);

    fFound = l_CursorFind( *pputodvec, pUuid, &iCursor );
    if ( fFound ) {

        // overwrites cursor at iCursor
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
        pNativeUTD = &(*pputodvec)->V2;
        
        MoveMemory( &pNativeUTD->rgCursors[ iCursor ],
                    &pNativeUTD->rgCursors[ iCursor+1 ],
                    (   sizeof( UPTODATE_CURSOR_NATIVE )
                      * ( pNativeUTD->cNumCursors - iCursor - 1 ) ) );

        pNativeUTD->cNumCursors--;

        UpToDateVec_Validate(*pputodvec);
    }
}


BOOL
UpToDateVec_GetCursorUSN(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT USN *               pusnCursorUSN
    )
{
    DWORD iCursor;

    UpToDateVec_Validate(putodvec);
    Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(putodvec));

    if (l_CursorFind(putodvec, puuidDsaOrig, &iCursor))
    {
        // cursor found
        if (pusnCursorUSN) {
            UPTODATE_VECTOR_NATIVE * pNativeUTD = &putodvec->V2;
            *pusnCursorUSN = pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate;
        }

        return TRUE;
    }

    return FALSE;
}


VOID
l_VectorGrow(
    THSTATE         *   pTHS,
    UPTODATE_VECTOR **  pputodvec,
    DWORD               cNumCursorsToGrow )
//
//  Extend the memory allocation for the given up-to-date vector to hold
//  a specified number of additional cursors.
//
{
    DWORD   cbNewVecSize;

    UpToDateVec_Validate(*pputodvec);

    if ( NULL == *pputodvec )
    {
        cbNewVecSize = UpToDateVecVNSizeFromLen( cNumCursorsToGrow );

        *pputodvec = THAllocEx(pTHS, cbNewVecSize );

        (*pputodvec)->dwVersion = UPTODATE_VECTOR_NATIVE_VERSION;
    }
    else
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &(*pputodvec)->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));

        cbNewVecSize = UpToDateVecVNSizeFromLen( pNativeUTD->cNumCursors + cNumCursorsToGrow );

        *pputodvec = THReAllocEx(pTHS, *pputodvec, cbNewVecSize );
    }
}


UPTODATE_VECTOR *
UpToDateVec_Convert(
    IN      THSTATE *                   pTHS,
    IN      DWORD                       dwOutVersion,
    IN      UPTODATE_VECTOR *           pIn             OPTIONAL
    )
{
    UPTODATE_VECTOR * pOut = NULL;
    DWORD iCursor;

    if (NULL != pIn) {
        Assert(IS_VALID_UPTODATE_VECTOR(pIn));
        
        if (pIn->dwVersion == dwOutVersion) {
            // In and out versions are the same -- no conversion required.
            pOut = pIn;
        } else if ((1 == pIn->dwVersion) && (2 == dwOutVersion)) {
            // Expand V1 vector to V2.
            pOut = THAllocEx(pTHS, UpToDateVecV2SizeFromLen(pIn->V1.cNumCursors));
            pOut->dwVersion = dwOutVersion;
            pOut->V2.cNumCursors = pIn->V1.cNumCursors;

            for (iCursor = 0; iCursor < pIn->V1.cNumCursors; iCursor++) {
                pOut->V2.rgCursors[iCursor].uuidDsa = pIn->V1.rgCursors[iCursor].uuidDsa;
                pOut->V2.rgCursors[iCursor].usnHighPropUpdate = pIn->V1.rgCursors[iCursor].usnHighPropUpdate;
            }
        } else if ((2 == pIn->dwVersion) && (1 == dwOutVersion)) {
            // Reduce V2 vector to V1.
            pOut = THAllocEx(pTHS, UpToDateVecV2SizeFromLen(pIn->V2.cNumCursors));
            pOut->dwVersion = dwOutVersion;
            pOut->V1.cNumCursors = pIn->V2.cNumCursors;

            for (iCursor = 0; iCursor < pIn->V2.cNumCursors; iCursor++) {
                pOut->V1.rgCursors[iCursor].uuidDsa = pIn->V2.rgCursors[iCursor].uuidDsa;
                pOut->V1.rgCursors[iCursor].usnHighPropUpdate = pIn->V2.rgCursors[iCursor].usnHighPropUpdate;
            }
        } else {
            DRA_EXCEPT(ERROR_UNKNOWN_REVISION, pIn->dwVersion);
        }
    }

    return pOut;
}


void
UpToDateVec_AddTimestamp(
    IN      UUID *                      puuidInvocId,
    IN      DSTIME                      timeToAdd,
    IN OUT  UPTODATE_VECTOR *           pUTD
    )
/*++

Routine Description:

    Fill in the timeLastSyncSuccess field for the specified cursor in the UTD
    vector with the given timestamp.
    
    The entry must already exist in the vector and the existing timestamp
    must be 0.

Arguments:

    puuidInvocId (IN) - Invocation ID of cursor to be updated.
    
    timeToAdd (IN) - Timestamp to associate with cursor.
    
    pUTD (IN/OUT) - Vector to be updated.

Return Values:

    None.

--*/
{
    UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUTD->V2;
    DWORD iCursor;
    BOOL fFound;

    Assert(!fNullUuid(puuidInvocId));
    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUTD));
        
    fFound = l_CursorFind(pUTD, puuidInvocId, &iCursor);
    Assert(fFound);

    if (fFound) {
        Assert(0 == memcmp(&pNativeUTD->rgCursors[iCursor].uuidDsa,
                           puuidInvocId, sizeof(UUID)));
        Assert(0 == pNativeUTD->rgCursors[iCursor].timeLastSyncSuccess);

        pNativeUTD->rgCursors[iCursor].timeLastSyncSuccess = timeToAdd;
    }
}

void 
UpToDateVec_Merge(
    IN THSTATE *           pTHS,
    IN UPTODATE_VECTOR *   pUTD1,
    IN UPTODATE_VECTOR *   pUTD2,
    OUT UPTODATE_VECTOR ** ppUTDMerge
    )
/*++

Routine Description:

    Merge two DC's UTD vectors to build a "common" vector.  This common UTD
    is the minimum value of usn's in the two UTD for the intersection of
    DSA's.  For each DSA and USN pair in the common UTD vector, it represents
    the replication state of that BOTH DC's share with respect to that DSA and
    USN pair.  So the common UTD can state that for each DSA in it's vector, both
    DC's have replicated changes up to the corresponding USN.  

Arguments:

    pTHS - 
    
    pUTD1 - utd to merge
    pUTD2 - utd to merge
    
    ppUTDMerge - utd to merge into

Return Values:

    None.

--*/      
{

    ULONG iUTD1 = 0;
    ULONG iUTD2 = 0;
    RPC_STATUS rpcStatus = RPC_S_OK;
    int   nDiff = 0;

    if ((pUTD1==NULL) || (pUTD2==NULL) || (*ppUTDMerge!=NULL)) {
	DRA_EXCEPT(DRAERR_InvalidParameter,0);
    }

    for (iUTD1=0, iUTD2=0; (iUTD1<pUTD1->V2.cNumCursors) && (iUTD2<pUTD2->V2.cNumCursors); ) {
       	nDiff = UuidCompare(&(pUTD1->V2.rgCursors[iUTD1].uuidDsa), &(pUTD2->V2.rgCursors[iUTD2].uuidDsa), &rpcStatus);
	Assert( RPC_S_OK == rpcStatus );

	if (nDiff == 0) {
	    UPTODATE_CURSOR_NATIVE uptodInsert;
	    uptodInsert.uuidDsa = pUTD1->V2.rgCursors[iUTD1].uuidDsa;
	    uptodInsert.usnHighPropUpdate = MIN(pUTD1->V2.rgCursors[iUTD1].usnHighPropUpdate,pUTD2->V2.rgCursors[iUTD2].usnHighPropUpdate);  
	    uptodInsert.timeLastSyncSuccess = 0;
	    l_CursorInsert(pTHS, ppUTDMerge, &uptodInsert);
	    iUTD1++;
	    iUTD2++;
	}
	else if ( nDiff < 0 ) {
	    iUTD1++;
	}
	else {
	    iUTD2++;
	}
    } 
    UpToDateVec_Validate(*ppUTDMerge);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\script.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       script.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

Server-side RPC entrypoints for the ExecuteScript function

Author:

    MariosZ

Environment:

Notes:

Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop


// Core DSA headers.
extern "C" {
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <attids.h>
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#undef new
#undef delete

#include <objids.h>
#include <anchor.h>
#include <dsatools.h>                   // needed for output allocation
#include <Wincrypt.h>                   // encryption / hashing routines
#include <filtypes.h>
#include <dominfo.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <ldap.h>
#include <windns.h>
#include <sddl.h>

#include <lmserver.h>   // needed for lmjoin.h
#include <lmjoin.h>     // needed for netsetup.h
#include <netsetup.h>   // needed for NetpSetDnsComputerNameAsRequired

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include "log.h"

// Assorted DSA headers.
#include "dsexcept.h"
#include "permit.h"

#include <base64.h>

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "SCRIPT:"           /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_NTDSCRIPT

extern ATTCACHE *getAttByNameW(IN THSTATE *pTHS, IN LPWSTR pszAttributeName);
extern int LocalCompare(THSTATE *pTHS, COMPAREARG *pCompareArg, COMPARERES *pCompareRes);


}

#include <NTDScript.h>
#include <NTDScriptUtil.h>
#include <NTDSContent.h>
#include <NTDScriptExec.h>

#include <SAXErrorHandlerImpl.h>


#define INTRUDER_DELAY (10 * 1000)

// guid used to sign the script stored in the database.
// this is used in addition to the user specified Key.
// {0916C8E3-3431-4586-AF77-44BD3B16F961}
static const GUID guidDomainRename = 
{ 0x916c8e3, 0x3431, 0x4586, { 0xaf, 0x77, 0x44, 0xbd, 0x3b, 0x16, 0xf9, 0x61 } };


extern "C" {
ULONG  gulRunningExecuteScriptOperations = 0;
CRITICAL_SECTION csDsaOpRpcIf;
ULONG gulScriptLoggerLogLevel = 1;
}
//
//  ScriptParseErrorGen
//
//  Description:
//
//      Generates an error related to parsing / executing of the NTDSA script
//
//  Arguments:
//
//      dsid - the DSID of the error
//      dwErr - the Error Code
//      data  - additional data needed for the error
//
//  Return Value:
//      the Error code
//      
DWORD ScriptParseErrorGen (DWORD dsid, DWORD dwErr, DWORD data, WCHAR *pMsg)
{
    THSTATE *pTHS = pTHStls;

    Assert (pTHS);

    ScriptLogPrint ( (DSLOG_ERROR, "Script Parsing Error(0x%x) DSID (0x%x) Data(0x%x)\n", dwErr, dsid, data) );

    // todo
    // save dsid, error in thstate

    LIST_OF_ERRORS *pErrList = (LIST_OF_ERRORS *)THAllocEx (pTHS, sizeof (LIST_OF_ERRORS));

    pErrList->data = data;
    pErrList->dsid = dsid;
    pErrList->dwErr = dwErr;
    pErrList->pMessage = pMsg;
    pErrList->pPrevError = pTHS->pErrList;

    pTHS->pErrList = pErrList;

    if (dwErr) {
        return dwErr;
    }

    return ERROR_DS_NTDSCRIPT_PROCESS_ERROR;
}

//
//  ScriptAlloc
//
//  Description:
//
//      Allocated memory used for script parsing. This functions isolates the 
//      memory allocation needs of the script parsing code from the DS
//
//  Arguments:
//
//      size  - memory size needed
//
//  Return Value:
//      the allocated memory buffer on success.
//      NULL on failure
//
void *ScriptAlloc (size_t size)
{
    void * pMem;

    pMem = THAlloc(size);

    return(pMem);
}

//
//  ScriptFree
//
//  Description:
//
//      Free memory used for script parsing. This functions isolates the 
//      memory allocation needs of the script parsing code from the DS
//
//  Arguments:
//
//      ptr - the memory to free
//
//  Return Value:
//     None
//
void ScriptFree (void *ptr)
{
    THSTATE *pTHS = pTHStls;

    Assert (pTHS);

    THFreeEx(pTHS, ptr);
}

//
//  ScriptStringToDSFilter
//
//  Description:
//
//      Converts a WCHAR string that contains an LDAP filter into 
//      a DS FILTER datastructure.
//
//  Arguments:
//
//      search_filter - the LDAP like filter to convert
//      ppFilter - the output filter
//
//  Return Value:
//     0 on success
//     1 on failure
//
DWORD ScriptStringToDSFilter (WCHAR *search_filter, FILTER **ppFilter)
{
    THSTATE *pTHS = pTHStls;
    DWORD cLen = wcslen (search_filter);
    FILTER *pFilter = NULL;
    CLASSCACHE *pCC = NULL;
    
    *ppFilter = NULL;

    if (wcsncmp (L"COUNT_DOMAINS_FILTER", search_filter, cLen) == 0) {

        pFilter = (FILTER *)THAllocEx (pTHS, sizeof (FILTER));

        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
        pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_SYSTEM_FLAGS;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof (DWORD);
        pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)THAllocEx (pTHS, sizeof (DWORD));
        *(DWORD *)(pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal) = FLAG_CR_NTDS_DOMAIN;

        *ppFilter = pFilter;
    }
    else if (wcsncmp (L"COUNT_TRUSTS_FILTER", search_filter, cLen) == 0) {

        pCC = SCGetClassById(pTHS, CLASS_TRUSTED_DOMAIN);
        if (!pCC) {
            Assert (FALSE);
            return 1;
        }

        pFilter = (FILTER *)THAllocEx (pTHS, sizeof (FILTER));

        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pCC->pDefaultObjCategory->structLen;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) pCC->pDefaultObjCategory;

        *ppFilter = pFilter;
    }
    else {
        ScriptLogPrint ( (DSLOG_ERROR, "Cannot parse filter: %ws\n", search_filter) );

        Assert (!"Not Supported Filter");
        return 1;
    }

    return 0;
}

#define SCRIPT_VALUE_TRUE  L"TRUE"
#define SCRIPT_VALUE_TRUE_LEN ( sizeof(SCRIPT_VALUE_TRUE)/sizeof(WCHAR) -1 )
#define SCRIPT_VALUE_FALSE  L"FALSE"
#define SCRIPT_VALUE_FALSE_LEN ( sizeof(SCRIPT_VALUE_FALSE)/sizeof(WCHAR) -1 )

//
//  ConvertScriptValueToDirAttrVal
//
//  Description:
//
//     Convert a string to the corresponding AttrVal structure
//     This function is similar to a corresponding function in the LDAP head
//
//  Arguments:
//
//      pAC - the attribute used
//      pVal - the string value
//      pAttrVal - where to store the resulted AttrVal
//
//  Return Value:
//
//     0 on success
//     Win32 error on failure
// 
//
DWORD ConvertScriptValueToDirAttrVal (THSTATE *pTHS, 
                                      ATTCACHE *pAC, 
                                      WCHAR    *pVal, 
                                      ATTRVAL  *pAttrVal)
{
    DWORD cLen = 0;
    DWORD dwErr = 0;


    if (!pVal) {
        pAttrVal->valLen = 0;
        pAttrVal->pVal = NULL;
        return 0;
    }
    else {
        cLen = wcslen (pVal);
        pAttrVal->valLen = cLen * sizeof (WCHAR);
        pAttrVal->pVal = (PUCHAR)pVal;
    }

    // Based on the att, turn the string we were given into a value.
    switch (pAC->OMsyntax) {
    case OM_S_BOOLEAN:
        {
            int val=0;
            // Only two values are allowed.  Anything else is not-understood.
            // Case matters.
            if((cLen == SCRIPT_VALUE_TRUE_LEN) &&
               (wcsncmp(SCRIPT_VALUE_TRUE, pVal, cLen)== 0)) {
                    val = 1;
            }
            else if((cLen == SCRIPT_VALUE_FALSE_LEN) &&
               (wcsncmp(SCRIPT_VALUE_FALSE, pVal, cLen)== 0)) {
                    val = 2;
            }

            if(!val) {   
                dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }
            else {
                pAttrVal->valLen = sizeof( BOOL );
                pAttrVal->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof(BOOL));
                *( BOOL * )pAttrVal->pVal = (val==1);
            }
        }

        break;

    case OM_S_ENUMERATION:
    case OM_S_INTEGER:
        {
            SYNTAX_INTEGER *pInt, sign=1;
            ATTCACHE *pACLink;
            unsigned i;

            pInt = ( SYNTAX_INTEGER  *) THAllocEx(pTHS, sizeof(SYNTAX_INTEGER));
            *pInt = 0;
            i=0;
            if(pVal[i] == L'-') {
                sign = -1;
                i++;
            }
            if(i==cLen) {
                // No length or just a '-'
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            } else {
                for(;i<cLen;i++) {
                    // Parse the string one character at a time to detect any
                    // non-allowed characters.
                    if((pVal[i] < L'0') || (pVal[i] > L'9')) {
                        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                        break;
                    }
                    *pInt = (*pInt * 10) + pVal[i] - L'0';
                }
            }
                
            if (dwErr == 0) {
                *pInt *= sign;
            } else if (pAC->id != ATT_LINK_ID) {
                return dwErr;
            } else {
                // AutoLinkId
                Assert (FALSE);
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }

            // Ok, got the value, set it up.
            pAttrVal->valLen = sizeof( SYNTAX_INTEGER );
            pAttrVal->pVal = ( UCHAR * ) pInt;
        }
        break;

    case OM_S_OBJECT:
        switch(pAC->syntax) {
        case SYNTAX_DISTNAME_TYPE:
            
            if ( !(dwErr = ScriptNameToDSName (pVal, cLen, (DSNAME **) &pAttrVal->pVal)) ) {
                pAttrVal->valLen=((DSNAME*)pAttrVal->pVal)->structLen;
            }
            break;


        case SYNTAX_DISTNAME_STRING_TYPE:
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_ADDRESS_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
            DPRINT1 (0, "Not Implemented Syntax Conversion: %d\n", pAC->syntax);
            Assert (!"Not Implemented Syntax Conversion");
            
            // fall through
        default:
            dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            break;
        }
        break;


    case OM_S_IA5_STRING:
    case OM_S_NUMERIC_STRING:
    case OM_S_TELETEX_STRING:
    case OM_S_PRINTABLE_STRING:
        {
            AssertionValue assertionVal;
            extern _enum1 CheckStringSyntax(int syntax, AssertionValue *pLDAP_val);

            // Convert Unicode to Ascii
            assertionVal.value = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                          CP_UTF8, 
                                                          pVal, 
                                                          -1, 
                                                          (LPLONG)&assertionVal.length, 
                                                          NULL);

            

            if(!pAC->bExtendedChars) {
                if (CheckStringSyntax(pAC->OMsyntax, &assertionVal)) {
                    THFreeEx (pTHS, assertionVal.value);
                    dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                    return dwErr;
                }
            }
            pAttrVal->valLen = assertionVal.length;
            pAttrVal->pVal = assertionVal.value;
        }
        break;

    case OM_S_OCTET_STRING:

        if (SYNTAX_SID_TYPE == pAC->syntax) {
            PSID   pSid;
            
            //
            // Check to see if this is the userfriendly string representation.
            //
            if (cLen >= 2 && !_wcsnicmp(pVal, L"S-", 2)
                && ConvertStringSidToSidW(pVal, &pSid)) {

                __try {
                    // Now copy the converted SID into THAlloc'ed memory
                    pAttrVal->valLen = RtlLengthSid(pSid);
                    pAttrVal->pVal = (PUCHAR)THAllocEx(pTHS, pAttrVal->valLen);
                    CopyMemory(pAttrVal->pVal, pSid, pAttrVal->valLen);
                }
                __finally {
                    LocalFree(pSid);
                }

            }
            break;
        }
        //
        // deliberate fall through if this is not a SID.
        //

    case OM_S_GENERAL_STRING:
    case OM_S_GRAPHIC_STRING:
    case OM_S_OBJECT_DESCRIPTOR_STRING:
    case OM_S_VIDEOTEX_STRING:

        // Strings is strings, just use them.
        // Convert Unicode to Ascii

        pAttrVal->pVal = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                  CP_UTF8, 
                                                  pVal, 
                                                  -1, 
                                                  (LPLONG)&pAttrVal->valLen, 
                                                  NULL);
        break;

    case OM_S_UNICODE_STRING:
        pAttrVal->valLen = cLen * sizeof(WCHAR);
        pAttrVal->pVal = (UCHAR *)THAllocEx(pTHS, pAttrVal->valLen + sizeof(WCHAR));
        memcpy (pAttrVal->pVal, pVal, pAttrVal->valLen);
        break;

    case OM_S_I8:
        {
            SYNTAX_I8 *pInt;
            LONG sign=1;
            unsigned i;

            pInt = ( SYNTAX_I8  *) THAllocEx(pTHS, sizeof(SYNTAX_I8));
            pInt->QuadPart = 0;
            i=0;
            if(pVal[i] == L'-') {
                sign = -1;
                i++;
            }

            if(i==cLen) {
                // No length or just a '-'
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }

            for(;i<cLen;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((pVal[i] < L'0') || (pVal[i] > L'9')) {
                    return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                }

                pInt->QuadPart = ((pInt->QuadPart * 10) + pVal[i] - '0');
            }
            pInt->QuadPart *= sign;

            // Ok, got the value, set it up.
            pAttrVal->valLen = sizeof( SYNTAX_I8 );
            pAttrVal->pVal = (UCHAR *)pInt;
        }
        break;


    case OM_S_OBJECT_IDENTIFIER_STRING:
        {
    extern _enum1
    LDAP_AttrTypeToDirAttrTyp (
            IN THSTATE       *pTHS,
            IN ULONG         CodePage,
            IN SVCCNTL*      Svccntl OPTIONAL,
            IN AttributeType *LDAP_att,
            OUT ATTRTYP      *pAttrType,
            OUT ATTCACHE     **ppAC         // OPTIONAL
            );

    extern _enum1
    LDAP_AttrTypeToDirClassTyp (
            IN  THSTATE       *pTHS,
            IN  ULONG         CodePage,
            IN  AttributeType *LDAP_att,
            OUT ATTRTYP       *pAttrType,
            OUT CLASSCACHE    **ppCC        // OPTIONAL
            );


            _enum1 code=success;
            SVCCNTL Svccntl;
            ULONG   CodePage = CP_UTF8;
            ATTCACHE *pACVal;
            AssertionValue assertionVal;

            // allocate space for the oid
            pAttrVal->valLen = sizeof( ULONG );
            pAttrVal->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof (ULONG));

            // Convert Unicode to Ascii
            assertionVal.value = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                          CP_UTF8, 
                                                          pVal, 
                                                          -1, 
                                                          (LPLONG)&assertionVal.length, 
                                                          NULL);

            // not interested in the trailing NULL.
            if (assertionVal.length) {
                assertionVal.length--;
            }

            // Call support routine to translate.
            code = LDAP_AttrTypeToDirAttrTyp (
                    pTHS,
                    CodePage,
                    &Svccntl,
                    (AttributeType *)&assertionVal,
                    (ATTRTYP *)pAttrVal->pVal,
                    &pACVal);

            // Need the tokenized OID (attributeId), not the internal id (msDS-IntId)
            if (code == success) {
                *((ATTRTYP *)pAttrVal->pVal) = pACVal->Extid;
            }

            if(code == noSuchAttribute) {
                // Ok, it's not an attribute, see if it is a class.
                code = LDAP_AttrTypeToDirClassTyp (
                        pTHS,
                        CodePage,
                        (AttributeType *)&assertionVal,
                        (ATTRTYP *)pAttrVal->pVal,
                        NULL);
            }

            if(code == noSuchAttribute) {
                // Not an object we know. Could be a new id.
                // Try to parse the string as an OID string,
                // (e.g.  "OID.1.2.814.500" or "1.2.814.500")
                // The call to StringToAttrType can handle
                // both strings starting with OID. and not

                if(StringToAttrTyp(pTHS, pVal, cLen, (ATTRTYP *)pAttrVal->pVal)== -1) {
                      // failed to convert.
                     code = noSuchAttribute;
                 }
                 else {
                     code = success;
                 }
            }

            if (assertionVal.value) {
                THFreeEx (pTHS, assertionVal.value);
            }

            if (code != success) {
                dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }
        }
        break;


    case OM_S_GENERALISED_TIME_STRING:
    case OM_S_UTC_TIME_STRING:
    case OM_S_OBJECT_SECURITY_DESCRIPTOR:
        
        ScriptLogPrint ( (DSLOG_ERROR, "Not Implemented OMSyntax Conversion: %d\n", pAC->OMsyntax) );        
        DPRINT1 (0, "Not Implemented OMSyntax Conversion: %d\n", pAC->OMsyntax);
        Assert (!"Not Implemented Syntax Conversion");

        // fall through

    case OM_S_NULL:
    case OM_S_ENCODING_STRING:
    default:
        // huh?
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
    }

    return dwErr;
}


//
//  ConvertScriptElementToDirAttr
//
//  Description:
//
//     Convert a ScriptAttribute to an ATTR
//
//  Arguments:
//
//      pElement - the ScriptAttribute to convert
//      pAttr - where to store the resulted Attr
//
//  Return Value:
//
//     0 on success
//     Win32 error on failure
// 
//
DWORD ConvertScriptElementToDirAttr (THSTATE *pTHS, 
                                     ScriptAttribute *pElement,  
                                     ATTR *pAttr)
{
    DWORD            dwErr=0;
    ATTCACHE        *pAC;

    do {
        
        pAC = getAttByNameW( pTHS, pElement->m_name);
        if (!pAC) {
            dwErr = ScriptParseError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            break;
        }

        pAttr->attrTyp = pAC->id;
        pAttr->AttrVal.valCount = 1;
        pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));

        dwErr = ConvertScriptValueToDirAttrVal (pTHS, pAC, pElement->m_characters, &pAttr->AttrVal.pAVal[0]);

    } while ( 0 );

    return dwErr;
}



//
//  ScriptInstantiatedRequest
//
//  Description:
//
//     Implement the Instantiated request
//
//  Arguments:
//
//      pObjectDN - the object to be checked for instantiated
//      pfisInstantiated - where to store the result
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptInstantiatedRequest (DSNAME *pObjectDN, BOOL *pfisInstantiated)
{
    THSTATE     *pTHS = pTHStls;
    DWORD        dwErr=0;
    ULONG        it;

    DPRINT1 (0, "Instantiated on Object: %ws\n", pObjectDN->StringName);

    *pfisInstantiated = FALSE;

    do {
        switch (dwErr = DBFindDSName(pTHS->pDB, pObjectDN)){

        case 0:
            // Get the instance type
            dwErr = DBGetSingleValue(pTHS->pDB,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);

            switch(dwErr) {
            case DB_ERR_NO_VALUE:
                // No instance type is an uninstantiated object
                it = IT_UNINSTANT;
                dwErr = 0;
                break;

            case 0:
                // No action.
                break;

            case DB_ERR_VALUE_TRUNCATED:
            default:
                // Something unexpected and bad happened.  Bail out.
                LogUnhandledErrorAnonymous(dwErr);
                dwErr = ScriptParseError (dwErr);
            }

            if (dwErr) {
                break;
            }

            if( it & IT_WRITE) {
                *pfisInstantiated = TRUE;
            }
            break;

        case DIRERR_OBJ_NOT_FOUND:
        case DIRERR_NOT_AN_OBJECT:

            // object is not instantiated
            dwErr = 0;
            break;

        default:
            dwErr = ScriptParseError (dwErr);

        }  /*switch*/

    } while ( 0 );

    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Instantiated Check. ObjectGUID:", &pObjectDN->Guid );
    }
    ScriptLogPrint ( (DSLOG_TRACE, "Instantiated Check (%ws)=%ws  Result: %d(0x%x)\n", 
                                pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                                *pfisInstantiated ? L"TRUE" : L"FALSE", 
                                dwErr, dwErr) );        

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_INSTANTIATED,
             szInsertDN(pObjectDN), szInsertHex(*pfisInstantiated), szInsertHex(dwErr) );

    return dwErr;
}


//
//  ScriptCardinalityRequest
//
//  Description:
//
//     Implement the Cardinality request
//
//  Arguments:
//
//      pObjectDN - the object to base the search request for cardinality
//      searchType - base, onelevel, subtree
//      pFilter - the filter to use
//      dwCardinality (OUT) - the number of objects found
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCardinalityRequest (DSNAME *pObjectDN, DWORD searchType, FILTER *pFilter, DWORD *pCardinality)
{
    THSTATE     *pTHS = pTHStls;
    SEARCHARG    SearchArg;
    SEARCHRES    SearchRes;
    ENTINFSEL    EntInfSel;
    ATTR         attrObjectGuid;
    DWORD        dwErr=0;
    BOOL         fMoreData;
    PRESTART     pRestart;
    DWORD        i = 0;

    *pCardinality = 0;

    do {
        //
        // Setup the Attribute Select parameter
        //
        attrObjectGuid.attrTyp = ATT_OBJECT_GUID;
        attrObjectGuid.AttrVal.valCount = 0;
        attrObjectGuid.AttrVal.pAVal = NULL;

        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
        EntInfSel.AttrTypBlock.attrCount = 1;
        EntInfSel.AttrTypBlock.pAttr = &attrObjectGuid;

        // Initialize 

        memset(&SearchArg, 0, sizeof(SEARCHARG));
        memset(&SearchRes, 0, sizeof (SEARCHRES));
        InitCommarg(&SearchArg.CommArg);

        SearchArg.pObject = pObjectDN;

        SearchArg.choice = searchType;
        SearchArg.bOneNC = TRUE;
        SearchArg.pFilter = pFilter;
        SearchArg.pSelection = &EntInfSel;
        SearchArg.pSelectionRange = NULL;

        fMoreData = TRUE;
        pRestart = NULL;

        while (fMoreData) {

            SearchArg.CommArg.PagedResult.fPresent = TRUE;
            SearchArg.CommArg.PagedResult.pRestart = pRestart;
#ifdef DBG
            SearchArg.CommArg.ulSizeLimit = 4;
#else
            SearchArg.CommArg.ulSizeLimit = 200;
#endif
            
            if (eServiceShutdown) {
                break;
            }

            SearchBody(pTHS, &SearchArg, &SearchRes, 0);
            dwErr = pTHS->errCode;

            if (dwErr) {
                break;
            }

            // Set fMoreData for next iteration
            if ( !( (SearchRes.PagedResult.pRestart != NULL)
                        && (SearchRes.PagedResult.fPresent)
                  ) ) {
                // No more data needs to be read. So no iterarions needed after this
                fMoreData = FALSE;
            }
            else {
                // more data. save off the restart to use in the next iteration.
                pRestart = SearchRes.PagedResult.pRestart;
            }

            *pCardinality += SearchRes.count;

            DBFreeSearhRes (pTHS, &SearchRes, FALSE);

            DPRINT2 (0, "Cardinality (iteration: %d) = %d\n", ++i, *pCardinality);
        }

    } while ( 0 );


    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Cardinality Check. ObjectGUID:", &pObjectDN->Guid );
    }
    ScriptLogPrint ( (DSLOG_TRACE, "Cardinality Check (%ws). Found=(%d) Type=(%d) Result: %d(0x%x)\n", 
                                pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                                *pCardinality, 
                                searchType,
                                dwErr, dwErr) );        

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_CARDINALITY,
             szInsertDN(pObjectDN), szInsertHex(*pCardinality), szInsertHex(dwErr) );

    return dwErr;
}


//
//  ScriptCompareRequest
//
//  Description:
//
//     Implement the Compare request
//
//  Arguments:
//
//      pObjectDN - the object we are checking values of
//      pAttribute - the name of the attribute we are interested in
//      pAttrVal - the expected value of the attribute
//      pDefaultVal - the default value we should compare against if the
//                    attribute is not present on the object
//      pfMatch (OUT) - the compare result (TRUE = the same)
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCompareRequest (DSNAME *pObjectDN, WCHAR *pAttribute, WCHAR *pAttrVal, WCHAR *pDefaultVal, BOOL *pfMatch)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    COMPAREARG       CompareArg;
    COMPARERES       CompareRes;
    ATTCACHE        *pAC;

    // Initialize 

    memset(&CompareArg, 0, sizeof(COMPAREARG));
    memset (&CompareRes, 0, sizeof (COMPARERES));
    InitCommarg(&CompareArg.CommArg);

    *pfMatch = FALSE;

    do {

        pAC = getAttByNameW( pTHS, pAttribute);
        if (!pAC) {
            ScriptLogLevel (0, ScriptLogPrint ( (DSLOG_ERROR, "Unknown Attribute: %ws\n", pAttribute) ) );
            dwErr = ScriptParseError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            break;
        }

        CompareArg.pObject = pObjectDN;
        CompareArg.Assertion.type = pAC->id;

        if (dwErr = ConvertScriptValueToDirAttrVal (pTHS, pAC, pAttrVal, &CompareArg.Assertion.Value)) {
            break;
        }

        if (DoNameRes(pTHS, 0, CompareArg.pObject, &CompareArg.CommArg,
                                   &CompareRes.CommRes, &CompareArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        dwErr = LocalCompare(pTHS, &CompareArg, &CompareRes);
        DPRINT2 (0, "Compare result %d. Matched=%d\n", dwErr, CompareRes.matched);
        if (CompareRes.matched) {
            *pfMatch = TRUE;
        }
        else if (dwErr == attributeError && pDefaultVal) {
            if (wcscmp (pAttrVal, pDefaultVal) == 0) {
                *pfMatch = TRUE;
            }
            pTHS->errCode = dwErr = 0;
            DPRINT2 (0, "Compare is using default value: %ws. Matched=%d\n", pDefaultVal, *pfMatch);
        }

    } while ( 0 );

    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Compare Check. ObjectGUID:", &pObjectDN->Guid );
    }
    ScriptLogPrint ( (DSLOG_TRACE, "Compare Check (%ws)  Attr(%ws)?=(%ws) = (%ws) Result: %d(0x%x)\n", 
                        pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                        pAttribute,
                        pAttrVal,
                        *pfMatch ? L"TRUE" : L"FALSE", 
                        dwErr, dwErr) );        

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_COMPARE,
             szInsertDN(pObjectDN), szInsertHex(*pfMatch), szInsertHex(dwErr) );

    return dwErr;
}

//
//  ScriptUpdateRequest
//
//  Description:
//
//     Implement the Update request
//
//  Arguments:
//
//      pObjectDN - the object we are updating values of
//      attributesList - the list of attributes we are updating
//      metadataUpdate - whether to update metadata or not
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptUpdateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributesList, BOOL metadataUpdate)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    MODIFYARG        modifyArg;
    MODIFYRES        modRes;
    ATTRMODLIST      *pMod, *pModTemp;
    DWORD            cModCount=0;
    DWORD            cbLen;
    DWORD            i,j;

    ATTCACHE        *pAC;
    BOOL            fOldMetaDataUpdate;
    
    ScriptAttributeList::iterator it = attributesList.begin();
    ScriptAttribute *pAttrEl;


    DPRINT1 (0, "Updating Object: %ws\n", pObjectDN->StringName);


    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Update. ObjectGUID:", &pObjectDN->Guid );
    }
    if (pObjectDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Update (%ws)\n", pObjectDN->StringName) );        
    }


    it = attributesList.begin();
    while (it != attributesList.end()) {

        pAttrEl = *it;

        ScriptLogPrint ( (DSLOG_TRACE, "Update Attr(%ws)=%ws  Type(%d)\n", 
                                pAttrEl->m_name, 
                                pAttrEl->m_characters,
                                pAttrEl->m_operation_type) );      

        it++;
    }

    // Initialize 
    
    memset(&modifyArg, 0, sizeof(modifyArg));
    memset(&modRes, 0, sizeof(modRes));
    InitCommarg(&modifyArg.CommArg);

    // we don't care if the value was not there by default when we modify the object
    modifyArg.CommArg.Svccntl.fPermissiveModify = TRUE;

    // do we really want to update metadata ?
    fOldMetaDataUpdate = pTHS->pDB->fSkipMetadataUpdate;
    pTHS->pDB->fSkipMetadataUpdate = !metadataUpdate;

    do {
        modifyArg.pObject = pObjectDN;

        // Perform name resolution to locate object.  If it fails, just
        // return an error, which may be a referral.  
        // We need a writable copy of the object
        if (DoNameRes(pTHS, 0, modifyArg.pObject, &modifyArg.CommArg,
                                   &modRes.CommRes, &modifyArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        pMod = &modifyArg.FirstMod;

        it = attributesList.begin();
        while (it != attributesList.end()) {

            pMod->pNextMod = NULL;
            
            pAttrEl = *it;

            pAC = getAttByNameW( pTHS, pAttrEl->m_name);
            if (!pAC) {
                DPRINT1 (0, "Attribute Not Found In Schema: %ws\n", pAttrEl->m_name);
                dwErr = ScriptParseError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
                break;
            }

            // if the attribute is not a member of partial Attribute Set
            // and the object is not writable, 
            if (!pAC->bMemberOfPartialSet && 
                !(modifyArg.pResObj->InstanceType & IT_WRITE)) {
                
                DPRINT1 (0, "Skipping update of attribute %ws because not in GC set\n", pAttrEl->m_name);

                it++;
                continue;
            }

            DPRINT2 (0, "Update Attribute %s=%ws\n", pAC->name, pAttrEl->m_characters);

            switch (pAttrEl->m_operation_type) {
            case ScriptAttribute::SCRIPT_OPERATION_APPEND:
                pMod->choice = AT_CHOICE_ADD_ATT;
                break;
            case ScriptAttribute::SCRIPT_OPERATION_REPLACE:
                pMod->choice = AT_CHOICE_REPLACE_ATT;
                break;
            case ScriptAttribute::SCRIPT_OPERATION_DELETE:
                pMod->choice = AT_CHOICE_REMOVE_ATT;
                break;
            }

            if (dwErr = ConvertScriptElementToDirAttr (pTHS, pAttrEl, &pMod->AttrInf)) {
                break;
            }

            it++;
            cModCount++;

            if (it != attributesList.end()) {
                pMod->pNextMod = (ATTRMODLIST *) THAllocEx (pTHS, sizeof (ATTRMODLIST));
                pMod = pMod->pNextMod;
            }
        }

        if (dwErr) {
            break;
        }

        modifyArg.count = cModCount;

        // do the modify call
        //
        LocalModify(pTHS, &modifyArg);
        dwErr =  pTHS->errCode;

        DPRINT1 (0, "Update result %d\n", dwErr);

    } while ( 0 );

    // free MODIFYARG
    pMod = &modifyArg.FirstMod;
    while (pMod) {
        if (pMod->AttrInf.AttrVal.pAVal) {
            if (pMod->AttrInf.AttrVal.pAVal->pVal) {
                THFreeEx (pTHS, pMod->AttrInf.AttrVal.pAVal->pVal);
            }
            THFreeEx (pTHS, pMod->AttrInf.AttrVal.pAVal);
        }

        pModTemp = pMod;
        pMod = pMod->pNextMod;
        
        // the first one is not allocated
        if ( pModTemp != &modifyArg.FirstMod ) {
            THFreeEx (pTHS, pModTemp);
        }
    }

    pTHS->pDB->fSkipMetadataUpdate = fOldMetaDataUpdate;

    ScriptLogPrint ( (DSLOG_TRACE, "Update Result = %d(0x%x)\n", dwErr, dwErr) );      

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_UPDATE,
             szInsertDN(pObjectDN), szInsertHex(dwErr), NULL );

    return dwErr;
}

//
//  ScriptMoveRequest
//
//  Description:
//
//     Implement the Move request
//
//  Arguments:
//
//      pObjectDN - the source object 
//      pDestDN - the destination object (not the destination parent)
//      metadataUpdate - whether to update metadata or not (1 or 0)
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptMoveRequest (DSNAME *pObjectDN, DSNAME *pDestDN, BOOL metadataUpdate)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    MODIFYDNARG      modifyDNArg;
    MODIFYDNRES      modifyDNRes;
    DSNAME          *pNewParentDN = NULL;
    ATTRBLOCK       *pDestBlockName = NULL;
    RESOBJ          *pParentResObj = NULL;
    COMMRES          commRes;

    // Initialize 
    
    memset(&modifyDNArg, 0, sizeof(modifyDNArg));
    memset(&modifyDNRes, 0, sizeof(modifyDNRes));
    memset (&commRes, 0, sizeof (COMMRES));
    InitCommarg(&modifyDNArg.CommArg);

    // do we really want to update metadata ?
    pTHS->pDB->fSkipMetadataUpdate = !metadataUpdate;

    DPRINT2 (0, "Moving Object: %ws ===> %ws\n", pObjectDN->StringName, pDestDN->StringName);
        
    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Move Source. ObjectGUID:", &pObjectDN->Guid );
    }
    if (pObjectDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Move Source (%ws)\n", pObjectDN->StringName) );        
    }

    if (fNullUuid(&pDestDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Move Dest. ObjectGUID:", &pDestDN->Guid );
    }
    if (pDestDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Move Dest (%ws)\n", pDestDN->StringName) );        
    }


    do {
        // break the dsname in parts
        if (dwErr = DSNameToBlockName (pTHS, pDestDN, &pDestBlockName, FALSE)) {
            break;
        }
        Assert (pDestBlockName->attrCount);

        // get the new parent
        pNewParentDN = (DSNAME *) THAllocEx(pTHS, pDestDN->structLen);

        if (TrimDSNameBy ( pDestDN, 1, pNewParentDN)) {
            dwErr = ScriptParseError(0);
            break;
        }
        modifyDNArg.pObject = pObjectDN;
        modifyDNArg.pNewParent = pNewParentDN;
        
        // get the newRDN
        modifyDNArg.pNewRDN = &pDestBlockName->pAttr[pDestBlockName->attrCount-1];

        // we don't need a writable copy of the object
        modifyDNArg.CommArg.Svccntl.dontUseCopy = FALSE;

        // check to see that the new parent exists
        // if it does not exist, create a phantom
        if (DoNameRes(pTHS,
                      0,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)){

            modifyDNArg.fAllowPhantomParent = TRUE;

            pTHS->errCode = 0;

            if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)) {
                
                DPRINT1 (0, "ScriptMoveRequest: New Parent exists as a phantom: %ws\n", pNewParentDN->StringName);
            }
            else {
                DPRINT1 (0, "ScriptMoveRequest: New Parent does not exist: %ws\n", pNewParentDN->StringName);
            }

            pTHS->errCode = 0;

            dwErr = DBFindDSName( pTHS->pDB, pNewParentDN );
            DPRINT1 (0, "ScriptMoveRequest: FindParent: %d\n", dwErr);

            dwErr = DBFindDSName( pTHS->pDB, modifyDNArg.pObject );
            DPRINT1 (0, "ScriptMoveRequest: FindObject: %d\n", dwErr);

            // we can use a phantom as the object
            if (dwErr && dwErr != ERROR_DS_NOT_AN_OBJECT) {
                pTHS->errCode = dwErr;
                break;
            }

            // do the trick so as to write the new phantom parent
            dwErr = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                              pNewParentDN->structLen,
                              pNewParentDN);

            if (dwErr) {
                pTHS->errCode = dwErr;
                break;
            }

            // and remove the value since it is not needed
            dwErr = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                              pNewParentDN->structLen,
                              pNewParentDN);

            dwErr = DBRepl( pTHS->pDB, FALSE, 0, NULL, 0 );
            if (dwErr) {
                pTHS->errCode = dwErr;
                break;
            }

            if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)) {

                DPRINT1 (0, "ScriptMoveRequest: New Parent STILL does not exist: %ws\n", pNewParentDN->StringName);
                Assert (!"New Parent STILL does not exist");
                dwErr =  pTHS->errCode;
                break;
            }
        }
        
        // fill in the pResObj
        if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      modifyDNArg.pObject,
                      &modifyDNArg.CommArg,
                      &modifyDNRes.CommRes,
                      &modifyDNArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }

        // Local Modify operation

        LocalModifyDN(pTHS,
                      &modifyDNArg,
                      &modifyDNRes);

        dwErr =  pTHS->errCode;

    } while ( 0 );
    
    ScriptLogPrint ( (DSLOG_TRACE, "Move Result %d(0x%x)\n", dwErr, dwErr) );        

    pTHS->pDB->fSkipMetadataUpdate = 0;

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_MOVE,
             szInsertDN(pObjectDN), 
             szInsertDN(pDestDN),
             szInsertHex(dwErr));

    return dwErr;
}

//
//  ScriptCreateRequest
//
//  Description:
//
//     Implement the Create request
//
//  Arguments:
//
//      pObjectDN - the object we are adding
//      attributesList - the list of attributes on the object
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCreateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributesList)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    ADDARG           addArg;
    ADDRES           addRes;
    ATTRMODLIST      *pMod;
    DWORD            cAttrCount=0;
    ATTRBLOCK       *pAttrBlock;
    ATTR            *pAttr;
    DSNAME          *pParentDN = NULL;

    ScriptAttributeList::iterator it = attributesList.begin();
    ScriptAttribute *pAttrEl;

    // Initialize 
    
    memset(&addArg, 0, sizeof(addArg));
    InitCommarg(&addArg.CommArg);

    do {

        addArg.pObject = pObjectDN;

        // get the parent
        pParentDN = (DSNAME *) THAllocEx(pTHS, pObjectDN->structLen);

        if (TrimDSNameBy ( pObjectDN, 1, pParentDN)) {
            dwErr = ScriptParseError(0);
            break;
        }

        if (DoNameRes(pTHS, 0, pParentDN, &addArg.CommArg,
                                   &addRes.CommRes, &addArg.pResParent)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        pAttrBlock = &addArg.AttrBlock;

        pAttrBlock->pAttr = (ATTR *)THAllocEx (pTHS, sizeof (ATTR) );

        while (it != attributesList.end()) {

            pAttrEl = *it;

            pAttr = &pAttrBlock->pAttr[cAttrCount];
            
            if (dwErr = ConvertScriptElementToDirAttr (pTHS, pAttrEl, pAttr)) {
                break;
            }

            DPRINT2 (0, "Add Attr %ws=%ws\n", pAttrEl->m_name, pAttrEl->m_characters);

            it++;
            cAttrCount++;

            if (it != attributesList.end()) {
                pAttrBlock->pAttr = (ATTR *)THReAllocEx(pTHS, pAttrBlock->pAttr, sizeof (ATTR) * (cAttrCount+1));
            }
        }

        if (dwErr) {
            break;
        }

        pAttrBlock->attrCount = cAttrCount;

        // do the call
        //
        LocalAdd(pTHS, &addArg, FALSE);
        dwErr = pTHS->errCode;

    } while ( 0 );

    ScriptLogPrint ( (DSLOG_TRACE, "Add Result %d(0x%x)\n", dwErr, dwErr) );        
    
    // free ADDARG

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_CREATE,
             szInsertDN(pObjectDN), 
             szInsertHex(dwErr), NULL);

    return dwErr;
}

//
//  ScriptComputeHashAndSignature
//
//  Description:
//
//     Calculate hash keys for the script
//
//  Arguments:
//
//      pStream - the script
//      cchStream - the lenght of the script
//      ppComputedSignature - the signature H (body + key)
//      pcbComputedSignature - the lenght of the signature
//      ppHashBody - the hash of the body H (body)
//      pcbHashBody - the lenght of the hash body
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptComputeHashAndSignature (THSTATE *pTHS,
                                     WCHAR   *pStream,
                                     DWORD    cchStream,
                                     BYTE   **ppSignature,
                                     DWORD   *pcbSignature,
                                     BYTE   **ppHashBody,
                                     DWORD   *pcbHashBody)
{
    DWORD      dwErr = 0;
    HCRYPTPROV hCryptProv = NULL; 
    HCRYPTHASH hHash = NULL;
    HCRYPTHASH hDupHash = NULL;


    *ppHashBody =  (BYTE *)THAllocEx (pTHS,  20);
    *ppSignature = (BYTE *)THAllocEx (pTHS,  20);
    *pcbSignature = *pcbHashBody = 20;

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT | CRYPT_MACHINE_KEYSET)) {

            dwErr = GetLastError();

            if (dwErr == NTE_BAD_KEYSET) {

                dwErr = 0;

                if(!CryptAcquireContext(&hCryptProv, 
                                        NULL, 
                                        NULL, 
                                        PROV_RSA_FULL, 
                                        CRYPT_SILENT | CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)) {

                    dwErr = GetLastError();

                    __leave;
                }
            }
            else {
                __leave;
            }
        }

        // Create the hash object.

        if(!CryptCreateHash(hCryptProv, 
                            CALG_SHA1, 
                            0, 
                            0, 
                            &hHash)) {
            dwErr = GetLastError();
            __leave;
        }


        // Compute the cryptographic hash of the buffer.

        if(!CryptHashData(hHash, 
                         (BYTE *)pStream,
                         cchStream * sizeof (WCHAR),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }

        // we have the common part of the hash ready (H(buf), now duplicate it
        // so as to calc the H (buf + guid)

        if (!CryptDuplicateHash(hHash, 
                               NULL, 
                               0, 
                               &hDupHash)) {
            dwErr = GetLastError();
            __leave;
        }


        if (!CryptGetHashParam(hHash,    
                               HP_HASHVAL,
                               *ppHashBody,
                               pcbHashBody,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        Assert (*pcbHashBody == 20);

        
        if(!CryptHashData(hDupHash, 
                         (BYTE *)&guidDomainRename,
                         sizeof (GUID),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }
        
        if (!CryptGetHashParam(hDupHash,    
                               HP_HASHVAL,
                               *ppSignature,
                               pcbSignature,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        Assert (*pcbSignature == 20);

    }
    __finally {

        if (hDupHash)
            CryptDestroyHash(hDupHash);

        if(hHash) 
            CryptDestroyHash(hHash);

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);
    }

    return dwErr;
}


//
//  ScriptCalculateAndCheckHashKeys
//
//  Description:
//
//     Calculate hash keys for the script
//     Checks to see whether hash keys match the one on the script
//
//  Arguments:
//
//      pwScript - the script
//      cchScriptLen - the lenght of the script
//      ppComputedSignature - the signature H (body + key)
//      pcbComputedSignature - the lenght of the signature
//      ppHashBody - the hash of the body H (body)
//      pcbHashBody - the lenght of the hash body
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCalculateAndCheckHashKeys (THSTATE *pTHS, 
                                       IN WCHAR   *pwScript,
                                       IN DWORD    cchScriptLen,
                                       OUT BYTE    **ppComputedSignature,
                                       OUT DWORD   *pcbComputedSignature,
                                       OUT BYTE    **ppHashBody,
                                       OUT DWORD   *pcbHashBody
                                       )
{
    DWORD dwErr = 0;
    WCHAR *pwSignature = NULL;
    
    CHAR  *pSignatureText = NULL;
    DWORD  cbSignature;
    
    BYTE   Signature[20];

    #if DBG
    CHAR   dbgSig[100];
    DWORD  dwSig;
    #endif
    
    // get the signature out of the string
    // 20 bytes as base64 encoded as 28 bytes
    //
    if (cchScriptLen > 28) {

        do {
            cchScriptLen -= 28;
            pwSignature = pwScript + cchScriptLen;
            
            pSignatureText = (CHAR *)String8FromUnicodeString(TRUE, 
                                                              CP_UTF8, 
                                                              pwSignature, 
                                                              -1, 
                                                              (LPLONG)&cbSignature, 
                                                              NULL);

            dwErr = base64decode(pSignatureText, 
                                 Signature,
                                 sizeof (Signature),
                                 &cbSignature);

            if (FAILED(dwErr)) {
                dwErr = ERROR_DS_INVALID_SCRIPT;
                break;
            }


            // remove the signature from the script
            *pwSignature = 0;

            if (dwErr = ScriptComputeHashAndSignature (pTHS, 
                                                       pwScript,
                                                       cchScriptLen,
                                                       ppComputedSignature,
                                                       pcbComputedSignature,
                                                       ppHashBody,
                                                       pcbHashBody)) {
                break;
            }

            #if DBG
            if (dwErr = base64encode(*ppComputedSignature, 
                             *pcbComputedSignature, 
                             dbgSig,
                             100,
                             &dwSig)) {

                DPRINT (0, "Error encoding signature\n");

                return dwErr;
            }
            //DPRINT1 (0, "Script: %ws\n", pwScript);
            DPRINT3 (0, "ScriptLen: %d  %d (%d)\n", cchScriptLen, wcslen (pwScript), cchScriptLen*2);
            DPRINT1 (0, "Stored Signature:%s|\n", pSignatureText);
            DPRINT1 (0, "Computed Signature:%s|\n", dbgSig);
            #endif


            if ((cbSignature != *pcbComputedSignature) || 
                memcmp (Signature, *ppComputedSignature, *pcbComputedSignature)!=0) {
                dwErr = ERROR_DS_INVALID_SCRIPT;
            }
            else {
                DPRINT (0, "Script is SIGNED\n ");
            }

        } while ( 0 );

    }
    else {

        dwErr = ERROR_DS_INVALID_SCRIPT;

    }

    return dwErr;
}


//
//  ScriptReadFromDatabase
//
//  Description:
//
//     Read the script from the database
//     Checks to see whether the script is signed using the provided key
//
//  Arguments:
//
//      ppScript - where to store the script
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptReadFromDatabase (THSTATE *pTHS, WCHAR **ppScript, DWORD *pcchLen)
{
    DWORD dwErr;
    DWORD cbActual;
    
    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:
        dwErr = DBGetAttVal (pTHS->pDB, 
                             1, 
                             ATT_MS_DS_UPDATESCRIPT,
                             DBGETATTVAL_fREALLOC,
                             0,
                             &cbActual,
                             (UCHAR **)ppScript);

        if (dwErr) {
            DPRINT1 (0, "ScriptReadFromDatabase: Error reading value: %d\n", dwErr);
        }
        else {
            *ppScript = (WCHAR *)THReAllocEx (pTHS, *ppScript, cbActual+sizeof(WCHAR));
            *pcchLen = cbActual/sizeof(WCHAR);
            (*ppScript)[*pcchLen]=0;

            DPRINT1 (0, "ScriptReadFromDatabase: XML script %d bytes\n", cbActual); 
        }
        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    return dwErr;
}


//
//  ScriptGenerateAndStorePassword
//
//  Description:
//
//     Generate a password and store it in the database
//
//  Arguments:
//
//      ppPassword - the password returned to the user
//      pcbPassword - the lenght of the password generated
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptGenerateAndStorePassword (THSTATE *pTHS, 
                                      BYTE **ppPassword, 
                                      DWORD *pcbPassword)
{
    DWORD dwErr = 0;
    HCRYPTPROV hCryptProv = NULL; 

    *pcbPassword = 8;
    *ppPassword = (BYTE *)THAllocEx (pTHS, *pcbPassword);

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT | CRYPT_MACHINE_KEYSET)) {
            dwErr = GetLastError();
            __leave;
        }

        if (!CryptGenRandom(hCryptProv,
                            *pcbPassword, 
                            *ppPassword)) {

            dwErr = GetLastError();
            __leave;
        }
    }
    __finally {

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);
    }

    if (dwErr) {
        return dwErr;
    }


    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:

        if (dwErr = DBReplaceAttVal (pTHS->pDB, 
                                     1, 
                                     ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                                     *pcbPassword,
                                     *ppPassword)) {

            DPRINT1 (0, "ScriptGenerateAndStorePassword: Error writing value: %d\n", dwErr);
        }
        else {
            DBUpdateRec(pTHS->pDB);
        }

        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    return dwErr;
}



DWORD ScriptPrepareForParsing (THSTATE    *pTHS, 
                               IN WCHAR  **ppScript,
                               BSTR      *pBstrScript)
{

    // create a variant for the value passed to the Parser
    *pBstrScript = SysAllocString(  *ppScript );
    if (!*pBstrScript) {
        return ERROR_OUTOFMEMORY;
    }

    // we don't need the value anymore since we converted it
    THFreeEx (pTHS, *ppScript); *ppScript = NULL;

    return 0;
}

//
//  ScriptExecute
//
//  Description:
//
//     Read the script from the database
//     Checks to see whether the script is signed using the provided key
//
//  Arguments:
//
//      fPerformUpdate - whether to perform the update or not (preprocess - process)
//      pBstrScript - the script to execute. This string should have been prepared with 
//                    ScriptPrepareForParsing
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptExecute (THSTATE *pTHS, BOOL fPerformUpdate, BSTR pBstrScript, WCHAR ** ppErrMessage )
{
    HRESULT             hr = S_OK;
    DWORD               err = 0;
    DWORD               retCode;
    ISAXXMLReader *     pReader = NULL;
    NTDSContent*        pHandler = NULL; 
    IClassFactory *     pFactory = NULL;

    VARIANT             varScript;
    const WCHAR         *pErrMessage = NULL;

    //::CoInitialize(NULL);
    
    try {
        // create a variant for the value passed to the Parser
        VariantInit(&varScript);
        varScript.vt = VT_BYREF|VT_BSTR;
        varScript.pbstrVal = &pBstrScript; 
        
        // do the COM creation of the SAMXMLReader manually
        GetClassFactory( CLSID_SAXXMLReader, &pFactory);

        hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

        if(!FAILED(hr)) 
        {
            pHandler = new NTDSContent();
            hr = pReader->putContentHandler(pHandler);

            SAXErrorHandlerImpl * pEc = new SAXErrorHandlerImpl();
            hr = pReader->putErrorHandler(pEc);

            hr = pReader->parse(varScript);
            ScriptLogPrint ( (DSLOG_TRACE,  "XML Parse result code: 0x%08x\n",hr) );

            if(FAILED(hr)) {
                err = ScriptParseError(hr);
            }
            else {
                err = pHandler->Process (SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS, retCode, &pErrMessage);

                ScriptLogPrint ( (DSLOG_TRACE,  "Syntax Validate Processing: 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\n", err, retCode, retCode, pErrMessage) );

                if (!err && !retCode) {
                    if (!fPerformUpdate) {
                        err = pHandler->Process (SCRIPT_PROCESS_PREPROCESS_PASS, retCode, &pErrMessage);
                        ScriptLogPrint ( (DSLOG_TRACE,  "Execute Preprocessing(RO): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws) \n", err, retCode, retCode, pErrMessage) );
                    }
                    else {
                        err = pHandler->Process (SCRIPT_PROCESS_EXECUTE_PASS, retCode, &pErrMessage);
                        ScriptLogPrint ( (DSLOG_TRACE,  "Execute Processing(RW): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\n", err, retCode, retCode, pErrMessage) );
                    }
                }

                // set error accordingly to fail transaction
                // err means that we had an error parsing / executing
                if (err) {
                    pTHS->errCode = err;
                }
                // retcode means that something was not as expected in the data
                // stored in the DS
                else if (retCode) {
                    err = pTHS->errCode = retCode;
                }
            }
        }
        else 
        {
            err = ScriptParseError(hr);
            ScriptLogPrint ( (DSLOG_ERROR,  "Error Parsing XML: 0x%08x\n",hr) );
        }
    }
    catch (...) {
        err = ScriptParseError(ERROR_EXCEPTION_IN_SERVICE);
    }

    if (pErrMessage && ppErrMessage) {
        *ppErrMessage = (WCHAR *)THAllocEx (pTHS, wcslen (pErrMessage) * sizeof (WCHAR) + sizeof (WCHAR));

        wcscpy (*ppErrMessage, pErrMessage);
    }

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    //::CoUninitialize();

    return err;
}

//
//  ScriptAsyncDsShutdown
//
//  Description:
//
//     Asyncronously Unitialize the DS
//     This function should be the entry point of a new thread
//
//  Arguments:
//
//
//  Return Value:
//
//     0 on success
// 
//
unsigned int ScriptAsyncDsShutdown ( void * StartupParam )
{
    HMODULE    ResourceDll;
    WCHAR     *ErrorMessage = NULL;
    BOOLEAN    WasEnabled;
    DWORD      dwErr = 0;

    
    // Get Message String from NTSTATUS code
    //
    ResourceDll = (HMODULE) GetModuleHandleW( L"ntdll.dll" );

    if (NULL != ResourceDll)
    {
        FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |    // find message from ntdll.dll
                       FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       ResourceDll,                     // source dll
                       STATUS_DS_SHUTTING_DOWN,          // message ID
                       0,                               // language ID 
                       (LPWSTR)&ErrorMessage,           // address of return Message String
                       0,                               // maximum buffer size if not 0
                       NULL                             // can not insert arguments, so set to NULL
                       );

        FreeLibrary(ResourceDll);
    }

    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME,
             NULL, NULL, NULL );
    
/*
    HANDLE hToken;              // handle to process token 
    TOKEN_PRIVILEGES tkp;       // pointer to token structure 

    BOOL fResult;               // system shutdown flag 

    do {


        // Get the current process token handle so we can get shutdown 
        // privilege. 

        if (!OpenProcessToken(GetCurrentProcess(), 
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {

            dwErr = GetLastError();

            DPRINT1 (0, "OpenProcessToken failed.\n, 0x%x", dwErr); 
            break;
        }

        // Get the LUID for shutdown privilege. 

        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                &tkp.Privileges[0].Luid); 

        tkp.PrivilegeCount = 1;  // one privilege to set    
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

        // Get shutdown privilege for this process. 

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES) NULL, 0); 

        // Cannot test the return value of AdjustTokenPrivileges. 

        if ( (dwErr = GetLastError()) != ERROR_SUCCESS) {
            DPRINT1 (0, "AdjustTokenPrivileges enable failed.: 0x%x\n", dwErr); 
            break;
        }


    } while (0);
*/
    
    DPRINT (0, "Partially Shutting Down System\n");
    
    DsUninitialize (TRUE);

    if (gfRunningInsideLsa) {

        // adjust privilege level, issue shutdown request.
        //
        dwErr = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            TRUE,       // enable shutdown privilege.
                            FALSE,
                            &WasEnabled
                           );

        ASSERT( NT_SUCCESS( dwErr ) );

        DPRINT (0, "Initiating shutdown of system\n");

        dwErr = InitiateSystemShutdownExW( NULL,       // computer name
                                         ErrorMessage, // message to display
                                         60,           // length of time to display
                                         TRUE,         // force closed option
                                         TRUE,          // reboot option
                                         ERROR_DS_SHUTTING_DOWN
                                        );

        if (!dwErr) {
            dwErr = GetLastError ();

            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME_FORCE,
                     szInsertHex(dwErr),
                     NULL, NULL );

            DPRINT1 (0, "Error %d performing shutdown. Forcing Shutdown of DS\n", dwErr);
        }
        else {
            dwErr=0;
        }

    }

    DPRINT (0, "Shutting Down System\n");
    
    ScriptLogPrint ( (DSLOG_TRACE, "Shutting Down System\n") );        

    DsUninitialize (FALSE);

    if (!gfRunningInsideLsa) {
        return 0;
    }

    // force shutdown if we failed
    if (dwErr) {
        ScriptLogPrint ( (DSLOG_TRACE, "Forcing Shut Down System: 0x%x\n", dwErr) );        

        ScriptLogFlush();
        
        NtShutdownSystem(ShutdownReboot);
    }

    if (ErrorMessage != NULL) {
        LocalFree(ErrorMessage);
    }

    // wait for shutdown to happen
    Sleep (120 * 1000);

    return 0;
}

//
//  ScriptExecuteDSShutdown
//
//  Description:
//
//     Shutdown the DS after the completion of the script execution
//
//  Arguments:
//
//
//  Return Value:
//
//     0 on success
// 
//
void ScriptExecuteDSShutdown()
{
    unsigned   ulThreadId;
    DWORD      dwShutDown;

    if(!_beginthreadex(NULL,
                       0,
                       ScriptAsyncDsShutdown,
                       NULL,
                       0,
                       &ulThreadId)) {

        dwShutDown = GetLastError ();

        // failed, so will do the shutdown asyncronously.
        DPRINT (0, "Failed to Asyncrounously Unitialize DS. Forcing Shutdown of DS\n");

        ScriptLogPrint ( (DSLOG_TRACE, "Failed to Asyncrounously Unitialize DS. Forcing Shutdown of DS: 0x%x\n", dwShutDown) );        

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME_FORCE,
                 szInsertHex(dwShutDown),
                 NULL, NULL );

        DsUninitialize (FALSE);

        if (gfRunningInsideLsa) {
            NtShutdownSystem(ShutdownReboot);
            ScriptLogFlush();
        }
    }
}

//
//  ScriptGetNewDomainName
//
//  Description:
//
//     Retrieve the possible new domain name
//
//  Arguments:
//
//      pbDnsDomainNameWasChanged - set to TRUE is domain name changed
//      ppLocalDnsDomainName - set to new value of LocalDomainName
//                             the memory is malloced
//
//  Return Value:
//
//     0 on success, Error otherwise
// 
//
DWORD ScriptGetNewDomainName(THSTATE *pTHS, 
                             BOOL *pbDnsDomainNameWasChanged, 
                             LPWSTR *ppLocalDnsDomainName)
{
    WCHAR NameBuffer[DNS_MAX_NAME_LENGTH + 1];
    DWORD NameBufferSize = DNS_MAX_NAME_LENGTH + 1;
    DWORD dwErr = 0;

    *ppLocalDnsDomainName = NULL;
    *pbDnsDomainNameWasChanged = FALSE;

    dwErr = ReadCrossRefPropertySecure(gAnchor.pDomainDN, 
                                       ATT_DNS_ROOT,
                                       (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                       ppLocalDnsDomainName);

    if (dwErr) {
        DPRINT (0, "Error getting the DnsRoot of the CrossRef object\n");
        return dwErr;
    }

    // get the current DomainName

    if ( ! GetComputerNameExW(
                      ComputerNameDnsDomain,
                      NameBuffer,
                      &NameBufferSize )) {

        dwErr = GetLastError();
        DPRINT1(0,"Cannot get host name. error %x\n", dwErr);
        return dwErr;
    }


    if (!DnsNameCompare_W( NameBuffer, *ppLocalDnsDomainName)) {
        *pbDnsDomainNameWasChanged = TRUE;
        DPRINT1 (0, "Domain Name Changed. Need to set computer name to new value: %ws\n", *ppLocalDnsDomainName);
    
        ScriptLogPrint ( (DSLOG_TRACE, "Domain Name Changed. Need to set computer name to new value: %ws\n", *ppLocalDnsDomainName) );        
    }

    return 0;
}

//
//  SetNewDomainName
//
//  Description:
//
//     Set the new computer name in registry as required.
//
//  Arguments:
//
//      pLocalDnsDomainName - the new DNS name of the machine
//
//  Return Value:
//
//     0 on success, Error otherwise
// 
//
DWORD SetNewDomainName (LPWSTR pLocalDnsDomainName) 
{
    DWORD NetStatus = 0;

    //
    // Change the computer name as required. The new name will take effect next time
    // the computer reboots. An error here is not fatal.
    //

    if ( pLocalDnsDomainName != NULL ) {
        if ( NetStatus = NetpSetDnsComputerNameAsRequired( pLocalDnsDomainName ) ) {
            DPRINT1 (0, "Can't NetpSetDnsComputerNameAsRequired %d\n", NetStatus );

            ScriptLogPrint ( (DSLOG_ERROR, "Cannot Set New Domain Name: %ws\n", pLocalDnsDomainName) );        

            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DOMAIN_RENAME_CANNOT_SET_NEW_DOMAIN_NAME,
                     szInsertWC (pLocalDnsDomainName),
                     szInsertHex(NetStatus), szInsertHex (DSID(FILENO, __LINE__)) );

        } else {
            DPRINT1 (0, "Successfully set computer name with suffix %ws\n", pLocalDnsDomainName );
            ScriptLogPrint ( (DSLOG_TRACE, "Successfully set computer name with suffix %ws\n", pLocalDnsDomainName) );        
        }
    }

    return NetStatus;
}


//
//  ScriptHasDomainRenameExecuteScriptPassword
//
//  Description:
//
//     Checks to see if the user has the correct password to execute the script
//
//  Arguments:
//      cbPassword - Lenght of password
//      pbPassword - Pointer to password
//      pbHasAccess - result
//
//  Return Value:
//
//     0 on success
//     pbHasAccess set to TRUE if user has access, otheriwse FALSE
//
DWORD ScriptHasDomainRenameExecuteScriptPassword(THSTATE *pTHS, 
                                                 DWORD   cbPassword,
                                                 BYTE    *pbPassword,
                                                 BOOL    *pbHasAccess)
{
    DWORD       dwErr;
    ULONG       ulLen;
    BYTE        *pbStoredPassword;

    *pbHasAccess = FALSE;

    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:

        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                        0, 0, &ulLen, (PUCHAR *)&pbStoredPassword)) {
            
            DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptPassword: Error reading password: %d\n", dwErr);

            return dwErr;
        }
        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    if ((ulLen == cbPassword) &&
        memcmp (pbPassword, pbStoredPassword, cbPassword) == 0 ) {
        *pbHasAccess = TRUE;
    }

    return 0;
}

//
//  ScriptHasDomainRenameExecuteScriptRight
//
//  Description:
//
//     Checks to see if the user has the right to execute the script
//     This is the same as beeing able to write the script on the partitions 
//     container
//
//  Arguments:
//      pbHasAccess - result
//
//  Return Value:
//
//     0 on success
//     pbHasAccess set to TRUE if user has access, otheriwse FALSE
//
DWORD ScriptHasDomainRenameExecuteScriptRight(THSTATE *pTHS, BOOL *pbHasAccess)
{
    DWORD                dwErr;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    ULONG                ulLen;
    ATTCACHE            *rgAC[1], *pAC;
    CLASSCACHE          *pCC;

    *pbHasAccess = FALSE;

    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:

        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                        0, 0, &ulLen, (PUCHAR *)&pNTSD)) {
            
            DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptRight: Error reading SD: %d\n", dwErr);

            return dwErr;
        }
        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    pAC = SCGetAttById (pTHS, ATT_MS_DS_UPDATESCRIPT);
    pCC = SCGetClassById(pTHS, CLASS_CROSS_REF_CONTAINER);
    if (!pCC || !pAC) {
        return ERROR_DS_MISSING_EXPECTED_ATT;
    }

    rgAC[0] = pAC;
    
    *pbHasAccess = IsAccessGrantedAttribute (pTHS,
                                     pNTSD,
                                     gAnchor.pPartitionsDN,
                                     1,
                                     pCC,
                                     rgAC,
                                     RIGHT_DS_WRITE_PROPERTY,
                                     TRUE);

    DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptRight: Has Access %d\n", *pbHasAccess);

    return 0;
}


#define DOMAIN_RENAME_KEYSIZE 128

//  ScriptDomainRenameVerifyCallIsSecure
//
//  Description:
//
//  This routine verifies that is using >= 128bit encryption. 
//  Domain Rename Requires a secure connection when we prepare the script
//  for execution.
//
// The keysize is extracted from the security context of the caller. 
// If the extracted keysize is less than 128, an error is returned.
//
//  Return Value:
//
//  0 on suceess, 
//  ERROR_DS_STRONG_AUTH_REQUIRED on error
//  other Win32 error
//
DWORD ScriptDomainRenameVerifyCallIsSecure(THSTATE *pTHS)
{
    DWORD                   dwErr;
    DWORD                   i;
    ULONG                   KeySize;
    PCtxtHandle             pSecurityContext;
    SecPkgContext_KeyInfo   KeyInfo;


    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if ( dwErr = RpcImpersonateClient(NULL) ) {
        DPRINT1 (0, "RpcImpersonateClient: Error 0x%x\n", dwErr);

        if (RPC_S_CANNOT_SUPPORT == dwErr) {
            dwErr = ERROR_DS_STRONG_AUTH_REQUIRED;
        }

        return ScriptParseError(dwErr);
    }
    RpcRevertToSelf();

    // Get the security context from the RPC handle
    dwErr = I_RpcBindingInqSecurityContext(I_RpcGetCurrentCallHandle(),
                                           (void **)&pSecurityContext);
    if (dwErr) {
        DPRINT1 (0, "RpcBindingInqSecurityContext: Error 0x%x\n", dwErr);
        return ScriptParseError(dwErr);
    }

    // get the keysize
    dwErr = QueryContextAttributesW(pSecurityContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo);
    if (dwErr) {
        // treat "not supported" as "not secure"
        if (dwErr != SEC_E_UNSUPPORTED_FUNCTION) {
            DPRINT1 (0, "QueryContextAttributesW: Error 0x%x\n", dwErr);
            return ScriptParseError(dwErr);
        }
        KeySize = 0;
    } else {
        KeySize = KeyInfo.KeySize;
        FreeContextBuffer(KeyInfo.sSignatureAlgorithmName);
        FreeContextBuffer(KeyInfo.sEncryptAlgorithmName);
    }

    // is the key size large enough?
    if (KeySize < DOMAIN_RENAME_KEYSIZE) {
        DPRINT2(0, "Domain Rename: keysize is %d (minimum is %d)\n",
                KeySize, DOMAIN_RENAME_KEYSIZE);
        return ERROR_DS_STRONG_AUTH_REQUIRED;
    }

    DPRINT (0, "DomainRename Verified secure call \n");

    return ERROR_SUCCESS;
}


//
//  IDL_DSAPrepareScript
//
//  Description:
//
//     RPC Entry popint to prepare the script
//
//  Arguments:
//     dwInVersion - requested version of RPC call
//     pmsgIn - input message
//     pdwOutVersion - output version of RPC call
//     pmsgOut - out message
//
//  Return Value:
//
//     0 on success
//
//     ERROR_DS_INVALID_SCRIPT			 when the script does not have the right form (body + hashSig)
//                                       or when the signature is not right
//     ERROR_DS_NTDSCRIPT_PROCESS_ERROR	 failed to read from database, execute, set new domain name
//     ERROR_DS_AUTHORIZATION_FAILED	 when you are not authorized to modify the script on the 
//                                       partitions contaner (so we don't generate hash/passwd) 
//                                       or when you specified an invalid password         
//     ERROR_ACCESS_DENIED			     when there is an outstanding call in progress (10sec delay)
//     ERROR_INVALID_PARAMETER			 when a needed param is missing
//     ERROR_DS_INTERNAL_FAILURE		 if we failed for some internel reason (thread create fail, etc)
//
ULONG IDL_DSAPrepareScript( 
    IN  RPC_BINDING_HANDLE hRpc,
    IN  DWORD dwInVersion,
    IN  DSA_MSG_PREPARE_SCRIPT_REQ *pmsgIn,
    OUT DWORD *pdwOutVersion,
    OUT DSA_MSG_PREPARE_SCRIPT_REPLY *pmsgOut)
{
    THSTATE          *pTHS;
    DWORD             ret = 0, dwErr;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    BOOL              bHasAccess;
    BOOL              fExit = FALSE;
    
    WCHAR            *pScript = NULL;
    DWORD             cchScriptLen;

    BYTE             *pbHashBody = NULL, *pbHashSignature = NULL, *pbPassword = NULL;
    DWORD            cbHashBody = 0, cbHashSignature = 0, cbPassword = 0;
    BSTR             bstrScript = NULL;
    WCHAR           *pErrMessage = NULL;

    ScriptLogPrint ( (DSLOG_TRACE, "PrepareScript: Entering\n") );

    Sleep (INTRUDER_DELAY);
    
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WHISTLER) {
        
        ScriptLogPrint ( (DSLOG_ERROR, "Wrong Forest Version: %d. Required Version: %d\n", gAnchor.ForestBehaviorVersion, DS_BEHAVIOR_WHISTLER) );
        
        return ERROR_DS_NOT_SUPPORTED;
    }

    if (gulRunningExecuteScriptOperations) {
        return ERROR_ACCESS_DENIED;
    }
    else {
        EnterCriticalSection(&csDsaOpRpcIf);
        __try {
            if (gulRunningExecuteScriptOperations) {
                fExit++;
            }
            else {
                gulRunningExecuteScriptOperations++;
            }
        }
        __finally {
            LeaveCriticalSection(&csDsaOpRpcIf);
        }

        if (fExit) {
            return ERROR_ACCESS_DENIED;
        }
    }

    __try {
        // Sanity check arguments.

        if (    ( NULL == hRpc )
                || ( NULL == pmsgIn )
                || ( NULL == pmsgOut )
                || ( NULL == pdwOutVersion )
                || ( 1 != dwInVersion ) ) {

            ret = ERROR_INVALID_PARAMETER;
            __leave;
        }
        
        *pdwOutVersion = 1;
        memset(pmsgOut, 0, sizeof(*pmsgOut));
        pmsgOut->V1.dwOperationStatus = ERROR_DS_INTERNAL_FAILURE;

        __try {
            if ( !(pTHS = InitTHSTATE(CALLERTYPE_DRA)) ) {
                ret = ERROR_DS_INTERNAL_FAILURE;
                __leave;
            }

            Assert(pTHS);
            Assert(VALID_THSTATE(pTHS));

            dwErr = ScriptDomainRenameVerifyCallIsSecure(pTHS);
            if (dwErr) {
                ScriptLogPrint ( (DSLOG_ERROR, "Caller is not in a secure context: 0x%x.\n", dwErr) );
                __leave;
            }

            SYNC_TRANS_READ();   // Identify a reader transaction

            __try {

                // check for the right priviledges
                //
                if (dwErr = ScriptHasDomainRenameExecuteScriptRight(pTHS, &bHasAccess)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Cannot verify that caller has execute rights: 0x%x\n", dwErr) );
                    bHasAccess = FALSE;
                }
                else if (!bHasAccess) {
                    dwErr = ScriptParseError(ERROR_DS_AUTHORIZATION_FAILED);
                }

                if (!bHasAccess) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Caller does not have execute rights\n") );

                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ScriptParseErrorExt(ERROR_DS_AUTHORIZATION_FAILED, dwErr);

                    __leave;
                }

                if (dwErr = ScriptReadFromDatabase (pTHS, &pScript, &cchScriptLen)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Error reading script: 0x%x\n", dwErr) );

                    DPRINT1 (0, "Error 0x%x reading script\n", dwErr);

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_READ_SCRIPT_FAILED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ScriptParseErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }

                if (dwErr = ScriptCalculateAndCheckHashKeys (pTHS,
                                                             pScript,
                                                             cchScriptLen,
                                                             &pbHashSignature,
                                                             &cbHashSignature,
                                                             &pbHashBody,
                                                             &cbHashBody
                                                             )) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error calculating hash: 0x%x\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ScriptParseError(dwErr);

                    __leave;
                }

                if (dwErr = ScriptPrepareForParsing (pTHS, &pScript, &bstrScript)) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error preparing for parsing: 0x%x\n", dwErr) );
                    
                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    dwErr = ScriptParseErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }
                
                // we are the DSA
                pTHS->fDSA = TRUE;

                if (dwErr = ScriptExecute (pTHS, FALSE, bstrScript, &pErrMessage)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Error 0x%x prepropcessing script\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    dwErr = ScriptParseError(dwErr);
                    __leave;
                }

            } __finally {

                if (bstrScript) {
                    SysFreeString(bstrScript);   
                }

                CLEAN_BEFORE_RETURN( pTHS->errCode );
            }
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
            ret = dwErr = ScriptParseErrorExt(ulErrorCode, dsid);
        }

        if (dwErr) {
            __leave;
        }

        __try {

            SYNC_TRANS_WRITE();   // Identify a writer transaction

            __try {

                if (dwErr = ScriptGenerateAndStorePassword (pTHS, 
                                                            &pbPassword, 
                                                            &cbPassword)) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error generating password: 0x%x\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    dwErr = ScriptParseError(dwErr);

                    __leave;
                }

            } __finally {
                CLEAN_BEFORE_RETURN( pTHS->errCode );
            }

        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                          &dwEA, &ulErrorCode, &dsid)) {
                HandleDirExceptions(dwException, ulErrorCode, dsid);
                DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
                ret = dwErr = ScriptParseErrorExt(ulErrorCode, dsid);
        }

        if (!dwErr) {
            pmsgOut->V1.cbHashBody = cbHashBody;
            pmsgOut->V1.pbHashBody = pbHashBody;
            pmsgOut->V1.cbHashSignature = cbHashSignature;
            pmsgOut->V1.pbHashSignature = pbHashSignature;
            pmsgOut->V1.pbPassword = pbPassword;
            pmsgOut->V1.cbPassword = cbPassword;
            pmsgOut->V1.pwErrMessage = NULL;
            pErrMessage = NULL;
        }

    }
    __finally {
        Assert (gulRunningExecuteScriptOperations == 1);
        gulRunningExecuteScriptOperations = 0;
    }

    if (pmsgOut) {
        pmsgOut->V1.dwOperationStatus = dwErr;
        pmsgOut->V1.pwErrMessage = (WCHAR *)pErrMessage;
    }

    ScriptLogPrint ( (DSLOG_TRACE, "PrepareScript: Exiting: 0x%x\n", dwErr) );

    return ret;
}


//
//  IDL_DSAExecuteScript
//
//  Description:
//
//     RPC Entry popint to execute the script
//
//  Arguments:
//     dwInVersion - requested version of RPC call
//     pmsgIn - input message
//     pdwOutVersion - output version of RPC call
//     pmsgOut - out message
//
//  Return Value:
//
//     0 on success
//
//     ERROR_DS_INVALID_SCRIPT			 when the script does not have the right form (body + hashSig)
//                                       or when the signature is not right
//     ERROR_DS_NTDSCRIPT_PROCESS_ERROR	 failed to read from database, execute, set new domain name
//     ERROR_DS_AUTHORIZATION_FAILED     when you are not authorized to modify the script on the 
//                                       partitions contaner (so we don't generate hash/passwd) 
//                                       or when you specified an invalid password         
//     ERROR_ACCESS_DENIED			     when there is an outstanding call in progress (10sec delay)
//     ERROR_INVALID_PARAMETER			 when a needed param is missing
//     ERROR_DS_INTERNAL_FAILURE		 if we failed for some internel reason (thread create fail, etc)
//
ULONG IDL_DSAExecuteScript( 
    IN RPC_BINDING_HANDLE hRpc,
    IN DWORD dwInVersion,
    IN DSA_MSG_EXECUTE_SCRIPT_REQ *pmsgIn,
    OUT DWORD *pdwOutVersion,
    OUT DSA_MSG_EXECUTE_SCRIPT_REPLY *pmsgOut)
{
    THSTATE          *pTHS;
    DWORD             dwErr=0, ret=0;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    WCHAR            *pScript = NULL;
    DWORD             cchScript;
    BOOL              bIsDomainAdmin = FALSE;
    BOOL              bHasAccess;
    BOOL              fExit = FALSE;

    BYTE             *pbHashBody = NULL, *pbHashSignature = NULL;
    DWORD            cbHashBody = 0, cbHashSignature = 0;
    BSTR             bstrScript = NULL;
    WCHAR           *pErrMessage = NULL;

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScript: Entering\n") );

    Sleep (INTRUDER_DELAY);
    
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WHISTLER) {
        
        ScriptLogPrint ( (DSLOG_ERROR, "Wrong Forest Version: %d. Required Version: %d\n", gAnchor.ForestBehaviorVersion, DS_BEHAVIOR_WHISTLER) );
        
        return ERROR_DS_NOT_SUPPORTED;
    }
    
    if (gulRunningExecuteScriptOperations) {
        return ERROR_ACCESS_DENIED;
    }
    else {
        EnterCriticalSection(&csDsaOpRpcIf);
        __try {
            if (gulRunningExecuteScriptOperations) {
                fExit++;
            }
            else {
                gulRunningExecuteScriptOperations++;
            }
        }
        __finally {
            LeaveCriticalSection(&csDsaOpRpcIf);
        }

        if (fExit) {
            return ERROR_ACCESS_DENIED;
        }
    }

    __try {

        // Sanity check arguments.

        if (    ( NULL == hRpc )
                || ( NULL == pmsgIn )
                || ( NULL == pmsgOut )
                || ( NULL == pdwOutVersion )
                || ( 1 != dwInVersion ) ) {

            ret = ERROR_INVALID_PARAMETER;
            __leave;
        }
        *pdwOutVersion = 1;
        memset(pmsgOut, 0, sizeof(*pmsgOut));
        pmsgOut->V1.dwOperationStatus = ERROR_DS_INTERNAL_FAILURE;

        
        __try {
            if ( !(pTHS = InitTHSTATE(CALLERTYPE_DRA)) ) {
                ret = ERROR_DS_INTERNAL_FAILURE;
                __leave;
            }

            Assert(pTHS);
            Assert(VALID_THSTATE(pTHS));

            SYNC_TRANS_READ();  // identify a reader transaction

            __try {
                // check for the right priviledges
                //
                if (dwErr = ScriptHasDomainRenameExecuteScriptPassword(pTHS, 
                                                                 pmsgIn->V1.cbPassword,
                                                                 pmsgIn->V1.pbPassword, 
                                                                 &bHasAccess)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Cannot verify caller's password: 0x%x\n", dwErr) );

                    bHasAccess = FALSE;
                }
                else if (!bHasAccess) {
                    dwErr = ERROR_DS_AUTHORIZATION_FAILED;
                }

                if (!bHasAccess) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Caller does not have the right password\n") );

                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ERROR_DS_AUTHORIZATION_FAILED;

                    __leave;
                } 
            
                // read script
                if (dwErr = ScriptReadFromDatabase (pTHS, &pScript, &cchScript)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Error reading script: 0x%x\n", dwErr) );
                    
                    DPRINT1 (0, "Error 0x%x reading script\n", dwErr);
                    
                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_READ_SCRIPT_FAILED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ERROR_DS_NTDSCRIPT_PROCESS_ERROR;
                    __leave;
                }

                // calculate hash keys
                if (dwErr = ScriptCalculateAndCheckHashKeys (pTHS,
                                                             pScript,
                                                             cchScript,
                                                             &pbHashSignature,
                                                             &cbHashSignature,
                                                             &pbHashBody,
                                                             &cbHashBody
                                                             )) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error calculating hash: 0x%x\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertHex(dwErr), NULL, NULL );

                    dwErr = ScriptParseError(dwErr);

                    __leave;
                }

                if (dwErr = ScriptPrepareForParsing (pTHS, &pScript, &bstrScript)) {
                    
                    ScriptLogPrint ( (DSLOG_ERROR, "Error preparing for parsing: 0x%x\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    dwErr = ScriptParseErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }
                
                // we are the DSA
                pTHS->fDSA = TRUE;

                // execute the preprocessing part of the script
                if (dwErr = ScriptExecute (pTHS, FALSE, bstrScript, &pErrMessage)) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error 0x%x prepropcessing script\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    ScriptParseError (dwErr);
                    __leave;
                }


            } __finally {
                CLEAN_BEFORE_RETURN( pTHS->errCode || dwErr);
            }

            if (dwErr || pTHS->errCode ) {
                __leave;
            }


            SYNC_TRANS_WRITE();  // identify a writer transaction

            __try {

                // continue with execution of the script.


                // we are executing the script, so go into single user mode
                //
                if (!DsaSetSingleUserMode()) {
                    DPRINT (0, "Failed to go into single user mode\n");
                    dwErr = ERROR_DS_SINGLE_USER_MODE_FAILED;

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    _leave;
                }


                if (dwErr = ScriptExecute (pTHS, TRUE, bstrScript, &pErrMessage)) {
                    DPRINT1 (0, "Error 0x%x executing script\n", dwErr);

                    ScriptLogPrint ( (DSLOG_ERROR, "Error executing script: 0x%x\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertHex(dwErr), szInsertHex (DSID(FILENO, __LINE__)), NULL );

                    ScriptParseError(dwErr);
                    __leave;
                }

            } __finally {
                CLEAN_BEFORE_RETURN( dwErr || pTHS->errCode );
            }

            // get the error if we missed it
            if ((dwErr == 0) && (pTHS->errCode!=0)) {
                dwErr = pTHS->errCode;
            }
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
            ret = dwErr = ulErrorCode;
        }

        if (bstrScript) {
            SysFreeString(bstrScript);   
        }
        
        // log an event regarding the status of the script execution 
        //
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCRIPT_EXECUTE_STATUS,
                 szInsertHex(dwErr), NULL, NULL );

        // shutdown computer
        // if we executed the script and we had no error or we are in singleuser mode
        //
        if (dwErr==0 || DsaIsSingleUserMode()) {

            ScriptExecuteDSShutdown ();
        }

        if (!dwErr) {
            pErrMessage = NULL;
        }

    }
    __finally {
        Assert (gulRunningExecuteScriptOperations == 1);
        gulRunningExecuteScriptOperations = 0;
    }

    if (pmsgOut) {
        pmsgOut->V1.dwOperationStatus = dwErr;
        pmsgOut->V1.pwErrMessage = (WCHAR *)pErrMessage;
    }

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScript: Exiting: 0x%x\n", dwErr) );

    return ret;
}

//
//  GeneralScriptExecute
//
//  Description:
//
//     Execute the given XML script
//
//  Arguments:
//
//      Script - the script to execute. 
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD GeneralScriptExecute (THSTATE *pTHS, WCHAR * Script )
{
    HRESULT             hr = S_OK;
    DWORD               err = 0;
    DWORD               retCode;
    ISAXXMLReader *     pReader = NULL;
    NTDSContent*        pHandler = NULL; 
    IClassFactory *     pFactory = NULL;
    BSTR                pBstrScript = NULL;

    VARIANT             varScript;
    const WCHAR         *pErrMessage = NULL;

    pBstrScript = SysAllocString( Script );
    if (!pBstrScript) {
        pTHS->errCode = ERROR_OUTOFMEMORY;
        return pTHS->errCode;
    }

    try {

        // create a variant for the value passed to the Parser
        VariantInit(&varScript);
        varScript.vt = VT_BYREF|VT_BSTR;
        varScript.pbstrVal = &pBstrScript; 
        
        // do the COM creation of the SAMXMLReader manually
        GetClassFactory( CLSID_SAXXMLReader, &pFactory);

        hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

        if(!FAILED(hr)) 
        {
            pHandler = new NTDSContent();
            hr = pReader->putContentHandler(pHandler);

            SAXErrorHandlerImpl * pEc = new SAXErrorHandlerImpl();
            hr = pReader->putErrorHandler(pEc);

            hr = pReader->parse(varScript);
            ScriptLogPrint ( (DSLOG_TRACE,  "XML Parse result code: 0x%08x\n",hr) );

            if(FAILED(hr)) {
                err = ScriptParseError(hr);
            }
            else {
                err = pHandler->Process (SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS, retCode, &pErrMessage);

                ScriptLogPrint ( (DSLOG_TRACE,  "Syntax Validate Processing: 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\n", err, retCode, retCode, pErrMessage) );

                if (!err && !retCode) {
                     err = pHandler->Process (SCRIPT_PROCESS_EXECUTE_PASS, retCode, &pErrMessage);
                    ScriptLogPrint ( (DSLOG_TRACE,  "Execute Processing(RW): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\n", err, retCode, retCode, pErrMessage) );
                }

                // set error accordingly to fail transaction
                // err means that we had an error parsing / executing
                if (err) {
                    pTHS->errCode = err;
                }
                // retcode means that something was not as expected in the data
                // stored in the DS
                else if (retCode) {
                    err = pTHS->errCode = retCode;
                }
            }
        }
        else 
        {
            err = ScriptParseError(hr);
            ScriptLogPrint ( (DSLOG_ERROR,  "Error Parsing XML: 0x%08x\n",hr) );
        }
    }
    catch (...) {
        err = ScriptParseError(ERROR_EXCEPTION_IN_SERVICE);
    }


    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    SysFreeString(pBstrScript);
     
    return err;
}


#ifdef DBG

ULONG
ExecuteScriptLDAP (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE          *pTHS = pTHStls;
    DWORD             dwErr;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    WCHAR            *pwScript;

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScriptLDAP: Entering\n") );


    __try {
        Assert(pTHS);
        Assert(VALID_THSTATE(pTHS));

        SYNC_TRANS_WRITE();  // identify a writer transaction

        __try {

            ScriptLogPrint ( (DSLOG_TRACE, "Script: %s\n", pOpArg->pBuf) );

            pwScript = UnicodeStringFromString8 (CP_UTF8, pOpArg->pBuf, pOpArg->cbBuf);

            dwErr = GeneralScriptExecute (pTHS, pwScript);

        } __finally {
            CLEAN_BEFORE_RETURN( dwErr || pTHS->errCode );
        }

        // get the error if we missed it
        if ((dwErr == 0) && (pTHS->errCode!=0)) {
            dwErr = pTHS->errCode;
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
        dwErr = ulErrorCode;
    }

    pOpRes->ulExtendedRet = dwErr;

    return dwErr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\ntdsapi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       ntdsapi.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements entry points for the NTDSAPI wire functions.

Author:

    Dave Straube    (DaveStr)   10/22/97

Revision History:
    Dave Straube    (DaveStr)   10/22/97
        Created - mostly copied from (now) obsolete msdsserv.c.
    Will Lees       (wlees)     28-Jan-98
        Added WriteSpn support
    Colin Brace     (ColinBr)   02-Feb-98
        Added remove server/domain support
    Dave Straube    (DaveStr)   02-Jun-98
        Added DomainControllerInfo support

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <cracknam.h>                   // name cracking prototypes
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>
#include <attids.h>
#include <filtypes.h>
#include <ldapagnt.h>

#include <ntdsa.h>
#include <dsconfig.h>                   // FILEPATHKEY
#include <ntdsctr.h>

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dstrace.h>

// Assorted DSA headers.
#include <dsexcept.h>

#include <windns.h>

#include "drarpc.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include "lmaccess.h"                   // UF_* flags

#include <fileno.h>
#define  FILENO FILENO_NTDSAPI

// External
DWORD
SpnOperation(
    DWORD Operation,
    DWORD Flags,
    LPCWSTR Account,
    DWORD cSpn,
    LPCWSTR *pSpn
    );

DWORD
RemoveDsServerWorker(
    IN  LPWSTR  ServerDN,
    IN  LPWSTR  DomainDN OPTIONAL,
    OUT BOOL   *fLastDcInDomain OPTIONAL,
    IN  BOOL    fCommit
    );

DWORD
RemoveDsDomainWorker(
    IN  LPWSTR  DomainDN
    );

DWORD
DcInfoHelperLdapObj(
    THSTATE *pTHS,
    VOID    *pmsgOut
    );

DWORD
DsaExceptionToWin32(
    DWORD   xCode
    )
{
    switch ( xCode )
    {
    case DSA_EXCEPTION:             return(DS_ERR_INTERNAL_FAILURE);
    case DRA_GEN_EXCEPTION:         return(DS_ERR_DRA_INTERNAL_ERROR);
    case DSA_MEM_EXCEPTION:         return(ERROR_NOT_ENOUGH_MEMORY);
    case DSA_DB_EXCEPTION:          return(ERROR_DS_BUSY);
    case DSA_BAD_ARG_EXCEPTION:     return(ERROR_INVALID_PARAMETER);
    }

    return(ERROR_DS_BUSY);
}

ULONG
IDL_DRSCrackNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_CRACKREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_CRACKREPLY *    pmsgOut
    )

/*++

Routine Description:

    Cracks a bunch of names from one format to another.  See external
    prototype and definitions in ntdsapi.h

Arguments:

    hContext - RPC context handle for the IDL_DRSNtdsapi* interface.

    dwFlags - flags as defined in ntdsapi.h

    pStat - pointer to STAT block which tells us about customer's LOCALE.
        In-process clients can pass NULL.

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    // This routine is mostly called by ntdsapi.dll clients who typically
    // want something better than DRAERR_* return codes.  So we break with
    // tradition for IDL_DRS* implementations and return WIN32 error codes.

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/
{
    THSTATE    *pTHS = NULL;
    ULONG       err = RPC_S_OK;
    DWORD       cBytes;
    DWORD       i;
    CrackedName *rCrackedNames = NULL;
    GUID        guidNtdsapi = NtdsapiClientGuid;
    SID         ServerLogonSid = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVER_LOGON_RID };
    HANDLE      ClientToken;
    DWORD       xCode;
    DWORD       cNamesOut = 0;
    DWORD       cNamesCracked = 0;
    DWORD       cNamesNotCracked = 0;
    DWORD       dwLastStatus = 0;
    DWORD       dwFlags;
    BOOL        fDbOpen = FALSE;
    BOOL        fNtdsapiClient = FALSE;

    drsReferenceContext( hDrs, IDL_DRSCRACKNAMES );
    __try {
	__try
	    {
	    *pdwOutVersion = 1;
	    memset(pmsgOut, 0, sizeof(DRS_MSG_CRACKREPLY));


	    // Sanity check arguments.

	    if (    ( NULL == hDrs )
		    || ( NULL == pmsgIn )
		    || ( NULL == pmsgOut )
		    || ( 1 != dwInVersion )
		    || ( NULL == pdwOutVersion )
		    || ( 0 == pmsgIn->V1.cNames )
		    || ( NULL == pmsgIn->V1.rpNames )
		    || ( NULL != pmsgOut->V1.pResult ) )
		{
		return(ERROR_INVALID_PARAMETER);
	    }        

	    if ( !memcmp(   &(((DRS_CLIENT_CONTEXT *) hDrs)->uuidDsa),
			    &guidNtdsapi,
			    sizeof(GUID)) )
		{
		fNtdsapiClient = TRUE;
	    }

	    for ( i = 0; i < pmsgIn->V1.cNames; i++ )
		{
		if ( (NULL == pmsgIn->V1.rpNames[i]) ||
		     (0 == *pmsgIn->V1.rpNames[i]) )
		    {
		    return(ERROR_INVALID_PARAMETER);
		}

		if ( fNtdsapiClient  )
		    {
		    INC(pcDsClientNameTranslate);
		}
		else
		    {
		    INC(pcDsServerNameTranslate);
		}
	    }

	    // This DC is not a GC and the caller specifically requested a GC.
	    // Probably a call out of CrackSingleName on another DC.
	    if (   (pmsgIn->V1.dwFlags & DS_NAME_FLAG_GCVERIFY)
		   && !gAnchor.fAmVirtualGC) {
		return(ERROR_DS_GCVERIFY_ERROR);
	    }

	    // Initialize thread state and open data base.

	    if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) )
		{
		return(ERROR_DS_INTERNAL_FAILURE);
	    }

	    Assert(1 == dwInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_INTERNAL,
			     DIRLOG_IDL_DRS_CRACK_NAMES_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsCrackNames,
			     szInsertUL(pmsgIn->V1.cNames),
			     szInsertUL(pmsgIn->V1.CodePage),
			     szInsertUL(pmsgIn->V1.LocaleId),
			     szInsertUL(pmsgIn->V1.formatOffered),
			     szInsertUL(pmsgIn->V1.formatDesired),
			     szInsertUL(pmsgIn->V1.dwFlags),
			     NULL, NULL);

	    DBOpen2(TRUE, &pTHS->pDB);
	    fDbOpen = TRUE;

	    //
	    // check to see if the caller is a DC. If so, set fDSA
	    //

	    // this impersonate call is safe not to clear the possible clientToken
	    // on the THREAD state
	    if (RpcImpersonateClient( NULL ) == ERROR_SUCCESS)
		{
		BOOL Result = FALSE;
		if (CheckTokenMembership(
		    NULL,                       // already impersonating
		    &ServerLogonSid,
		    &Result
		    ))
		    {
		    if (Result)
			{
			pTHS->fDSA = TRUE;
		    }
		}
		RpcRevertToSelf();
	    }
	    __try
		{
		// Do the real work by calling core.  ntdsapi.dll clients
		// always get FPO resolution so UI components look nice.
		// All other clients need to ask for it explicitly.

		dwFlags = pmsgIn->V1.dwFlags;

		if ( fNtdsapiClient )
		    {
		    dwFlags |= DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS;
		}

		CrackNames(
		    dwFlags,
		    pmsgIn->V1.CodePage,
		    pmsgIn->V1.LocaleId,
		    pmsgIn->V1.formatOffered,
		    pmsgIn->V1.formatDesired,
		    pmsgIn->V1.cNames,
		    pmsgIn->V1.rpNames,
		    &cNamesOut,
		    &rCrackedNames);

		// Close DB thereby ending any transactions in case we
		// process FPOs which can cause calls to go off machine.
		// Set flag so that _finally doesn't do it.

		DBClose(pTHS->pDB, TRUE);
		fDbOpen = FALSE;

		if (    (dwFlags & DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS)
			&& rCrackedNames )
		    {
		    ProcessFPOsExTransaction(pmsgIn->V1.formatDesired,
					     cNamesOut,
					     rCrackedNames);
		}

		pmsgOut->V1.pResult =
		    (DS_NAME_RESULTW *) THAllocEx(pTHS, sizeof(DS_NAME_RESULTW));

		if ( (cNamesOut > 0) && rCrackedNames )
		    {
		    // Server side MIDL_user_allocate is same as THAlloc which
		    // also zeros memory by default.

		    cBytes = cNamesOut * sizeof(DS_NAME_RESULT_ITEMW);
		    pmsgOut->V1.pResult->rItems =
			(DS_NAME_RESULT_ITEMW *) THAllocEx(pTHS, cBytes);

		    for ( i = 0; i < cNamesOut; i++ )
			{
			// Remember the last status and the number of names
			// successfully cracked for logging below. The last
			// status is useful if only one name was cracked;
			// which is 99% of the time.
			if (!(  dwLastStatus
				= pmsgOut->V1.pResult->rItems[i].status
				= rCrackedNames[i].status)) {
			    ++cNamesCracked;
			} else {
			    ++cNamesNotCracked;
			}
			pmsgOut->V1.pResult->rItems[i].pDomain =
			    rCrackedNames[i].pDnsDomain;
			pmsgOut->V1.pResult->rItems[i].pName =
			    rCrackedNames[i].pFormattedName;
		    }

		    THFree(rCrackedNames);
		    pmsgOut->V1.pResult->cItems = cNamesOut;

		}
	    }
	    __finally
		{
		// End the transaction.  Faster to commit a read only
		// transaction than abort it - so set commit to TRUE.

		if ( fDbOpen )
		    {
		    DBClose(pTHS->pDB, TRUE);
		}
	    }
	}
	__except(HandleMostExceptions(xCode = GetExceptionCode()))
	{
	    err = DsaExceptionToWin32(xCode);
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_INTERNAL,
			     DIRLOG_IDL_DRS_CRACK_NAMES_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsCrackNames,
			     szInsertUL(err),
			     szInsertUL(cNamesOut),
			     szInsertUL(cNamesCracked),
			     szInsertUL(cNamesNotCracked),
			     szInsertUL(dwLastStatus),
			     NULL, NULL, NULL);
	}
    }
    __finally {
	drsDereferenceContext( hDrs, IDL_DRSCRACKNAMES );
    }
    return(err);
}


ULONG
IDL_DRSWriteSPN(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_SPNREQ *        pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_SPNREPLY *      pmsgOut
    )

/*++

Routine Description:

    Description

Arguments:

    hDrs - Rpc handle
    dwInVersion - Version of input structure
    pmsgIn - Input arguments
    pdwOutVersion - Version of output structure
    pmsgOut - Output arguments

Return Value:

    // This routine is mostly called by ntdsapi.dll clients who typically
    // want something better than DRAERR_* return codes.  So we break with
    // tradition for IDL_DRS* implementations and return WIN32 error codes.

    ULONG - Win32 status of operation

--*/

{
    DWORD   status = RPC_S_OK;
    GUID    guidNtdsapi = NtdsapiClientGuid;
    DWORD   xCode;
    THSTATE *pTHS = NULL;

    drsReferenceContext(hDrs, IDL_DRSWRITESPN);
    __try {
	__try
	    {
	    *pdwOutVersion = 1;  // you will get RPC_INVALID_TAG if this not set on return

	    // Sanity check arguments.


	    if (    ( NULL == hDrs )
		    || ( NULL == pmsgIn )
		    || ( NULL == pmsgOut )
		    || ( 1 != dwInVersion )
		    || ( NULL == pdwOutVersion )
		    || ( NULL == pmsgIn->V1.pwszAccount )
		    || ( 0 != memcmp(
			&(((DRS_CLIENT_CONTEXT *) hDrs)->uuidDsa),
			&guidNtdsapi,
			sizeof(GUID)) ) )
		{
		return(ERROR_INVALID_PARAMETER);
	    } 

	    // Initialize thread state

	    if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) )
		{
		return(ERROR_DS_INTERNAL_FAILURE);
	    }

	    Assert(1 == dwInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_WRITE_SPN_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsWriteSPN,
			     pmsgIn->V1.pwszAccount
			     ? szInsertWC(pmsgIn->V1.pwszAccount)
			     : szInsertSz(""),
		szInsertUL(pmsgIn->V1.operation),
		szInsertUL(pmsgIn->V1.cSPN),
		szInsertUL(pmsgIn->V1.flags),
		NULL, NULL, NULL, NULL);

	    // Do the real work here

	    // This routine lives in dramain\src\spnop.c
	    status = SpnOperation(
		pmsgIn->V1.operation,
		pmsgIn->V1.flags,
		pmsgIn->V1.pwszAccount,
		pmsgIn->V1.cSPN,
		pmsgIn->V1.rpwszSPN );
	}
	__except(HandleMostExceptions(xCode = GetExceptionCode()))
	{
	    status = DsaExceptionToWin32(xCode);
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_WRITE_SPN_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsWriteSPN,
			     szInsertUL(status),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}

	// This will always be executed
	pmsgOut->V1.retVal = status;
    }
    __finally {
	drsDereferenceContext( hDrs, IDL_DRSWRITESPN );
    }
    return status;
} /* IDL_DRSWriteSPN */


ULONG
IDL_DRSRemoveDsServer(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_RMSVRREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_RMSVRREPLY *    pmsgOut
    )
/*++

Routine Description:

    This routine is the server side portion of DsRemoveDsServer.

Arguments:

    hDrs - Rpc handle

    dwInVersion - Version of input structure

    pmsgIn - Input arguments

    pdwOutVersion - Version of output structure

    pmsgOut - Output arguments

Return Values:

    A value from the win32 error space.

--*/
{
    ULONG     WinError;
    LPWSTR    ServerDN;
    LPWSTR    DomainDN;
    BOOL      fCommit;
    BOOL      fLastDcInDomain = FALSE;

    drsReferenceContext(hDrs, IDL_DRSREMOVEDSSERVER);
    __try {
	//
	// Parameter analysis
	//
	if (   ( INVALID_HANDLE_VALUE == hDrs )
	       || ( 1    != dwInVersion )
	       || ( NULL == pmsgIn )
	       || ( NULL == pmsgOut )
	       || ( NULL == pdwOutVersion )
	       || ( NULL == pmsgIn->V1.ServerDN ) )
	    {
	    return ERROR_INVALID_PARAMETER;
	}

	//
	// Dissect the in params
	//
	ServerDN = pmsgIn->V1.ServerDN;
	DomainDN = pmsgIn->V1.DomainDN;
	fCommit  = pmsgIn->V1.fCommit;

	//
	// Do the work
	//
	WinError = RemoveDsServerWorker( ServerDN,
					 DomainDN,
					 &fLastDcInDomain,
					 fCommit );


	//
	// Set the out parameters
	//
	RtlZeroMemory( pmsgOut, sizeof( DRS_MSG_RMSVRREPLY ) );
	*pdwOutVersion = 1;
	if ( ERROR_SUCCESS == WinError )
	    {
	    pmsgOut->V1.fLastDcInDomain = fLastDcInDomain;
	}
    }
    __finally {
        drsDereferenceContext( hDrs, IDL_DRSREMOVEDSSERVER );
    }
    return( WinError );
}


DWORD
IDL_DRSRemoveDsDomain(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_RMDMNREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_RMDMNREPLY *    pmsgOut
    )
/*++

Routine Description:

Arguments:

Return Values:

    An appropriate drs error.

--*/
{

    NTSTATUS   NtStatus;
    DWORD      DirError, WinError;

    LPWSTR     DomainDN;
    DSNAME    *Domain, *CrossRef, *HostedDomain;

    drsReferenceContext(hDrs, IDL_DRSREMOVEDSDOMAIN);
    __try {
	//
	// Parameter analysis
	//
	if (   ( INVALID_HANDLE_VALUE == hDrs )
	       || ( 1    != dwInVersion )
	       || ( NULL == pmsgIn )
	       || ( NULL == pmsgIn->V1.DomainDN )
	       || ( NULL == pmsgOut )
	       || ( NULL == pdwOutVersion ) )
	    {
	    return ERROR_INVALID_PARAMETER;
	}

	//
	// Prep the (unreferenced) out parameter
	//
	*pdwOutVersion = 1;
	pmsgOut->V1.Reserved = 0;

	DomainDN = pmsgIn->V1.DomainDN;

	WinError = RemoveDsDomainWorker( DomainDN );
    }
    __finally {
	drsDereferenceContext( hDrs, IDL_DRSREMOVEDSDOMAIN );
    }
    return ( WinError );
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// IDL_DRSDomainControllerInfo implementation                       //
//                                                                  //
//////////////////////////////////////////////////////////////////////

// Forward reference ...

DWORD
DcInfoHelperV1orV2(
    THSTATE *pTHS,
    DSNAME  *pDomainDN,
    DWORD   InfoLevel,
    VOID    *pReply);

// The real thing ...

DWORD
IDL_DRSDomainControllerInfo(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_DCINFOREQ *     pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_DCINFOREPLY *   pmsgOut
    )
/*++

  Routine Description:

    Server side implementation for sdk\inc\ntdsapi.h - DsDomainControllerInfo.

  Parameters:

    hDrs - DRS interface binding handle.

    dwInVersion - Identifies in version - should be 1 forever more.  See
        comments on DRS_MSF_DCINFOREQ in ds\src\_idl\drs.idl.

    pmsgIn - Pointer to DRS_MSG_DCINFOREQ request.

    pdwOutVersion - Receives output version number which should be same as
        requested pmsgIn->V1.InfoLevel.  Se drs.idl comments for details.

    pmsgOut - Receives output DRS_MSG_DCINFOREPLY info.

  Return Values:

--*/
{
    DWORD       err = RPC_S_OK;
    DWORD       xCode;
    THSTATE     *pTHS = NULL;
    COMMARG     commArg;
    COMMRES     commRes;
    DSNAME      *pDN;
    DWORD       cBytes;
    DWORD       cNamesOut;
    CrackedName *pCrackedName;
    DWORD       pass;
    WCHAR       *pTmp = NULL;
    BOOL        foundSomething = FALSE;
    DWORD       infoLevel = 0;
    CROSS_REF_LIST *pCRL;

    drsReferenceContext(hDrs, IDL_DRSDOMAINCONTROLLERINFO);
    __try {
	__try
	    { 
	    // Sanity check arguments.	

	    infoLevel = pmsgIn->V1.InfoLevel;
	    if (    ( NULL == hDrs )
		    || ( NULL == pmsgIn )
		    || ( NULL == pmsgOut )
		    || ( 1 != dwInVersion )
		    // Make sure we have a valid domain name.
		    || ( NULL == pmsgIn->V1.Domain )
		    // Only know how to handle levels 1,2, & 0xffffffff for now - so test here.
		    || ( (1 != infoLevel) &&
			 (2 != infoLevel) &&
			 (0xFFFFFFFF != infoLevel) )
		    || ( NULL == pdwOutVersion ) )
		{
		return(ERROR_INVALID_PARAMETER);
	    }

	    // Initialize out parameters to safe value in case of early return.
	    *pdwOutVersion = infoLevel;
	    memset(pmsgOut, 0, sizeof(DRS_MSG_DCINFOREPLY));

	    // Initialize thread state and open data base.

	    if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) )
		{
		return(ERROR_DS_INTERNAL_FAILURE);
	    }

	    //
	    // InfoLevel 0xFFFFFFFF is used to get ldap connection info.
	    // Bypass the rest of this stuff
	    //

	    if ( infoLevel == 0xFFFFFFFF ) {
		err = DcInfoHelperLdapObj(pTHS,pmsgOut);
		return err;
	    }

	    Assert(1 == dwInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_DC_INFO_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsDCInfo,
			     pmsgIn->V1.Domain
			     ? szInsertWC(pmsgIn->V1.Domain)
			     : szInsertSz(""),
		szInsertUL(infoLevel),
		NULL, NULL, NULL, NULL, NULL, NULL);

	    DBOpen2(TRUE, &pTHS->pDB);

	    __try
		{
		// Be kind and quickly locate a netbios or dns domain name

		for (pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR)
		    {
		    if (     (pCRL->CR.DnsName
			      && DnsNameCompare_W(pCRL->CR.DnsName, pmsgIn->V1.Domain))
			     ||
			     (pCRL->CR.NetbiosName
			      && !_wcsicmp(pCRL->CR.NetbiosName, pmsgIn->V1.Domain)) )
			{
			if (NameMatched(pCRL->CR.pNC, gAnchor.pDomainDN))
			    {
			    pDN = pCRL->CR.pNC;
			    goto FOUNDIT;
			}
		    }
		}

		// Be kind and crack the name from various and sundry formats.

		for ( pass = 1; pass <= 3; pass++ )
		    {
		    cNamesOut = 0;
		    pCrackedName = NULL;

		    if ( 1 == pass )
			{
			// Crack the name as-is.
			pTmp = pmsgIn->V1.Domain;
		    }
		    else if ( 2 == pass )
			{
			// Assume it is DS_NT4_ACCOUNT_NAME w/o the trailing '\'.
			cBytes = (wcslen(pmsgIn->V1.Domain) + 2) * sizeof(WCHAR);
			pTmp = (WCHAR *) THAllocEx(pTHS, cBytes);
			wcscpy(pTmp, pmsgIn->V1.Domain);
			wcscat(pTmp, L"\\");
		    }
		    else if ( 3 == pass )
			{
			// Assume it is DS_CANONICAL_NAME w/o the trailing '/'.
			wcscpy(pTmp, pmsgIn->V1.Domain);
			wcscat(pTmp, L"/");
		    }

		    CrackNames(
			DS_NAME_NO_FLAGS,
			GetACP(),
			GetUserDefaultLCID(),
			DS_UNKNOWN_NAME,
			DS_FQDN_1779_NAME,
			1,
			&pTmp,
			&cNamesOut,
			&pCrackedName);

		    if (    (1 == cNamesOut)
			    && pCrackedName
			    && (DS_NAME_NO_ERROR == pCrackedName->status)
			    && (pCrackedName->pDSName) )
			{
			// Caller gave us a valid name
			foundSomething = TRUE;

			// Caller gave us a valid name and it's OUR domain name
			if (NameMatched(pCrackedName->pDSName, gAnchor.pDomainDN) )
			    {
			    pDN = pCrackedName->pDSName;
			    goto FOUNDIT;
			}
		    }
		}

		// Caller gave us a valid name but it's not OUR domain name or
		// caller gave us an invalid name
		return ((foundSomething) ? ERROR_INVALID_PARAMETER : ERROR_DS_OBJ_NOT_FOUND);

		FOUNDIT:
		    if ( DBFindDSName(pTHS->pDB, pDN) )
			{
			return(ERROR_DS_INTERNAL_FAILURE);
		    }

		    // Domain is good - go do the grunt work.  DcInfoHelper*
		    // should return a WIN32 error code.

		    switch ( infoLevel )
			{
		    case 1:
		    case 2:
			err = DcInfoHelperV1orV2(pTHS,
						 pDN,
						 infoLevel,
						 pmsgOut);
			break;

			// Add new cases here as new info levels are defined.

		    default:
			err = ERROR_DS_NOT_SUPPORTED;
			break;
		    }
	    }
	    __finally
		{
		DBClose(pTHS->pDB, TRUE);
	    }
	}
	__except(HandleMostExceptions(xCode = GetExceptionCode()))
	{
	    err = DsaExceptionToWin32(xCode);
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_DC_INFO_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsDCInfo,
			     szInsertUL(err),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}
    }
    __finally {
	drsDereferenceContext( hDrs, IDL_DRSDOMAINCONTROLLERINFO );
    }
    return(err);
}

VOID
GetV2SiteAndDsaInfo(
    THSTATE                         *pTHS,
    DSNAME                          *pSiteDN,
    DSNAME                          *pServerDN,
    DS_DOMAIN_CONTROLLER_INFO_2W    *pItemV2
    )
/*++

  Routine Description:

  Arguments:

    pSiteDN - DSNAME of site object (missing GUID field as it was derived
        via TrimDsNameBy().

    pServerDN - DSNAME of Server object.

    pItemV2 = Address of V@ info struct whose fields are filled on success.

  Return Values:

    None.  On error we just leave that field blank.  Clients are supposed to
    check for NULL names and GUIDs.
--*/
{
    CLASSCACHE      *pCC;
    DSNAME          *pCategoryDN;
    ULONG           len;
    SEARCHARG       searchArg;
    SEARCHRES       searchRes;
    FILTER          categoryFilter;
    ENTINFSEL       selection;
    COMMARG         commArg;
    DSNAME          *pFullSiteDN = NULL;
    ENTINFLIST      *pEntInfList, *pEntInfTmp;
    ATTR            selAtts[1];
    ATTR            *pOption;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(fNullUuid(&pSiteDN->Guid));
    Assert(pSiteDN->structLen && pSiteDN->NameLen);
    Assert(!fNullUuid(&pServerDN->Guid));
    Assert(pServerDN->structLen && pServerDN->NameLen);
    Assert(!pItemV2->NtdsDsaObjectName)
    Assert(fNullUuid(&pItemV2->SiteObjectGuid));
    Assert(fNullUuid(&pItemV2->NtdsDsaObjectGuid));
    Assert(!pItemV2->fIsGc);

    if (    !(pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA))
         || !(pCategoryDN = pCC->pDefaultObjCategory) )
    {
        return;
    }

    // Derive GUID of site object.

    if (    !DBFindDSName(pTHS->pDB, pSiteDN)
         && !DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0,
                         0, &len, (UCHAR **) &pFullSiteDN) )
    {
        pItemV2->SiteObjectName = pFullSiteDN->StringName;
        pItemV2->SiteObjectGuid = pFullSiteDN->Guid;
    }

    // Find the NTDS-DSA object and get its options.

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&categoryFilter, 0, sizeof (FILTER));
    searchArg.pObject = pServerDN;
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    categoryFilter.pNextFilter = NULL;
    categoryFilter.choice = FILTER_CHOICE_ITEM;
    categoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    pCategoryDN->structLen;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) pCategoryDN;
    searchArg.pFilter = &categoryFilter;
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 1;
    selection.AttrTypBlock.pAttr = selAtts;
    selection.AttrTypBlock.pAttr[0].attrTyp = ATT_OPTIONS;
    selection.AttrTypBlock.pAttr[0].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[0].AttrVal.pAVal = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);
    SearchBody(pTHS, &searchArg, &searchRes, 0);

    if ( pTHS->errCode )
    {
        THClearErrors();
        return;
    }

    if ( 1 == searchRes.count )
    {
        pItemV2->NtdsDsaObjectName =
                        searchRes.FirstEntInf.Entinf.pName->StringName;
        pItemV2->NtdsDsaObjectGuid =
                        searchRes.FirstEntInf.Entinf.pName->Guid;

        if ( searchRes.FirstEntInf.Entinf.AttrBlock.attrCount )
        {
            pOption = searchRes.FirstEntInf.Entinf.AttrBlock.pAttr;
        }
        else
        {
            pOption = NULL;
        }

        if (    pOption
             && (ATT_OPTIONS == pOption->attrTyp)
             && (1 == pOption->AttrVal.valCount)
             && pOption->AttrVal.pAVal
             && (sizeof(DWORD) == pOption->AttrVal.pAVal->valLen)
             && pOption->AttrVal.pAVal->pVal
             && (NTDSDSA_OPT_IS_GC & (* (PDWORD) pOption->AttrVal.pAVal->pVal)))
        {
            pItemV2->fIsGc = TRUE;
            THFreeEx(pTHS, pOption->AttrVal.pAVal->pVal);
            THFreeEx(pTHS, pOption->AttrVal.pAVal);
            THFreeEx(pTHS, pOption);
        }
    }
    else if ( searchRes.count >= 2 )
    {
        // Free components of search result we don't need.

        pEntInfList = searchRes.FirstEntInf.pNextEntInf;
        while ( pEntInfList )
        {
            pEntInfTmp = pEntInfList;
            pEntInfList = pEntInfList->pNextEntInf;
            THFreeEx(pTHS, pEntInfTmp->Entinf.pName);
            pOption = pEntInfTmp->Entinf.AttrBlock.pAttr;
            if ( pOption ) {
                if ( pOption->AttrVal.pAVal ) {
                    if ( pOption->AttrVal.pAVal->pVal ) {
                        THFreeEx(pTHS, pOption->AttrVal.pAVal->pVal);
                    }
                    THFreeEx(pTHS, pOption->AttrVal.pAVal);
                }
                THFreeEx(pTHS, pOption);
            }
            THFreeEx(pTHS, pEntInfTmp);
        }
    }
}

DWORD
DcInfoHelperV1orV2(
    THSTATE *pTHS,
    DSNAME  *pDomainDN,
    DWORD   InfoLevel,
    VOID    *pmsgOut
    )
/*++

  Routine Description:

    Helper function which does most of the grunt work for
    IDL_DRSDomainControllerInfo.  General algorithm is as follows:

            read fsmo name off of domain object
            search for all DCs via account type in the domain
            for each DC (aka computer object)
                derive netbios name from sam account name
                read dns host name from search result
                fDsEnabled == (server-bl is populated and real object)
                if ( fDsEnabled )
                    reverse engineer site name from ntds dsa name
                    if ( pdc fsmo == server bl )
                        set fIsPdc TRUE
                    else
                        set fIsPdc FALSE

  Parameters:

    pTHS - Valid THSTATE pointer.

    pDomainDN - DSNAME of domain we're to get DC info for and on which
        our DBPOS is positioned.

    InfoLevel - Identifies return info level 1 or 2.

    pmsgOut - Empty DRS_MSG_DCINFOREPLY struct to be filled on return.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD           i, j, DNT, cBytes, cChars;
    ULONG           len;
    ATTRTYP         attrTyp;
    DSNAME          *pPdcDsaDN;
    DSNAME          *pPdcServerDN;
    DSNAME          *pCategoryDN;
    CLASSCACHE      *pCC;
    ATTR            selAtts[3];
    ENTINFSEL       selection;
    FILTER          andFilter, categoryFilter, flagsFilter, groupFilter;
    DWORD           serverTrustFlags;
    SEARCHARG       searchArg;
    SEARCHRES       searchRes;
    ENTINFLIST      *pEntInfList;
    ATTR            *pSamName, *pDnsName, *pRefBL;
    DSNAME          *pSiteDN = NULL;
    WCHAR           computerName[MAX_COMPUTERNAME_LENGTH+1] = { 0 };
    DWORD           cComputerName;
    DWORD           primaryGroupId;
    DWORD           *pcItems = NULL;
    VOID            **prItems = NULL;
    BOOL            *pfIsPdc;
    BOOL            *pfDsEnabled;
    WCHAR           **ppNetbiosName;
    WCHAR           **ppDnsHostName;
    WCHAR           **ppSiteName;
    WCHAR           **ppServerObjectName;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pItemV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pItemV2;

    Assert((1 == InfoLevel) || (2 == InfoLevel));
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));

    // Verify we're positioned on the domain object.
    Assert(    (DNT = pTHS->pDB->DNT,
                !DBFindDSName(pTHS->pDB, pDomainDN))
            && (DNT == pTHS->pDB->DNT) );

    // See comments in drs.idl regarding how all versions of
    // DRS_MSG_DCINFOREPLY have the same layout.
    Assert(& ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.cItems ==
                            & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V2.cItems);
    Assert((PVOID) & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.rItems ==
                        (PVOID) & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V2.rItems);

    if ( (1 == InfoLevel) || (2 == InfoLevel) )
    {
        pcItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.cItems;
        prItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.rItems;
    }
    else
    {
        return(DIRERR_INTERNAL_FAILURE);
    }

    Assert(!*pcItems && !*prItems);

    // Read PDC FSMO role owner.

    if (    DBGetAttVal(pTHS->pDB, 1, ATT_FSMO_ROLE_OWNER,
                        0, 0, &len, (UCHAR **) &pPdcDsaDN)
         || !(pPdcServerDN = (DSNAME *) THAllocEx(pTHS, pPdcDsaDN->structLen))
         || TrimDSNameBy(pPdcDsaDN, 1, pPdcServerDN)
         || !(pCC = SCGetClassById(pTHS, CLASS_COMPUTER))
         || !(pCategoryDN = pCC->pDefaultObjCategory) )
    {
        return(DIRERR_INTERNAL_FAILURE);
    }

    // Search for all computer account objects which are DCs.

    // set up search arguments ...
    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));

    memset(&andFilter, 0, sizeof (andFilter));
    memset(&categoryFilter, 0, sizeof (categoryFilter));
    memset(&flagsFilter, 0, sizeof (flagsFilter));
    memset(&groupFilter, 0, sizeof (groupFilter));

    searchArg.pObject = pDomainDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = TRUE;
    // set up filter ...
    // This filter for correctness, not performance.
    serverTrustFlags = UF_SERVER_TRUST_ACCOUNT;
    flagsFilter.pNextFilter = NULL;
    flagsFilter.choice = FILTER_CHOICE_ITEM;
    flagsFilter.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    flagsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USER_ACCOUNT_CONTROL;
    flagsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    sizeof(serverTrustFlags);
    flagsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) &serverTrustFlags;
    // This filter for correctness, not performance.
    categoryFilter.pNextFilter = &flagsFilter;
    categoryFilter.choice = FILTER_CHOICE_ITEM;
    categoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    pCategoryDN->structLen;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) pCategoryDN;
    // This filter for performance.  SAM mandates that all domain controllers
    // have DOMAIN_GROUP_RID_CONTROLLERS as their primary group ID.  When the
    // first DC in a domain is upgraded, all downlevel DC computer objects
    // are patched.  Downlevel BDCs which are installed later are given the
    // right value too.
    primaryGroupId = DOMAIN_GROUP_RID_CONTROLLERS;
    groupFilter.pNextFilter = &categoryFilter;
    groupFilter.choice = FILTER_CHOICE_ITEM;
    groupFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    groupFilter.FilterTypes.Item.FilTypes.ava.type = ATT_PRIMARY_GROUP_ID;
    groupFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    sizeof(primaryGroupId);
    groupFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) &primaryGroupId;
    andFilter.pNextFilter = NULL;
    andFilter.choice = FILTER_CHOICE_AND;
    andFilter.FilterTypes.And.count = 3;
    andFilter.FilterTypes.And.pFirstFilter = &groupFilter;
    searchArg.pFilter = &andFilter;
    // set up selection ...
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 3;
    selection.AttrTypBlock.pAttr = selAtts;
    selection.AttrTypBlock.pAttr[0].attrTyp = ATT_SERVER_REFERENCE_BL;
    selection.AttrTypBlock.pAttr[0].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[0].AttrVal.pAVal = NULL;
    selection.AttrTypBlock.pAttr[1].attrTyp = ATT_DNS_HOST_NAME;
    selection.AttrTypBlock.pAttr[1].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[1].AttrVal.pAVal = NULL;
    selection.AttrTypBlock.pAttr[2].attrTyp = ATT_SAM_ACCOUNT_NAME;
    selection.AttrTypBlock.pAttr[2].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[2].AttrVal.pAVal = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection = &selection;
    // set up just a few more arguments ...
    InitCommarg(&searchArg.CommArg);

    SearchBody(pTHS, &searchArg, &searchRes, 0);

    if ( pTHS->errCode )
    {
        return(DirErrorToWinError(pTHS->errCode, &searchRes.CommRes));
    }

    if ( 0 == searchRes.count )
    {
        Assert(!*pcItems && !*prItems);
        return(ERROR_SUCCESS);
    }

    // Allocate memory for output.
    if ( 1 == InfoLevel )
    {
        i = searchRes.count * sizeof(DS_DOMAIN_CONTROLLER_INFO_1W);
        *prItems = THAllocEx(pTHS, i);
    }
    else
    {
        i = searchRes.count * sizeof(DS_DOMAIN_CONTROLLER_INFO_2W);
        *prItems = THAllocEx(pTHS, i);
    }

    // Iterate over the search result.

    for ( pEntInfList = &searchRes.FirstEntInf;
          pEntInfList;
          (*pcItems)++, pEntInfList = pEntInfList->pNextEntInf )
    {
        // Find attributes in the result.
        pSamName = pDnsName = pRefBL = NULL;
        for ( i = 0; i < pEntInfList->Entinf.AttrBlock.attrCount; i++ )
        {
            switch ( pEntInfList->Entinf.AttrBlock.pAttr[i].attrTyp )
            {
            case ATT_SERVER_REFERENCE_BL:
                pRefBL = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            case ATT_SAM_ACCOUNT_NAME :
                pSamName = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            case ATT_DNS_HOST_NAME:
                pDnsName = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            default:
                Assert(!"Core returned stuff we didn't ask for!"); break;
            }
        }

        // Now construct return data.

        j = *pcItems;
        if ( 1 == InfoLevel )
        {
            pItemV1 = & ((* ((DS_DOMAIN_CONTROLLER_INFO_1W **) prItems))[j]);
            pfIsPdc             = &pItemV1->fIsPdc;
            pfDsEnabled         = &pItemV1->fDsEnabled;
            ppNetbiosName       = &pItemV1->NetbiosName;
            ppDnsHostName       = &pItemV1->DnsHostName;
            ppSiteName          = &pItemV1->SiteName;
            ppServerObjectName  = &pItemV1->ServerObjectName;
            pItemV1->ComputerObjectName = pEntInfList->Entinf.pName->StringName;
        }
        else
        {
            pItemV2 = & ((* ((DS_DOMAIN_CONTROLLER_INFO_2W **) prItems))[j]);
            pfIsPdc             = &pItemV2->fIsPdc;
            pfDsEnabled         = &pItemV2->fDsEnabled;
            ppNetbiosName       = &pItemV2->NetbiosName;
            ppDnsHostName       = &pItemV2->DnsHostName;
            ppSiteName          = &pItemV2->SiteName;
            ppServerObjectName  = &pItemV2->ServerObjectName;
            pItemV2->ComputerObjectName = pEntInfList->Entinf.pName->StringName;
            pItemV2->ComputerObjectGuid = pEntInfList->Entinf.pName->Guid;
            pItemV2->fIsGc = FALSE;
        }

        *pfIsPdc = FALSE;
        *pfDsEnabled = FALSE;

        if (    pSamName
             && pSamName->AttrVal.valCount
             && pSamName->AttrVal.pAVal
                // expect at least one char followed by '$'
             && (pSamName->AttrVal.pAVal[0].valLen >= (2 * sizeof(WCHAR)))
             && pSamName->AttrVal.pAVal[0].pVal )
        {
            // The netbios name is the sam account name w/o the trailing $;
            // or just the sam account name if there is no trailing $. The
            // trailing $ may be missing because the object was built by
            // hand instead of being built with the SAM APIs.

            // Need to realloc to add L'\0';
            cBytes = pSamName->AttrVal.pAVal[0].valLen;
            *ppNetbiosName = (WCHAR *) THAllocEx(pTHS, cBytes + sizeof(WCHAR));
            memcpy(*ppNetbiosName,
                   pSamName->AttrVal.pAVal[0].pVal,
                   cBytes);
            cChars = (cBytes / sizeof(WCHAR)) - 1;
            if ((*ppNetbiosName)[cChars] == L'$') {
                (*ppNetbiosName)[cChars] = L'\0';
            }
        }

        if (    pDnsName
             && pDnsName->AttrVal.valCount
             && pDnsName->AttrVal.pAVal
             && pDnsName->AttrVal.pAVal[0].valLen
             && pDnsName->AttrVal.pAVal[0].pVal )
        {
            // Need to realloc to add L'\0';
            cBytes = pDnsName->AttrVal.pAVal[0].valLen;
            *ppDnsHostName = (WCHAR *) THAllocEx(pTHS, cBytes + sizeof(WCHAR));
            memcpy(*ppDnsHostName,
                   pDnsName->AttrVal.pAVal[0].pVal,
                   cBytes);
        }
        else
        {
            // No valid DNS_HOST_NAME property on the object.  This can
            // happen if the admin mistakenly overwrote it, or just after
            // install/boot when the WriteServerInfo daemon hasn't run
            // yet.  If the DS object represents ourself, then use our
            // own DNS host name from gAnchor.

            if ( (gAnchor.pwszHostDnsName != NULL)
                 && *ppNetbiosName
                 && (    (L'\0' != computerName[0])
                      || (cComputerName = MAX_COMPUTERNAME_LENGTH+1,
                          GetComputerNameW(computerName, &cComputerName)) )
                 && !_wcsicmp(*ppNetbiosName, computerName) )
            {
                cBytes = sizeof(WCHAR) * (wcslen(gAnchor.pwszHostDnsName) + 1);
                *ppDnsHostName = (WCHAR *) THAllocEx(pTHS, cBytes);
                wcscpy(*ppDnsHostName, gAnchor.pwszHostDnsName);
            }
        }

        // We know that the DS daemon keeps ATT_SERVER_REFERENCE correct for
        // Server objects, therefore ATT_SERVER_REFERENCE_BL is correct as
        // well.  Ignore windows where an admin may have temporarily written
        // a bad value.  Thus site name is derived by snipping two components
        // off ATT_SERVER_REFERENCE_BL and grabbing the RDN.

        if (    pRefBL
             && pRefBL->AttrVal.valCount
             && pRefBL->AttrVal.pAVal
             && pRefBL->AttrVal.pAVal[0].valLen
             && pRefBL->AttrVal.pAVal[0].pVal
                // While we're here, fill in the ServerObjectName field
                // and note the use of the comma operator ...
             && (*ppServerObjectName =
                        ((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal)->StringName,
                 (pSiteDN = (DSNAME *)
                            THAllocEx(pTHS, pRefBL->AttrVal.pAVal[0].valLen)))
             && !TrimDSNameBy((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal,
                              2, pSiteDN)
             && (*ppSiteName =
                    (WCHAR *) THAllocEx(pTHS, MAX_RDN_SIZE * sizeof(WCHAR)))
             && !GetRDNInfo(pTHS, pSiteDN, *ppSiteName, &len, &attrTyp) )
        {
            (*ppSiteName)[len] = L'\0';
            *pfDsEnabled = TRUE;

            if ( 2 == InfoLevel )
            {
                pItemV2->ServerObjectGuid =
                            ((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal)->Guid;
                GetV2SiteAndDsaInfo(pTHS, pSiteDN,
                                    (DSNAME *) pRefBL->AttrVal.pAVal[0].pVal,
                                    pItemV2);
            }

            THFree(pSiteDN);
            pSiteDN = NULL;

            if ( NameMatched(pPdcServerDN,
                             (DSNAME *) pRefBL->AttrVal.pAVal[0].pVal) )
            {
                *pfIsPdc = TRUE;
            }
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
DcInfoHelperLdapObj(
    THSTATE *pTHS,
    VOID    *pmsgOut
    )
/*++

  Routine Description:

    Helper function which handles ldap related requests.

    currently we only support infor level FFFFFFFF which queries for
    active ldap connections.

  Parameters:

    pTHS - Valid THSTATE pointer.

    pmsgOut - Empty DRS_MSG_DCINFOREPLY struct to be filled on return.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD   *pcItems = NULL;
    PVOID   *prItems = NULL;
    DWORD   xCode;
    DWORD   err = ERROR_SUCCESS;
    DWORD   DumpAccessCheck(IN LPCSTR pszCaller);

    Assert(VALID_THSTATE(pTHS));

    __try {

        // Check permissions
        err = DumpAccessCheck("ldapConnDump");
        if ( err != ERROR_SUCCESS ) {
            __leave;
        }

        pcItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->VFFFFFFFF.cItems;
        prItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->VFFFFFFFF.rItems;

        Assert(!*pcItems && !*prItems);

        //
        // See how many entries there are by passing a null buffer
        //

        err = LdapEnumConnections(pTHS,pcItems,prItems);

    } __except(HandleMostExceptions(xCode = GetExceptionCode())) {

        err = DsaExceptionToWin32(xCode);
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\drsserv\drsuapi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drsuapi.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Wrappers for DRS interface RPC client functions.  Historically the DRS
    interface was used only for installation and replication, though for NT
    its responsibilities have grown to cover other DS-to-DS and arbitrary
    client-to-DS communication.

DETAILS:

CREATED:

REVISION HISTORY:

    Greg Johnson (gregjohn) 2/28/01
	RPC cancel functions added.  In order to use the RPC cancel call
	functions each thread wishing to set a specific time to cancel must
	have it's own copy of the context handle.  This is simply a copy of
	the handle however, so only when all copies are no longer in use
	may the handle be freed.
	
	To reduce contention and network serialization instead of freeing a 
	handle when it is no longer used, it is placed on a queue.  Later, 
	a dedicated thread frees the handles on the queue.

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include "dsevent.h"
#include "mdcodes.h"
#include "dsexcept.h"
#include "drserr.h"
#include <heurist.h>
#include "bhcache.h"
#include "mdglobal.h"   // for eServiceShutdown
#include "anchor.h"     // for gAnchor
#include "scache.h"     // reqd. for mdlocal.h
#include "dbglobal.h"   // reqd. for mdlocal.h
#include "mdlocal.h"    // for DsaIsInstalling()
#include <drautil.h>
#include <dramail.h>
#include <dsatools.h>
#include "objids.h"     // Defines for selected classes and atts
#include <dsconfig.h>   // GetConfigParam
#include <mdcodes.h>    // Event codes
#include <winsock2.h>   // inet_addr
#include <pek.h>
#include <dsutil.h>     // MAP_SECURITY_PACKAGE_ERROR
#include <ntdsctr.h>    // perf counters
#include <dstaskq.h>
#include <dnsresl.h>    // for GetIpAddrByDnsNameW

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRSUAPI:" /* define the subsystem for debugging */

#include "drsuapi.h"
extern RPC_IF_HANDLE _drsuapi_ClientIfHandle;

#include <fileno.h>
#define  FILENO FILENO_DRSUAPI

#define GCSpnType       L"GC"

// Does the SPN specify the domain name that the target account is in (by
// appending @domain.com)?
#define IS_DOMAIN_QUALIFIED_SPN(pszSpn) (NULL != wcschr((pszSpn), L'@'))

// ISSUE 20001-01-17 JeffParh - Remove once winerror.mc contains new error code.
#ifndef ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF
#   define ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF ERROR_DS_GENERIC_ERROR
#endif

void
DRSExpireContextHandles(
    IN  VOID *  pvArg,
    OUT VOID ** ppvNextArg,
    OUT DWORD * pcSecsUntilNextRun
    );

// Time limit (in minutes) of various RPC operations.
ULONG gulDrsRpcBindTimeoutInMins;
ULONG gulDrsRpcReplicationTimeoutInMins;
ULONG gulDrsRpcGcLookupTimeoutInMins;
ULONG gulDrsRpcMoveObjectTimeoutInMins;
ULONG gulDrsRpcNT4ChangeLogTimeoutInMins;
ULONG gulDrsRpcObjectExistenceTimeoutInMins;
ULONG gulDrsRpcGetReplInfoTimeoutInMins;

// How long do we keep DRS context handles in the cache?  (in sec)
ULONG gulDrsCtxHandleLifetimeIntrasite;
ULONG gulDrsCtxHandleLifetimeIntersite;

// How often do we check to see if context handles have expired? (in sec)
ULONG gulDrsCtxHandleExpiryCheckInterval;


// FBindSzDRS flags

#define FBINDSZDRS_NO_CACHED_HANDLES (1)
#define FBINDSZDRS_LOCK_HANDLE       (2)
#define FBINDSZDRS_CRYPTO_BIND       (4)

// Tracks DRS context handle state.  Returned by FBindSzDRS() and freed by
// DRSFreeContextInfo().

typedef struct _DRS_CONTEXT_INFO {
    LPWSTR     pszServerName;          // Net name of the server.
    DRS_HANDLE hDrs;                   // The DRS context handle.
    unsigned   fIsHandleFromCache : 1; // Did we reuse an already cached handle?
    unsigned   fIsHandleInCache   : 1; // Is this handle currently in the cache
                                       //   (i.e., was already there or we got a
                                       //   new one and added it to the cache)?
    union {                            // The server's extensions set.
        BYTE            rgbExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS  ext;
    };
    ULONG      ulFlags;                // flags used to get this context
    HANDLE *   phThread;      	       // thread handle of thread using this context handle
    LIST_ENTRY ListEntry;
} DRS_CONTEXT_INFO;

typedef struct _DRS_HANDLE_LIST_ELEM {
    LPWSTR     pszServerName;          // Net name of the server
    DRS_HANDLE hDrs;                   // The DRS context handle.
    LIST_ENTRY ListEntry;
} DRS_HANDLE_LIST_ELEM;


// Has this library been initialized?
BOOL gfIsDrsClientLibInitialized = FALSE;

// List of outstanding async RPC calls.
LIST_ENTRY gDrsAsyncRpcList;
RTL_CRITICAL_SECTION gcsDrsAsyncRpcListLock;

// List of outstanding sync RPC handles - uses DRS_CONTEXT_INFO
// This list's sole purpose is to enable the cancelation of 
// all sync RPC calls if a shutdown is intiated.
LIST_ENTRY gDrsRpcServerCtxList;
CRITICAL_SECTION gcsDrsRpcServerCtxList;
BOOL gfDrsRpcServerCtxListInitialized = FALSE;
DWORD gcNumDrsRpcServerCtxListEntries = 0;

// List of sync RPC handles to free - uses DRS_HANDLE_LIST_ELEM
// In order to decrease contention between threads, RPC handles
// to be freed are placed on this list to be freed later by
// a thread dedicated to the task.
LIST_ENTRY gDrsRpcFreeHandleList;
CRITICAL_SECTION gcsDrsRpcFreeHandleList;
BOOL gfDrsRpcFreeHandleListInitialized = FALSE;
DWORD gcNumDrsRpcFreeHandleListEntries = 0;

//
// Credential manangement routines
//
//
CRITICAL_SECTION            csCredentials;
PSEC_WINNT_AUTH_IDENTITY_W  gCredentials = NULL;
UCHAR                       gCredentialSeed = 0;
HANDLE                      gInstallClientToken = 0;

VOID
DrspFreeCredentials(
    PSEC_WINNT_AUTH_IDENTITY_W pCred
    )
{
    Assert(pCred);

    free(pCred->User);
    free(pCred->Domain);
    free(pCred->Password);
    free(pCred);
}

DWORD
DRSSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength
    )
//
// This function translates the parameters into a RPC_AUTH_IDENTITY_HANDLE
// that can be used when establishing an RPC connection
//
{

    ULONG                      ret;
    PSEC_WINNT_AUTH_IDENTITY_W pNewCred = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pOldCred = NULL;
    ULONG                      Length;
    WCHAR                      *wsUser = NULL, *wsDomain = NULL, *wsPassword = NULL;
    BOOL                       fInCriticalSection = FALSE;
    UNICODE_STRING             EPassword;

    if ( !gfIsDrsClientLibInitialized )
    {
        DRSClientCacheInit();
    }

    __try
    {

        if (!User && !Domain && !Password) {
            //
            // Set the credentials to NULL
            //
            EnterCriticalSection( &csCredentials );
            fInCriticalSection = TRUE;

            pOldCred =  gCredentials;
            gCredentials = NULL;

            ret = DRAERR_Success;

            __leave;

        }

        if (!User || !Domain || !Password) {
            ret = DRAERR_InvalidParameter;
            __leave;
        }

        //
        // At this point we have a new set of acceptable credentials
        //
        pNewCred = (PSEC_WINNT_AUTH_IDENTITY_W) malloc(sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        if (!pNewCred) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(pNewCred, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

        Length = wcslen(User);
        wsUser = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsUser) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsUser, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsUser, User);
        pNewCred->UserLength = Length;
        pNewCred->User       = wsUser;

        Length = wcslen(Domain);
        wsDomain = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsDomain) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsDomain, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsDomain, Domain);
        pNewCred->DomainLength = Length;
        pNewCred->Domain       = wsDomain;

        Length = PasswordLength;
        wsPassword = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsPassword) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsPassword, 0, (Length+1)*sizeof(WCHAR));
        memcpy(wsPassword, Password, (Length)*sizeof(WCHAR));
        pNewCred->PasswordLength = Length;
        pNewCred->Password       = wsPassword;

        pNewCred->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        //
        // Set the global Credentials
        //
        EnterCriticalSection( &csCredentials );
        fInCriticalSection  = TRUE;

        //
        // Encrypt the password
        //
        RtlInitUnicodeString( &EPassword, pNewCred->Password );
        RtlRunEncodeUnicodeString( &gCredentialSeed, &EPassword );

        pOldCred =  gCredentials;
        gCredentials = pNewCred;
        gInstallClientToken = ClientToken;

        ret = DRAERR_Success;

    }
    __finally
    {
        if (fInCriticalSection) {
            LeaveCriticalSection( &csCredentials );
        }

        if (ret != DRAERR_Success) {

            if (pNewCred) {
                free(pNewCred);
            }
            if (wsUser) {
                free(wsUser);
            }
            if (wsDomain) {
                free(wsDomain);
            }
            if (wsPassword) {
                free(wsPassword);
            }
        }

        if (pOldCred) {
            DrspFreeCredentials(pOldCred);
        }

    }

    return ret;
}

DWORD
DRSImpersonateInstallClient(
    OUT BOOL *pfImpersonate
    )
//
// This routine impersonates the global client token if one
// is present.  This is only necessary during install.
//
{
    *pfImpersonate = FALSE;
    if (gInstallClientToken) {
        *pfImpersonate = ImpersonateLoggedOnUser(gInstallClientToken);
        if (!(*pfImpersonate)) {
            return GetLastError();
        }
    }
    return ERROR_SUCCESS;
}

ULONG
DrspGetCredentials(
    OUT PSEC_WINNT_AUTH_IDENTITY_W *ppCred
    )
//
// This routine returns the globally stored credentials to
// perform a DsBind with.  This is only necessary during install.
//
{

    ULONG                      ret;
    PSEC_WINNT_AUTH_IDENTITY_W pNewCred = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pOldCred;
    ULONG                      Length;
    WCHAR                      *wsUser = NULL, *wsDomain = NULL, *wsPassword = NULL;
    UNICODE_STRING             EPassword;

    EnterCriticalSection( &csCredentials );
    __try
    {
        //
        // If there are no credentials, bail out now
        //
        if (!gCredentials) {
            *ppCred = NULL;
            ret = DRAERR_Success;
            __leave;
        }

        pNewCred = (PSEC_WINNT_AUTH_IDENTITY_W) malloc(sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        if (!pNewCred) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(pNewCred, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

        Length = wcslen(gCredentials->User);
        wsUser = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsUser) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsUser, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsUser, gCredentials->User);
        pNewCred->UserLength = Length;
        pNewCred->User       = wsUser;

        Length = wcslen(gCredentials->Domain);
        wsDomain = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsDomain) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsDomain, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsDomain, gCredentials->Domain);
        pNewCred->DomainLength = Length;
        pNewCred->Domain       = wsDomain;

        Length = gCredentials->PasswordLength;
        wsPassword = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsPassword) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsPassword, 0, (Length+1)*sizeof(WCHAR));
        memcpy(wsPassword, gCredentials->Password, (Length)*sizeof(WCHAR));
        pNewCred->PasswordLength = Length;
        pNewCred->Password       = wsPassword;

        //
        // Unencrypt the password
        //
        RtlInitUnicodeString( &EPassword, pNewCred->Password );
        RtlRunDecodeUnicodeString( gCredentialSeed, &EPassword );

        pNewCred->Flags = gCredentials->Flags;

        //
        // Return the copy of the credentials
        //
        *ppCred =  pNewCred;

        ret = DRAERR_Success;

    }
    __finally
    {
        if (ret != DRAERR_Success) {

            if (pNewCred) {
                free(pNewCred);
            }
            if (wsUser) {
                free(wsUser);
            }
            if (wsDomain) {
                free(wsDomain);
            }
            if (wsPassword) {
                free(wsPassword);
            }
        }

        LeaveCriticalSection( &csCredentials );

    }

    return ret;

}

VOID
DRSSetRpcCancelTime(
    IN      ULONG               MinutesTillCancel,
    IN OUT  DRS_HANDLE *        phDrs
    )
{
    RPC_BINDING_HANDLE hRpc;
    ULONG rpcstatus = RPC_S_OK;

    // get the binding handle.  (RPC says not to free this handle)
    rpcstatus = RpcSsGetContextBinding(*phDrs, &hRpc);
    if (rpcstatus!=RPC_S_OK) {
  	DRA_EXCEPT(rpcstatus,0); 
    }

    // set the cancel time in milliseconds
    rpcstatus = RpcBindingSetOption(hRpc, RPC_C_OPT_CALL_TIMEOUT, MinutesTillCancel*60*1000); 
    if (rpcstatus!=RPC_S_OK) {
	DRA_EXCEPT(rpcstatus,0); 
    }
}

void
InitRpcSessionEncryption(
    THSTATE             *pTHS,
    ULONG               ulBindFlags,
    DRS_CONTEXT_INFO    *pContextInfo,
    RPC_BINDING_HANDLE  ExistingBindingHandle
    )
{
    RPC_STATUS          RpcStatus;
    RPC_BINDING_HANDLE  RpcBindingHandle;

    // Caller should have either binding handle or context, but not both.
    Assert(    ( pContextInfo && !ExistingBindingHandle)
            || (!pContextInfo &&  ExistingBindingHandle) );

    // Callers like GetNCChanges use "one shot" session encryption which
    // is not tied to the context handle.  Many GetNCChanges calls can use
    // the same cached handle and each gets a new session key on each call.
    // Callers like InterDomainMove are associating a session key with
    // the context handle and will use the same key on one or more subsequent
    // RPC calls.  Although I don't see any obvious conflict with the two
    // modes, for now we assert that context handle based session keys
    // require an exclusively owned handle.

    Assert(FBINDSZDRS_CRYPTO_BIND & ulBindFlags
                ? FBINDSZDRS_LOCK_HANDLE & ulBindFlags
                : TRUE);

    // Clear any existing key on the thread state.

    PEKClearSessionKeys(pTHS);

    // Register a notification call back with RPC.  This will call a call
    // back function telling us the security context used.  This security
    // context is then used to query the session key and that session key
    // is then set on the thread state. When the DRA subsequently reads
    // the database all "secret" data are then re-encrypted using the
    // session key.

    if ( ExistingBindingHandle )
    {
        RpcBindingHandle = ExistingBindingHandle;
        RpcStatus = RPC_S_OK;
    }
    else
    {
        RpcStatus = RpcSsGetContextBinding(
                                        pContextInfo->hDrs,
                                        &RpcBindingHandle);
    }

    if ( RPC_S_OK == RpcStatus )
    {
        RpcStatus = RpcBindingSetOption(
                                        RpcBindingHandle,
                                        RPC_C_OPT_SECURITY_CALLBACK,
                                        (ULONG_PTR) PEKSecurityCallback);

        // After checking with RPC folks should not free
        // the binding handle returned by this function
    }

    if ( RPC_S_OK != RpcStatus )
    {
        // Could not establish session key - raise exception

        RaiseDsaExcept( DSA_CRYPTO_EXCEPTION,
                        RpcStatus,
                        0,
                        DSID(FILENO,__LINE__),
                        DS_EVENT_SEV_MINIMAL);
    }
}

CRITICAL_SECTION csBHCache;

// Uninitialized elements are default initialized to zero.
static BHCacheElement NullBHCacheElement = { 0 };

BHCacheElement rgBHCache[BHCacheSize];

void DRSClientCacheInit(void)
{
    static BOOL fAreCritSecsInitialized = FALSE;

    if (!fAreCritSecsInitialized)
    {
        //
        // This has nothing to do with the client cache, but is put in this
        // in this function to be initialized when starting up
        //
        __try {
            InitializeCriticalSection( &csCredentials );

            InitializeCriticalSection( &csBHCache );

            fAreCritSecsInitialized = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            fAreCritSecsInitialized = FALSE;
        }

        if(!fAreCritSecsInitialized) {
            DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
        }
    }

    memset(rgBHCache, 0, sizeof(rgBHCache));

    if (gfTaskSchedulerInitialized          // not so in DCPROMO
        && !gfDisableBackgroundTasks) {     // not doing performance testing
        InsertInTaskQueue(TQ_DRSExpireContextHandles,
                          NULL,
                          gulDrsCtxHandleExpiryCheckInterval);
    }

    gfIsDrsClientLibInitialized = TRUE;
}


ULONG
DRSHandleRpcClientException(
    IN  EXCEPTION_POINTERS *  pExceptPtrs,
    IN  LPWSTR                pszServerName,
    IN  DRS_CONTEXT_INFO *    pContextInfo      OPTIONAL,
    OUT ULONG *               pulErrorCode
    )
/*++

Routine Description:

    Handle RPC exceptions generated while making DRS client calls using an
    already bound DRS context handle acquired via a prior call to FBindSzDRS().
    Called as part of an __except wrapping an _IDL_DRS* call.

Arguments:

    pExceptPtrs (IN) - Exception data returned by GetExceptionInformation(),
        as retrieved in the __except.

    pszServerName (IN) - Server to which we're making the RPC call.
    
    pContextInfo (IN, OPTIONAL) - Context info associated with current binding
        to pszServerName.

    pulErrorCode (OUT) - Exception code for caller to use

Return Values:

    EXCEPTION_EXECUTE_HANDLER - Exception handled.
    EXCEPTION_CONTINUE_SEARCH - Exception not handled.

--*/
{
    ULONG   ulResult;
    ULONG   ulExceptCode;
    VOID *  pExceptAddr;
    ULONG   ulExtErrorCode;
    DWORD   dwWin32Error;

    Assert( pulErrorCode );

    *pulErrorCode = ERROR_SUCCESS; // GetExceptData does not always set this

    ulResult = GetExceptionData(pExceptPtrs, &ulExceptCode, &pExceptAddr,
                                pulErrorCode, &ulExtErrorCode);

    // If there was not an error data parameter associated with the exception,
    // turn the exception code itself into something meaningful.  If the
    // exception looks like a NTSTATUS, convert to Win32.

    if (*pulErrorCode == ERROR_SUCCESS) {
        if ( (ulExceptCode & 0xf0000000) == 0xc0000000 ) {
            *pulErrorCode = RtlNtStatusToDosError( ulExceptCode );
        } else {
            *pulErrorCode = ulExceptCode;
        }
    }

    Assert( *pulErrorCode != RPC_S_OK );

    if (EXCEPTION_EXECUTE_HANDLER == ulResult) {
        // Derive Win32 error from exception data.
        switch (ulExceptCode) {
        case DRA_GEN_EXCEPTION:
            // DRA exceptions always have an acompanying Win32 error code.
            dwWin32Error = *pulErrorCode;
            break;

        case DSA_EXCEPTION:
        case DSA_MEM_EXCEPTION:
        case DSA_DB_EXCEPTION:
        case DSA_BAD_ARG_EXCEPTION:
        case DSA_CRYPTO_EXCEPTION:
            // These NTDSA exceptions don't specify Win32 counterparts.
            // Fall through and consider the Win32 error code to be the
            // exception code for purposes of determining which event to log.
        
        default:
            // System-generated exceptions (such as those generated by RPC)
            // use a Win32 error code as the exception code.
            dwWin32Error = ulExceptCode;
            break;
        }

        // Log the exception code (if logging is cranked high enough).
        switch (dwWin32Error) {
        case RPC_S_CALL_CANCELLED:
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_DISPATCHER_CANCELED,
                     szInsertHex(GetCurrentThreadId()),
                     NULL,
                     NULL);
            break;

        case ERROR_DS_DIFFERENT_REPL_EPOCHS:
            // Only NULL on binds, and this error is not generated on binds.
            Assert(NULL != pContextInfo);

            DPRINT3(0, "RPC to %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                    pszServerName,
                    REPL_EPOCH_FROM_DRS_EXT(&pContextInfo->ext),
                    gAnchor.pLocalDRSExtensions->dwReplEpoch);
            
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                     szInsertWC(pszServerName),
                     pContextInfo
                        ? szInsertUL(REPL_EPOCH_FROM_DRS_EXT(&pContextInfo->ext))
                        : szInsertSz(""),
                     szInsertUL(gAnchor.pLocalDRSExtensions->dwReplEpoch));
            break;
        
        default:
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_RPC_EXCEPTION,
                     szInsertUL(ulExceptCode),
                     szInsertWC(pszServerName),
                     szInsertUL(*pulErrorCode));
            break;
        }
    }

    return ulResult;
}

void
DRSFreeContextHandle(
    IN      LPWSTR          pszServerName,
    IN OUT  DRS_HANDLE *    phDrs
    )
/*++

Routine Description:

    Free a given DRS_HANDLE (a context handle for the DRS interface).

    During normal operation we call the server to unbind, which frees both its
    associated resources and our own resources.  During shutdown, we must avoid
    going off-machine, so we free only our own resources and rely on the
    server's context handle rundown routine to free its resources.  

Arguments:

    pszServerName (IN) - The server to which the context handle corresponds.
        Used for logging if there are any complications.

    phDrs (IN/OUT) - on input, holds the client handle to free.  Reset to
        NULL on success.

Return Values:

    None.

--*/
{
    ULONG ulErrorCode;

    if (NULL != *phDrs) {
        BOOL fFreed = FALSE; 

        if (!eServiceShutdown) {
            __try {
		ULONG ret = RPC_S_OK; 
		DRSSetRpcCancelTime(gulDrsRpcBindTimeoutInMins, phDrs);
		_IDL_DRSUnbind(phDrs);   
		fFreed = TRUE;
	    }
            __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                                  pszServerName,
                                                  NULL,
                                                  &ulErrorCode)) {
                ;
            }
        }

        if (!fFreed) {
            // We're either shutting down or the unbind attempt failed;  the
            // remote resources will have to be freed by the context handle
            // rundown routine.  Free our local resources.
            RpcSsDestroyClientContext(phDrs);
        }
    }
}

void
DRSInsertFreeHandleQueue(
    IN      LPWSTR          pszServerName,
    IN      DRS_HANDLE      hDrs
    )
/*++

Routine Description:

    The purpose of this routine is to reduce contention between threads.  Using this
    queue of handles to be freed, only a single thread attempts to free handles, and only
    while not holding any crit. sec.  
    

Arguments:

    pszServerName - the name of the server which to free the handle from
    hDrs - the handle to free

Return Values:

    None.

--*/
{
    if (NULL != hDrs) {
	DRS_HANDLE_LIST_ELEM * pInsHandle;
	ULONG                   cbServerName;

	// allocate element and Server string name (accessable outside of this
	// threads lifetime
	pInsHandle = (DRS_HANDLE_LIST_ELEM *)malloc(sizeof(DRS_HANDLE_LIST_ELEM)); 
	if (pInsHandle==NULL) {
	    // we don't have the resources to unbind this handle.  free our resources 
	    RpcSsDestroyClientContext(&hDrs);
	    DRA_EXCEPT(ERROR_NOT_ENOUGH_MEMORY,0);
	}

	cbServerName = (wcslen(pszServerName)+1)*sizeof(WCHAR);
	pInsHandle->pszServerName = malloc(cbServerName);
	if (pInsHandle->pszServerName==NULL) {
	    // we don't have the resources to unbind this handle.  free our resources 	
	    RpcSsDestroyClientContext(&hDrs);
	    free(pInsHandle);
	    DRA_EXCEPT(ERROR_NOT_ENOUGH_MEMORY,0);
	}

	wcscpy(pInsHandle->pszServerName, pszServerName);
	pInsHandle->hDrs = hDrs;

	// insert into queue     
	EnterCriticalSection(&gcsDrsRpcFreeHandleList);
	__try {
	    if (!gfDrsRpcFreeHandleListInitialized) {
		InitializeListHead(&gDrsRpcFreeHandleList);  
		Assert(0 == gcNumDrsRpcFreeHandleListEntries);
		gfDrsRpcFreeHandleListInitialized = TRUE;
	    }
	    InsertTailList(&gDrsRpcFreeHandleList, &pInsHandle->ListEntry);
	    ++gcNumDrsRpcFreeHandleListEntries; 
	}
	__finally {
	    LeaveCriticalSection(&gcsDrsRpcFreeHandleList);
	} 
    }

}

void
DRSExpireClientCtxHandles(
    void
    ) 
{
    if (gfDrsRpcFreeHandleListInitialized) { 
	
	// this is the only deletion task on the queue, so we
	// don't need to hold the critsec to check IsListEmpty 
	while (!IsListEmpty(&gDrsRpcFreeHandleList)) {
	    PLIST_ENTRY listEntry = NULL;
	    DRS_HANDLE_LIST_ELEM * phFreeHandle = NULL;
	    ULONG rpcstatus = 0; 

	    // release the critsec before going off machine
	    EnterCriticalSection(&gcsDrsRpcFreeHandleList);
	    __try {
		listEntry = RemoveHeadList(&gDrsRpcFreeHandleList);
		phFreeHandle = CONTAINING_RECORD(listEntry,DRS_HANDLE_LIST_ELEM,ListEntry); 
	    }
	    __finally {
		LeaveCriticalSection(&gcsDrsRpcFreeHandleList);
	    }

	    // free the context handle (do the rpc call to unbind)
	    DRSFreeContextHandle(phFreeHandle->pszServerName, &phFreeHandle->hDrs);
	    free(phFreeHandle->pszServerName);
	    free(phFreeHandle); 
	}
    }
}

void DRSClientCacheUninit(
    void
    )
{
    ULONG i;

    if (gfIsDrsClientLibInitialized) {

        // Reject any new callers.
        gfIsDrsClientLibInitialized = FALSE;

        // Release references to all cached binding handles.  Free each of them
        // if no one else claims a reference.
        EnterCriticalSection(&csBHCache);
        __try
        {
            for (i=0; i < BHCacheSize; i++)
            {
                VALIDATE_BH_ENTRY(i);

                if (    ( NULL != rgBHCache[i].hDrs )
                     && ( 0 == --rgBHCache[i].cRefs )
                   )
                {    
		    Assert(eServiceShutdown || DsaIsSingleUserMode());
		    // DRSFreeContextHandles does not go off machine while
		    // eServiceShutdown is true.
		    DRSFreeContextHandle(rgBHCache[i].pszServer,
                                         &rgBHCache[i].hDrs);
	      
                    free(rgBHCache[i].pszServer);
		    if (rgBHCache[i].pszServerPrincName) {
			free(rgBHCache[i].pszServerPrincName);
		    }
                    memset(&rgBHCache[i], 0, sizeof(rgBHCache[i]));
                }
            }
        }
        __finally
        {
            LeaveCriticalSection(&csBHCache);
        }
    }
}


ULONG
UlBHCacheHash(
    IN  LPWSTR  szServer
    )
{
    ULONG ulHashVal = 0;
    ULONG key = 0x0a1;

    while (*szServer)
    {
        ULONG hash1 = ((ulHashVal << 4) ^ *szServer);
        ULONG hash2 = ((ulHashVal & 0x80) ? key : 0);
        ULONG hash3 = ((ulHashVal & 0x40) ? key << 1 : 0);
        ULONG hash4 = ((ulHashVal & 0x20) ? key << 2 : 0);
        ULONG hash5 = ((ulHashVal & 0x10) ? key << 3 : 0);
        ulHashVal = hash1 ^ hash2 ^ hash3 ^ hash4 ^ hash5;
        szServer++;
    }

    ulHashVal %= BHCacheSize;
    return ulHashVal;
}


void
BHCacheDecRef(
    IN OUT  BHCacheElement *  pEntry
    )
/*++

Routine Description:

    Decrease the refcount of an entry in the handle cache.  If the refcount
    drops to zero, free the entry.

Arguments:

    pEntry (IN/OUT) - Entry for which to decrement the refcount.

Return Values:

    None.

--*/
{
    Assert(OWN_CRIT_SEC(csBHCache));
    Assert((BYTE *)pEntry >= (BYTE *)rgBHCache);
    Assert((BYTE *)pEntry < (BYTE *)rgBHCache + sizeof(rgBHCache));

    pEntry->cRefs -= 1;

    if (0 == pEntry->cRefs) {
	DRSInsertFreeHandleQueue(pEntry->pszServer, pEntry->hDrs);
        free(pEntry->pszServer);
        if (pEntry->pszServerPrincName) {
            free(pEntry->pszServerPrincName);
        }
        memset(pEntry, 0, sizeof(*pEntry));
    }
    else {
        // Update "last used" timestamp.
        pEntry->cTickLastUsed = GetTickCount(); 
    }
}

void
BHCacheFreeContext(
    IN      LPWSTR       szServer,
    IN OUT  DRS_HANDLE * pHandle
    )
{
    ULONG i;

    i = UlBHCacheHash(szServer);

    EnterCriticalSection(&csBHCache);
    __try
    {
        VALIDATE_BH_ENTRY(i);

	// The server name should match.
        Assert(    ( NULL != rgBHCache[i].pszServer )
                && !_wcsicmp( rgBHCache[i].pszServer, szServer )
              );

        // And the pointer to the context handle passed in by the caller must
        // not point to the handle in the cache -- otherwise we'll zero it
        // out below, even if it still has a positive refcount.
        Assert(&rgBHCache[i].hDrs != pHandle);

	
        // Make sure it's our server.
        if (    ( NULL != rgBHCache[i].pszServer )
             && !_wcsicmp( rgBHCache[i].pszServer, szServer )
           )
        {
            // unlock the handle ( if it was locked )
            rgBHCache[i].fLocked = FALSE; 
            BHCacheDecRef(&rgBHCache[i]);
        }

        *pHandle = NULL;
    }
    __finally
    {
        LeaveCriticalSection(&csBHCache);
    }
}


void BHCacheVoidServer(
    IN  LPWSTR      szServer
    )
{
    ULONG i;

    i = UlBHCacheHash(szServer);

    EnterCriticalSection(&csBHCache);
    __try
    {
        VALIDATE_BH_ENTRY(i);
        if (    ( NULL != rgBHCache[i].pszServer )
             && !_wcsicmp(rgBHCache[i].pszServer, szServer)
             && !rgBHCache[i].fDontUse )
        {
            // Set fDontUse flag.  This will stop entry from being handed
            // out and insure that it is nuked after the last deref.
            rgBHCache[i].fDontUse = TRUE;

            // Deref the entry's self-reference.
            BHCacheDecRef(&rgBHCache[i]);
        }
    }
    __finally
    {
        LeaveCriticalSection(&csBHCache);
    }
}

// Helper to copy (possibly NULL) source extensions to
// destination extensions.

VOID
CopyExtensions(
    DRS_EXTENSIONS *pextSrc,
    DRS_EXTENSIONS *pextDst)
{
    // We assume destination extensions are allocated to hold at least
    // CURR_MAX_DRS_EXT_FIELD_LEN bytes in their rgb field (i.e., that the
    // extensions *structure* is at least CURR_MAX_DRS_EXT_STRUCT_SIZE bytes).

    DWORD cb;

    if ( NULL == pextSrc )
    {
        pextDst->cb = 0;
    }
    else
    {
        // If we've never heard of an extension, we're not going
        // to ask about it, so cut the stream to fit our buffer
        // size (eliminating the need to dynamically allocate
        // extension buffers).

        pextDst->cb = min(pextSrc->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
        memcpy(pextDst->rgb, pextSrc->rgb, pextDst->cb);
    }
}

//
// Flags for BHCacheGetDrsContext
//

#define BHCACHE_FLAGS_LOCK_HANDLE (1)

BOOL
BHCacheGetDrsContext(
    IN  THSTATE *         pTHS,
    IN  DRS_EXTENSIONS *  pextCurrentLocal,
    IN  LPWSTR            pszServer,
    IN  ULONG             flags,
    OUT DRS_HANDLE *      phDrs,
    OUT DRS_EXTENSIONS *  pextRemote
    )
/*++

Routine Description:

    Retrieve the DRS context handle and extensions associated with a given
    server from the cache, if an appropriate cache entry is available.

Arguments:

    pszServer (IN) - name of the server for which to retrieve handle/extensions.
    flags (IN) Controls operation of the routine. Defined flags are as follows

                  BHCACHE_FLAGS_LOCK_HANDLE -- Indicates that the handle be locked
                                               before returning. If this flag is
                                               specified then this routine will
                                               only return handles with a ref count
                                               of 1 after setting the locked flags

    phDrs (OUT) - on successful return, holds the associated context handle.
    pextRemote (OUT) - on successful return, holds the associated server extensions.

Return Values:

    TRUE - success.
    FALSE - no cache entry exists for this server.

--*/
{
    BOOL fSuccess = FALSE;
    int  i;
    ULONG rpcstatus = RPC_S_OK;

    Assert((NULL != pszServer) && (NULL != phDrs) && (NULL != pextRemote));

    i = UlBHCacheHash(pszServer);

    EnterCriticalSection(&csBHCache);
    __try {
        VALIDATE_BH_ENTRY(i);

        // Do we have a cached handle to *this* server which
        // can be returned - i.e. is not flagged for expiry?

        if (    (NULL != rgBHCache[i].pszServer)
             && !_wcsicmp(pszServer, rgBHCache[i].pszServer)
             && (!rgBHCache[i].fDontUse)
             && (!rgBHCache[i].fLocked)
             && ((1==rgBHCache[i].cRefs) || (!(flags & BHCACHE_FLAGS_LOCK_HANDLE)))){
            if ((pextCurrentLocal->cb != rgBHCache[i].extLocal.cb)
                || (0 != memcmp(pextCurrentLocal->rgb,
                                rgBHCache[i].extLocal.rgb,
                                pextCurrentLocal->cb))) {
                // Our DRS extensions have changed since we bound to this remote
                // DSA.  Unbind and rebind so we can inform the remote DSA of
                // our latest extensions.
                DPRINT1(0, "Forcing rebind to %ls because our DRS_EXTENSIONS have changed.\n",
                        rgBHCache[i].pszServer);
            
                // Set fDontUse flag.  This will stop entry from being handed
                // out and ensure that it is nuked after the last deref.
                rgBHCache[i].fDontUse = TRUE;
    
                // Deref the entry's self-reference.
                BHCacheDecRef(&rgBHCache[i]);

                Assert(!fSuccess);
            } else {

		// Return a copy of the cached handle.  We don't return
		// a pointer to the handle itself so that we can set
		// per handle variables, such as time to cancel.  IE
		// if we returned a pointer to the cached handle, all
		// calls using this handle, no matter with what purpose
		// would have the same time to cancel.
		rpcstatus = RpcBindingCopy(rgBHCache[i].hDrs, phDrs);
		if (rpcstatus != RPC_S_OK) {
		    fSuccess = FALSE; 
		    __leave;
		}
                CopyExtensions(&rgBHCache[i].extRemote, pextRemote);
                rgBHCache[i].cRefs += 1;
                if (flags & BHCACHE_FLAGS_LOCK_HANDLE) {
                    rgBHCache[i].fLocked = TRUE;
                }
    
                fSuccess = TRUE;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csBHCache);
    }

    return fSuccess;
}


BOOL
findDomainNcFast(
    THSTATE *pTHS,
    DBPOS *pDBTmp,
    LPWSTR *ppszDomainNcName
    )

/*++

Routine Description:

Helper routine to extract the domain guid.  This routine tries to obtain
the domain from the masterNC list.  This may not always work if the list
does not have the expected contents.

We expect the hasMasterNcs list to have three items: schema nc, config nc
and the domain nc.  Match the schema and config nc's by guid to eliminate them,
and we are left with the domain nc.  This could legitimately fail if:
1. hasMasterNCs not populated during install scenarios for some reason
2. In the future if we support more than 1 writable NC per server

Expect we are positioned on a NTDSA object

Arguments:

    pDBTmp -
    puuidDomain -

Return Value:

    BOOL - Whether the masterNC list was in expected form.  It may not be
    and this is not an error.
    Exceptions raised for errors.

--*/

{
    BOOL fFound = FALSE, fSeenSchema = FALSE, fSeenConfig = FALSE;
    ULONG NthValIndex = 0;
    ULONG len, nameLength;
    DSNAME *pNC = NULL;

    // Loop through the hasMasterNCs list
    while (!(DBGetAttVal(pDBTmp,
                         ++NthValIndex,
                         ATT_HAS_MASTER_NCS,
                         0,
                         0, &len, (PUCHAR *)&pNC))) {

        // Config NC
        if ( 0 == memcmp( &(pNC->Guid), &(gAnchor.pConfigDN->Guid), sizeof( UUID ) ) ) {
            Assert( !fSeenConfig );
            fSeenConfig = TRUE;
            DPRINT1( 2, "dnConfig = %ws\n", pNC->StringName );
            THFree( pNC );
            continue;
        }

        // Schema NC
        if ( 0 == memcmp( &(pNC->Guid), &(gAnchor.pDMD->Guid), sizeof( UUID ) ) ) {
            Assert( !fSeenSchema );
            fSeenSchema = TRUE;
            DPRINT1( 2, "dnSchema = %ws\n", pNC->StringName );
            THFree( pNC );
            continue;
        }

        // Its a domain NC.  In the future, may be more than one
        // ISSUE 2001-01-19 JeffParh - Should bail early (and free string) if
        // we've already seen one non-config/schema NC.
        nameLength = wcslen( pNC->StringName ) + 1;
        *ppszDomainNcName = THAllocEx( pTHS, nameLength * sizeof(WCHAR) );
        wcscpy( *ppszDomainNcName, pNC->StringName );
        DPRINT1( 2, "dnDomain = %ws\n", pNC->StringName );
        THFree( pNC );
    }

    // Must only be three NCs in the list, and have a schema and config nc
    if ( (4 == NthValIndex) && fSeenSchema && fSeenConfig ) {
        fFound = TRUE;
    }

    // This may not be true if the server has its domain nc removed, for example
    // by deleting its cross-ref object, or if the ntdsDsa object itself has been
    // deleted (in which case it has no ATT_HAS_MASTER_NCS).

    return fFound;
} /* findDomainNcFast */


VOID
findDomainNcGeneral(
    THSTATE *pTHS,
    DBPOS *pDBTmp,
    LPWSTR *ppszDomainNcName
    )

/*++

Routine Description:

Helper routine to extract the domain NC name.  This algorithm will work
regardless of the number of master NC's a server may host.

Assumed pDBTmp is positioned on the server object, which is valid and
present.

Arguments:

    pDBTmp -
    puuidDomain -

Return Value:

   None.
   Exceptions raised on error

--*/

{
    DWORD dbErr;
    DSNAME *pdnComputer = NULL;
    COMMARG commArg;
    CROSS_REF * pCR;
    DWORD cb, nameLength;

    __try {

        // Get the computer dn
        dbErr = DBGetAttVal(pDBTmp, 1, ATT_SERVER_REFERENCE,
                         0, 0, &cb, (BYTE **) &pdnComputer);
        if (dbErr) {
            DPRINT1(0, "Can't find server reference, db error %d.\n", dbErr);
            
            // Server object (parent of NTDS Settings) lacks a server reference
            // attribute.  This might occur if the server object had been
            // deleted, for example, or if the server reference has not yet been
            // written,
            DRA_EXCEPT(ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF, dbErr);
        }

        DPRINT1( 2, "dnComputer = %ws\n", pdnComputer->StringName );

        // If the server reference contains mangled components, it is not a useful
        // or valid input to FindBestCrossRef. Don't even try.
        // This check is to help diagnose cases where the server reference is mangled.
        // If we did not make this check, FindBestCrossRef might return a parent
        // cross-ref, resulting in an valid but wrong SPN being generated.  The user
        // would see this as wrong account name when A calls B, and not know to check
        // the server reference attribute for B on A.

        if (IsMangledDSNAME(pdnComputer)) {
            DRA_EXCEPT(ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF, dbErr);
        }

        // Find the naming context of the computer
        // This could be a phantom on this machine if we don't hold nc
        memset( &commArg, 0, sizeof( COMMARG ) );  // not used
        pCR = FindBestCrossRef( pdnComputer, &commArg );
        if (NULL == pCR) {
            DPRINT1(0, "Can't find cross ref for %ws.\n",
                    pdnComputer->StringName );
            DRA_EXCEPT(ERROR_DS_NO_CROSSREF_FOR_NC, DRAERR_InternalError);
        }

        nameLength = wcslen( pCR->pNC->StringName ) + 1;
        *ppszDomainNcName = THAllocEx( pTHS, nameLength * sizeof(WCHAR) );
        wcscpy( *ppszDomainNcName, pCR->pNC->StringName );

        DPRINT1( 2, "NC = %ws\n", pCR->pNC->StringName );

    } _finally {

        if (NULL != pdnComputer) {
            THFree(pdnComputer);
        }
    }

} /* findDomainNcGeneral */


VOID
findDnsHostDomainNames(
    THSTATE *pTHS,
    UUID *pguidNtdsaObject,
    LPWSTR *ppszDnsDomainName
    )

/*++

Routine Description:

Given the guid of an NTDS DSA object, calculate the dns hostname and the
dns domain name.

The hostname comes from the ATT_DNS_HOST_NAME attribute on the parent object, which
is the server object.

The dns domain name comes by
1. Determining the domain nc that the server is in
2. Converting the domain nc to a dns domain name

Arguments:

    pTHS -
    pguidNtdsaObject - guid of ntdsa object
    ppszDnsDomainName - pointer to pointer to receive dns domain name

Return Value:

    VOID - raises exceptions

--*/

{
    DWORD cb, dbErr, status, length;
    DBPOS *pDBTmp = NULL;
    DSNAME dnNtdsaByGuid = {0};
    BOOL fInTransAlready = pTHS->fSyncSet, fDomainFound;
    LPWSTR pszValue = NULL;
    LPWSTR pszDomainNC = NULL;
    PDS_NAME_RESULTW pResult = NULL;

    Assert( pguidNtdsaObject );

    // Create a dsname with just the server's guid in it
    dnNtdsaByGuid.structLen = sizeof(dnNtdsaByGuid);
    dnNtdsaByGuid.Guid = *pguidNtdsaObject;

    // We may or may not be in a trasaction already at this point
    if (!fInTransAlready) {
        BeginDraTransaction(SYNC_READ_ONLY);
    }
    __try {
        // Use another DBPOS so not as to disturb callers thread db state
        DBOpen (&pDBTmp);

        // Look up the server's NTDSA object
        dbErr = DBFindDSName(pDBTmp, &dnNtdsaByGuid);
        if (dbErr)
        {
            DPRINT1( 0, "DbFindDsName(guid) failed with db err %d\n", dbErr );
            DRA_EXCEPT(ERROR_DS_CANT_FIND_DSA_OBJ, dbErr);
        }

        //
        // Find the domain name
        //

        fDomainFound = findDomainNcFast( pTHS, pDBTmp, &pszDomainNC );

        // Reposition to parent (server obj) if needed
        // We only need to do this if the fast domain method did not work
        if (!fDomainFound) {
            dbErr = DBFindDNT( pDBTmp, pDBTmp->PDNT );
            if (dbErr) {
                DPRINT2(0, "Can't find server ntdsa parent by dnt 0x%x, db error %d.\n", pDBTmp->PDNT, dbErr);
                // ERROR: can't find server object
                DRA_EXCEPT(DRAERR_DBError, dbErr);
            }
        }

        // If we failed to find the fast way, try the general way
        // We need to be positioned on the server object to do this
        if (!fDomainFound) {
            // We think there is still a situation in product 1 where we need this code.
            // It would be when the domain crossRef has been deleted, and the
            // HAS_MASTER_NCs attribute is missing the domain
            findDomainNcGeneral( pTHS, pDBTmp, &pszDomainNC );
        }

        // Convert the NC to a DNS name

        status = DsCrackNamesW (
            NULL,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME_EX,
            1,
            &pszDomainNC,
            &pResult);
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "DsCrackNamesW failed, error %d\n", status );
            DRA_EXCEPT(ERROR_DS_BAD_NAME_SYNTAX, status);
        }
        if ( (pResult->cItems != 1) ||
             ( (pResult->rItems[0].status != DS_NAME_NO_ERROR) &&
               (pResult->rItems[0].status != DS_NAME_ERROR_DOMAIN_ONLY) ) ) {
            DPRINT1( 0, "DsCrackNamesW returned unexpected results %d\n",
                     pResult->rItems[0].status );
            // ERROR: domain is in wrong form, can't crack
            DRA_EXCEPT(ERROR_DS_BAD_NAME_SYNTAX, status);
        }

        // Copy out the domain name
        length = wcslen( pResult->rItems[0].pDomain ) + 1;
        *ppszDnsDomainName = THAllocEx( pTHS, length * sizeof(WCHAR) );
        wcscpy( *ppszDnsDomainName, pResult->rItems[0].pDomain );
        DPRINT1( 2, "dnsDomain = %ws\n", *ppszDnsDomainName );

    } _finally {
        if (pDBTmp) {
            DBClose (pDBTmp, !AbnormalTermination());
        }
        if (!fInTransAlready) {
            EndDraTransaction(!AbnormalTermination());
        }
        if (pszValue) {
            THFreeEx(pTHS, pszValue);
        }
        if (pszDomainNC) {
            THFreeEx(pTHS, pszDomainNC);
        }
        if (pResult) {
            DsFreeNameResultW( pResult );
        }
    }
} /* findDnsHostDomainNames */


BOOL
DRSMakeFQDnsName(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    OUT LPWSTR *    ppszFQDnsName
    )
/*++

Routine Description:

    Converts a non-qualified DNS name (e.g., L"172.31.238.167") to a fully
    qualified DNS name (e.g., L"ntdsdc0.ntdev.microsoft.com").

Arguments:

    pszServerName (IN) - server name to convert.

    ppszFQDnsName (OUT) - On successful return, holds the fully qualified
        DNS name of the server.  Optional.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    BOOL              fSuccess = FALSE;
    LPSTR             paszServerName;
    struct hostent *  pHostEntry = NULL;

    paszServerName = String8FromUnicodeString(TRUE, CP_ACP, pszServerName, -1,
                                              NULL, NULL);
    Assert(NULL != paszServerName);
    Assert('\0' != *paszServerName);

    pHostEntry = gethostbyname(paszServerName);
    if (pHostEntry) {
        if (ppszFQDnsName) {
            *ppszFQDnsName = UnicodeStringFromString8(CP_ACP,
                                                      pHostEntry->h_name, -1);
            Assert(NULL != *ppszFQDnsName);
            Assert(L'\0' != **ppszFQDnsName);
        }

        fSuccess = TRUE;
    }

    THFreeEx(pTHS, paszServerName);

    return fSuccess;
}


DWORD
DRSMakeOneWaySpn(
    IN  THSTATE *           pTHS,
    IN  LPWSTR              pszTargetServerName,
    IN  RPC_BINDING_HANDLE  hServer,
    OUT LPWSTR *            ppszSpn
    )

/*++

Routine Description:

Create a one-way authentication SPN.  This is done by asking the server what name
he would like us to use.  Not very secure this way.

Arguments:

    pTHS - Thread state
    pszTargetServerName - Name of target server
    hServer - RPC binding handle to target server
    ppszSpn - pointer to pointer, to receive pointer to allocated string

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    LPWSTR pszRpcSpn = NULL, pszSpnTemp;

    DPRINT1( 0, "Rpc Handle to %ls is using one-way authentication.\n",
             pszTargetServerName );

    status = RpcMgmtInqServerPrincNameW(hServer,
                                        RPC_C_AUTHN_GSS_KERBEROS,
                                        &pszRpcSpn);

    Assert((status != RPC_S_BINDING_INCOMPLETE)
           && "Contact RPC dev -- this shouldn't be returned by"
           "RpcMgmtInqServerPrincName().");

    if (RPC_S_OK != status) {
        DPRINT1(0, "RpcMgmtInqServerPrincName failed with %d\n", status);
        return status;
    }

    Assert( pszRpcSpn && wcslen(pszRpcSpn) );

    // Spn is expected to returned from malloc heap - reallocate
    length = wcslen( pszRpcSpn ) + 1;
    pszSpnTemp = malloc(length * sizeof(WCHAR));
    if (NULL == pszSpnTemp) {
        status = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        wcscpy(pszSpnTemp, pszRpcSpn);
        *ppszSpn = pszSpnTemp;
    }

    RpcStringFreeW(&pszRpcSpn);

    return status;
} /* DRSMakeOneWaySpn */


DWORD
DRSMakeMutualAuthSpn(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszTargetServerName,
    IN  LPWSTR      pszTargetDomainName,    OPTIONAL
    OUT LPWSTR *    ppszSpn
    )
/*++

Routine Description:

   Construct a SPN for use in communicating with the desired server.

   The SPN's which the server is expecting are written in
   dsamain\src\servinfo.c

   According to the SPN specification by Paulle, client side replication spns
   are as follows:

   DCGUID = guid of the host server DC
   DDNS = fully qualified DNS name of domain of the host server DC

   Form the SPN "E3514235-4B06-11D1-AB04-00C04FC2DCD2/DCGUID/DDNS". (The GUID
   is that of the replication RPC interface.) This is what is written to the
   servicePrincipalName attribute of the DCs account object

   A replication client adds "@DDNS" to the above SPN to pass in to the
   pszTargetName parameter of InitializeSecurityContext or the ServerPrincName
   parameter of RpcBndingSetAuthInfo. The reason for the "@DDNS" is so that
   the KDC does not try and look the SPN up in the GC, which we don't want to
   do because the GC depends on replication, so we'd have a circular
   dependency.  The "@DDNS" does not get written to the servicePrincipalName
   attribute.

Arguments:

    pTHS (IN)
    pszTargetServerName (IN) - dns name of server to be called
    pszTargetDomainName (IN, OPTIONAL) - dns name of domain for which the target
        server is a DC
    ppszSpn (OUT) - receives pointer to buffer to new spn

    A note on variable usage:

    pszTargetServerName - incoming server name, never modified
    pszServiceName - The domain name part of the spn. This is a pointer to
           whatever storage we decide to use. Never freed itself.
    pszInstanceName - The host name part of the spn. This is a pointer to
           whatever storage we decide to use. Never freed itself.
    pszSpn - actual spn to be returned to the user. Only freed on error.
    pszTemp, pszDnsHostName, pszDnsDomainName - temporary internal allocations
            Always freed on exit.

Return Value:

    DWORD - win32 status

--*/
{
#define UUID_STRING_LENGTH 36
    DWORD status, length, nameLength;
    LPWSTR pszFirstDot, pszServiceName, pszInstanceName, pszClassName;
    WCHAR szServerUuid[UUID_STRING_LENGTH + 1];
    UUID uuidServer, uuidDomain;
    BOOL fGuidBasedName = FALSE;
    LPWSTR pszSpn = NULL, pszTemp = NULL;
    LPWSTR pszDnsHostName = NULL, pszDnsDomainName = NULL;

    DPRINT1( 1, "DRSMakeSpn: server = %ls\n", pszTargetServerName );

    Assert( pszTargetServerName );
    Assert( ppszSpn );

    // Start with the name we are given
    pszInstanceName = pszTargetServerName;

    // Name transformations

    // Treat netbios names like dns names, remove \\ prefix
    if (*pszInstanceName == L'\\') {
        pszInstanceName++;
        if (*pszInstanceName == L'\\') {
            pszInstanceName++;
        }
    }

    // If server name has trailing '.', make a copy and remove it
    nameLength = wcslen( pszInstanceName );
    Assert( nameLength );
    if (pszInstanceName[nameLength - 1] == L'.') {
        pszTemp = THAllocEx(pTHS, nameLength * sizeof(WCHAR));
        nameLength--;
        wcsncpy(pszTemp, pszInstanceName, nameLength);
        pszTemp[nameLength] = L'\0';
        pszInstanceName = pszTemp;
    }

    // Determine what kind of name this.

    pszFirstDot = wcschr( pszInstanceName, L'.' );
    if (NULL != pszFirstDot) {
        // Determine if this is a guid-based name
        length = (DWORD)(pszFirstDot - pszInstanceName);
        if (UUID_STRING_LENGTH == length) {
            wcsncpy(szServerUuid, pszInstanceName, length);
            szServerUuid[length] = L'\0';
            status = UuidFromStringW(szServerUuid, &uuidServer);
            fGuidBasedName = (status == ERROR_SUCCESS);
        }
    }

    if (fGuidBasedName) {
        // GUID-based DNS name.
        //
        // SPN = drs idl guid / ntdsa-guid / domain @ domain
        //

        // If caller supplied GUID-based DNS name and target domain name, what
        // does he expect us to do?
        Assert(NULL == pszTargetDomainName);

        __try {
            findDnsHostDomainNames( pTHS,
                                    &uuidServer,
                                    &pszDnsDomainName );
            status = ERROR_SUCCESS;
        } __except (GetDraException((GetExceptionInformation()), &status)) {
            ;
        }
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
        pszClassName = DRS_IDL_UUID_W;
        pszInstanceName = szServerUuid;
        pszServiceName = pszDnsDomainName;
        pszTargetDomainName = pszDnsDomainName;
    } else {
        // HOST-based DNS name
        //
        // SPN = GC / Hostname / forest (aka Root DNS name )
        //
        pszClassName = GCSpnType;
        // pszInstanceName already set to incoming target host name
        pszServiceName = gAnchor.pwszRootDomainDnsName;
        // pszTargetDomainName is set if present
    }

    // Construct host-based replication SPN
    // Note, malloc is used to allocate the principal name because it is stored
    // in the binding cache and must outlast the current thread.

    Assert( pszInstanceName );
    Assert( pszServiceName );

    length = UUID_STRING_LENGTH + 1 +
        wcslen( pszInstanceName ) + 1 +
        wcslen( pszServiceName ) + 1 +
        (pszTargetDomainName ? wcslen( pszTargetDomainName ) : 0) + 1;

    pszSpn = (LPWSTR) malloc(length * sizeof(WCHAR));
    if (NULL == pszSpn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = DsMakeSpnW( pszClassName,
                         pszServiceName,
                         pszInstanceName,
                         0,
                         NULL,
                         &length,
                         pszSpn );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "DsMakeSpn failed with status %d\n", status );
        goto cleanup;
    }

    // If we have a target domain name, use it
    // The @ form is needed when making a call to the GC
    if (pszTargetDomainName) {
        wcscat( pszSpn, L"@" );
        wcscat( pszSpn, pszTargetDomainName );
    }

    DPRINT2( 1, "DRSMakeSpn: server=%ws, new SPN = %ls\n",
             pszTargetServerName, pszSpn );

    *ppszSpn = pszSpn;
    pszSpn = NULL; // don't clean up

    // fall through for cleanup of temporaries

cleanup:
    if (pszSpn) {
        free( pszSpn );
    }
    if (pszTemp) {
        THFreeEx(pTHS, pszTemp);
    }
    if (pszDnsHostName) {
        THFreeEx(pTHS, pszDnsHostName);
    }
    if (pszDnsDomainName) {
        THFreeEx(pTHS, pszDnsDomainName);
    }

    return status;
} /* DRSMakeSpn */


RPC_STATUS
DRSGetRpcBinding(
    IN  THSTATE *             pTHS,
    IN  LPWSTR                pszServer,
    IN  LPWSTR                pszDomain,            OPTIONAL
    IN  BOOL                  fUseMutualAuthSpn,
    OUT RPC_BINDING_HANDLE *  prpc_handle,
    OUT LPWSTR *              ppszServerPrincName
    )
/*++

Description:

    Generate a new RPC_BINDING_HANDLE for the given server.

Arguments:

    pTHS (IN)

    pszServer (IN) - server of interest.

    pszDomain (IN, OPTIONAL) - DNS domain name of server.

    prpc_handle (OUT) - on success, holds a pointer to RPC_BINDING_HANDLE for
        szServer.

    ppszServerPrincName (IN/OUT) on success, holds a pointer to the server
        principal name as returned by RpcMgmtInqServerPrincName.  Should be
        freed via RpcStringFree.

Return value:

    RPC_STATUS - Win32 error code

--*/
{
    RPC_IF_HANDLE               IfHandle = _drsuapi_ClientIfHandle;
    RPC_STATUS                  status;
    ULONG                       DrsError;
    PSEC_WINNT_AUTH_IDENTITY_W  Credentials = NULL;
    LPWSTR                      pszStringBinding = NULL;
    LPWSTR                      pszAddress;
    WCHAR                       pszIpAddress[IPADDRSTR_SIZE];
    BOOL                        fFallback = FALSE;

    Assert(NULL != pszServer);
    Assert(NULL != prpc_handle);
    Assert(NULL != ppszServerPrincName);

    *ppszServerPrincName = NULL;
    *prpc_handle = NULL;

    __try {
        status = DrspGetCredentials(&Credentials);
        if (0 != status) {
            // This function should only fail on resource allocation failures.
            DPRINT1(0, "DRSGetRpcBinding: DrspGetCredentials failed (%d)\n", status);
            __leave;
        }

        // Strip leading backslashes.
        for (pszAddress = pszServer; L'\\' == *pszAddress; pszAddress++) {
            ;
        }

        if(status = GetIpAddrByDnsNameW(pszAddress, pszIpAddress)){
            LogEvent8WithData(DS_EVENT_CAT_RPC_CLIENT,
                              DS_EVENT_SEV_EXTENSIVE,
                              DIRLOG_DS_DNS_HOST_RESOLUTION_FAILED,
                              szInsertWC(pszAddress),
                              szInsertWin32Msg(status),
                              NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(status),
                              &status);
            DPRINT2(1, "DRSGetRpcBinding: GetIpAddrByDnsNameW() failed to resolve hostname %ws Winsock failed with %d\n",
                    pszAddress, status);
            status = ERROR_DS_DNS_LOOKUP_FAILURE;
            __leave;
        }

        status = RpcStringBindingComposeW(0,
                                          L"ncacn_ip_tcp",
                                          pszIpAddress,
                                          NULL,
                                          0,
                                          &pszStringBinding);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcStringBindingComposeW failed (%d)\n",
                    status);
            __leave;
        }

        status = RpcBindingFromStringBindingW(pszStringBinding, prpc_handle);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcBindingFromStringBindingW failed (%d)\n",
                    status);
            __leave;
        }

        Assert(NULL != *prpc_handle);

        // Binding handle created successfully.  Resolve the partially bound
        // handle into a fully bound handle.
        status = RpcEpResolveBinding(*prpc_handle, IfHandle);
        if (RPC_S_OK != status) {
            DPRINT1(1, "DRSGetRpcBinding: RpcEpResolveBinding failed (%d)\n",
                    status);
            __leave;
        }

        // Make mutual auth spn if requested.
        // There are two types of fallback here: construction time and bind time.
        // If we fail to construct the spn for an expected reason, construct a one-
        // way spn.  If we construct ok, but fail to bind, this routine gets called
        // again with the fUseMutual flag false, at which we build a one-way spn.
        if (fUseMutualAuthSpn) {
            //
            // Caller wants a mutual authenticated binding
            //
            status = DRSMakeMutualAuthSpn(pTHS, pszAddress, pszDomain,
                                          ppszServerPrincName);
            if (status) {
                if ((0 == GetConfigParam(DRA_SPN_FALLBACK, &fFallback, sizeof(BOOL)))
                    && fFallback) {
                    // We've been configured to allow fallback to one-way auth
                    // if we fail to construct a mutual-auth SPN.
                    DPRINT2(0, "Handling error %d by falling back to one-way auth for %ws.\n",
                            status, pszAddress);
                    status = DRSMakeOneWaySpn( pTHS,pszAddress,*prpc_handle,ppszServerPrincName );
                } else {
                    LogEvent8WithData(DS_EVENT_CAT_RPC_CLIENT,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_BUILD_SPN_FAILURE,
                                      szInsertWC(pszAddress),
                                      szInsertWin32Msg(status),
                                      NULL, NULL, NULL, NULL, NULL, NULL,
                                      sizeof(status),
                                      &status);
                    DPRINT2( 0, "Error %d creating mutual auth SPN for %ws.\n",
                             status, pszAddress);
                }
            }
        } else {
            //
            // Caller wants a one-way authenticated binding
            //
            status = DRSMakeOneWaySpn( pTHS,pszAddress,*prpc_handle,ppszServerPrincName );
        }
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: DRSMakeSpn failed (%d)\n", status);
            __leave;
        }

        Assert(L'\0' != *ppszServerPrincName);

        status = RpcBindingSetAuthInfoW(*prpc_handle,
                                        *ppszServerPrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_GSS_KERBEROS,
                                        Credentials,
                                        RPC_C_AUTHZ_NONE);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcBindingSetAuthInfo failed (%d)\n",
                    status);
            __leave;
        }

        // Success!
        Assert(RPC_S_OK == status);
        Assert(NULL != *prpc_handle);
        Assert(NULL != *ppszServerPrincName);
    }
    __finally {
        if (NULL != pszStringBinding) {
            RpcStringFreeW(&pszStringBinding);
        }

        if ((RPC_S_OK != status) || AbnormalTermination()) {
            if (NULL != *prpc_handle) {
                RpcBindingFree(prpc_handle);
                Assert(NULL == *prpc_handle)
            }

            if (NULL != *ppszServerPrincName) {
                free(*ppszServerPrincName);
                *ppszServerPrincName = NULL;
            }
        }

        if (NULL != Credentials) {
            DrspFreeCredentials(Credentials);
        }
    }

    // We should return a binding handle if and only if we we return success.
    if (RPC_S_OK == status) {
        Assert(NULL != *prpc_handle);
        Assert(NULL != *ppszServerPrincName);
    }
    else {
        Assert(NULL == *prpc_handle);
        Assert(NULL == *ppszServerPrincName);
    }

    return status;
}

VOID
RpcCancelAll()
{
    ULONG i;
    EnterCriticalSection(&gcsDrsRpcServerCtxList);
    __try {
	if (!gfDrsRpcServerCtxListInitialized) {
	   __leave;
	}

	while (!IsListEmpty(&gDrsRpcServerCtxList)) {
	    PLIST_ENTRY listEntry;
	    DRS_CONTEXT_INFO *pContextInfo = NULL;
	    ULONG rpcstatus = 0; 
	    ULONG ulCancelWait = 1000; //ms 

	    listEntry = RemoveHeadList(&gDrsRpcServerCtxList);
	    pContextInfo = CONTAINING_RECORD(listEntry,DRS_CONTEXT_INFO,ListEntry); 
	    if ((pContextInfo->phThread!=NULL) && (*(pContextInfo->phThread)!=INVALID_HANDLE_VALUE)) { 
		rpcstatus = RpcCancelThreadEx(*(pContextInfo->phThread), ulCancelWait);
	    }
	    else {
		Assert(!"Trying to cancel invalid thread!");
	    }
	}
    }
    __finally {
	LeaveCriticalSection(&gcsDrsRpcServerCtxList);
    }

}

BOOL
FBindSzDRS(
    IN      THSTATE *           pTHS,
    IN      LPWSTR              szServer,
    IN      LPWSTR              pszDomainName,  OPTIONAL
    IN      ULONG               ulFlags,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo,
    IN OUT  DWORD *             pdwStatus
    )
/*++

Routine Description:

    Retrieve a DRS context handle and extension set for the given server.

    Optionally searches the cache for a pre-existing handle.  Otherwise or
    if no appropriate entry is found in the cache, contacts the server for a
    new context handle.

    If a cache search is requested but none is found, and a new context
    handle is succesfully generated, this function adds the handle to the
    cache if a free entry is available.

Arguments:

    szServer (IN) - Server for which a context handle is desired.  This string
        buffer must be valid for the lifetime of the DRS_CONTEXT_INFO structure.

    pszDomainName (IN, OPTIONAL) - Domain name of the server; used to construct
        the SPN.  If the server name supplied is not a GUID-based DNS name and
        the pszDomainName is absent, one-way (not mutual) authentication will be
        performed.

    ulFlags (IN) - Zero or more of the following bits:
        FBINDSZDRS_NO_CACHED_HANDLES - Do not return cached context handles, and do
            not cache the fresh context handle returned from this function to
            be used by other threads.
        FBINDSZDRS_LOCK_HANDLE - Allows the use of cached handles which reduces the
            number of binds needed. But also ensures that this handle is exclusively
            owned by this thread till a DeReferenceHandle is called.

    ppContextInfo (IN/OUT) - Should hold NULL before the first call.  On
        successful return, hold a valid context handle and extension set for the
        given server (amongst other state info).

    pdwStatus (IN OUT) - Detailed error code indicating why function failed
        If the error of this function is "no more bindings to try", we leave
        a non-success value of this error alone
        There is an assumption that if we run out of bindings, there must have
        been a previous error.

Return Values:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL                fNeedsBind;
    ULONG               draErr;
    ULONG               rpcStatus;
    ULONG               ulRpcException;
    ULONG               i;
    BOOL                fSuccess = FALSE;
    RPC_BINDING_HANDLE  hRpc = NULL;
    DRS_HANDLE          hDrs = NULL;
    DRS_EXTENSIONS *    pextRemote = NULL;
    DWORD               cchServer;
    UUID *              puuidDsa;
    LPWSTR              pszServerPrincName = NULL;
    VOID *              pvAddr;
    ULONG               ul1, ul2;
    ULONG               bhflags=0;
    BOOL                fUseMutualAuthSpn = TRUE;
    BOOL                fImpersonate = FALSE;
    DRS_EXTENSIONS *    pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    Assert( pdwStatus );

    if (!gfIsDrsClientLibInitialized || eServiceShutdown) {
        // Either we've been stopped or we were never started.
        *pdwStatus = ERROR_DS_DRA_SHUTDOWN;
        return FALSE;
    }

    //
    // Get the correct binding handle cache flags
    //

    if (ulFlags & FBINDSZDRS_LOCK_HANDLE)
    {
        bhflags|=BHCACHE_FLAGS_LOCK_HANDLE;
    }

    if (NULL == *ppContextInfo) {
        // This is our first request for a context handle.
        *ppContextInfo = THAllocOrgEx(pTHS, sizeof(DRS_CONTEXT_INFO));

	if ((NULL == &(pTHS->hThread)) || (INVALID_HANDLE_VALUE == pTHS->hThread)) {
	  if (!DuplicateHandle(GetCurrentProcess(),
				  GetCurrentThread(),
				  GetCurrentProcess(),
				  &(pTHS->hThread),
				  0,
				  FALSE,
				  DUPLICATE_SAME_ACCESS)) {
	    return FALSE;
	  }
	} 
	(*ppContextInfo)->phThread = &(pTHS->hThread);

	EnterCriticalSection(&gcsDrsRpcServerCtxList);
	__try {
	    if (!gfDrsRpcServerCtxListInitialized) {
		InitializeListHead(&gDrsRpcServerCtxList);  
		Assert(0 == gcNumDrsRpcServerCtxListEntries);
		gfDrsRpcServerCtxListInitialized = TRUE;
	    }
	    InsertTailList(&gDrsRpcServerCtxList, &(*ppContextInfo)->ListEntry);
	    ++gcNumDrsRpcServerCtxListEntries;
	}
	__finally {
	    LeaveCriticalSection(&gcsDrsRpcServerCtxList);
	} 

        // Note that we don't copy the server name; we assume the string
        // we were given is valid for the lifetime of the structure.
        (*ppContextInfo)->pszServerName = szServer;

        if (!(ulFlags & FBINDSZDRS_NO_CACHED_HANDLES)
            && BHCacheGetDrsContext(pTHS,
                                    pextLocal,
                                    szServer,
                                    bhflags,
                                    &(*ppContextInfo)->hDrs,
                                    &(*ppContextInfo)->ext)) {
            // Found a context handle in the cache -- we're done!
            Assert(NULL != (*ppContextInfo)->hDrs);
            (*ppContextInfo)->ulFlags = ulFlags;
            (*ppContextInfo)->fIsHandleFromCache = TRUE;
            (*ppContextInfo)->fIsHandleInCache = TRUE;
            *pdwStatus = ERROR_SUCCESS; 
            return TRUE;
        }
    }
    else {
        // We've tried (and failed) to use a context handle already.
        Assert((*ppContextInfo)->pszServerName == szServer);
        Assert(NULL != (*ppContextInfo)->hDrs);

	if (*pdwStatus == RPC_S_CALL_CANCELLED) {
	    if ((*ppContextInfo)->fIsHandleInCache) {  
		// void the handle in cache (so nobody else uses it after
		// all current calls are through)
		BHCacheVoidServer(szServer);
	    } 

	    // leave the previous failure intact
	    return FALSE;
	}

        if (!(*ppContextInfo)->fIsHandleFromCache) {
            // Whatever RPC exception occurred did so while using a handle that
            // was not retrieved from the cache.  Fail the call.

            // Leave the previous failure status intact in *pdwStatus
            if (*pdwStatus == ERROR_SUCCESS) {
                Assert( !"A previous non-success rpc exception should have occurred" );
                *pdwStatus = RPC_S_NO_MORE_BINDINGS;
            }  
	    return FALSE;
        } 

	// We're going to try to acquire a new context handle, but before we do
	// we need to free the reference to the cached handle we already have. 

	BHCacheFreeContext(szServer, &(*ppContextInfo)->hDrs);
	RpcBindingFree(&(*ppContextInfo)->hDrs); 
	BHCacheVoidServer(szServer);

        // Reset state.
        (*ppContextInfo)->fIsHandleFromCache = FALSE;
        (*ppContextInfo)->fIsHandleInCache   = FALSE;
    }

    Assert(NULL != *ppContextInfo);
    Assert(NULL == (*ppContextInfo)->hDrs);
    Assert(!(*ppContextInfo)->fIsHandleFromCache);
    Assert(!(*ppContextInfo)->fIsHandleInCache);

    puuidDsa = (NULL == gAnchor.pDSADN) ? NULL : &gAnchor.pDSADN->Guid;

getbindingretry:

    if (!gfIsDrsClientLibInitialized || eServiceShutdown) {
        // Either we've been stopped or we were never started.
        *pdwStatus = ERROR_DS_DRA_SHUTDOWN;
        return FALSE;
    }

    draErr = DRSImpersonateInstallClient(&fImpersonate);
    if (ERROR_SUCCESS != draErr) {
        *pdwStatus = draErr;
        return FALSE;
    }

    // Attempt to create a binding handle, and, if successful, use it to acquire
    // a DRS context handle.
    _try {
	rpcStatus = DRSGetRpcBinding(pTHS,
				     szServer,
				     pszDomainName,
				     fUseMutualAuthSpn,
				     &hRpc,
				     &pszServerPrincName);
	if (RPC_S_OK == rpcStatus) {
	    // set the time to cancel this rpc call 
	    rpcStatus = RpcBindingSetOption(hRpc, RPC_C_OPT_CALL_TIMEOUT, gulDrsRpcBindTimeoutInMins*60*1000);
	    if (RPC_S_OK != rpcStatus) {
		DRA_EXCEPT(rpcStatus,0); 
	    }

	    if ( FBINDSZDRS_CRYPTO_BIND & ulFlags )
		{
		// Register the callback with RPC which will ultimately
		// set the SESSION_KEY in our thread state on return
		// from _IDL_DRSBind.
		InitRpcSessionEncryption(pTHS, ulFlags, NULL, hRpc);
	    }

	    __try {
		draErr = _IDL_DRSBind(hRpc,
				      puuidDsa,
				      pextLocal,
				      &pextRemote,
				      &hDrs);
		MAP_SECURITY_PACKAGE_ERROR( draErr );

		if ( !draErr && (FBINDSZDRS_CRYPTO_BIND & ulFlags) )
		    {
		    if ( !IS_DRS_EXT_SUPPORTED(pextRemote,
					       DRS_EXT_CRYPTO_BIND) ) {
			draErr = DRAERR_NotSupported;
		    } else {
			// Should have SESSION_KEY in thread state now.
			Assert(    pTHS->SessionKey.SessionKey
				   && pTHS->SessionKey.SessionKeyLength);
		    }
		}
	    } __except(GetExceptionData(GetExceptionInformation(),
					&rpcStatus, &pvAddr, &ul1, &ul2)) {
		  MAP_SECURITY_PACKAGE_ERROR( rpcStatus );
		  Assert( rpcStatus != RPC_S_OK );
	    } // end try/except

	// Error code used to be here.

	} // if (RPC_S_OK)

    } __finally {
	if (fImpersonate) {
	    RevertToSelf();
	}
    }

    // Check for linked value mode compatibility
    if ( (rpcStatus == RPC_S_OK) &&
	 (draErr == ERROR_SUCCESS) ) {

        if (pTHS->fLinkedValueReplication) {
            // If we are in LVR mode

            // If remote does not support, reject
            if ( !IS_LINKED_VALUE_REPLICATION_SUPPORTED(pextRemote) ) {
                draErr = ERROR_DS_NOT_SUPPORTED;
            }
        } else {
            // We are not in LVR mode

            // Remote supports it, upgrade
            if ( IS_LINKED_VALUE_REPLICATION_SUPPORTED(pextRemote) ) {
                DsaEnableLinkedValueReplication( pTHS, TRUE );
            }
        }
    }

    // Service Principal Name cannot be found on the target
    if ( (rpcStatus == ERROR_WRONG_TARGET_NAME) && (fUseMutualAuthSpn) ) {
        BOOL fFallback = 0;
        GetConfigParam(DRA_SPN_FALLBACK, &fFallback, sizeof(BOOL));
        if (fFallback) {
            fUseMutualAuthSpn = FALSE;
            if (NULL != hRpc) {
                RpcBindingFree(&hRpc);
            }
            if (NULL != pszServerPrincName) {
                free(pszServerPrincName);
		pszServerPrincName = NULL;
            }
            goto getbindingretry;
        } else {
            DPRINT3( 0, "Got error %d binding to %ws using spn %ws;\n"
                     "target server does not have or support mutual auth spn;\n"
                     "Check if server and domain specified correctly;\n"
                     "Verify that SPN is present on source or call Chandans;\n"
                     "set registry key to allow falling back to one way authentication.\n",
                     rpcStatus, szServer, pszServerPrincName );
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_SPN_WRONG_TARGET_NAME,
                     szInsertWC(szServer),
                     szInsertWC(pszServerPrincName),
                     NULL );
        }
    }

    if (RPC_S_OK != rpcStatus) {
        // This is a first-leg error
        *pdwStatus = rpcStatus;

        // Failed to acquire new DRS context handle.
        if (DsaIsInstalling()) {
            // Log install failure.
            LogEvent(DS_EVENT_CAT_SETUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_RPC_CONNECTION_FAILED,
                     szInsertWC(szServer),
                     szInsertUL(rpcStatus),
                     NULL);
        }
        else if (RPC_S_CALL_CANCELLED == rpcStatus) {
            // Log non-install RPC cancellation.
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_DISPATCHER_CANCELED,
                     szInsertHex(GetCurrentThreadId()),
                     NULL,
                     NULL);
        }
        else {
            // Log other non-install failure.
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GET_RPC_HANDLE_FAILURE,
                     szInsertWC(szServer),
                     szInsertUL(rpcStatus),
                     NULL);
        }
    }
    else if (DRAERR_Success == draErr) {
        // Acquired new DRS context handle.
        Assert(NULL != hDrs);
 
        if (!(ulFlags & FBINDSZDRS_NO_CACHED_HANDLES)
            && (NULL != pszServerPrincName)
            && IS_DOMAIN_QUALIFIED_SPN(pszServerPrincName)) {
            // Cache our context handle.
            
            // Note that we do not cache non-domain-qualified SPNs -- i.e.,
            // those without @domain.com tacked on the end.  This is to protect
            // against having code paths that require DQSPNs (like GC lookup,
            // to avoid infinite recursion) from re-using contexts based on
            // NDQSPNs (which may require a re-bind under the covers using the
            // NDQSPN -- e.g., if the Kerberos ticket has expired).
            //
            // In the ideal world we would cache (and look up) contexts based on
            // server name / domain name / SPN triples, which would guarantee
            // the right behavior yet allow caching of any SPN form.  This would
            // be a performance hit today, though, as we have not yet calculated
            // the SPN when we perform the context cache lookup and deriving the
            // SPN is potentially expensive (requiring a transaction and
            // several database reads).

            i = UlBHCacheHash(szServer);
            EnterCriticalSection(&csBHCache);
            __try {
                VALIDATE_BH_ENTRY(i);
    
                cchServer = 1 + wcslen(szServer);
    
                // Update cache if caching is desired and entry is available.
                if ((NULL == rgBHCache[i].pszServer)
                    && (NULL != (rgBHCache[i].pszServer
                                 = malloc(cchServer * sizeof(WCHAR)))) ) {
                    rgBHCache[i].cchServer = cchServer;
                    memcpy(rgBHCache[i].pszServer,
                           szServer,
                           rgBHCache[i].cchServer * sizeof(WCHAR));
                    CopyExtensions(pextRemote, &rgBHCache[i].extRemote);
                    CopyExtensions(pextLocal, &rgBHCache[i].extLocal);
                    rgBHCache[i].hDrs = hDrs;
                    rgBHCache[i].pszServerPrincName = pszServerPrincName;
                    // One ref to keep the cache entry alive.
                    // One ref for the current caller.
                    rgBHCache[i].cRefs = 2; 
		    rgBHCache[i].fDontUse = FALSE;
                    // Lock the handle if required
                    if (ulFlags & FBINDSZDRS_LOCK_HANDLE)
                    {
                        rgBHCache[i].fLocked = TRUE;
                    }
                    (*ppContextInfo)->fIsHandleInCache = TRUE;
                }
            }
            __finally {
                VALIDATE_BH_ENTRY(i);
                LeaveCriticalSection(&csBHCache);
            }
        } 

	// Update caller.
	(*ppContextInfo)->hDrs = hDrs; 
	(*ppContextInfo)->ulFlags = ulFlags;
	CopyExtensions(pextRemote, &(*ppContextInfo)->ext);
	if (NULL != pextRemote) {
	    MIDL_user_free(pextRemote);
	}

	fSuccess = TRUE;
	*pdwStatus = ERROR_SUCCESS;
    } else {
	// This is a second-leg error
	// This is a rare occurance since IDL_BIND does not ususally fail
	*pdwStatus = draErr; 
	if (hDrs) { 
	    DRSInsertFreeHandleQueue(szServer, hDrs);
	    hDrs = NULL;
	}
	if (pextRemote!=NULL) {
	    MIDL_user_free(pextRemote);
	}
	Assert( !fSuccess );
    }


    if ((!(*ppContextInfo)->fIsHandleInCache) && (pszServerPrincName!=NULL)) {
	// free the principle name since we are not caching it
	free(pszServerPrincName);
	pszServerPrincName=NULL;
    }

    if (NULL != hRpc) {
	// Free the RPC binding handle whether we successfully retrieved a
	// context handle or not -- it's no longer needed.
	RpcBindingFree(&hRpc);
    }

    Assert(NULL == hRpc);
    Assert(fSuccess || (NULL == hDrs));
    Assert( (*ppContextInfo)->fIsHandleInCache || (pszServerPrincName==NULL) );

    return(fSuccess);
}

void
DRSExpireServerCtxHandles(
    void
    )
/*
 Routine Description:
    Scan the context handle cache and expire any handles that haven't been used
    recently.  This is particularly important for the intersite demand-dial case
    since closing the handle prevents RPC keep alives from being sent, which in
    turn allows the dial-up line to go idle and be automcatically disconnected.
*/
{
    DWORD     i;
    GUID *    pLocalSiteGuid;
    GUID *    pRemoteSiteGuid;
    BOOL      fSameSite;
    DWORD     cMaxTicksSinceLastUse;
    DWORD     cTicksDiff;
    DWORD     cTickNow = GetTickCount();

    pLocalSiteGuid = gAnchor.pSiteDN ? &gAnchor.pSiteDN->Guid : NULL;

    EnterCriticalSection(&csBHCache);
    __try {
	for (i = 0; i < BHCacheSize; i++) {
	    VALIDATE_BH_ENTRY(i);

	    if ((NULL == rgBHCache[i].pszServer)    // empty
		|| rgBHCache[i].fDontUse            // already expired
		|| (1 != rgBHCache[i].cRefs)) {     // in use
		continue;
	    }

            pRemoteSiteGuid = SITE_GUID_FROM_DRS_EXT(&rgBHCache[i].extRemote);

		    // Note that we err on the side of "not same site" if
		// w	e can't tell for sure.
	    fSameSite = (NULL != pLocalSiteGuid)
	    && (NULL != pRemoteSiteGuid)
	    && (0 == memcmp(pLocalSiteGuid,
			    pRemoteSiteGuid,
			    sizeof(GUID)));

	    cMaxTicksSinceLastUse = fSameSite ? gulDrsCtxHandleLifetimeIntrasite
		: gulDrsCtxHandleLifetimeIntersite;
	    cMaxTicksSinceLastUse *= 1000; // secs to msecs

	    cTicksDiff = cTickNow - rgBHCache[i].cTickLastUsed;

	    if ((cMaxTicksSinceLastUse > 0)
		&& (cTicksDiff >= cMaxTicksSinceLastUse)) {
		// Stick a fork in it -- it's done.
		DPRINT3(2, "Expiring DRS context handle to %ls after %d min, %d sec.\n",
			rgBHCache[i].pszServer,
			cTicksDiff / (60 * 1000),
			(cTicksDiff / 1000) % 60);
		BHCacheDecRef(&rgBHCache[i]);
		Assert(NULL == rgBHCache[i].pszServer);
	    }
	}
    }
    __finally {
	LeaveCriticalSection(&csBHCache);
    }
}

void
DRSExpireContextHandles(
    IN  VOID *  pvArg,
    OUT VOID ** ppvNextArg,
    OUT DWORD * pcSecsUntilNextRun
    )
/*++

Routine Description:

   
Arguments/Return Values:

    Typical task queue function signature.

--*/
{
    __try {
	    // call client and server expire
	DRSExpireServerCtxHandles();
	DRSExpireClientCtxHandles();
    }
    __finally{
	*pcSecsUntilNextRun = gulDrsCtxHandleExpiryCheckInterval;
    }
}

void
DRSFreeContextInfo(
    IN      THSTATE           * pTHS,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo
    )
/*++

Routine Description:

    Free context handle data returned by a prior call to FBindSzDRS().

Arguments:

    ppContextInfo (IN/OUT) - The context handle data to free.

Return Values:

    None.

--*/
{
    if (NULL != *ppContextInfo) {
	EnterCriticalSection(&gcsDrsRpcServerCtxList);
	__try {
	    RemoveEntryList(&(*ppContextInfo)->ListEntry);
	    gcNumDrsRpcServerCtxListEntries--;
	}
	__finally {
	    LeaveCriticalSection(&gcsDrsRpcServerCtxList);
	}

        if ((*ppContextInfo)->fIsHandleInCache) {
            // Context handle is in the cache; decrement its refcount.
            BHCacheFreeContext((*ppContextInfo)->pszServerName,
                               &(*ppContextInfo)->hDrs);
        
	    // free the copy of the handle
	    RpcBindingFree(&(*ppContextInfo)->hDrs); 
        }
        else { 
            // Context handle is not cached; free it outright.
	    DRSInsertFreeHandleQueue((*ppContextInfo)->pszServerName,
                                 (*ppContextInfo)->hDrs);
        } 
        THFreeOrg(pTHS, *ppContextInfo);
        *ppContextInfo = NULL;
    }
}


BOOL
drsIsCallComplete(
    IN  RPC_STATUS          rpcStatus,
    IN  ULONG               ulError,
    IN  DRS_CONTEXT_INFO *  pContextInfo
    )

/*++

Routine Description:

    Determine whether the result of an RPC call merits a retry with a fresh
    binding handle.

Arguments:

    rpcStatus - Status from RPC run-time, where applicable
    ulError - Status returned from server manager routine
    pContextInfo - Client-side context

Return Value:

    BOOL - TRUE - call should NOT be retried
           FALSE - call should be retried

--*/

{
    if (rpcStatus) {
        // RPC call was not completed.  If the last attempt was using a cached
        // handle, try again with a fresh handle, since the failure may have
        // been due to the cached handle no longer being valid.
        return !(pContextInfo->fIsHandleFromCache);
    }
    else if ((ERROR_ACCESS_DENIED == ulError)
             || (ERROR_DS_DRA_ACCESS_DENIED == ulError)
             || (ERROR_REVISION_MISMATCH == ulError)) {
        // RPC call completed but the server side denied us access.
        //
        // In this scenario, the authentication was successful -- i.e., the
        // IDL_DRSBind call succeeded, ergo the machine account for the local
        // DC (or whatever account was used for authentication) is present on
        // the remote DC.  However, the token derived for this account by the
        // remote DC from the Kerberos ticket does not have sufficient
        // privileges to perfrom the requested operation, possibly because the
        // Kerberos ticket does not yet include the latest group memberships
        // for this account.
        //
        // If the previous call was using a cached RPC binding handle, try a
        // new one to encourage a new ticket to be used, which has a slightly
        // better chance of having the correct current group memberships for
        // the account we're using.
        //
        // [wlees 12 Apr 00] Could also be that server has changed extensions
        // since we last bound.
        return !(pContextInfo->fIsHandleFromCache);
    }
    else {
        // RPC call completed with success or a non-retriable error.
        return TRUE;
    }
} /* drsIsCallComplete */

BOOL
DRSIsRegisteredAsyncRpcState(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Scans the list of registered async state structures to determine if the
    given async state is present.

Arguments:

    pAsyncState (IN) - Async RPC state to look for.

Return Values:

    TRUE - pAsyncState is registered.
    FALSE - pAsyncState is not registered.

--*/
{
    LIST_ENTRY * pListEntry;
    LIST_ENTRY * pTargetListEntry = &pAsyncState->ListEntry;
    BOOL fFound = FALSE;

    // Note that pAsyncState must not be dereferenced -- assume it can be a
    // random pointer.
    RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
    __try {
        for (pListEntry = gDrsAsyncRpcList.Flink;
             pListEntry != &gDrsAsyncRpcList;
             pListEntry = pListEntry->Flink) {
            if (pListEntry == pTargetListEntry) {
                fFound = TRUE;
                break;
            }
        }
    } __finally {
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    return fFound;
}

void
drsZeroAsyncOutParameters(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Zero-fill OUT parameters associated with the given async RPC call.  This
    forces RPC to allocate new buffers for returned data, rather than
    attempting to re-use previous buffers (which we have likely invalidated
    via TH_free_to_mark or never initialized in the first place).

Arguments:

    pAsyncState (IN) - Async RPC call info.

Return Values:

    None.

--*/
{
    switch (pAsyncState->CallType) {
    case DRS_CALL_GET_CHANGES:
        memset(pAsyncState->CallArgs.GetChg.pmsgOut,
               0,
               sizeof(*pAsyncState->CallArgs.GetChg.pmsgOut));
        break;

    default:
        Assert(!"Unknown CallType!");
        DRA_EXCEPT(DRAERR_InternalError, pAsyncState->CallType);
    }
}

void
drsCancelAsyncRpc(
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Cancel an async RPC call that's currently in progress.

Arguments:

    pAsyncState (IN/OUT) - Async RPC call to cancel.

Return Values:

    None.

--*/
{
    DWORD waitStatus;
    DWORD err;

    Assert(pAsyncState->fIsCallInProgress);

    __try {
        // Tell RPC to abort the call.
        err = RpcAsyncCancelCall(&pAsyncState->RpcState, TRUE);
        Assert(RPC_S_OK == err);

        // We never seed RPC with pre-allocated buffers for out parameters.
        drsZeroAsyncOutParameters(pAsyncState);

        // Wait for aborted call to terminate.
        waitStatus = WaitForSingleObject(pAsyncState->RpcState.u.hEvent,
                                         INFINITE);
        if (WAIT_OBJECT_0 != waitStatus) {
            err = GetLastError();
            LogUnhandledError(waitStatus);
            LogUnhandledError(err);
            DPRINT2(0, "Wait for async RPC completion failed (%d, GLE %d)",
                    waitStatus, err);
            Assert(!"Wait for async RPC completion failed -- contact JeffParh");
        }

        // Call completed.  Retrieve exit code and out parameters.
        // Note that this is required even though we cancelled the call.
        RpcAsyncCompleteCall(&pAsyncState->RpcState, &err);
    } __except(1) {
        err = GetExceptionCode();
        DPRINT1(0, "Exception 0x%x caught in drsCancelAsyncRpc!\n", err);
        Assert(!"Exception caught in drsCancelAsyncRpc -- contact JeffParh.");
    }

    pAsyncState->fIsCallInProgress = FALSE;
}

void
DRSDestroyAsyncRpcState(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Free all the resources associated with a DRS_ASYNC_RPC_STATE structure.

    This function is designed to gracefully handle being called on a empty/freed
    DRS_ASYNC_RPC_STATE structures, so no need to worry too much about e.g.
    calling DRSDestroyAsyncRpcState twice.  (Just make sure you call it at least
    once!)

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Async RPC state to destroy.

Return Values:

    None.

--*/
{
    RPC_STATUS  rpcStatus;
    SESSION_KEY SessionKeyAtStart;

    // Save session key so we can restore it when we're done.
    PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtStart);

    if (pAsyncState->fIsCallInProgress) {
        drsCancelAsyncRpc(pAsyncState);
        Assert(!pAsyncState->fIsCallInProgress);
    }

    if (NULL != pAsyncState->RpcState.u.hEvent) {
        CloseHandle(pAsyncState->RpcState.u.hEvent);
        pAsyncState->RpcState.u.hEvent = NULL;
    }

    if (NULL != pAsyncState->pContextInfo) {
        DRSFreeContextInfo(pTHS, &pAsyncState->pContextInfo);
        Assert(NULL == pAsyncState->pContextInfo);
    }

    if (NULL != pAsyncState->SessionKey.SessionKey) {
        Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
        PEKDestroySessionKeySavedByDiffThread(&pAsyncState->SessionKey);
    }

    RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
    __try {
        if (NULL != pAsyncState->ListEntry.Flink) {
            Assert(NULL != pAsyncState->ListEntry.Blink);
            RemoveEntryList(&pAsyncState->ListEntry);
            pAsyncState->ListEntry.Flink = NULL;
            pAsyncState->ListEntry.Blink = NULL;
        }
    } __finally {
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    // Erase the structure.
    memset(pAsyncState, 0, sizeof(*pAsyncState));

    DPRINT1(1, "Destroyed async RPC state %p.\n", pAsyncState);

    // Exit with the same session key we entered with.
    PEKRestoreSessionKeySavedByMyThread(pTHS, &SessionKeyAtStart);
}

void
drsPrepareAsyncRpcState(
    IN  THSTATE *               pTHS,
    IN  LPWSTR                  pszServerName,
    IN  LPWSTR                  pszDomainName   OPTIONAL,
    IN  DRS_CALL_TYPE           CallType,
    OUT DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Initializes async RPC state for a forthcoming async RPC call.

    This routine may be invoked multiple times on a given async state structure
    without an intervening DRSDestroyAsyncRpcState.  Doing so cancels the async
    RPC call in progress (if any) and prepares for a new async RPC call.

    The caller must eventually call DRSDestroyAsyncRpcState to free the
    resources associated with this structure.

Arguments:

    pTHS (IN)

    pszServerName (IN) - Name of the RPC server (e.g., replication source for a
        GetChanges call).  The buffer for this string must remain valid until
        DRSDestroyAsyncRpcState is invoked -- i.e., it is saved by reference,
        not copied.

    pszDomainName (IN, OPTIONAL) - DNS name of the domain to which pszServerName
        belongs.  Should be NULL if pszServerName is a GUID-based DNS name, may
        be NULL or non-NULL for other names.  The buffer for this string must
        remain valid until DRSDestroyAsyncRpcState is invoked -- i.e., it is
        saved by reference, not copied.

    CallType (IN) - Identifies the forthcoming async RPC call (e.g.,
        GetChanges).

    pAsyncState (OUT) - Async RPC state to prepare.

Return Values:

    None.  Throws exception on error.

--*/
{
    ULONG   ret;
    HANDLE  hEvent;
    BOOL    fResetEvent = FALSE;

    Assert(DRS_CALL_NONE != CallType);

    if (0 == pAsyncState->timeInitialized) {
        // First time initializing this DRS_ASYNC_RPC_STATE.  The structure
        // should be zeroed out, with the possible exception of pContextInfo.
        Assert(0 == pAsyncState->dwCallerTID);
        Assert(0 == pAsyncState->CallType);
        Assert(NULL == pAsyncState->CallArgs.pszServerName);
        Assert(NULL == pAsyncState->CallArgs.pszDomainName);
        Assert(NULL == pAsyncState->ListEntry.Flink);
        Assert(NULL == pAsyncState->ListEntry.Blink);
        Assert(NULL == pAsyncState->RpcState.u.hEvent);
        Assert(!pAsyncState->fIsCallInProgress);

        DPRINT1(1, "Preparing new async RPC state %p.\n", pAsyncState);
    }
    else {
        // Not the first time initializing this DRS_ASYNC_RPC_STATE.
        Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
        Assert(CallType == pAsyncState->CallType);
        Assert(pszServerName == pAsyncState->CallArgs.pszServerName);
        Assert(pszDomainName == pAsyncState->CallArgs.pszDomainName);
        Assert(NULL != pAsyncState->ListEntry.Flink);
        Assert(NULL != pAsyncState->ListEntry.Blink);
        Assert(NULL != pAsyncState->RpcState.u.hEvent);
        Assert(!pAsyncState->fIsCallInProgress);

        if (NULL != pAsyncState->SessionKey.SessionKey) {
            Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
            PEKDestroySessionKeySavedByDiffThread(&pAsyncState->SessionKey);
        }

        DPRINT1(1, "Re-preparing existing async RPC state %p.\n", pAsyncState);
    }

    __try {
        hEvent = pAsyncState->RpcState.u.hEvent;
        if (NULL == hEvent) {
            // Create event for RPC to signal when the response has been
            // received.
            hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == hEvent) {
                ret = GetLastError();
                DRA_EXCEPT(ret, 0);
            }
        }
        else {
            // Already have an event -- make sure it's reset later.
            // Can't reset now, as e.g. cancelling a call in progress may set
            // the event.
            fResetEvent = TRUE;
        }

        // Init RPC portion.
        if (pAsyncState->fIsCallInProgress) {
            drsCancelAsyncRpc(pAsyncState);
            Assert(!pAsyncState->fIsCallInProgress);
        }
        ret = RpcAsyncInitializeHandle(&pAsyncState->RpcState,
                                       sizeof(RPC_ASYNC_STATE));
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        if (fResetEvent && !ResetEvent(hEvent)) {
            ret = GetLastError();
            DRA_EXCEPT(ret, 0);
        }

        pAsyncState->RpcState.NotificationType = RpcNotificationTypeEvent;
        pAsyncState->RpcState.u.hEvent = hEvent;
        hEvent = NULL;
    }
    __finally {
        if (AbnormalTermination()) {
            // Encountered exception while trying to initialize -- tear down
            // whatever portion we did manage to init.
            DRSDestroyAsyncRpcState(pTHS, pAsyncState);

            if (NULL != hEvent) {
                CloseHandle(hEvent);
            }
        }
    }

    if (0 == pAsyncState->timeInitialized) {
        // First time initializing this DRS_ASYNC_RPC_STATE.
        pAsyncState->timeInitialized = GetSecondsSince1601();
        pAsyncState->dwCallerTID = GetCurrentThreadId();
        pAsyncState->CallType = CallType;
        pAsyncState->CallArgs.pszServerName = pszServerName;
        pAsyncState->CallArgs.pszDomainName = pszDomainName;

        // Save async state on global linked list.
        RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
        InsertTailList(&gDrsAsyncRpcList, &pAsyncState->ListEntry);
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    Assert(!pAsyncState->fIsCallInProgress);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);
    Assert(RpcNotificationTypeEvent == pAsyncState->RpcState.NotificationType);
    Assert(0 == pAsyncState->SessionKey.SessionKeyLength);
    Assert(NULL == pAsyncState->SessionKey.SessionKey);
    Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
    Assert(pszServerName == pAsyncState->CallArgs.pszServerName);
    Assert(pszDomainName == pAsyncState->CallArgs.pszDomainName);
    Assert(NULL != pAsyncState->ListEntry.Flink);
    Assert(NULL != pAsyncState->ListEntry.Blink);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);

    // Assert(IsListEmpty(&gDrsAsyncRpcList)) on shutdown?
}

ULONG
drsWaitForAsyncRpc(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState,
    OUT     ULONG *                 pRet
    )
/*++

Routine Description:

    Waits for completion of a prior, outstanding async RPC call.

    The async RPC must have been posted by this same thread -- this is required
    by (RPC's) RpcAsyncCancelCall.

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Async RPC state associated with oustanding async RPC
        call.

    pRet (OUT) - When this function returns, either there was no RPC error
        (indicating our function was invoked on the remote DSA), or there was
        an RPC error (in which case our function may or may not have executed on
        the remote DSA).  In the former case, this output parameter holds the
        return code of the server-side function we invoked on the remote DSA.
        In the latter case, this output parameter holds the RPC error code.

Return Values:

    0 or RPC error.  If the server-side function on the remote DSA was executed
    and the results returned to the local DSA, the return value is 0.  If there
    was any sort of error in reaching the remote DSA or transferring the data,
    the return value is non-0.

    Note that a return code of 0 *DOES NOT* indicate that the function we
    invoked on the remote DSA returned 0 -- that information is held in *pRet.
    The return code of drsWaitForAsyncRpc solely indicates whether there was
    an RPC communications error.

--*/
{
#if DBG
    static DWORD s_cNumTicksWaitedForReply = 0;
    static DWORD s_cNumReplies = 0;
    DWORD       tickStart;
    DWORD       cNumTicks;
#endif

    static struct {
        DRS_CALL_TYPE   CallType;
        DWORD           dwMsgID;
        ULONG *         pcNumMinutesUntilRpcTimeout;
    } rgCallTypeTable[] = {
        {DRS_CALL_NONE,        0,                      NULL},   // placeholder
        {DRS_CALL_GET_CHANGES, DIRLOG_RPC_CALL_GETCHG, &gulDrsRpcReplicationTimeoutInMins},
    };

    RPC_STATUS  rpcStatus;
    DWORD       waitStatus;
    ULONG       ret = 0;
    DWORD       cNumMSecToTimeout;
    HANDLE      rghWaitHandles[2];

    Assert(pAsyncState->fIsCallInProgress);
    Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
    Assert(RpcNotificationTypeEvent == pAsyncState->RpcState.NotificationType);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);

    // Sanity check CallType argument / table.
    Assert(DRS_CALL_NONE != pAsyncState->CallType);
    Assert(pAsyncState->CallType < DRS_CALL_MAX);
    Assert(pAsyncState->CallType < ARRAY_SIZE(rgCallTypeTable));
    Assert(pAsyncState->CallType
           == rgCallTypeTable[pAsyncState->CallType].CallType);

    __try {
        // We never seed RPC with pre-allocated buffers for out parameters.
        drsZeroAsyncOutParameters(pAsyncState);

        DPRINT1(1, "Waiting for completion of RPC call with state %p.\n", pAsyncState);
#if DBG
        tickStart = GetTickCount();
#endif
        // Asynchronous call has been initiated.  Wait for it to complete.
        cNumMSecToTimeout
            = *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout
              * 60 * 1000;

        rghWaitHandles[0] = hServDoneEvent; // shutdown
        rghWaitHandles[1] = pAsyncState->RpcState.u.hEvent; // RPC completed

        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rghWaitHandles),
                                            rghWaitHandles,
                                            FALSE,
                                            cNumMSecToTimeout);
#if DBG
        cNumTicks = GetTickCount() - tickStart;
        s_cNumTicksWaitedForReply += cNumTicks;
        s_cNumReplies++;

        DPRINT3(1, "Async RPC call %p terminated; waited %d msec (%d msec avg).\n",
                pAsyncState,
                cNumTicks,
                s_cNumTicksWaitedForReply / s_cNumReplies);
#endif

        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // DS is shutting down.
            DPRINT1(0, "Aborting async RPC call to %ls due to DS shutdown.\n",
                    pAsyncState->CallArgs.pszServerName);

            drsCancelAsyncRpc(pAsyncState);
            rpcStatus = ERROR_DS_SHUTTING_DOWN;
            break;

        case WAIT_OBJECT_0 + 1:
            // Call completed.  Retrieve exit code and out parameters.
            rpcStatus = RpcAsyncCompleteCall(&pAsyncState->RpcState, &ret);
            pAsyncState->fIsCallInProgress = FALSE;
            break;

        case WAIT_TIMEOUT:
            // RPC call timed out.
            DPRINT2(0, "Async RPC call to %ls timed out after %d minutes!\n",
                    pAsyncState->CallArgs.pszServerName,
                    *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout);

            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_DISPATCHER_VILLIAN,
                     szInsertWC(pAsyncState->CallArgs.pszServerName),
                     szInsertHex(pAsyncState->dwCallerTID),
                     szInsertDsMsg(rgCallTypeTable[pAsyncState->CallType].dwMsgID));

            drsCancelAsyncRpc(pAsyncState);
            rpcStatus = RPC_S_CALL_CANCELLED;
            break;

        case WAIT_ABANDONED_0:
        case WAIT_ABANDONED_0 + 1:
        default:
            // An unexpected error occurred.
            ret = GetLastError();
            LogUnhandledError(waitStatus);
            LogUnhandledError(ret);
            DPRINT2(0, "Wait for async RPC completion failed (%d, GLE %d)",
                    waitStatus, ret);
            Assert(!"Wait for async RPC completion failed -- contact JeffParh");

            drsCancelAsyncRpc(pAsyncState);
            rpcStatus = ERROR_DS_INTERNAL_FAILURE;
            break;
        }

        Assert(!pAsyncState->fIsCallInProgress);

        if (rpcStatus) {
            DRA_EXCEPT(rpcStatus, 0);
        }

        if (ret) {
            // RPC call succeeded, but the server-side function returned an
            // error.
            __leave;
        }

        // Update THSTATE so pek code can match destination's capabilities.
        DraSetRemoteDsaExtensionsOnThreadState(pTHS,
                                               &pAsyncState->pContextInfo->ext);

        // Restore session key associated with this RPC call.
        Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
        Assert(NULL != pAsyncState->SessionKey.SessionKey);
        PEKRestoreSessionKeySavedByDiffThread(pTHS, &pAsyncState->SessionKey);
    }
    __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                          pAsyncState->pContextInfo->pszServerName,
                                          pAsyncState->pContextInfo,
                                          &rpcStatus)) {
        ret = rpcStatus;
    }

    MAP_SECURITY_PACKAGE_ERROR(ret);

    *pRet = ret;

    DPRINT2(1, "Async RPC call %p returned status %d.\n", pAsyncState, ret);

    // If an RPC failure occurred, *pRet must indicate an error.
    Assert(!rpcStatus || *pRet);

    return rpcStatus;
}

ULONG
I_DRSReplicaSync(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    DSNAME *    pNC,
    LPWSTR      pszFromServerName,
    UUID *      pInvocationId,
    ULONG       ulOptions
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPSYNC     msgSync;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgSync, 0, sizeof(msgSync));

    msgSync.V1.pNC       = pNC;
    msgSync.V1.ulOptions = ulOptions;

    if (NULL != pszFromServerName) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszFromServerName);
        msgSync.V1.pszDsaSrc = pmtx->mtx_name;
    }

    if (NULL != pInvocationId) {
        msgSync.V1.uuidDsaSrc = *pInvocationId;
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {  
	    DRSSetRpcCancelTime(gulDrsRpcReplicationTimeoutInMins,
				&pContextInfo->hDrs
				);  
	    ret = _IDL_DRSReplicaSync(pContextInfo->hDrs, 1, &msgSync); 
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	} 
	 __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}

ULONG
I_DRSGetNCChanges(
    IN  THSTATE *                     pTHS,
    IN  LPWSTR                        pszServerName,
    IN  LPWSTR                        pszServerDnsDomainName,     OPTIONAL
    IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgInNative,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOutNative,
    OUT PBYTE                         pSchemaInfo,
    OUT DRS_ASYNC_RPC_STATE *         pAsyncState                 OPTIONAL
    )
/*++

Routine Description:

    Request replication changes from a source server over RPC.

Arguments:

    pTHS (IN)

    pszServerName (IN) - DNS name (GUID-based or other) of the source server.

    pszServerDnsDomainName (IN, OPTIONAL) - DNS name of the domain of the
        source server.  Used to optimize SPN resolution by Kerberos when the
        pszServerName parameter is not the GUID-based DNS name.

    pmsgInNative (IN) - The replication request.

    pmsgOut (OUT) - Holds the replication response after the source server
        has completed processing the request.

    pSchemaInfo (OUT) - Holds the schema signature of the source server after
        the source server has completed processing the request.

    pAsyncState (OUT, OPTIONAL) - If NULL, the traditional GetNCChanges
        behavior is observed -- i.e., if this function returns successfully,
        pmsgOutV1 holds the source server's response and pSchemaInfo holds the
        source server's schema signature.

        If non-NULL, this function returns immediately after posting the
        replication request to the source server -- i.e., it does not wait for
        the server to process the request and send the response.  Rather, the
        caller can perform other operations in the interim and later come back
        to retrieve the response via I_DRSGetNCChangesComplete, at which point
        pmsgOutV1 and pSchemaInfo will hold the returned data.  (Alternatively
        the caller can cancel via DRSDestroyAsyncRpcState.)  Note that the
        buffers pmsgOutV1, pSchemaInfo, and pAsyncState must remain valid until
        the caller invokes I_DRSGetNCChangesComplete or DRSDestroyAsyncRpcState.

        Note that in the non-NULL case the MIDL_user_allocate calls to allocate
        buffers for the unmarshalled data are not invoked until
        I_DRSGetNCChangesComplete is called -- these MIDL_user_allocates are
        *not* invoked by other threads asynchronously.  This is an important
        detail here, given the DS thread-based allocation model and
        ReplicateNC()'s alternating of heaps for GetChanges responses (i.e.,
        the TH_mark, TH_free_to_mark functionality).

        If non-NULL and this function returns successfully the caller MUST
        later call I_DRSGetNCChangesComplete or DRSDestroyAsyncRpcState.
        (Either will do but both are okay, too, as long as
        DRSDestroyAsyncRpcState is called last.)

Return Values:

    0 or Win32 error code.

--*/
{
    ULONG                   ret = ERROR_SUCCESS;
    BOOL                    fCallCompleted = FALSE;
    DRS_MSG_GETCHGREPLY *   pmsgOut;
    DRS_MSG_GETCHGREQ       MsgIn;
    ULONG                   BindFlags=0;
    DWORD                   dwInVersion;
    BOOL                    fWaitForCompletion = (NULL == pAsyncState);
    SESSION_KEY             SessionKeyAtStart;
    BOOL                    fConstructedMsgIn = FALSE;

    // Allocate async RPC state if it was not supplied by the caller.
    if (NULL == pAsyncState) {
        pAsyncState = alloca(sizeof(*pAsyncState));
        memset(pAsyncState, 0, sizeof(*pAsyncState));
    }

    UpToDateVec_Validate(pmsgInNative->pUpToDateVecDest);
    UsnVec_Validate(&pmsgInNative->usnvecFrom);

    // Cast the V1 pointer as a VX pointer.  We abuse the fact that the V1
    // struct is the biggest struct in the VX union to avoid putting the VX on
    // the stack and having to perform the copy (or changing the signature of
    // this function).
    Assert(sizeof(DRS_MSG_GETCHGREPLY_NATIVE) == sizeof(DRS_MSG_GETCHGREPLY));
    pmsgOut = (DRS_MSG_GETCHGREPLY *) pmsgOutNative;

    // We need to prevent multi threaded use of the same handle in order to use
    // the security callback feature of RPC to retrieve the session key.
    BindFlags |= FBINDSZDRS_LOCK_HANDLE;

    if (!fWaitForCompletion) {
        // We're not getting the reply packet on this call, therefore we should
        // return from this call with the session key we were called with.
        PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtStart);
    }

    __try {
        while (!fCallCompleted
               && FBindSzDRS(pTHS, pszServerName, pszServerDnsDomainName,
                             BindFlags, &pAsyncState->pContextInfo, &ret)) {
            __try {
                if (!fConstructedMsgIn) {
                    // First pass -- construct message.  We can't do this before
                    // we FBindSzDRS() because we need bind-time extensions info
                    // from the source DC to determine which message version to
                    // send.

                    if ((0 == pmsgInNative->cMaxObjects)
                        || (0 == pmsgInNative->cMaxBytes)) {
                        // Use appropriate default packet size based on whether
                        // the source is in the same site or in a different site.
                        if (IS_REMOTE_DSA_IN_SITE(&pAsyncState->pContextInfo->ext,
                                                  gAnchor.pSiteDN)) {
                            // Same site.  (Note that we err on the side of
                            // "same site" if we can't tell for sure.)
                            pmsgInNative->cMaxObjects = gcMaxIntraSiteObjects;
                            pmsgInNative->cMaxBytes   = gcMaxIntraSiteBytes;
                        } else {
                            // Different sites.
                            pmsgInNative->cMaxObjects = gcMaxInterSiteObjects;
                            pmsgInNative->cMaxBytes   = gcMaxInterSiteBytes;
                        }
                    }

                    if (IS_DRS_GETCHGREQ_V8_SUPPORTED(&pAsyncState->pContextInfo->ext)) {
                        // Target DSA is running post whistler review bits
                        dwInVersion = 8;
                    } else if (IS_DRS_GETCHGREQ_V5_SUPPORTED(&pAsyncState->pContextInfo->ext)) {
                        // Target DSA is running post Win2k RTM RC1 bits.
                        dwInVersion = 5;
                    } else {
                        // Target DSA is a pre-Win2k RTM RC2 DC.  We no longer
                        // support those.
                        DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
                    }

                    if (!IS_DRS_EXT_SUPPORTED(&pAsyncState->pContextInfo->ext,
                                              DRS_EXT_RESTORE_USN_OPTIMIZATION)) {
                        // Pre-Win2k RC3 DC -- we don't support those.
                        DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
                    }

                    draXlateNativeRequestToOutboundRequest(pTHS,
                                                           pmsgInNative,
                                                           NULL,
                                                           NULL,
                                                           dwInVersion,
                                                           &MsgIn);
                    fConstructedMsgIn = TRUE;
                }

                // Inform RPC to issue a call back on the security context used
                // for this call, so that we can copy the session key for
                // stronger encryption of secrets/passwords.
                InitRpcSessionEncryption(pTHS,
                                         BindFlags,
                                         pAsyncState->pContextInfo,
                                         NULL);

                // Construct state for asynchronous RPC call.
                drsPrepareAsyncRpcState(pTHS,
                                        pszServerName,
                                        pszServerDnsDomainName,
                                        DRS_CALL_GET_CHANGES,
                                        pAsyncState);
                pAsyncState->CallArgs.GetChg.pmsgIn      = pmsgInNative;
                pAsyncState->CallArgs.GetChg.pmsgOut     = pmsgOutNative;
                pAsyncState->CallArgs.GetChg.pSchemaInfo = pSchemaInfo;

                // Initiate the async call.  When control returns to us, RPC
                // has marshalled the input parameters and has enqueued the
                // send (but the response/out parameters have not yet been
                // received).
                _IDL_DRSGetNCChanges(&pAsyncState->RpcState,
                                     pAsyncState->pContextInfo->hDrs,
                                     dwInVersion,
                                     &MsgIn,
                                     &pAsyncState->CallArgs.GetChg.dwOutVersion,
                                     pmsgOut);
                pAsyncState->fIsCallInProgress = TRUE;

                DPRINT3(1, "Posted async GetChg call %p from USN 0x%I64x with flags 0x%x.\n",
                        pAsyncState,
                        pAsyncState->CallArgs.GetChg.pmsgIn->usnvecFrom.usnHighObjUpdate,
                        pAsyncState->CallArgs.GetChg.pmsgIn->ulFlags);

                fCallCompleted = TRUE;
            }
            __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                                  pszServerName,
                                                  pAsyncState->pContextInfo,
                                                  &ret)) {
                // Exception intercepted.  We may decide to try contacting the
                // source machine again.
                Assert(!fCallCompleted);
            }
        }

        MAP_SECURITY_PACKAGE_ERROR(ret);

        if (!ret && fWaitForCompletion) {
            ret = I_DRSGetNCChangesComplete(pTHS, pAsyncState);
        }
    }
    __finally {
        if (AbnormalTermination() || ret) {
            DRSDestroyAsyncRpcState(pTHS, pAsyncState);
        }

        if (!fWaitForCompletion) {
            PEKRestoreSessionKeySavedByMyThread(pTHS, &SessionKeyAtStart);
        }
    }

    return ret;
}

ULONG
I_DRSGetNCChangesComplete(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Complete a replication get changes request begun during a previous call
    to I_DRSGetNCChanges.

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Pointer to async state constructed via a previous
        call to I_DRSGetNCChanges.

Return Values:

    0 or Win32 error code.

--*/
{
    RPC_STATUS                    rpcStatus;
    ULONG                         ret;
    SESSION_KEY                   SessionKeyAtRpcCompletion;
    BOOL                          fSessionKeySaved = FALSE;

    // We abuse the fact that the native struct is the biggest struct in the
    // union to avoid putting the union on the stack and having to perform the
    // copy.
    Assert(sizeof(DRS_MSG_GETCHGREPLY_NATIVE) == sizeof(DRS_MSG_GETCHGREPLY));

    Assert(DRS_CALL_GET_CHANGES == pAsyncState->CallType);
    Assert(NULL != pAsyncState->pContextInfo);

    __try {
        do {
            rpcStatus = drsWaitForAsyncRpc(pTHS, pAsyncState, &ret);

            if (drsIsCallComplete(rpcStatus, ret, pAsyncState->pContextInfo)) {
                // Success or non-retriable error.
                break;
            }

            // Call failed in a way that dictates we must try again.
            ret = I_DRSGetNCChanges(pTHS,
                                    pAsyncState->CallArgs.pszServerName,
                                    pAsyncState->CallArgs.pszDomainName,
                                    pAsyncState->CallArgs.GetChg.pmsgIn,
                                    pAsyncState->CallArgs.GetChg.pmsgOut,
                                    pAsyncState->CallArgs.GetChg.pSchemaInfo,
                                    pAsyncState);
        } while (!ret);

        if (ret) {
            __leave;
        }

        PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtRpcCompletion);
        fSessionKeySaved = TRUE;

        draXlateInboundReplyToNativeReply(pTHS,
                                          pAsyncState->CallArgs.GetChg.dwOutVersion,
                                          (DRS_MSG_GETCHGREPLY *) pAsyncState->CallArgs.GetChg.pmsgOut,
                                          pAsyncState->CallArgs.GetChg.pmsgIn->ulExtendedOp
                                            ? DRA_XLATE_FSMO_REPLY
                                            : 0,
                                          pAsyncState->CallArgs.GetChg.pmsgOut);

        UpToDateVec_Validate(pAsyncState->CallArgs.GetChg.pmsgOut->pUpToDateVecSrc);
        UsnVec_Validate(&pAsyncState->CallArgs.GetChg.pmsgOut->usnvecTo);

        __try {
            if (IS_DRS_SCHEMA_INFO_SUPPORTED(pTHS->pextRemote)) {
                // Schema info piggybacked on the prefix table, Strip it
                StripSchInfoFromPrefixTable(&pAsyncState->CallArgs.GetChg.pmsgOut->PrefixTableSrc,
                                            pAsyncState->CallArgs.GetChg.pSchemaInfo);
            }
        }
        __except (GetDraException((GetExceptionInformation()), &ret)) {
            DPRINT1(1,"I_DRSGetNCChanges: Exception %d while trying to strip schema info\n", ret);
        }
    }
    __finally {
        DRSDestroyAsyncRpcState(pTHS, pAsyncState);

        if (fSessionKeySaved) {
            PEKRestoreSessionKeySavedByMyThread(pTHS,
                                                &SessionKeyAtRpcCompletion);
        }
    }

    Assert(ret || (NULL != pTHS->SessionKey.SessionKey));
    Assert(ret || (NULL != pTHS->pextRemote));

    return ret;
}

ULONG
I_DRSUpdateRefsEx(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    DSNAME *    pNC,
    LPWSTR      pszDsaDest,
    UUID *      puuidDsaDest,
    ULONG       ulOptions,
    PULONG      pfCallCompleted
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_UPDREFS     msgUpdRefs;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgUpdRefs, 0, sizeof(msgUpdRefs));

    msgUpdRefs.V1.pNC        = pNC;
    msgUpdRefs.V1.ulOptions  = ulOptions;

    if (NULL != pszDsaDest) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszDsaDest);
        msgUpdRefs.V1.pszDsaDest = pmtx->mtx_name;
    }

    if (NULL != puuidDsaDest) {
        msgUpdRefs.V1.uuidDsaObjDest = *puuidDsaDest;
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcReplicationTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret = _IDL_DRSUpdateRefs(pContextInfo->hDrs, 1, &msgUpdRefs);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
	__except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    if (pfCallCompleted) {
        *pfCallCompleted = fCallCompleted;
    }

    return ret;
}

ULONG
I_DRSReplicaAddEx(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pNCName,
    IN  DSNAME *    pSourceDsaDN,
    IN  DSNAME *    pTransportDN,
    IN  LPWSTR      pszSourceDsaAddress,
    IN  REPLTIMES * pSyncSchedule,
    IN  ULONG       ulOptions,
    OUT PULONG      pfCallCompleted
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPADD      msgAdd;
    DWORD               dwMsgVersion;
    MTX_ADDR *          pmtx = NULL;

    Assert(NULL != pszSourceDsaAddress);

    memset(&msgAdd, 0, sizeof(msgAdd));

    pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDsaAddress);

    if ((NULL == pSourceDsaDN) && (NULL == pTransportDN)) {
        dwMsgVersion = 1;

        msgAdd.V1.pNC       = pNCName;
        msgAdd.V1.pszDsaSrc = pmtx->mtx_name;
        msgAdd.V1.ulOptions = ulOptions;

        if (NULL != pSyncSchedule) {
            msgAdd.V1.rtSchedule = *pSyncSchedule;
        }
    }
    else {
        dwMsgVersion = 2;

        msgAdd.V2.pNC                 = pNCName;
        msgAdd.V2.pSourceDsaDN        = pSourceDsaDN;
        msgAdd.V2.pTransportDN        = pTransportDN;
        msgAdd.V2.pszSourceDsaAddress = pmtx->mtx_name;
        msgAdd.V2.ulOptions           = ulOptions;

        if (NULL != pSyncSchedule) {
            msgAdd.V2.rtSchedule = *pSyncSchedule;
        }
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        if ((2 == dwMsgVersion)
            && !IS_DRS_REPADD_V2_SUPPORTED(&pContextInfo->ext)) {
            ret = DRAERR_NotSupported;
            break;
        }
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcReplicationTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret =  _IDL_DRSReplicaAdd(pContextInfo->hDrs, dwMsgVersion, &msgAdd);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    THFreeEx(pTHS, pmtx);

    if (pfCallCompleted) {
        *pfCallCompleted = fCallCompleted;
    }

    return ret;
}


ULONG
I_DRSReplicaDel(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszServerName,
    IN  DSNAME *  pNCName,
    IN  LPWSTR    pszSourceDSA,
    IN  ULONG     ulOptions
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPDEL      msgDel;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgDel, 0, sizeof(msgDel));

    msgDel.V1.pNC       = pNCName;
    msgDel.V1.ulOptions = ulOptions;

    if (NULL != pszSourceDSA) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDSA);
        msgDel.V1.pszDsaSrc = pmtx->mtx_name;
    }

    while (!fCallCompleted
	   && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcReplicationTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret =  _IDL_DRSReplicaDel(pContextInfo->hDrs, 1, &msgDel);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    return ret;
}


ULONG
I_DRSVerifyNames(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    LPWSTR                  pszDnsDomainName,
    DWORD                   dwInVersion,
    DRS_MSG_VERIFYREQ *     pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_VERIFYREPLY *   pmsgOut
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcGcLookupTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret = _IDL_DRSVerifyNames(pContextInfo->hDrs,
				      dwInVersion,
				      pmsgIn,
				      pdwOutVersion,
				      pmsgOut);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSGetMemberships(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    LPWSTR      pszServerDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      errCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory
    )
{
    ULONG                   ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *      pContextInfo = NULL;
    BOOL                    fCallCompleted = FALSE;
    DRS_MSG_REVMEMB_REQ     msgIn;
    DRS_MSG_REVMEMB_REPLY   msgOut;
    DWORD                   dwOutVersion;

    msgIn.V1.ppDsNames       = ppObjects;
    msgIn.V1.cDsNames        = cObjects;
    msgIn.V1.dwFlags         = 0;
    msgIn.V1.pLimitingDomain = pLimitingDomain;
    msgIn.V1.OperationType   = OperationType;

    RtlZeroMemory(&msgOut, sizeof(msgOut));

    while (!fCallCompleted
	   && FBindSzDRS(pTHS, pszServerName, pszServerDnsDomainName, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcGcLookupTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret = _IDL_DRSGetMemberships(
		pContextInfo->hDrs,
		1,
		&msgIn,
		&dwOutVersion,
		&msgOut
		);

	    *prpDsNames = msgOut.V1.ppDsNames;
	    *pcDsNames  = msgOut.V1.cDsNames;

	    if (ARGUMENT_PRESENT(pAttributes)) {
		*pAttributes = msgOut.V1.pAttributes;
	    }

	    if ((ARGUMENT_PRESENT(pcSidHistory))
		&& (ARGUMENT_PRESENT(rgSidHistory))) {
		*pcSidHistory = msgOut.V1.cSidHistory;
		*rgSidHistory = msgOut.V1.ppSidHistory;
	    }
	  
	    *errCode = msgOut.V1.errCode;

	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
	__except (DRSHandleRpcClientException(GetExceptionInformation(),
					      pszServerName,
					      pContextInfo,
					      &ret)) {
	    ;
	}
    }
    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSInterDomainMove(
    IN  THSTATE *           pTHS,
    IN  LPWSTR              pszServerName,
    IN  DWORD               dwInVersion,
    IN  DRS_MSG_MOVEREQ *   pmsgIn,
    IN  DWORD *             pdwOutVersion,
    OUT DRS_MSG_MOVEREPLY * pmsgOut
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    ULONG               BindFlags;
    extern ULONG        EncryptSecretData(THSTATE *, ENTINF *);

    if (    (NULL == pszServerName)
         || (NULL == pmsgIn)
         || (NULL == pmsgOut)
         || (2 != dwInVersion) ) {
        return(DRAERR_InvalidParameter);
    }

    BindFlags = FBINDSZDRS_LOCK_HANDLE |            // required by encryption
                FBINDSZDRS_NO_CACHED_HANDLES |      // for user impersonation
                FBINDSZDRS_CRYPTO_BIND;             // RPC session encryption

    while (    !fCallCompleted
            && FBindSzDRS(  pTHS,
                            pszServerName,
                            NULL,
                            BindFlags,
                            &pContextInfo, &ret)) {

        // Security error check.
        MAP_SECURITY_PACKAGE_ERROR(ret);
        if ( ret ) {
            break;
        }

        // Versioning check.
        if (    (2 == dwInVersion)
             && !IS_DRS_MOVEREQ_V2_SUPPORTED(&pContextInfo->ext) ) {
            ret = DRAERR_NotSupported;
            break;
        }

        // FBINDSZDRS_CRYPTO_BIND sanity check.
        Assert(    pTHS->SessionKey.SessionKey
                && pTHS->SessionKey.SessionKeyLength);

        // Update THSTATE so pek code can match destination's capabilities.
        DraSetRemoteDsaExtensionsOnThreadState(pTHS, &pContextInfo->ext);

        // At this point we know that:
        //
        //      1) The destination has the session keys stashed in the
        //         DRS_CLIENT_CONTEXT for this client session and will
        //         presumably use them when decrypting DBIsSecretData()
        //         in the ENTINF we are about to send.
        //      3) We have the corresponding session keys stashed in our
        //         thread state such that we will encrypt DBIsSecretData()
        //         with those keys for any items read while fDRA is set.
        //
        // So now invoke the callback to encrypt those things which need it.
        //
        // N.B. The PEK code (pek.c) figures out for itself which version/level
        // of encryption is supported in common between source and destination
        // based on the extensions.


        if ( ret = EncryptSecretData(pTHS, pmsgIn->V2.pSrcObject) ) {
            break;
        }

        if (IS_DRS_SCHEMA_INFO_SUPPORTED(&pContextInfo->ext)) {
             // need to ship the schema info piggybacked on the prefix table
             // Note: the client doesn't ship the table unless it also
             // send some atts (like partial atts). We send the schema
             // info anyway. Right now it will not be used on the
             // server side.

             if (AddSchInfoToPrefixTable(pTHS, &pmsgIn->V2.PrefixTable)){
                 ret = DRAERR_SchemaInfoShip;
                 break;
             }
        }

	__try {
	    DRSSetRpcCancelTime(gulDrsRpcMoveObjectTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret = _IDL_DRSInterDomainMove(pContextInfo->hDrs,
					  dwInVersion,
					  pmsgIn,
					  pdwOutVersion,
					  pmsgOut);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    PEKClearSessionKeys(pTHS);

    return ret;
}


ULONG
I_DRSGetNT4ChangeLog(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    DWORD                   dwFlags,
    ULONG                   PreferredMaximumLength,
    PVOID *                 ppRestart,
    PULONG                  pcbRestart,
    PVOID *                 ppLog,
    PULONG                  pcbLog,
    NT4_REPLICATION_STATE * ReplicationState,
    NTSTATUS *              ActualNtStatus
    )
{
    ULONG                     ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *        pContextInfo = NULL;
    BOOL                      fCallCompleted = FALSE;
    DRS_MSG_NT4_CHGLOG_REQ    msgIn;
    DRS_MSG_NT4_CHGLOG_REPLY  msgOut;
    DWORD                     dwOutVersion;

    msgIn.V1.dwFlags                = dwFlags;
    msgIn.V1.PreferredMaximumLength = PreferredMaximumLength;
    msgIn.V1.cbRestart              = *pcbRestart;
    msgIn.V1.pRestart               = *ppRestart;

    RtlZeroMemory(&msgOut,sizeof(msgOut));

    //
    // For getting the change log, we do not try hard, but try
    // weakly. Remember it is a best effort process, and if we
    // encounter any errors we will end up dropping the idea, of
    // getting the change log and rescheduling it later.
    //

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcNT4ChangeLogTimeoutInMins,
				&pContextInfo->hDrs
				    );    

	    ret =  _IDL_DRSGetNT4ChangeLog(
		pContextInfo->hDrs,
		1,
		&msgIn,
		&dwOutVersion,
		&msgOut
		);
	    Assert(1 == dwOutVersion);

	    *ppRestart = msgOut.V1.pRestart;
	    *pcbRestart = msgOut.V1.cbRestart;
	    *ppLog = msgOut.V1.pLog;
	    *pcbLog = msgOut.V1.cbLog;

	    *ReplicationState = msgOut.V1.ReplicationState;
	    *ActualNtStatus = msgOut.V1.ActualNtStatus;

	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	}
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSCrackNames(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    LPWSTR                  pszDnsDomainName,
    DWORD                   dwInVersion,
    DRS_MSG_CRACKREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_CRACKREPLY *    pmsgOut
    )
{
    ULONG               win32Err = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    // N.B. - For various reasons, _IDL_DRSCrackNames returns WIN32
    // error codes, not DRAERR* values.  See dsamain\dra\ntdsapi.c.
    // Therefore this routine does too.  The only known internal client
    // at this time is CrackSingleName in dsamain\src\cracknam.c.

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &win32Err)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcGcLookupTimeoutInMins,
				&pContextInfo->hDrs
				);    
	    win32Err = _IDL_DRSCrackNames(pContextInfo->hDrs,
					  dwInVersion,
					  pmsgIn,
					  pdwOutVersion,
					  pmsgOut);
	    fCallCompleted = drsIsCallComplete(0, win32Err, pContextInfo);
	}
	__except (DRSHandleRpcClientException(GetExceptionInformation(),
					      pszServerName,
					      pContextInfo,
					      &win32Err)) {
	    ;
	}
    }

    MAP_SECURITY_PACKAGE_ERROR( win32Err );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return win32Err;
}

#ifdef INCLUDE_UNIT_TESTS

/*++

    This is a Unit test that excercises the binding handle cache
    and also usage of cached as well as locked handles. Just make
    sure that the machine to which you want to get binding handle is
    running and is reachable. The test will assert on failure. Typically
    on an idle machine the test will succeed. There can be spurious failures
    on a busy machine. Agreed it is primitive that the we have to declare the
    server name statically like below, and it will be a later excercise to
    improve this such that this can be taken as a parameter to BHCacheTest.

--*/
LPWSTR szTestServer = L"murli06.murlitest.nttest.microsoft.com";

VOID BHCacheTest(VOID)
{
    DRS_CONTEXT_INFO *pContextInfo1=NULL;
    DRS_CONTEXT_INFO *pContextInfo2=NULL;

    DWORD            dwStatus=0;
    BOOL             Success;
    DRS_HANDLE       hDrs;

    //
    // Void the cache for this server
    //

    BHCacheVoidServer(szTestServer);

    //
    // First try a simple binding
    //

    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);

    //
    // Try a simple binding again. Should get back the
    // same handle.
    //

     Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo2,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo2->fIsHandleInCache);
    // The handle should be the same
    Assert(pContextInfo1->hDrs==pContextInfo2->hDrs);

    //
    // Save the handle. Will be used below
    //

    hDrs = pContextInfo1->hDrs;
    //
    // Free the handles. The handles should be returned to
    // the cache
    //


    DRSFreeContextInfo(pTHStls, &pContextInfo1);
    DRSFreeContextInfo(pTHStls, &pContextInfo2);


    //
    // Try a case of a locked handle. The handle should now
    // come from the cache
    //

    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                FBINDSZDRS_LOCK_HANDLE,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);
    // Should have the same handle back.
    Assert(hDrs==pContextInfo1->hDrs);

    //
    // Try to obtain one other handle. This handle should
    // not come from the cache ( the one in the cache is locked )
    //

     Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo2,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(!(pContextInfo2->fIsHandleInCache));
    // The handle should be the same
    Assert(hDrs!=pContextInfo2->hDrs);

    //
    // Free Handles
    //

    DRSFreeContextInfo(pTHStls, &pContextInfo2);
    DRSFreeContextInfo(pTHStls, &pContextInfo1);

    //
    // Get one more handle, and this should be
    // from the cache and the same as the first 3
    // handles
    //


    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);
    // Should have the same handle back.
    Assert(hDrs==pContextInfo1->hDrs);

    //
    // Free the handle
    //

    DRSFreeContextInfo(pTHStls, &pContextInfo1);

 }


#endif

ULONG
I_DRSAddEntry(
    IN  THSTATE *                   pTHS,
    IN  LPWSTR                      pszServerName,
    IN  DRS_SecBufferDesc *         pClientCreds,   OPTIONAL
    IN  DRS_MSG_ADDENTRYREQ_V2 *    pReq,
    OUT DWORD *                     pdwReplyVer,
    OUT DRS_MSG_ADDENTRYREPLY *     pReply
    )

/*++

  Routine Description:

    Calls the DSA on server pszServerName to add the object described in
    pReq, with the results of the operation being returned in pReply.

  Parameters:

    pszServerName - Name of server where the add should take place

    pClientCreds (OPTIONAL) - Credentials to use to add the object, if other
        than the default credentials (gCredentials)

    pReq - mostly an addarg in a bag

    pReply - add results

  Return Values:

    ERROR_SUCCESS on success

--*/

{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    ULONG               ReqVer;
    DRS_MSG_ADDENTRYREQ uReq;
    DRS_MSG_ADDENTRYREPLY uReply;

    if (NULL == pClientCreds) {
        ReqVer = 2;
        uReq.V2 = *pReq;
    } else {
        ReqVer = 3;
        uReq.V3.EntInfList = pReq->EntInfList;
        uReq.V3.pClientCreds = pClientCreds;
    }

    RtlZeroMemory( &uReply, sizeof( uReply ) );

    while (!fCallCompleted && FBindSzDRS(pTHS,
                                         pszServerName,
                                         NULL,
                                         0,
                                         &pContextInfo,
                                         &ret)) {
        Assert(!ret)
        switch (ReqVer) {
        case 2:
            if (!IS_DRS_ADDENTRY_V2_SUPPORTED(&pContextInfo->ext)) {
                ret = DRAERR_NotSupported;
            }
            break;

        case 3:
            if (!IS_DRS_ADDENTRY_V3_SUPPORTED(&pContextInfo->ext)) {
                ret = DRAERR_NotSupported;
            }
            break;

        default:
            Assert(!"Logic Error");
            ret = DRAERR_NotSupported;
            break;
        }

        if (ret) {
            break;
        }

	__try {
	    DRSSetRpcCancelTime(gulDrsRpcReplicationTimeoutInMins,
				&pContextInfo->hDrs
				);     
	    ret =  _IDL_DRSAddEntry(pContextInfo->hDrs,
				    ReqVer,
				    &uReq,
				    pdwReplyVer,
				    &uReply);

	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    *pReply = uReply;

    return ret;
}

ULONG
I_DRSIsExtSupported(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  ULONG       Ext
    )
/*++

  Routine Description:

    This routine determines if pszServerName supports Ext

  Parameters:

    pszServerName - Name of server where the add should take place

    Ext -- the extension of the DRS interface the caller is interested in


  Return Values:

    ERROR_SUCCESS or DRAERR_NotSupported, or network error

--*/

{
    ULONG               ret = DRAERR_Success;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;

    if ( FBindSzDRS(
            pTHS,
            pszServerName,
            NULL, 0,
            &pContextInfo,
            &ret) && !ret ){
        // bind succeeded w/ no errors.
        // see if exts are supported.
        if ( !IS_DRS_EXT_SUPPORTED(&pContextInfo->ext, Ext) ) {
            ret = DRAERR_NotSupported;
        }
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}

ULONG
I_DRSGetMemberships2(
    THSTATE                       *pTHS,
    LPWSTR                         pszServerName,
    LPWSTR                         pszDnsDomainName,
    DWORD                          dwInVersion,
    DRS_MSG_GETMEMBERSHIPS2_REQ   *pmsgIn,
    DWORD                         *pdwOutVersion,
    DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
    )
/*++

Routine Description:

    This routine is a batchable form of I_DRSGetMemberships

Parameters:

    pTHS -- thread state

    pszServerName -- target server

    pszServerDnsDomainDomain -- domain of pszServerName, needed for SPN

    dwMsgInVersion -- version of in blob

    psgIn -- in blob, see drs.idl for details

    pdwMsgOutVersion -- version of returned blob

    psgOut -- returned blob, see drs.idl for details

  Return Values:

    ERROR_SUCCESS on success

--*/
{

    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &ret)) {
	__try {
	    DRSSetRpcCancelTime(gulDrsRpcGcLookupTimeoutInMins,
				&pContextInfo->hDrs
				);       
	    ret = _IDL_DRSGetMemberships2(pContextInfo->hDrs,
					  dwInVersion,
					  pmsgIn,
					  pdwOutVersion,
					  pmsgOut);
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);

	}
	__except (DRSHandleRpcClientException(GetExceptionInformation(),
					      pszServerName,
					      pContextInfo,
					      &ret)) {
	    ;
	}
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;

}



BOOL
I_DRSIsIntraSiteServer(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName
    )
/*++

  Routine Description:

    This routine determines if pszServerName is intra-site relative
    to this server (as given by gAnchor).

  Parameters:

    pTHS - Thread context
    pszServerName - Name of server where the add should take place

  Return Values:

    TRUE: Target server is intra-site
    FALSE: Target server is NOT intra-site
    (or some other failure, i.e. default is inter-site)

--*/

{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fIntra = FALSE;

    if ( FBindSzDRS(
            pTHS,
            pszServerName,
            NULL,0,
            &pContextInfo,
            &ret)           &&
         IS_REMOTE_DSA_IN_SITE(&pContextInfo->ext, gAnchor.pSiteDN) )
    {
        fIntra = TRUE;
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return fIntra;
}

ULONG
I_DRSGetObjectExistence(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DRS_MSG_EXISTREQ *            pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_EXISTREPLY *          pmsgOut
    )
/*++

  Routine Description:

    This routine determines if a set of objects on the source server
    match the set of objects on the destination (this) server.  If not,
    the set of object guids is returned.

  Parameters:

    pTHS - Thread context
    pszServerName - Source server (transport address)
    pmsgIn
    pdwOutVersion
    pmsgOut

  Return Values:

    0 or Errors

--*/
{
    ULONG                ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *   pContextInfo = NULL;
    BOOL                 fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {  
	    DRSSetRpcCancelTime(gulDrsRpcObjectExistenceTimeoutInMins,
				&pContextInfo->hDrs
				);  

	    ret = _IDL_DRSGetObjectExistence(pContextInfo->hDrs, 
					     1, 
					     pmsgIn,
					     pdwOutVersion,
					     pmsgOut); 
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	} 
	 __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;

}

ULONG
I_DRSGetReplInfo(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pmsgOut
    )
/*++

  Routine Description:

    This routine allows access to RepInfo from DC to DC.

  Parameters:

    pTHS - Thread context
    pszServerName - Server to access
    dwInVersion -
    pmsgIn -
    pdwOutVersion -
    pmsgOut -

  Return Values:

    0 or Errors

--*/
{
    ULONG                ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *   pContextInfo = NULL;
    BOOL                 fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
	__try {  
	    DRSSetRpcCancelTime(gulDrsRpcGetReplInfoTimeoutInMins,
				&pContextInfo->hDrs
				);   
	    ret = _IDL_DRSGetReplInfo(pContextInfo->hDrs, 
				      1, 
				      pmsgIn,
				      pdwOutVersion,
				      pmsgOut); 
	    fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
	} 
	 __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\gclogon.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gclogon.c
//
//--------------------------------------------------------------------------

/*++

    This File Contains Services Pertaining to Reverse Membership Lookup
    in a G.C


    Author

        Murlis

    Revision History

        4/8/97 Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "mappings.h"
#include "drarpc.h"

#include <fileno.h>
#define  FILENO FILENO_GCLOGON

ULONG
NtStatusToDraError(NTSTATUS NtStatus)
/*++

    This Routine Maps an NtStatus error code
    to an equivalent DRA error

    Parameters:

        NtStatus - NtStatus Code to Map

    Return Values:

        Dra Error Code
--*/
{
    //
    // DRA errors are win32 errors
    //
    return RtlNtStatusToDosError(NtStatus);
}

ULONG
IDL_DRSGetMemberships(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_REVMEMB_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_REVMEMB_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine Evaluates the Transitive Reverse Membership on any given
        domain controller, including a G.C

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        pdwOutVersion The server's version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0;
    THSTATE                 *pTHS = NULL;

    drsReferenceContext( rpc_handle, IDL_DRSGETMEMBERSHIPS);
    __try {
	__try
	    {
	    // We currently support just one output message version.
	    *pdwOutVersion = 1;

	    // Discard request if we're not installed


	    if ( DsaIsInstalling() ) {
		DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
	    }

	    if (    ( NULL == pmsgIn )
		    || ( 1 != dwInVersion )
		    ) {
		DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
	    }

	    // Initialize thread state and open data base.

	    if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM))) {
		DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0 )