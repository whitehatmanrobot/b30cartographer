ing of 2048 characters.");
            }
        }
    }

    public class STSAppliesToClaimType
    {
        public string ClaimTypeUri;
        public bool Required;
    }

    public class STSClaimTypeInfo
    {
        public string ClaimTypeUri;
        public bool Encrypted;
        public string Title;
        public string Description;
        public string ValueType;
    }

    public static partial class MixSettingsDataTypeFactory
    {
        public static LiveInfoSetting Convert(LiveHiveSettingV3 lisV3)
        {
            if(lisV3 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveHiveSetting was null.");
            }

            LiveInfoSetting set = new LiveInfoSetting();

            if(lisV3.Config != null) // This could be null for a call to SetSetting
            {
                set.Config = Convert(lisV3.Config);
            }

            set.Name = lisV3.Name;
            set.Value = lisV3.Value;

            return set;
        }

        public static LiveInfoConfig Convert(LiveHiveConfigV3 lhcV3)
        {
            if(lhcV3 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveInfoConfig was null.");
            }

            LiveInfoConfig lic = new LiveInfoConfig();

            lic.Platform = Convert(lhcV3.Platform);
            lic.Build = lhcV3.Build;
            lic.Qfe = lhcV3.Qfe;
            lic.BetaGroupId = lhcV3.BetaGroupId;

            return lic;
        }

        public static LiveInfoConfig.PlatformType Convert(PlatformTypeV3 plat)
        {
            switch(plat)
            {
                case PlatformTypeV3.Xenon:
                    return LiveInfoConfig.PlatformType.xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV1), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }

        public static LiveHiveSettingV3 ConvertV3(LiveInfoSetting lis)
        {
            LiveHiveSettingV3 lhs = new LiveHiveSettingV3();
            lhs.Config = ConvertV3(lis.Config);
            lhs.Name = lis.Name;
            lhs.Value = lis.Value;

            return lhs;
        }

        public static LiveHiveConfigV3 ConvertV3(LiveInfoConfig lic)
        {
            LiveHiveConfigV3 lvc = new LiveHiveConfigV3();

            lvc.Platform = ConvertV3(lic.Platform);
            lvc.Build = lic.Build;
            lvc.Qfe = lic.Qfe;
            lvc.BetaGroupId = lic.BetaGroupId;

            return lvc;
        }

        public static PlatformTypeV3 ConvertV3(LiveInfoConfig.PlatformType plat)
        {
            // We only support Xenon for now.
            //
            switch(plat)
            {
                case LiveInfoConfig.PlatformType.xenon:
                    return PlatformTypeV3.Xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV3), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }

        public static BusinessPartner Convert(BusinessPartnerV3 bpV3)
        {
            BusinessPartner bp = new BusinessPartner();
            bp.BusinessPartnerID = bpV3.BusinessPartnerID;
            bp.FriendlyName = bpV3.FriendlyName;
            bp.ConnectionInfos = ConvertAll(bpV3.ConnectionInfos);

            return bp;
        }

        public static BusinessPartnerConnectionInfo Convert(BusinessPartnerConnectionInfoV3 connInfoV3)
        {
            BusinessPartnerConnectionInfo bpci = new BusinessPartnerConnectionInfo();
            bpci.FriendlyName = connInfoV3.FriendlyName;
            bpci.SGCertificate = connInfoV3.SGCertificate;
            return bpci;
        }

        public static BusinessPartnerConnectionInfo[] ConvertAll(BusinessPartnerConnectionInfoV3[] connInfoV3)
        {
            List<BusinessPartnerConnectionInfo> connList = new List<BusinessPartnerConnectionInfo>();

            foreach(BusinessPartnerConnectionInfoV3 pciv3 in connInfoV3)
            {
                connList.Add(Convert(pciv3));
            }

            return connList.ToArray();
        }

        public static STSAppliesTo Convert(STSAppliesToV3 atV3)
        {
            STSAppliesTo at = new STSAppliesTo();
            at.BusinessPartnerID = atV3.BusinessPartnerID;
            at.AppliesToUri = atV3.AppliesToUri;
            at.ValidityInterval = atV3.ValidityInterval;
            at.TokenType = atV3.TokenType;
            at.ClaimTypes = ConvertAll(atV3.ClaimTypes);
            at.AppliesToCertificate = atV3.AppliesToCertificate;

            return at;
        }

        public static STSAppliesToClaimType Convert(STSAppliesToClaimTypeV3 atctV3)
        {
            STSAppliesToClaimType atct = new STSAppliesToClaimType();
            atct.ClaimTypeUri = atctV3.ClaimTypeUri;
            atct.Required = atctV3.Required;
            return atct;
        }

        public static STSAppliesToClaimType[] ConvertAll(STSAppliesToClaimTypeV3[] claimTypesV3)
        {
            List<STSAppliesToClaimType> claimTypes = new List<STSAppliesToClaimType>();

            foreach(STSAppliesToClaimTypeV3 atctV3 in claimTypesV3)
            {
                claimTypes.Add(Convert(atctV3));
            }

            return claimTypes.ToArray();
        }

        public static STSClaimTypeInfo Convert(STSClaimTypeInfoV3 ctiV3)
        {
            STSClaimTypeInfo cti = new STSClaimTypeInfo();
            cti.ClaimTypeUri = ctiV3.ClaimTypeUri;
            cti.Encrypted = ctiV3.Encrypted;
            cti.Title = ctiV3.Title;
            cti.Description = ctiV3.Description;
            cti.ValueType = ctiV3.ValueType;

            return cti;
        }

        public static BusinessPartnerV3 Convert(BusinessPartner bp)
        {
            BusinessPartnerV3 bpV3 = new BusinessPartnerV3();
            bpV3.BusinessPartnerID = bp.BusinessPartnerID;
            bpV3.FriendlyName = bp.FriendlyName;
            bpV3.ConnectionInfos = ConvertAll(bp.ConnectionInfos);

            return bpV3;
        }

        public static BusinessPartnerConnectionInfoV3 Convert(BusinessPartnerConnectionInfo connInfo)
        {
            BusinessPartnerConnectionInfoV3 bpciV3 = new BusinessPartnerConnectionInfoV3();
            bpciV3.FriendlyName = connInfo.FriendlyName;
            bpciV3.SGCertificate = connInfo.SGCertificate;
            return bpciV3;
        }

        public static BusinessPartnerConnectionInfoV3[] ConvertAll(BusinessPartnerConnectionInfo[] connInfo)
        {
            List<BusinessPartnerConnectionInfoV3> connListV3 = new List<BusinessPartnerConnectionInfoV3>();

            foreach(BusinessPartnerConnectionInfo pci in connInfo)
            {
                connListV3.Add(Convert(pci));
            }

            return connListV3.ToArray();
        }

        public static STSAppliesToV3 Convert(STSAppliesTo at)
        {
            STSAppliesToV3 atV3 = new STSAppliesToV3();
            atV3.BusinessPartnerID = at.BusinessPartnerID;
            atV3.AppliesToUri = at.AppliesToUri;
            atV3.ValidityInterval = at.ValidityInterval;
            atV3.TokenType = at.TokenType;
            atV3.ClaimTypes = ConvertAll(at.ClaimTypes);
            atV3.AppliesToCertificate = at.AppliesToCertificate;

            return atV3;
        }

        public static STSAppliesToClaimTypeV3 Convert(STSAppliesToClaimType atct)
        {
            STSAppliesToClaimTypeV3 atctV3 = new STSAppliesToClaimTypeV3();
            atctV3.ClaimTypeUri = atct.ClaimTypeUri;
            atctV3.Required = atct.Required;
            return atctV3;
        }

        public static STSAppliesToClaimTypeV3[] ConvertAll(STSAppliesToClaimType[] claimTypes)
        {
            List<STSAppliesToClaimTypeV3> claimTypesV3 = new List<STSAppliesToClaimTypeV3>();

            foreach(STSAppliesToClaimType atct in claimTypes)
            {
                claimTypesV3.Add(Convert(atct));
            }

            return claimTypesV3.ToArray();
        }

        public static STSClaimTypeInfoV3 Convert(STSClaimTypeInfo cti)
        {
            STSClaimTypeInfoV3 ctiV3 = new STSClaimTypeInfoV3();
            ctiV3.ClaimTypeUri = cti.ClaimTypeUri;
            ctiV3.Encrypted = cti.Encrypted;
            ctiV3.Title = cti.Title;
            ctiV3.Description = cti.Description;
            ctiV3.ValueType = cti.ValueType;

            return ctiV3;
        }

        public static STSClaimTypeInfoV3[] ConvertAll(STSClaimTypeInfo[] claimTypes)
        {
            List<STSClaimTypeInfoV3> claimTypeInfoV3 = new List<STSClaimTypeInfoV3>();

            foreach(STSClaimTypeInfo atct in claimTypes)
            {
                claimTypeInfoV3.Add(Convert(atct));
            }

            return claimTypeInfoV3.ToArray();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsDataTypeFactoryV2.cs ===
ï»¿
using System;
using xonline.mix.settingsmanagement.contract;
using System.Data;
using xonline.common.service;
using System.Collections.Generic;
using System.Linq;
using xonline.common.content;
using System.Collections;
using System.Text;

using xonline.server.liveinfo.client;

namespace xonline.mix.settingsmanagement.service
{
    public static partial class MixSettingsDataTypeFactory
    {
        public static LiveInfoSetting Convert(LiveHiveSettingV2 lisv2)
        {
            if(lisv2 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveHiveSetting was null.");
            }

            LiveInfoSetting set = new LiveInfoSetting();

            if(lisv2.Config != null) // This could be null for a call to SetSetting
            {
                set.Config = Convert(lisv2.Config);
            }

            set.Name = lisv2.Name;
            set.Value = lisv2.Value;

            return set;
        }

        public static LiveInfoConfig Convert(LiveHiveConfigV2 lhcv2)
        {
            if(lhcv2 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveInfoConfig was null.");
            }

            LiveInfoConfig lic = new LiveInfoConfig();

            lic.Platform = Convert(lhcv2.Platform);
            lic.Build = lhcv2.Build;
            lic.Qfe = lhcv2.Qfe;
            lic.BetaGroupId = lhcv2.BetaGroupId;

            return lic;
        }

        public static LiveInfoConfig.PlatformType Convert(PlatformTypeV2 plat)
        {
            switch(plat)
            {
                case PlatformTypeV2.Xenon:
                    return LiveInfoConfig.PlatformType.xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV1), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }

        public static LiveHiveSettingV2 ConvertV2(LiveInfoSetting lis)
        {
            LiveHiveSettingV2 lhs = new LiveHiveSettingV2();
            lhs.Config = ConvertV2(lis.Config);
            lhs.Name = lis.Name;
            lhs.Value = lis.Value;

            return lhs;
        }

        public static LiveHiveConfigV2 ConvertV2(LiveInfoConfig lic)
        {
            LiveHiveConfigV2 lvc = new LiveHiveConfigV2();

            lvc.Platform = ConvertV2(lic.Platform);
            lvc.Build = lic.Build;
            lvc.Qfe = lic.Qfe;
            lvc.BetaGroupId = lic.BetaGroupId;

            return lvc;
        }

        public static PlatformTypeV2 ConvertV2(LiveInfoConfig.PlatformType plat)
        {
            // We only support Xenon for now.
            //
            switch(plat)
            {
                case LiveInfoConfig.PlatformType.xenon:
                    return PlatformTypeV2.Xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV2), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsManagement.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using System.Xml.Linq;

using xonline.server.liveinfo.client;
using xonline.common.config;
using xonline.common.core.etx;
using xonline.common.content;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities2;
using xonline.mix.common;
using xonline.mix.settingsmanagement.contract;

using xonline.config.sts.interfaces;
using xonline.config.sts.databaseconfig;

namespace xonline.mix.settingsmanagement.service
{
    public class MixSettingsManagement : PackageInstaller
    {
        public static readonly string GetSettingsApiName = "MixSettingsManagement.GetSettings";
        public static readonly string SetSettingApiName = "MixSettingsManagement.SetSetting";
        public static readonly string IngestEtxManifestApiName = "MixSettingsManagement.IngestEtxManifest";
        public static readonly string SetBusinessPartnerApiName = "MixSettingsManagement.SetBusinessPartner";
        public static readonly string SetAppliesToInfoApiName = "MixSettingsManagement.SetAppliesToInfo";
        public static readonly string RemoveAppliesToInfoApiName = "MixSettingsManagement.RemoveAppliesToInfo";
        public static readonly string GetAppliesToInfoApiName = "MixSettingsManagement.GetAppliesToInfo";
        public static readonly string GetBusinessPartnerTypesApiName = "MixSettingsManagement.GetBusinessPartnerTypes";
        public static readonly string GetClaimTypesApiName = "MixSettingsManagement.GetClaimTypes";
        public static readonly string GetTokenTypesApiName = "MixSettingsManagement.GetTokenTypes";

        #region GetSettings
        /// <summary>
        /// Definition for GetSettings
        /// </summary>
        /// <param name="config">The config to retrieve</param>
        /// <param name="systemOnlineManifest"></param>
        /// <param name="SystemManifest"></param>
        /// <param name="group"></param>
        internal static IEnumerable<LiveInfoSetting> GetSettings(LiveInfoConfig config)
        {
            try
            {
                return LiveInfoClient.GetSettings(config);
            }
            catch(XRLException ex)
            {
                if(ex.HResult == HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG)
                {
                    // Wrap this up in a mix errorr specifically for this.
                    throw new XRLException(
                        HResult.XONLINE_E_MIX_INVALID_CONFIG,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Invalid configuration while calling GetSettings.",
                        ex);
                }
                else
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Unknown error while calling GetSettings.  Check internal exception for details.",
                        ex);
                }
            }
        }

        #endregion

        #region SetSettings
        /// <summary>
        /// Definition for SetSettings
        /// </summary>
        /// <param name="config">The config for the setting to set</param>
        /// <param name="setting">The livehive setting to set</param>
        internal static void SetSetting(LiveInfoConfig config, LiveInfoSetting setting)
        {
            if(setting.Name == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Setting name was null for SetSetting");
            }

            if(setting.Name == String.Empty)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_EMPTY,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Setting name was empty string for SetSetting");
            }

            try
            {
                if(setting.Value != null)
                {
                    LiveInfoClient.SetSetting(config, setting);
                }
                else
                {
                    LiveInfoClient.RemoveSetting(config, setting);
                }
            }
            catch(XRLException ex)
            {
                if(ex.HResult == HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG)
                {
                    // Wrap this up in a mix errorr specifically for this.
                    throw new XRLException(
                        HResult.XONLINE_E_MIX_INVALID_CONFIG,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Invalid configuration while calling SetSetting.",
                        ex);
                }
                else
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "Unknown error while calling SetSettings.  Check internal exception for details.",
                        ex);
                }
            }
        }
        #endregion

        #region IngestEtxManifest

        private const string ELEMENT_RESULT = "result";
        private const string ELEMENT_CHECKPOINT = "checkpoint";
        private const string ELEMENT_ERROR_LIST = "errors";
        private const string ELEMENT_ERROR_ITEM = "item";
        private const string ELEMENT_ERROR_DESCRIPTION = "description";
        private const string ELEMENT_EXCEPTION = "exception";
        private const string ELEMENT_EXCEPTION_MESSAGE = "message";
        private const string ELEMENT_EXCEPTION_STACK = "stack";
        private const string ATTRIB_EXCEPTION_SITE = "site";

        /// <summary>
        /// Definition for IngestEtxManifest
        /// </summary>
        /// <param name="xmlManifest">The xml manifest to ingest as a string.</param>
        internal static string IngestEtxManifest(string xmlManifest)
        {
            EtxManifest manifest;
            XElement result;
            List<Blob> newProducers;
            List<Blob> updatedProducers;

            result = new XElement(ELEMENT_RESULT);

            if(string.IsNullOrEmpty(xmlManifest))
            {
                CreateError(result, "Etx manifest cannot be null or empty.");
                
                return result.ToString();
            }
            
            // Validate the input manifest during deserialization

            try
            {
                manifest = new EtxManifest(EtxLoader.NPDB.CreateValidatingReader((new StringReader(xmlManifest))));

                CreateCheckpoint(result, "Schema validation", "Completed etx manifest schema validation.");
            }
            catch(Exception ex)
            {
                CreateError(result, ex, "Error parsing input etx manifest.");

                return result.ToString();
            }

            // Generate a catalog of changes

            newProducers = new List<Blob>();
            updatedProducers = new List<Blob>();

            if (!TryGenerateChangeCatalog(result, newProducers, updatedProducers, manifest))
            {
                return result.ToString();
            }
            else
            {
                CreateCheckpoint(result, "Change catalog generation", "Completed change catalog, {0} new producers and {1} updated producers found.", newProducers.Count, updatedProducers.Count);
            }

            // Upload the etx manifest to npdb storage

            try
            {
                EtxLoader.NPDB.UploadManifest(manifest);

                CreateCheckpoint(result, "Etx manifest upload", "Completed etx manifest upload to npdb.");
            }
            catch (Exception ex)
            {
                CreateError(result, ex, "Error uploading etx manifest to npdb.");

                return result.ToString();
            }
            
            // Get virtual interfaces for vortexfd
            IInterfaceInfo[] vortexInterfaces;

            try
            {
                string[] vortexServers;

                vortexServers = Config.GetServerListByInterface(Interface.vortexfd);

                vortexInterfaces = vortexServers.Select(s => Config.GetInterface(s, Interface.vortexfd)).ToArray();

                CreateCheckpoint(result, "Vortex interface lookup", "Vortex interface information fetched, serverList '{0}'", string.Join(",", vortexServers));
            }
            catch (Exception ex)
            {
                CreateError(result, ex, "Error getting interface info for vortex frontdoor.");

                return result.ToString();
            }

            // Trigger vortex etx manifest update across all frontdoors
            if (!ForceVortexManifestUpdate(result, manifest, newProducers, updatedProducers, vortexInterfaces))
            {
                return result.ToString();
            }
            else
            {
                CreateCheckpoint(result, "Vortex updates complete", "Vortex etx manifest update successly across all servers");
            }
            
            return result.ToString();
        }

        private const string ELEMENT_CHANGES = "changes";
        private const string STATUS_NEW = "new";
        private const string STATUS_UPDATED = "updated";
        private const string STATUS_EXISTING = "existing";
        private const string ATTRIB_ACTION = "action";

        private static bool TryGenerateChangeCatalog(XElement root, List<Blob> newProducers, List<Blob> updatedProducers, EtxManifest manifest)
        {
            EtxManifest world;
            XElement changes;

            foreach (Producer producer in manifest.Producers)
            {
                foreach (Event ev in producer.Events)
                {
                    
                }
            }

            try
            {
                DateTime dt1, dt2;

                world = EtxLoader.NPDB.GetManifest(ProducerFetchMode.Normalized, out dt1, out dt2);

                CreateCheckpoint(root, "Etx manifest download from npdb", "Completed download of full ext manifest definition from npdb, {0} producers found", world.Producers.Count);
            }
            catch (Exception ex)
            {
                CreateError(root, ex, "Error downloading full etx manifest definition from npdb.");

                return false;
            }

            changes = new XElement(ELEMENT_CHANGES);

            // identifying new & modified producers
            foreach (Producer current in manifest.Producers)
            {
                if (world.Producers.Fingerprints.ContainsKey(current.Fingerprint))
                {
                    // existing producer, therefore all events are existing
                    changes.Add(GetProducerInformation(current, STATUS_EXISTING, e => STATUS_EXISTING));
                }
                else
                {
                    List<Producer> versions;

                    versions = world.Producers.Where(p => p.Symbol == current.Symbol).ToList();

                    if (versions.Count == 0)
                    {
                        // new producer, therefore all events are new
                        changes.Add(GetProducerInformation(current, STATUS_NEW, e => STATUS_NEW));

                        newProducers.Add(current.Fingerprint);
                    }
                    else
                    {
                        // updated producer, events may be new, existing, or updated
                        changes.Add(GetProducerInformation(
                            current,
                            STATUS_UPDATED, 
                            e =>
                            {
                                string result = STATUS_NEW;

                                foreach (Producer p in versions)
                                {
                                    if (p.Events.Fingerprints.ContainsKey(e.Fingerprint))
                                    {
                                        return STATUS_EXISTING;
                                    }
                                    else if (p.Events.Symbols.ContainsKey(e.Symbol))
                                    {
                                        result = STATUS_UPDATED;
                                    }
                                }

                                return result;
                            }));

                        updatedProducers.Add(current.Fingerprint);
                    }
                }
            }

            try
            {
                world.Merge(manifest);
            }
            catch (Exception ex)
            {
                CreateError(root, ex, "Failed to merge the new manifest with the current manifest in npdb due to conflicts.");

                return false;
            }

            root.Add(changes);

            return true;
        }

        private const string ATTRIB_STATUS = "status";
        private const string ATTRIB_SYMBOL = "symbol";
        private const string ATTRIB_LOGSTRINGID = "logstringid";
        private const string ATTRIB_FINGERPRINT = "fingerprint";
        private const string ATTRIB_DESCRIPTION = "description";
        private const string ATTRIB_ORDINAL = "ordinal";
        private const string ATTRIB_INDEX = "index";
        private const string ATTRIB_NAME = "name";
        private const string ATTRIB_INTYPE = "inType";
        private const string ATTRIB_OUTTYPE = "outType";
        private const string ATTRIB_OMNITUREVAR = "omnitureVar";
        private const string ATTRIB_AUTOVALUE = "autovalue";
        private const string ATTRIB_CATEGORY = "category";
        private const string ATTRIB_HEADERVERSION = "header";

        private const string ELEMENT_PRODUCER = "producer";
        private const string ELEMENT_EVENT_LIST = "events";
        private const string ELEMENT_EVENT = "event";
        private const string ELEMENT_FIELD_LIST = "fields";
        private const string ELEMENT_FIELD = "field";

        private static XElement GetProducerInformation(Producer current, string producerStatus, Func<Event, string> eventStatusFunc)
        {
            XElement producer;
            XElement events;

            producer = new XElement(ELEMENT_PRODUCER);

            producer.Add(new XAttribute(ATTRIB_STATUS, producerStatus));
            producer.Add(new XAttribute(ATTRIB_SYMBOL, current.Symbol));
            producer.Add(new XAttribute(ATTRIB_FINGERPRINT, current.Fingerprint));
            producer.Add(new XAttribute(ATTRIB_DESCRIPTION, current.Description));

            producer.Add(events = new XElement(ELEMENT_EVENT_LIST));

            foreach (Event ev in current.Events)
            {
                XElement item;
                XElement fields;

                // header fields are not propped - they should be empty at this point anway
                ev.HeaderFields.Clear();

                events.Add(item = new XElement(ELEMENT_EVENT));

                item.Add(new XAttribute(ATTRIB_STATUS, eventStatusFunc(ev)));
                item.Add(new XAttribute(ATTRIB_SYMBOL, ev.Symbol));
                item.Add(new XAttribute(ATTRIB_LOGSTRINGID, ev.LogStringId));
                item.Add(new XAttribute(ATTRIB_FINGERPRINT, ev.Fingerprint));
                item.Add(new XAttribute(ATTRIB_ORDINAL, ev.Ordinal));
                item.Add(new XAttribute(ATTRIB_INDEX, ev.Value));
                item.Add(new XAttribute(ATTRIB_DESCRIPTION, ev.Description));
                item.Add(new XAttribute(ATTRIB_CATEGORY, ev.Category));
                item.Add(new XAttribute(ATTRIB_HEADERVERSION, ev.HeaderVersion));
                
                item.Add(fields = new XElement(ELEMENT_FIELD_LIST));

                foreach (DataField df in ev.DataFields)
                {
                    XElement field;

                    fields.Add(field = new XElement(ELEMENT_FIELD));
                    field.Add(new XAttribute(ATTRIB_NAME, df.Name));
                    field.Add(new XAttribute(ATTRIB_ORDINAL, df.Ordinal));
                    if (null != df.AutoValue)
                    {
                        field.Add(new XAttribute(ATTRIB_AUTOVALUE, df.AutoValue));
                    }
                    field.Add(new XAttribute(ATTRIB_INTYPE, df.InType));
                    field.Add(new XAttribute(ATTRIB_OUTTYPE, df.OutType));
                    if (null != df.OmnitureVar)
                    {
                        field.Add(new XAttribute(ATTRIB_OMNITUREVAR, df.OmnitureVar));
                    }
                }
            }

            return producer;
        }

        private static XElement CreateCheckpoint(XElement root, string action, string descriptionFormat, params object[] args)
        {
            XElement result;

            result = new XElement(ELEMENT_CHECKPOINT,
                new XAttribute(ATTRIB_ACTION, action),
                string.Format(descriptionFormat, args));

            root.Add(result);

            return result;
        }

        private const string XMGMT_CMD_CACHEREFRESH = "configCacheRefresh";
        private const string XMGMT_CMD_ETXLIST = "etxList";

        private static bool ForceVortexManifestUpdate(XElement root, EtxManifest manifest, List<Blob> newProducers, List<Blob> updatedProducers, IInterfaceInfo[] vortexInterfaces)
        {
            foreach (IInterfaceInfo vi in vortexInterfaces)
            {
                XomAdminSession session = null;

                try
                {
                    string[] response;
                    HResult result;
                    int timeout;

                    session = new XomAdminSession(vi.IPAddress);

                    timeout = Config.GetIntSetting(Setting.mixsettingsmanagement_etx_vortex_mgmt_timeout_ms);

                    session.SendCommand(null, Component.vortexfd, XMGMT_CMD_CACHEREFRESH, timeout, out response, out result);
                    
                    if (result.IsFailure())
                    {
                        CreateError(root, "Vortex etx manifest cache update failed with code {0:X8} on server '{1}'. Response:\n {2}", result, vi.ServerName, string.Join("\n", response));

                        return false;
                    }

                    session.SendCommand(null, Component.vortexfd, XMGMT_CMD_ETXLIST, timeout, out response, out result);

                    if (result.IsSuccess())
                    {
                        if (newProducers.Count + updatedProducers.Count > 0)
                        {
                            if (!ValidateProducerList(root, vi.ServerName, manifest, newProducers, updatedProducers, response))
                            {
                                return false;
                            }
                            else
                            {
                                CreateCheckpoint(root, "Vortex cache updated with check", "Vortex etx manifest cache updated on server '{0}'. Server check passed, the new and updated producers have been loaded into the server cache for '{0}'.", vi.ServerName);
                            }
                        }
                        else
                        {
                            CreateCheckpoint(root, "Vortex cache updated without check", "Vortex etx manifest cache updated on server '{0}'. No server check performed since no new or updated producers were found.", vi.ServerName);
                        }
                    }
                    else
                    {
                        CreateError(root, "Vortex etx manifest cache list failed with code {0:X8} on server '{1}'. Response:\n {2}", result, vi.ServerName, string.Join("\n", response));
                    }
                }
                catch (Exception e)
                {
                    CreateError(root, e, "Unexpected error encountered while trying to update etx manifest cache for server '{0}'.", vi.ServerName);

                    return false;
                }
                finally
                {
                    if (null != session)
                    {
                        session.Close();
                    }
                }
            }

            return true;
        }

        private static bool ValidateProducerList(XElement root, string server, EtxManifest manifest, List<Blob> newProducers, List<Blob> updateProducers, string[] listing)
        {
            HashSet<Blob> union;
            string block;
            int index;
            
            union = new HashSet<Blob>(newProducers.Union(updateProducers));
            
            block = string.Join("\n", listing);

            index = block.IndexOf("FP=");

            // FORMAT in scan
            //   Symbol1 :: FP=FingerprintHex1\n
            //   Symbol2 :: FP=FingerprintHex2\n
            while (-1 != index)
            {
                int fingerprintEnd;

                index += 3; // Length of (FP=)
                fingerprintEnd = index;

                while (fingerprintEnd < block.Length - 1)
                {
                    if (char.IsWhiteSpace(block[fingerprintEnd]))
                    {
                        break;
                    }

                    fingerprintEnd++;
                }

                union.Remove(Blob.Parse(block.Substring(index, fingerprintEnd - index)));

                index = block.IndexOf("FP=", fingerprintEnd);
            }

            if (union.Count == 0)
            {
                // success, all items were found
                return true;
            }
            else
            {
                // not all items were found, indicate which items were left over
                StringBuilder errorMessage;

                errorMessage = new StringBuilder();
                
                errorMessage.AppendFormat("Vortex producer list for server '{0}' missing the following new or updated producers:", server);
                
                Array.ForEach(union.ToArray(), blob => errorMessage.AppendFormat("  {0}, {1}", manifest.Producers.Fingerprints[blob].Symbol, blob));

                CreateError(root, errorMessage.ToString());

                return false;
            }
        }

        private static XElement CreateError(XElement root, Exception e, string descriptionFormat, params object[] args)
        {
            XElement result;

            result = new XElement(ELEMENT_ERROR_LIST,
                new XElement(ELEMENT_ERROR_ITEM,
                    new XElement(ELEMENT_ERROR_DESCRIPTION, string.Format(descriptionFormat, args)),
                    new XElement(ELEMENT_EXCEPTION,
                        new XAttribute(ATTRIB_EXCEPTION_SITE, e.TargetSite),
                        new XElement(ELEMENT_EXCEPTION_MESSAGE, e.Message),
                        new XElement(ELEMENT_EXCEPTION_STACK, e.StackTrace))));

            root.Add(result);

            return result;
        }

        private static XElement CreateError(XElement root, string descriptionFormat, params object[] args)
        {
            XElement result;

            result = new XElement(ELEMENT_ERROR_LIST,
                new XElement(ELEMENT_ERROR_ITEM,
                    new XElement(ELEMENT_ERROR_DESCRIPTION, string.Format(descriptionFormat, args))));

            root.Add(result);

            return result;
        }

        #endregion

        public static void SetBusinessPartner(BusinessPartner bp)
        {
            DatabaseConfigurationProvider dcp = null;
            IEBBusinessPartner partner = null;
            bool bCreatedPartner = false;

            bp.Verify();

            GetConfigObjects(out dcp);

            foreach(IIEBBusinessPartner ip in dcp.IEBBusinessPartners.Values)
            {
                IEBBusinessPartner p = ip as IEBBusinessPartner;
                if(p.Id == bp.BusinessPartnerID)
                {
                    partner = p;
                }
            }

            if(partner != null)
            {
                if (partner.Type.Type == "Private")
                {
                    throw new XRLException
                        (HResult.XONLINE_E_MIX_PRIVATE_BUSINESS_PARTNER
                        , XEvent.Id.MIX_STS_CONFIGURATION_PRIVATE_BUSINESS_PARTNER
                        , "{0} {1} is a private Business Partner.  You cannot modify."
                        , partner.Id
                        , partner.Name
                        );
                }

                // Business partner exists.  Just update some fields.
                partner.Name = bp.FriendlyName;
                bCreatedPartner = false;
            }
            else
            {
                // Create new one!
                bCreatedPartner = true;
                partner = new IEBBusinessPartner();
                partner.Id = bp.BusinessPartnerID;
                partner.Name = bp.FriendlyName;
                if (!string.IsNullOrEmpty(bp.Type))
                {
                    partner.SetType(bp.Type);
                }


                byte[] saltBytes = new byte[20];
                Random r = new Random();
                r.NextBytes(saltBytes);
                partner.AnonymizingSalt = ((Blob)saltBytes).ToString();

                IEBBusinessPartnerKey key = new IEBBusinessPartnerKey(partner);

                key.MasterKeyVersion = Config.GetIntSetting(Setting.MasterKey_currentEncryptKeyVersion);
                key.KeyVersion = 1;
                key.SymmetricKey = new byte[20];
                r.NextBytes(key.SymmetricKey);
                key.SymmetricIV = new byte[20];
                r.NextBytes(key.SymmetricIV);

                partner.Keys.Add(key);
            }

            // Set connection info.
            partner.IEBPartnerConnectionInfoes.Clear();

            foreach(BusinessPartnerConnectionInfo bpci in bp.ConnectionInfos)
            {
                IEBPartnerConnectionInfo newConnInfo = new IEBPartnerConnectionInfo(partner);
                bpci.Verify();

                byte[] rawCertificate = Convert.FromBase64String(bpci.SGCertificate);

                // Here we make sure the cert if at least somewhat valid.
                newConnInfo.SecurityGatewayCertificate = new X509Certificate2(rawCertificate);
                newConnInfo.FriendlyName = bpci.FriendlyName;

                partner.IEBPartnerConnectionInfoes.Add(newConnInfo);
            }

            // Write it out, flush the config.
            try
            {
                DatabaseWriter.SetBusinessPartner(partner);
                DatabaseWriter.SetBusinessPartnerConnectionInfos(partner);

                if(bCreatedPartner)
                {
                    DatabaseWriter.SetBusinessPartnerKeys(partner);
                }
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR,
                        "Encountered an error writing the business partner and its connection infos to the database.  See inner exception for more details.",
                        e);
            }

            ForceSTSConfigurationReload();
        }

        public static void SetAppliesToInfo(STSAppliesTo at)
        {
            STSConfiguration stsconf;
            IEBBusinessPartner p;

            at.Verify();

            GetConfigObjects(out stsconf, out p, at.BusinessPartnerID);

            Dictionary<Uri, IAppliesToClaimType> claimTypes = new Dictionary<Uri, IAppliesToClaimType>();

            AppliesTo newAt = new AppliesTo();

            if (p.Type.Type == "Private")
            {
                throw new XRLException
                    ( HResult.XONLINE_E_MIX_PRIVATE_BUSINESS_PARTNER
                    , XEvent.Id.MIX_STS_CONFIGURATION_PRIVATE_BUSINESS_PARTNER
                    , "{0} {1} is a private Business Partner.  You cannot modify."
                    , p.Id
                    , p.Name
                    );
            }

            newAt.BusinessPartner = p;

            newAt.AppliesToUri = new Uri(at.AppliesToUri);
            newAt.ValidityInterval = at.ValidityInterval;

            if(!String.IsNullOrEmpty(at.AppliesToCertificate))
            {
                newAt.AppliesToCertificate = new X509Certificate2(Convert.FromBase64String(at.AppliesToCertificate));
            }

            if(!stsconf.TokenTypes.Keys.Contains(at.TokenType))
            {
                string exceptionString = string.Format(
                        "The token type {0} is unsupported",
                        at.TokenType);

                throw new XRLException(HResult.XONLINE_E_MIX_UNSUPPORTED_TOKEN_TYPE,
                        XEvent.Id.MIX_STS_CONFIGURATION_UNSUPPORTED_TOKEN_TYPE,
                        exceptionString);
            }

            newAt.TokenType = stsconf.TokenTypes[at.TokenType];

            foreach(STSAppliesToClaimType stsatct in at.ClaimTypes)
            {
                if(!stsconf.ClaimTypes.ContainsKey(stsatct.ClaimTypeUri))
                {
                    string exString = string.Format(
                            "{0} is not a valid claim type.",
                            stsatct.ClaimTypeUri);

                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_CLAIM_TYPE,
                            XEvent.Id.MIX_STS_CONFIGURATION_INVALID_CLAIM_TYPE,
                            exString);
                }


                if(!p.Claims.Contains(new Uri(stsatct.ClaimTypeUri)))
                {
                    string exString = string.Format(
                            "{0} is a private claim type.  You cannot use it.",
                            stsatct.ClaimTypeUri);

                    throw new XRLException(HResult.XONLINE_E_MIX_PRIVATE_CLAIM_TYPE,
                            XEvent.Id.MIX_STS_CONFIGURATION_PRIVATE_CLAIM_TYPE,
                            exString);
                }

                AppliesToClaimType atct = new AppliesToClaimType();
                atct.AppliesToUrl = new Uri(at.AppliesToUri);
                atct.ClaimTypeUri = new Uri(stsatct.ClaimTypeUri);
                atct.Required = stsatct.Required;
                newAt.ClaimTypes.Add(atct.ClaimTypeUri, atct);
            }

            try
            {
                DatabaseWriter.SetAppliesTo(newAt);
                DatabaseWriter.SetAppliesToClaimTypes(newAt);
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR,
                        "Error writing appliesto and claim types to the database.  See inner exception for more detail.",
                        e);
            }

            ForceSTSConfigurationReload();
        }

        public static void RemoveAppliesToInfo(string appliesToUri)
        {
            try
            {
                DatabaseWriter.RemoveAppliesTo(appliesToUri);
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR,
                        "Error removing the appliesto from the database.  See inner exception for more details.",
                        e);
            }

            ForceSTSConfigurationReload();
        }

        public static STSAppliesTo GetAppliesToInfo(string appliesToUri)
        {
            STSAppliesTo sat = new STSAppliesTo();
            List<STSAppliesToClaimType> claimTypes = new List<STSAppliesToClaimType>();
            STSConfiguration stsconf;

            GetConfigObjects(out stsconf);

            if(!stsconf.AppliesToes.Keys.Contains(new Uri(appliesToUri)))
            {
                string exString = string.Format(
                        "The appliesto url: {0} isn't configured.",
                        appliesToUri);

                throw new XRLException(HResult.XONLINE_E_MIX_APPLIES_TO_DOES_NOT_EXIST,
                        XEvent.Id.MIX_STS_CONFIGURATION_APPLIES_TO_DOES_NOT_EXIST,
                        exString);
            }

            IAppliesTo iat = stsconf.AppliesToes[new Uri(appliesToUri)];

            IEBBusinessPartner bp = iat.BusinessPartner as IEBBusinessPartner;
            sat.BusinessPartnerID = bp.Id;
            sat.AppliesToUri = iat.AppliesToUri.ToString();

            if(iat.AppliesToCertificate != null)
            {
                sat.AppliesToCertificate = Convert.ToBase64String(iat.AppliesToCertificate.RawData);
            }

            sat.ValidityInterval = iat.ValidityInterval;
            sat.TokenType = iat.TokenType.Uri.ToString();

            foreach(IAppliesToClaimType iact in iat.ClaimTypes.Values)
            {
                STSAppliesToClaimType newCT = new STSAppliesToClaimType();
                newCT.ClaimTypeUri = iact.ClaimTypeUri.ToString();
                newCT.Required = iact.Required;

                claimTypes.Add(newCT);
            }

            sat.ClaimTypes = claimTypes.ToArray();
            return sat;
        }

        // Omit Business Partner Type = "Private" from the Mix enumeration
        // GDNP should not be used to maintain "private" Business Partner appliest to's
        public static string[] GetBusinessPartnerTypes()
        {
            STSConfiguration stsconf;

            GetConfigObjects(out stsconf);

            List<string> bpTypes = new List<string>();

            foreach (string type in stsconf.BusinessPartnerTypes)
            {
                if ("Private" != type)
                {
                    bpTypes.Add(type);
                }
            }

            return bpTypes.ToArray();
        }

        public static STSClaimTypeInfo[] GetClaimTypes()
        {
            List<STSClaimTypeInfo> claimTypes = new List<STSClaimTypeInfo>();

            STSConfiguration stsconf;

            GetConfigObjects(out stsconf);

            foreach (IIEBBusinessPartnerTypeClaimType bptct in stsconf.BusinessPartnerTypeCaimTypes)
            {
                if (bptct.BusinessPartnerType == "Partner")
                {
                    IClaimType ict = stsconf.ClaimTypes[bptct.ClaimTypeUri.ToString()];

                    STSClaimTypeInfo ct = new STSClaimTypeInfo();
                    ct.ClaimTypeUri = ict.ClaimTypeUri.ToString();
                    ct.Encrypted = ict.Encrypted;
                    ct.Title = ict.Title;
                    ct.Description = ict.Description;
                    ct.ValueType = ict.ValueType;

                    claimTypes.Add(ct);
                }
            }

            return claimTypes.ToArray();
        }

        // Business Partner Type = "Private" should never be called by Mix as it 
        // is omitted from the Business Partner Tyep enumeration for Mix
        public static STSClaimTypeInfo[] GetClaimTypes(string businessPartnerType)
        {
            List<STSClaimTypeInfo> claimTypes = new List<STSClaimTypeInfo>();

            STSConfiguration stsconf;

            GetConfigObjects(out stsconf);

            foreach (IIEBBusinessPartnerTypeClaimType bptct in stsconf.BusinessPartnerTypeCaimTypes)
            {
                if (bptct.BusinessPartnerType == businessPartnerType)
                {
                    IClaimType ict = stsconf.ClaimTypes[bptct.ClaimTypeUri.ToString()];

                    STSClaimTypeInfo ct = new STSClaimTypeInfo();
                    ct.ClaimTypeUri = ict.ClaimTypeUri.ToString();
                    ct.Encrypted = ict.Encrypted;
                    ct.Title = ict.Title;
                    ct.Description = ict.Description;
                    ct.ValueType = ict.ValueType;

                    claimTypes.Add(ct);
                }
            }

            return claimTypes.ToArray();
        }

        public static string[] GetTokenTypes()
        {
            STSConfiguration stsconf;

            GetConfigObjects(out stsconf);

            List<string> tokenTypes = new List<string>();

            foreach(ITokenType itt in stsconf.TokenTypes.Values)
            {
                tokenTypes.Add(itt.Uri.ToString());
            }

            return tokenTypes.ToArray();
        }

        private static void GetConfigObjects(out DatabaseConfigurationProvider dcp)
        {
            try
            {
                dcp = new DatabaseConfigurationProvider();
                dcp.Load();
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED,
                        "Failed loading the STS configuration data from the database.  See inner exception for more details.",
                        e);
            }
        }

        private static void GetConfigObjects(out STSConfiguration stsconf)
        {
            DatabaseConfigurationProvider dcp = null;

            GetConfigObjects(out dcp);

            stsconf = dcp.STSConfiguration as STSConfiguration;
        }

        private static void GetConfigObjects(out STSConfiguration stsconf, out IEBBusinessPartner partner, Guid partnerID)
        {
            DatabaseConfigurationProvider dcp = null;
            partner = null;

            GetConfigObjects(out dcp);

            stsconf = dcp.STSConfiguration as STSConfiguration;

            foreach(IIEBBusinessPartner ip in dcp.IEBBusinessPartners.Values)
            {
                IEBBusinessPartner p = ip as IEBBusinessPartner;
                if(p.Id == partnerID)
                {
                    partner = p;
                }
            }

            if(partner == null)
            {
                string exString = string.Format(
                        "The business partner with ID {0} doesn't exist.",
                        partnerID);

                throw new XRLException(HResult.XONLINE_E_MIX_BUSINESS_PARTNER_DOES_NOT_EXIST,
                        XEvent.Id.MIX_STS_CONFIGURATION_PARTNER_DOES_NOT_EXIST,
                        exString);
            }
        }

        private static void ForceSTSConfigurationReload()
        {
            try
            {
                MixUtilities.ResetFrontDoor(Interface.liveinfo, "", "liveinfo", "reloadnacl", 200);
            }
            catch (System.Exception e)
            {
                Xom.NtEvent(XEvent.Id.MIX_STS_CONFIGURATION_RELOAD_FAILED, e, "Liveinfo STS Configuration reload failed.  Some servers may have stale configuration data.");
            }

            try
            {
                MixUtilities.ResetFrontDoor(Interface.xsts, "", "xsts", "reload", 200);
            }
            catch (System.Exception e)
            {
                Xom.NtEvent(XEvent.Id.MIX_STS_CONFIGURATION_RELOAD_FAILED, e, "XSTS Configuration reload failed.  Some servers may have stale configuration data.");
            }

            // Sts v1 is now using XSts configuration data as well
            try
            {
                MixUtilities.ResetFrontDoor(Interface.sts, "", "sts", "reload", 1000);
            }
            catch (System.Exception e)
            {
                Xom.NtEvent(XEvent.Id.MIX_STS_CONFIGURATION_RELOAD_FAILED, e, "STS Configuration reload failed.  Some servers may have stale configuration data.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsManagementV2.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.mix.common;
using xonline.server.webcache.common;
using xonline.mix.settingsmanagement.contract;
using xonline.common.mgmt;
using xonline.server.liveinfo.client;

namespace xonline.mix.settingsmanagement.service
{
    // NOTE: If you change the class name "MixSettingsManagement" here, you must also update the reference to "MixSettingsManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixSettingsManagementV2 : IMixSettingsManagementV2
    {
        public IEnumerable<LiveHiveSettingV2> GetSettings(LiveHiveConfigV2 config)
        {
            List<LiveHiveSettingV2> ret = new List<LiveHiveSettingV2>();

            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetSettingsApiName, "V2");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "ResultCount"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetSettingsApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert the config
                LiveInfoConfig lic = MixSettingsDataTypeFactory.Convert(config);

                // Run the call and convert the results
                foreach(LiveInfoSetting setting in MixSettingsManagement.GetSettings(lic))
                {
                    ret.Add(MixSettingsDataTypeFactory.ConvertV2(setting));
                }

                logHelper.SetCountField("ResultCount", ret);
            });

            return ret;
        }

        public void SetSetting(LiveHiveConfigV2 config, LiveHiveSettingV2 setting)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetSettingApiName, "V2");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "SettingName", "SettingValue"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                if (setting!=null)
                {
                    logHelper.SetField("SettingName", setting.Name);
                    logHelper.SetStringField("SettingValue", setting.Value, 200);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetSettingApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                LiveInfoConfig cfg = MixSettingsDataTypeFactory.Convert(config);
                LiveInfoSetting set = MixSettingsDataTypeFactory.Convert(setting);

                MixSettingsManagement.SetSetting(cfg, set);
            });
        }

        public string IngestEtxManifest(string xmlManifest)
        {
            string ret=null;

            LogHelper logHelper=new LogHelper(MixSettingsManagement.IngestEtxManifestApiName, "V2");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"XmlManifest", "Return"});
                logHelper.SetStringField("XmlManifest", xmlManifest, 100);

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.IngestEtxManifestApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                ret=MixSettingsManagement.IngestEtxManifest(xmlManifest);

                logHelper.SetStringField("Return", ret, 100);
            });

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsDataTypeFactoryV4.cs ===
ï»¿
using System;
using xonline.mix.settingsmanagement.contract;
using System.Data;
using xonline.common.service;
using System.Collections.Generic;
using System.Linq;
using xonline.common.content;
using System.Collections;
using System.Text;

using xonline.server.liveinfo.client;

namespace xonline.mix.settingsmanagement.service
{
    public class BusinessPartnerType
    {
        public string Type;
    }

    public static partial class MixSettingsDataTypeFactory
    {
        public static LiveInfoSetting Convert(LiveHiveSettingV4 lisV4)
        {
            if (lisV4 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveHiveSetting was null.");
            }

            LiveInfoSetting set = new LiveInfoSetting();

            if (lisV4.Config != null) // This could be null for a call to SetSetting
            {
                set.Config = Convert(lisV4.Config);
            }

            set.Name = lisV4.Name;
            set.Value = lisV4.Value;

            return set;
        }

        public static LiveInfoConfig Convert(LiveHiveConfigV4 lhcV4)
        {
            if (lhcV4 == null)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MIX_ARGUMENT_NULL,
                        XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                        "LiveInfoConfig was null.");
            }

            LiveInfoConfig lic = new LiveInfoConfig();

            lic.Platform = Convert(lhcV4.Platform);
            lic.Build = lhcV4.Build;
            lic.Qfe = lhcV4.Qfe;
            lic.BetaGroupId = lhcV4.BetaGroupId;

            return lic;
        }

        public static LiveHiveConfigV4 ConvertV4(LiveInfoConfig lic)
        {
            LiveHiveConfigV4 lvc = new LiveHiveConfigV4();

            lvc.Platform = ConvertV4(lic.Platform);
            lvc.Build = lic.Build;
            lvc.Qfe = lic.Qfe;
            lvc.BetaGroupId = lic.BetaGroupId;

            return lvc;
        }

        public static LiveInfoConfig.PlatformType Convert(PlatformTypeV4 plat)
        {
            switch (plat)
            {
                case PlatformTypeV4.Xenon:
                    return LiveInfoConfig.PlatformType.xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV1), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }

        public static LiveHiveSettingV4 ConvertV4(LiveInfoSetting lis)
        {
            LiveHiveSettingV4 lhs = new LiveHiveSettingV4();
            lhs.Config = ConvertV4(lis.Config);
            lhs.Name = lis.Name;
            lhs.Value = lis.Value;

            return lhs;
        }

        public static PlatformTypeV4 ConvertV4(LiveInfoConfig.PlatformType plat)
        {
            // We only support Xenon for now.
            //
            switch (plat)
            {
                case LiveInfoConfig.PlatformType.xenon:
                    return PlatformTypeV4.Xenon;
                default:
                    string exceptionString = String.Format(
                            "Call had an invalid parameter for this version. {0} is not supported",
                            Enum.GetName(typeof(PlatformTypeV4), plat));

                    throw new XRLException(
                            HResult.XONLINE_E_MIX_INVALID_PLATFORM,
                            XEvent.Id.MIX_SETTINGS_INVALID_ARGUMENT,
                            exceptionString);
            }
        }

        public static BusinessPartner Convert(BusinessPartnerV4 bpV4)
        {
            BusinessPartner bp = new BusinessPartner();
            bp.BusinessPartnerID = bpV4.BusinessPartnerID;
            bp.FriendlyName = bpV4.FriendlyName;
            bp.Type = bpV4.Type;
            bp.ConnectionInfos = ConvertAll(bpV4.ConnectionInfos);

            return bp;
        }

        public static BusinessPartnerV4 ConvertV4(BusinessPartner bp)
        {
            BusinessPartnerV4 bpV4 = new BusinessPartnerV4();
            bpV4.BusinessPartnerID = bp.BusinessPartnerID;
            bpV4.FriendlyName = bp.FriendlyName;
            bpV4.Type = bp.Type;
            bpV4.ConnectionInfos = ConvertAllV4(bp.ConnectionInfos);

            return bpV4;
        }

        public static BusinessPartnerConnectionInfo[] ConvertAll(BusinessPartnerConnectionInfoV4[] connInfoV4)
        {
            List<BusinessPartnerConnectionInfo> connList = new List<BusinessPartnerConnectionInfo>();

            foreach (BusinessPartnerConnectionInfoV4 pciV4 in connInfoV4)
            {
                connList.Add(Convert(pciV4));
            }

            return connList.ToArray();
        }

        public static BusinessPartnerConnectionInfoV4 ConvertV4(BusinessPartnerConnectionInfo connInfo)
        {
            BusinessPartnerConnectionInfoV4 bpciV4 = new BusinessPartnerConnectionInfoV4();
            bpciV4.FriendlyName = connInfo.FriendlyName;
            bpciV4.SGCertificate = connInfo.SGCertificate;
            return bpciV4;
        }

        public static BusinessPartnerConnectionInfoV4[] ConvertAllV4(BusinessPartnerConnectionInfo[] connInfo)
        {
            List<BusinessPartnerConnectionInfoV4> connListV4 = new List<BusinessPartnerConnectionInfoV4>();

            foreach (BusinessPartnerConnectionInfo pci in connInfo)
            {
                connListV4.Add(ConvertV4(pci));
            }

            return connListV4.ToArray();
        }

        public static BusinessPartnerConnectionInfo Convert(BusinessPartnerConnectionInfoV4 connInfoV4)
        {
            BusinessPartnerConnectionInfo bpci = new BusinessPartnerConnectionInfo();
            bpci.FriendlyName = connInfoV4.FriendlyName;
            bpci.SGCertificate = connInfoV4.SGCertificate;
            return bpci;
        }

        public static STSAppliesTo Convert(STSAppliesToV4 atV4)
        {
            STSAppliesTo at = new STSAppliesTo();
            at.BusinessPartnerID = atV4.BusinessPartnerID;
            at.AppliesToUri = atV4.AppliesToUri;
            at.ValidityInterval = atV4.ValidityInterval;
            at.TokenType = atV4.TokenType;
            at.ClaimTypes = ConvertAll(atV4.ClaimTypes);
            at.AppliesToCertificate = atV4.AppliesToCertificate;

            return at;
        }

        public static STSAppliesToV4 ConvertV4(STSAppliesTo at)
        {
            STSAppliesToV4 atV4 = new STSAppliesToV4();
            atV4.BusinessPartnerID = at.BusinessPartnerID;
            atV4.AppliesToUri = at.AppliesToUri;
            atV4.ValidityInterval = at.ValidityInterval;
            atV4.TokenType = at.TokenType;
            atV4.ClaimTypes = ConvertAllV4(at.ClaimTypes);
            atV4.AppliesToCertificate = at.AppliesToCertificate;

            return atV4;
        }

        public static STSAppliesToClaimType Convert(STSAppliesToClaimTypeV4 atctV4)
        {
            STSAppliesToClaimType atct = new STSAppliesToClaimType();
            atct.ClaimTypeUri = atctV4.ClaimTypeUri;
            atct.Required = atctV4.Required;
            return atct;
        }

        public static STSAppliesToClaimType[] ConvertAll(STSAppliesToClaimTypeV4[] claimTypesV4)
        {
            List<STSAppliesToClaimType> claimTypes = new List<STSAppliesToClaimType>();

            foreach (STSAppliesToClaimTypeV4 atctV4 in claimTypesV4)
            {
                claimTypes.Add(Convert(atctV4));
            }

            return claimTypes.ToArray();
        }

        public static STSAppliesToClaimTypeV4 ConvertV4(STSAppliesToClaimType atct)
        {
            STSAppliesToClaimTypeV4 atctV4 = new STSAppliesToClaimTypeV4();
            atctV4.ClaimTypeUri = atct.ClaimTypeUri;
            atctV4.Required = atct.Required;
            return atctV4;
        }

        public static STSAppliesToClaimTypeV4[] ConvertAllV4(STSAppliesToClaimType[] claimTypes)
        {
            List<STSAppliesToClaimTypeV4> claimTypesV4 = new List<STSAppliesToClaimTypeV4>();

            foreach (STSAppliesToClaimType atct in claimTypes)
            {
                claimTypesV4.Add(ConvertV4(atct));
            }

            return claimTypesV4.ToArray();
        }

        public static STSClaimTypeInfoV4 ConvertV4(STSClaimTypeInfo cti)
        {
            STSClaimTypeInfoV4 ctiV4 = new STSClaimTypeInfoV4();
            ctiV4.ClaimTypeUri = cti.ClaimTypeUri;
            ctiV4.Encrypted = cti.Encrypted;
            ctiV4.Title = cti.Title;
            ctiV4.Description = cti.Description;
            ctiV4.ValueType = cti.ValueType;

            return ctiV4;
        }

        public static STSClaimTypeInfoV4[] ConvertAllV4(STSClaimTypeInfo[] claimTypes)
        {
            List<STSClaimTypeInfoV4> claimTypeInfoV4 = new List<STSClaimTypeInfoV4>();

            foreach (STSClaimTypeInfo cti in claimTypes)
            {
                claimTypeInfoV4.Add(ConvertV4(cti));
            }

            return claimTypeInfoV4.ToArray();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\ProductManagement\Service\MixProductManagement.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.ServiceModel;
using System.Text;
using System.Data.Objects.DataClasses;
using xonline.mix.productmanagement.contract;
using xonline.mix.common;
using xonline.common.config;
using xonline.common.service;
using xonline.common.marketplace.catalog;

namespace xonline.mix.productmanagement.service
{
    public class MixProductManagement
    {
        public static readonly string ConfigureProductApiName = "ProductManagement.ConfigureProduct";
        public static readonly string GetProductApiName = "ProductManagement.GetProduct";

        #region GetProduct

        /// <summary>
        /// Called into from Content Ingestion Mix API
        /// Returns a Data Contract object 
        /// </summary>
        /// <param name="id">Guid</param>
        static public ProductV1 GetProduct(Guid id)
        {
            RawCatalogDBEntities catalog = null;

            try
            {
                catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);

                // Finding the instance of the media
                Media catalogMedia = catalog.GetPrimitiveMediaOrThrow(id);

                if (catalogMedia.MediaType == null && !catalogMedia.MediaTypeReference.IsLoaded)
                {
                    catalogMedia.MediaTypeReference.Load();
                }

                switch (catalogMedia.MediaType.mediaTypeId)
                {
                    // Game
                    case (int)CatalogConstants.MediaTypeEnum.Game:
                    case (int)CatalogConstants.MediaTypeEnum.XboxOriginalGame:
                    case (int)CatalogConstants.MediaTypeEnum.ArcadeGame:
                    case (int)CatalogConstants.MediaTypeEnum.XNACommunityGame:
                    case (int)CatalogConstants.MediaTypeEnum.FullGame:
                    case (int)CatalogConstants.MediaTypeEnum.GamePackagedVideo:
                    case (int)CatalogConstants.MediaTypeEnum.LegacyXbox1Game:
                    case (int)CatalogConstants.MediaTypeEnum.PCGame:
                    case (int)CatalogConstants.MediaTypeEnum.ServerBackedGames:
                    case (int)CatalogConstants.MediaTypeEnum.Marketplace:
                    case (int)CatalogConstants.MediaTypeEnum.LiveApp:
                    case (int)CatalogConstants.MediaTypeEnum.WebGame:
                    case (int)CatalogConstants.MediaTypeEnum.MobileGame:
                        GameV1 mixGame = new GameV1();
                        LoadProductInfo(catalog, mixGame, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixGame, catalogMedia);
                        LoadProductBaseInfo(catalog, mixGame, catalogMedia);
                        LoadGameAttributes(catalog, mixGame);
                        LoadProductPackageInfo(catalog, mixGame);
                        LoadGame(catalog, mixGame, catalogMedia);
                        LoadGameLocalizedData(catalog, mixGame, catalogMedia);
                        LoadVideoPreviewInfo(catalog, mixGame);
                        mixGame.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixGame;

                    // App
                    case (int)CatalogConstants.MediaTypeEnum.App:
                        AppV1 mixApp = new AppV1();
                        LoadProductInfo(catalog, mixApp, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixApp, catalogMedia);
                        LoadProductBaseInfo(catalog, mixApp, catalogMedia);
                        LoadProductAttributes(catalog, mixApp);
                        LoadAppPackageInfo(catalog, mixApp);
                        LoadApp(catalog, mixApp, catalogMedia);
                        LoadAppLocalizedData(catalog, mixApp, catalogMedia);
                        mixApp.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixApp;

                    //	Game Content
                    case (int)CatalogConstants.MediaTypeEnum.GameContent:
                    case (int)CatalogConstants.MediaTypeEnum.Theme:
                    case (int)CatalogConstants.MediaTypeEnum.GameTrial:
                    case (int)CatalogConstants.MediaTypeEnum.GameDemo:
                    case (int)CatalogConstants.MediaTypeEnum.GamerTile:
                    case (int)CatalogConstants.MediaTypeEnum.GameVideo:
                    case (int)CatalogConstants.MediaTypeEnum.GameTrailer:
                    case (int)CatalogConstants.MediaTypeEnum.MobilePDLC:
                        GameContentV1 mixGameContent = new GameContentV1();
                        LoadProductInfo(catalog, mixGameContent, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixGameContent, catalogMedia);
                        LoadProductBaseInfo(catalog, mixGameContent, catalogMedia);
                        LoadGameContent(catalog, mixGameContent, catalogMedia);
                        mixGameContent.LocalizedData = GetLocalizedData(catalog, catalogMedia);
                        LoadProductPackageInfo(catalog, mixGameContent);
                        mixGameContent.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixGameContent;

                    //	Game Consumable
                    case (int)CatalogConstants.MediaTypeEnum.GameConsumable:
                    case (int)CatalogConstants.MediaTypeEnum.MobileConsumable:
                        GameConsumableV1 mixGameConsumable = new GameConsumableV1();
                        LoadProductInfo(catalog, mixGameConsumable, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixGameConsumable, catalogMedia);
                        LoadProductBaseInfo(catalog, mixGameConsumable, catalogMedia);
                        LoadGameContent(catalog, mixGameConsumable, catalogMedia);
                        mixGameConsumable.LocalizedData = GetLocalizedData(catalog, catalogMedia);
                        LoadProductPackageInfo(catalog, mixGameConsumable);
                        LoadGameConsumable(catalog, mixGameConsumable);
                        mixGameConsumable.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixGameConsumable;
                    //image
                    case (int)CatalogConstants.MediaTypeEnum.Poster:
                    case (int)CatalogConstants.MediaTypeEnum.Image:
                    case (int)CatalogConstants.MediaTypeEnum.BoxArt:
                    case (int)CatalogConstants.MediaTypeEnum.ArtistPicture:
                    case (int)CatalogConstants.MediaTypeEnum.ScreenShot:
                    case (int)CatalogConstants.MediaTypeEnum.AlbumArt:
                    case (int)CatalogConstants.MediaTypeEnum.BackgroundArt:
                    case (int)CatalogConstants.MediaTypeEnum.SlideshowPreviewImage:
                        ImageV1 mixImage = new ImageV1();
                        LoadProductInfo(catalog, mixImage, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixImage, catalogMedia);
                        LoadImageInfo(catalog, mixImage);
                        return mixImage;

                    //	Avatar Item               
                    case (int)CatalogConstants.MediaTypeEnum.AvatarItem:
                        AvatarItemV1 mixAvatarItem = new AvatarItemV1();
                        LoadProductInfo(catalog, mixAvatarItem, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixAvatarItem, catalogMedia);
                        LoadProductBaseInfo(catalog, mixAvatarItem, catalogMedia);
                        LoadGameContent(catalog, mixAvatarItem, catalogMedia);
                        mixAvatarItem.LocalizedData = GetLocalizedData(catalog, catalogMedia);
                        LoadProductPackageInfo(catalog, mixAvatarItem);
                        LoadAvatarItem(catalog, mixAvatarItem);
                        mixAvatarItem.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixAvatarItem;

                    //  Bundles
                    case (int)CatalogConstants.MediaTypeEnum.Bundle:
                        BundleV1 mixBundle = new BundleV1();
                        LoadProductInfo(catalog, mixBundle, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixBundle, catalogMedia);
                        LoadBundleInfo(catalog, mixBundle, catalogMedia);
                        mixBundle.SearchInformation = GetSearchInformation(catalog, catalogMedia);
                        return mixBundle;

                    //  PointsBundles
                    case (int)CatalogConstants.MediaTypeEnum.PointsBundle:
                        PointsBundleV1 mixPointsBundle = new PointsBundleV1();
                        LoadProductBaseInfo(catalog, mixPointsBundle, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixPointsBundle, catalogMedia);
                        LoadPointsBundleInfo(catalog, mixPointsBundle, catalogMedia);
                        return mixPointsBundle;

                    //  Live SubscriptionFamily
                    case (int)CatalogConstants.MediaTypeEnum.LiveSubscriptionFamily:
                        LiveSubscriptionFamilyV1 mixLiveSubscriptionFamily = new LiveSubscriptionFamilyV1();
                        LoadProductBaseInfo(catalog, mixLiveSubscriptionFamily, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixLiveSubscriptionFamily, catalogMedia);
                        LoadSubscriptionFamilyInfo(catalog, catalogMedia, mixLiveSubscriptionFamily);
                        LoadLiveSubscriptionFamily(catalog, catalogMedia, mixLiveSubscriptionFamily);
                        return mixLiveSubscriptionFamily;

                    //  Game SubscriptionFamily
                    case (int)CatalogConstants.MediaTypeEnum.GameSubscriptionFamily:
                        GameSubscriptionFamilyV1 mixGameSubscriptionFamily = new GameSubscriptionFamilyV1();
                        LoadProductBaseInfo(catalog, mixGameSubscriptionFamily, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixGameSubscriptionFamily, catalogMedia);
                        LoadSubscriptionFamilyInfo(catalog, catalogMedia, mixGameSubscriptionFamily);
                        return mixGameSubscriptionFamily;

                    //  Addon SubscriptionFamily
                    case (int)CatalogConstants.MediaTypeEnum.AddonSubscriptionFamily:
                        AddonSubscriptionFamilyV1 mixAddonSubscriptionFamily = new AddonSubscriptionFamilyV1();
                        LoadProductBaseInfo(catalog, mixAddonSubscriptionFamily, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixAddonSubscriptionFamily, catalogMedia);
                        LoadSubscriptionFamilyInfo(catalog, catalogMedia, mixAddonSubscriptionFamily);
                        return mixAddonSubscriptionFamily;

                    //  Addon Subscription
                    case (int)CatalogConstants.MediaTypeEnum.AddonSubscription:
                        AddonSubscriptionV1 mixAddonSubscription = new AddonSubscriptionV1();
                        LoadProductBaseInfo(catalog, mixAddonSubscription, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixAddonSubscription, catalogMedia);
                        LoadSubscriptionInfo(catalog, catalogMedia, mixAddonSubscription);
                        return mixAddonSubscription;

                    //  Game SubscriptionFamily
                    case (int)CatalogConstants.MediaTypeEnum.GameSubscription:
                        GameSubscriptionV1 mixGameSubscription = new GameSubscriptionV1();
                        LoadProductBaseInfo(catalog, mixGameSubscription, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixGameSubscription, catalogMedia);
                        LoadSubscriptionInfo(catalog, catalogMedia, mixGameSubscription);
                        return mixGameSubscription;

                    //  Live SubscriptionFamily
                    case (int)CatalogConstants.MediaTypeEnum.LiveSubscription:
                        LiveSubscriptionV1 mixLiveSubscription = new LiveSubscriptionV1();
                        LoadProductBaseInfo(catalog, mixLiveSubscription, catalogMedia);
                        LoadMediaBaseInfo(catalog, mixLiveSubscription, catalogMedia);
                        LoadSubscriptionInfo(catalog, catalogMedia, mixLiveSubscription);
                        return mixLiveSubscription;
                }//end switch
            }
            catch (System.Data.EntityException ex)
            {
                if (ex.InnerException != null)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR, XEvent.Id.MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR, string.Format("Entity Framework Model does not match up to the current catalog schema.  Exception generating entities from SQL {0}", ex.InnerException.Message), true);
                }

                throw new XRLException(HResult.XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR, XEvent.Id.MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR, string.Format("Entity Framework Model does not match up to the current catalog schema.  Exception generating entities from SQL {0}", ex.Message), true);
            }
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_GETPRODUCT, "Product " + id.ToString() + " is not of valid Data Contract type", false);
        }//end GetProduct



        /// <summary>
        /// Loads the avatar speicific values into AvatarItem
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="avatarItem"></param>
        static private void LoadAvatarItem(RawCatalogDBEntities catalog, AvatarItemV1 mixAvatarItem)
        {
            GameContentAvatarItem catalogGameContentAvatarItem = catalog.GetPrimitiveGameContentAvatarItem(mixAvatarItem.ProductId);
            
            if (catalogGameContentAvatarItem.AvatarBodyType == null && !catalogGameContentAvatarItem.AvatarBodyTypeReference.IsLoaded)
            {
                catalogGameContentAvatarItem.AvatarBodyTypeReference.Load();
            }
            mixAvatarItem.BodyType = catalogGameContentAvatarItem.AvatarBodyType.avatarBodyTypeId;
            mixAvatarItem.AssetId = catalogGameContentAvatarItem.avatarItemAssetId;

        }


        
        /// <summary>
        /// Loads the GameConsumable speicific values into GameConsumable Product
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="avatarItem"></param>
        static private void LoadGameConsumable(RawCatalogDBEntities catalog, GameConsumableV1 mixGameConsumable)
        {
            GameConsumable catalogGameConsumable = catalog.GetPrimitiveGameConsumable(mixGameConsumable.ProductId);

            mixGameConsumable.AssetId = catalogGameConsumable.liveTitleAssetId;
        }
        

        /// <summary>
        /// Sets the ProductItem information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixProduct">ProductItemV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadProductInfo(RawCatalogDBEntities catalog, ProductV1 mixProduct, Media catalogMedia)
        {
            mixProduct.ProductId = catalogMedia.mediaId;
        }//end LoadProductInfo

        /// <summary>
        /// Sets the MediaBase information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadMediaBaseInfo(RawCatalogDBEntities catalog, MediaBaseV1 mixMediaBase, Media catalogMedia)
        {
            if (catalogMedia.VisibilityStatus == null && !catalogMedia.VisibilityStatusReference.IsLoaded)
            {
                catalogMedia.VisibilityStatusReference.Load();
            }

            mixMediaBase.ProductId = catalogMedia.mediaId;
            mixMediaBase.VisibilityDate = catalogMedia.visibilityDate;
            mixMediaBase.VisibilityStatus = catalogMedia.VisibilityStatus.visibilityStatusId;

            MediaRevenueSku mrs = catalog.GetPrimitiveMediaRevenueSku(mixMediaBase.ProductId);
            if (mrs != null)
            {
                mixMediaBase.Sku = mrs.revenueSku;
            }
        }//end LoadMediaBaseInfo

        /// <summary>
        /// Sets the ProductBase information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixProductBase">ProductBaseV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadProductBaseInfo(RawCatalogDBEntities catalog, ProductBaseV1 mixProductBase, Media catalogMedia)
        {
            mixProductBase.ReleaseDate = catalogMedia.originalReleaseDate;
            mixProductBase.GeoCheckPolicy = true;
            if (catalogMedia.geoCheckPolicy == 0)
            {
                mixProductBase.GeoCheckPolicy = false;
            }

            MediaRating[] mediaRatings = catalog.GetPrimitiveMediaRatings(catalogMedia.mediaId);
            mixProductBase.Ratings = new int[mediaRatings.Length];
            for (int i = 0; i < mediaRatings.Length; i++)
            {
                mixProductBase.Ratings[i] = mediaRatings[i].ratingValueId;
            }

            MediaRatingDescriptor[] mediaRatingDescriptors = catalog.GetPrimitiveMediaRatingDescriptors(catalogMedia.mediaId);
            mixProductBase.RatingDescriptors = new int[mediaRatingDescriptors.Length];
            for (int i = 0; i < mediaRatingDescriptors.Length; i++)
            {
                mixProductBase.RatingDescriptors[i] = mediaRatingDescriptors[i].ratingDescriptorId;
            }
        }//end LoadProductBaseInfo

        /// <summary>
        /// Sets the Game information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGame">GameV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadGame(RawCatalogDBEntities catalog, GameV1 mixGame, Media catalogMedia)
        {
            if (catalogMedia.Game == null && !catalogMedia.GameReference.IsLoaded)
            {
                catalogMedia.GameReference.Load();
            }
            if (catalogMedia.MediaType == null && !catalogMedia.MediaTypeReference.IsLoaded)
            {
                catalogMedia.MediaTypeReference.Load();
            }

            mixGame.LiveTitleId = (uint)catalogMedia.Game.liveTitleId;
            mixGame.GameTypeId = catalogMedia.MediaType.mediaTypeId;

            mixGame.Categories = GetCategories(catalog, catalogMedia);
        }//end LoadGame

        /// <summary>
        /// Sets the App information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGame">AppV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadApp(RawCatalogDBEntities catalog, AppV1 mixApp, Media catalogMedia)
        {
            if (catalogMedia.App == null && !catalogMedia.AppReference.IsLoaded)
            {
                catalogMedia.AppReference.Load();
            }
            if (catalogMedia.MediaType == null && !catalogMedia.MediaTypeReference.IsLoaded)
            {
                catalogMedia.MediaTypeReference.Load();
            }

            mixApp.LiveTitleId = (uint)catalogMedia.App.liveTitleId;
            mixApp.TypeId = catalogMedia.MediaType.mediaTypeId;
            mixApp.Categories = GetCategories(catalog, catalogMedia);            
            mixApp.AppTypes = GetAppAppTypes(catalog, catalogMedia);
        }//end LoadApp



        /// <summary>
        /// Load media attributes into App
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixApp"></param>
        static private void LoadProductAttributes(RawCatalogDBEntities catalog, AppV1 mixApp)
        {
            //Load data into mixApp.ProductAttributes
            MediaCapabilityCountry[] catalogMediaCapabilityCountries = catalog.GetPrimitiveMediaCapabilityCountries(mixApp.ProductId);

            if (catalogMediaCapabilityCountries.Count() > 0)
            {
                Dictionary<string, ProductAttributeV1> prodAttrByCountry = new Dictionary<string, ProductAttributeV1>();

                foreach (MediaCapabilityCountry mcc in catalogMediaCapabilityCountries)
                {
                    if (!prodAttrByCountry.ContainsKey(mcc.countryCode))
                    {
                        ProductAttributeV1 prodAttr = new ProductAttributeV1();
                        prodAttr.Country = mcc.countryCode;
                        // Data was cached by EF above, so next line should not hit DB
                        MediaCapabilityCountry[] catalogMediaCapabilityCountryGroup = catalog.GetPrimitiveMediaCapabilityCountries(mixApp.ProductId, mcc.countryCode);

                        prodAttr.Attributes = new AttributeV1[catalogMediaCapabilityCountryGroup.Count()];

                        int i = 0;
                        foreach (MediaCapabilityCountry mcc2 in catalogMediaCapabilityCountryGroup)
                        {
                            if (mcc2.CapabilityType == null && !mcc2.CapabilityTypeReference.IsLoaded)
                            {
                                mcc2.CapabilityTypeReference.Load();
                            }
                            if (mcc2.UnitType == null && !mcc2.UnitTypeReference.IsLoaded)
                            {
                                mcc2.UnitTypeReference.Load();
                            }

                            prodAttr.Attributes[i] = new AttributeV1();
                            prodAttr.Attributes[i].AttributeName = mcc2.CapabilityType.internalName;
                            prodAttr.Attributes[i].Value = mcc2.value;
                            if (mcc2.UnitType != null)
                            {
                                prodAttr.Attributes[i].AttributeUnitType = mcc2.UnitType.unitTypeId;
                            }
                            i++;
                        }

                        prodAttrByCountry.Add(mcc.countryCode, prodAttr);
                    }
                }

                if (prodAttrByCountry.Count > 0)
                {
                    mixApp.ProductAttributes = prodAttrByCountry.Values.ToArray();
                }
            }
        }//end LoadGameAttributes
        
        /// <summary>
        /// Load game attributes into mixGame
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixGame"></param>
        static private void LoadGameAttributes(RawCatalogDBEntities catalog, GameV1 mixGame)
        {
            GameCapabilityCountry[] catalogGameCapabilityCountries = catalog.GetPrimitiveGameCapabilityCountries(mixGame.ProductId);

            if (catalogGameCapabilityCountries.Count() > 0)
            {
                mixGame.GameAttributes = new GameAttributeV1[catalogGameCapabilityCountries.Count()];

                for (int i = 0; i < mixGame.GameAttributes.Length; i++)
                {
                    mixGame.GameAttributes[i] = GameAttributeHelper.Load(catalog, catalogGameCapabilityCountries[i]);
                }
            }
        }//end LoadGameAttributes

        /// <summary>
        /// Sets the GameContent information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGameContent">GameContentV1</param>       
        /// <param name="catalogMedia">Media</param>
        static private void LoadGameContent(RawCatalogDBEntities catalog, GameContentV1 mixGameContent, Media catalogMedia)
        {
            if (catalogMedia.GameContent == null && !catalogMedia.GameContentReference.IsLoaded)
            {
                catalogMedia.GameContentReference.Load();
            }
            if (catalogMedia.MediaType == null && !catalogMedia.MediaTypeReference.IsLoaded)
            {
                catalogMedia.MediaTypeReference.Load();
            }

            GameContent catalogGameContent = catalogMedia.GameContent;
            mixGameContent.EffectiveLiveTitle = catalogGameContent.effectiveLiveTitleId;
            mixGameContent.GameContentTypeId = catalogMedia.MediaType.mediaTypeId;
            mixGameContent.InheritRating = catalogGameContent.inheritRating;
            mixGameContent.Categories = GetCategories(catalog, catalogMedia);

            MediaRelationship[] catalogMediaRelationships = catalog.GetPrimitiveMediaRelationShip(mixGameContent.ProductId,
                (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload);

            mixGameContent.GameRelationships = new GameRelationshipV1[catalogMediaRelationships.Length];
            for (int i = 0; i < catalogMediaRelationships.Length; i++)
            {
                mixGameContent.GameRelationships[i] = new GameRelationshipV1();
                mixGameContent.GameRelationships[i].SortOrder = catalogMediaRelationships[i].sortOrder;
                if (catalogMediaRelationships[i].Media == null && !catalogMediaRelationships[i].MediaReference.IsLoaded)
                {
                    catalogMediaRelationships[i].MediaReference.Load();
                }
                mixGameContent.GameRelationships[i].GameId = catalogMediaRelationships[i].Media.mediaId;
            }
        }//end LoadGameContent


        /// <summary>
        /// Sets the LocalizedData information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixApp">AppV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LocalizedData(RawCatalogDBEntities catalog, LocalizedDataV1 mixLocalizedData, MediaLocale catalogMediaLocale)
        {
                mixLocalizedData.Locale = catalogMediaLocale.Locale.locale1;
                mixLocalizedData.Title = catalogMediaLocale.title;
                mixLocalizedData.TitleSort = catalogMediaLocale.titleSort;
                mixLocalizedData.TitleReduced = catalogMediaLocale.reducedTitle;
                mixLocalizedData.VoiceDisplayTitle = catalogMediaLocale.voiceDisplayTitle;
                mixLocalizedData.Description = catalogMediaLocale.description;
                mixLocalizedData.DescriptionReduced = catalogMediaLocale.reducedDescription;

                // Get Media Locale Maps for the media and its Locale
                MediaLocaleMap[] catalogMediaLocaleMaps = catalog.GetPrimitiveMediaLocaleMapMappings(catalogMediaLocale.Media.mediaId, catalogMediaLocale.Locale);

                // Only populate the EquivalentLocales optional field no mapping is there
                if (catalogMediaLocaleMaps != null)
                {
                    // Get the mapping array in its string representation
                    int[] catalogMediaLcidMaps = (from mlm in catalogMediaLocaleMaps
                                                  select mlm.lcid).ToArray();

                    // List of Locales to use as a dictionary
                    Locale[] catalogLocales = catalog.Locale.ToArray();

                    // Add the text version of the Locale based on it's LCID
                    mixLocalizedData.EquivalentLocales = (from cmlm in catalogMediaLcidMaps
                                                             from cl in catalogLocales
                                                             where cmlm == cl.lcid
                                                             select cl.locale1).ToArray();
                }             
        }//end LoadLocalizedData

        
        /// <summary>
        /// Sets the AppLocalizedData information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixApp">AppV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadAppLocalizedData(RawCatalogDBEntities catalog, AppV1 mixApp, Media catalogMedia)
        {
            List<AppLocalizedDataV1> mixAppLocalizedDataList = new List<AppLocalizedDataV1>();

            foreach (MediaLocale catalogMediaLocale in
                catalog.MediaLocale.Where(ml => ml.mediaId == catalogMedia.mediaId))
            {
                if (catalogMediaLocale.Locale == null && !catalogMediaLocale.LocaleReference.IsLoaded)
                {
                    catalogMediaLocale.LocaleReference.Load();
                }

                AppLocalizedDataV1 mixAppLocalizedData = new AppLocalizedDataV1();

                LocalizedData(catalog, mixAppLocalizedData,catalogMediaLocale);

                AppLocale catalogAppLocale = catalog.AppLocale.Where
                    (gl => gl.appMediaId == catalogMedia.mediaId
                    && gl.lcid == catalogMediaLocale.lcid).FirstOrDefault();
                if (catalogAppLocale != null)
                {
                    mixAppLocalizedData.Developer = catalogAppLocale.developer;
                    mixAppLocalizedData.Publisher = catalogAppLocale.publisher;
                }//end if

                mixAppLocalizedDataList.Add(mixAppLocalizedData);
            }//end foreach MediaLocale

            mixApp.AppLocalizedData = mixAppLocalizedDataList.ToArray();
        }//end LoadAppLocalizedData


        /// <summary>
        /// Sets the GameLocalizedData information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGame">GameV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void LoadGameLocalizedData(RawCatalogDBEntities catalog, GameV1 mixGame, Media catalogMedia)
        {
            List<GameLocalizedDataV1> mixGameLocalizedDataList = new List<GameLocalizedDataV1>();

            foreach (MediaLocale catalogMediaLocale in
                catalog.MediaLocale.Where(ml => ml.mediaId == catalogMedia.mediaId))
            {
                if (catalogMediaLocale.Locale == null && !catalogMediaLocale.LocaleReference.IsLoaded)
                {
                    catalogMediaLocale.LocaleReference.Load();
                }

                GameLocalizedDataV1 mixGameLocalizedData = new GameLocalizedDataV1();
                LocalizedData(catalog, mixGameLocalizedData, catalogMediaLocale);

                GameLocale catalogGameLocale = catalog.GameLocale.Where
                    (gl => gl.gameMediaId == catalogMedia.mediaId
                    && gl.lcid == catalogMediaLocale.lcid).FirstOrDefault();
                if (catalogGameLocale != null)
                {
                    mixGameLocalizedData.CustomGenre = catalogGameLocale.customGenre;
                    mixGameLocalizedData.Developer = catalogGameLocale.developer;
                    mixGameLocalizedData.Publisher = catalogGameLocale.publisher;
                }//end if

                mixGameLocalizedDataList.Add(mixGameLocalizedData);
            }//end foreach MediaLocale

            mixGame.GameLocalizedData = mixGameLocalizedDataList.ToArray();
        }//end LoadGameLocalizedData
        
        /// <summary>
        /// Loads the product package into App
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void LoadAppPackageInfo(RawCatalogDBEntities catalog, AppV1 mixApp)
        {
            MediaInstance[] mediaInstances = catalog.GetPrimitiveMediaInstances(mixApp.ProductId, (byte)CatalogConstants.IsPreview.False);

            mixApp.Packages = new AppPackageV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Count(); i++)
            {
                Guid mediaInstanceId = mediaInstances[i].mediaInstanceId;
                AppPackageV1 mixAppPackage =  new AppPackageV1();

                AppInstance appInstance = catalog.GetPrimitiveAppInstance(mediaInstanceId);

                if (appInstance != null)
                {
                    if (appInstance.PackageType == null && !appInstance.PackageTypeReference.IsLoaded)
                    {
                        appInstance.PackageTypeReference.Load();
                    }

                    mixAppPackage.PackageId = appInstance.appInstanceId;
                    mixAppPackage.InstallSize = (ulong)appInstance.installSize;
                    mixAppPackage.PackageSize = (ulong)appInstance.packageSize;
                    mixAppPackage.PackageType = appInstance.PackageType.packageTypeId;
                    mixAppPackage.ContentId = appInstance.liveContentId;

                    //Loading File information 
                    AppInstanceFile[] appInstanceFiles = catalog.GetPrimitiveAppInstanceFiles(mediaInstanceId);

                    mixAppPackage.Files = new FileV1[appInstanceFiles.Length];

                    for (int j = 0; j < appInstanceFiles.Length; j++)
                    {
                        FileV1 file = new FileV1();
                        file.FileUrl = appInstanceFiles[j].fileUrl;
                        file.SortOrder = appInstanceFiles[j].sortOrder;
                        mixAppPackage.Files[j] = file;
                    }                    

                    // Loading Encryption Information
                    AppInstanceEncryptedKey appEncryptedKey = catalog.GetPrimitiveAppInstanceEncryptedKey(mediaInstanceId);

                    EncryptionV1 encryptedKey = null;
                    if (appEncryptedKey != null)
                    {
                        encryptedKey = new EncryptionV1();
                        encryptedKey.PublicKey = appEncryptedKey.encryptedPublicKey;
                        encryptedKey.SymKey = appEncryptedKey.encryptedSymKey;
                        mixAppPackage.Encryption = encryptedKey;
                    }

                }

                // Loading ClientTypes
                MediaInstanceClientType[] mediaInstanceClientTypes = catalog.GetPrimitiveMediaInstanceClientTypes(mediaInstanceId);
                mixAppPackage.ClientTypes = new int[mediaInstanceClientTypes.Length];
                for (int j = 0; j < mediaInstanceClientTypes.Length; j++)
                {
                    mixAppPackage.ClientTypes[j] = mediaInstanceClientTypes[j].clientTypeId;
                }
                
                mixApp.Packages[i] = mixAppPackage;
            }
        } //end LoadProductPackageInfo
    


        /// <summary>
        /// Loads the product package into Game Contract
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, GameV1 game)
        {
            MediaInstance[] mediaInstances = catalog.GetPrimitiveMediaInstances(game.ProductId, (byte)CatalogConstants.IsPreview.False);

            game.Executables = new ProductPackageV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Count(); i++)
            {
                game.Executables[i] = new ProductPackageV1();
                LoadProductPackageInfo(catalog, game.Executables[i], mediaInstances[i].mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the product package into GameContent
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="gameContent"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, GameContentV1 gameContent)
        {
            MediaInstance[] mediaInstances = catalog.GetPrimitiveMediaInstances(gameContent.ProductId, (byte)CatalogConstants.IsPreview.False);

            gameContent.Packages = new ProductPackageV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Length; i++)
            {
                gameContent.Packages[i] = new ProductPackageV1();
                LoadProductPackageInfo(catalog, gameContent.Packages[i], mediaInstances[i].mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the ProductPackageInfo into ProductPackage COntract.Look up happens based on MediaInstanceId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            LoadProductPackageClientTypes(catalog, productPackage, mediaInstanceId);

            GameContentInstance gameContentInstance = catalog.GetPrimitiveGameContentInstance(mediaInstanceId);

            if (gameContentInstance != null)
            {
                if (gameContentInstance.PackageType == null && !gameContentInstance.PackageTypeReference.IsLoaded)
                {
                    gameContentInstance.PackageTypeReference.Load();
                }

                if (gameContentInstance.GameRegionMask == null && !gameContentInstance.GameRegionMaskReference.IsLoaded)
                {
                    gameContentInstance.GameRegionMaskReference.Load();
                }

                productPackage.PackageId = gameContentInstance.gameContentInstanceId;
                productPackage.InstallSize = (ulong)gameContentInstance.installSize;
                productPackage.PackageSize = (ulong)gameContentInstance.packageSize;
                productPackage.PackageType = gameContentInstance.PackageType.packageTypeId;
                productPackage.ContentId = gameContentInstance.liveContentId;
                productPackage.SupportedGameRegionMask = gameContentInstance.GameRegionMask.gameRegionMaskId;

                LoadProductPackageFiles(catalog, productPackage, mediaInstanceId);

                LoadProductPackageEncryptedKey(catalog, productPackage, mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the ProductPackage Files into ProductPackageContract.
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageFiles(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            GameContentInstanceFile[] gameContentInstanceFiles = catalog.GetPrimitiveGameContentInstanceFiles(mediaInstanceId);

            productPackage.Files = new FileV1[gameContentInstanceFiles.Length];

            for (int i = 0; i < gameContentInstanceFiles.Length; i++)
            {
                FileV1 file = new FileV1();
                file.FileUrl = gameContentInstanceFiles[i].fileUrl;
                file.SortOrder = gameContentInstanceFiles[i].sortOrder;
                productPackage.Files[i] = file;
            }

        }

        /// <summary>
        /// Loads the MediaInstance clienttypes into ProductPackage
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageClientTypes(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            MediaInstanceClientType[] mediaInstanceClientTypes = catalog.GetPrimitiveMediaInstanceClientTypes(mediaInstanceId);

            productPackage.ClientTypes = new int[mediaInstanceClientTypes.Length];

            for (int i = 0; i < mediaInstanceClientTypes.Length; i++)
            {
                productPackage.ClientTypes[i] = mediaInstanceClientTypes[i].clientTypeId;
            }
        }

        /// <summary>
        /// Loads the Encryption Public and Private Key Info into ProductPackage
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageEncryptedKey(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            GameContentInstanceEncryptedKey gameContentEncryptedKey = catalog.GetPrimitiveGameContentInstanceEncryptedKey(mediaInstanceId);

            EncryptionV1 encryptedKey = null;
            if (gameContentEncryptedKey != null)
            {
                encryptedKey = new EncryptionV1();
                encryptedKey.PublicKey = gameContentEncryptedKey.encryptedPublicKey;
                encryptedKey.SymKey = gameContentEncryptedKey.encryptedSymKey;
                productPackage.Encryption = encryptedKey;
            }
        }

        /// <summary>
        /// Loads the videoPreview into Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void LoadVideoPreviewInfo(RawCatalogDBEntities catalog, GameV1 game)
        {
            // For Games, POR has been since Stockholm that the only Preview-Instances present are For Video-Previews
            MediaInstance[] mediaInstances = catalog.GetPrimitiveMediaInstances(game.ProductId, (byte)CatalogConstants.IsPreview.True);

            game.VideoPreviews = new VideoPreviewV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Length; i++)
            {
                game.VideoPreviews[i] = new VideoPreviewV1();
                LoadVideoPreviewInfo(catalog, game.VideoPreviews[i], mediaInstances[i].mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the videoPreview into Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void LoadVideoPreviewInfo(RawCatalogDBEntities catalog, VideoPreviewV1 videoPreview, Guid mediaInstanceId)
        {
            PreviewMediaInstance previewMediaInstance = catalog.GetPrimitivePreviewMediaInstance(mediaInstanceId);
            VideoInstance videoInstance = catalog.GetPrimitiveVideoInstance(mediaInstanceId);
            VideoFile[] videoFiles = null;

            if (videoInstance != null)
            {
                videoFiles = catalog.GetPrimitiveVideoFiles(videoInstance.videoMediaInstanceId);
            }

            // 1 PreviewMediaInstance per MediaInstance
            if (previewMediaInstance != null && videoInstance != null && videoFiles != null && videoFiles.Length > 0)
            {
                if (previewMediaInstance.Country == null && !previewMediaInstance.CountryReference.IsLoaded)
                {
                    previewMediaInstance.CountryReference.Load();
                }

                videoPreview.PackageId = previewMediaInstance.previewMediaInstanceId;
                videoPreview.Country = previewMediaInstance.Country.countryCode;

                // N VideoFiles per VideoInstance in DB, even though only 1 VideoPreview File/URL is allowed to be ingested for Previews of Games
                videoPreview.FileUrl = videoFiles[0].fileUrl;
            }
            else
            {
                //videoPreview not found
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_NOT_FOUND_IN_CATALOG, "VideoPreview for MediaInstance " + mediaInstanceId.ToString() + " not found", false);
            }
        }

        /// <summary>
        /// Sets the points bundle information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixPointsBundle"></param>
        /// <param name="catalogMedia"></param>
        static private void LoadPointsBundleInfo(RawCatalogDBEntities catalog, PointsBundleV1 mixPointsBundle, Media catalogMedia)
        {
            if (catalogMedia.PointsBundle == null && !catalogMedia.PointsBundleReference.IsLoaded)
            {
                catalogMedia.PointsBundleReference.Load();
            }

            mixPointsBundle.Points = catalogMedia.PointsBundle.points;
            mixPointsBundle.LocalizedData = GetLocalizedData(catalog, catalogMedia);

        }//end LoadGame

        /// <summary>
        /// Loads the data relevant to the Bundle object from the database.
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixBundle">Bundle object</param>
        /// <param name="catalogMedia">Object holding the Media datarow info</param>
        private static void LoadBundleInfo(RawCatalogDBEntities catalog, BundleV1 mixBundle, Media catalogMedia)
        {
            // load localized data
            //mixBundle.BundleLocalizedData = GetLocalizedData(catalog, catalogMedia);

            // load ProductIds for this bundle
            mixBundle.ProductIds = catalog.GetPrimitiveRelatedMediaIds(mixBundle.ProductId, (int)CatalogConstants.MediaRelationshipTypeEnum.BundleToAssociatedMedia);
        }

        /// <summary>
        /// Returns the Categories from the retrieved RawCatalogDB values
        /// Used by Game and GameContent
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixCategories">int[]</param>
        /// <param name="catalogMedia">Media</param>
        static private int[] GetCategories(RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<int> catalogMediaCategories = new List<int>();
            foreach (MediaCategory catalogMediaCategory in catalog.MediaCategory.Where(mc => mc.mediaId == catalogMedia.mediaId))
            {
                catalogMediaCategories.Add(catalogMediaCategory.categoryId);
            }
            return catalogMediaCategories.ToArray();
        }//end GetCategories

        /// <summary>
        /// Returns the AppTypes from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixCategories">int[]</param>
        /// <param name="catalogMedia">AppMediaId</param>
        static private int[] GetAppAppTypes(RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<int> catalogAppAppTypes = new List<int>();
            foreach (AppAppType appAppType in catalog.GetPrimitiveAppAppTypes(catalogMedia.mediaId))
            {
                if (appAppType == null && !appAppType.AppReference.IsLoaded)
                {
                    appAppType.AppReference.Load();
                }

                catalogAppAppTypes.Add(appAppType.appTypeId);
            }
            return catalogAppAppTypes.ToArray();
        }//end GetAppAppTypes

        /// <summary>
        /// Returns the MediaTerms information for SearchInformationV1
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="catalogMedia">media</param>
        static private SearchInformationV1[] GetSearchInformation(RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<SearchInformationV1> catalogMediaTerms = new List<SearchInformationV1>();

            foreach (Locale locale in catalog.Locale)
            {
                MediaTerm[] catalogMediaTermKeywords = catalog.GetPrimitiveMediaTerm(catalogMedia.mediaId, 
                    (int)CatalogConstants.TermType.Keyword, locale.lcid);
                
                MediaTerm[] catalogMediaTermAlternateTitles = catalog.GetPrimitiveMediaTerm(catalogMedia.mediaId,
                    (int)CatalogConstants.TermType.AlternateTitle, locale.lcid);

                // Create an entry in SearchInformation for this locale only if a term exists
                if (catalogMediaTermKeywords.Count() > 0 || catalogMediaTermAlternateTitles.Count() > 0)
                {
                    SearchInformationV1 mixSearchInformation = new SearchInformationV1();
                    mixSearchInformation.Locale = locale.locale1;

                    // Assigning Keyword values
                    List<string> keywords = new List<string>();
                    if (catalogMediaTermKeywords.Count() > 0)
                    {
                        mixSearchInformation.Keywords = catalogMediaTermKeywords.Select(cMTK => cMTK.term).ToArray();
                    }

                    // Assigning AlternateTitle values
                    List<string> AlternateTitles = new List<string>();
                    if (catalogMediaTermAlternateTitles.Count() > 0)
                    {
                        mixSearchInformation.AlternateTitles = catalogMediaTermAlternateTitles.Select(cMTK => cMTK.term).ToArray();
                    }

                    catalogMediaTerms.Add(mixSearchInformation);
                } 
            }
            
            return catalogMediaTerms.ToArray();
        }//end GetSearchInformation



        /// <summary>
        /// Gets data from MediaLocale and MediaLocaleMap into the MIx LocalizedData Data Contract
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        /// <returns></returns>
        static private LocalizedDataV1[] GetLocalizedData(RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<LocalizedDataV1> mixLocalizedDataList = new List<LocalizedDataV1>();

            foreach (MediaLocale catalogMediaLocale in
                catalog.MediaLocale.Where(ml => ml.mediaId == catalogMedia.mediaId))
            {
                if (catalogMediaLocale.Locale == null && !catalogMediaLocale.LocaleReference.IsLoaded)
                {
                    catalogMediaLocale.LocaleReference.Load();
                }

                LocalizedDataV1 mixLocalizedData = new LocalizedDataV1();

                LocalizedData(catalog, mixLocalizedData, catalogMediaLocale);

                mixLocalizedDataList.Add(mixLocalizedData);
            }

            return mixLocalizedDataList.ToArray();
        }

        /// <summary>
        /// Retrieves the subscription family info
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        /// <returns></returns>
        static private void LoadSubscriptionFamilyInfo(RawCatalogDBEntities catalog, Media catalogMedia, SubscriptionFamilyV1 mixSubscriptionFamily)
        {

            SubscriptionFamily subscriptionFamily = catalog.GetPrimitiveSubscriptionFamily(catalogMedia.mediaId);

            if (subscriptionFamily != null)
            {
                //Populate the properties for a subscription family
                mixSubscriptionFamily.ProductId = subscriptionFamily.subscriptionFamilyId;
                mixSubscriptionFamily.InternalName = subscriptionFamily.internalName;
                mixSubscriptionFamily.TitleId = (uint)subscriptionFamily.titleId;

                MediaRelationship[] catalogMediaRelationShip = catalog.GetPrimitiveMediaRelationShip(catalogMedia.mediaId);
                ProductRelationshipV1[] mixProductRelationShip = new ProductRelationshipV1[catalogMediaRelationShip.Length];

                //Populate the ProductRelationShips
                for (int i = 0; i < catalogMediaRelationShip.Length; i++)
                {
                    if (catalogMediaRelationShip[i].MediaRelationshipType == null && !catalogMediaRelationShip[i].MediaRelationshipTypeReference.IsLoaded)
                    {
                        catalogMediaRelationShip[i].MediaRelationshipTypeReference.Load();
                    }
                    mixProductRelationShip[i] = new ProductRelationshipV1();
                    mixProductRelationShip[i].RelationshipTypeId = catalogMediaRelationShip[i].MediaRelationshipType.mediaRelationshipTypeId;
                    mixProductRelationShip[i].ProductId = catalogMediaRelationShip[i].mediaId;
                    mixProductRelationShip[i].SortOrder = catalogMediaRelationShip[i].sortOrder;
                }
                mixSubscriptionFamily.ProductRelationships = mixProductRelationShip;

                //Populate the services
                SubscriptionFamilyService[] catalogSubscriptionFamilyService = catalog.GetPrimitiveSubscriptionFamilyServices(catalogMedia.mediaId);
                int[] serviceIds = new int[catalogSubscriptionFamilyService.Length];

                //Populate the ProductRelationShips
                for (int i = 0; i < catalogSubscriptionFamilyService.Length; i++)
                {
                    if (catalogSubscriptionFamilyService[i].Service == null && !catalogSubscriptionFamilyService[i].ServiceReference.IsLoaded)
                    {
                        catalogSubscriptionFamilyService[i].ServiceReference.Load();
                    }
                    serviceIds[i] = catalogSubscriptionFamilyService[i].Service.serviceId;
                }

                mixSubscriptionFamily.Services = serviceIds;

                // load localized data
                mixSubscriptionFamily.LocalizedData = GetLocalizedData(catalog, catalogMedia);
            }
        }

        /// <summary>
        /// Gets the Livesubscription family from Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        /// <param name="mixLiveSubscriptionFamily"></param>
        static void LoadLiveSubscriptionFamily(RawCatalogDBEntities catalog, Media catalogMedia, LiveSubscriptionFamilyV1 mixLiveSubscriptionFamily)
        {
            LiveSubscriptionFamily liveSubscriptionFamily = catalog.GetPrimitiveLiveSubscriptionFamily(catalogMedia.mediaId);
            if (liveSubscriptionFamily.Tier == null && !liveSubscriptionFamily.TierReference.IsLoaded)
            {
                liveSubscriptionFamily.TierReference.Load();
            }
            //Populate the Tier
            mixLiveSubscriptionFamily.Tier = liveSubscriptionFamily.Tier.tierId;
        }

        /// <summary>
        /// Gets the Livesubscription family from Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        /// <param name="mixLiveSubscriptionFamily"></param>
        static void LoadSubscriptionInfo(RawCatalogDBEntities catalog, Media catalogMedia, SubscriptionBaseV1 mixSubscription)
        {
            Subscription subscription = catalog.GetPrimitiveSubscription(catalogMedia.mediaId);
            if (subscription.BillingFrequency == null && !subscription.BillingFrequencyReference.IsLoaded)
            {
                subscription.BillingFrequencyReference.Load();
            }
            if (subscription.DurationType == null && !subscription.DurationTypeReference.IsLoaded)
            {
                subscription.DurationTypeReference.Load();
            }
            if (subscription.Media == null && !subscription.MediaReference.IsLoaded)
            {
                subscription.MediaReference.Load();
            }
            if (subscription.SellType == null && !subscription.SellTypeReference.IsLoaded)
            {
                subscription.SellTypeReference.Load();
            }
            if (subscription.SubscriptionFamily == null && !subscription.SubscriptionFamilyReference.IsLoaded)
            {
                subscription.SubscriptionFamilyReference.Load();
            }
            if (subscription.SubscriptionBillingInformation == null && !subscription.SubscriptionBillingInformationReference.IsLoaded)
            {
                subscription.SubscriptionBillingInformationReference.Load();
            }
            //Populate the Tier
            mixSubscription.BillingFrequencyId = subscription.BillingFrequency.billingFrequencyId;
            mixSubscription.InternalName = subscription.internalName;
            mixSubscription.IsCancelable = Convert.ToBoolean(subscription.isCancelable);
            mixSubscription.SellTypeId = subscription.SellType.sellTypeId;


            if (subscription.SubscriptionBillingInformation != null)
            {
                if (subscription.SubscriptionBillingInformation.billingsvcComponentId.HasValue)
                {
                    mixSubscription.ServiceComponentId = subscription.SubscriptionBillingInformation.billingsvcComponentId.ToString(); ;
                }
                else
                {
                    mixSubscription.ServiceComponentId = null;
                }
            }
            mixSubscription.SubscriptionDuration = subscription.subscriptionDuration;
            mixSubscription.SubscriptionDurationTypeId = subscription.DurationType.durationTypeId;
            mixSubscription.SubscriptionFamilyId = subscription.SubscriptionFamily.subscriptionFamilyId;

            // load localized data
            mixSubscription.LocalizedData = GetLocalizedData(catalog, catalogMedia);
        }
        #endregion

        #region ConfigureProduct
        /// <summary>
        /// Called into from Content Ingestion Mix API
        /// Props a Data Contract object 
        /// </summary>
        /// <param name="mixProduct">ProductV1</param>
        static public void ConfigureProduct(ProductV1 mixProduct)
        {
            RawCatalogDBEntities catalog = null;
            try
            {
                catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);


                Media catalogMedia = null;
                if (mixProduct.GetType() == typeof(GameV1))
                {
                    Game catalogGame = null;
                    GameV1 mixGame = (GameV1)mixProduct;

                    // Validate the mediaTypeId
                    if (mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.Game
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.XboxOriginalGame
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.ArcadeGame
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.XNACommunityGame
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.ServerBackedGames
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.Marketplace
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.LiveApp
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.WebGame
                        && mixGame.GameTypeId != (int)CatalogConstants.MediaTypeEnum.MobileGame)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIATYPE,
                            String.Format("MediaTypeID  {0} is an invalid Game type", mixGame.GameTypeId));
                    }

                    SaveProductBaseInfo(catalog, mixGame, out catalogMedia, mixGame.GameTypeId);
                    SaveGame(catalog, mixGame, catalogMedia, out catalogGame);
                    SaveGameAttributes(catalog, mixGame, catalogGame);
                    SaveProductPackages(catalog, mixGame, catalogMedia, catalogGame);
                    SaveVideoPreviews(catalog, mixGame, catalogMedia);
                    SaveSearchInformation(catalog, catalogMedia, mixGame.SearchInformation);
                    RemoveImageRelationships(catalog, mixProduct);

                    try
                    {
                        catalog.Save(catalogMedia);
                    }
                    catch (InvalidOperationException ex)
                    {
                        // In the case of a Game trying to create a MediaRelationship to itself
                        // after saving to the database the refresh of the Object Context catalog 
                        // will throw an an exception due to the circular reference
                        // Service will swallow the exception if a circular media relationship save should
                        // have occured and the particular inner message occurs (and not a domain data
                        // or other validation inner message that shares the same exception type)
                        // This error messsage should only occur when an Executable is being saved to the database
                        if (ex.Message != MixConstants.CircularReferenceExceptionMessage || mixGame.Executables == null)
                        {
                            throw;
                        }
                    }
                    return;
                }
                if (mixProduct.GetType() == typeof(AppV1))
                {
                    App catalogApp = null;
                    AppV1 mixApp = (AppV1)mixProduct;

                    // Validate the mediaTypeId
                    if (mixApp.TypeId != (int)CatalogConstants.MediaTypeEnum.App)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIATYPE,
                            String.Format("MediaTypeID  {0} is an invalid App type", mixApp.TypeId));
                    }

                    SaveProductBaseInfo(catalog, mixApp, out catalogMedia, mixApp.TypeId);
                    SaveApp(catalog, mixApp, catalogMedia, out catalogApp);
                    SaveProductAttributes(catalog, mixApp, catalogMedia);
                    SaveAppPackages(catalog, mixApp, catalogMedia, catalogApp);
                    SaveSearchInformation(catalog, catalogMedia, mixApp.SearchInformation);
                    RemoveImageRelationships(catalog, mixProduct);

                    try
                    {
                        catalog.Save(catalogMedia);
                    }
                    catch (InvalidOperationException ex)
                    {
                        // In the case of a App trying to create a MediaRelationship to itself
                        // after saving to the database the refresh of the Object Context catalog 
                        // will throw an an exception due to the circular reference
                        // Service will swallow the exception if a circular media relationship save should
                        // have occured and the particular inner message occurs (and not a domain data
                        // or other validation inner message that shares the same exception type)
                        // This error messsage should only occur when an Executable is being saved to the database
                        if (ex.Message != MixConstants.CircularReferenceExceptionMessage || mixApp.Packages == null)
                        {
                            throw;
                        }
                    }
                    return;
                }
                if (mixProduct.GetType() == typeof(GameContentV1))
                {
                    GameContent catalogGameContent = null;
                    GameContentV1 mixGameContent = (GameContentV1)mixProduct;

                    // Validate the mediaTypeId
                    if (mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameContent
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.Theme
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameTrial
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameDemo
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GamerTile
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameVideo
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameTrailer
                        && mixGameContent.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.MobilePDLC)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIATYPE,
                            String.Format("MediaTypeID  {0} is an invalid GameContent type", mixGameContent.GameContentTypeId));
                    }

                    SaveProductBaseInfo(catalog, mixGameContent, out catalogMedia, mixGameContent.GameContentTypeId);
                    SaveGameContent(catalog, mixGameContent, catalogMedia, out catalogGameContent);
                    SaveProductPackages(catalog, mixGameContent, catalogMedia);
                    RemoveImageRelationships(catalog, mixProduct);
                    SaveSearchInformation(catalog, catalogMedia, mixGameContent.SearchInformation);
                    catalog.Save(catalogMedia);
                    return;
                }

                if (mixProduct.GetType() == typeof(GameConsumableV1))
                {
                    GameContent catalogGameContent = null;
                    GameConsumableV1 mixGameConsumable = (GameConsumableV1)mixProduct;

                    // Validate the mediaTypeId
                    if (mixGameConsumable.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.GameConsumable &&
                        mixGameConsumable.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.MobileConsumable)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIATYPE,
                            String.Format("MediaTypeID {0} is an invalid GameConsumable type", mixGameConsumable.GameContentTypeId));
                    }

                    SaveProductBaseInfo(catalog, mixGameConsumable, out catalogMedia, mixGameConsumable.GameContentTypeId);
                    SaveGameContent(catalog, mixGameConsumable, catalogMedia, out catalogGameContent);
                    SaveProductPackages(catalog, mixGameConsumable, catalogMedia);
                    SaveGameConsumable(catalog, mixGameConsumable, catalogGameContent);
                    RemoveImageRelationships(catalog, mixProduct);
                    SaveSearchInformation(catalog, catalogMedia, mixGameConsumable.SearchInformation);
                    catalog.Save(catalogMedia);
                    return;
                }

                if (mixProduct.GetType() == typeof(AvatarItemV1))
                {
                    GameContent catalogGameContent = null;
                    AvatarItemV1 mixAvatarItem = (AvatarItemV1)mixProduct;

                    // Validate the mediaTypeId
                    if (mixAvatarItem.GameContentTypeId != (int)CatalogConstants.MediaTypeEnum.AvatarItem)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIATYPE,
                            String.Format("MediaTypeID  {0} is an invalid AvatarItem type", mixAvatarItem.GameContentTypeId));
                    }

                    SaveProductBaseInfo(catalog, mixAvatarItem, out catalogMedia, mixAvatarItem.GameContentTypeId);
                    SaveGameContent(catalog, mixAvatarItem, catalogMedia, out catalogGameContent);
                    SaveProductPackages(catalog, mixAvatarItem, catalogMedia);
                    SaveAvatarItem(catalog, mixAvatarItem, catalogGameContent);
                    RemoveImageRelationships(catalog, mixProduct);
                    SaveSearchInformation(catalog, catalogMedia, mixAvatarItem.SearchInformation);
                    catalog.Save(catalogMedia);
                    return;
                }

                if (mixProduct.GetType() == typeof(ImageV1))
                {
                    ImageV1 mixImage = (ImageV1)mixProduct;
                    SaveMediaBaseInfo(catalog, mixImage, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.Image);
                    SaveImageInfo(catalog, mixImage, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                
                if (mixProduct.GetType() == typeof(BundleV1))
                {
                    /* Temp removal of Bundles until TFS ISS-All 26798's design has been implimented
                    BundleV1 mixBundle = (BundleV1)mixProduct;
                    SaveMediaBaseInfo(catalog, mixBundle, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.Bundle);
                    SaveBundleInfo(catalog, mixBundle, catalogMedia);
                    RemoveImageRelationships(catalog, mixProduct);
                    SaveSearchInformation(catalog, catalogMedia, mixBundle.SearchInformation);
                    catalog.Save(catalogMedia);
                     * */
                    return;
                }

                if (mixProduct.GetType() == typeof(PointsBundleV1))
                {
                    PointsBundleV1 mixPointsBundle = (PointsBundleV1)mixProduct;
                    SaveProductBaseInfo(catalog, mixPointsBundle, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.PointsBundle);
                    SavePointsBundleInfo(catalog, mixPointsBundle, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(LiveSubscriptionV1))
                {
                    LiveSubscriptionV1 mixLiveSubscription = ((LiveSubscriptionV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixLiveSubscription, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.LiveSubscription);
                    SaveSubscriptionInfo(catalog, mixLiveSubscription, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(LiveSubscriptionFamilyV1))
                {
                    LiveSubscriptionFamilyV1 mixLiveSubscriptionFamily = ((LiveSubscriptionFamilyV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixLiveSubscriptionFamily, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.LiveSubscriptionFamily);
                    SaveLiveSubscriptionFamilyInfo(catalog, mixLiveSubscriptionFamily, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(GameSubscriptionV1))
                {
                    GameSubscriptionV1 mixGameSubscription = ((GameSubscriptionV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixGameSubscription, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.GameSubscription);
                    SaveSubscriptionInfo(catalog, mixGameSubscription, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(GameSubscriptionFamilyV1))
                {
                    GameSubscriptionFamilyV1 mixGameSubscriptionFamily = ((GameSubscriptionFamilyV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixGameSubscriptionFamily, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.GameSubscriptionFamily);
                    SaveBasicSubscriptionFamilyInfo(catalog, mixGameSubscriptionFamily, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(AddonSubscriptionV1))
                {
                    AddonSubscriptionV1 mixAddonSubscription = ((AddonSubscriptionV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixAddonSubscription, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.AddonSubscription);
                    SaveSubscriptionInfo(catalog, mixAddonSubscription, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
                if (mixProduct.GetType() == typeof(AddonSubscriptionFamilyV1))
                {
                    AddonSubscriptionFamilyV1 mixAddonSubscriptionFamily = ((AddonSubscriptionFamilyV1)mixProduct);
                    SaveProductBaseInfo(catalog, mixAddonSubscriptionFamily, out catalogMedia, (int)CatalogConstants.MediaTypeEnum.AddonSubscriptionFamily);
                    SaveBasicSubscriptionFamilyInfo(catalog, mixAddonSubscriptionFamily, catalogMedia);
                    catalog.Save(catalogMedia);
                    return;
                }
            }
            catch (System.Data.OptimisticConcurrencyException ex)
            {
                //setting IsRetryable to true
                throw new XRLException(HResult.XONLINE_E_MIX_CONCURRENCY_ERROR, XEvent.Id.MIX_CONCURRENCY_ERROR, string.Format("Concurrency issue occured while saving to the Database {0}", ex.Message), true);
            }
            catch (System.Data.EntityException ex)
            {
                string msg = ex.Message;
                if (ex.InnerException != null)
                {
                    msg = ex.InnerException.Message;
                }
                throw new XRLException(HResult.XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR, XEvent.Id.MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR, string.Format("Entity Framework Model does not match up to the current catalog schema.  Exception generating entities from SQL {0}", msg), true);
            }

            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_CONFIGUREPRODUCT, "Incorrect Product Type " + mixProduct.GetType().FullName + " for mixProduct " + mixProduct.ProductId.ToString(), false);
        }//end ConfigureProduct
        
        /// <summary>
        /// Sets and updates the AvatarItem information for RawCatalogDB
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixAvatarItem">AvatarItemV1</param>
        /// <param name="catalogGameContent">GameContent</param>
        static private void SaveGameConsumable(RawCatalogDBEntities catalog, GameConsumableV1 mixGameConsumable, GameContent catalogGameContent)
        {
            catalog.SavePrimitiveGameConsumable(catalogGameContent, mixGameConsumable.AssetId);
        }//end SaveGameConsumable
                        
        /// <summary>
        /// Sets and updates the AvatarItem information for RawCatalogDB
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixAvatarItem">AvatarItemV1</param>
        /// <param name="catalogGameContent">GameContent</param>
        static private void SaveAvatarItem(RawCatalogDBEntities catalog, AvatarItemV1 mixAvatarItem, GameContent catalogGameContent)
        {
            catalog.SavePrimitiveGameContentAvatarItem(catalogGameContent, mixAvatarItem.ProductId, mixAvatarItem.BodyType, mixAvatarItem.AssetId);
        }//end SaveAvatarItem

        /// <summary>
        /// Sets and updates the MediaBase information for RawCatalogDB
        /// Used for Images and Video
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveMediaBaseInfo(RawCatalogDBEntities catalog, MediaBaseV1 mixMediaBase, out Media catalogMedia, int mediaType)
        {
            catalog.SavePrimitiveMedia(out catalogMedia, mixMediaBase.ProductId, mediaType, 123, DateTime.UtcNow,
                mixMediaBase.VisibilityDate, mixMediaBase.VisibilityStatus, 0);

            catalog.SavePrimitiveMediaRevenueSku(mixMediaBase.Sku, catalogMedia);
        }//end SaveMediaBaseInfo

        /// <summary>
        /// Sets and updates the ProductBase information for RawCatalogDB
        /// Uses for Game and GameContent
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveProductBaseInfo(RawCatalogDBEntities catalog, ProductBaseV1 mixProductBase, out Media catalogMedia, int mediaType)
        {
            byte geoCheckPolicyByte = 0;
            if (mixProductBase.GeoCheckPolicy)
            {
                geoCheckPolicyByte = 1;
            }

            catalog.SavePrimitiveMedia(out catalogMedia, mixProductBase.ProductId, mediaType, 123, mixProductBase.ReleaseDate,
                mixProductBase.VisibilityDate, mixProductBase.VisibilityStatus, geoCheckPolicyByte);

            catalog.SavePrimitiveMediaRevenueSku(mixProductBase.Sku, catalogMedia);

            SaveProductRatings(catalog, catalogMedia, mixProductBase.Ratings, mixProductBase.RatingDescriptors);
        }//end SaveProductBaseInfo

        /// <summary>
        /// /// Sets and updates the Ratings information for RawCatalogDB
        /// Uses for Game
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="catalogMedia">Media</param>
        /// <param name="mixRatings">GameRatingV1[]</param>
        static private void SaveProductRatings(RawCatalogDBEntities catalog, Media catalogMedia, int[] ratings, int[] ratingDescriptors)
        {
            int convertPegiAllToPegiFinland = -10000; // Pegi All Ratings are 14001-14005, and Pegi Finland are 4001-4005
            List<int> catalogRatingSystems = new List<int>();
            List<int> catalogRatings = new List<int>();
            List<int> catalogRatingDescriptors = new List<int>();
            bool ratedInPegiFinland = false;
            int pegiFinlandRatingValue = -1;

            if (ratings != null)
            {
                catalog.DeletePrimitiveMediaRatings(catalogMedia, ratings);

                // Validating RatingValues
                foreach (int rating in ratings)
                {
                    //Checks that no more than one RatingValue is being used for any RatingSystem
                    RatingValue catalogRatingValue = catalog.GetPrimitiveRatingValueOrThrow(rating);

                    if (!catalogRatingSystems.Contains(catalogRatingValue.ratingSystemId))
                    {
                        catalogRatingSystems.Add(catalogRatingValue.ratingSystemId);

                        if (catalogRatingValue.ratingSystemId == CatalogConstants.PegiFinlandRatingSystem)
                        {
                            ratedInPegiFinland = true;
                        }
                    } 
                    else
                    {                        
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_UNIQUE_RATINGSYSTEMS_ERROR,
                            String.Format("More than one RatingValue found for RatingSystem {0}, only one allowed per RatingSystem", catalogRatingValue.ratingSystemId));
                    }

                    // Adding matching PEGI-Finland ratings for PEGI-all ratings
                    if (catalogRatingValue.ratingSystemId == CatalogConstants.PegiAllCountriesRatingSystem)
                    {
                        pegiFinlandRatingValue = catalogRatingValue.ratingValueId + convertPegiAllToPegiFinland;
                    }

                    catalogRatings.Add(rating);
                }

                // Add to the list of Ratings if not already set by client
                if (!ratedInPegiFinland && pegiFinlandRatingValue != -1)
                {
                    catalogRatings.Add(pegiFinlandRatingValue);
                }

                // Ingest client given ratings and any additional PEGI ratings
                foreach(int rating in catalogRatings)
                {
                    catalog.SavePrimitiveMediaRating(catalogMedia, catalogMedia.mediaId, rating);
                }

            }

            if (ratingDescriptors != null)
            {
                catalog.DeletePrimitiveMediaRatingDescriptor(catalogMedia, ratingDescriptors);                
  
                foreach (int ratingDescriptor in ratingDescriptors)
                {
                    // Validate no duplicate ratingDescriptors in the product
                    if (catalogRatingDescriptors.Contains(ratingDescriptor))
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_DUPLICATE_RATINGDESCRIPTOR,
                            String.Format("Duplicate RatingDescriptor {0} found for Product {1}", ratingDescriptor, catalogMedia.mediaId));
                    }

                    catalogRatingDescriptors.Add(ratingDescriptor);

                    catalog.SavePrimitiveMediaRatingDescriptor(catalogMedia, catalogMedia.mediaId, ratingDescriptor, CatalogConstants.DefaultRatingDescriptorLevel);
                }
            }
        }//end SaveProductRatings

        /// <summary>
        /// Saves the Packages from App
        /// </summary>
        static private void SaveAppPackages(RawCatalogDBEntities catalog, AppV1 app, Media catalogMedia, App catalogApp)
        {
            if (app.Packages != null && app.Packages.Length > 0)
            {            
                catalog.SavePrimitiveMediaRelationShip(catalogMedia, catalogMedia, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload, CatalogConstants.GameSortOrder);

                //Validate if a duplicate ContentId occurs in the array of packages in this game
                ValidateAppPackageContentId(app.Packages);

                foreach (AppPackageV1 packages in app.Packages)
                {
                    SaveAppPackageInfo(catalog, packages, catalogMedia);
                }
            }
            else
            {
                catalog.DeletePrimitiveMediaRelationships(catalogMedia.mediaId, catalogMedia.mediaId);
            }
        }

        /// <summary>
        /// Saves the Executables from Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveProductPackages(RawCatalogDBEntities catalog, GameV1 game, Media catalogMedia, Game catalogGame)
        {
            if (game.Executables != null && game.Executables.Length > 0)
            {
                int effectiveLiveTitleId = (int)game.LiveTitleId;

                // Use special effective live title id for Xbox Originals and Xna Community games
                if (catalogMedia.MediaType == null && !catalogMedia.MediaTypeReference.IsLoaded)
                {
                    catalogMedia.MediaTypeReference.Load();
                }
                if (catalogMedia.MediaType.mediaTypeId == (int)CatalogConstants.MediaTypeEnum.XboxOriginalGame)
                {
                    effectiveLiveTitleId = CatalogConstants.XboxOriginalGameEffectiveTitleId;
                }
                else if (catalogMedia.MediaType.mediaTypeId == (int)CatalogConstants.MediaTypeEnum.XNACommunityGame)
                {
                    effectiveLiveTitleId = CatalogConstants.XnaCommunityGameEffectiveTitleId;
                }

                // Save the GameContent
                GameContent catalogGameContent = null;

                catalog.SavePrimitiveGameContent(out catalogGameContent, catalogMedia.mediaId, catalogGame, catalogMedia, effectiveLiveTitleId);
                catalog.SavePrimitiveMediaRelationShip(catalogMedia, catalogMedia, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload, CatalogConstants.GameSortOrder);
                
                //Validate if a duplicate ContentId occurs in the array of packages in this game
                ValidateContentId(game.Executables);

                foreach (ProductPackageV1 executable in game.Executables)
                {
                    SaveProductPackageInfo(catalog, executable, catalogMedia);
                }
            }
            else
            {
                // TODO: Clean up of removed ProductPackages ie: gamecontentinstances
                catalog.DeletePrimitiveMediaRelationships(catalogMedia.mediaId, catalogMedia.mediaId);
            }
        }

        /// <summary>
        /// Saves the VideoPreviews from Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        /// <param name="media"></param>
        static private void SaveVideoPreviews(RawCatalogDBEntities catalog, GameV1 game, Media catalogMedia)
        {
            // 360CS bug 173556 - MIX: don't delete streaming video from the catalog when GG props a title without streaming video
            // Do not allow video previews propped through MIX
            // Until they are fully supported

            if ((game.VideoPreviews != null) && (game.VideoPreviews.Length > 0))
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_OPERATION_NOT_SUPPORTED, "VideoPreviews are not supported for MIX v.1");
            }

            //MediaInstance[] mediaInstances = catalog.GetPrimitiveMediaInstances(game.ProductId, (byte)CatalogConstants.IsPreview.True);
            //Guid[] videoPreviewIds = null;

            //if (game.VideoPreviews != null)
            //{
            //    videoPreviewIds = new Guid[game.VideoPreviews.Length];

            //    // Save current videoPreviews
            //    for (int i = 0; i < game.VideoPreviews.Length; i++)
            //    {
            //        SaveVideoPreviewInfo(catalog, game.VideoPreviews[i], catalogMedia);
            //        videoPreviewIds[i] = game.VideoPreviews[i].PackageId;
            //    }
            //}

            //// For Games, POR has been since Stockholm that the only Preview-Instances present are For Video-Previews
            //// Need to remove any instances not in the Contract
            //if (mediaInstances != null)
            //{
            //    catalog.DeletePrimitiveVideoFiles(videoPreviewIds, mediaInstances);
            //    catalog.DeletePrimitiveVideoInstances(videoPreviewIds, mediaInstances);
            //    catalog.DeletePrimitivePreviewMediaInstances(videoPreviewIds, mediaInstances);
            //    catalog.DeletePrimitiveMediaInstances(videoPreviewIds, mediaInstances);
            //}
        }

        /// <summary>
        /// Saves the gamecontentPackages from Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveProductPackages(RawCatalogDBEntities catalog, GameContentV1 gameContent, Media catalogMedia)
        {
            if (gameContent.Packages != null)
            {
                //Validate if a duplicate ContentId occurs in the array of packages in this gamecontent
                ValidateContentId(gameContent.Packages);

                foreach (ProductPackageV1 contentPackage in gameContent.Packages)
                {
                    //Game Trials:  Do not want to overwrite the current MediaId if one exists
                    if (gameContent.GameContentTypeId == (int)CatalogConstants.MediaTypeEnum.GameTrial)
                    {
                        //Retrieving current MediaInstance row to obtain the current MediaId
                        MediaInstance catalogMediaInstance = catalog.MediaInstance.Where(mi => mi.mediaInstanceId == contentPackage.PackageId).FirstOrDefault();

                        if (catalogMediaInstance != null)
                        {
                            //loading Media to get Media Guid
                            if (!catalogMediaInstance.MediaReference.IsLoaded && catalogMediaInstance.Media == null)
                            {
                                catalogMediaInstance.MediaReference.Load();
                            }

                            Media catalogOriginalMedia = catalog.GetPrimitiveMediaOrThrow(catalogMediaInstance.Media.mediaId);

                            SaveProductPackageInfo(catalog, contentPackage, catalogOriginalMedia);
                            return;
                        }
                    }
                    SaveProductPackageInfo(catalog, contentPackage, catalogMedia);
                }


            }
        }

        /// <summary>
        /// Saves AppPackages to Database. 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="catalog"></param>
        /// <param name="appPackage"></param>
        /// <param name="media"></param>
        static private void SaveAppPackageInfo(RawCatalogDBEntities catalog, AppPackageV1 appPackage, Media catalogMedia)
        {
            MediaInstance catalogMediaInstance = null;

            // Save the mediaInstance
            catalog.SavePrimitiveMediaInstance(catalogMedia, appPackage.PackageId, (byte)CatalogConstants.IsAcquirable.True, CatalogConstants.IsAdSupported, (byte)CatalogConstants.IsPreview.False, out catalogMediaInstance);

            // Delete the Primitive MediaInstanceClientTypes which are in the database and not in the contract
            catalog.DeletePrimitiveMediaInstanceClientTypes(appPackage.ClientTypes, catalogMediaInstance);

            // Save the client types
            if (appPackage.ClientTypes != null)
            {
                foreach (int clientType in appPackage.ClientTypes)
                {
                    catalog.SavePrimitiveMediaInstanceClientType(clientType, catalogMediaInstance);
                }
            }

            AppInstance appInstance = null;
            //Save the AppInstance
            catalog.SavePrimitiveAppInstance(appPackage.PackageId, catalogMediaInstance,
                (long)appPackage.InstallSize, (long)appPackage.PackageSize, appPackage.ContentId,
                appPackage.PackageType, out appInstance);

            // Save the AppInstanceEncryptedKey
            if (appPackage.Encryption != null)
            {
                catalog.SavePrimitiveAppInstanceEncryptedKey(appPackage.Encryption.SymKey,
                    appPackage.Encryption.PublicKey, appInstance);
            }
            else
            {
                catalog.DeletePrimitiveAppInstanceEncryptedKey(appInstance);
            }

            // Save the AppInstanceFile
            if (appPackage.Files != null)
            {
                foreach (FileV1 file in appPackage.Files)
                {
                    catalog.SavePrimitiveAppInstanceFile(Guid.NewGuid(), appInstance, file.FileUrl, file.SortOrder);
                }

                int[] sortOrders = (from f in appPackage.Files
                                    select f.SortOrder).ToArray();
                catalog.DeletePrimitiveAppInstanceFile(appInstance, sortOrders);
            }
        }


        /// <summary>
        /// Saves productpackages to Database. 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveProductPackageInfo(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Media catalogMedia)
        {
            MediaInstance catalogMediaInstance = null;

            // Save the mediaInstance
            catalog.SavePrimitiveMediaInstance(catalogMedia, productPackage.PackageId, (byte)CatalogConstants.IsAcquirable.True, CatalogConstants.IsAdSupported, (byte)CatalogConstants.IsPreview.False, out catalogMediaInstance);

            // Delete the Primitive MediaInstanceClientTypes which are in the database and not in the contract
            catalog.DeletePrimitiveMediaInstanceClientTypes(productPackage.ClientTypes, catalogMediaInstance);

            // Save the client types
            if (productPackage.ClientTypes != null)
            {
                foreach (int clientType in productPackage.ClientTypes)
                {
                    catalog.SavePrimitiveMediaInstanceClientType(clientType, catalogMediaInstance);
                }
            }

            GameContentInstance gameContentInstance = null;
            //Save the GameContentInstance
            catalog.SavePrimitiveGameContentInstance(productPackage.PackageId, catalogMediaInstance,
                (long)productPackage.InstallSize, (long)productPackage.PackageSize, productPackage.ContentId,
                productPackage.PackageType, productPackage.SupportedGameRegionMask, out gameContentInstance);

            // Save the GameContentInstanceEncryptedKey
            if (productPackage.Encryption != null)
            {
                catalog.SavePrimitiveGameContentInstanceEncryptedKey(productPackage.Encryption.SymKey,
                    productPackage.Encryption.PublicKey, gameContentInstance);
            }
            else
            {
                catalog.DeletePrimitiveGameContentInstanceEncryptedKey(gameContentInstance);
            }

            // Save the GameContentInstanceFile
            if (productPackage.Files != null)
            {
                foreach (FileV1 file in productPackage.Files)
                {
                    catalog.SavePrimitiveGameContentInstanceFile(Guid.NewGuid(), gameContentInstance, file.FileUrl, file.SortOrder);
                }
                
                int[] sortOrders = (from f in productPackage.Files
                                    select f.SortOrder).ToArray();
                catalog.DeletePrimitiveGameContentInstanceFile(gameContentInstance, sortOrders);
            }
        }

        /// <summary>
        /// Saves videoPreviews to Database. 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveVideoPreviewInfo(RawCatalogDBEntities catalog, VideoPreviewV1 mixVideoPreview, Media catalogMedia)
        {
            MediaInstance catalogMediaInstance = null;
            VideoInstance catalogVideoInstance = null;

            //Save the mediaInstance
            catalog.SavePrimitiveMediaInstance(catalogMedia, mixVideoPreview.PackageId, (byte)CatalogConstants.IsAcquirable.False, CatalogConstants.IsAdSupported, (byte)CatalogConstants.IsPreview.True, out catalogMediaInstance);

            //Save the PreviewMediaInstance
            catalog.SavePrimitivePreviewMediaInstance(CatalogConstants.VideoPreviewPreviewMediaInstanceTypeId, mixVideoPreview.Country, CatalogConstants.VideoPreviewProviderId, CatalogConstants.VideoPreviewExternalLicenseContentId, CatalogConstants.VideoPreviewDRMLicenseIssuerId, catalogMediaInstance);

            //Save the VideoInstance
            catalog.SavePrimitiveVideoInstance(catalogMediaInstance, CatalogConstants.IsDRM, CatalogConstants.VideoPreviewAudioEncodingId, CatalogConstants.VideoPreviewVideoDefinitionId, CatalogConstants.VideoPreviewAspectRatio, CatalogConstants.VideoPreviewResolution, CatalogConstants.VideoPreviewEncodingId, CatalogConstants.VideoPreviewBitRate, out catalogVideoInstance);

            //Save the VideoFile -- only 1 allowed for Video Previes for Games, which is only scenario supported by MIX
            catalog.SavePrimitiveVideoFile(catalogVideoInstance, mixVideoPreview.FileUrl, CatalogConstants.VideoPreviewFileSize, CatalogConstants.VideoPreviewFileIndex);
        }

        /// <summary>
        /// Saves the images into the Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="image"></param>
        /// <param name="catalogMedia"></param>
        static private void SaveImageInfo(RawCatalogDBEntities catalog, ImageV1 image, Media catalogMedia)
        {
            catalog.SavePrimitiveImage(catalogMedia, null, null);

            // Process image instances and localized data
            if (image.LocalizedImageFiles != null)
            {
                #region Extract LocalizedImageFiles and Validate
                Dictionary<ImageInstanceKey, LocalizedImageFileV1> imageInstances = new Dictionary<ImageInstanceKey, LocalizedImageFileV1>();

                foreach(LocalizedImageFileV1 imageFile in image.LocalizedImageFiles)
                {
                    int lcid = catalog.GetPrimitiveLocaleOrThrow(imageFile.Locale).lcid;
                    ImageInstanceKey key = new ImageInstanceKey(lcid, imageFile.SizeId, imageFile.FormatId);
                    if (imageInstances.ContainsKey(key))
                    {
                        // key already exists
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_PRODUCT_DUPLICATE_IMAGE_INSTANCE_ID,
                            String.Format("Duplicate Image Instance Id not allowed. Combination of lcid ({0}), sizeId ({1}) and formatId ({2}) for Image {3} needs to be unique.",
                            key.Lcid,
                            key.SizeId,
                            key.FormatId,
                            image.ProductId));
                    }
                    imageInstances.Add(key,imageFile);
                }

                #endregion
                
                #region EquivalentLocales Extract and Validate

                Dictionary<string, string> equivalentLocaleMaps = new Dictionary<string, string>();

                equivalentLocaleMaps = ProcessEquivalentLocaleMaps(ExtractEquivalentLocaleMaps(image.LocalizedImageFiles));

                #endregion

                #region MediaLocale and MediaLocaleMaps Removal

                //Delete MediaLocales and related MediaLocaleMaps existing 
                //in the catalog but not present in the new submission 

                string[] localeList = (from elk in equivalentLocaleMaps.Values.Distinct()
                                       select elk).ToArray();

                catalog.DeletePrimitiveMediaLocale(catalogMedia, localeList);

                #endregion

                #region MediaInstance and MediaLocale Save

                // use the dictionary with all the image instances to get what needs to be added/updated
                foreach (ImageInstanceKey key in imageInstances.Keys)
                {
                    var catalogImageInstances = catalog.ImageInstance.Where(instance => 
                        instance.MediaInstance.Media.mediaId == image.ProductId 
                        && instance.Locale.lcid == key.Lcid
                        && instance.ImageSize.imageSizeId == key.SizeId 
                        && instance.ImageFormat.imageFormatId == key.FormatId);

                    Guid imageInstanceId;
                    MediaInstance imageMediaInstance = null;
                    LocalizedImageFileV1 localizedImageFile = imageInstances[key];

                    if (catalogImageInstances.Count() == 0)
                    {
                        // if this is a new ImageInstance key, try to use the id that is passed in or generate a new one.
                        imageInstanceId = (localizedImageFile.LocalizedFileId != Guid.Empty) ? localizedImageFile.LocalizedFileId : new Guid();
                    }
                    else if (catalogImageInstances.Count() == 1)
                    {
                        // if the id exists, use the same id that exists in database and ignore the one that is passed in
                        imageInstanceId = catalogImageInstances.First().imageMediaInstanceId;
                    }
                    else
                    {
                        // use the first imageInstanceId to do an update
                        imageInstanceId = catalogImageInstances.First().imageMediaInstanceId;

                        // delete the rest
                        foreach (ImageInstance catalogImageInstance in catalogImageInstances)
                        {
                            if (catalogImageInstance.imageMediaInstanceId != imageInstanceId)
                            {
                                catalog.DeleteObject(catalog.MediaInstance.Where(instance => catalogImageInstance.imageMediaInstanceId == instance.mediaInstanceId).First());
                                catalog.DeleteObject(catalogImageInstance);
                            }
                        }
                    }

                    catalog.SavePrimitiveMediaInstance(catalogMedia, imageInstanceId, (byte)1, (byte)0,
                        (byte)0, out imageMediaInstance);

                    catalog.SavePrimitiveImageInstance(imageMediaInstance, localizedImageFile.Locale, localizedImageFile.FileUrl, localizedImageFile.FormatId,
                        localizedImageFile.SizeId, CatalogConstants.ImageFileSize);

                    catalog.SavePrimitiveMediaLocale(catalogMedia, key.Lcid, string.Empty, string.Empty, string.Empty,
                        string.Empty, string.Empty, string.Empty, string.Empty, localizedImageFile.EquivalentLocales);
                }

                #endregion

                #region EquivalentLocales Save

                // Saving MediaLocaleMaps so the FE queries can retrieve content for a particular locale
                catalog.SavePrimitiveMediaLocaleMaps(catalogMedia, equivalentLocaleMaps);

                #endregion

            }

            // ProductRelationships Save

            SaveChildProductRelationship(catalog, catalogMedia, image.ProductRelationships);
        }

        /// <summary>
        /// Saves the products into the Database
        /// Passed in product would be the child media in the relationships
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        /// <param name="ProductRelationshipV1"></param>
        static private void SaveChildProductRelationship(RawCatalogDBEntities catalog, Media catalogMedia, ProductRelationshipV1[] mixProductRelationships)
        {
            Dictionary<Guid, int> mixProductList = new Dictionary<Guid, int>();
            
            //Save the mediarelationships
            if (mixProductRelationships != null)
            {
                foreach (ProductRelationshipV1 item in mixProductRelationships)
                {
                    Media catalogParentProduct = catalog.GetPrimitiveMediaOrThrow(item.ProductId);

                    catalog.SavePrimitiveMediaRelationShip(catalogParentProduct, catalogMedia, item.RelationshipTypeId, item.SortOrder);

                    mixProductList.Add(item.ProductId, item.RelationshipTypeId);
                }
            }

            // Removing old relationships
            MediaRelationship[] productMediaRelationShips = catalog.GetPrimitiveMediaRelationShip(catalogMedia.mediaId);
            // getting a list of all relationships in the catalog
            foreach (MediaRelationship catalogMediaRelationship in productMediaRelationShips)
            {
                // Checks if the Parent/Child relationship exists but with a different mediatype, to be deleted
                if (mixProductList.ContainsKey(catalogMediaRelationship.mediaId))
                {
                    if (mixProductList[catalogMediaRelationship.mediaId] != catalogMediaRelationship.mediaRelationshipTypeId)
                    {
                        //Deleting relationship
                        catalog.DeletePrimitiveMediaRelationships(catalogMediaRelationship.mediaId, catalogMedia.mediaId);
                    }
                }
                else
                {
                    // Old relationship that is no longer needed, to be deleted
                    catalog.DeletePrimitiveMediaRelationships(catalogMediaRelationship.mediaId, catalogMedia.mediaId);
                }
            }
        }

        /// <summary>
        /// Extracts equivalent locales from Localized Image Files
        /// </summary>
        /// <param name="localizedImageFiles">Media Files with localization information</param>
        /// <returns>Dictionary of LocaleMap to Locale[] (inverse mapping)</returns>
        private static Dictionary<string, string[]> ExtractEquivalentLocaleMaps(LocalizedImageFileV1[] localizedImageFiles)
        {
            Dictionary<string, string[]> equivalentLocalesInverseMaps = 
                (from lif in localizedImageFiles
                 select new { lif.Locale, lif.EquivalentLocales }).ToDictionary(el => el.Locale, el => el.EquivalentLocales);

            return (equivalentLocalesInverseMaps);
        }

        /// <summary>
        /// Extracts equivalent locales from Localized Data
        /// </summary>
        /// <param name="localizedData">Data Files with localization information</param>
        /// <returns>Dictionary of LocaleMap to Locale[] (inverse mapping)</returns>
        private static Dictionary<string, string[]> ExtractEquivalentLocaleMaps(LocalizedDataV1[] localizedData)
        {
            // Extract equivalent locales from the localized data
            Dictionary<string, string[]> equivalentLocalesInverseMaps =
                (from ld in localizedData
                 select new { ld.Locale, ld.EquivalentLocales }).ToDictionary(el => el.Locale, el => el.EquivalentLocales);

            return (equivalentLocalesInverseMaps);
        }

        /// <summary>
        /// Generates an equivalent locale map that can be used to generate MediaLocaleMaps,
        /// validates the equivalent locales, and adds the mapping to the media's own locale
        /// </summary>
        /// <param name="equivalentLocaleInverseMaps">Dictionary of LocaleMap to Locale[] (inverse mapping)</param>
        /// <returns>Dictionary of Locale to LocaleMap</returns>
        private static Dictionary<string, string> ProcessEquivalentLocaleMaps(Dictionary<string, string[]> equivalentLocaleInverseMaps)
        {           
            // Convert equivalent locales (which is an inverse Map - MediaLocale to MapLocale) 
            // to MediaLocaleMaps form with locales in string form)
            Dictionary<string, string> equivalentLocaleMaps = new Dictionary<string, string>();

            foreach (string localeMap in equivalentLocaleInverseMaps.Keys)
            {
                #region Explicit Mapping

                if (equivalentLocaleInverseMaps[localeMap] != null)
                {
                    // Create the equivalent locale mapping
                    foreach (string locale in equivalentLocaleInverseMaps[localeMap])
                    {
                        if (!equivalentLocaleMaps.Keys.Contains(locale))
                        {
                            equivalentLocaleMaps.Add(locale, localeMap);
                        }
                        else
                        {
                            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_MEDIALOCALEMAPS_INVALID_MAPPING,
                                    String.Format("The mapping for Locale '{0}' has already been defined in the current product and there shouldn't be duplicates.", locale));
                        }
                    }
                }

                #endregion

                #region Default Mapping

                // Add mapping to the media file's own locale by default
                if (!equivalentLocaleMaps.Keys.Contains(localeMap))
                {
                    equivalentLocaleMaps.Add(localeMap, localeMap);
                }
                else
                {
                    if (equivalentLocaleMaps[localeMap] != localeMap)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_MEDIALOCALEMAPS_INVALID_MAPPING,
                            String.Format("Locale '{0}' cannot be mapped to a different locale than itself.", localeMap));
                    }
                }

                #endregion
            }

            if (equivalentLocaleMaps.Count == 0)
            {
                // TODO - this check shouldn't be needed once story 139604 is done.
                //      139604 - LocalizedData[] should have a ArrayCountValidator to validate we always get at least one locale.
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_MEDIALOCALEMAPS_INVALID_MAPPING,
                    "The equivalent locale mappings were empty. Please ensure a Locale is present for the Media.");
            }

            return equivalentLocaleMaps;
        }

        /// <summary>
        /// Get array of ProductRelationships from  Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId">Child Media in the relationship</param>
        static private ProductRelationshipV1[] GetChildrenProductRelationships(RawCatalogDBEntities catalog, Guid mediaId)
        {
            MediaRelationship[] catalogMediaRelationShip = catalog.GetPrimitiveMediaRelationShip(mediaId); 
            List<ProductRelationshipV1> productRelationshipList = new List<ProductRelationshipV1>();
            
            //Populate the ProductRelationShips
            for (int i = 0; i < catalogMediaRelationShip.Length; i++)
            {
                if (catalogMediaRelationShip[i].mediaId != catalogMediaRelationShip[i].relatedMediaId) //Avoid the relationship of the media back to itself
                {
                    ProductRelationshipV1 mixProductRelationship = new ProductRelationshipV1();

                    if (catalogMediaRelationShip[i].MediaRelationshipType == null && !catalogMediaRelationShip[i].MediaRelationshipTypeReference.IsLoaded)
                    {
                        catalogMediaRelationShip[i].MediaRelationshipTypeReference.Load();
                    }
                    mixProductRelationship = new ProductRelationshipV1();
                    mixProductRelationship.RelationshipTypeId = catalogMediaRelationShip[i].MediaRelationshipType.mediaRelationshipTypeId;
                    mixProductRelationship.ProductId = catalogMediaRelationShip[i].mediaId;
                    mixProductRelationship.SortOrder = catalogMediaRelationShip[i].sortOrder;

                    productRelationshipList.Add(mixProductRelationship);
                }
            }

            return productRelationshipList.ToArray();
        }


        /// <summary>
        /// Loads the Image from Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="image"></param>
        static private void LoadImageInfo(RawCatalogDBEntities catalog, ImageV1 image)
        {
            Image catalogImage = catalog.GetPrimitiveImage(image.ProductId);
            image.ProductId = catalogImage.imageMediaId;

            ImageInstance[] catalogImageInstance = catalog.GetPrimitiveImageInstances(image.ProductId);
            LocalizedImageFileV1[] localizedFiles = new LocalizedImageFileV1[catalogImageInstance.Length];

            //Populate the LocalizedFiles
            for (int i = 0; i < catalogImageInstance.Length; i++)
            {
                if (catalogImageInstance[i].ImageSize == null && !catalogImageInstance[i].ImageSizeReference.IsLoaded)
                {
                    catalogImageInstance[i].ImageSizeReference.Load();
                }
                if (catalogImageInstance[i].ImageFormat == null && !catalogImageInstance[i].ImageFormatReference.IsLoaded)
                {
                    catalogImageInstance[i].ImageFormatReference.Load();
                }
                if (catalogImageInstance[i].Locale == null && !catalogImageInstance[i].LocaleReference.IsLoaded)
                {
                    catalogImageInstance[i].LocaleReference.Load();
                }

                localizedFiles[i] = new LocalizedImageFileV1();
                localizedFiles[i].LocalizedFileId = catalogImageInstance[i].imageMediaInstanceId;
                localizedFiles[i].FileUrl = catalogImageInstance[i].fileUrl;
                localizedFiles[i].FormatId = catalogImageInstance[i].ImageFormat.imageFormatId;
                localizedFiles[i].SizeId = catalogImageInstance[i].ImageSize.imageSizeId;
                ImageInstance catalogImageInstanceItem = catalogImageInstance[i];
                Locale catalogLocale = catalog.GetPrimitiveLocaleOrThrow(catalogImageInstanceItem.Locale.locale1);
                localizedFiles[i].Locale = catalogLocale.locale1;

                #region EquivalentLocales

                // Get Media Locale Maps for the image and its Locale
                MediaLocaleMap[] catalogMediaLocaleMaps = catalog.GetPrimitiveMediaLocaleMapMappings(image.ProductId, catalogLocale);

                // Only populate the EquivalentLocales optional field no mapping is there
                if (catalogMediaLocaleMaps != null)
                {
                    // Get the mapping array in its string representation
                    int[] catalogMediaLcidMaps = (from mlm in catalogMediaLocaleMaps
                                                 select mlm.lcid).ToArray();

                    // List of Locales to use as a dictionary
                    Locale[] catalogLocales = catalog.Locale.ToArray();

                    // Add the text version of the Locale based on it's LCID
                    localizedFiles[i].EquivalentLocales = (from cmlm in catalogMediaLcidMaps
                                                           from cl in catalogLocales
                                                           where cmlm == cl.lcid
                                                           select cl.locale1).ToArray();
                }

                #endregion
                
            }

            image.LocalizedImageFiles = localizedFiles;
            image.ProductRelationships = GetChildrenProductRelationships(catalog, image.ProductId);
        }

        /// <summary>
        /// Saves the game to Database
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGame">GameV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveGame(RawCatalogDBEntities catalog, GameV1 mixGame, Media catalogMedia, out Game catalogGame)
        {
            catalogGame = null;

            catalog.SavePrimitiveGame(mixGame.ProductId, mixGame.LiveTitleId, catalogMedia, out catalogGame);

            SaveLocalizationDataInfo(catalog, mixGame.GameLocalizedData, catalogMedia);
            SaveGameLocalizationDataInfo(catalog, mixGame.GameLocalizedData, catalogGame);
            SaveCategories(catalog, catalogMedia, mixGame.Categories);
        }//end SaveGame
        
        /// <summary>
        /// Saves the game to Database
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGame">AppV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveApp(RawCatalogDBEntities catalog, AppV1 mixApp, Media catalogMedia, out App catalogApp)
        {
            catalogApp = null;
            catalog.SavePrimitiveApp(mixApp.ProductId, mixApp.LiveTitleId, catalogMedia, out catalogApp);
            SaveLocalizationDataInfo(catalog, mixApp.AppLocalizedData, catalogMedia);
            SaveAppLocalizationDataInfo(catalog, mixApp.AppLocalizedData, catalogApp);
            ValidateCategoryPublisherBit(catalog, mixApp.TypeId, mixApp.Categories);
            SaveCategories(catalog, catalogMedia, mixApp.Categories);

            //Update AppTypes information
            catalog.DeletePrimitiveAppAppTypes(catalogMedia.mediaId, mixApp.AppTypes);
            foreach (int mixAppTypeId in mixApp.AppTypes)
            {
                catalog.SavePrimitiveAppAppType(catalogApp, mixAppTypeId);
            }
        }//end saveApp
         

        /// <summary>
        /// Save game attributes to database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixGame"></param>
        /// <param name="catalogGame"></param>
        static private void SaveGameAttributes(RawCatalogDBEntities catalog, GameV1 mixGame, Game catalogGame)
        {
            List<GameCapabilityCountry> catalogGameCapabilityCountriesToKeep = new List<GameCapabilityCountry>();

            if (mixGame.GameAttributes != null)
            {
                foreach (GameAttributeV1 mixGameAttribute in mixGame.GameAttributes)
                {
                    GameCapabilityCountry catalogGameCapabilityCountry = GameAttributeHelper.Save(catalog, catalogGame, mixGameAttribute);
                    catalogGameCapabilityCountriesToKeep.Add(catalogGameCapabilityCountry);
                }
            }
            
            // Delete extra game capabilities not passed as input to Mix
            GameAttributeHelper.Delete(catalog, catalogGame, catalogGameCapabilityCountriesToKeep.ToArray());
        }//end SaveGameAttributes


        /// <summary>
        /// Save game attributes to database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixGame"></param>
        /// <param name="catalogGame"></param>
        static private void SaveProductAttributes(RawCatalogDBEntities catalog, AppV1 mixApp, Media catalogMedia)
        {
            // Save (Insert or Update) new values to MediaCapabilityCountry table
            List<MediaCapabilityCountry> lmcc = new List<MediaCapabilityCountry>();

            if (mixApp.ProductAttributes != null)
            {
                foreach (ProductAttributeV1 prodAttr in mixApp.ProductAttributes)
                {
                    foreach (AttributeV1 attr in prodAttr.Attributes)
                    {
                        MediaCapabilityCountry mc;
                        catalog.SavePrimitiveMediaCapabilityCountry(catalogMedia, attr.AttributeName, prodAttr.Country, attr.Value, attr.AttributeUnitType, out mc);
                        lmcc.Add(mc);
                    }
                }
            }

            // Delete values that should no longer be in MediaCapabilityCountry table
            if (lmcc.Count > 0)
            {
                catalog.DeletePrimitiveMediaCapabilityCountries(mixApp.ProductId, lmcc.ToArray());
            }
        }//end SaveProductAttributes

        /// <summary>
        /// Saves the gamecontent to Database
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGameContent">GameContentV1</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveGameContent(RawCatalogDBEntities catalog, GameContentV1 mixGameContent,
            Media catalogMedia, out GameContent catalogGameContent)
        {
            catalogGameContent = null;

            ValidateCategoryPublisherBit(catalog, mixGameContent.GameContentTypeId, mixGameContent.Categories);

            //Retrieve the game with the smallest SortOrder
            int smallestSortOrder = int.MaxValue;

            Guid mixGameGuid = Guid.Empty;

            for (int i = 0; i < mixGameContent.GameRelationships.Length; i++)
            {
                if (mixGameContent.GameRelationships[i].SortOrder < smallestSortOrder)
                {
                    mixGameGuid = mixGameContent.GameRelationships[i].GameId;
                    smallestSortOrder = mixGameContent.GameRelationships[i].SortOrder;
                }
            }
            // TODO:  Add cases in which the game vaue is not given for Avatar Items (Bug 120008)
            Game catalogTempGame = catalog.GetPrimitiveGameOrThrow(mixGameGuid);

            catalog.SavePrimitiveGameContent(out catalogGameContent, mixGameContent.ProductId, catalogTempGame, catalogMedia, mixGameContent.EffectiveLiveTitle, mixGameContent.InheritRating);

            SaveLocalizationDataInfo(catalog, mixGameContent.LocalizedData, catalogMedia);
            SaveCategories(catalog, catalogMedia, mixGameContent.Categories);

            // Current list of MediaRelationships
            List<Guid> mixGameRelationships = new List<Guid>();
            foreach (GameRelationshipV1 relationship in mixGameContent.GameRelationships)
            {
                Media catalogGame = catalog.GetPrimitiveMediaOrThrow(relationship.GameId);

                catalog.SavePrimitiveMediaRelationShip(catalogGame, catalogMedia, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload, relationship.SortOrder);

                mixGameRelationships.Add(catalogGame.mediaId);
            }

            // Removing old MediaRelationships
            MediaRelationship[] catalogMediaRelationships = catalog.GetPrimitiveMediaRelationShip(catalogMedia.mediaId, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload);
            // Getting all relationships in the catalog
            foreach (MediaRelationship catalogMediaRelationship in catalogMediaRelationships)
            {
                // Checking if relationships in the catalog does not exist in the list of current relationships, to be deleted
                if (!mixGameRelationships.Contains(catalogMediaRelationship.mediaId))
                {
                    catalog.DeletePrimitiveMediaRelationships(catalogMediaRelationship.mediaId, catalogMedia.mediaId);
                }
            }

        }//end SaveGameContent

        /// <summary>
        /// Validates Product Management Category PublisherBit object
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixGameContent"></param>
        static private void ValidateCategoryPublisherBit(RawCatalogDBEntities catalog, int mediaTypeId, int[] mixCategories)
        {
            string publisherBitMediaTypes = Config.GetSetting("catalog_publisherBitMediaTypes");
            if (string.IsNullOrEmpty(publisherBitMediaTypes))
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_NO_SETTING,
                    "NPDB setting 'catalog_publisherBitMediaTypes' is missing and it is required for MixProductManagement");
            }

            string[] mediaTypesWithPublisherBits = publisherBitMediaTypes.Split(',');

            if (mediaTypesWithPublisherBits.Contains(mediaTypeId.ToString()))
            {
                // Validate that GameContent has at least one publisher bit category present in Catalog.
                // Propping with zero-bits for the bit-filter (i.e. no CategoryIds in System 12000) will make the Content not enumerate for games using XDK-APIs:
                bool publisherBitCategoryFound = false;
                foreach (int category in mixCategories)
                {
                    //Category c = TableOperations.GetPrimitiveCategoryOrThrow(catalog, category);
                    Category c = catalog.GetPrimitiveCategoryOrThrow(category);
                    if (c.categorySystemId == CatalogConstants.CategorySystemForPublisherBits)
                    {
                        if (publisherBitCategoryFound)
                        {
                            // found more than one, which is not supported
                            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_PRODUCT_TOOMANYPUBLISHERBITCATEGORIES,
                                "Product has more than one publisher bit category (from categorySystem 12000) in the Catalog and only one is allowed.");
                        }
                        publisherBitCategoryFound = true;
                    }
                }

                if (!publisherBitCategoryFound)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_PRODUCT_PUBLISHERBITCATEGORYMISSING,
                        "Product has is missing a publisher bit category (from categorySystem 12000) in the Catalog.");
                }
            }
        }

        /// <summary>
        /// Saves the categories for a Game or GameContent to Database
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="catalogMedia">Media</param>
        /// <param name="categories">int[]</param>
        static private void SaveCategories(RawCatalogDBEntities catalog, Media catalogMedia, int[] categories)
        {
            //Adding, Updating and deleting Categories
            catalog.DeletePrimitiveMediaCategories(catalogMedia, categories);

            //for each category that does not already exist
            if (categories != null)
            {
                foreach (int mixMediaCategory in categories)
                {
                    catalog.SavePrimitiveMediaCategory(catalogMedia, catalogMedia.mediaId, mixMediaCategory);
                }
            }
        }//end SaveCategories

        /// <summary>
        /// /// Sets and updates the LocalizationData information for RawCatalogDB
        /// Uses for Game and GameContent
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixLocalizedData">LocalizedDataV1[]</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveLocalizationDataInfo(RawCatalogDBEntities catalog, LocalizedDataV1[] mixLocalizedData, Media catalogMedia)
        {
            #region MediaLocale and MediaLocaleMaps Removal

            //Delete MediaLocales and related MediaLocaleMaps existing 
            //in the catalog but not present in the new submission 

            string[] localeList = (from mld in mixLocalizedData
                                       select mld.Locale).ToArray();
             
            catalog.DeletePrimitiveMediaLocale(catalogMedia, localeList);

            #endregion

            #region EquivalentLocales Extract and Validate

            Dictionary<string, string> equivalentLocaleMaps = new Dictionary<string, string>();

            equivalentLocaleMaps = ProcessEquivalentLocaleMaps(ExtractEquivalentLocaleMaps(mixLocalizedData));

            #endregion

            #region MediaLocale Save

            //insert or update medialocale that exist
            foreach (LocalizedDataV1 localizedData in mixLocalizedData)
            {
                int lcid = catalog.GetPrimitiveLocaleOrThrow(localizedData.Locale).lcid;

                catalog.SavePrimitiveMediaLocale(catalogMedia, lcid, localizedData.Title, localizedData.TitleSort,
                    localizedData.TitleReduced, localizedData.Description, localizedData.DescriptionReduced, localizedData.VoiceDisplayTitle,
                    CatalogConstants.MediaLocaleCopyright, localizedData.EquivalentLocales);
            }

            #endregion

            #region EquivalentLocales Save

            // Saving MediaLocaleMaps so the FE queries can retrieve content for a particular locale
            catalog.SavePrimitiveMediaLocaleMaps(catalogMedia, equivalentLocaleMaps);

            #endregion
        }

        /// <summary>
        /// /// Sets and updates the GameLocalizationData information for RawCatalogDB
        /// Uses for Game
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGameLocalizedDatas">GameLocalizedDataV1[]</param>
        /// <param name="catalogGame">Game</param>
        static private void SaveGameLocalizationDataInfo(RawCatalogDBEntities catalog, GameLocalizedDataV1[] mixGameLocalizedData, Game catalogGame)
        {
            #region GameLocale Removal

            //Delete MediaLocales existing in the catalog but not present in the new submission 

            string[] localeList = (from mgld in mixGameLocalizedData
                                       select mgld.Locale).ToArray();

            catalog.DeletePrimitiveGameLocale(catalogGame, localeList);

            #endregion

            #region GameLocale Save

            //insert or update medialocale that exist
            foreach (GameLocalizedDataV1 gameLocalizedData in mixGameLocalizedData)
            {
                int lcid = catalog.GetPrimitiveLocaleOrThrow(gameLocalizedData.Locale).lcid;
                
                catalog.SavePrimitiveGameLocale(catalogGame, lcid,
                    gameLocalizedData.CustomGenre, gameLocalizedData.Developer, gameLocalizedData.Publisher);
            }

            #endregion
        }

        /// <summary>
        /// /// Sets and updates the AppLocalizationData information for RawCatalogDB
        /// Uses for App
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGameLocalizedDatas">AppLocalizedDataV1[]</param>
        /// <param name="catalogApp">App</param>
        static private void SaveAppLocalizationDataInfo(RawCatalogDBEntities catalog, AppLocalizedDataV1[] mixAppLocalizedData, App catalogApp)
        {
            //Locale Removal
            string[] localeList = (from mgld in mixAppLocalizedData
                                   select mgld.Locale).ToArray();
            catalog.DeletePrimitiveAppLocale(catalogApp, localeList);

            //Locale Save
            foreach (AppLocalizedDataV1 AppLocalizedData in mixAppLocalizedData)
            {
                int lcid = catalog.GetPrimitiveLocaleOrThrow(AppLocalizedData.Locale).lcid;
                catalog.SavePrimitiveAppLocale(catalogApp, lcid, AppLocalizedData.Developer, AppLocalizedData.Publisher);

            }            
        }
                
        /// <summary>
        /// /// Sets and updates the Keywords and AlternateTitle information for RawCatalogDB
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixGameLocalizedDatas">SearchInformation[]</param>
        /// <param name="catalogMedia">Media</param>
        static private void SaveSearchInformation(RawCatalogDBEntities catalog, Media catalogMedia, SearchInformationV1[] mixSearchInformations)
        {
            if (mixSearchInformations != null)
            {
                foreach (SearchInformationV1 mixSearchInformation in mixSearchInformations)
                {
                    catalog.GetPrimitiveLocaleOrThrow(mixSearchInformation.Locale);
                }

                foreach (Locale catalogLocale in catalog.Locale)
                {
                    if (mixSearchInformations != null)
                    {
                        SearchInformationV1[] mixSearchInfo = mixSearchInformations.Where(msi => msi.Locale == catalogLocale.locale1).ToArray();
                        if (mixSearchInfo.Count() > 1)
                        {
                            // mutiple enteries of search information with the same locale found
                            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_PRODUCT_DUPLICATESEARCHLOCALE,
                                                string.Format("Duplicate SearchInformation with Locale {0}", catalogLocale.locale1));
                        }
                        else
                            if (mixSearchInfo.Count() == 1)
                            {
                                if (mixSearchInfo[0].Keywords != null)
                                {
                                    SaveSearchTerm(catalog, catalogMedia, (int)CatalogConstants.TermType.Keyword, catalogLocale.lcid, mixSearchInfo[0].Keywords);
                                }

                                if (mixSearchInfo[0].AlternateTitles != null)
                                {
                                    SaveSearchTerm(catalog, catalogMedia, (int)CatalogConstants.TermType.AlternateTitle, catalogLocale.lcid, mixSearchInfo[0].AlternateTitles);
                                }

                            }
                    }
                }
            }
        } // SaveSearchInformation

        /// <summary>
        /// updates the database to have a matching list of term values per lcid and term type
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        static private void SaveSearchTerm(RawCatalogDBEntities catalog, Media catalogMedia, int termTypeId, int lcid, string[] mixTerms)
        {
            // Creating a list of terms in the catalog            
            MediaTerm[] catalogMediaTerms = catalog.GetPrimitiveMediaTerm(catalogMedia.mediaId, termTypeId, lcid);
            List<string> catalogTerms = catalogMediaTerms.Select(cmt => cmt.term).ToList();
 


            List<string> duplicateTerms = new List<string>();
            List<string> newTerms = new List<string>();
            foreach (string term in mixTerms)
            {
                //Verify no duplicates occur in mixTerms
                if (duplicateTerms.Contains(term.ToUpper()))
                {
                    // duplicate keyword found in this locale
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_PRODUCT_DUPLICATETERM,
                        string.Format("Duplicate Term '{0}' found in lcid {1}", term, lcid.ToString()));
                }

                duplicateTerms.Add(term.ToUpper());

                if(!catalogTerms.Contains(term))
                {
                    // to be inserted into the database
                    newTerms.Add(term);
                }else
                {
                    // exist in both mix metadata and catalog
                    catalogTerms.Remove(term);
                }
            }            

            // Inserting new terms into the database
            foreach (string newTerm in newTerms)
            {
                catalog.SavePrimitiveMediaTerm(catalogMedia, catalogMedia.mediaId, termTypeId, lcid, newTerm);
            }
            
            // Deleting existing terms from the database
            foreach (string catalogTerm in catalogTerms)
            {
                catalog.DeletePrimitiveMediaTerm(catalogMedia, termTypeId, lcid, catalogTerm);
            }
        }



        
        /// <summary>
        /// Saves a bundle product to database
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixBundle">Mix Bundle Data Contract</param>
        /// <param name="catalogMedia"></param>
        static private void SaveBundleInfo(RawCatalogDBEntities catalog, BundleV1 mixBundle, Media catalogMedia)
        {
            // save localized data
            SaveLocalizationDataInfo(catalog, mixBundle.BundleLocalizedData, catalogMedia);

            // delete any existing MediaRelationship that we are not updating
            catalog.DeletePrimitiveMediaRelationships(mixBundle.ProductId,
                (int)CatalogConstants.MediaRelationshipTypeEnum.BundleToAssociatedMedia, mixBundle.ProductIds);

            //Save the ProductIds as MediaRelationships
            if (mixBundle.ProductIds != null)
            {
                // add/update Media Relationships
                int sortOrder = 1;
                foreach (Guid relatedProductId in mixBundle.ProductIds)
                {
                    Media relatedMedia = catalog.GetPrimitiveMediaOrThrow(relatedProductId);

                    catalog.SavePrimitiveMediaRelationShip(catalogMedia, relatedMedia,
                        (int)CatalogConstants.MediaRelationshipTypeEnum.BundleToAssociatedMedia, sortOrder++);
                }
            }
        }

        /// <summary>
        /// Saves the Points Bundle Product into Catalog
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixPointsBundle"></param>
        /// <param name="catalogMedia"></param>
        static private void SavePointsBundleInfo(RawCatalogDBEntities catalog, PointsBundleV1 mixPointsBundle, Media catalogMedia)
        {

            //Saves localized data
            SaveLocalizationDataInfo(catalog, mixPointsBundle.LocalizedData, catalogMedia);

            //Saves the Points Bundle Product
            catalog.SavePrimitivePointsBundle(mixPointsBundle.ProductId, mixPointsBundle.Points, catalogMedia);

            //query for the dash title
            Media catalogGame = catalog.GetPrimitiveMediaOrThrow(MixConstants.DashTitleProductId);

            //create dashtitle->media association.We dont need to delete as this is the only link which will ever be created
            catalog.SavePrimitiveMediaRelationShip(catalogGame, catalogMedia, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload, 0);
        }

        /// <summary>
        /// Saves the Subscription Family into Catalog
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixSubscriptionFamily"></param>
        /// <param name="catalogMedia"></param>
        static private void SaveBasicSubscriptionFamilyInfo(RawCatalogDBEntities catalog, SubscriptionFamilyV1 mixSubscriptionFamily,
            Media catalogMedia)
        {
            SubscriptionFamily subscriptionFamily = new SubscriptionFamily();
            SaveBasicSubscriptionFamilyInfo(catalog, mixSubscriptionFamily, catalogMedia, out subscriptionFamily);
        }

        /// <summary>
        /// Saves the Subscription Family into Catalog
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixPointsBundle"></param>
        /// <param name="catalogMedia"></param>
        static private void SaveBasicSubscriptionFamilyInfo(RawCatalogDBEntities catalog, SubscriptionFamilyV1 mixSubscriptionFamily,
            Media catalogMedia, out SubscriptionFamily catalogSubFamily)
        {

            //Validates the subscription family info
            ValidateSubscriptionFamilyInfo(mixSubscriptionFamily);

            //Save the localized data
            SaveLocalizationDataInfo(catalog, mixSubscriptionFamily.LocalizedData, catalogMedia);

            #region ProductRelationships Save

            Dictionary<Guid, int> mixSubscriptionFamilyList = new Dictionary<Guid, int>();


            //Save the mediarelationships
            if (mixSubscriptionFamily.ProductRelationships != null)
            {
                foreach (ProductRelationshipV1 item in mixSubscriptionFamily.ProductRelationships)
                {
                    Media catalogParentProduct = catalog.GetPrimitiveMediaOrThrow(item.ProductId);

                    catalog.SavePrimitiveMediaRelationShip(catalogParentProduct, catalogMedia, item.RelationshipTypeId, item.SortOrder);

                    mixSubscriptionFamilyList.Add(item.ProductId, item.RelationshipTypeId);
                }
            }

            // Removing old relationships
            MediaRelationship[] productMediaRelationShips = catalog.GetPrimitiveMediaRelationShip(mixSubscriptionFamily.ProductId);
            // getting a list of all relationships in the catalog
            foreach (MediaRelationship catalogMediaRelationship in productMediaRelationShips)
            {
                // Checks if the Parent/Child relationship exists but with a different mediatype, to be deleted
                if (mixSubscriptionFamilyList.ContainsKey(catalogMediaRelationship.mediaId))
                {
                    if (mixSubscriptionFamilyList[catalogMediaRelationship.mediaId] != catalogMediaRelationship.mediaRelationshipTypeId)
                    {
                        //Deleting relationship
                        catalog.DeletePrimitiveMediaRelationships(catalogMediaRelationship.mediaId, mixSubscriptionFamily.ProductId);
                    }
                }
                else
                {
                    // Old relationship that is no longer needed, to be deleted
                    catalog.DeletePrimitiveMediaRelationships(catalogMediaRelationship.mediaId, mixSubscriptionFamily.ProductId);
                }
            }

            #endregion


            //Saves the subscription Family base.We also save services here
            catalog.SavePrimitiveSubscriptionFamilyBase(mixSubscriptionFamily.ProductId, catalogMedia,
                mixSubscriptionFamily.InternalName, mixSubscriptionFamily.Services,(int)mixSubscriptionFamily.TitleId,out catalogSubFamily);
        }

        /// <summary>
        /// Saves the Live subscription family info
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixSubscriptionFamily"></param>
        /// <param name="catalogMedia"></param>
        static private void SaveLiveSubscriptionFamilyInfo(RawCatalogDBEntities catalog,
            LiveSubscriptionFamilyV1 mixLiveSubscriptionFamily, Media catalogMedia)
        {
            SubscriptionFamily subscriptionFamily = null;
            //Save the basic info
            SaveBasicSubscriptionFamilyInfo(catalog, mixLiveSubscriptionFamily, catalogMedia, out subscriptionFamily);
            //Save the Live subscription family
            catalog.SavePrimitiveLiveSubscriptionFamily(catalogMedia, mixLiveSubscriptionFamily.Tier, subscriptionFamily);

        }

        /// <summary>
        /// Saves the subscription Info
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixLiveSubscriptionFamily"></param>
        /// <param name="catalogMedia"></param>
        static private void SaveSubscriptionInfo(RawCatalogDBEntities catalog, SubscriptionBaseV1 mixSubscription, Media catalogMedia)
        {
            ValidateSubscriptionInfo(mixSubscription);
            catalog.SavePrimitiveSubscription(mixSubscription.ProductId, catalogMedia,
                mixSubscription.InternalName, mixSubscription.BillingFrequencyId, mixSubscription.SubscriptionDuration,
                mixSubscription.SubscriptionDurationTypeId, mixSubscription.SellTypeId, Convert.ToInt32(mixSubscription.IsCancelable),
                mixSubscription.SubscriptionFamilyId, mixSubscription.ServiceComponentId);

            //save the localized data for subscriptions
            SaveLocalizationDataInfo(catalog, mixSubscription.LocalizedData, catalogMedia);
        }


        /// <summary>
        /// Removes all Image Relationships for this Product
        /// Functionality is turned on and off by a NPDB setting
        /// For more information check out Product Studio Bug 178487 "MixProductManagement - Game and GameContent remove Image Relationships"
        /// </summary>
        /// <param name="mixProduct">ProductV1</param>
        static private void RemoveImageRelationships(RawCatalogDBEntities catalog, ProductV1 mixProduct)
        {
            bool cleanupImages = Config.GetBoolSetting(Setting.mix_productMgmt_imageCleanup);

            if (cleanupImages)
            {
                // Get a list of all mediarelationships for this product
                MediaRelationship[] catalogMediaRelationships = catalog.GetPrimitiveMediaRelationShipByMedia(mixProduct.ProductId);

                foreach (MediaRelationship catalogMediaRelationship in catalogMediaRelationships)
                {
                    // Remove the relatinoship if the related type is an image
                    Image catalogImage = catalog.GetPrimitiveImage(catalogMediaRelationship.relatedMediaId);
                    if (catalogImage != null)
                    {
                        catalog.DeletePrimitiveMediaRelationships(mixProduct.ProductId, catalogImage.imageMediaId); 
                    }
                }
            }
        }//end RemoveImageRelationships


        #region Validation Methods

        /// <summary>
        /// Validates that no ContentId is duplicated across ProductPackages 
        /// Used in Configuring of Game and Gamecontent
        /// </summary>
        static private void ValidateContentId(ProductPackageV1[] packages)
        {
            Dictionary<string, object> contentIdDict = new Dictionary<string, object>();
            foreach (ProductPackageV1 package in packages)
            {
                if (contentIdDict.ContainsKey(BitConverter.ToString(package.ContentId))) //using strings because byte arrays comparisons dont work here
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_DUPLICATE_CONTENTID,
                       String.Format("Can not assign the provided ContentId to package '{0}' because another package already exists with the same contentId for this product",
                       package.PackageId.ToString()));
                }
                contentIdDict.Add(BitConverter.ToString(package.ContentId), null); // converstion of byte array to hex to ease debugging if necessary
            }
        }
        /// <summary>
        /// Validates that no ContentId is duplicated across ProductPackages 
        /// Used in Configuring of App
        /// </summary>
        static private void ValidateAppPackageContentId(AppPackageV1[] packages)
        {
            Dictionary<string, object> contentIdDict = new Dictionary<string, object>();
            foreach (AppPackageV1 package in packages)
            {
                if (contentIdDict.ContainsKey(BitConverter.ToString(package.ContentId))) //using strings because byte arrays comparisons dont work here
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_DUPLICATE_CONTENTID,
                       String.Format("Can not assign the provided ContentId to package '{0}' because another package already exists with the same contentId for this product",
                       package.PackageId.ToString()));
                }
                contentIdDict.Add(BitConverter.ToString(package.ContentId), null); // converstion of byte array to hex to ease debugging if necessary
            }
        }

        /// <summary>
        /// Validates the subscription data
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixSubscription"></param>
        /// <param name="catalogMedia"></param>
        static private void ValidateSubscriptionInfo(SubscriptionBaseV1 mixSubscription)
        {
            //Duration type check
            if (!mixSubscription.SubscriptionDuration.HasValue && mixSubscription.SubscriptionDurationTypeId != (int)CatalogConstants.DurationType.NonTerminating)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_DURATION_TYPE, "Duration Type {0} is not valid for Duration value null", mixSubscription.SubscriptionDurationTypeId);
            }
        }

        /// <summary>
        /// Validates the subscriptionFamily data
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixSubscriptionFamily"></param>
        /// <param name="catalogMedia"></param>
        static private void ValidateSubscriptionFamilyInfo(SubscriptionFamilyV1 mixSubscriptionFamily)
        {
            if (mixSubscriptionFamily.ProductRelationships != null && mixSubscriptionFamily.ProductRelationships.Length > 0)
            {
                StringBuilder errorMessage = new StringBuilder();
                foreach (ProductRelationshipV1 item in mixSubscriptionFamily.ProductRelationships)
                {
                    if (item.RelationshipTypeId != (int)CatalogConstants.MediaRelationshipTypeEnum.SubscriptionFamilyToAllowedUpgrade
                        && item.RelationshipTypeId != (int)CatalogConstants.MediaRelationshipTypeEnum.SubscriptionFamilyToAllowedDownGrade
                        && item.RelationshipTypeId != (int)CatalogConstants.MediaRelationshipTypeEnum.SubscriptionFamilyToAllowedAddon
                        && item.RelationshipTypeId != (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload
                        )
                    {
                        errorMessage.AppendLine(string.Format("MediaRelationShiptype {0} is not valid for a subscriptionFamily with mediaid {1}", item.RelationshipTypeId, mixSubscriptionFamily.ProductId));
                    }
                }
                if (errorMessage.Length > 0)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_INVALID_MEDIA_RELATIONSHIP_TYPE, errorMessage.ToString());
                }
            }
        }
        #endregion
        
        #endregion
    }

    /// <summary>
    /// Helper class to represent how we will do lookups for the Image Instance Key
    /// </summary>
    class ImageInstanceKey
    {
        public int Lcid;
        public int SizeId;
        public int FormatId;

        public ImageInstanceKey(int lcid, int sizeId, int formatId)
        {
            this.Lcid = lcid;
            this.SizeId = sizeId;
            this.FormatId = formatId;
        }

        public override bool Equals(object obj)
        {
            ImageInstanceKey otherKey = obj as ImageInstanceKey;
            if (otherKey != null)
            {
                return (this.FormatId == otherKey.FormatId) && (this.SizeId == otherKey.SizeId) && (this.Lcid == otherKey.Lcid);
            }

            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            //A hash function must have the following properties: 
            //If two objects compare as equal, the GetHashCode method for each object must return the same value. However, if two objects do not compare as equal, the GetHashCode methods for the two object do not have to return different values.
            //The GetHashCode method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's Equals method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.
            //For the best performance, a hash function must generate a random distribution for all input. 

            // assuming we will use 16 bits for lcid, 8 bits for formatId and 8 bits for sizeId
            return this.Lcid | (this.FormatId << 16) | (this.SizeId << 24);
        }

        public override string ToString()
        {
            return this.GetHashCode().ToString("X");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsManagementV3.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.mix.common;
using xonline.server.webcache.common;
using xonline.mix.settingsmanagement.contract;
using xonline.common.mgmt;
using xonline.server.liveinfo.client;

namespace xonline.mix.settingsmanagement.service
{
    // NOTE: If you change the class name "MixSettingsManagement" here, you must also update the reference to "MixSettingsManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixSettingsManagementV3 : IMixSettingsManagementV3
    {
        public IEnumerable<LiveHiveSettingV3> GetSettings(LiveHiveConfigV3 config)
        {
            List<LiveHiveSettingV3> ret = new List<LiveHiveSettingV3>();

            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetSettingsApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "ResultCount"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetSettingsApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert the config
                LiveInfoConfig lic = MixSettingsDataTypeFactory.Convert(config);

                // Run the call and convert the results
                foreach(LiveInfoSetting setting in MixSettingsManagement.GetSettings(lic))
                {
                    ret.Add(MixSettingsDataTypeFactory.ConvertV3(setting));
                }

                logHelper.SetCountField("ResultCount", ret);
            });

            return ret;
        }

        public void SetSetting(LiveHiveConfigV3 config, LiveHiveSettingV3 setting)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetSettingApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "SettingName", "SettingValue"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                if (setting!=null)
                {
                    logHelper.SetField("SettingName", setting.Name);
                    logHelper.SetStringField("SettingValue", setting.Value, 200);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetSettingApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                LiveInfoConfig cfg = MixSettingsDataTypeFactory.Convert(config);
                LiveInfoSetting set = MixSettingsDataTypeFactory.Convert(setting);

                MixSettingsManagement.SetSetting(cfg, set);
            });
        }

        public string IngestEtxManifest(string xmlManifest)
        {
            string ret=null;

            LogHelper logHelper=new LogHelper(MixSettingsManagement.IngestEtxManifestApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"XmlManifest", "Return"});
                logHelper.SetStringField("XmlManifest", xmlManifest, 100);

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.IngestEtxManifestApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                ret=MixSettingsManagement.IngestEtxManifest(xmlManifest);

                logHelper.SetStringField("Return", ret, 100);
            });

            return ret;
        }

        public void SetBusinessPartner(BusinessPartnerV3 bpv3)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetBusinessPartnerApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"BusinessPartnerID", "FriendlyName", "ConnectionInfoCount"});

                if (bpv3 != null)
                {
                    logHelper.SetField("BusinessPartnerID", bpv3.BusinessPartnerID);
                    logHelper.SetField("FriendlyName", bpv3.FriendlyName);

                    if(bpv3.ConnectionInfos != null)
                    {
                        logHelper.SetField("ConnectionInfoCount", bpv3.ConnectionInfos.Length);
                    }
                    else
                    {
                        logHelper.SetField("ConnectionInfoCount", "null");
                    }
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetBusinessPartnerApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                BusinessPartner bp = MixSettingsDataTypeFactory.Convert(bpv3);

                MixSettingsManagement.SetBusinessPartner(bp);
            });
        }

        public void SetAppliesToInfo(STSAppliesToV3 atv3)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetAppliesToInfoApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri", "BusinessPartnerID", "ValidityInterval", "TokenType", "ClaimTypesCount", "AppliesToCertificate"});

                if (atv3 != null)
                {
                    logHelper.SetField("AppliesToUri", atv3.AppliesToUri);
                    logHelper.SetField("BusinessPartnerID", atv3.BusinessPartnerID);
                    logHelper.SetField("ValidityInterval", atv3.ValidityInterval);
                    logHelper.SetField("TokenType", atv3.TokenType);
                    logHelper.SetField("AppliesToCertificate", atv3.AppliesToCertificate);
                    logHelper.SetField("ClaimTypesCount", atv3.ClaimTypes.Length);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                STSAppliesTo at = MixSettingsDataTypeFactory.Convert(atv3);

                MixSettingsManagement.SetAppliesToInfo(at);
            });
        }

        public void RemoveAppliesToInfo(string appliesToUri)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.RemoveAppliesToInfoApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri"});

                if (appliesToUri != null)
                {
                    logHelper.SetField("AppliesToUri", appliesToUri);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.RemoveAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                MixSettingsManagement.RemoveAppliesToInfo(appliesToUri);
            });
        }

        public STSAppliesToV3 GetAppliesToInfo(string appliesToUri)
        {
            STSAppliesToV3 atv3 = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetAppliesToInfoApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri"});

                if (atv3 != null)
                {
                    logHelper.SetField("AppliesToUri", appliesToUri);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                STSAppliesTo at = MixSettingsManagement.GetAppliesToInfo(appliesToUri);
                atv3 = MixSettingsDataTypeFactory.Convert(at);
            });

            return atv3;
        }

        public STSClaimTypeInfoV3[] GetClaimTypes()
        {
            STSClaimTypeInfoV3[] claims = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetClaimTypesApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetClaimTypesApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                STSClaimTypeInfo[] cti = MixSettingsManagement.GetClaimTypes();
                claims = MixSettingsDataTypeFactory.ConvertAll(cti);
            });

            return claims;
        }

        public string[] GetTokenTypes()
        {
            string[] tokenTypes = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetTokenTypesApiName, "V3");
            logHelper.ExecuteAndLog(delegate()
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetTokenTypesApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                tokenTypes = MixSettingsManagement.GetTokenTypes();
            });

            return tokenTypes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsManagementV1.svc.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.mix.common;
using xonline.server.webcache.common;
using xonline.mix.settingsmanagement.contract;
using xonline.common.mgmt;
using xonline.server.liveinfo.client;

[assembly: XomIisInstallerAttribute(Interface.mixsettingsmanagement)]
[assembly: ConfigAttribute(Component.mixsettingsmanagement)]
[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.mix.settingsmanagement.service
{
    // NOTE: If you change the class name "MixSettingsManagement" here, you must also update the reference to "MixSettingsManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixSettingsManagementV1 : IMixSettingsManagementV1
    {
        public IEnumerable<LiveHiveSettingV1> GetSettings(LiveHiveConfigV1 config)
        {
            List<LiveHiveSettingV1> ret = new List<LiveHiveSettingV1>();

            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetSettingsApiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "ResultCount"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetSettingsApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert the config
                LiveInfoConfig lic = MixSettingsDataTypeFactory.Convert(config);

                // Run the call and convert the results
                foreach(LiveInfoSetting setting in MixSettingsManagement.GetSettings(lic))
                {
                    ret.Add(MixSettingsDataTypeFactory.ConvertV1(setting));
                }

                logHelper.SetCountField("ResultCount", ret);
            });

            return ret;
        }

        public void SetSetting(LiveHiveConfigV1 config, LiveHiveSettingV1 setting)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetSettingApiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "SettingName", "SettingValue"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                if (setting!=null)
                {
                    logHelper.SetField("SettingName", setting.Name);
                    logHelper.SetStringField("SettingValue", setting.Value, 200);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetSettingApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                LiveInfoConfig cfg = MixSettingsDataTypeFactory.Convert(config);
                LiveInfoSetting set = MixSettingsDataTypeFactory.Convert(setting);

                MixSettingsManagement.SetSetting(cfg, set);
            });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SettingsManagement\Service\MixSettingsManagementV4.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.mix.common;
using xonline.server.webcache.common;
using xonline.mix.settingsmanagement.contract;
using xonline.common.mgmt;
using xonline.server.liveinfo.client;

namespace xonline.mix.settingsmanagement.service
{
    // NOTE: If you change the class name "MixSettingsManagement" here, you must also update the reference to "MixSettingsManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixSettingsManagementV4 : IMixSettingsManagementV4
    {
        public IEnumerable<LiveHiveSettingV4> GetSettings(LiveHiveConfigV4 config)
        {
            List<LiveHiveSettingV4> ret = new List<LiveHiveSettingV4>();

            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetSettingsApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "ResultCount"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetSettingsApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert the config
                LiveInfoConfig lic = MixSettingsDataTypeFactory.Convert(config);

                // Run the call and convert the results
                foreach(LiveInfoSetting setting in MixSettingsManagement.GetSettings(lic))
                {
                    ret.Add(MixSettingsDataTypeFactory.ConvertV4(setting));
                }

                logHelper.SetCountField("ResultCount", ret);
            });

            return ret;
        }

        public void SetSetting(LiveHiveConfigV4 config, LiveHiveSettingV4 setting)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetSettingApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Build", "QFE", "BetaGroupId", "PlatformType", "SettingName", "SettingValue"});

                if (config!=null)
                {
                    logHelper.SetField("Build", config.Build);
                    logHelper.SetField("QFE", config.Qfe);
                    logHelper.SetField("BetaGroupId", config.BetaGroupId);
                    logHelper.SetField("PlatformType", config.Platform);
                }

                if (setting!=null)
                {
                    logHelper.SetField("SettingName", setting.Name);
                    logHelper.SetStringField("SettingValue", setting.Value, 200);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetSettingApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                LiveInfoConfig cfg = MixSettingsDataTypeFactory.Convert(config);
                LiveInfoSetting set = MixSettingsDataTypeFactory.Convert(setting);

                MixSettingsManagement.SetSetting(cfg, set);
            });
        }

        public string IngestEtxManifest(string xmlManifest)
        {
            string ret=null;

            LogHelper logHelper=new LogHelper(MixSettingsManagement.IngestEtxManifestApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"XmlManifest", "Return"});
                logHelper.SetStringField("XmlManifest", xmlManifest, 100);

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.IngestEtxManifestApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                ret=MixSettingsManagement.IngestEtxManifest(xmlManifest);

                logHelper.SetStringField("Return", ret, 100);
            });

            return ret;
        }

        public void SetBusinessPartner(BusinessPartnerV4 bpV4)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetBusinessPartnerApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[] { "BusinessPartnerID", "FriendlyName", "Type", "ConnectionInfoCount" });

                if (bpV4 != null)
                {
                    logHelper.SetField("BusinessPartnerID", bpV4.BusinessPartnerID);
                    logHelper.SetField("FriendlyName", bpV4.FriendlyName);
                    logHelper.SetField("Type", bpV4.Type);

                    if(bpV4.ConnectionInfos != null)
                    {
                        logHelper.SetField("ConnectionInfoCount", bpV4.ConnectionInfos.Length);
                    }
                    else
                    {
                        logHelper.SetField("ConnectionInfoCount", "null");
                    }
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetBusinessPartnerApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                BusinessPartner bp = MixSettingsDataTypeFactory.Convert(bpV4);

                MixSettingsManagement.SetBusinessPartner(bp);
            });
        }

        public void SetAppliesToInfo(STSAppliesToV4 atV4)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.SetAppliesToInfoApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri", "BusinessPartnerID", "ValidityInterval", "TokenType", "ClaimTypesCount", "AppliesToCertificate"});

                if (atV4 != null)
                {
                    logHelper.SetField("AppliesToUri", atV4.AppliesToUri);
                    logHelper.SetField("BusinessPartnerID", atV4.BusinessPartnerID);
                    logHelper.SetField("ValidityInterval", atV4.ValidityInterval);
                    logHelper.SetField("TokenType", atV4.TokenType);
                    logHelper.SetField("AppliesToCertificate", atV4.AppliesToCertificate);
                    logHelper.SetField("ClaimTypesCount", atV4.ClaimTypes.Length);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.SetAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                // Convert args
                STSAppliesTo at = MixSettingsDataTypeFactory.Convert(atV4);

                MixSettingsManagement.SetAppliesToInfo(at);
            });
        }

        public void RemoveAppliesToInfo(string appliesToUri)
        {
            LogHelper logHelper=new LogHelper(MixSettingsManagement.RemoveAppliesToInfoApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri"});

                if (appliesToUri != null)
                {
                    logHelper.SetField("AppliesToUri", appliesToUri);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.RemoveAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                MixSettingsManagement.RemoveAppliesToInfo(appliesToUri);
            });
        }

        public STSAppliesToV4 GetAppliesToInfo(string appliesToUri)
        {
            STSAppliesToV4 atV4 = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetAppliesToInfoApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"AppliesToUri"});

                if (atV4 != null)
                {
                    logHelper.SetField("AppliesToUri", appliesToUri);
                }

                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetAppliesToInfoApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                STSAppliesTo at = MixSettingsManagement.GetAppliesToInfo(appliesToUri);
                atV4 = MixSettingsDataTypeFactory.ConvertV4(at);
            });

            return atV4;
        }

        public STSClaimTypeInfoV4[] GetClaimTypes(string businessPartnerType)
        {
            STSClaimTypeInfoV4[] claims = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetClaimTypesApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetClaimTypesApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                STSClaimTypeInfo[] cti = MixSettingsManagement.GetClaimTypes(businessPartnerType);
                claims = MixSettingsDataTypeFactory.ConvertAllV4(cti);
            });

            return claims;
        }

        public string[] GetTokenTypes()
        {
            string[] tokenTypes = null;
            LogHelper logHelper=new LogHelper(MixSettingsManagement.GetTokenTypesApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetTokenTypesApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                tokenTypes = MixSettingsManagement.GetTokenTypes();
            });

            return tokenTypes;
        }

        public string[] GetBusinessPartnerTypes()
        {
            string[] bpTypes = null;
            LogHelper logHelper = new LogHelper(MixSettingsManagement.GetBusinessPartnerTypesApiName, "V4");
            logHelper.ExecuteAndLog(delegate()
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixSettingsManagement.GetBusinessPartnerTypesApiName);
                }
                catch (Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, ex, "Partner Validation did not pass, see internal exception for more detail.", false);
                }

                bpTypes = MixSettingsManagement.GetBusinessPartnerTypes();
            });

            return bpTypes;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\DataContractV1.cs ===
ï»¿
namespace xonline.mix.stats.contract
{
    // TODO: Put any data contracts here
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Service\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Service\Global.asax.cs ===
using System;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.mix.common;

namespace xonline.mix.stats.service
{
    public class MixStatsApp : SoapFrontEndApp
    {
        /// <summary>
        /// Default constructor
        /// </summary>
        public MixStatsApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            //Call the base 
            base.Application_Start(sender, eventArgs);

            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);

        }
        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            //TODO add xmgmt control command parsing logic and code
            //Is there any thing to reload, cancel? 
        }
        /// <summary>
        /// Error handling for Mix will happen using MixError handler
        /// On Error is not capable of catching FaultExceptions
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            //We handle errors in the MixErrorHandler
        }

        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            //We dont need to reformat any response
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\obj\i386\MixStatsProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------



[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.stats.contracts/V1", ConfigurationName="MixStats")]
public interface MixStats
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboards", ReplyAction="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsValidationFau" +
        "lt", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsMixClientFaul" +
        "tFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureLeaderboards(uint titleId, bool force);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboard", ReplyAction="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardMixClientFaultFaul" +
        "t", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ResetLeaderboard(uint titleId, int leaderboardID);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixStatsChannel : MixStats, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixStatsClient : System.ServiceModel.ClientBase<MixStats>, MixStats
{
    
    public MixStatsClient()
    {
    }
    
    public MixStatsClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixStatsClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStatsClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStatsClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureLeaderboards(uint titleId, bool force)
    {
        base.Channel.ConfigureLeaderboards(titleId, force);
    }
    
    public void ResetLeaderboard(uint titleId, int leaderboardID)
    {
        base.Channel.ResetLeaderboard(titleId, leaderboardID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Service\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\objd\i386\MixStatsProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------



[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.stats.contracts/V1", ConfigurationName="MixStats")]
public interface MixStats
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboards", ReplyAction="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsValidationFau" +
        "lt", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ConfigureLeaderboardsMixClientFaul" +
        "tFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureLeaderboards(uint titleId, bool force);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboard", ReplyAction="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.stats.contracts/V1/MixStats/ResetLeaderboardMixClientFaultFaul" +
        "t", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ResetLeaderboard(uint titleId, int leaderboardID);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixStatsChannel : MixStats, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixStatsClient : System.ServiceModel.ClientBase<MixStats>, MixStats
{
    
    public MixStatsClient()
    {
    }
    
    public MixStatsClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixStatsClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStatsClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStatsClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureLeaderboards(uint titleId, bool force)
    {
        base.Channel.ConfigureLeaderboards(titleId, force);
    }
    
    public void ResetLeaderboard(uint titleId, int leaderboardID)
    {
        base.Channel.ResetLeaderboard(titleId, leaderboardID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Service\MixStats.cs ===
ï»¿using System.Collections.Generic;
using System.Collections;

using xonline.common.service;
using xonline.common.leaderboard;
using xonline.common.livetitleconfig;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.mix.common;
using xonline.stats.admin;
using System;

using XConfig = xonline.common.config.Config;

namespace xonline.mix.stats.service
{
    public class MixStats
    {
        public static readonly string ConfigureLeaderboardsApiName = "MixStats.ConfigureLeaderboards";
        public static readonly string ResetLeaderboardApiName = "MixStats.ResetLeaderboard";

        #region ConfigureLeaderboards

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        static public void ConfigureLeaderboards(uint titleId, bool force)
        {
            if (0 == titleId)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_STATS_INVALID_TITLE_ID, "ConfigureLeaderboards Called With a null Title ID.");
            }

            ArrayList configLbs = GetXlastLeaderboards(titleId);

            LiveTitleConfig ltc = LiveTitleConfig.Get(titleId);

            foreach (LeaderboardSettings lb in configLbs)
            {
                foreach (LeaderboardConfig lbc in ltc.LeaderboardConfigs)
                {
                    if (lbc.LeaderboardID == lb.LeaderboardID &&
                        lbc.IsCompetition == (lb.Type == LbType.Competition))
                    {
                        lb.LBServer = lbc.HostingLbs;
                        break;
                    }
                }
            }

            ArrayList npdbLeaderboards = DbLeaderboard.GetNPDBLeaderboardConfiguration(titleId);

            ArrayList updated; //list of modified lb requiring a reset
            ArrayList inNpdbOnly;
            ArrayList inConfigOnly;
            ArrayList updatedNoResetRequired;//list of modified lb not requiring a reset            
            List<int> requireNotification;

            int lbCount = 0;
            int compCount = 0;            

            bool foundPlatformLeaderboardChanges; 

            CompareStatsConfig(npdbLeaderboards, 
                configLbs, 
                out updated, 
                out inNpdbOnly, 
                out inConfigOnly, 
                out updatedNoResetRequired, 
                out requireNotification,
                out foundPlatformLeaderboardChanges);
                        
            if (!force) // They didn't specify the override parameter
            {
                foreach (LeaderboardSettings lb in configLbs)
                {
                    if (!inConfigOnly.Contains(lb) && (ColumnsModified(lb, titleId)))
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_STATS_FORCE_REQUIRED, XEvent.Id.MIX_STATS_FORCE_REQUIRED, "This Leaderboard configuration requires the force parameter set to true to be successful.");
                    }

                    if ((updated.Count > 0 || inNpdbOnly.Count > 0))
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_STATS_FORCE_REQUIRED, XEvent.Id.MIX_STATS_FORCE_REQUIRED, "This Leaderboard configuration requires the force parameter set to true to be successful.");
                    }
                }
            }

            //update those leaderboards which does not require a reset
            foreach (LeaderboardSettings lb in updatedNoResetRequired)
            {
                
                DbLeaderboard.UpdateLbInNPDB(lb);
                DbLeaderboard.UpdateLbInWebDB(lb);
            }

            if (requireNotification.Count > 0)
            {
                
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.lbsvr);
                string[] responses;
                int hr;
                foreach (string server in servers)
                {
                    IInterfaceInfo iinfo = xonline.common.config.Config.GetInterface(server, Interface.lbsvr);
                    XomAdminSession xmgmt = new XomAdminSession(iinfo.IPAddress);
                    try
                    {
                        // call xmgmt reloadsettingforlb
                        foreach (int lbID in requireNotification)
                        {
                            xmgmt.SendCommand(null, Component.lbsvr, "reloadsettingforlb " + titleId + " " + lbID, iinfo.Timeout, out responses, out hr);
                        }
                    }
                    finally
                    {
                        xmgmt.Close();
                    }
                }
            }

            // delete updated leaderboards..
            foreach (LeaderboardSettings lb in updated)
            {
                if (lb.Type != LbType.Competition)
                {
                    DbLeaderboard.DeleteLeaderboard(titleId, (int)lb.LeaderboardID);
                }
            }

            // delete removed leaderboards..
            foreach (LeaderboardSettings lb in inNpdbOnly)
            {
                if (lb.Type != LbType.Competition)
                {
                    DbLeaderboard.DeleteLeaderboard(titleId, (int)lb.LeaderboardID);
                }
            }

            // create updated leaderboards with new settings..
            foreach (LeaderboardSettings lb in updated)
            {
                if (lb.Type != LbType.Competition)
                {
                    DbLeaderboard.CreateLeaderboard(lb);
                    lbCount++;
                }
            }

            // create new leaderboards with new settings..
            foreach (LeaderboardSettings lb in inConfigOnly)
            {
                if (lb.Type != LbType.Competition)
                {
                    DbLeaderboard.CreateLeaderboard(lb);
                    lbCount++;
                }
            }

            // create competition templates
            foreach (LeaderboardSettings lb in configLbs)
            {
                if (lb.Type == LbType.Competition)
                {
                    DbLeaderboard.DeleteCompetitionTemplate(lb.TitleID, (int)lb.LeaderboardID);
                    DbLeaderboard.CreateCompetitionTemplate(lb);
                    compCount++;
                }
            }

            DbLeaderboard.ConfigureTitle(titleId, ltc.StatsMaxWrites, ltc.StatsMaxReads);

            MixUtilities.ResetFrontDoor(Interface.xstatsfd_int, "", "xstatsfd", "ReloadDbMap", XConfig.GetIntSetting(Setting.mix_titleMgmt_kdcReloadTimeout), /*waitForCompletion*/ false);
            MixUtilities.ResetFrontDoor(Interface.wcstats, "", "wcstats", "ReloadLeaderboards", XConfig.GetIntSetting(Setting.mix_titleMgmt_kdcReloadTimeout), /*waitForCompletion*/ false);       
            
            if (foundPlatformLeaderboardChanges)
            {
                // Flush all platform visible leaderboard metadata from t_platform_visible_leaderboards for this titleId...
                DbLeaderboard.DeletePlatformVisibleLeaderboardMetadataForTitleId(titleId);

                // ...and then ingest all new platform visible leaderboard metadata anew!
                foreach (LeaderboardSettings lb in configLbs)
                {
                    foreach (KeyValuePair<string, PlatformVisibleLeaderboardLocInfo> kvp in lb.PlatformVisibleLeaderboardData)
                    {
                        PlatformVisibleLeaderboardLocInfo pvlInfo = kvp.Value;

                        DbLeaderboard.AddPlatformVisibleLeaderboardMetaData(
                            lb.TitleID,
                            (uint)lb.LeaderboardID,
                            kvp.Key,
                            pvlInfo.RatingAttributeId,
                            pvlInfo.Flags,
                            pvlInfo.FormatType,
                            pvlInfo.Format,
                            pvlInfo.Name,
                            pvlInfo.Rating
                            );
                    }
                }

                // Only reload platform visible leaderboard table if there was a change
                MixUtilities.ResetFrontDoor(Interface.xstatsfd_int, "", "xstatsfd", "reloadplatformvisibleleaderboards ", XConfig.GetIntSetting(Setting.mix_titleMgmt_kdcReloadTimeout), /*waitForCompletion*/ false);
            }

            Xom.NtEvent(XEvent.Id.MIX_STATS_SUCCESS, "Leaderboards propped successfully for title 0x{0:X}.", titleId);
        }

        #endregion


        #region ResetLeaderboard

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="leaderboard"></param>
        static public void ResetLeaderboard(uint titleId, int leaderboard)
        {
            if (0 == titleId)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_STATS_INVALID_TITLE_ID, "ResetLeaderboard Called With a null Title ID.");
            }
            if (0 == leaderboard)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_LEADERBOARD_ID, XEvent.Id.MIX_STATS_INVALID_LEADERBOARD_ID, "ResetLeaderboard Called With an invalid Leaderboard ID.");
            }

            // Check if we are in a production environment
            if (String.Compare(xonline.common.config.Config.Environment, "production", true) == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_FORBIDDEN_ENVIRONMENT, XEvent.Id.MIX_STATS_FORBIDDEN_ENVIRONMENT, "ResetLeaderboard cannot be called in a production environment.");
            }

            DbLeaderboard.ResetLeaderboard((int)titleId, leaderboard);
            Xom.NtEvent(XEvent.Id.MIX_STATS_SUCCESS, "Leaderboard {0} successfully reset for titleID 0x{1:X}.", leaderboard, titleId);
        }

        #endregion


        #region Utils

        static bool ColumnsModified(LeaderboardSettings lb, uint titleId)
        {
            List<string> list = DbLeaderboard.GetLeaderboardColumnIDs(titleId, lb.LeaderboardID);
            int count = 0;
            for (int i = 0; i < lb.Columns.Length; i++)
            {
                if (!list.Contains(lb.Columns[i].Name))
                {
                    // column exist in xlast, but not in webdb
                    return true;
                }
                else count++;
            }
            return (list.Count > count);
        }


        private static void CompareStatsConfig(
            ArrayList npdbLbs,
            ArrayList configLbs,
            out ArrayList updated,
            out ArrayList inNpdbOnly,
            out ArrayList inConfigOnly,
            out ArrayList updatedNoResetRequired,            
            out List<int> requireNotification,
            out bool foundPlatformLeaderboardChanges)
        {
            updated = new ArrayList();
            inNpdbOnly = new ArrayList();
            inConfigOnly = new ArrayList();            
            updatedNoResetRequired = new ArrayList();
            requireNotification = new List<int>();

            foundPlatformLeaderboardChanges = false; // init out param

            foreach (LeaderboardSettings npdbLb in npdbLbs)
            {
                LeaderboardSettings xlastLb = null;
                bool foundExisting = false;

                if (StatLbIdParser.IsCompetition((uint)npdbLb.LeaderboardID))
                {
                    // skip it -- since comp leaderboards are transient and
                    // are created and go away with the competition, we'll
                    // ignore reconfiguring it.

                    continue;
                }

                for (int i = 0; i < configLbs.Count; i++)
                {
                    xlastLb = (LeaderboardSettings)configLbs[i];

                    if (xlastLb.Type == LbType.Competition)
                        // skip it
                        continue;

                    if (xlastLb.TitleID == npdbLb.TitleID &&
                        xlastLb.LeaderboardID == npdbLb.LeaderboardID)
                    {
                        // xlast leaderboard already exists in the db!
                        foundExisting = true;

                        if ((xlastLb.DecayDays != npdbLb.DecayDays) ||
                            (xlastLb.MaxAttachmentSize != npdbLb.MaxAttachmentSize) ||
                            (xlastLb.ResetType != npdbLb.ResetType) ||
                            ((xlastLb.TopEntries == -1) != (npdbLb.TopEntries == 0)) ||
                            (xlastLb.MaxAttachments != npdbLb.MaxAttachments))
                        {
                            updatedNoResetRequired.Add(xlastLb);
                        }
                        if ((xlastLb.DecayDays != npdbLb.DecayDays) || (xlastLb.ResetType != npdbLb.ResetType))
                        {
                            requireNotification.Add(xlastLb.LeaderboardID);
                        }

                        // check for acceptable config-only changes..
                        string changes = "";

                        if (xlastLb.EloCtable != npdbLb.EloCtable ||
                            xlastLb.EloE != npdbLb.EloE ||
                            xlastLb.EloK != npdbLb.EloK ||
                            xlastLb.EloNew != npdbLb.EloNew)
                            changes = "ELO settings";

                        // note: technically updating TeamView and Arbitrated
                        // don't require clearing the lb,
                        // but currently there's no existing way to just update npdb
                        if (xlastLb.TeamView != npdbLb.TeamView)
                            changes += (changes == "" ? "" : ", ") + "Team LB";

                        if (xlastLb.Arbitrated != npdbLb.Arbitrated)
                            changes += (changes == "" ? "" : ", ") + "Arbitration";

                        if (changes != "")
                        {
                            updated.Add(xlastLb);
                        }

                        if (!foundPlatformLeaderboardChanges)
                        {
                            foundPlatformLeaderboardChanges = xlastLb.PlatformLeaderboardIsDifferent(npdbLb);
                        }

                        break;

                    } // if same lb

                } // for

                if (foundExisting == false)
                {
                    inNpdbOnly.Add(npdbLb);
                }

            } // foreach (npdbLb)

            // check for new leaderboards in config
            foreach (LeaderboardSettings configLb in configLbs)
            {
                bool foundExisting = false;

                foreach (LeaderboardSettings npdbLb in npdbLbs)
                {
                    if (configLb.TitleID == npdbLb.TitleID &&
                        configLb.LeaderboardID == npdbLb.LeaderboardID)
                    {                        
                        if (!foundPlatformLeaderboardChanges)
                        {
                            foundPlatformLeaderboardChanges = configLb.PlatformLeaderboardIsDifferent(npdbLb);
                        }

                        // found it!  comparison already done above..
                        foundExisting = true;

                        break;
                    }
                }

                if (!foundExisting)
                {
                    inConfigOnly.Add(configLb);
                    if (!foundPlatformLeaderboardChanges)
                    {
                        foundPlatformLeaderboardChanges = configLb.HasPlatformLeaderboards;
                    }
                }
               
            } // foreach (configLb)

        } // CompareStatsConfig       
        
        static ArrayList GetXlastLeaderboards(uint titleId)
        {
            return StatsXlastUtil.GetXLASTLeaderboardConfiguration(titleId);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Contracts\ServiceContractV1.cs ===
ï»¿using System.ServiceModel;

using xonline.mix.common;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.stats.contract
{
    // NOTE: If you change the interface name "IMixStatsV1" here, you must also update the reference to "IMixStatsV1" in Web.config.
    [ServiceContract(Name = "MixStats", Namespace = "http://xonline.mix.stats.contracts/V1")]
    public interface IMixStatsV1
    {
        [OperationContract(Name = "ConfigureLeaderboards")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void ConfigureLeaderboards(uint titleId, bool force);

        [OperationContract(Name = "ResetLeaderboard")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void ResetLeaderboard(uint titleId, int leaderboardID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\DataContractV1.cs ===
ï»¿using System.Runtime.Serialization;

namespace xonline.mix.storage.contract
{
    [DataContract(Name = "MIXFileType", Namespace = "http://xonline.mix.storage.contracts/V1")]
    public enum MIXFileTypeV1
    {
        [EnumMember]
        Achievement,
        [EnumMember]
        Gamertile,
        [EnumMember]
        GameIcon,
        [EnumMember]
        MarketplaceIcon,
        [EnumMember]
        Avatar64,
        [EnumMember]
        Avatar128,
        [EnumMember]
        Avatar300,
        [EnumMember]
        AvatarDetails0,
        [EnumMember]
        AvatarDetails1,
        [EnumMember]
        AvatarDetails2,
        [EnumMember]
        AvatarDetails3,
        [EnumMember]
        AvatarDetails4,
        [EnumMember]
        AvatarDetails5,
        [EnumMember]
        AvatarDetails6,
        [EnumMember]
        AvatarDetails7,
        [EnumMember]
        AvatarDetails8,
        [EnumMember]
        AvatarDetails9,
        [EnumMember]
        InGameMarketplaceBanner
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\ServiceContractV1.cs ===
ï»¿using System;
using System.ServiceModel;

using xonline.mix.common;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.storage.contract
{
    // NOTE: If you change the interface name "IMixStorage" here, you must also update the reference to "IMixTokenManagement" in Web.config.
    [ServiceContract(Name = "IMixStorage", Namespace = "http://xonline.mix.storage.contracts/V1")]    
    public interface IMixStorageV1
    {
        /// <summary>
        /// Submit a file to storage
        /// </summary>
        [OperationContract(Name = "SubmitFileToStorage")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SubmitFileToStorage(uint titleId, MIXFileTypeV1 type, ulong imageID, byte[] imageBlob);


        [OperationContract(Name = "SubmitAvatarImageToStorage")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SubmitAvatarImageToStorage(uint titleId, MIXFileTypeV1 type, Guid avatarItemGuid, byte[] imageBlob);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Service\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Stats\Service\MixStatsV1.svc.cs ===
ï»¿using System.Collections.Generic;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.mix.stats.contract;
using xonline.server.webcache.common;
using xonline.common.mgmt;
using xonline.mix.common;

[assembly: XomIisInstallerAttribute(Interface.mixstats)]
[assembly: ConfigAttribute(Component.mixstats)]
[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.mix.stats.service
{
    // NOTE: If you change the class name "MixStats" here, you must also update the reference to "MixStats" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixStatsV1 : IMixStatsV1
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId">TitleId to configure</param>
        /// <param name="force">Force reloading leaderboards</param>
        public void ConfigureLeaderboards(uint titleId, bool force)
        {
            try
            {
                Utilities.Instance.CheckAPI(MixStats.ConfigureLeaderboardsApiName);
            }
            catch (XboxWebInternalException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (XboxWebException ex)
            {
                //catches incorrect IP information
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (KeyNotFoundException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    
                    MixStats.ConfigureLeaderboardsApiName,
                    // Input params
                    titleId.ToString(),
                    force.ToString()
                });
                Xom.Log(XomAreaName.log, appLog);
            }

            MixStats.ConfigureLeaderboards(titleId, force);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="leaderboard"></param>
        public void ResetLeaderboard(uint titleId, int leaderboard)
        {
            try
            {
                Utilities.Instance.CheckAPI(MixStats.ResetLeaderboardApiName);
            }
            catch (XboxWebInternalException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (XboxWebException ex)
            {
                //catches incorrect IP information
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (KeyNotFoundException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    
                    MixStats.ResetLeaderboardApiName,
                    // Input params
                    titleId.ToString(),
                    leaderboard.ToString()
                });
                Xom.Log(XomAreaName.log, appLog);
            }

            MixStats.ResetLeaderboard(titleId, leaderboard);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Service\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\obj\i386\MixStorageProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.storage.contracts/V1", ClrNamespace="xonline.mix.storage.contracts.V1")]

namespace xonline.mix.storage.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MIXFileType", Namespace="http://xonline.mix.storage.contracts/V1")]
    public enum MIXFileType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Achievement = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Gamertile = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        GameIcon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        MarketplaceIcon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar64 = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar128 = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar300 = 6,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails0 = 7,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails1 = 8,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails2 = 9,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails3 = 10,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails4 = 11,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails5 = 12,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails6 = 13,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails7 = 14,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails8 = 15,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails9 = 16,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InGameMarketplaceBanner = 17,
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.storage.contracts/V1", ConfigurationName="IMixStorage")]
public interface IMixStorage
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorage", ReplyAction="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageValidation" +
        "Fault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageMixClientF" +
        "aultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SubmitFileToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, ulong imageID, byte[] imageBlob);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorage", ReplyAction="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageRes" +
        "ponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageMix" +
        "ClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageVal" +
        "idationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SubmitAvatarImageToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, System.Guid avatarItemGuid, byte[] imageBlob);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface IMixStorageChannel : IMixStorage, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixStorageClient : System.ServiceModel.ClientBase<IMixStorage>, IMixStorage
{
    
    public MixStorageClient()
    {
    }
    
    public MixStorageClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixStorageClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStorageClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStorageClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void SubmitFileToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, ulong imageID, byte[] imageBlob)
    {
        base.Channel.SubmitFileToStorage(titleId, type, imageID, imageBlob);
    }
    
    public void SubmitAvatarImageToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, System.Guid avatarItemGuid, byte[] imageBlob)
    {
        base.Channel.SubmitAvatarImageToStorage(titleId, type, avatarItemGuid, imageBlob);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Contracts\objd\i386\MixStorageProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.storage.contracts/V1", ClrNamespace="xonline.mix.storage.contracts.V1")]

namespace xonline.mix.storage.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MIXFileType", Namespace="http://xonline.mix.storage.contracts/V1")]
    public enum MIXFileType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Achievement = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Gamertile = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        GameIcon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        MarketplaceIcon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar64 = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar128 = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Avatar300 = 6,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails0 = 7,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails1 = 8,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails2 = 9,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails3 = 10,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails4 = 11,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails5 = 12,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails6 = 13,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails7 = 14,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails8 = 15,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AvatarDetails9 = 16,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InGameMarketplaceBanner = 17,
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.storage.contracts/V1", ConfigurationName="IMixStorage")]
public interface IMixStorage
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorage", ReplyAction="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageValidation" +
        "Fault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitFileToStorageMixClientF" +
        "aultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SubmitFileToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, ulong imageID, byte[] imageBlob);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorage", ReplyAction="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageRes" +
        "ponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageMix" +
        "ClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.storage.contracts/V1/IMixStorage/SubmitAvatarImageToStorageVal" +
        "idationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SubmitAvatarImageToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, System.Guid avatarItemGuid, byte[] imageBlob);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface IMixStorageChannel : IMixStorage, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixStorageClient : System.ServiceModel.ClientBase<IMixStorage>, IMixStorage
{
    
    public MixStorageClient()
    {
    }
    
    public MixStorageClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixStorageClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStorageClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixStorageClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void SubmitFileToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, ulong imageID, byte[] imageBlob)
    {
        base.Channel.SubmitFileToStorage(titleId, type, imageID, imageBlob);
    }
    
    public void SubmitAvatarImageToStorage(uint titleId, xonline.mix.storage.contracts.V1.MIXFileType type, System.Guid avatarItemGuid, byte[] imageBlob)
    {
        base.Channel.SubmitAvatarImageToStorage(titleId, type, avatarItemGuid, imageBlob);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Service\Global.asax.cs ===
using System;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.mix.common;


namespace xonline.mix.storage.service
{
    public class MixStorageApp : SoapFrontEndApp
    {
        /// <summary>
        /// Default constructor
        /// </summary>
        public MixStorageApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            //Call the base 
            base.Application_Start(sender, eventArgs);

            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);

        }
        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            //TODO add xmgmt control command parsing logic and code
            //Is there any thing to reload, cancel? 
        }
        /// <summary>
        /// Error handling for Mix will happen using MixError handler
        /// On Error is not capable of catching FaultExceptions
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            //We handle errors in the MixErrorHandler
        }

        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            //We dont need to reformat any response
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\DataContractV1.cs ===
ï»¿using System;
using System.Runtime.Serialization;

namespace xonline.mix.subscriptionfamily.contract
{
    [DataContract(Name="NameValue", Namespace = "http://xonline.mix.subscriptionfamily.contracts/v1")]
    public class NameValueV1
    {
        public const int MaxNameLength = 128;
        
        [DataMember(Name = "Value", IsRequired = true)]
        public int Value {
            get; set;
        }

        [DataMember(Name = "Name", IsRequired = true)]
        public string Name {
            get; set;
        }

        public NameValueV1(string name, int value) {
            Name  = name;
            Value = value;
        }
    }

    [DataContract(Name = "SubscriptionFamilyInfo", Namespace = "http://xonline.mix.subscriptionfamily.contracts/v1")]
    public class SubscriptionFamilyInfoV1
    {
        [DataMember(Name = "FamilyId", IsRequired = true)]
        public Guid FamilyId {
            get; set;
        }

        [DataMember(Name = "FamilyName", IsRequired = true)]
        public string FamilyName {
            get; set;
        }

        [DataMember(Name = "ServiceType", IsRequired = true)]
        public int ServiceType {
            get; set;
        }

        [DataMember(Name = "SubscriptionType", IsRequired = true)]
        public int SubscriptionType {
            get; set;
        }

        [DataMember(Name = "ServicePrivilegeSet", IsRequired = false)]
        public int? ServicePrivilegeSet {
            get; set;
        }

        [DataMember(Name = "TierId", IsRequired = true)]
        public int TierId {
            get; set;
        }

        [DataMember(Name = "TitleIds", IsRequired = false)]
        public int[] TitleIds
        {
            get;
            set;
        }

        public SubscriptionFamilyInfoV1(Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, int? servicePrivilegeSet)
        {
            FamilyId            = familyId;
            FamilyName          = familyName;
            ServiceType         = serviceType;
            SubscriptionType    = subscriptionType;
            TierId              = tierId;
            TitleIds            = titleIds;
            ServicePrivilegeSet = servicePrivilegeSet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\ServiceContractV1.cs ===
ï»¿using System;
using System.ServiceModel;

using xonline.mix.common;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.subscriptionfamily.contract
{
    // NOTE: If you change the interface name "ISubscriptionFamily" here, you must also update the reference to "ISubscriptionFamily" in Web.config.

    [ServiceContract(Name = "SubscriptionFamily", Namespace = "http://xonline.mix.subscriptionfamily.contracts/v1")]    
    public interface ISubscriptionFamilyV1
    {
        /// <summary>
        /// Get a list of the service privilege sets
        /// </summary>
        [OperationContract(Name = "ServicePrivilegeSetEnumerate")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        NameValueV1[] ServicePrivilegeSetEnumerate();

        /// <summary>
        /// Get a list of the service types
        /// </summary>
        [OperationContract(Name = "ServiceTypeEnumerate")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        NameValueV1[] ServiceTypeEnumerate();

        /// <summary>
        /// Get a list of the subscription types
        /// </summary>
        [OperationContract(Name = "SubscriptionTypeEnumerate")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        NameValueV1[] SubscriptionTypeEnumerate();

        /// <summary>Create (or update) the subscription family</summary>
        /// <param name="familyId">A guid that uniquely identifies the subscription family</param>
        /// <param name="familyName">A friendly name for referencing subscription family.</param>
        /// <param name="serviceType">The service type under which this subscription is valid</param>
        /// <param name="subscriptionType">The subscription type for this subscription family (i.e. base, game, content)</param>
        /// <param name="tierId">The tier this subscription family grants to the user</param>
        /// <param name="servicePrivilegeSet">The set of services and privileges users get with this subscription</param>
        [OperationContract(Name = "SubscriptionFamilyConfigure")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SubscriptionFamilyConfigure(Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, int? servicePrivilegeSet);

        /// <summary>Returns a single subscription family objects.</summary>
        /// <param name="familyId">a guid representing the subscription family id for which information is to be returned.</param>
        /// <returns>A single subscription family object, or null if no such object is found.</returns>
        [OperationContract(Name = "SubscriptionFamilyGet")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        SubscriptionFamilyInfoV1 SubscriptionFamilyGet(Guid familyId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Storage\Service\MixStorageV1.svc.cs ===
ï»¿using System;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.tools.stutilcore;
using xonline.common.mgmt;
using xonline.mix.common;
using xonline.server.webcache.common;
using xonline.mix.storage.contract;
using System.Collections.Generic;

[assembly: XomIisInstallerAttribute(Interface.mixstorage)]
[assembly: ConfigAttribute(Component.mixstorage)]
[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.mix.storage.service
{
    // NOTE: If you change the class name "MixStorageV1" here, you must also update the reference to "Mix" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixStorageV1 : IMixStorageV1
    {
        // APIs
        //
        // Contains the service APIs the exposed to external callers (clients)

        #region APIs
        public static string SubmitFileToStorageApiName = "MixStorage.SubmitFileToStorage";
        public static string SubmitAvatarImageToStorageApiName = "MixStorage.SubmitAvatarImageToStorage";

        public void SubmitFileToStorage(uint titleId, MIXFileTypeV1 type, ulong imageID, byte[] imageBlob)
        {
            // NOTE: The API must match the name defined in the webdb.
            try
            {
                Utilities.Instance.CheckAPI(SubmitFileToStorageApiName);
            }
            catch (XboxWebInternalException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (XboxWebException ex)
            {
                //catches incorrect IP information
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (KeyNotFoundException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    
                    SubmitFileToStorageApiName,
                    // Input params
                    titleId.ToString(),
                    type.ToString(),
                    imageID.ToString(),
                    imageBlob.Length.ToString() + " bytes of image"
                });

                Xom.Log(XomAreaName.log, appLog);
            }


            string target = "";
            string strImageID = imageID.ToString("x");

            switch (type)
            {
                case MIXFileTypeV1.Avatar64:
                    target = "ach";
                    break;
                case MIXFileTypeV1.Achievement:
                    target = "ach";
                    break;
                case MIXFileTypeV1.GameIcon:
                    target = "icon";
                    strImageID = "8000";
                    break;
                case MIXFileTypeV1.Gamertile:
                    target = "tile";
                    break;
                case MIXFileTypeV1.MarketplaceIcon:
                    target = "marketplace";
                    strImageID = "1";
                    break;
                case MIXFileTypeV1.InGameMarketplaceBanner:
                    target = "marketplace";
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_FILE_TYPE, XEvent.Id.MIX_STORAGE_INVALID_FILE_TYPE, "Invalid image type specified.");

            }

            string dest = String.Format("//global/t:{0:x}/{1}/0/{2}", titleId, target, strImageID);

            submitToStorage(dest, titleId, imageBlob);
            Xom.NtEvent(XEvent.Id.MIX_STORAGE_SUCCESS, "File of type {0} saved successfully at {1}.", type, dest);
        }

        public void SubmitAvatarImageToStorage(uint titleId, MIXFileTypeV1 type, Guid avatarItemGuid, byte[] imageBlob)
        {
            // NOTE: The API must match the name defined in the webdb.
            try
            {
                Utilities.Instance.CheckAPI(SubmitAvatarImageToStorageApiName);
            }
            catch (XboxWebInternalException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (XboxWebException ex)
            {
                //catches incorrect IP information
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (KeyNotFoundException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    
                    SubmitAvatarImageToStorageApiName,
                    // Input params
                    titleId.ToString(),
                    type.ToString(),
                    avatarItemGuid.ToString(),
                    imageBlob.Length.ToString() + " bytes of image"
                });

                Xom.Log(XomAreaName.log, appLog);
            }


            if (avatarItemGuid == Guid.Empty) throw new XRLException(HResult.XONLINE_E_MIX_INVALID_GUID, XEvent.Id.MIX_STORAGE_INVALID_GUID, "The Empty Guid cannot be used as an Avatar Item.");
            string suffix = "";
            switch (type)
            {
                case MIXFileTypeV1.Avatar64:
                    suffix = "64";
                    break;
                case MIXFileTypeV1.Avatar128:
                    suffix = "128";
                    break;
                case MIXFileTypeV1.Avatar300:
                    suffix = "300";
                    break;
                case MIXFileTypeV1.AvatarDetails0:
                    suffix = "0";
                    break;
                case MIXFileTypeV1.AvatarDetails1:
                    suffix = "1";
                    break;
                case MIXFileTypeV1.AvatarDetails2:
                    suffix = "2";
                    break;
                case MIXFileTypeV1.AvatarDetails3:
                    suffix = "3";
                    break;
                case MIXFileTypeV1.AvatarDetails4:
                    suffix = "4";
                    break;
                case MIXFileTypeV1.AvatarDetails5:
                    suffix = "5";
                    break;
                case MIXFileTypeV1.AvatarDetails6:
                    suffix = "6";
                    break;
                case MIXFileTypeV1.AvatarDetails7:
                    suffix = "7";
                    break;
                case MIXFileTypeV1.AvatarDetails8:
                    suffix = "8";
                    break;
                case MIXFileTypeV1.AvatarDetails9:
                    suffix = "9";
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_FILE_TYPE, XEvent.Id.MIX_STORAGE_INVALID_FILE_TYPE, "Invalid image type specified.");
            }

            string dest = String.Format("//global/t:{0:x}/avataritem/{1}/{2}", titleId, avatarItemGuid, suffix);
            submitToStorage(dest, titleId, imageBlob);
            Xom.NtEvent(XEvent.Id.MIX_STORAGE_SUCCESS, "File of type {0} saved successfully at {1}.", type, dest);
        }

        private void submitToStorage(string dest, uint titleID, byte[] imageBlob)
        {
            StUtil.Write(0, 0, dest, titleID, true /*overwrite*/, imageBlob);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\obj\i386\SubscriptionFamilyProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.subscriptionfamily.contracts/v1", ClrNamespace="xonline.mix.subscriptionfamily.contracts.v1")]

namespace xonline.mix.subscriptionfamily.contracts.v1
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="NameValue", Namespace="http://xonline.mix.subscriptionfamily.contracts/v1")]
    public partial class NameValue : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string NameField;
        
        private int ValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SubscriptionFamilyInfo", Namespace="http://xonline.mix.subscriptionfamily.contracts/v1")]
    public partial class SubscriptionFamilyInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid FamilyIdField;
        
        private string FamilyNameField;
        
        private System.Nullable<int> ServicePrivilegeSetField;
        
        private int ServiceTypeField;
        
        private int SubscriptionTypeField;
        
        private int TierIdField;
        
        private int[] TitleIdsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid FamilyId
        {
            get
            {
                return this.FamilyIdField;
            }
            set
            {
                this.FamilyIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string FamilyName
        {
            get
            {
                return this.FamilyNameField;
            }
            set
            {
                this.FamilyNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> ServicePrivilegeSet
        {
            get
            {
                return this.ServicePrivilegeSetField;
            }
            set
            {
                this.ServicePrivilegeSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int ServiceType
        {
            get
            {
                return this.ServiceTypeField;
            }
            set
            {
                this.ServiceTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int SubscriptionType
        {
            get
            {
                return this.SubscriptionTypeField;
            }
            set
            {
                this.SubscriptionTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int TierId
        {
            get
            {
                return this.TierIdField;
            }
            set
            {
                this.TierIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int[] TitleIds
        {
            get
            {
                return this.TitleIdsField;
            }
            set
            {
                this.TitleIdsField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.subscriptionfamily.contracts/v1", ConfigurationName="SubscriptionFamily")]
public interface SubscriptionFamily
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServicePrivilegeSetEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "Enumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServiceTypeEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] SubscriptionTypeEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigure", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SubscriptionFamilyConfigure(System.Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGet", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.SubscriptionFamilyInfo SubscriptionFamilyGet(System.Guid familyId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface SubscriptionFamilyChannel : SubscriptionFamily, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class SubscriptionFamilyClient : System.ServiceModel.ClientBase<SubscriptionFamily>, SubscriptionFamily
{
    
    public SubscriptionFamilyClient()
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public SubscriptionFamilyClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServicePrivilegeSetEnumerate()
    {
        return base.Channel.ServicePrivilegeSetEnumerate();
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServiceTypeEnumerate()
    {
        return base.Channel.ServiceTypeEnumerate();
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] SubscriptionTypeEnumerate()
    {
        return base.Channel.SubscriptionTypeEnumerate();
    }
    
    public void SubscriptionFamilyConfigure(System.Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet)
    {
        base.Channel.SubscriptionFamilyConfigure(familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.SubscriptionFamilyInfo SubscriptionFamilyGet(System.Guid familyId)
    {
        return base.Channel.SubscriptionFamilyGet(familyId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\contracts\objd\i386\SubscriptionFamilyProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.subscriptionfamily.contracts/v1", ClrNamespace="xonline.mix.subscriptionfamily.contracts.v1")]

namespace xonline.mix.subscriptionfamily.contracts.v1
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="NameValue", Namespace="http://xonline.mix.subscriptionfamily.contracts/v1")]
    public partial class NameValue : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string NameField;
        
        private int ValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SubscriptionFamilyInfo", Namespace="http://xonline.mix.subscriptionfamily.contracts/v1")]
    public partial class SubscriptionFamilyInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid FamilyIdField;
        
        private string FamilyNameField;
        
        private System.Nullable<int> ServicePrivilegeSetField;
        
        private int ServiceTypeField;
        
        private int SubscriptionTypeField;
        
        private int TierIdField;
        
        private int[] TitleIdsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid FamilyId
        {
            get
            {
                return this.FamilyIdField;
            }
            set
            {
                this.FamilyIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string FamilyName
        {
            get
            {
                return this.FamilyNameField;
            }
            set
            {
                this.FamilyNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> ServicePrivilegeSet
        {
            get
            {
                return this.ServicePrivilegeSetField;
            }
            set
            {
                this.ServicePrivilegeSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int ServiceType
        {
            get
            {
                return this.ServiceTypeField;
            }
            set
            {
                this.ServiceTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int SubscriptionType
        {
            get
            {
                return this.SubscriptionTypeField;
            }
            set
            {
                this.SubscriptionTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int TierId
        {
            get
            {
                return this.TierIdField;
            }
            set
            {
                this.TierIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int[] TitleIds
        {
            get
            {
                return this.TitleIdsField;
            }
            set
            {
                this.TitleIdsField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.subscriptionfamily.contracts/v1", ConfigurationName="SubscriptionFamily")]
public interface SubscriptionFamily
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServicePriv" +
        "ilegeSetEnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServicePrivilegeSetEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "Enumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/ServiceType" +
        "EnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServiceTypeEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerate", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nTypeEnumerateMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.NameValue[] SubscriptionTypeEnumerate();
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigure", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyConfigureMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SubscriptionFamilyConfigure(System.Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGet", ReplyAction="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.subscriptionfamily.contracts/v1/SubscriptionFamily/Subscriptio" +
        "nFamilyGetValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.subscriptionfamily.contracts.v1.SubscriptionFamilyInfo SubscriptionFamilyGet(System.Guid familyId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface SubscriptionFamilyChannel : SubscriptionFamily, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class SubscriptionFamilyClient : System.ServiceModel.ClientBase<SubscriptionFamily>, SubscriptionFamily
{
    
    public SubscriptionFamilyClient()
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public SubscriptionFamilyClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public SubscriptionFamilyClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServicePrivilegeSetEnumerate()
    {
        return base.Channel.ServicePrivilegeSetEnumerate();
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] ServiceTypeEnumerate()
    {
        return base.Channel.ServiceTypeEnumerate();
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.NameValue[] SubscriptionTypeEnumerate()
    {
        return base.Channel.SubscriptionTypeEnumerate();
    }
    
    public void SubscriptionFamilyConfigure(System.Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet)
    {
        base.Channel.SubscriptionFamilyConfigure(familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
    }
    
    public xonline.mix.subscriptionfamily.contracts.v1.SubscriptionFamilyInfo SubscriptionFamilyGet(System.Guid familyId)
    {
        return base.Channel.SubscriptionFamilyGet(familyId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\service\SubscriptionFamilyV1.svc.cs ===
using System;
using System.ServiceModel.Activation;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;

using xonline.server.mgmt.soap;
using xonline.server.webcache.common;

using xonline.mix.common;
using xonline.mix.subscriptionfamily.contract;

[assembly: ConfigAttribute(Component.mixsubscriptionfamily)]
[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomIisInstallerAttribute(Interface.mixsubscriptionfamily)]

namespace xonline.mix.subscriptionfamily.service
{
    // NOTE: If you change the class name "SubscriptionFamilyV1" here, you must also update the
    // reference to "SubscriptionFamilyV1" in Web.config and in the associated .svc file.   Set
    // the compat mode to allow the WCF application mimic the ASPNET lifecycle.  This will ensure
    // that the current components like SoapFrontEndApp will continue to work with our service

    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class SubscriptionFamilyV1 : ISubscriptionFamilyV1
    {
        public NameValueV1[] ServicePrivilegeSetEnumerate()
        {
            NameValueV1[] servicePrivilegeSets = null;

            string apiName = "ServicePrivilegeSetEnumerate";
            LogHelper logHelper=new LogHelper(apiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Count"});

                try
                {
                    CheckApi(apiName);
                    servicePrivilegeSets = SubscriptionFamily.ServicePrivilegeSetEnumerate();

                    logHelper.SetCountField("Count", servicePrivilegeSets);
                }
                catch (Exception e)
                {
                    if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent))
                        throw;
                    throw new XRLException(XblException.GetHResult(e), XEvent.Id.MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR, e, "{0}: error enumerating service privilege sets", apiName);
                }
            });

            return servicePrivilegeSets;
        }

        public NameValueV1[] ServiceTypeEnumerate()
        {
            NameValueV1[] serviceTypes = null;

            string apiName = "ServiceTypeEnumerate";
            LogHelper logHelper=new LogHelper(apiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Count"});

                try
                {
                    CheckApi(apiName);
                    serviceTypes = SubscriptionFamily.ServiceTypeEnumerate();

                    logHelper.SetCountField("Count", serviceTypes);
                }
                catch (Exception e)
                {
                    if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent))
                        throw;
                    throw new XRLException(XblException.GetHResult(e), XEvent.Id.MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR, e, "{0}: error enumerating service types", apiName);
                }
            });

            return serviceTypes;
        }

        public NameValueV1[] SubscriptionTypeEnumerate()
        {
            NameValueV1[] subscriptionTypes = null;

            string apiName = "SubscriptionTypeEnumerate";
            LogHelper logHelper=new LogHelper(apiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"Count"});

                try
                {
                    CheckApi(apiName);
                    subscriptionTypes = SubscriptionFamily.SubscriptionTypeEnumerate();

                    logHelper.SetCountField("Count", subscriptionTypes);
                }
                catch (Exception e)
                {
                    if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent))
                        throw;
                    throw new XRLException(XblException.GetHResult(e), XEvent.Id.MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR, e, "{0}: error enumerating subscription types", apiName);
                }
            });

            return subscriptionTypes;
        }

        public void SubscriptionFamilyConfigure(
            Guid   familyId,
            string familyName,
            int    serviceType,
            int    subscriptionType,
            int    tierId,
            int[]  titleIds,
            int?   servicePrivilegeSet
        )
        {
            string apiName = "SubscriptionFamilyConfigure";
            LogHelper logHelper=new LogHelper(apiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"FamilyId", "FamilyName", "ServiceType", "SubscriptionType", "Tier", "TitleIds", "ServicePrivilegeSet"});
                logHelper.SetField("FamilyId", familyId);
                logHelper.SetField("FamilyName", familyName);
                logHelper.SetField("ServiceType", serviceType);
                logHelper.SetField("SubscriptionType", subscriptionType);
                logHelper.SetField("Tier", tierId);
                logHelper.SetHexListField("TitleIds", titleIds, 100, 4);
                logHelper.SetField("ServicePrivilegeSet", servicePrivilegeSet);

                try
                {
                    CheckApi(apiName);

                    SubscriptionFamily.SubscriptionFamilyConfigure(familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
                }
                catch (Exception e)
                {
                    HResult hr = XblException.GetHResult(e);

                    if (hr == HResult.XONLINE_E_DATABASE_FOREIGN_KEY_VIOLATION)
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST, e, "Invalid request");
                    else
                    {
                        if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent))
                            throw;
                        throw new XRLException(hr, XEvent.Id.MIX_SUBSCRIPTION_FAMILY_CREATE_ERROR, e, "{0}: error creating subscription family", apiName);
                    }
                }
            });
        }

        public SubscriptionFamilyInfoV1 SubscriptionFamilyGet(
            Guid familyId
        )
        {
            SubscriptionFamilyInfoV1 subscriptionFamilyInfo = null;

            string apiName = "SubscriptionFamilyGet";
            LogHelper logHelper=new LogHelper(apiName, "V1");
            logHelper.ExecuteAndLog(delegate()
            {
                logHelper.SetFieldOrder(new string[]{"FamilyId", "Returned"});

                try
                {
                    logHelper.SetField("FamilyId", familyId);

                    CheckApi(apiName);
                    subscriptionFamilyInfo = SubscriptionFamily.SubscriptionFamilyGet(familyId);

                    logHelper.SetField("Returned", (subscriptionFamilyInfo!=null?"1":"0"));
                }
                catch (Exception e)
                {
                    if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent)) throw;
                    throw new XRLException(XblException.GetHResult(e), XEvent.Id.MIX_SUBSCRIPTION_FAMILY_GET_ERROR, e, "{0}: error getting subscription family", apiName);
                }
            });

            return subscriptionFamilyInfo;
        }

        private const string WIDGET_NAME = "MixSubscriptionFamily";

        private void CheckApi(string apiName)
        {
            Utilities.Instance.CheckAPI(WIDGET_NAME + "." + apiName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AddConsoleIDsToGroupV2.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV2=xonline.mix.betamanagement.contracts.V2;
using xonline.common.config;

//V2 and V3 are identical except for a tiny behavioural change in the case of adding a machine that's already in a group to that group, hence V2 is only a subset of the newer version tests.

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the AddConsoleIDsToGroup (beta group) API")]
    public class AddConsoleIDsToGroupV2: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AddConsoleIDsToGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Adds 1 machine to a group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string []consoles=new string[]{MachineEditor.CreateNew(mtype).ConsoleId};

            BetaManagementV2WCFClient client=new BetaManagementV2WCFClient();
            BetaV2.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV2.VerifyGroupMembership(bge.Id, consoles);
            BetaManagementUtilsV2.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV2.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 1, but it's already in that group.")]
        public void AlreadyInSameGroup()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            string []actualConsoles=new string[]{machine.ConsoleId};
            bge.AddMachine(machine.Id);

            BetaManagementV2WCFClient client=new BetaManagementV2WCFClient();
            BetaV2.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(actualConsoles, bge.Id);

            BetaManagementUtilsV2.VerifyGroupMembership(bge.Id, actualConsoles);

            BetaV2.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV2.BuildSuccessfulGroupMembershipChangeResult(actualConsoles);
            BetaManagementUtilsV2.ChangeGroupMembershipChangeResult(expectedResult, actualConsoles, BetaV2.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bge.Id});
            BetaManagementUtilsV2.VerifyGroupMembershipChangeResult(result, expectedResult);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\service\global.asax.cs ===
using System;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.mix.common;

namespace xonline.mix.subscriptionfamily.service
{
    public class SubscriptionFamilyApp : SoapFrontEndApp
    {
        /// <summary>
        /// Default constructor
        /// </summary>
        public SubscriptionFamilyApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            //Call the base 
            base.Application_Start(sender, eventArgs);

            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            //TODO add xmgmt control command parsing logic and code
            //Is there any thing to reload, cancel? 
        }

        /// <summary>
        /// Error handling for Mix will happen using MixError handler
        /// On Error is not capable of catching FaultExceptions
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            //We handle errors in the MixErrorHandler
        }

        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            //We dont need to reformat any response
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\SubscriptionFamily\service\SubscriptionFamily.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Data;
using System.ServiceModel.Activation;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.mix.subscriptionfamily.contract;

using Microsoft.Webstore.WstClient;

namespace xonline.mix.subscriptionfamily.service
{
    internal class SubscriptionFamily
    {
        private static readonly string SUBSCRIPTION_FAMILY_WEBSTOREAPP = ConfigUtil.UodbWebstoreApp;

        internal static NameValueV1[] ServicePrivilegeSetEnumerate()
        {
            using (WSClient ws = new WSClient(SUBSCRIPTION_FAMILY_WEBSTOREAPP, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_service_privilege_set_get";
                ws.Partition = WSClient.ANY_PARTITION;

                List<NameValueV1> servicePrivilegeSets = new List<NameValueV1>();

                using (WstDataReader reader = ws.Execute())
                {
                    int nameOrdinal  = reader.GetOrdinal("vc_friendly_name");
                    int valueOrdinal = reader.GetOrdinal("si_service_privilege_set_id");

                    while (reader.Read())
                    {
                        servicePrivilegeSets.Add(new NameValueV1(
                            reader.GetString(nameOrdinal),
                            (int) reader.GetInt16(valueOrdinal)
                        ));
                    }
                }

                if (servicePrivilegeSets.Count == 0) return null;
                return servicePrivilegeSets.ToArray();
            }
        }


        internal static NameValueV1[] ServiceTypeEnumerate()
        {
            using (WSClient ws = new WSClient(SUBSCRIPTION_FAMILY_WEBSTOREAPP, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_service_type_get";
                ws.Partition = WSClient.ANY_PARTITION;

                List<NameValueV1> serviceTypes = new List<NameValueV1>();

                using (WstDataReader reader = ws.Execute())
                {
                    int nameOrdinal  = reader.GetOrdinal("vc_friendly_name");
                    int valueOrdinal = reader.GetOrdinal("ti_service_type");

                    while (reader.Read())
                    {
                        serviceTypes.Add(new NameValueV1(
                            reader.GetString(nameOrdinal),
                            (int) reader.GetByte(valueOrdinal)
                        ));
                    }
                }

                if (serviceTypes.Count == 0) return null;
                return serviceTypes.ToArray();
            }
        }


        internal static NameValueV1[] SubscriptionTypeEnumerate()
        {
            using (WSClient ws = new WSClient(SUBSCRIPTION_FAMILY_WEBSTOREAPP, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_subscription_type_get";
                ws.Partition = WSClient.ANY_PARTITION;

                List<NameValueV1> subscriptionTypes = new List<NameValueV1>();

                using (WstDataReader reader = ws.Execute())
                {
                    int nameOrdinal  = reader.GetOrdinal("vc_friendly_name");
                    int valueOrdinal = reader.GetOrdinal("si_subscription_type");

                    while (reader.Read())
                    {
                        subscriptionTypes.Add(new NameValueV1(
                            reader.GetString(nameOrdinal), 
                            (int) reader.GetInt16(valueOrdinal)
                        ));
                    }
                }

                if (subscriptionTypes.Count == 0) return null;
                return subscriptionTypes.ToArray();
            }
        }


        internal static SubscriptionFamilyInfoV1 SubscriptionFamilyGet(Guid familyId)
        {
            using (WSClient ws = new WSClient(SUBSCRIPTION_FAMILY_WEBSTOREAPP, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_subscription_family_get";
                ws.Partition = WSClient.ANY_PARTITION;
                ws.AddParameter("@guid_subscription_family", familyId);

                using (WstDataReader reader = ws.Execute())
                {
                    SubscriptionFamilyInfoV1 subscriptionFamily = null;

                    if (reader.Read())
                    {
                        string familyName = WSClient.GetNullableString(reader, "vc_friendly_name");
                        if (familyName == null) familyName = string.Empty;

                        // use the single row in the first result set to  create
                        // the subscription family info  class  we  will  return

                        subscriptionFamily = new SubscriptionFamilyInfoV1(
                            WSClient.GetGuid(reader, "guid_subscription_family"),
                            familyName,
                            (int) WSClient.GetByte(reader,  "ti_service_type"),
                            (int) WSClient.GetInt16(reader, "si_subscription_type"),
                            (int) WSClient.GetInt32(reader, "i_tier_id"),
                            null,
                            (int ?) WSClient.GetNullableInt16(reader, "si_service_privilege_set_id")
                        );

                        // if there is a second result set it contains a list of
                        // title ids where this subscription is considered valid

                        if (reader.NextResult())
                        {
                            List<int> titleIds = new List<int>();
                            while (reader.Read()) titleIds.Add(WSClient.GetInt32(reader, "i_title_id"));
                            subscriptionFamily.TitleIds = titleIds.ToArray();
                        }
                    }

                    return subscriptionFamily;
                }
            }
        }


        internal static void SubscriptionFamilyConfigure(
           Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, int? servicePrivilegeSet
        )
        {
            // if they have title ids then use a data table to  pass
            // the variable number of title ids as a table parameter

            DataTable dataTable = new DataTable("titleIds");
            dataTable.Columns.Add(new DataColumn("i_title_id", typeof(int)));

            if (titleIds != null) {
                for (int i = 0; i < titleIds.Length; i++) {
                    DataRow dataRow = dataTable.NewRow();
                    dataRow["i_title_id"] = titleIds[i];
                    dataTable.Rows.Add(dataRow);
                }
            }

            // create a single connection,  then spin through all of
            // the partitions and configure the subscription  family

            using (WstConnection connection = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                connection.Open();

                for (int i = 0; i < connection.SqlPartitions.Count; i++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.StoredProc = "p_subscription_family_configure";
                        ws.PhysicalPartition = i;

                        ws.AddParameter("@guid_subscription_family",    familyId);
                        ws.AddParameter("@vc_friendly_name",            familyName == null ? string.Empty : familyName);
                        ws.AddParameter("@ti_service_type",             (byte) serviceType);
                        ws.AddParameter("@si_subscription_type",        (short) subscriptionType);
                        ws.AddParameter("@i_tier_id",                   tierId);
                        ws.Parameters.AddWithValue("@title_id_list",    dataTable);

                        if (servicePrivilegeSet.HasValue) {
                            ws.AddParameter("@si_service_privilege_set_id", (short) servicePrivilegeSet.Value);
                        }

                        ws.AddParameter(ParamType.RETVAL, "@hr",        0);

                        using (WstDataReader reader = ws.Execute())
                        {
                            HResult hr = (uint) ws.GetIntParameter("@hr");
                            if (hr.IsSuccess()) continue;
                            
                            // something went wrong. translate the HR into a meaningful text string
                            string columnName = string.Empty;

                            switch (hr) {
                                case HResult.XONLINE_E_MIX_INVALID_SERVICE_TYPE          : columnName = ", serviceType";         break;
                                case HResult.XONLINE_E_MIX_INVALID_SUBSCRIPTION_TYPE     : columnName = ", subscriptionType";    break;
                                case HResult.XONLINE_E_MIX_INVALID_TIER                  : columnName = ", tierId";              break;
                                case HResult.XONLINE_E_MIX_INVALID_SERVICE_PRIVILEGE_SET : columnName = ", servicePrivilegeSet"; break;
                            }
                            
                            throw new XRLExceptionWithoutEvent(hr, string.Format("Invalid parameter{0}", columnName));
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AssignReleaseToGroup.cs ===
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

using xonline.common.service;
using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.mix.betamanagement.contracts.V4;

using Microsoft.Webstore.WstClient;

using MIXTesting;

namespace MixTest
{
    class AssignReleaseToGroupV4TestNode: TestNode
    {
        public override void PreRun()
        {
            UniqueRunIdentifier=Name+"_"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next();
        }

        public BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();
        public string UniqueRunIdentifier;
    };

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("AssignReleaseToGroup Tests")]
    public class AssignReleaseToGroup : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AssignReleaseToGroup");
        }

        static BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();

        [TestCase, TestCasePriority(1)]
        class P_Golden : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                AssignAndValidateRelease(client, BuildDefaultReleaseGroup());
            }
        }


        [TestCase, Description("Assigning the empty guid is valid, it is how a release is assigned to the production group."), TestCasePriority(1)]
        class P_ZeroGroupGuid : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Summary.GroupGuid = Guid.Empty;
                AssignAndValidateRelease(client, g);
            }
        }

        [TestCase, Description("Assigning to a guid that is not a group is not valid"), TestCasePriority(2)]
        class N_InvalidGroup : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Summary.GroupGuid = Guid.NewGuid();

                client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
                client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, true, new ReleaseApp[0]);
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_NoUpgradePaths : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Titles[0].UpgradeVersion += 0x100; // Make sure it's none of the previous upgrades
                AssignAndValidateRelease(client, g, false);
            }
        }

        [TestCase, TestCasePriority(2)]
        class N_ZeroUpgrade : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Titles[0].UpgradeVersion = 0;
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }


        [TestCase, TestCasePriority(2)]
        class N_NULL_SOM : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.RelInfos[0].SOMRevision = "";
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }


        [TestCase, TestCasePriority(2)]
        class N_NULL_SM : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.RelInfos[0].SMRevision = "";
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }

        [TestCase, Description("Ensure that the KDC is reloaded when we assign a release."), TestCasePriority(1)]
        class P_CheckForKDCReload : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                // Set up the reload watcher
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "Xkdc";
                change.Init();

                AssignAndValidateRelease(client, BuildDefaultReleaseGroup());

                if (!change.TestForChange("Reinitialize: completed reinitialization."))
                {
                    throw new UnexpectedTestResultException("Did not find the reload event on the KDC.");
                }
            }
        }

        [TestCase, Description("Normal request except that ReleaseApps is null."), TestCasePriority(1)]
        class P_ReleaseAppsNull : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                AssignAndValidateRelease(client, BuildDefaultReleaseGroup(), true, null);
            }
        }

        [TestCase, Description("Positive mainline that also adds one release app."), TestCasePriority(1)]
        class P_OneReleaseApp : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                ReleaseApp app0=CreateReleaseApp(UniqueRunIdentifier, "Friendly", true, "1.2.3.4", "SomeManifest");
                ReleaseApp []apps=new ReleaseApp[]{app0};

                AssignAndValidateRelease(client, BuildDefaultReleaseGroup(), true, apps);
            }
        }

        [TestCase, Description("Add a large number of apps at once"), TestCasePriority(1)]
        class P_ManyReleaseApps : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                ReleaseApp []apps=new ReleaseApp[100];
                for (int i=0; i<100; ++i)
                {
                    apps[i]=CreateReleaseApp(UniqueRunIdentifier+"_"+i, "Name"+i, (i%2==0)?true:false, "7.7.7."+(i%20), "Manifest"+(i%10));
                }

                AssignAndValidateRelease(client, BuildDefaultReleaseGroup(), true, apps);
            }
        }

        [TestCase, Description("An entry in the release apps array is null"), TestCasePriority(3)]
        class N_NullReleaseApp : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                ReleaseApp app0=CreateReleaseApp(UniqueRunIdentifier+"1", "X", true, "2.3.4.5", "X");
                ReleaseApp app1=null;
                ReleaseApp app2=CreateReleaseApp(UniqueRunIdentifier+"0", "Z", true, "2.3.4.5", "Z");
                ReleaseApp []apps=new ReleaseApp[]{app0, app1, app2};

                Group g=BuildDefaultReleaseGroup(false);

                client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
                client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, true, apps);

                //verify that no apps were actually added and no work was done
                VerifyNoTitleData(g.Summary.GroupGuid);
                VerifyNoReleaseAppData(UniqueRunIdentifier);
            }
        }

        [TestCase, Description("A field in a ReleaseApp is abused."), TestCasePriority(2)]
        class N_ReleaseApp_Fields : AssignReleaseToGroupV4TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                string tenChars="0123456789";
                string longerThanDB=""; //db can hold 100, so make these 200
                for (int i=0; i<20; ++i)
                {
                    longerThanDB+=tenChars;
                }

                instances.Add(new CompoundCaseAttribute("Null FileName",      new object[]{CreateReleaseApp(null,         "Friendly",   true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_NULL}));
                instances.Add(new CompoundCaseAttribute("Null FriendlyName",  new object[]{CreateReleaseApp("ChangeMe",   null,         true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_NULL}));
                instances.Add(new CompoundCaseAttribute("Null Version",       new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, null,                  "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_NULL}));
                instances.Add(new CompoundCaseAttribute("Null Manifest",      new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, "3.4.5.6",             null),           HResult.XONLINE_E_MIX_ARGUMENT_NULL}));
                instances.Add(new CompoundCaseAttribute("Empty FileName",     new object[]{CreateReleaseApp("",           "Friendly",   true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_EMPTY}));
                instances.Add(new CompoundCaseAttribute("Empty FriendlyName", new object[]{CreateReleaseApp("ChangeMe",   "",           true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_EMPTY}));
                instances.Add(new CompoundCaseAttribute("Empty Version",      new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, "",                    "SomeManifest"), HResult.XONLINE_E_MIX_ARGUMENT_EMPTY}));
                instances.Add(new CompoundCaseAttribute("Empty Manifest",     new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, "3.4.5.6",             ""),             HResult.XONLINE_E_MIX_ARGUMENT_EMPTY}));
                instances.Add(new CompoundCaseAttribute("Long FileName",      new object[]{CreateReleaseApp(longerThanDB, "Friendly",   true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_STRING_TOO_LONG}));
                instances.Add(new CompoundCaseAttribute("Long FriendlyName",  new object[]{CreateReleaseApp("ChangeMe",   longerThanDB, true, "3.4.5.6",             "SomeManifest"), HResult.XONLINE_E_MIX_STRING_TOO_LONG}));
                instances.Add(new CompoundCaseAttribute("Long Version",       new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, longerThanDB+".0.0.0", "SomeManifest"), HResult.XONLINE_E_MIX_STRING_TOO_LONG}));
                instances.Add(new CompoundCaseAttribute("Long Manifest",      new object[]{CreateReleaseApp("ChangeMe",   "Friendly",   true, "3.4.5.6",             longerThanDB),   HResult.XONLINE_E_MIX_STRING_TOO_LONG}));
            }

            public override void Run()
            {
                ReleaseApp app0=(ReleaseApp)MyValues[0];
                client.ExpectedHR=(uint)MyValues[1];

                if (app0.FileName=="ChangeMe")
                {
                    app0.FileName=UniqueRunIdentifier;
                }

                ReleaseApp []apps=new ReleaseApp[]{app0};
                Group g=BuildDefaultReleaseGroup(false);

                client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, true, apps);

                //verify that no apps were actually added and no work was done
                VerifyNoTitleData(g.Summary.GroupGuid);
                VerifyNoReleaseAppData(UniqueRunIdentifier);
            }
        }

        [TestCase, Description("More than one app has the same FileName and manifest"), TestCasePriority(3)]
        class N_ReleaseApp_DuplicateKey : AssignReleaseToGroupV4TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Using filename: "+UniqueRunIdentifier);
                ReleaseApp app0=CreateReleaseApp(UniqueRunIdentifier, "FriendOne", true,  "4.4.5.4", "SameManifest");
                ReleaseApp app1=CreateReleaseApp(UniqueRunIdentifier, "FriendTwo", false, "4.4.6.4", "SameManifest");
                ReleaseApp []apps=new ReleaseApp[]{app0, app1};

                Group g=BuildDefaultReleaseGroup(false);

                client.ExpectedHR=HResult.XONLINE_E_MIX_DUPLICATE_APP_NOT_ALLOWED;
                client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, true, apps);

                //verify that no apps were actually added and no work was done
                VerifyNoTitleData(g.Summary.GroupGuid);
                VerifyNoReleaseAppData(UniqueRunIdentifier);
            }
        }

        // --

        public static void AssignAndValidateRelease(BetaManagementV4WCFClient client, Group g)
        {

            AssignAndValidateRelease(client, g, true);
        }

        public static void AssignAndValidateRelease(BetaManagementV4WCFClient client, Group g, bool update)
        {
            AssignAndValidateRelease(client, g, update, new ReleaseApp[0]);
        }

        public static void AssignAndValidateRelease(BetaManagementV4WCFClient client, Group g, bool update, ReleaseApp []apps)
        {
            client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, update, apps);

            if (!BetaManagementUtilsV4.ValidateRelease(g.Summary.GroupGuid, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, ((g.Titles[0].BaseVersion / 0x100) & 0xFFFF) + 1))
            {
                throw new UnexpectedTestResultException("ValidateRelease failed!");
            }

            if (!update)
            {
                g.Titles[0].BaseVersion = g.Titles[0].UpgradeVersion;
            }

            // Will return true if the upgrade exists AND it should, or if it doesn't and shouldn't
            if (!BetaManagementUtilsV4.ValidateUpgradeExists(g.Titles[0], g.Summary.GroupGuid))
            {
                throw new UnexpectedTestResultException("ValidateUpgradeExists failed!");
            }

            if (!update) // We didn't force the other rows to update
            {
                // Make sure there's only one row
                if (!BetaManagementUtilsV4.ValidateUpdateIsUnique(g.Titles[0].UpgradeVersion, g.Summary.GroupGuid))
                {
                    throw new UnexpectedTestResultException("ValidateUpdateIsUnique failed!");
                }
            }

            //validate the release assignment
            ValidateReleaseAssignment(g.Summary.GroupGuid, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, (int)g.Titles[0].UpgradeVersion);

            //validate the apps
            if (apps==null)
            {
                ValidateReleaseApps(new ReleaseApp[0]);
            }
            else
            {
                ValidateReleaseApps(apps);
            }

            // Clean up after ourselves
            if (g.Summary.GroupGuid != Guid.Empty)
            {
                string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
                BetaManagementUtilsV4.ExecuteNPDBScalar(relInfoClear);
                string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
                TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            }
        }

        public static Group BuildDefaultReleaseGroup()
        {
            return BuildDefaultReleaseGroup(true);
        }

        public static Group BuildDefaultReleaseGroup(bool insertTitleVersions)
        {
            BetaGroupEditor bge = BetaGroupEditor.CreateNew();

            Group g = new Group();
            g.Summary = new GroupSummary();
            g.Summary.GroupGuid = bge.Id;

            UpgradePath path = new UpgradePath();
            path.BaseVersion = 0x505000;
            path.UpgradeVersion = 0x505100;
            path.TitleId = XOn.XENON_DASH_TITLE_ID;
            path.ConsoleType = PlatformType.Xenon;
            g.Titles = new UpgradePath[] { path };

            if (insertTitleVersions)
            {
                List<uint> titles = new List<uint>();
                BetaManagementUtilsV4.InsertUpgradePath(path, g.Summary.GroupGuid, ref titles); // Insert an upgrade path that doesn't currently exist (there aren't any dash versions of 5)
            }

            ReleaseInfo rinfo = new ReleaseInfo();
            rinfo.FlashQfe = 0;
            rinfo.FlashVersion = 5050;
            rinfo.SMRevision = "Fake SM Revision";
            rinfo.SOMRevision = "Fake SOM Revision";

            g.RelInfos = new ReleaseInfo[] { rinfo };

            return g;
        }

        public static ReleaseApp CreateReleaseApp(string fileName, string friendlyName, bool online, string version, string manifest)
        {
            ReleaseApp app=new ReleaseApp();

            app.FileName=fileName;
            app.FriendlyName=friendlyName;
            app.Online=online;
            app.Version=version;
            app.Manifest=manifest;

            return app;
        }

        public static void ValidateReleaseAssignment(Guid group, string somRevision, string smRevision, int flashVersion)
        {
            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                int bucket=ws.SetHashVal(group);
                ws.CommandSql="select vc_som_revision, vc_sm_revision, i_flash_version, si_hash_bucket from t_beta_group_releases where uid_group_id='"+group+"'";

                using (WstDataReader reader=ws.Execute())
                {
                    if (!reader.Read())
                    {
                        throw new UnexpectedTestResultException("No entry in t_beta_group_releases for group "+group);
                    }

                    ValueCheck.Test("vc_som_revision for group "+group, somRevision,  (string)reader[0]);
                    ValueCheck.Test("vc_sm_revision for group "+group,  smRevision,   (string)reader[1]);
                    ValueCheck.Test("i_flash_version for group "+group, flashVersion, (int)reader[2]);
                    ValueCheck.Test("si_hash_bucket for group "+group,  bucket,       (short)reader[3]);
                }
            }
        }

        public static void ValidateReleaseApps(ReleaseApp []appsExpected)
        {
            foreach (ReleaseApp app in appsExpected)
            {
                if (app!=null && app.FileName!=null && app.FriendlyName!=null && app.Version!=null && app.Manifest!=null)
                {
                    using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        string query="select count(*) from t_release_apps where vc_app_name="+QueryGenerator.EvaluateObject(app.FileName)+" and vc_friendly_name="+QueryGenerator.EvaluateObject(app.FriendlyName)+" and b_online="+(app.Online?"1":"0")+" and vc_version="+QueryGenerator.EvaluateObject(app.Version)+" and vc_manifest_revision="+QueryGenerator.EvaluateObject(app.Manifest);

                        for (int p=0; p<ws.PhysicalPartitions; ++p)
                        {
                            ws.ClearParameters();
                            ws.PhysicalPartition=p;
                            ws.CommandSql=query;

                            using (WstDataReader reader=ws.Execute())
                            {
                                reader.Read();
                                int count=(int)reader[0];
                                if (count!=1)
                                {
                                    throw new UnexpectedTestResultException("Partition "+p+" did not match query: "+query);
                                }
                            }
                        }
                    }
                }
            }
        }

        public static void VerifyNoTitleData(System.Guid group)
        {
            ValueCheck.Test("Rows for title group "+group, 0, UodbWS.ExecuteSQLScalar("select count(*) from t_title_versions where uid_beta_group_id="+QueryGenerator.EvaluateObject(group), null));
        }

        public static void VerifyNoReleaseAppData(string fileName)
        {
            ValueCheck.Test("Rows for app "+fileName, 0, UodbWS.ExecuteSQLScalar("select count(*) from t_release_apps where vc_app_name="+QueryGenerator.EvaluateObject(fileName), null));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AddConsoleIDsToGroupV3.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV3=xonline.mix.betamanagement.contracts.V3;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the AddConsoleIDsToGroup (beta group) API")]
    public class AddConsoleIDsToGroupV3: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AddConsoleIDsToGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Adds 1 machine to a group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string []consoles=new string[]{MachineEditor.CreateNew(mtype).ConsoleId};

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Adds 1 machine to a group that already has some other machines in it.")]
        public void AddToGroupThatHasExistingMachines()
        {
            MachineEditor existingMachine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor existingMachine1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor existingMachine2=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor newMachine=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(existingMachine0.Id);
            bge.AddMachine(existingMachine1.Id);
            bge.AddMachine(existingMachine2.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{newMachine.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{newMachine.ConsoleId, existingMachine0.ConsoleId, existingMachine1.ConsoleId, existingMachine2.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Adds 1000 machine to a group.")]
        public void Add1000Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 1000 machines...");
            string []consoles=new string[1000];
            for (int i=0; i<1000; ++i)
            {
                consoles[i]=MachineEditor.CreateNew(MachineType.Xbox360).ConsoleId;
            }

            Global.RO.Debug("Running...");
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []consolesToAdd=new string[]{MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360)};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        public void InvalidConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []consolesToAdd=new string[]{"SN.ABCDEFGHIJHL"};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Adds 0 machine to a group.")]
        public void AddNoMachines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string []consoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleIDsNull()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string []consoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(null, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add to the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []actualConsoles=new string[]{MachineEditor.CreateNew(MachineType.Xbox360).ConsoleId};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(actualConsoles, System.Guid.Empty);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add to a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []actualConsoles=new string[]{MachineEditor.CreateNew(MachineType.Xbox360).ConsoleId};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(actualConsoles, System.Guid.NewGuid());

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 1, but it's already in a different group.")]
        public void AlreadyInADifferentGroup()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            string []actualConsoles=new string[]{machine.ConsoleId};
            bgeOther.AddMachine(machine.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(actualConsoles, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeOther.Id, actualConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(actualConsoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, actualConsoles, BetaV3.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bgeOther.Id});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 1, but it's already in that group.")]
        public void AlreadyInSameGroup()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            string []actualConsoles=new string[]{machine.ConsoleId};
            bge.AddMachine(machine.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(actualConsoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, actualConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(actualConsoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, actualConsoles, BetaV3.GroupMembershipChangeOutcome.MemberAlreadyInGroup, new System.Guid[]{bge.Id});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 3, but the second one is already in another group")]
        public void Add3WithOneAlreadyInADifferentGroup()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeOther.AddMachine(machine1.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consolesToAdd=new string[]{machine0.ConsoleId, machine1.ConsoleId, machine2.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[2]{machine0.ConsoleId, machine2.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeOther.Id, new string[1]{machine1.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[]{machine1.ConsoleId}, BetaV3.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bgeOther.Id});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Pass a real array but with null for one of the consoles in the list.")]
        public void ConsoleIDsArrayEntryNull()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;

            string []consolesToAdd=new string[]{machine0.ConsoleId, null, machine2.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bgeNew.Id);

            // Make sure they didn't get added
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]{});
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{spoofyName};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to add a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consolesToAdd=new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machNormal1.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bge.Id);

            //verify
            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machDupe1.ConsoleId, machNormal1.ConsoleId}); //note that there are two results for the duplicate
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new ulong[]{machNormal0.Id, machNormal1.Id, machDupe0.Id, machDupe1.Id});
        }

        [TestCase, TestCasePriority(1), Description("Attempt to add a consoleID that is shared by multiple machines to a group, where one of the two machines is in a conflicting group.")]
        public void DuplicateConsoleId_OneConflict()
        {
            //create machines and groups
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);

            BetaGroupEditor bge0=BetaGroupEditor.CreateNew();
            BetaGroupEditor bge1=BetaGroupEditor.CreateNew();
            bge1.AddMachine(machDupe1.Id);

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consolesToAdd=new string[]{machDupe0.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.AddConsoleIDsToGroup(consolesToAdd, bge0.Id);

            //verify
            ValueCheck.Test("Number of results return", 2, result.Length); //there will be one result for each actual machine, so two in this case
            int foundConflicting=0;
            int foundSucceeded=0;
            foreach (BetaV3.GroupMembershipChangeResult r in result)
            {
                ValueCheck.Test("ConsoleID in result", machDupe0.ConsoleId, r.ConsoleID);
                if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.Success)
                {
                    ++foundSucceeded;

                    if (r.ConflictingGroups!=null)
                    {
                        ValueCheck.Test("Conflicting groups", 0, r.ConflictingGroups.Length);
                    }
                }
                else if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.MemberInOtherGroup)
                {
                    ++foundConflicting;

                    ValueCheck.Test("Conflicting groups", 1, r.ConflictingGroups.Length);
                    ValueCheck.Test("Conflicting group", bge1.Id, r.ConflictingGroups[0]);
                }
                else
                {
                    throw new UnexpectedTestResultException("Did not expect to get result: "+r.Outcome);
                }
            }

            ValueCheck.Test("Number of success results", 1, foundSucceeded);
            ValueCheck.Test("Number of conflicting results", 1, foundConflicting);

            BetaManagementUtilsV3.VerifyGroupMembership(bge0.Id, new ulong[]{machDupe0.Id});
            BetaManagementUtilsV3.VerifyGroupMembership(bge1.Id, new ulong[]{machDupe1.Id});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\BetaManagementUtilsV2.cs ===
using System;
using xonline.mix.betamanagement.contracts.V2;
using System.Collections.Generic;
using System.Collections;
using MIXTesting;
using ServerTestFramework.Database;
using Microsoft.Webstore.WstClient;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using xonline.common.service;
using ServerTestFramework.Utilities;

namespace MixTest
{
    public class BetaManagementUtilsV2
    {
        public static List<Group> CreateFakeGroups(int count)
        {
            Random r = new Random();
            List<Group> groups = new List<Group>();

            for (int i = 0; i < count; i++)
            {
                Group g = new Group();

                g.FlashVersion =  (uint)r.Next();

                BetaGroupEditor be =  BetaGroupEditor.CreateNew();

                g.Summary = new GroupSummary();
                g.Summary.Created = be.Created;
                g.Summary.Creator = be.Creator;
                g.Summary.GroupGuid = be.Id;
                g.Summary.Name = be.Name;

                List<ReleaseInfo> infos = new List<ReleaseInfo>();
                ReleaseInfo ri;
                int relcount = r.Next(1, 5);
                for (int j = 0; j < relcount; j++)
                {
                    ri = new ReleaseInfo();
                    ri.FlashQfe = (short)r.Next(128);
                    ri.FlashVersion = (short) (((g.FlashVersion & 0xFFFF00) / 0x100) - j);
                    ri.SMRevision = "Fake System Manifest Revision " + j;
                    ri.SOMRevision = "Fake System Online Manifest Revision " + j;
                    infos.Add(ri);
                }

                g.RelInfos = infos.ToArray();


                List<UpgradePath> paths = new List<UpgradePath>();
                UpgradePath up;
                int pathcount = r.Next(1, 5);
                PlatformType pt = PlatformType.Xenon;

                for (int j = 0; j < pathcount; j++)
                {
                    up = new UpgradePath();
                    up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                    up.BaseVersion = (uint) r.Next(1, (int) up.UpgradeVersion); // Get a random base version upgrading to the current flash version
                    up.ConsoleType = pt;
                    up.TitleId = XOn.XENON_DASH_TITLE_ID;
                    paths.Add(up);
                }

                // Now make the self-referential upgrade path
                up = new UpgradePath();
                up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                up.BaseVersion = up.UpgradeVersion; // Base-enabling it
                up.ConsoleType = pt;
                up.TitleId = XOn.XENON_DASH_TITLE_ID;
                paths.Add(up);


                g.Titles = paths.ToArray();

                groups.Add(g);
            }
            return groups;
        }

        public static void AddFakeGroups(IEnumerable<Group> groups, ref List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                foreach (UpgradePath up in g.Titles)
                {
                    InsertUpgradePath(up, g.Summary.GroupGuid, ref titlesToDelete);
                }

                foreach (ReleaseInfo ri in g.RelInfos)
                {
                    InsertReleaseInfo(ri, g.Summary.GroupGuid);
                }
            }
        }

        private static void InsertReleaseInfo(ReleaseInfo ri, Guid group)
        {
            string query = String.Format("exec p_betagroup_assign_release '{0}', {1}, '{2}', '{3}', {4}", group.ToString(), ri.FlashVersion, ri.SOMRevision, ri.SMRevision, ri.FlashQfe);
            ExecuteNPDBScalar(query);
        }

        public static bool InsertTitle(uint titleID, byte consoleType)
        {
            string titlequery = String.Format("select null from t_titles where i_title_id={0}", (int) titleID);
            string titleinsert = String.Format("insert into t_titles (i_title_id,ti_console_type_id) values ({0},{1})", (int)titleID, consoleType);
            // The title tables are global, so just check one of them
            bool inserted = false;
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(titlequery, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                WstDataReader reader = cmd.ExecuteReader();

                if (!reader.HasRows) // Title did not exist
                {
                    TitleManagementWCFClient.ExecuteUODBScalar(titleinsert);
                    inserted = true;
                }
                reader.Close();
            }
            return inserted;
        }

        public static void InsertUpgradePath(UpgradePath up, Guid group, ref List<uint> titlesToDelete)
        {
            string insert = String.Format("insert into t_title_versions (i_title_id,i_base_version,i_update_version,ti_console_type_id,uid_beta_group_id) values ({0},{1},{2},{3},'{4}')", (int)up.TitleId, (int)up.BaseVersion, (int)up.UpgradeVersion, (byte)up.ConsoleType, group.ToString());
            // Make sure the title's in t_titles
            if (InsertTitle(up.TitleId, (byte)up.ConsoleType))
            {
                titlesToDelete.Add(up.TitleId);
            }

            // Now we know the title exists.
            TitleManagementWCFClient.ExecuteUODBScalar(insert);
        }

        public static void ExecuteNPDBScalar(string s)
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            npdb.ExecuteScalar(s);
            npdb.Close();
        }

        public static void CleanGroups(IEnumerable<Group> groups, List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                CleanGroup(g);
            }

            foreach (uint title in titlesToDelete)
            {
                RemoveTitle(title);             
            }
        }

        public static void RemoveTitle(uint title)
        {
            string deleteTitle = String.Format("delete from t_titles where i_title_id={0}", title);
            TitleManagementWCFClient.ExecuteUODBScalar(deleteTitle);   
        }

        public static void CleanGroup(Group g)
        {
            BetaGroupEditor.NukeGroup(g.Summary.GroupGuid);
            string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
            string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());

            TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            ExecuteNPDBScalar(relInfoClear);
        }

        public static bool ValidateRelease(Guid group, string SOMRevision, string SMRevision, uint version)
        {
            string validateSOMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SOMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SOMRevision, group.ToString());
            string validateSMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SMRevision, group.ToString());

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();

                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = validateSOMRevision;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Online Manifest Revision.  Expected: {1}", group, SOMRevision);
                        return false;
                    }
                }


                cmd.CommandText = validateSMRevision;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Manifest Revision.  Expected: {1}", group, SMRevision);
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool ValidateUpgradeExists(UpgradePath path, Guid group)
        {
            string validateUpgradeQuery = "select null from t_title_versions where i_base_version={0} and i_update_version={1} and ti_console_type_id={2} and uid_beta_group_id='{3}'";


            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(String.Format(validateUpgradeQuery, path.BaseVersion, path.UpgradeVersion, (byte)path.ConsoleType, group.ToString()), conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                using (WstDataReader reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) // Title did not exist
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static bool ValidateUpdateIsUnique(uint version, Guid group)
        {
            string countUpdates = String.Format("select count(null) from t_title_versions where i_update_version={0} and uid_beta_group_id='{1}'", version, group.ToString());
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(countUpdates, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                if ((int)cmd.ExecuteScalar() != 1) // More rows were added than we expect
                {
                    Global.RO.Error("There were multiple upgrade paths to the dash version 0x{0:X} for group {1}", version, group);
                    return false;
                }
            }
            return true;
        }

        public static bool InsertFlashVersionLocation(uint version)
        {
            string insertVersion = String.Format("insert into t_title_update_locations values (0xFFFE07D1, 0x1, {0}, 1, 'xrl:invalid', CURRENT_TIMESTAMP,2)", version);
            TitleManagementWCFClient.ExecuteUODBScalar(insertVersion);

            return true;
        }

        public static bool DeleteFlashVersionLocation(uint version)
        {
            string removeVersion = String.Format("delete from t_title_update_locations where i_title_id=0xFFFE07D1 and i_title_base_version=0x1 and i_title_update_version = {0}", version);
            TitleManagementWCFClient.ExecuteUODBScalar(removeVersion);

            return true;
        }
        public static void VerifyGroupMembership(System.Guid group, string []expectedConsoles)
        {
            BetaGroupEditor bge=BetaGroupEditor.FromId(group);
            string []actualConsoles=bge.GetAllConsoles();

            ValueCheck.TestAllUnordered("Group membership for "+group, expectedConsoles, actualConsoles);
        }

        public static void VerifyGroupMembershipChangeResult(GroupMembershipChangeResult []result, GroupMembershipChangeResult []expected)
        {
            if (result==null)
            {
                throw new UnexpectedTestResultException("Result was null.");
            }

            if (result.Length!=expected.Length)
            {
                throw new UnexpectedTestResultException("Got a different number of results("+result.Length+") than expected("+expected.Length+").");
            }

            for (int i=0; i<result.Length; ++i)
            {
                if (expected[i].ConsoleID!=result[i].ConsoleID)
                {
                    throw new UnexpectedTestResultException("ConsoleID for index "+i+": Expected "+expected[i].ConsoleID+", got "+result[i].ConsoleID);
                }

                if (expected[i].Outcome!=result[i].Outcome)
                {
                    throw new UnexpectedTestResultException("Reason for console "+expected[i].ConsoleID+": Expected "+expected[i].Outcome+", got "+result[i].Outcome);
                }

                if (expected[i].ConflictingGroups!=null && result[i].ConflictingGroups!=null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, expected[i].ConflictingGroups, result[i].ConflictingGroups);
                }
                else if ((expected[i].ConflictingGroups==null || expected[i].ConflictingGroups.Length==0) && (result[i].ConflictingGroups==null || result[i].ConflictingGroups.Length==0))
                {
                    //both empty are ok
                }
                else if (expected[i].ConflictingGroups==null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, new System.Guid[0], result[i].ConflictingGroups);
                }
                else //result[i].ConflictingGroups==null
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, expected[i].ConflictingGroups, new System.Guid[0]);
                }
            }
        }

        public static GroupMembershipChangeResult[] BuildSuccessfulGroupMembershipChangeResult(string []consoles)
        {
            GroupMembershipChangeResult []results=new GroupMembershipChangeResult[consoles.Length];
            for (int i=0; i<consoles.Length; ++i)
            {
                results[i]=new GroupMembershipChangeResult();
                results[i].ConsoleID=consoles[i];
                results[i].Outcome=GroupMembershipChangeOutcome.Success;
                results[i].ConflictingGroups=new System.Guid[0];
            }

            return results;
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, string []consoles, GroupMembershipChangeOutcome reason)
        {
            ChangeGroupMembershipChangeResult(result, consoles, reason, new System.Guid[0]);
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, string []consoles, GroupMembershipChangeOutcome reason, IEnumerable<System.Guid> conflictingGroups)
        {
            foreach (string console in consoles)
            {
                bool found=false;
                foreach (GroupMembershipChangeResult r in result)
                {
                    if (r.ConsoleID==console)
                    {
                        r.Outcome=reason;

                        //r.ConflictingGroups=conflictingGroups; //this should work!  but the mix contract generated proxy is creating a type (Guid[]) that's different than the data contract definition (IEnumerable<Guid>).  For now just manually create an array from it...
                        int count=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            ++count;
                        }
                        r.ConflictingGroups=new System.Guid[count];
                        int i=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            r.ConflictingGroups[i]=cg;
                            ++i;
                        }

                        found=true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new System.Exception("Console "+console+" not found to change.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\BetaManagementUtils.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.service;
using xonline.mix.betamanagement.contracts.V1;
using Microsoft.Webstore.WstClient;

using MIXTesting;

namespace MixTest
{
    public class BetaManagementUtils
    {
        public static List<Group> CreateFakeGroups(int count)
        {
            Random r = new Random();
            List<Group> groups = new List<Group>();

            for (int i = 0; i < count; i++)
            {
                Group g = new Group();


                BetaGroupEditor be =  BetaGroupEditor.CreateNew();

                g.Summary = new GroupSummary();
                g.Summary.Created = be.Created;
                g.Summary.Creator = be.Creator;
                g.Summary.FlashVersion = (uint) r.Next();
                g.Summary.GroupGuid = be.Id;
                g.Summary.Name = be.Name;

                List<ReleaseInfo> infos = new List<ReleaseInfo>();
                ReleaseInfo ri;
                int relcount = r.Next(1, 5);
                for (int j = 0; j < relcount; j++)
                {
                    ri = new ReleaseInfo();
                    ri.FlashQfe = (short)r.Next(128);
                    ri.FlashVersion = (short) (((g.Summary.FlashVersion & 0xFFFF00) / 0x100) - j);
                    ri.SMRevision = "Fake System Manifest Revision " + j;
                    ri.SOMRevision = "Fake System Online Manifest Revision " + j;
                    infos.Add(ri);
                }

                g.RelInfos = infos.ToArray();


                List<UpgradePath> paths = new List<UpgradePath>();
                UpgradePath up;
                int pathcount = r.Next(1, 5);
                PlatformType pt = PlatformType.Xenon;

                for (int j = 0; j < pathcount; j++)
                {
                    up = new UpgradePath();
                    up.UpgradeVersion = ((g.Summary.FlashVersion & 0xFFFF00) / 0x100);
                    up.BaseVersion = (uint) r.Next(1, (int) up.UpgradeVersion); // Get a random base version upgrading to the current flash version
                    up.ConsoleType = pt;
                    up.TitleId = XOn.XENON_DASH_TITLE_ID;
                    paths.Add(up);
                }

                // Now make the self-referential upgrade path
                up = new UpgradePath();
                up.UpgradeVersion = ((g.Summary.FlashVersion & 0xFFFF00) / 0x100);
                up.BaseVersion = up.UpgradeVersion; // Base-enabling it
                up.ConsoleType = pt;
                up.TitleId = XOn.XENON_DASH_TITLE_ID;
                paths.Add(up);


                g.Titles = paths.ToArray();

                groups.Add(g);
            }
            return groups;
        }

        public static void AddFakeGroups(IEnumerable<Group> groups, ref List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                foreach (UpgradePath up in g.Titles)
                {
                    InsertUpgradePath(up, g.Summary.GroupGuid, ref titlesToDelete);
                }

                foreach (ReleaseInfo ri in g.RelInfos)
                {
                    InsertReleaseInfo(ri, g.Summary.GroupGuid);
                }
            }
        }

        private static void InsertReleaseInfo(ReleaseInfo ri, Guid group)
        {
            string query = String.Format("exec p_betagroup_assign_release '{0}', {1}, '{2}', '{3}', {4}", group.ToString(), ri.FlashVersion, ri.SOMRevision, ri.SMRevision, ri.FlashQfe);
            ExecuteNPDBScalar(query);
        }

        public static bool InsertTitle(uint titleID, byte consoleType)
        {
            string titlequery = String.Format("select null from t_titles where i_title_id={0}", (int) titleID);
            string titleinsert = String.Format("insert into t_titles (i_title_id,ti_console_type_id) values ({0},{1})", (int)titleID, consoleType);
            // The title tables are global, so just check one of them
            bool inserted = false;
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(titlequery, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                WstDataReader reader = cmd.ExecuteReader();

                if (!reader.HasRows) // Title did not exist
                {
                    TitleManagementWCFClient.ExecuteUODBScalar(titleinsert);
                    inserted = true;
                }
                reader.Close();
            }
            return inserted;
        }

        public static void InsertUpgradePath(UpgradePath up, Guid group, ref List<uint> titlesToDelete)
        {
            string insert = String.Format("insert into t_title_versions (i_title_id,i_base_version,i_update_version,ti_console_type_id,uid_beta_group_id) values ({0},{1},{2},{3},'{4}')", (int)up.TitleId, (int)up.BaseVersion, (int)up.UpgradeVersion, (byte)up.ConsoleType, group.ToString());
            // Make sure the title's in t_titles
            if (InsertTitle(up.TitleId, (byte)up.ConsoleType))
            {
                titlesToDelete.Add(up.TitleId);
            }

            // Now we know the title exists.
            TitleManagementWCFClient.ExecuteUODBScalar(insert);
        }

        public static void ExecuteNPDBScalar(string s)
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            npdb.ExecuteScalar(s);
            npdb.Close();
        }

        public static void CleanGroups(IEnumerable<Group> groups, List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                CleanGroup(g);
            }

            foreach (uint title in titlesToDelete)
            {
                RemoveTitle(title);             
            }
        }

        public static void RemoveTitle(uint title)
        {
            string deleteTitle = String.Format("delete from t_titles where i_title_id={0}", title);
            TitleManagementWCFClient.ExecuteUODBScalar(deleteTitle);   
        }

        public static void CleanGroup(Group g)
        {
            BetaGroupEditor.NukeGroup(g.Summary.GroupGuid);
            string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
            string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());

            TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            ExecuteNPDBScalar(relInfoClear);
        }

        public static bool ValidateRelease(Guid group, string SOMRevision, string SMRevision, uint version)
        {
            string validateSOMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SOMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SOMRevision, group.ToString());
            string validateSMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SMRevision, group.ToString());

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();

                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = validateSOMRevision;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Online Manifest Revision.  Expected: {1}", group, SOMRevision);
                        return false;
                    }
                }


                cmd.CommandText = validateSMRevision;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Manifest Revision.  Expected: {1}", group, SMRevision);
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool ValidateUpgradeExists(UpgradePath path, Guid group)
        {
            string validateUpgradeQuery = "select null from t_title_versions where i_base_version={0} and i_update_version={1} and ti_console_type_id={2} and uid_beta_group_id='{3}'";


            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(String.Format(validateUpgradeQuery, path.BaseVersion, path.UpgradeVersion, (byte)path.ConsoleType, group.ToString()), conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                using (WstDataReader reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) // Title did not exist
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static bool ValidateUpdateIsUnique(uint version, Guid group)
        {
            string countUpdates = String.Format("select count(null) from t_title_versions where i_update_version={0} and uid_beta_group_id='{1}'", version, group.ToString());
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(countUpdates, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                if ((int)cmd.ExecuteScalar() != 1) // More rows were added than we expect
                {
                    Global.RO.Error("There were multiple upgrade paths to the dash version 0x{0:X} for group {1}", version, group);
                    return false;
                }
            }
            return true;
        }

        public static bool InsertFlashVersionLocation(uint version)
        {
            string insertVersion = String.Format("insert into t_title_update_locations values (0xFFFE07D1, 0x1, {0}, 1, 'xrl:invalid', CURRENT_TIMESTAMP,2)", version);
            TitleManagementWCFClient.ExecuteUODBScalar(insertVersion);

            return true;
        }

        public static bool DeleteFlashVersionLocation(uint version)
        {
            string removeVersion = String.Format("delete from t_title_update_locations where i_title_id=0xFFFE07D1 and i_title_base_version=0x1 and i_title_update_version = {0}", version);
            TitleManagementWCFClient.ExecuteUODBScalar(removeVersion);

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AssignReleaseToGroupV2.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V2;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{
    class AssignReleaseToGroupV2TestNode: TestNode
    {
        public BetaManagementV2WCFClient client = new BetaManagementV2WCFClient();
    };

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class AssignReleaseToGroupV2 : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AssignReleaseToGroup");
        }

        [TestCase]
        class P_Golden : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                AssignAndValidateRelease(client, BuildDefaultReleaseGroup());
            }
        }


        [TestCase, Description("Assigning the empty guid is valid, it is how a release is assigned to the production group."), TestCasePriority(1)]
        class P_ZeroGroupGuid : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Summary.GroupGuid = Guid.Empty;
                AssignAndValidateRelease(client, g);
            }
        }

        [TestCase, Description("Assigning to a guid that is not a group is not valid")]
        class N_InvalidGroup : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Summary.GroupGuid = Guid.NewGuid();

                client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
                client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, true);
            }
        }

        [TestCase]
        class P_NoUpgradePaths : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Titles[0].UpgradeVersion += 0x100; // Make sure it's none of the previous upgrades
                AssignAndValidateRelease(client, g, false);
            }
        }

        // Negative Cases For AssignGroupToRelease

        [TestCase]
        class N_ZeroUpgrade : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.Titles[0].UpgradeVersion = 0;
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }


        [TestCase]
        class N_NULL_SOM : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.RelInfos[0].SOMRevision = "";
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }


        [TestCase]
        class N_NULL_SM : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                Group g = BuildDefaultReleaseGroup();
                g.RelInfos[0].SMRevision = "";
                try
                {
                    AssignAndValidateRelease(client, g);
                }
                catch (UnexpectedTestResultException) { }
            }
        }

        [TestCase, Description("Ensure that the KDC is reloaded when we assign a release.")]
        class P_CheckForKDCReload : AssignReleaseToGroupV2TestNode
        {
            public override void Run()
            {
                // Set up the reload watcher
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "Xkdc";
                change.Init();

                AssignAndValidateRelease(client, BuildDefaultReleaseGroup());

                if (!change.TestForChange("Reinitialize: completed reinitialization."))
                {
                    throw new UnexpectedTestResultException("Did not find the reload event on the KDC.");
                }
            }
        }

        // --

        public static void AssignAndValidateRelease(BetaManagementV2WCFClient client, Group g)
        {
            AssignAndValidateRelease(client, g, true);
        }

        public static void AssignAndValidateRelease(BetaManagementV2WCFClient client, Group g, bool update)
        {
            client.AssignReleaseToGroup(g.Titles[0].BaseVersion, g.Titles[0].UpgradeVersion, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, g.Summary.GroupGuid, g.Titles[0].TitleId, update);

            if (!BetaManagementUtilsV2.ValidateRelease(g.Summary.GroupGuid, g.RelInfos[0].SOMRevision, g.RelInfos[0].SMRevision, ((g.Titles[0].BaseVersion / 0x100) & 0xFFFF) + 1))
            {
                throw new UnexpectedTestResultException("ValidateRelease failed!");
            }

            if (!update)
            {
                g.Titles[0].BaseVersion = g.Titles[0].UpgradeVersion;
            }

            // Will return true if the upgrade exists AND it should, or if it doesn't and shouldn't
            if (!BetaManagementUtilsV2.ValidateUpgradeExists(g.Titles[0], g.Summary.GroupGuid))
            {
                throw new UnexpectedTestResultException("ValidateUpgradeExists failed!");
            }

            if (!update) // We didn't force the other rows to update
            {
                // Make sure there's only one row
                if (!BetaManagementUtilsV2.ValidateUpdateIsUnique(g.Titles[0].UpgradeVersion, g.Summary.GroupGuid))
                {
                    throw new UnexpectedTestResultException("ValidateUpdateIsUnique failed!");
                }
            }

            // Clean up after ourselves
            if (g.Summary.GroupGuid != Guid.Empty)
            {
                string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
                BetaManagementUtilsV2.ExecuteNPDBScalar(relInfoClear);
                string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
                TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            }
        }

        public static Group BuildDefaultReleaseGroup()
        {
            BetaGroupEditor bge = BetaGroupEditor.CreateNew();

            Group g = new Group();
            g.Summary = new GroupSummary();
            g.Summary.GroupGuid = bge.Id;
            UpgradePath path = new UpgradePath();
            path.BaseVersion = 0x505000;
            path.UpgradeVersion = 0x505100;
            path.TitleId = XOn.XENON_DASH_TITLE_ID;
            path.ConsoleType = PlatformType.Xenon;

            List<uint> titles = new List<uint>();
            BetaManagementUtilsV2.InsertUpgradePath(path, g.Summary.GroupGuid, ref titles); // Insert an upgrade path that doesn't currently exist (there aren't any dash versions of 5)
            g.Titles = new UpgradePath[] { path };

            ReleaseInfo rinfo = new ReleaseInfo();
            rinfo.FlashQfe = 0;
            rinfo.FlashVersion = 5050;
            rinfo.SMRevision = "Fake SM Revision";
            rinfo.SOMRevision = "Fake SOM Revision";

            g.RelInfos = new ReleaseInfo[] { rinfo };

            return g;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\BetaManagementUtilsV3.cs ===
using System;
using xonline.mix.betamanagement.contracts.V3;
using System.Collections.Generic;
using System.Collections;
using MIXTesting;
using ServerTestFramework.Database;
using Microsoft.Webstore.WstClient;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using xonline.common.service;
using ServerTestFramework.Utilities;

namespace MixTest
{
    public class BetaManagementUtilsV3
    {
        public static List<Group> CreateFakeGroups(int count)
        {
            Random r = new Random();
            List<Group> groups = new List<Group>();

            for (int i = 0; i < count; i++)
            {
                Group g = new Group();

                g.FlashVersion =  (uint)r.Next();

                BetaGroupEditor be =  BetaGroupEditor.CreateNew();

                g.Summary = new GroupSummary();
                g.Summary.Created = be.Created;
                g.Summary.Creator = be.Creator;
                g.Summary.GroupGuid = be.Id;
                g.Summary.Name = be.Name;

                List<ReleaseInfo> infos = new List<ReleaseInfo>();
                ReleaseInfo ri;
                int relcount = r.Next(1, 5);
                for (int j = 0; j < relcount; j++)
                {
                    ri = new ReleaseInfo();
                    ri.FlashQfe = (short)r.Next(128);
                    ri.FlashVersion = (short) (((g.FlashVersion & 0xFFFF00) / 0x100) - j);
                    ri.SMRevision = "Fake System Manifest Revision " + j;
                    ri.SOMRevision = "Fake System Online Manifest Revision " + j;
                    infos.Add(ri);
                }

                g.RelInfos = infos.ToArray();


                List<UpgradePath> paths = new List<UpgradePath>();
                UpgradePath up;
                int pathcount = r.Next(1, 5);
                PlatformType pt = PlatformType.Xenon;

                for (int j = 0; j < pathcount; j++)
                {
                    up = new UpgradePath();
                    up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                    up.BaseVersion = (uint) r.Next(1, (int) up.UpgradeVersion); // Get a random base version upgrading to the current flash version
                    up.ConsoleType = pt;
                    up.TitleId = XOn.XENON_DASH_TITLE_ID;
                    paths.Add(up);
                }

                // Now make the self-referential upgrade path
                up = new UpgradePath();
                up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                up.BaseVersion = up.UpgradeVersion; // Base-enabling it
                up.ConsoleType = pt;
                up.TitleId = XOn.XENON_DASH_TITLE_ID;
                paths.Add(up);


                g.Titles = paths.ToArray();

                groups.Add(g);
            }
            return groups;
        }

        public static void AddFakeGroups(IEnumerable<Group> groups, ref List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                foreach (UpgradePath up in g.Titles)
                {
                    InsertUpgradePath(up, g.Summary.GroupGuid, ref titlesToDelete);
                }

                foreach (ReleaseInfo ri in g.RelInfos)
                {
                    InsertReleaseInfo(ri, g.Summary.GroupGuid);
                }
            }
        }

        private static void InsertReleaseInfo(ReleaseInfo ri, Guid group)
        {
            string query = String.Format("exec p_betagroup_assign_release '{0}', {1}, '{2}', '{3}', {4}", group.ToString(), ri.FlashVersion, ri.SOMRevision, ri.SMRevision, ri.FlashQfe);
            ExecuteNPDBScalar(query);
        }

        public static bool InsertTitle(uint titleID, byte consoleType)
        {
            string titlequery = String.Format("select null from t_titles where i_title_id={0}", (int) titleID);
            string titleinsert = String.Format("insert into t_titles (i_title_id,ti_console_type_id) values ({0},{1})", (int)titleID, consoleType);
            // The title tables are global, so just check one of them
            bool inserted = false;
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(titlequery, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                WstDataReader reader = cmd.ExecuteReader();

                if (!reader.HasRows) // Title did not exist
                {
                    TitleManagementWCFClient.ExecuteUODBScalar(titleinsert);
                    inserted = true;
                }
                reader.Close();
            }
            return inserted;
        }

        public static void InsertUpgradePath(UpgradePath up, Guid group, ref List<uint> titlesToDelete)
        {
            string insert = String.Format("insert into t_title_versions (i_title_id,i_base_version,i_update_version,ti_console_type_id,uid_beta_group_id) values ({0},{1},{2},{3},'{4}')", (int)up.TitleId, (int)up.BaseVersion, (int)up.UpgradeVersion, (byte)up.ConsoleType, group.ToString());
            // Make sure the title's in t_titles
            if (InsertTitle(up.TitleId, (byte)up.ConsoleType))
            {
                titlesToDelete.Add(up.TitleId);
            }

            // Now we know the title exists.
            TitleManagementWCFClient.ExecuteUODBScalar(insert);
        }

        public static void ExecuteNPDBScalar(string s)
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            npdb.ExecuteScalar(s);
            npdb.Close();
        }

        public static void CleanGroups(IEnumerable<Group> groups, List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                CleanGroup(g);
            }

            foreach (uint title in titlesToDelete)
            {
                RemoveTitle(title);             
            }
        }

        public static void RemoveTitle(uint title)
        {
            string deleteTitle = String.Format("delete from t_titles where i_title_id={0}", title);
            TitleManagementWCFClient.ExecuteUODBScalar(deleteTitle);   
        }

        public static void CleanGroup(Group g)
        {
            BetaGroupEditor.NukeGroup(g.Summary.GroupGuid);
            string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
            string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());

            TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            ExecuteNPDBScalar(relInfoClear);
        }

        public static bool ValidateRelease(Guid group, string SOMRevision, string SMRevision, uint version)
        {
            string validateSOMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SOMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SOMRevision, group.ToString());
            string validateSMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SMRevision, group.ToString());

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();

                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = validateSOMRevision;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Online Manifest Revision.  Expected: {1}", group, SOMRevision);
                        return false;
                    }
                }


                cmd.CommandText = validateSMRevision;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Manifest Revision.  Expected: {1}", group, SMRevision);
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool ValidateUpgradeExists(UpgradePath path, Guid group)
        {
            string validateUpgradeQuery = "select null from t_title_versions where i_base_version={0} and i_update_version={1} and ti_console_type_id={2} and uid_beta_group_id='{3}'";


            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(String.Format(validateUpgradeQuery, path.BaseVersion, path.UpgradeVersion, (byte)path.ConsoleType, group.ToString()), conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                using (WstDataReader reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) // Title did not exist
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static bool ValidateUpdateIsUnique(uint version, Guid group)
        {
            string countUpdates = String.Format("select count(null) from t_title_versions where i_update_version={0} and uid_beta_group_id='{1}'", version, group.ToString());
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(countUpdates, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                if ((int)cmd.ExecuteScalar() != 1) // More rows were added than we expect
                {
                    Global.RO.Error("There were multiple upgrade paths to the dash version 0x{0:X} for group {1}", version, group);
                    return false;
                }
            }
            return true;
        }

        public static bool InsertFlashVersionLocation(uint version)
        {
            string insertVersion = String.Format("insert into t_title_update_locations values (0xFFFE07D1, 0x1, {0}, 1, 'xrl:invalid', CURRENT_TIMESTAMP,2)", version);
            TitleManagementWCFClient.ExecuteUODBScalar(insertVersion);

            return true;
        }

        public static bool DeleteFlashVersionLocation(uint version)
        {
            string removeVersion = String.Format("delete from t_title_update_locations where i_title_id=0xFFFE07D1 and i_title_base_version=0x1 and i_title_update_version = {0}", version);
            TitleManagementWCFClient.ExecuteUODBScalar(removeVersion);

            return true;
        }

        public static void VerifyGroupMembership(System.Guid group, string []expectedConsoles)
        {
            BetaGroupEditor bge=BetaGroupEditor.FromId(group);
            string []actualConsoles=bge.GetAllConsoles();

            ValueCheck.TestAllUnordered("Group membership for "+group, expectedConsoles, actualConsoles);
        }

        public static void VerifyGroupMembership(System.Guid group, ulong []expectedMachines)
        {
            BetaGroupEditor bge=BetaGroupEditor.FromId(group);
            ulong []actualMachines=bge.GetAllMachines();

            ValueCheck.TestAllUnordered("Group membership for "+group, expectedMachines, actualMachines);
        }

        public static void VerifyGroupMembershipChangeResult(GroupMembershipChangeResult []result, GroupMembershipChangeResult []expected)
        {
            if (result==null)
            {
                throw new UnexpectedTestResultException("Result was null.");
            }

            if (result.Length!=expected.Length)
            {
                throw new UnexpectedTestResultException("Got a different number of results("+result.Length+") than expected("+expected.Length+").");
            }

            for (int i=0; i<result.Length; ++i)
            {
                if (expected[i].ConsoleID!=result[i].ConsoleID)
                {
                    throw new UnexpectedTestResultException("ConsoleID for index "+i+": Expected "+expected[i].ConsoleID+", got "+result[i].ConsoleID);
                }

                if (expected[i].Outcome!=result[i].Outcome)
                {
                    throw new UnexpectedTestResultException("Reason for console "+expected[i].ConsoleID+": Expected "+expected[i].Outcome+", got "+result[i].Outcome);
                }

                if (expected[i].ConflictingGroups!=null && result[i].ConflictingGroups!=null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, expected[i].ConflictingGroups, result[i].ConflictingGroups);
                }
                else if ((expected[i].ConflictingGroups==null || expected[i].ConflictingGroups.Length==0) && (result[i].ConflictingGroups==null || result[i].ConflictingGroups.Length==0))
                {
                    //both empty are ok
                }
                else if (expected[i].ConflictingGroups==null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, new System.Guid[0], result[i].ConflictingGroups);
                }
                else //result[i].ConflictingGroups==null
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleID, expected[i].ConflictingGroups, new System.Guid[0]);
                }
            }
        }

        public static GroupMembershipChangeResult[] BuildSuccessfulGroupMembershipChangeResult(string []consoles)
        {
            GroupMembershipChangeResult []results=new GroupMembershipChangeResult[consoles.Length];
            for (int i=0; i<consoles.Length; ++i)
            {
                results[i]=new GroupMembershipChangeResult();
                results[i].ConsoleID=consoles[i];
                results[i].Outcome=GroupMembershipChangeOutcome.Success;
                results[i].ConflictingGroups=new System.Guid[0];
            }

            return results;
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, string []consoles, GroupMembershipChangeOutcome reason)
        {
            ChangeGroupMembershipChangeResult(result, consoles, reason, new System.Guid[0]);
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, string []consoles, GroupMembershipChangeOutcome reason, IEnumerable<System.Guid> conflictingGroups)
        {
            foreach (string console in consoles)
            {
                bool found=false;
                foreach (GroupMembershipChangeResult r in result)
                {
                    if (r.ConsoleID==console)
                    {
                        r.Outcome=reason;

                        //r.ConflictingGroups=conflictingGroups; //this should work!  but the mix contract generated proxy is creating a type (Guid[]) that's different than the data contract definition (IEnumerable<Guid>).  For now just manually create an array from it...
                        int count=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            ++count;
                        }
                        r.ConflictingGroups=new System.Guid[count];
                        int i=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            r.ConflictingGroups[i]=cg;
                            ++i;
                        }

                        found=true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new System.Exception("Console "+console+" not found to change.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AssignTitleUpdateToGroup.cs ===
using System;
using ServerTestFramework;
using MIXTesting;
using ServerTestFramework.Database;
using System.Collections.Generic;
using xonline.common.config;

namespace MixTest
{
    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class AssignTitleUpdateToGroup : TestNode
    {
        static BetaManagementV4WCFClient clientV4 = new BetaManagementV4WCFClient();

        [TestGroup, Description("Mix Group Management Tests")]
        public class SetupWithBetaGroup : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();
                MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AssignTitleUpdateToGroup", "MixBetaManagement.AssignTitleUpdateToGroups");
            }

            [TestCase, TestCasePriority(1)]
            class BaseEnable : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.BaseEnable));
                }
            }

            [TestCase, TestCasePriority(1)]
            class UpgradeBaseEnable : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeBaseEnable));
                }
            }

            [TestCase]
            class UpgradeWithUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithUntouchedVersions));
                }
            }

            [TestCase, TestCasePriority(1)]
            class UpgradeWithMultipleUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithMultipleUntouchedVersions));
                }
            }

            [TestCase]
            class NewVersionWithMultipleUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NewVersionWithMultipleUntouchedVersions));
                }
            }

            [TestCase]
            class AltPathInsideUpgrage : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltPathInsideUpgrage));
                }
            }

            [TestCase]
            class AltUpgradeLeavingUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeLeavingUpgradePath));
                }
            }

            [TestCase]
            class AltUpgradeEnteringUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeEnteringUpgradePath));
                }
            }

            [TestCase]
            class AltUpgradeSurroundingUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeSurroundingUpgradePath));
                }
            }

            [TestCase]
            class AltUpgradeThroughUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughUpgradePath));
                }
            }

            [TestCase]
            class AltUpgradeThroughComplexUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughComplexUpgradePath));
                }
            }

            [TestCase]
            class NullTitleID : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NullTitleID), false, true, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NullTitleID), false, true, true);
                }
            }

            [TestCase, TestCasePriority(3)]
            class NullUpgradeVersion : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NullUpgrade), false, true, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NullUpgrade), false, true, true);
                }
            }

            [TestCase]
            class FlippedUpgrade : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.FlippedVersion), false, true, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.FlippedVersion), false, true, true);
                }
            }

            [TestCase]
            class BatchedVerifyNoReload : WCFTestBase
            {
                public override void Run()
                {
                    // The other tests will make sure the APIs are working functionally. This test is purely for testing the reload parameter
                    string s = TestPath(TitleUpgradeTestFiles.BaseEnable);

                    TitleUpgradeTests tests = TitleUpgradeTests.Load(s);

                    bool pass = true;
                    Exception lastException = null;
                    foreach (TitleUpgradeTest t in tests.Items)
                    {
                        BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                        Guid[] betaGroupIds = new Guid[1] { bge.Id };

                        try
                        {
                            SetupTitleUpgradeTest(t.StartVersions, betaGroupIds);
                            Version v = t.UpdateVersion.Version;

                            // Set up the reload watcher
                            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                            change.Source = "Xkdc";
                            change.Init();

                            // true = noReload
                            clientV4.AssignTitleUpdateToGroups(v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds, true);

                            // Validate reload didn't occur
                            bool reloadEvent = change.TestForChange("Reinitialize: completed reinitialization.");

                            if (reloadEvent)
                                throw new UnexpectedTestResultException("Reload event still occured when we passed true to noReload!");
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error(e.ToString());
                            pass = false;
                            lastException = e;
                        }
                        finally
                        {
                            String query;
                            foreach (Version v in t.StartVersions)
                            {
                                query = String.Format("delete from t_title_versions where i_title_id=0x{0:X} and i_base_version=0x{1:X} and i_update_version=0x{2:X} and uid_beta_group_id='{3}'",
                                    v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds[0]);
                                UodbWS.ExecuteSQLNonQuery(query, null);
                            }
                            query = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", betaGroupIds[0]);
                            UodbWS.ExecuteSQLNonQuery(query, null);
                            BetaGroupEditor.NukeGroup(betaGroupIds[0]);
                        }
                    }

                    if (!pass)
                    {
                        throw new UnexpectedTestResultException("Got one or more exceptions.", lastException);
                    }
                }
            }

            [TestCase]
            class BatchedVerifyReload : WCFTestBase
            {
                public override void Run()
                {
                    // The other tests will make sure the APIs are working functionally. This test is purely for testing the reload parameter
                    string s = TestPath(TitleUpgradeTestFiles.BaseEnable);

                    TitleUpgradeTests tests = TitleUpgradeTests.Load(s);

                    bool pass = true;
                    Exception lastException = null;
                    foreach (TitleUpgradeTest t in tests.Items)
                    {
                        BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                        Guid[] betaGroupIds = new Guid[1] { bge.Id };

                        try
                        {
                            SetupTitleUpgradeTest(t.StartVersions, betaGroupIds);
                            Version v = t.UpdateVersion.Version;

                            // Set up the reload watcher
                            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                            change.Source = "Xkdc";
                            change.Init();

                            // false = yesReload
                            clientV4.AssignTitleUpdateToGroups(v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds, false);

                            // Validate reload did occur
                            bool reloadEvent = change.TestForChange("Reinitialize: completed reinitialization.");

                            if (!reloadEvent)
                                throw new UnexpectedTestResultException("Reload event didn't occur when we passed false to noReload!");
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error(e.ToString());
                            pass = false;
                            lastException = e;
                        }
                        finally
                        {
                            String query;
                            foreach (Version v in t.StartVersions)
                            {
                                query = String.Format("delete from t_title_versions where i_title_id=0x{0:X} and i_base_version=0x{1:X} and i_update_version=0x{2:X} and uid_beta_group_id='{3}'",
                                    v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds[0]);
                                UodbWS.ExecuteSQLNonQuery(query, null);
                            }
                            query = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", betaGroupIds[0]);
                            UodbWS.ExecuteSQLNonQuery(query, null);
                            BetaGroupEditor.NukeGroup(betaGroupIds[0]);
                        }
                    }

                    if (!pass)
                    {
                        throw new UnexpectedTestResultException("Got one or more exceptions.", lastException);
                    }
                }
            }
        }


        [TestGroup, Description("Mix Group Management Tests")]
        public class SetupWithGA : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();
                MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AssignTitleUpdateToGroup");
            }

            [TestCase, TestCasePriority(1)]
            class BaseEnable : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.BaseEnable), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.BaseEnable), true, false, true);
                }
            }

            [TestCase, TestCasePriority(1)]
            class UpgradeBaseEnable : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeBaseEnable), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeBaseEnable), true, false, true);
                }
            }

            [TestCase]
            class UpgradeWithUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithUntouchedVersions), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithUntouchedVersions), true, false, true);
                }
            }

            [TestCase, TestCasePriority(1)]
            class UpgradeWithMultipleUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithMultipleUntouchedVersions), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.UpgradeWithMultipleUntouchedVersions), true, false, true);
                }
            }

            [TestCase]
            class NewVersionWithMultipleUntouchedVersions : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NewVersionWithMultipleUntouchedVersions), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.NewVersionWithMultipleUntouchedVersions), true, false, true);
                }
            }

            [TestCase]
            class AltPathInsideUpgrage : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltPathInsideUpgrage), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltPathInsideUpgrage), true, false, true);
                }
            }

            [TestCase]
            class AltUpgradeLeavingUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeLeavingUpgradePath), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeLeavingUpgradePath), true, false, true);
                }
            }

            [TestCase]
            class AltUpgradeEnteringUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeEnteringUpgradePath), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeEnteringUpgradePath), true, false, true);
                }
            }

            [TestCase]
            class AltUpgradeSurroundingUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeSurroundingUpgradePath), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeSurroundingUpgradePath), true, false, true);
                }
            }

            [TestCase]
            class AltUpgradeThroughUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughUpgradePath), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughUpgradePath), true, false, true);
                }
            }

            [TestCase]
            class AltUpgradeThroughComplexUpgradePath : WCFTestBase
            {
                public override void Run()
                {
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughComplexUpgradePath), true, false, false);
                    TestUpdates(TestPath(TitleUpgradeTestFiles.AltUpgradeThroughComplexUpgradePath), true, false, true);
                }
            }
        }



        #region Utils

        private static string TestPath(string p)
        {
            return @"InputFiles\MixBetaManagement\" + p;
        }


        public static void TestUpdates(string s)
        {
            // Call for both unbatched and batched
            TestUpdates(s, false, false, false);
            TestUpdates(s, false, false, true);
        }

        public static void TestUpdates(string s, bool useGAGuid, bool expectFailure, bool batched)
        {
            if (useGAGuid) // The GA Guid tests all use a -null suffix to distinguish them
            {
                s = s + "-null";
            }

            TitleUpgradeTests tests = TitleUpgradeTests.Load(s);

            bool pass = true;
            Exception lastException=null;
            foreach (TitleUpgradeTest t in tests.Items)
            {
                int numBetaGroups = 1;
                if (batched)
                {
                    // If we want to use the batching API, let's create between 2 and 20 beta groups
                    Random rand = new Random();
                    numBetaGroups = rand.Next(2, 20);
                }

                Guid[] betaGroupIds = new Guid[numBetaGroups];

                for (int i = 0; i < numBetaGroups; ++i)
                {
                    BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                    betaGroupIds[i] = bge.Id;
                }

                Global.RO.Info("Number of Beta Groups: " + numBetaGroups);

                try
                {
                    SetupTitleUpgradeTest(t.StartVersions, useGAGuid ? new Guid[] { Guid.Empty } : betaGroupIds);
                    Version v = t.UpdateVersion.Version;

                    // Here we will use the batched version of the API if we have more than 1 beta group
                    if (betaGroupIds.Length > 1)
                    {
                        clientV4.AssignTitleUpdateToGroups(v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds, false);
                    }
                    else
                    {
                        clientV4.AssignTitleUpdateToGroup(v.titleID, v.baseVersion, v.upgradeVersion, betaGroupIds[0]);
                    }
                    
                    pass = ValidateTitleUpgrades(t.ExpectedVersions, betaGroupIds);
                }
                catch (Exception e)
                {
                    Global.RO.Error(e.ToString());
                    pass = false;
                    lastException=e;
                }
                finally
                {
                    foreach (Guid bgid in betaGroupIds)
                    {
                        String query;
                        foreach (Version v in t.StartVersions)
                        {
                            query = String.Format("delete from t_title_versions where i_title_id=0x{0:X} and i_base_version=0x{1:X} and i_update_version=0x{2:X} and uid_beta_group_id='{3}'",
                                v.titleID, v.baseVersion, v.upgradeVersion, useGAGuid ? Guid.Empty : bgid);
                            UodbWS.ExecuteSQLNonQuery(query, null);
                        }
                        query = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", bgid);
                        UodbWS.ExecuteSQLNonQuery(query, null);
                        BetaGroupEditor.NukeGroup(bgid);
                    }
                }
            }

            if (!expectFailure && !pass)
            {
                throw new UnexpectedTestResultException("Got one or more exceptions.", lastException);
            }

            if (expectFailure && pass)
            {
                throw new UnexpectedTestResultException("Unexpectedly succeeded.");
            }
        }

        private static bool ValidateTitleUpgrades(Version[] versions, Guid[] betaGroupIds)
        {
            bool passed = true;

            // Using a dictionary to prevent an excessive number of calls to get the title versions
            Dictionary<uint, List<Version>> expectedVersions = new Dictionary<uint, List<Version>>();
            Dictionary<uint, List<Version>> actualVersions = new Dictionary<uint, List<Version>>();

            // Build our expected lists per title
            foreach (Version v in versions)
            {
                if (!expectedVersions.ContainsKey(v.titleID)) // TitleID hasn't been added yet
                {
                    expectedVersions.Add(v.titleID, new List<Version>());
                }
                expectedVersions[v.titleID].Add(v);
            }

            // Now build our actual lists per title
            TitleEditor te;
            foreach (uint title in expectedVersions.Keys)
            {
                te = TitleEditor.FromId(title);
                foreach (Guid bgid in betaGroupIds)
                {
                    ServerTestFramework.Database.TitleEditor.TitleVersion[] tvs = te.GetAllVersions(bgid);
                    foreach (ServerTestFramework.Database.TitleEditor.TitleVersion tv in tvs)
                    {
                        Version v = (Version)tv;
                        v.titleID = title;
                        if (!actualVersions.ContainsKey(title))
                        {
                            actualVersions.Add(title, new List<Version>());
                        }
                        actualVersions[title].Add(v);
                    }
                }
            }

            //Finally, validate that all of our expected versions are present
            foreach (uint title in expectedVersions.Keys)
            {
                foreach (Version v in expectedVersions[title])
                {
                    if (!actualVersions[title].Contains(v))
                    {
                        passed = false;
                        Global.RO.Error("Could not find expected upgraded path for title 0x{0:X}.  Base: 0x{1:X}  Upgrade: 0x{2:X}", v.titleID, v.baseVersion, v.upgradeVersion);
                    }
                }
            }

            if (!passed)
            {
                Global.RO.Warn("Paths Found:\n");
                foreach (uint i in actualVersions.Keys)
                {
                    foreach (Version v in actualVersions[i])
                    {
                        Global.RO.Error("TitleID: 0x{0:X}   Base: 0x{1:X}   Update: 0x{2:X}", v.titleID, v.baseVersion, v.upgradeVersion);
                    }
                }
            }

            return passed;
        }

        /// <summary>
        /// Set up the environment / state that this test requires
        /// </summary>
        /// <param name="versions"></param>
        /// <param name="betaGroupIds"></param>
        private static void SetupTitleUpgradeTest(Version[] versions, Guid[] betaGroupIds)
        {
            TitleEditor te;
            foreach (Version v in versions)
            {
                te = TitleEditor.FromId(v.titleID);
                foreach (Guid bgid in betaGroupIds)
                {
                    te.AddVersion(v.baseVersion, v.upgradeVersion, 2, bgid);
                }
            }
        }

        public class TitleUpgradeTestFiles
        {
            public static string BaseEnable = "1.xml";
            public static string UpgradeBaseEnable = "2.xml";
            public static string UpgradeWithUntouchedVersions = "3.xml";
            public static string UpgradeWithMultipleUntouchedVersions = "4.xml";
            public static string NewVersionWithMultipleUntouchedVersions = "5.xml";
            public static string AltPathInsideUpgrage = "6.xml";
            public static string AltUpgradeLeavingUpgradePath = "7.xml";
            public static string AltUpgradeEnteringUpgradePath = "8.xml";
            public static string AltUpgradeSurroundingUpgradePath = "9.xml";
            public static string AltUpgradeThroughUpgradePath = "10.xml";
            public static string AltUpgradeThroughComplexUpgradePath = "11.xml";
            public static string NullTitleID = "12.xml";
            public static string NullUpgrade = "13.xml";
            public static string FlippedVersion = "14.xml";
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\AddConsoleInfosToGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using Utils=MixTest.BetaManagementUtilsV4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the AddConsoleInfosToGroup (beta group) API")]
    public class AddConsoleInfosToGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.AddConsoleInfosToGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Adds 1 machine to a group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.CreateNew(mtype))};

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, consoles);
            Utils.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Add a machine that has an scode that is not a duplicate to a group without specifying an scode.")]
        [CompoundCase("Null", null)]
        [CompoundCase("Empty", "")]
        public void NoSCode_Nonduplicate(TestNode myNode)
        {
            string scode=(string)myNode.MyValues[0];

            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaV4.ConsoleInfo []consolesToPass=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};
            BetaV4.ConsoleInfo []consolesExpected=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach)};

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToPass, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, consolesToPass);
            Utils.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesExpected));
        }

        [TestCase, TestCasePriority(1), Description("Add an xbox360 that has not been migrated to the new key table without specifying an scode.  Since we don't have a unique differentiator for this machine in the db yet, it is treated as a duplicate since it could potentially become swapped with a duplicate in the future still.")]
        public void NoSCode_LegacyXbox360()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, null)};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV4.GroupMembershipChangeOutcome.MachineDuplicate);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Adds 1 machine to a group that already has some other machines in it.")]
        public void AddToGroupThatHasExistingMachines()
        {
            MachineEditor existingMachine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor existingMachine1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor existingMachine2=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor newMachine=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(existingMachine0.Id);
            bge.AddMachine(existingMachine1.Id);
            bge.AddMachine(existingMachine2.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(newMachine)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consoles, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo []{Utils.MakeConsoleInfo(newMachine), Utils.MakeConsoleInfo(existingMachine0), Utils.MakeConsoleInfo(existingMachine1), Utils.MakeConsoleInfo(existingMachine2)});
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Adds 500 machine to a group.")]
        public void Add500Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 500 machines...");
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[500];
            for (int i=0; i<500; ++i)
            {
                consoles[i]=Utils.MakeConsoleInfo(MachineEditor.CreateNew(MachineType.Xbox360));
            }

            Global.RO.Debug("Running...");
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consoles, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, consoles);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360), "0000-0000-0000-0000")};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        [CompoundCase("BadChars", "XE.ABCDEFGHIJHL")]
        [CompoundCase("TooShort", "XE.1")]
        [CompoundCase("TooLong", "XE.1111111111111")]
        [CompoundCase("Empty", "")]
        public void InvalidConsoleID(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(cid, "0000-0000-0000-0000")};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid SCode")]
        [CompoundCase("BadChars", "XX**ThisIsNotValid*")]
        [CompoundCase("TooShort", "0000")]
        [CompoundCase("TooLong", "0000-0000-0000-0000-0000")]
        //[CompoundCase("Empty", "")] //Note, starting with the 2011 june xsr, we will treat this case as null (which is valid) ONLY FOR SCODE
        public void InvalidSCode(TestNode self)
        {
            string scode=(string)self.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Adds 0 machine to a group.")]
        public void AddNoMachines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[0];

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(consoles, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for a consoleid in the console list.")]
        public void ConsoleIDsEntryNull()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(null, null)};

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(null, bge.Id);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleIDsNull()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[0];

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(null, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add to the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.CreateNew(MachineType.Xbox360))};

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(actualConsoles, System.Guid.Empty);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add to a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            System.Guid guid=System.Guid.NewGuid();

            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.CreateNew(MachineType.Xbox360))};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(actualConsoles, guid);

            BetaManagementUtilsV4.VerifyGroupMembership(guid, expectedConsoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 1, but it's already in a different group.")]
        public void AlreadyInADifferentGroup()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine)};
            bgeOther.AddMachine(machine.Id);

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(actualConsoles, bgeNew.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);
            BetaManagementUtilsV4.VerifyGroupMembership(bgeOther.Id, actualConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(actualConsoles);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, actualConsoles, BetaV4.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bgeOther.Id});
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 1, but it's already in that group.")]
        public void AlreadyInSameGroup()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine)};
            bge.AddMachine(machine.Id);

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(actualConsoles, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, actualConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(actualConsoles);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, actualConsoles, BetaV4.GroupMembershipChangeOutcome.MemberAlreadyInGroup, new System.Guid[]{bge.Id});
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to add 3, but the second one is already in another group")]
        public void Add3WithOneAlreadyInADifferentGroup()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeOther.AddMachine(machine1.Id);

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine0), Utils.MakeConsoleInfo(machine1), Utils.MakeConsoleInfo(machine2)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bgeNew.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[2]{Utils.MakeConsoleInfo(machine0), Utils.MakeConsoleInfo(machine2)});
            BetaManagementUtilsV4.VerifyGroupMembership(bgeOther.Id, new BetaV4.ConsoleInfo[1]{Utils.MakeConsoleInfo(machine1)});

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine1)}, BetaV4.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bgeOther.Id});
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Pass a real array but with null for one of the consoles in the list.")]
        public void ConsoleInfosArrayEntryNull()
        {
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine0), null, Utils.MakeConsoleInfo(machine2)};

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.AddConsoleInfosToGroup(consolesToAdd, bgeNew.Id);

            // Make sure they didn't get added
            BetaManagementUtilsV4.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]{});
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(spoofyName, mach.ComputeSCode())};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consoles, bge.Id);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to add a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_NoSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            //call api
            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0.ConsoleId, null), Utils.MakeConsoleInfo(machNormal1.ConsoleId, null)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            //verify - Note that we have a problem here.  The order returned from MixBetaManagement is supposed to always deterministically match the order passed in.  Here we don't know which SCode will come back first though, so try validating both orders.  This is a littly hacky but it works.
            bool eitherValidates=false;
            System.Exception exception0=null;
            System.Exception exception1=null;

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                expectedResult[2].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception0=e;
            }

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                expectedResult[2].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception1=e;
            }

            if (!eitherValidates)
            {
                throw new UnexpectedTestResultException("Neither order validates.", exception0??exception1);
            }

            //verify group in db
            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, new ulong[]{machNormal0.Id, machNormal1.Id});
        }

        [TestCase, TestCasePriority(1), Description("Attempt to add a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_WithSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            MachineEditor machDupe2=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId); //we don't add this one
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            //call api
            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge.Id);

            //verify
            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);

            BetaManagementUtilsV4.VerifyGroupMembership(bge.Id, new ulong[]{machNormal0.Id, machNormal1.Id, machDupe0.Id, machDupe1.Id});
        }

        [TestCase, TestCasePriority(1), Description("Attempt to add a consoleID that is shared by multiple machines to a group, where one of the two machines is in a conflicting group.")]
        public void DuplicateConsoleId_OneConflict()
        {
            //create machines and groups
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);

            BetaGroupEditor bge0=BetaGroupEditor.CreateNew();
            BetaGroupEditor bge1=BetaGroupEditor.CreateNew();
            bge1.AddMachine(machDupe1.Id);

            //call api
            BetaV4.ConsoleInfo []consolesToAdd=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().AddConsoleInfosToGroup(consolesToAdd, bge0.Id);

            //verify
            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machDupe1)}, BetaV4.GroupMembershipChangeOutcome.MemberInOtherGroup, new System.Guid[]{bge1.Id});
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);

            BetaManagementUtilsV4.VerifyGroupMembership(bge0.Id, new ulong[]{machDupe0.Id});
            BetaManagementUtilsV4.VerifyGroupMembership(bge1.Id, new ulong[]{machDupe1.Id});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetConsoleIDsInGroupV3.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV1=xonline.mix.betamanagement.contracts.V1;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the GetConsoleIDsInGroup (beta group) API")]
    public class GetConsoleIDsInGroupV3: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetConsoleIDsInGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Gets a list from a group with 1 member.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(MachineEditor.CreateNew(mtype).Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []result=client.GetConsoleIDsInGroup(bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, result);
        }

        [TestCase, TestCasePriority(1), Description("Gets 1000 machines from a group.")]
        public void Get1000Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 1000 machines...");
            for (int i=0; i<1000; ++i)
            {
                bge.AddMachine(MachineEditor.CreateNew(MachineType.Xbox360).Id);
            }

            Global.RO.Debug("Running...");
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []result=client.GetConsoleIDsInGroup(bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, result);
        }

        [TestCase, TestCasePriority(1), Description("Get 0 machine from a group.")]
        public void GetNoMachines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []result=client.GetConsoleIDsInGroup(bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, result);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to get from the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            string []result=client.GetConsoleIDsInGroup(System.Guid.Empty);

            if (result!=null && result.Length!=0)
            {
                throw new UnexpectedTestResultException("Expected no consoles!");
            }
        }

        [TestCase, TestCasePriority(2), Description("Attempt to get from a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            string []result=client.GetConsoleIDsInGroup(System.Guid.NewGuid());

            if (result!=null && result.Length!=0)
            {
                throw new UnexpectedTestResultException("Expected no consoles!");
            }
        }

        [TestCase, TestCasePriority(1), Description("Attempt to get a consoleID that is shared by multiple machines from a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId()
        {
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            bge.AddMachine(machNormal0.Id);
            bge.AddMachine(machNormal1.Id);
            bge.AddMachine(machDupe0.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []result=client.GetConsoleIDsInGroup(bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\BetaManagementUtilsV4.cs ===
using System;
using xonline.mix.betamanagement.contracts.V4;
using System.Collections.Generic;
using System.Collections;
using MIXTesting;
using ServerTestFramework.Database;
using Microsoft.Webstore.WstClient;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using xonline.common.service;
using ServerTestFramework.Utilities;

namespace MixTest
{
    public class BetaManagementUtilsV4
    {
        public static List<Group> CreateFakeGroups(int count)
        {
            Random r = new Random();
            List<Group> groups = new List<Group>();

            for (int i = 0; i < count; i++)
            {
                Group g = new Group();

                g.FlashVersion =  (uint)r.Next();

                BetaGroupEditor be =  BetaGroupEditor.CreateNew();

                g.Summary = new GroupSummary();
                g.Summary.Created = be.Created;
                g.Summary.Creator = be.Creator;
                g.Summary.GroupGuid = be.Id;
                g.Summary.Name = be.Name;

                List<ReleaseInfo> infos = new List<ReleaseInfo>();
                ReleaseInfo ri;
                int relcount = r.Next(1, 5);
                for (int j = 0; j < relcount; j++)
                {
                    ri = new ReleaseInfo();
                    ri.FlashQfe = (short)r.Next(128);
                    ri.FlashVersion = (short) (((g.FlashVersion & 0xFFFF00) / 0x100) - j);
                    ri.SMRevision = "Fake System Manifest Revision " + j;
                    ri.SOMRevision = "Fake System Online Manifest Revision " + j;
                    infos.Add(ri);
                }

                g.RelInfos = infos.ToArray();


                List<UpgradePath> paths = new List<UpgradePath>();
                UpgradePath up;
                int pathcount = r.Next(1, 5);
                PlatformType pt = PlatformType.Xenon;

                for (int j = 0; j < pathcount; j++)
                {
                    up = new UpgradePath();
                    up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                    up.BaseVersion = (uint) r.Next(1, (int) up.UpgradeVersion); // Get a random base version upgrading to the current flash version
                    up.ConsoleType = pt;
                    up.TitleId = XOn.XENON_DASH_TITLE_ID;
                    paths.Add(up);
                }

                // Now make the self-referential upgrade path
                up = new UpgradePath();
                up.UpgradeVersion = ((g.FlashVersion & 0xFFFF00) / 0x100);
                up.BaseVersion = up.UpgradeVersion; // Base-enabling it
                up.ConsoleType = pt;
                up.TitleId = XOn.XENON_DASH_TITLE_ID;
                paths.Add(up);


                g.Titles = paths.ToArray();

                groups.Add(g);
            }
            return groups;
        }

        public static void AddFakeGroups(IEnumerable<Group> groups, ref List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                foreach (UpgradePath up in g.Titles)
                {
                    InsertUpgradePath(up, g.Summary.GroupGuid, ref titlesToDelete);
                }

                foreach (ReleaseInfo ri in g.RelInfos)
                {
                    InsertReleaseInfo(ri, g.Summary.GroupGuid);
                }
            }
        }

        private static void InsertReleaseInfo(ReleaseInfo ri, Guid group)
        {
            string query = String.Format("exec p_betagroup_assign_release '{0}', {1}, '{2}', '{3}', {4}", group.ToString(), ri.FlashVersion, ri.SOMRevision, ri.SMRevision, ri.FlashQfe);
            ExecuteNPDBScalar(query);
        }

        public static bool InsertTitle(uint titleID, byte consoleType)
        {
            string titlequery = String.Format("select null from t_titles where i_title_id={0}", (int) titleID);
            string titleinsert = String.Format("insert into t_titles (i_title_id,ti_console_type_id) values ({0},{1})", (int)titleID, consoleType);
            // The title tables are global, so just check one of them
            bool inserted = false;
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(titlequery, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                WstDataReader reader = cmd.ExecuteReader();

                if (!reader.HasRows) // Title did not exist
                {
                    TitleManagementWCFClient.ExecuteUODBScalar(titleinsert);
                    inserted = true;
                }
                reader.Close();
            }
            return inserted;
        }

        public static void InsertUpgradePath(UpgradePath up, Guid group, ref List<uint> titlesToDelete)
        {
            string insert = String.Format("insert into t_title_versions (i_title_id,i_base_version,i_update_version,ti_console_type_id,uid_beta_group_id) values ({0},{1},{2},{3},'{4}')", (int)up.TitleId, (int)up.BaseVersion, (int)up.UpgradeVersion, (byte)up.ConsoleType, group.ToString());
            // Make sure the title's in t_titles
            if (InsertTitle(up.TitleId, (byte)up.ConsoleType))
            {
                titlesToDelete.Add(up.TitleId);
            }

            // Now we know the title exists.
            TitleManagementWCFClient.ExecuteUODBScalar(insert);
        }

        public static void ExecuteNPDBScalar(string s)
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            npdb.ExecuteScalar(s);
            npdb.Close();
        }

        public static void CleanGroups(IEnumerable<Group> groups, List<uint> titlesToDelete)
        {
            foreach (Group g in groups)
            {
                CleanGroup(g);
            }

            foreach (uint title in titlesToDelete)
            {
                RemoveTitle(title);             
            }
        }

        public static void RemoveTitle(uint title)
        {
            string deleteTitle = String.Format("delete from t_titles where i_title_id={0}", title);
            TitleManagementWCFClient.ExecuteUODBScalar(deleteTitle);   
        }

        public static void CleanGroup(Group g)
        {
            BetaGroupEditor.NukeGroup(g.Summary.GroupGuid);
            string upgradeClear = String.Format("delete from t_title_versions where uid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());
            string relInfoClear = String.Format("delete from t_live_registry_settings where guid_beta_group_id='{0}'", g.Summary.GroupGuid.ToString());

            TitleManagementWCFClient.ExecuteUODBScalar(upgradeClear);
            ExecuteNPDBScalar(relInfoClear);
        }

        public static bool ValidateRelease(Guid group, string SOMRevision, string SMRevision, uint version)
        {
            string validateSOMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SOMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SOMRevision, group.ToString());
            string validateSMRevision = String.Format("select null from t_live_registry_settings where vc_setting='SMRevision' and vc_value='{0}' and guid_beta_group_id='{1}'", SMRevision, group.ToString());

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();

                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = validateSOMRevision;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Online Manifest Revision.  Expected: {1}", group, SOMRevision);
                        return false;
                    }
                }


                cmd.CommandText = validateSMRevision;
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!(reader.HasRows)) // No results
                    {
                        Global.RO.Error("Group {0} does not have the correct System Manifest Revision.  Expected: {1}", group, SMRevision);
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool ValidateUpgradeExists(UpgradePath path, Guid group)
        {
            string validateUpgradeQuery = "select null from t_title_versions where i_base_version={0} and i_update_version={1} and ti_console_type_id={2} and uid_beta_group_id='{3}'";


            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(String.Format(validateUpgradeQuery, path.BaseVersion, path.UpgradeVersion, (byte)path.ConsoleType, group.ToString()), conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                using (WstDataReader reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) // Title did not exist
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static bool ValidateUpdateIsUnique(uint version, Guid group)
        {
            string countUpdates = String.Format("select count(null) from t_title_versions where i_update_version={0} and uid_beta_group_id='{1}'", version, group.ToString());
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                WstCommand cmd = new WstCommand(countUpdates, conn, 0);
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                if ((int)cmd.ExecuteScalar() != 1) // More rows were added than we expect
                {
                    Global.RO.Error("There were multiple upgrade paths to the dash version 0x{0:X} for group {1}", version, group);
                    return false;
                }
            }
            return true;
        }

        public static bool InsertFlashVersionLocation(uint version)
        {
            string insertVersion = String.Format("insert into t_title_update_locations values (0xFFFE07D1, 0x1, {0}, 1, 'xrl:invalid', CURRENT_TIMESTAMP,2)", version);
            TitleManagementWCFClient.ExecuteUODBScalar(insertVersion);

            return true;
        }

        public static bool DeleteFlashVersionLocation(uint version)
        {
            string removeVersion = String.Format("delete from t_title_update_locations where i_title_id=0xFFFE07D1 and i_title_base_version=0x1 and i_title_update_version = {0}", version);
            TitleManagementWCFClient.ExecuteUODBScalar(removeVersion);

            return true;
        }

        public static void VerifyGroupMembership(System.Guid group, ConsoleInfo []expectedConsoles)
        {
            //convert the consoles to machine puids to do the actual verification
            List<ulong> expectedMachines=new List<ulong>();

            foreach (ConsoleInfo ci in expectedConsoles)
            {
                MachineEditor mach=MachineEditor.FromName(ci.ConsoleID, ci.SCode);
                expectedMachines.Add(mach.Id);
            }

            VerifyGroupMembership(group, expectedMachines.ToArray());
        }

        public static void VerifyGroupMembership(System.Guid group, ulong []expectedMachines)
        {
            BetaGroupEditor bge=BetaGroupEditor.FromId(group);
            ulong []actualMachines=bge.GetAllMachines();

            ValueCheck.TestAllUnordered("Group membership for "+group, expectedMachines, actualMachines);
        }

        public static ConsoleInfo MakeConsoleInfo(string consoleId, string scode)
        {
            ConsoleInfo ci=new ConsoleInfo();
            ci.ConsoleID=consoleId;
            ci.SCode=scode;
            return ci;
        }

        public static ConsoleInfo MakeConsoleInfo(MachineEditor mach)
        {
            ConsoleInfo ci=new ConsoleInfo();
            ci.ConsoleID=mach.ConsoleId;
            ci.SCode=mach.ComputeSCode();
            return ci;
        }

        public static void VerifyConsoleInfo(string message, ConsoleInfo expected, ConsoleInfo got)
        {
            if (expected==null && got==null)
            {
                return;
            }

            if ((expected!=null && got==null) || (expected==null && got!=null))
            {
                throw new UnexpectedTestResultException(message+": got "+got+", expected "+expected);
            }

            ValueCheck.Test(message+" ConsoleID", expected.ConsoleID, got.ConsoleID);
            ValueCheck.Test(message+" SCode", expected.SCode, got.SCode);
        }

        public static bool ConsoleInfoEquals(ConsoleInfo a, ConsoleInfo b)
        {
            if (a==null && b==null)
            {
                return true;
            }

            if ((a!=null && b==null) || (a==null && b!=null))
            {
                return false;
            }

            if (a.ConsoleID==b.ConsoleID && a.SCode==b.SCode)
            {
                return true;
            }

            return false;
        }

        public static string ConsoleInfoString(ConsoleInfo ci)
        {
            string s="";
            if (ci!=null)
            {
                s+="ConsoleID="+ci.ConsoleID;
                s+=" SCode="+ci.SCode;
            }
            return s;
        }

        public static void VerifyGroupMembershipChangeResult(GroupMembershipChangeResult []result, GroupMembershipChangeResult []expected)
        {
            if (result==null)
            {
                throw new UnexpectedTestResultException("Result was null.");
            }

            if (result.Length!=expected.Length)
            {
                throw new UnexpectedTestResultException("Got a different number of results("+result.Length+") than expected("+expected.Length+").");
            }

            for (int i=0; i<result.Length; ++i)
            {
                VerifyConsoleInfo("ConsoleInfo for index "+i, expected[i].ConsoleIDWithSCode, result[i].ConsoleIDWithSCode);

                if (expected[i].Outcome!=result[i].Outcome)
                {
                    throw new UnexpectedTestResultException("Reason for console "+expected[i].ConsoleIDWithSCode+": Expected "+expected[i].Outcome+", got "+result[i].Outcome);
                }

                if (expected[i].ConflictingGroups!=null && result[i].ConflictingGroups!=null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleIDWithSCode, expected[i].ConflictingGroups, result[i].ConflictingGroups);
                }
                else if ((expected[i].ConflictingGroups==null || expected[i].ConflictingGroups.Length==0) && (result[i].ConflictingGroups==null || result[i].ConflictingGroups.Length==0))
                {
                    //both empty are ok
                }
                else if (expected[i].ConflictingGroups==null)
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleIDWithSCode, new System.Guid[0], result[i].ConflictingGroups);
                }
                else //result[i].ConflictingGroups==null
                {
                    ValueCheck.TestAllUnordered("Conflicting groups for console "+result[i].ConsoleIDWithSCode, expected[i].ConflictingGroups, new System.Guid[0]);
                }
            }
        }

        public static GroupMembershipChangeResult[] BuildSuccessfulGroupMembershipChangeResult(ConsoleInfo []consoles)
        {
            GroupMembershipChangeResult []results=new GroupMembershipChangeResult[consoles.Length];
            for (int i=0; i<consoles.Length; ++i)
            {
                results[i]=new GroupMembershipChangeResult();
                results[i].ConsoleIDWithSCode=consoles[i];
                results[i].Outcome=GroupMembershipChangeOutcome.Success;
                results[i].ConflictingGroups=new System.Guid[0];
            }

            return results;
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, ConsoleInfo []consoles, GroupMembershipChangeOutcome reason)
        {
            ChangeGroupMembershipChangeResult(result, consoles, reason, new System.Guid[0]);
        }

        public static void ChangeGroupMembershipChangeResult(GroupMembershipChangeResult []result, ConsoleInfo []consoles, GroupMembershipChangeOutcome reason, IEnumerable<System.Guid> conflictingGroups)
        {
            foreach (ConsoleInfo console in consoles)
            {
                bool found=false;
                foreach (GroupMembershipChangeResult r in result)
                {
                    if (r.ConsoleIDWithSCode.ConsoleID==console.ConsoleID && r.ConsoleIDWithSCode.SCode==console.SCode)
                    {
                        r.Outcome=reason;

                        //r.ConflictingGroups=conflictingGroups; //this should work!  but the mix contract generated proxy is creating a type (Guid[]) that's different than the data contract definition (IEnumerable<Guid>).  For now just manually create an array from it...
                        int count=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            ++count;
                        }
                        r.ConflictingGroups=new System.Guid[count];
                        int i=0;
                        foreach (System.Guid cg in conflictingGroups)
                        {
                            r.ConflictingGroups[i]=cg;
                            ++i;
                        }

                        found=true;
                        //break; //in case of duplicates we want to change them all
                    }
                }

                if (!found)
                {
                    throw new System.Exception("Console "+console+" not found to change.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetConsoleInfosInGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using Utils=MixTest.BetaManagementUtilsV4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the GetConsoleInfosInGroup (beta group) API")]
    public class GetConsoleInfosInGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetConsoleInfosInGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Gets a list from a group with 1 member.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];
            MachineEditor mach=MachineEditor.CreateNew(mtype);


            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(bge.Id);

            Utils.VerifyGroupMembership(bge.Id, result);

            ValueCheck.Test("SCode in result", mach.ComputeSCode(), result[0].SCode);
        }

        [TestCase, TestCasePriority(1), Description("A legacy xbox360 is in a group.")]
        public void LegacyXbox360()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(MachineEditor.CreateLegacyXbox360().Id);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(bge.Id);

            Utils.VerifyGroupMembership(bge.Id, result);

            ValueCheck.Test("SCode in result", (string)null, result[0].SCode);
        }

        [TestCase, TestCasePriority(1), Description("Gets 1000 machines from a group.")]
        public void Get1000Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 1000 machines...");
            for (int i=0; i<1000; ++i)
            {
                bge.AddMachine(MachineEditor.CreateNew(MachineType.Xbox360).Id);
            }

            Global.RO.Debug("Running...");
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(bge.Id);

            Utils.VerifyGroupMembership(bge.Id, result);
        }

        [TestCase, TestCasePriority(1), Description("Get 0 machine from a group.")]
        public void GetNoMachines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(bge.Id);

            Utils.VerifyGroupMembership(bge.Id, result);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to get from the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(System.Guid.Empty);

            if (result!=null && result.Length!=0)
            {
                throw new UnexpectedTestResultException("Expected no consoles!");
            }
        }

        [TestCase, TestCasePriority(2), Description("Attempt to get from a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(System.Guid.NewGuid());

            if (result!=null && result.Length!=0)
            {
                throw new UnexpectedTestResultException("Expected no consoles!");
            }
        }

        [TestCase, TestCasePriority(1), Description("Attempt to get a consoleID that is shared by multiple machines from a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId()
        {
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            bge.AddMachine(machNormal0.Id);
            bge.AddMachine(machNormal1.Id);
            bge.AddMachine(machDupe0.Id);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            BetaV4.ConsoleInfo []result=client.GetConsoleInfosInGroup(bge.Id);

            Utils.VerifyGroupMembership(bge.Id, result);

            foreach (BetaV4.ConsoleInfo r in result)
            {
                if (r.SCode==null || r.SCode=="")
                {
                    throw new UnexpectedTestResultException("A null SCode was unexpectedly returned.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\CreateGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the CreateGroup (beta group) API")]
    public class CreateGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.CreateGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case.")]
        public void SimpleMainline()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name;

            //call API and verify return value is sane
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            System.Guid group=client.CreateGroup(randomName, creator);

            if (group==System.Guid.Empty)
            {
                throw new UnexpectedTestResultException("Did not expect an empty guid back.");
            }

            //verify the result with the DB
            BetaGroupEditor bge=BetaGroupEditor.FromId(group);
            ValueCheck.Test("Group exists in DB", true, bge.Exists);
            ValueCheck.Test("Group name in DB", randomName, bge.Name);
            ValueCheck.Test("Group creator in DB", creator, bge.Creator);
            ValueCheck.Test("Group creation time in DB", System.DateTime.UtcNow, bge.Created, new System.TimeSpan(0, 5, 0)); //within 5 minutes

            if (bge.HashBucket==0)
            {
                throw new UnexpectedTestResultException("Hash bucket in DB for the group is 0.");
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the name parameter.")]
        public void NullName()
        {
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            client.CreateGroup(null, creator);
        }

        [TestCase, TestCasePriority(2), Description("Pass an empty string for the name parameter.")]
        public void EmptyName()
        {
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_INVALID_GROUP_NAME;
            client.CreateGroup("", creator);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the creator parameter.")]
        public void NullCreator()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            client.CreateGroup(randomName, null);
        }

        [TestCase, TestCasePriority(2), Description("Pass an empty string for the creator parameter.")]
        public void EmptyCreator()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_INVALID_GROUP_CREATOR;
            client.CreateGroup(randomName, "");
        }

        [TestCase, TestCasePriority(1), Description("Attempt to create a group with a name that already exists.")]
        public void NameAlreadyExists()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name;

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.Name=randomName;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_DUPLICATE_GROUP_NAME_NOT_ALLOWED;
;
            client.CreateGroup(randomName, creator);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to create a group with a name that is too long to store in the DB.")]
        public void NameTooLong()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(500);
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_INVALID_GROUP_NAME;
            client.CreateGroup(randomName, creator);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to create a group with a creator that is too long to store in the DB.")]
        public void CreatorTooLong()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);
            string creator=System.Security.Principal.WindowsIdentity.GetCurrent().Name + "creating group" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(500);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_INVALID_GROUP_CREATOR;
            client.CreateGroup(randomName, creator);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroups.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V4;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class GetGroups : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroups");
        }


        static BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();

        [TestCase, TestCasePriority(1)]
        class P_GetGroups_1 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(1);
            }
        }


        [TestCase]
        class P_GetGroups_2 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(2);
            }
        }


        [TestCase]
        class P_GetGroups_3 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(3);
            }
        }


        [TestCase, TestCasePriority(1)]
        class P_GetGroups_10 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(10);
            }
        }


        [TestCase]
        class P_GetGroups_Random : WCFTestBase
        {
            public override void Run()
            {
                TestGroups((new Random()).Next() % 32);
            }
        }


        static void TestGroups(int i)
        {
            List<Group> groups = BetaManagementUtilsV4.CreateFakeGroups(1);
            List<uint> titlesToDelete = new List<uint>();
            BetaManagementUtilsV4.AddFakeGroups(groups, ref titlesToDelete);
            bool passed = true;
            try
            {
                GroupSummary[] foundGroups = client.GetGroups();
                foreach (Group g in groups)
                {
                    bool foundGroup = false;
                    foreach (GroupSummary gs in foundGroups)
                    {
                        if (gs.GroupGuid == g.Summary.GroupGuid)
                        {
                            if (gs.Equals(g.Summary))
                            {
                                Global.RO.Error("Group {0} did not have matching fields with the group returned by GetGroups.", g.Summary.GroupGuid);
                                passed = false;
                            }

                            foundGroup = true;
                            break;
                        }
                    }
                    if (!foundGroup)
                    {
                        Global.RO.Error("Group {0} was not found in the returned groups.", g.Summary.GroupGuid);
                        passed = false;
                    }
                }
            }
            finally
            {
                BetaManagementUtilsV4.CleanGroups(new List<Group>(groups), titlesToDelete);
            }

            if (!passed)
            {
                throw new UnexpectedTestResultException("Group verification failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroupsV1.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V1;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class GetGroupsV1 : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroups");
        }


        static BetaManagementWCFClient client = new BetaManagementWCFClient();

        [TestCase, TestCasePriority(1)]
        class P_GetGroups_1 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(1);
            }
        }


        [TestCase]
        class P_GetGroups_2 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(2);
            }
        }


        [TestCase]
        class P_GetGroups_3 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(3);
            }
        }


        [TestCase, TestCasePriority(1)]
        class P_GetGroups_10 : WCFTestBase
        {
            public override void Run()
            {
                TestGroups(10);
            }
        }


        [TestCase]
        class P_GetGroups_Random : WCFTestBase
        {
            public override void Run()
            {
                TestGroups((new Random()).Next() % 32);
            }
        }


        static void TestGroups(int i)
        {
            List<Group> groups = BetaManagementUtils.CreateFakeGroups(1);
            List<uint> titlesToDelete = new List<uint>();
            BetaManagementUtils.AddFakeGroups(groups, ref titlesToDelete);
            bool passed = true;
            try
            {
                GroupSummary[] foundGroups = client.GetGroups();
                foreach (Group g in groups)
                {
                    bool foundGroup = false;
                    foreach (GroupSummary gs in foundGroups)
                    {
                        if (gs.GroupGuid == g.Summary.GroupGuid)
                        {
                            if (gs.Equals(g.Summary))
                            {
                                Global.RO.Error("Group {0} did not have matching fields with the group returned by GetGroups.", g.Summary.GroupGuid);
                                passed = false;
                            }

                            foundGroup = true;
                            break;
                        }
                    }
                    if (!foundGroup)
                    {
                        Global.RO.Error("Group {0} was not found in the returned groups.", g.Summary.GroupGuid);
                        passed = false;
                    }
                }
            }
            finally
            {
                BetaManagementUtils.CleanGroups(new List<Group>(groups), titlesToDelete);
            }

            if (!passed)
            {
                throw new UnexpectedTestResultException("Group verification failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroupDetails.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V4;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class GetGroupDetails : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroupDetails");
        }


        static BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();


        [TestCase, TestCasePriority(1)]
        class P_GetGroupDetails_Random : WCFTestBase
        {
            public override void Run()
            {
                TestGroupDetails((new Random()).Next() % 32);
            }
        }

        [TestCase]
        class P_GetGroupDetails_NullGuid : WCFTestBase
        {
            public override void Run()
            {
                client.GetGroupDetails(Guid.Empty);
            }
        }

        public static void TestGroupDetails(int i)
        {
            List<Group> groups = BetaManagementUtilsV4.CreateFakeGroups(i);
            List<uint> titlesToDelete = new List<uint>();
            BetaManagementUtilsV4.AddFakeGroups(groups, ref titlesToDelete);
            bool passed = true;
            try
            {
                foreach (Group g in groups)
                {
                    Group received = client.GetGroupDetails(g.Summary.GroupGuid);
                    if (!GroupEquals(g, received))
                    {
                        Global.RO.Error("Group {0} did not have matching fields with the group returned by GetGroupDetails.", g.Summary.GroupGuid);
                        passed = false;
                    }
                }
            }
            finally
            {
                BetaManagementUtilsV4.CleanGroups(new List<Group>(groups), titlesToDelete);
            }

            if (!passed)
            {
                throw new UnexpectedTestResultException("Group verification failed.");
            }
        }

        private static bool GroupEquals(Group g,Group received)
        {
            if ((g.FlashVersion / 0x100) % 0x10000 != received.FlashVersion) return false;
            if (!g.Summary.Creator.Equals(received.Summary.Creator)) return false;
            if (g.Summary.GroupGuid != received.Summary.GroupGuid) return false;
            if (!g.Summary.Name.Equals(received.Summary.Name)) return false;
            if (Array.Equals(g.RelInfos, received.RelInfos)) return false;
            if (Array.Equals(g.Titles, received.Titles)) return false;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroupsForConsoleIDsV3.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV3=xonline.mix.betamanagement.contracts.V3;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the GetGroupsForConsoleIDs (beta group) API")]
    [CompoundCase("Xbox360", MachineType.Xbox360)]
    [CompoundCase("PC", MachineType.PC)]
    [CompoundCase("Phone", MachineType.Phone)]
    public class GetGroupsForConsoleIDsV3: TestNode
    {
        public override void OneTimeSetup()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroupsForConsoleIDs");
        }

        //delete the Duplicates test group for every child except Xbox360
        protected override void PostProcessBranchConstruction()
        {
            if (Name=="GetGroupsForConsoleIDs") //don't run for the child instances
            {
                foreach (TestNode child in Children)
                {
                    if (child.Name!="Xbox360")
                    {
                        ((GetGroupsForConsoleIDsV3)child).RemoveDuplicateGroupNode();
                    }
                }
            }
        }

        protected void RemoveDuplicateGroupNode()
        {
            foreach (TestNode child in Children)
            {
                if (child is DuplicateConsoles)
                {
                    RemoveChild(child);
                    break;
                }
            }
        }

        //
        [Flags]
        public enum ConsoleState
        {
            // these are the high level state
            DoesNotExist = 0x1,
            NoGroup = 0x2,
            Grouped = 0x4,
            GroupDoesNotExist = 0x8,
            StateOnly = DoesNotExist | NoGroup | Grouped | GroupDoesNotExist,

            // these are the groups that apply if Grouped is set
            Group0 = 0x100,
            InGroup0 = Grouped | Group0,
            Group1 = 0x200,
            InGroup1 = Grouped | Group1,
            Group2 = 0x400,
            InGroup2 = Grouped | Group2,
            AllGroups = Group0 | Group1 | Group2
        }

        public const int GroupsCount = 3;
        public static Dictionary<ConsoleState, BetaGroupEditor> Groups = null;

        public static Guid NonGroup;

        public override void PreRun ()
        {
            CreateContextData();
            SetContextData("Platform", (MachineType)MyValues[0]);

            Groups = new Dictionary<ConsoleState, BetaGroupEditor>();

            for (int i = 0; i < GroupsCount; ++i)
            {
                Groups.Add((ConsoleState)(((int)ConsoleState.Group0) << i), BetaGroupEditor.CreateNew());
            }

            NonGroup = Guid.NewGuid();
        }

        /// <summary>
        /// Creates a console based on the given state.
        /// </summary>
        public static string CreateConsole (ConsoleState state, MachineType mtype)
        {
            string ans = null;

            switch (state & ConsoleState.StateOnly)
            {
                case ConsoleState.DoesNotExist:
                    ans = MachineEditor.GenerateRandomConsoleID(mtype);
                    break;

                case ConsoleState.NoGroup:
                    ans = MachineEditor.CreateNew(mtype).ConsoleId;
                    break;

                case ConsoleState.Grouped:
                    {
                        MachineEditor me = MachineEditor.CreateNew(mtype);
                        BetaGroupEditor bge = Groups[state & ConsoleState.AllGroups];
                        bge.AddMachine(me.Id);
                        ans = me.ConsoleId;
                    }
                    break;

                case ConsoleState.GroupDoesNotExist:
                    {
                        MachineEditor me = MachineEditor.CreateNew(mtype);
                        BetaGroupEditor bge = BetaGroupEditor.FromId(NonGroup);
                        bge.AddMachine(me.Id);
                        ans = me.ConsoleId;
                    }
                    break;
            }

            return ans;
        }

        public static void ExecuteValidate (string[] consoleIds, ConsoleState[] states)
        {
            ExecuteValidate(consoleIds, states, HResult.S_OK);
        }

        public static void ExecuteValidate (string[] consoleIds, ConsoleState[] states, uint hr)
        {
            BetaManagementV3WCFClient client = new BetaManagementV3WCFClient();
            client.ExpectedHR = hr;

            BetaV3.GroupSummaryForConsole[] results = client.GetGroupsForConsoleIDs(consoleIds);

            if (hr == HResult.S_OK)
            {
                ValueCheck.Test("Result count", consoleIds.Length, results.Length);

                for (int i = 0; i < consoleIds.Length; ++i)
                {
                    string consoleId = consoleIds[i];
                    ConsoleState state = states[i];
                    BetaV3.GroupSummaryForConsole result = results[i];

                    ValueCheck.Test("ConsoleId." + i, consoleId, result.ConsoleID);

                    switch (state & ConsoleState.StateOnly)
                    {
                        case ConsoleState.DoesNotExist:
                            ValueCheck.Test("Outcome." + i, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist, result.Outcome);
                            break;

                        case ConsoleState.NoGroup:
                            ValueCheck.Test("Outcome." + i, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup, result.Outcome);
                            break;

                        // per bug X360CS 142462, this is the result
                        case ConsoleState.Grouped:
                        case ConsoleState.GroupDoesNotExist:
                            ValueCheck.Test("Outcome." + i, BetaV3.GroupMembershipChangeOutcome.Success, result.Outcome);
                            break;
                    }

                    switch (state & ConsoleState.StateOnly)
                    {
                        case ConsoleState.DoesNotExist:
                        case ConsoleState.NoGroup:
                            ValueCheck.Test("GroupsCount." + i, 0, result.Groups.Length);
                            break;

                        // per bug X360CS 142462, this is the result
                        case ConsoleState.GroupDoesNotExist:
                            {
                                ValueCheck.Test("GroupsCount." + i, 1, result.Groups.Length);
                                ValueCheck.Test("GroupsGuid." + i, NonGroup, result.Groups[0].GroupGuid);
                                ValueCheck.Test("GroupsName." + i, "", result.Groups[0].Name);
                                ValueCheck.Test("GroupsCreator." + i, "", result.Groups[0].Creator);
                                ValueCheck.Test("GroupsCreated." + i, DateTime.MinValue, result.Groups[0].Created);
                            }
                            break;

                        case ConsoleState.Grouped:
                            {
                                ValueCheck.Test("GroupsCount." + i, 1, result.Groups.Length);

                                BetaGroupEditor bge = Groups[state & ConsoleState.AllGroups];
                                ValueCheck.Test("GroupsGuid." + i, bge.Id, result.Groups[0].GroupGuid);
                                ValueCheck.Test("GroupsName." + i, bge.Name, result.Groups[0].Name);
                                ValueCheck.Test("GroupsCreator." + i, bge.Creator, result.Groups[0].Creator);
                                ValueCheck.Test("GroupsCreated." + i, bge.Created, result.Groups[0].Created);
                            }
                            break;
                    }
                }
            }
        }

        [TestCase, TestCasePriority(1), Description("Mainline case that sends a single good console.")]
        public class Mainline : TestNode
        {
            public override void Run()
            {
                MachineType mtype = (MachineType)GetContextData("Platform");
                ExecuteValidate(new string[]{ CreateConsole(ConsoleState.InGroup0, mtype) }, new ConsoleState[]{ ConsoleState.InGroup0 });
            }
        }

        public class StateListBase : TestNode
        {
            public override void Run()
            {
                MachineType mtype = (MachineType)GetContextData("Platform");
                string[] consoleIds = new string[MyValues.Length];
                ConsoleState[] states = new ConsoleState[MyValues.Length];

                for (int i = 0; i < MyValues.Length; ++i)
                {
                    states[i] = (ConsoleState)MyValues[i];
                    consoleIds[i] = CreateConsole(states[i], mtype);
                }

                ExecuteValidate(consoleIds, states);
            }
        }

        [TestCase, TestCasePriority(2), Description("Consoles in states other than in the mainline group.")]
        [CompoundCase("{0}", ConsoleState.InGroup1)]
        [CompoundCase("{0}", ConsoleState.InGroup2)]
        [CompoundCase("{0}", ConsoleState.DoesNotExist)]
        [CompoundCase("{0}", ConsoleState.NoGroup)]
        [CompoundCase("{0}", ConsoleState.GroupDoesNotExist)]
        public class States : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Console pairs.")]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup0, ConsoleState.InGroup0)]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup2, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.InGroup0)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.InGroup2)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.NoGroup)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.GroupDoesNotExist)]
        public class Pairs : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Larger lists of consoles.")]
        [CompoundCase("GroupCache_2", ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup1, ConsoleState.InGroup2, 
            ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("GroupCache_3", ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup0,
            ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("Everything", ConsoleState.InGroup1, ConsoleState.NoGroup, ConsoleState.GroupDoesNotExist, ConsoleState.InGroup0,
            ConsoleState.DoesNotExist, ConsoleState.InGroup2, ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2)]
        public class Lists : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Console list has many entries.")]
        [CompoundCase("{0}", 20)]
        [CompoundCase("{0}", 100)]
        [CompoundCase("{0}", 500)]
        [CompoundCase("{0}", 1000)]
        public class LargeConsoleList : TestNode
        {
            public override void Run()
            {
                int count = (int)MyValues[0];
                string[] consoleIds = new string[count];
                ConsoleState[] states = new ConsoleState[count];

                for (int i = 0; i < count; ++i)
                {
                    consoleIds[i] = MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                    states[i] = ConsoleState.DoesNotExist;
                }

                ExecuteValidate(consoleIds, states);
            }
        }

        [TestGroup, Description("Tests for duplicate Xbox360 consoles.")]
        public class DuplicateConsoles : TestNode
        {
            [TestCase]
            public void BothInGroup()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge.AddMachine(mach0.Id);
                bge.AddMachine(mach1.Id);

                BetaV3.GroupSummaryForConsole[] results = new BetaManagementV3WCFClient().GetGroupsForConsoleIDs(new string[]{mach0.ConsoleId});

                //verify.  note that each actual machine will have a result in the event that more than one machine share a console id
                ValueCheck.Test("Number of results returned", 2, results.Length);

                foreach (BetaV3.GroupSummaryForConsole r in results)
                {
                    ValueCheck.Test("Console ID in result", mach0.ConsoleId, r.ConsoleID);
                    ValueCheck.Test("Result outcome", BetaV3.GroupMembershipChangeOutcome.Success, r.Outcome);
                    ValueCheck.TestDifferent("ResultGroups", (BetaV3.GroupSummary[])null, r.Groups);
                    ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);
                    ValueCheck.Test("Group in result", bge.Id, r.Groups[0].GroupGuid);
                }
            }

            [TestCase]
            public void OneInGroupOneInOtherGroup()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge0 = BetaGroupEditor.CreateNew();
                BetaGroupEditor bge1 = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge0.AddMachine(mach0.Id);
                bge1.AddMachine(mach1.Id);

                BetaV3.GroupSummaryForConsole[] results = new BetaManagementV3WCFClient().GetGroupsForConsoleIDs(new string[]{mach0.ConsoleId});

                //verify.  note that each actual machine will have a result in the event that more than one machine share a console id
                ValueCheck.Test("Number of results returned", 2, results.Length);

                int countInGroup0 = 0;
                int countInGroup1 = 0;

                foreach (BetaV3.GroupSummaryForConsole r in results)
                {
                    ValueCheck.Test("Console ID in result", mach0.ConsoleId, r.ConsoleID);
                    ValueCheck.Test("Result outcome", BetaV3.GroupMembershipChangeOutcome.Success, r.Outcome);
                    ValueCheck.TestDifferent("ResultGroups", (BetaV3.GroupSummary[])null, r.Groups);
                    ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);

                    if (r.Groups[0].GroupGuid == bge0.Id)
                    {
                        ++countInGroup0;
                    }
                    else if (r.Groups[0].GroupGuid == bge1.Id)
                    {
                        ++countInGroup1;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Unexpected group guid in result: "+r.Groups[0].GroupGuid);
                    }
                }

                ValueCheck.Test("Number of results for group 0", 1, countInGroup0);
                ValueCheck.Test("Number of results for group 1", 1, countInGroup1);
            }

            [TestCase]
            public void OneInGroupOneInNoGroup()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge0 = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge0.AddMachine(mach0.Id);

                BetaV3.GroupSummaryForConsole[] results = new BetaManagementV3WCFClient().GetGroupsForConsoleIDs(new string[]{mach0.ConsoleId});

                //verify.  note that each actual machine will have a result in the event that more than one machine share a console id
                ValueCheck.Test("Number of results returned", 2, results.Length);

                int countInGroup0 = 0;
                int countInNoGroup = 0;

                foreach (BetaV3.GroupSummaryForConsole r in results)
                {
                    ValueCheck.Test("Console ID in result", mach0.ConsoleId, r.ConsoleID);
                    ValueCheck.TestDifferent("ResultGroups", (BetaV3.GroupSummary[])null, r.Groups);

                    if (r.Outcome == BetaV3.GroupMembershipChangeOutcome.Success)
                    {
                        ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);

                        if (r.Groups[0].GroupGuid == bge0.Id)
                        {
                            ++countInGroup0;
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Unexpected group guid in result: "+r.Groups[0].GroupGuid);
                        }
                    }
                    else if (r.Outcome == BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup)
                    {
                        ++countInNoGroup;

                        ValueCheck.Test("Number of groups in result", 0, r.Groups.Length);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Unexpected outcome in result: "+r.Outcome);
                    }
                }

                ValueCheck.Test("Number of results for group 0", 1, countInGroup0);
                ValueCheck.Test("Number of results in no group", 1, countInNoGroup);
            }
        };

        [TestGroup, TestCasePriority(3), Description("Negative cases.")]
        public class Negative : TestNode
        {
            [TestCase, Description("Console list is null.")]
            public class NullConsoleList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(null, null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list is empty.")]
            public class EmptyConsoleList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new string[0], null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list has a null value.")]
            public class NullConsoleInList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new string[1]{ null }, null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list has non-consoles.")]
            [CompoundCase("Empty", "")]
            [CompoundCase("Number", "1")]
            [CompoundCase("Random", "zd8yfwerzfdx")]
            [CompoundCase("Large", "sp9o87r6y238dhf87324yrqfguj97fj3r63856fq28f2rty6987346jy9560o87wq3y65f8747")]
            public class GarbageConsole : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new string[]{ (string)MyValues[0] }, new ConsoleState[]{ ConsoleState.DoesNotExist });
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroupsForConsoleInfos.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using Utils=MixTest.BetaManagementUtilsV4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the GetGroupsForConsoleInfos (beta group) API")]
    [CompoundCase("Xbox360", MachineType.Xbox360)]
    [CompoundCase("PC", MachineType.PC)]
    [CompoundCase("Phone", MachineType.Phone)]
    public class GetGroupsForConsoleInfos: TestNode
    {
        public override void OneTimeSetup()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroupsForConsoleInfos");
        }

        //delete the Duplicates test group for every child except Xbox360
        protected override void PostProcessBranchConstruction()
        {
            if (Name == "GetGroupsForConsoleInfos") //don't run for the child instances
            {
                foreach (TestNode child in Children)
                {
                    if (child.Name != "Xbox360")
                    {
                        ((GetGroupsForConsoleInfos)child).RemoveNonXbox360Nodes();
                    }
                }
            }
        }

        protected void RemoveNonXbox360Nodes()
        {
            for (;;)
            {
                bool anyChanged = false;
                foreach (TestNode child in Children)
                {
                    if (child is DuplicateConsoles || child is LegacyXbox360)
                    {
                        RemoveChild(child);
                        anyChanged = true;
                        break;
                    }
                }

                if (!anyChanged)
                {
                    break;
                }
            }
        }

        //
        [Flags]
        public enum ConsoleState
        {
            // these are the high level state
            DoesNotExist = 0x1,
            NoGroup = 0x2,
            Grouped = 0x4,
            GroupDoesNotExist = 0x8,
            StateOnly = DoesNotExist | NoGroup | Grouped | GroupDoesNotExist,

            // these are the groups that apply if Grouped is set
            Group0 = 0x100,
            InGroup0 = Grouped | Group0,
            Group1 = 0x200,
            InGroup1 = Grouped | Group1,
            Group2 = 0x400,
            InGroup2 = Grouped | Group2,
            AllGroups = Group0 | Group1 | Group2
        }

        public const int GroupsCount = 3;
        public static Dictionary<ConsoleState, BetaGroupEditor> Groups = null;

        public static Guid NonGroup;

        public override void PreRun ()
        {
            CreateContextData();
            SetContextData("Platform", (MachineType)MyValues[0]);

            Groups = new Dictionary<ConsoleState, BetaGroupEditor>();

            for (int i = 0; i < GroupsCount; ++i)
            {
                Groups.Add((ConsoleState)(((int)ConsoleState.Group0) << i), BetaGroupEditor.CreateNew());
            }

            NonGroup = Guid.NewGuid();
        }

        /// <summary>
        /// Creates a console based on the given state.
        /// </summary>
        public static BetaV4.ConsoleInfo CreateConsole (ConsoleState state, MachineType mtype)
        {
            BetaV4.ConsoleInfo ans = null;

            switch (state & ConsoleState.StateOnly)
            {
                case ConsoleState.DoesNotExist:
                    ans = Utils.MakeConsoleInfo(MachineEditor.GenerateRandomConsoleID(mtype), "0000-0000-0000-0000");
                    break;

                case ConsoleState.NoGroup:
                    ans = Utils.MakeConsoleInfo(MachineEditor.CreateNew(mtype));
                    break;

                case ConsoleState.Grouped:
                    {
                        MachineEditor me = MachineEditor.CreateNew(mtype);
                        BetaGroupEditor bge = Groups[state & ConsoleState.AllGroups];
                        bge.AddMachine(me.Id);
                        ans = Utils.MakeConsoleInfo(me);
                    }
                    break;

                case ConsoleState.GroupDoesNotExist:
                    {
                        MachineEditor me = MachineEditor.CreateNew(mtype);
                        BetaGroupEditor bge = BetaGroupEditor.FromId(NonGroup);
                        bge.AddMachine(me.Id);
                        ans = Utils.MakeConsoleInfo(me);
                    }
                    break;
            }

            return ans;
        }

        public static void ExecuteValidate (BetaV4.ConsoleInfo[] consoleIds, ConsoleState[] states)
        {
            ExecuteValidate(consoleIds, states, HResult.S_OK);
        }

        public static void ExecuteValidate (BetaV4.ConsoleInfo[] consoleIds, ConsoleState[] states, uint hr)
        {
            BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();
            client.ExpectedHR = hr;

            BetaV4.GroupSummaryForConsole[] results = client.GetGroupsForConsoleInfos(consoleIds);

            if (hr == HResult.S_OK)
            {
                ValueCheck.Test("Result count", consoleIds.Length, results.Length);

                for (int i = 0; i < consoleIds.Length; ++i)
                {
                    ConsoleState state = states[i];
                    BetaV4.GroupSummaryForConsole result = results[i];

                    Utils.VerifyConsoleInfo("ConsoleId." + i, consoleIds[i], result.ConsoleIDWithSCode);

                    switch (state & ConsoleState.StateOnly)
                    {
                        case ConsoleState.DoesNotExist:
                            ValueCheck.Test("Outcome." + i, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist, result.Outcome);
                            break;

                        case ConsoleState.NoGroup:
                            ValueCheck.Test("Outcome." + i, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup, result.Outcome);
                            break;

                        // per bug X360CS 142462, this is the result
                        case ConsoleState.Grouped:
                        case ConsoleState.GroupDoesNotExist:
                            ValueCheck.Test("Outcome." + i, BetaV4.GroupMembershipChangeOutcome.Success, result.Outcome);
                            break;
                    }

                    switch (state & ConsoleState.StateOnly)
                    {
                        case ConsoleState.DoesNotExist:
                        case ConsoleState.NoGroup:
                            ValueCheck.Test("GroupsCount." + i, 0, result.Groups.Length);
                            break;

                        // per bug X360CS 142462, this is the result
                        case ConsoleState.GroupDoesNotExist:
                            {
                                ValueCheck.Test("GroupsCount." + i, 1, result.Groups.Length);
                                ValueCheck.Test("GroupsGuid." + i, NonGroup, result.Groups[0].GroupGuid);
                                ValueCheck.Test("GroupsName." + i, "", result.Groups[0].Name);
                                ValueCheck.Test("GroupsCreator." + i, "", result.Groups[0].Creator);
                                ValueCheck.Test("GroupsCreated." + i, DateTime.MinValue, result.Groups[0].Created);
                            }
                            break;

                        case ConsoleState.Grouped:
                            {
                                ValueCheck.Test("GroupsCount." + i, 1, result.Groups.Length);

                                BetaGroupEditor bge = Groups[state & ConsoleState.AllGroups];
                                ValueCheck.Test("GroupsGuid." + i, bge.Id, result.Groups[0].GroupGuid);
                                ValueCheck.Test("GroupsName." + i, bge.Name, result.Groups[0].Name);
                                ValueCheck.Test("GroupsCreator." + i, bge.Creator, result.Groups[0].Creator);
                                ValueCheck.Test("GroupsCreated." + i, bge.Created, result.Groups[0].Created);
                            }
                            break;
                    }
                }
            }
        }

        [TestCase, TestCasePriority(1), Description("Mainline case that sends a single good console.")]
        public class Mainline : TestNode
        {
            public override void Run()
            {
                MachineType mtype = (MachineType)GetContextData("Platform");
                ExecuteValidate(new BetaV4.ConsoleInfo[]{ CreateConsole(ConsoleState.InGroup0, mtype) }, new ConsoleState[]{ ConsoleState.InGroup0 });
            }
        }

        public class StateListBase : TestNode
        {
            public override void Run()
            {
                MachineType mtype = (MachineType)GetContextData("Platform");
                BetaV4.ConsoleInfo[] consoleIds = new BetaV4.ConsoleInfo[MyValues.Length];
                ConsoleState[] states = new ConsoleState[MyValues.Length];

                for (int i = 0; i < MyValues.Length; ++i)
                {
                    states[i] = (ConsoleState)MyValues[i];
                    consoleIds[i] = CreateConsole(states[i], mtype);
                }

                ExecuteValidate(consoleIds, states);
            }
        }

        [TestCase, TestCasePriority(2), Description("Consoles in states other than in the mainline group.")]
        [CompoundCase("{0}", ConsoleState.InGroup1)]
        [CompoundCase("{0}", ConsoleState.InGroup2)]
        [CompoundCase("{0}", ConsoleState.DoesNotExist)]
        [CompoundCase("{0}", ConsoleState.NoGroup)]
        [CompoundCase("{0}", ConsoleState.GroupDoesNotExist)]
        public class States : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Console pairs.")]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup0, ConsoleState.InGroup0)]
        [CompoundCase("{0}_{1}", ConsoleState.InGroup2, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.InGroup0)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.InGroup2)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.DoesNotExist)]
        [CompoundCase("{0}_{1}", ConsoleState.NoGroup, ConsoleState.NoGroup)]
        [CompoundCase("{0}_{1}", ConsoleState.GroupDoesNotExist, ConsoleState.GroupDoesNotExist)]
        public class Pairs : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Larger lists of consoles.")]
        [CompoundCase("GroupCache_2", ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup1, ConsoleState.InGroup2, 
            ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("GroupCache_3", ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup0,
            ConsoleState.InGroup1, ConsoleState.InGroup2, ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2)]
        [CompoundCase("Everything", ConsoleState.InGroup1, ConsoleState.NoGroup, ConsoleState.GroupDoesNotExist, ConsoleState.InGroup0,
            ConsoleState.DoesNotExist, ConsoleState.InGroup2, ConsoleState.InGroup0, ConsoleState.InGroup1, ConsoleState.InGroup2)]
        public class Lists : StateListBase
        {
        }

        [TestCase, TestCasePriority(2), Description("Console list has many entries.")]
        [CompoundCase("{0}", 20)]
        [CompoundCase("{0}", 100)]
        [CompoundCase("{0}", 500)]
        public class LargeConsoleList : TestNode
        {
            public override void Run()
            {
                int count = (int)MyValues[0];
                BetaV4.ConsoleInfo[] consoleIds = new BetaV4.ConsoleInfo[count];
                ConsoleState[] states = new ConsoleState[count];

                for (int i = 0; i < count; ++i)
                {
                    consoleIds[i] = Utils.MakeConsoleInfo(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360), "0000-0000-0000-0000");
                    states[i] = ConsoleState.DoesNotExist;
                }

                ExecuteValidate(consoleIds, states);
            }
        }

        [TestGroup, Description("Tests for duplicate Xbox360 consoles.")]
        public class DuplicateConsoles : TestNode
        {
            [TestCase]
            public void BothInGroup_NoSCode()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge.AddMachine(mach0.Id);
                bge.AddMachine(mach1.Id);

                BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0.ConsoleId, null)};
                BetaV4.GroupSummaryForConsole[] results = new BetaManagementV4WCFClient().GetGroupsForConsoleInfos(consoles);

                //verify.  note that each actual machine will have a result in the event that more than one machine share a console id
                ValueCheck.Test("Number of results returned", 2, results.Length);

                //Unfortunately the order is not deterministic, so a trivial check here is not possible.  Instead verify that everything is correct except for the SCodes, then verify that both SCodes are present.
                bool mach0SCodeIsPresent = false;
                bool mach1SCodeIsPresent = false;
                foreach (BetaV4.GroupSummaryForConsole r in results)
                {
                    ValueCheck.Test("ConsoleID is result", mach0.ConsoleId, r.ConsoleIDWithSCode.ConsoleID);
                    if (r.ConsoleIDWithSCode.SCode == mach0.ComputeSCode())
                    {
                        mach0SCodeIsPresent = true;
                    }
                    if (r.ConsoleIDWithSCode.SCode == mach1.ComputeSCode())
                    {
                        mach1SCodeIsPresent = true;
                    }

                    ValueCheck.Test("Result outcome", BetaV4.GroupMembershipChangeOutcome.Success, r.Outcome);
                    ValueCheck.TestDifferent("ResultGroups", (BetaV4.GroupSummary[])null, r.Groups);
                    ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);
                    ValueCheck.Test("Group in result", bge.Id, r.Groups[0].GroupGuid);
                }

                if (!mach0SCodeIsPresent)
                {
                    throw new UnexpectedTestResultException("Machine0's SCode was not found in the results.");
                }

                if (!mach1SCodeIsPresent)
                {
                    throw new UnexpectedTestResultException("Machine1's SCode was not found in the results.");
                }
            }

            [TestCase]
            public void BothInGroup_WithSCode()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge.AddMachine(mach0.Id);
                bge.AddMachine(mach1.Id);

                BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
                BetaV4.GroupSummaryForConsole[] results = new BetaManagementV4WCFClient().GetGroupsForConsoleInfos(consoles);

                //verify
                ValueCheck.Test("Number of results returned", 1, results.Length);

                BetaV4.GroupSummaryForConsole r = results[0];
                Utils.VerifyConsoleInfo("Console in result", consoles[0], r.ConsoleIDWithSCode);
                ValueCheck.Test("Result outcome", BetaV4.GroupMembershipChangeOutcome.Success, r.Outcome);
                ValueCheck.TestDifferent("ResultGroups", (BetaV4.GroupSummary[])null, r.Groups);
                ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);
                ValueCheck.Test("Group in result", bge.Id, r.Groups[0].GroupGuid);
            }

            [TestCase]
            public void OneInGroupOneInOtherGroup()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge0 = BetaGroupEditor.CreateNew();
                BetaGroupEditor bge1 = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor mach1 = MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge0.AddMachine(mach0.Id);
                bge1.AddMachine(mach1.Id);

                BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
                BetaV4.GroupSummaryForConsole[] results = new BetaManagementV4WCFClient().GetGroupsForConsoleInfos(consoles);

                //verify
                ValueCheck.Test("Number of results returned", 1, results.Length);

                BetaV4.GroupSummaryForConsole r = results[0];
                Utils.VerifyConsoleInfo("Console in result", consoles[0], r.ConsoleIDWithSCode);
                ValueCheck.Test("Result outcome", BetaV4.GroupMembershipChangeOutcome.Success, r.Outcome);
                ValueCheck.TestDifferent("ResultGroups", (BetaV4.GroupSummary[])null, r.Groups);
                ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);
                ValueCheck.Test("Group in result", bge0.Id, r.Groups[0].GroupGuid);
            }
        };

        [TestCase]
        public class LegacyXbox360: TestNode
        {
            public override void Run()
            {
                //create machines and groups then call the api
                BetaGroupEditor bge = BetaGroupEditor.CreateNew();
                MachineEditor mach0 = MachineEditor.CreateLegacyXbox360();

                bge.AddMachine(mach0.Id);

                BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
                BetaV4.GroupSummaryForConsole[] results = new BetaManagementV4WCFClient().GetGroupsForConsoleInfos(consoles);

                //verify
                ValueCheck.Test("Number of results returned", 1, results.Length);

                BetaV4.GroupSummaryForConsole r = results[0];
                Utils.VerifyConsoleInfo("Console in result", consoles[0], r.ConsoleIDWithSCode);
                ValueCheck.Test("Result outcome", BetaV4.GroupMembershipChangeOutcome.Success, r.Outcome);
                ValueCheck.TestDifferent("ResultGroups", (BetaV4.GroupSummary[])null, r.Groups);
                ValueCheck.Test("Number of groups in result", 1, r.Groups.Length);
                ValueCheck.Test("Group in result", bge.Id, r.Groups[0].GroupGuid);
            }
        }

        [TestGroup, TestCasePriority(3), Description("Negative cases.")]
        public class Negative : TestNode
        {
            [TestCase, Description("Console list is null.")]
            public class NullConsoleList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(null, null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list is empty.")]
            public class EmptyConsoleList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new BetaV4.ConsoleInfo[0], null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list has a null value.")]
            public class NullConsoleInList : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new BetaV4.ConsoleInfo[1]{ null }, null, HResult.XONLINE_E_MIX_ARGUMENT_NULL);
                }
            }

            [TestCase, Description("Console list has non-consoles.")]
            [CompoundCase("Empty", "")]
            [CompoundCase("Number", "1")]
            [CompoundCase("Random", "zd8yfwerzfdx")]
            [CompoundCase("Large", "sp9o87r6y238dhf87324yrqfguj97fj3r63856fq28f2rty6987346jy9560o87wq3y65f8747")]
            public class GarbageConsole : TestNode
            {
                public override void Run()
                {
                    ExecuteValidate(new BetaV4.ConsoleInfo[]{ Utils.MakeConsoleInfo((string)MyValues[0], "0000-0000-0000-0000") }, new ConsoleState[]{ ConsoleState.DoesNotExist });
                }
            }

            //!
            //!TODO: Tests for messing with SCode and ConsoleInfo itself
            //!
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\MigrateConsoleIDsToGroupV3.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV3=xonline.mix.betamanagement.contracts.V3;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the MigrateConsoleIDsToGroup (beta group) API")]
    public class MigrateConsoleIDsToGroupV3: TestNode
    {
        public override void OneTimeSetup()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.MigrateConsoleIDsToGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Migrates 1 machine to another group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            MachineEditor mach0=MachineEditor.CreateNew(mtype);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(mach0.Id);

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Migrates 1000 machine from one group to another.")]
        public void Migrate1000Machines()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            Global.RO.Debug("Creating 1000 machines...");
            MachineEditor []machines=new MachineEditor[1000];
            string []consoles=new string[1000];
            for (int i=0; i<1000; ++i)
            {
                machines[i]=MachineEditor.CreateNew(MachineType.Xbox360);
                consoles[i]=machines[i].ConsoleId;

                bgeOrig.AddMachine(machines[i].Id);
            }

            Global.RO.Debug("Running...");
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Migrates a subset of machines from one group to another group that already has some machines in it.")]
        public void MigrateSubset()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor []machines=new MachineEditor[6];
            for (int i=0; i<6; ++i)
            {
                machines[i]=MachineEditor.CreateNew(MachineType.Xbox360);
            }

            bgeOrig.AddMachine(machines[0].Id);
            bgeOrig.AddMachine(machines[1].Id); //to be moved
            bgeOrig.AddMachine(machines[2].Id);
            bgeOrig.AddMachine(machines[3].Id); //to be moved
            bgeNew.AddMachine(machines[4].Id);
            bgeNew.AddMachine(machines[5].Id);

            string []consolesToMove=new string[]{machines[1].ConsoleId, machines[3].ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consolesToMove, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[]{machines[0].ConsoleId, machines[2].ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[]{machines[1].ConsoleId, machines[3].ConsoleId, machines[4].ConsoleId, machines[5].ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToMove));
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            string []consolesToMigrate=new string[]{MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360)};

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consolesToMigrate, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToMigrate);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToMigrate, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        public void InvalidConsoleID()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            string []consolesToMigrate=new string[]{"XE.ABCDEFGHIJHL"};

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consolesToMigrate, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToMigrate);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToMigrate, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate from a group to itself.")]
        public void MigrateToSelf()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_CANNOT_MIGRATE_TO_SELF;
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeOrig.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Migrates 0 machines to a group.")]
        public void MigrateNoMachines()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            string []consoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleIDsNull()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            string []consoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(null, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate to the special 0-guid group.")]
        public void ZeroGuidTo()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, System.Guid.Empty);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate from the special 0-guid group.")]
        public void ZeroGuidFrom()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, System.Guid.Empty, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate to a group that does not exist.")]
        public void GroupDoesNotExistTo()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            System.Guid badGroup=System.Guid.NewGuid();

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, badGroup);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, consoles);
            BetaManagementUtilsV3.VerifyGroupMembership(badGroup, new string[0]);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate from a group that does not exist.")]
        public void GroupDoesNotExistFrom()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            System.Guid badGroup=System.Guid.NewGuid();

            string []consoles=new string[]{mach0.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, badGroup, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(badGroup, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult[] expectedResult = BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        //TODO: not in source, in none
        //TODO: not in source, in different
        //TODO: not in source, in dest

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that's not in any group.")]
        public void ConsoleNotInAnyGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);

            string []consoles=new string[]{machine.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that's in a group that is neither the destination or the source.")]
        public void ConsoleInUnrelatedGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeUnrelated=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeUnrelated.AddMachine(machine.Id);

            string []consoles=new string[]{machine.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeUnrelated.Id, consoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup, 
                new System.Guid[] { bgeUnrelated.Id });
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that is already in the destination group.")]
        public void ConsoleInDestinationGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeNew.AddMachine(machine.Id);

            string []consoles=new string[]{machine.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, consoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup,
                new System.Guid[] { bgeNew.Id });
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Some of the consoles should migrate correctly, others won't.")]
        public void MixedFailures()
        {
            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360); //in orig
            MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360); //in dest
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360); //in other
            string console3=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360); //machine3 doesn't exist
            MachineEditor machine4=MachineEditor.CreateNew(MachineType.Xbox360); //in orig

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeUnrelated=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(machine0.Id);
            bgeNew.AddMachine(machine1.Id);
            bgeUnrelated.AddMachine(machine2.Id);
            bgeOrig.AddMachine(machine4.Id);

            string []consoles=new string[]{machine0.ConsoleId, machine1.ConsoleId, machine2.ConsoleId, console3, machine4.ConsoleId};
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult[] result = client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[]{machine0.ConsoleId, machine1.ConsoleId, machine4.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeUnrelated.Id, new string[]{machine2.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[] { machine1.ConsoleId },
                BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[] { bgeNew.Id });
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[] { machine2.ConsoleId },
                BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[] { bgeUnrelated.Id });
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[]{console3}, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeOrig.AddMachine(mach.Id);
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{spoofyName};
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new string[]{mach.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new string[0]);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a consoleID that is shared by multiple machines to another group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(machNormal0.Id);
            bgeOrig.AddMachine(machNormal1.Id);
            bgeOrig.AddMachine(machDupe0.Id);
            bgeOrig.AddMachine(machDupe1.Id);

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machNormal1.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            //verify
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new ulong[]{machNormal0.Id, machDupe0.Id, machDupe1.Id, machNormal1.Id});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machDupe1.ConsoleId, machNormal1.ConsoleId}); //note that there are two results for the duplicate
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a consoleID that is shared by multiple machines to another group, where one machine is in a different group than the source.")]
        public void DuplicateConsoleId_OneInDifferentGroup()
        {
            //create machines and group
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);

            BetaGroupEditor bgeUnrelated=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeUnrelated.AddMachine(machDupe0.Id);
            bgeOrig.AddMachine(machDupe1.Id);

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{machDupe0.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.MigrateConsoleIDsToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            //verify
            ValueCheck.Test("Number of results return", 2, result.Length); //there will be one result for each actual machine, so two in this case
            int foundNotInGroup=0;
            int foundSucceeded=0;
            foreach (BetaV3.GroupMembershipChangeResult r in result)
            {
                ValueCheck.Test("ConsoleID in result", machDupe0.ConsoleId, r.ConsoleID);
                if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.Success)
                {
                    ++foundSucceeded;

                    if (r.ConflictingGroups!=null)
                    {
                        ValueCheck.Test("Conflicting groups", 0, r.ConflictingGroups.Length);
                    }
                }
                else if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup)
                {
                    ++foundNotInGroup;
                }
                else
                {
                    throw new UnexpectedTestResultException("Did not expect to get result: "+r.Outcome);
                }
            }

            ValueCheck.Test("Number of success results", 1, foundSucceeded);
            ValueCheck.Test("Number of not in group results", 1, foundNotInGroup);

            BetaManagementUtilsV3.VerifyGroupMembership(bgeUnrelated.Id, new ulong[]{machDupe0.Id});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeOrig.Id, new ulong[0]);
            BetaManagementUtilsV3.VerifyGroupMembership(bgeNew.Id, new ulong[]{machDupe1.Id});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\GetGroupDetailsV1.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V1;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class GetGroupDetailsV1 : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.GetGroupDetails");
        }


        static BetaManagementWCFClient client = new BetaManagementWCFClient();


        [TestCase, TestCasePriority(1)]
        class P_GetGroupDetails_Random : WCFTestBase
        {
            public override void Run()
            {
                TestGroupDetails((new Random()).Next() % 32);
            }
        }

        [TestCase]
        class P_GetGroupDetails_NullGuid : WCFTestBase
        {
            public override void Run()
            {
                client.GetGroupDetails(Guid.Empty);
            }
        }

        public static void TestGroupDetails(int i)
        {
            List<Group> groups = BetaManagementUtils.CreateFakeGroups(i);
            List<uint> titlesToDelete = new List<uint>();
            BetaManagementUtils.AddFakeGroups(groups, ref titlesToDelete);
            bool passed = true;
            try
            {
                foreach (Group g in groups)
                {
                    Group received = client.GetGroupDetails(g.Summary.GroupGuid);
                    if (!GroupEquals(g, received))
                    {
                        Global.RO.Error("Group {0} did not have matching fields with the group returned by GetGroupDetails.", g.Summary.GroupGuid);
                        passed = false;
                    }
                }
            }
            finally
            {
                BetaManagementUtils.CleanGroups(new List<Group>(groups), titlesToDelete);
            }

            if (!passed)
            {
                throw new UnexpectedTestResultException("Group verification failed.");
            }
        }

        private static bool GroupEquals(Group g,Group received)
        {
            if ((g.Summary.FlashVersion / 0x100) % 0x10000 != received.Summary.FlashVersion) return false;
            if (!g.Summary.Creator.Equals(received.Summary.Creator)) return false;
            if (g.Summary.GroupGuid != received.Summary.GroupGuid) return false;
            if (!g.Summary.Name.Equals(received.Summary.Name)) return false;
            if (Array.Equals(g.RelInfos, received.RelInfos)) return false;
            if (Array.Equals(g.Titles, received.Titles)) return false;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\IsTitleVersionPropped.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V4;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;

namespace MixTest
{

    /// <summary>
    /// This test group covers the Group Management APIs.
    /// </summary>
    /// 
    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("Mix Group Management Tests"), TestCasePriority(2)]
    public class IsTitleVersionPropped : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.IsTitleVersionPropped");
        }


        static BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();

        [TestCase, TestCasePriority(1)]
        class P_IsTitleVersionPropped : WCFTestBase
        {
            public override void Run()
            {
                try
                {
                    if (BetaManagementUtilsV4.InsertFlashVersionLocation(0x1))
                    {
                        if (!client.IsTitleVersionPropped(0, 0x1))
                            throw new UnexpectedTestResultException("IsTitleVersionPropped failed");
                    }
                }
                finally
                {
                    BetaManagementUtilsV4.DeleteFlashVersionLocation(0x1);
                }
            }
        }

        [TestCase]
        class P_IsTitleVersionPropped_Not : WCFTestBase
        {
            public override void Run()
            {
                if (client.IsTitleVersionPropped(0, 0x1))
                    throw new UnexpectedTestResultException("IsTitleVersionPropped unexpectedly succeeded");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\RemoveConsoleIDsFromGroupV3.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV3=xonline.mix.betamanagement.contracts.V3;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the RemoveConsoleIDsFromGroup (beta group) API")]
    public class RemoveConsoleIDsFromGroupV3: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.RemoveConsoleIDsFromGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Removes 1 of 2 machines in a group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            MachineEditor machine0=MachineEditor.CreateNew(mtype);
            MachineEditor machine1=MachineEditor.CreateNew(mtype);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machine0.Id);
            bge.AddMachine(machine1.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{machine0.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{machine1.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Remove all 1000 machine from a group.")]
        public void Remove1000Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 1000 machines...");
            string []consoles=new string[1000];
            for (int i=0; i<1000; ++i)
            {
                MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                consoles[i]=mach.ConsoleId;
                bge.AddMachine(mach.Id);
            }

            Global.RO.Debug("Running...");
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[0]);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove a machine that's not in any group from a group.")]
        public void NotInAnyGroup()
        {
            MachineEditor machToRemove=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machUnrelated=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machUnrelated.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{machToRemove.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{machUnrelated.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove a machine that's in a different group from a group.")]
        public void NotInThisGroup()
        {
            MachineEditor machToRemove=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machUnrelated=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machUnrelated.Id);

            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();
            bgeOther.AddMachine(machToRemove.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{machToRemove.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{machUnrelated.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeOther.Id, new string[]{machToRemove.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []consolesToAdd=new string[]{MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360)};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        public void InvalidConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []consolesToAdd=new string[]{"SN.ABCDEFGHIJHL"};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consolesToAdd, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consolesToAdd);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consolesToAdd, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Remove 0 machines from a group.")]
        public void RemoveNoMachines()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(new string[0], bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{mach.ConsoleId});
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleIDsNull()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            string []consoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(null, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove from the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []actualConsoles=new string[]{MachineEditor.CreateNew(MachineType.Xbox360).ConsoleId};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(actualConsoles, System.Guid.Empty);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove from a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            string []actualConsoles=new string[]{MachineEditor.CreateNew(MachineType.Xbox360).ConsoleId};
            string []expectedConsoles=new string[0];

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(actualConsoles, System.Guid.NewGuid());

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, expectedConsoles);
        }

        [TestCase, TestCasePriority(2), Description("Remove a set from a group with one in the middle being in a different group and one in the middle not being valid")]
        public void PartialFailure()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360); //will be removed
            MachineEditor mach1=MachineEditor.CreateNew(MachineType.Xbox360); //will be left
            MachineEditor mach2=MachineEditor.CreateNew(MachineType.Xbox360); //in a different group
            string mach3Cid="XE.THISISRLYBAD";
            MachineEditor mach4=MachineEditor.CreateNew(MachineType.Xbox360); //will be removed

            bge.AddMachine(mach0.Id);
            bge.AddMachine(mach1.Id);
            bge.AddMachine(mach4.Id);
            bgeOther.AddMachine(mach2.Id);

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{mach0.ConsoleId, mach2.ConsoleId, mach3Cid, mach4.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{mach1.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembership(bgeOther.Id, new string[]{mach2.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[]{mach2.ConsoleId}, BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, new string[]{mach3Cid}, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consoles=new string[]{spoofyName};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consoles, bge.Id);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[]{mach.ConsoleId});

            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV3.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV3.GroupMembershipChangeOutcome.MachineAccountNotExist);
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to remove a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            bge.AddMachine(machNormal0.Id);
            bge.AddMachine(machNormal1.Id);
            bge.AddMachine(machDupe0.Id);
            bge.AddMachine(machDupe1.Id);

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consolesToRemove=new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machNormal1.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consolesToRemove, bge.Id);

            //verify
            BetaV3.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV3.BuildSuccessfulGroupMembershipChangeResult(new string[]{machNormal0.ConsoleId, machDupe0.ConsoleId, machDupe1.ConsoleId, machNormal1.ConsoleId});
            BetaManagementUtilsV3.VerifyGroupMembershipChangeResult(result, expectedResult);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[0]{});
        }

        [TestCase, TestCasePriority(1), Description("Attempt to remove a consoleID that is shared by multiple machines to a group, where one of the machines isn't in a group.")]
        public void DuplicateConsoleId_OneNotInGroup()
        {
            //create machines and group
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machDupe0.Id);

            //call api
            BetaManagementV3WCFClient client=new BetaManagementV3WCFClient();
            string []consolesToRemove=new string[]{machDupe0.ConsoleId};
            BetaV3.GroupMembershipChangeResult []result=client.RemoveConsoleIDsFromGroup(consolesToRemove, bge.Id);

            //verify
            ValueCheck.Test("Number of results return", 2, result.Length); //there will be one result for each actual machine, so two in this case
            int foundNotInGroup=0;
            int foundSucceeded=0;
            foreach (BetaV3.GroupMembershipChangeResult r in result)
            {
                ValueCheck.Test("ConsoleID in result", machDupe0.ConsoleId, r.ConsoleID);
                if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.Success)
                {
                    ++foundSucceeded;

                    if (r.ConflictingGroups!=null)
                    {
                        ValueCheck.Test("Conflicting groups", 0, r.ConflictingGroups.Length);
                    }
                }
                else if (r.Outcome==BetaV3.GroupMembershipChangeOutcome.MachineNotInGroup)
                {
                    ++foundNotInGroup;
                }
                else
                {
                    throw new UnexpectedTestResultException("Did not expect to get result: "+r.Outcome);
                }
            }

            ValueCheck.Test("Number of success results", 1, foundSucceeded);
            ValueCheck.Test("Number of not in group results", 1, foundNotInGroup);

            BetaManagementUtilsV3.VerifyGroupMembership(bge.Id, new string[0]{});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\RemoveGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the RemoveGroup (beta group) API")]
    public class RemoveGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.RemoveGroup");
        }

        const uint TITLE_ID=0xF457F00D;
        private static TitleEditor Title;

        public override void PreRun()
        {
            Title=TitleEditor.CreateOrUseExistingId(TITLE_ID);
        }

        [TestCase, TestCasePriority(1), Description("Deletes a group which has a title version and hive setting associated with it.")]
        public void SimpleMainline(TestNode me)
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            Title.RemoveAllVersions();
            Title.AddVersion(1, 1, 2, bge.Id);
            Title.AddVersion(2, 2, 2, System.Guid.Empty);

            string hiveConfigName=me.FullName.Replace(".", "_");
            LiveRegistry.RemoveSettingsForClientConfig(hiveConfigName);
            LiveRegistry.AddSetting(hiveConfigName, 1, 2, bge.Id,            "testname", "testvalue");
            LiveRegistry.AddSetting(hiveConfigName, 1, 2, System.Guid.Empty, "testname", "othervalue");

            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.RemoveGroup(bge.Id);

            //verify that its all gone
            ValueCheck.Test("Group exists", false, bge.Exists);
            ValueCheck.Test("Title versions remaining for group", 1, Title.GetAllVersions().Length);
            ValueCheck.Test("LiveHive settings remaining for group", 1, LiveRegistry.GetSettingsForClientConfig(hiveConfigName).Length);
        }

        [TestCase, TestCasePriority(1), Description("Delete a group that has nothing configured for it.")]
        public void NoTitleOrHiveConfigured()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.RemoveGroup(bge.Id);

            //verify that its all gone
            ValueCheck.Test("Group exists", false, bge.Exists);
        }

        [TestCase, TestCasePriority(1), Description("Deletes a group which has a large amount of data configured for it.")]
        public void LargeAmountOfData(TestNode me)
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            Global.RO.Debug("Adding test data...");
            Title.RemoveAllVersions();
            for (uint i=0; i<1000; ++i)
            {
                Title.AddVersion(i, i+1, 2, bge.Id);
            }

            string hiveConfigName=me.FullName.Replace(".", "_");
            LiveRegistry.RemoveSettingsForClientConfig(hiveConfigName);
            for (ushort i=0; i<1000; ++i)
            {
                LiveRegistry.AddSetting(hiveConfigName, i, i, bge.Id,            "testname", "testvalue"+i);
            }

            //call the api
            Global.RO.Debug("Running...");
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.RemoveGroup(bge.Id);

            //verify that its all gone
            ValueCheck.Test("Group exists", false, bge.Exists);
            ValueCheck.Test("Title versions remaining for group", 0, Title.GetAllVersions().Length);
            ValueCheck.Test("LiveHive settings remaining for group", 0, LiveRegistry.GetSettingsForClientConfig(hiveConfigName).Length);
        }

        [TestCase, TestCasePriority(1), Description("Try to delete a group that still has machines in it.")]
        public void GroupHasMachines(TestNode me)
        {
            MachineEditor mach=MachineEditor.CreateNew();

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);

            Title.RemoveAllVersions();
            Title.AddVersion(1, 1, 2, bge.Id);
            Title.AddVersion(2, 2, 2, System.Guid.Empty);

            string hiveConfigName=me.FullName.Replace(".", "_");
            LiveRegistry.RemoveSettingsForClientConfig(hiveConfigName);
            LiveRegistry.AddSetting(hiveConfigName, 1, 2, bge.Id,            "testname", "testvalue");
            LiveRegistry.AddSetting(hiveConfigName, 1, 2, System.Guid.Empty, "testname", "othervalue");

            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_MUST_BE_EMPTY;
            client.RemoveGroup(bge.Id);

            //verify that its all gone
            ValueCheck.Test("Group exists", true, bge.Exists);
            ValueCheck.Test("Title versions remaining for group", 2, Title.GetAllVersions().Length);
            ValueCheck.Test("LiveHive settings remaining for group", 2, LiveRegistry.GetSettingsForClientConfig(hiveConfigName).Length);
        }

        [TestCase, TestCasePriority(2), Description("Try to delete the empty guid.")]
        public void DeleteEmptyGuid(TestNode me)
        {
            Title.RemoveAllVersions();
            Title.AddVersion(2, 2, 2, System.Guid.Empty);

            string hiveConfigName=me.FullName.Replace(".", "_");
            LiveRegistry.RemoveSettingsForClientConfig(hiveConfigName);
            LiveRegistry.AddSetting(hiveConfigName, 1, 2, System.Guid.Empty, "testname", "othervalue");

            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            client.RemoveGroup(System.Guid.Empty);

            //verify that its all gone
            ValueCheck.Test("Title versions remaining for group", 1, Title.GetAllVersions().Length);
            ValueCheck.Test("LiveHive settings remaining for group", 1, LiveRegistry.GetSettingsForClientConfig(hiveConfigName).Length);
        }

        [TestCase, TestCasePriority(2), Description("Deletes a group that doesn't exist.")]
        public void GroupDoesNotExist()
        {
            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            client.RemoveGroup(System.Guid.NewGuid());
        }

        [TestCase, TestCasePriority(2), Description("Deletes a group that has release info and release info and verify that that stuff goes away.")]
        public void GroupHasReleaseInfo(TestNode me)
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Group: "+bge.Id);
            Title.RemoveAllVersions();

            string hiveConfigName=me.FullName.Replace(".", "_");
            LiveRegistry.RemoveSettingsForClientConfig(hiveConfigName);

            BetaGroupEditor.BetaReleaseInfo brinfo=new BetaGroupEditor.BetaReleaseInfo();
            brinfo.SOMRevision="Hello";
            brinfo.SMRevision="World";
            brinfo.FlashVersion=0x77777777;
            bge.SetReleaseInfo(brinfo);

            //call the api
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.RemoveGroup(bge.Id);

            //verify that its all gone
            ValueCheck.Test("Group exists", false, bge.Exists);
            if (bge.GetReleaseInfo()!=null)
            {
                throw new UnexpectedTestResultException("t_beta_group_releases still has data for the beta group even after it was removed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\MigrateConsoleInfosToGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using Utils=MixTest.BetaManagementUtilsV4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the MigrateConsoleInfosToGroup (beta group) API")]
    public class MigrateConsoleInfosToGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.MigrateConsoleInfosToGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Migrates 1 machine to another group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            MachineEditor mach0=MachineEditor.CreateNew(mtype);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(mach0.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Migrate a machine that has an scode that is not a duplicate to a group without specifying an scode.")]
        [CompoundCase("Null", null)]
        [CompoundCase("Empty", "")]
        public void NoSCode_Nonduplicate(TestNode myNode)
        {
            string scode=(string)myNode.MyValues[0];

            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(mach.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach)}));
        }

        [TestCase, TestCasePriority(1), Description("Migrate an xbox360 that has not been migrated to the new key table without specifying an scode.  Since we don't have a unique differentiator for this machine in the db yet, it is treated as a duplicate since it could potentially become swapped with a duplicate in the future still.")]
        public void NoSCode_LegacyXbox360()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(mach.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, null)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(consoles);
            BetaManagementUtilsV4.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineDuplicate);
            BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);
        }

        [TestCase, TestCasePriority(1), Description("Migrates 500 machine from one group to another.")]
        public void Migrate500Machines()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            Global.RO.Debug("Creating 500 machines...");
            MachineEditor []machines=new MachineEditor[500];
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[500];
            for (int i=0; i<500; ++i)
            {
                machines[i]=MachineEditor.CreateNew(MachineType.Xbox360);
                consoles[i]=Utils.MakeConsoleInfo(machines[i]);

                bgeOrig.AddMachine(machines[i].Id);
            }

            Global.RO.Debug("Running...");
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Migrates a subset of machines from one group to another group that already has some machines in it.")]
        public void MigrateSubset()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor []machines=new MachineEditor[6];
            for (int i=0; i<6; ++i)
            {
                machines[i]=MachineEditor.CreateNew(MachineType.Xbox360);
            }

            bgeOrig.AddMachine(machines[0].Id);
            bgeOrig.AddMachine(machines[1].Id); //to be moved
            bgeOrig.AddMachine(machines[2].Id);
            bgeOrig.AddMachine(machines[3].Id); //to be moved
            bgeNew.AddMachine(machines[4].Id);
            bgeNew.AddMachine(machines[5].Id);

            BetaV4.ConsoleInfo []consolesToMove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machines[1]), Utils.MakeConsoleInfo(machines[3])};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consolesToMove, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new ulong[]{machines[0].Id, machines[2].Id});
            Utils.VerifyGroupMembership(bgeNew.Id, new ulong[]{machines[1].Id, machines[3].Id, machines[4].Id, machines[5].Id});
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToMove));
        }

        [TestCase, TestCasePriority(1), Description("Invalid SCode")]
        [CompoundCase("BadChars", "XX**ThisIsNotValid*")]
        [CompoundCase("TooShort", "0000")]
        [CompoundCase("TooLong", "0000-0000-0000-0000-0000")]
        //[CompoundCase("Empty", "")] //Note, starting with the 2011 june xsr, we will treat this case as null (which is valid) ONLY FOR SCODE
        public void InvalidSCode(TestNode self)
        {
            string scode=(string)self.MyValues[0];

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaV4.ConsoleInfo []consolesToMigrate=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};

            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consolesToMigrate, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToMigrate);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToMigrate, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToMigrate=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360), "0000-0000-0000-0000")};

            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consolesToMigrate, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToMigrate);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToMigrate, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        [CompoundCase("BadChars", "XE.ABCDEFGHIJHL")]
        [CompoundCase("TooShort", "XE.1")]
        [CompoundCase("TooLong", "XE.1111111111111")]
        [CompoundCase("Empty", "")]
        public void InvalidConsoleID(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToMigrate=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(cid, "0000-0000-0000-0000")};

            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consolesToMigrate, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToMigrate);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToMigrate, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate from a group to itself.")]
        public void MigrateToSelf()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_CANNOT_MIGRATE_TO_SELF;
            BetaV4.GroupMembershipChangeResult[] result=client.MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeOrig.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Migrates 0 machines to a group.")]
        public void MigrateNoMachines()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[0];

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult[] result=client.MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleInfosNull()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[0];

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult[] result=client.MigrateConsoleInfosToGroup(null, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate to the special 0-guid group.")]
        public void ZeroGuidTo()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV4.GroupMembershipChangeResult []result=client.MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, System.Guid.Empty);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate from the special 0-guid group.")]
        public void ZeroGuidFrom()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV4.GroupMembershipChangeResult[] result=client.MigrateConsoleInfosToGroup(consoles, System.Guid.Empty, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate to a group that does not exist.")]
        public void GroupDoesNotExistTo()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(mach0.Id);

            System.Guid badGroup=System.Guid.NewGuid();

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV4.GroupMembershipChangeResult[] result=client.MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, badGroup);

            Utils.VerifyGroupMembership(bgeOrig.Id, consoles);
            Utils.VerifyGroupMembership(badGroup, new BetaV4.ConsoleInfo[0]);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to migrate from a group that does not exist.")]
        public void GroupDoesNotExistFrom()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            System.Guid badGroup=System.Guid.NewGuid();

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0)};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, badGroup, bgeNew.Id);

            Utils.VerifyGroupMembership(badGroup, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult[] expectedResult = Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that's not in any group.")]
        public void ConsoleNotInAnyGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine)};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that's in a group that is neither the destination or the source.")]
        public void ConsoleInUnrelatedGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeUnrelated=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeUnrelated.AddMachine(machine.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine)};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeUnrelated.Id, consoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[] { bgeUnrelated.Id });
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a console that is already in the destination group.")]
        public void ConsoleInDestinationGroup()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeNew.AddMachine(machine.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine)};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, consoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[] { bgeNew.Id });
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Some of the consoles should migrate correctly, others won't.")]
        public void MixedFailures()
        {
            MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360); //in orig
            MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360); //in dest
            MachineEditor machine2=MachineEditor.CreateNew(MachineType.Xbox360); //in other
            string console3=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360); //machine3 doesn't exist
            MachineEditor machine4=MachineEditor.CreateNew(MachineType.Xbox360); //in orig

            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeUnrelated=BetaGroupEditor.CreateNew();
            bgeOrig.AddMachine(machine0.Id);
            bgeNew.AddMachine(machine1.Id);
            bgeUnrelated.AddMachine(machine2.Id);
            bgeOrig.AddMachine(machine4.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine0), Utils.MakeConsoleInfo(machine1), Utils.MakeConsoleInfo(machine2), Utils.MakeConsoleInfo(console3, "0000-0000-0000-0000"), Utils.MakeConsoleInfo(machine4)};
            BetaV4.GroupMembershipChangeResult[] result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembership(bgeNew.Id, new ulong[]{machine0.Id, machine1.Id, machine4.Id});
            Utils.VerifyGroupMembership(bgeUnrelated.Id, new ulong[]{machine2.Id});

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine1)}, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[]{bgeNew.Id});
            Utils.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine2)}, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup, new System.Guid[]{bgeUnrelated.Id});
            Utils.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(console3, "0000-0000-0000-0000")}, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            bgeOrig.AddMachine(mach.Id);
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(spoofyName, "0000-0000-0000-0000")};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            Utils.VerifyGroupMembership(bgeOrig.Id, new ulong[]{mach.Id});
            Utils.VerifyGroupMembership(bgeNew.Id, new ulong[0]);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a consoleID that is shared by multiple machines to another group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_NoSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(machNormal0.Id);
            bgeOrig.AddMachine(machNormal1.Id);
            bgeOrig.AddMachine(machDupe0.Id);
            bgeOrig.AddMachine(machDupe1.Id);

            //call api
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0.ConsoleId, null), Utils.MakeConsoleInfo(machNormal1.ConsoleId, null)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            //verify - Note that we have a problem here.  The order returned from MixBetaManagement is supposed to always deterministically match the order passed in.  Here we don't know which SCode will come back first though, so try validating both orders.  This is a littly hacky but it works.
            bool eitherValidates=false;
            System.Exception exception0=null;
            System.Exception exception1=null;

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                expectedResult[2].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception0=e;
            }

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                expectedResult[2].Outcome=BetaV4.GroupMembershipChangeOutcome.MachineDuplicate;
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception1=e;
            }

            if (!eitherValidates)
            {
                throw new UnexpectedTestResultException("Neither order validates.", exception0??exception1);
            }

            //verify group in db
            Utils.VerifyGroupMembership(bgeNew.Id, new ulong[]{machNormal0.Id, machNormal1.Id});
            Utils.VerifyGroupMembership(bgeOrig.Id, new ulong[]{machDupe0.Id, machDupe1.Id});
        }

        [TestCase, TestCasePriority(1), Description("Attempt to migrate a consoleID that is shared by multiple machines to another group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_WithSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            MachineEditor machDupe2=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId); //we don't move this one
            BetaGroupEditor bgeOrig=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeNew=BetaGroupEditor.CreateNew();

            bgeOrig.AddMachine(machNormal0.Id);
            bgeOrig.AddMachine(machNormal1.Id);
            bgeOrig.AddMachine(machDupe0.Id);
            bgeOrig.AddMachine(machDupe1.Id);
            bgeOrig.AddMachine(machDupe2.Id);

            //call api
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().MigrateConsoleInfosToGroup(consoles, bgeOrig.Id, bgeNew.Id);

            //verify
            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);

            Utils.VerifyGroupMembership(bgeNew.Id, new ulong[]{machNormal0.Id, machDupe0.Id, machDupe1.Id, machNormal1.Id});
            Utils.VerifyGroupMembership(bgeOrig.Id, new ulong[]{machDupe2.Id});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\RemoveConsoleInfosFromGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using BetaV4=xonline.mix.betamanagement.contracts.V4;
using Utils=MixTest.BetaManagementUtilsV4;
using xonline.common.config;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the RemoveConsoleInfosFromGroup (beta group) API")]
    public class RemoveConsoleInfosFromGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.RemoveConsoleInfosFromGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case: Removes 1 of 2 machines in a group.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SimpleMainline(TestNode myNode)
        {
            MachineType mtype=(MachineType)myNode.MyValues[0];

            MachineEditor machine0=MachineEditor.CreateNew(mtype);
            MachineEditor machine1=MachineEditor.CreateNew(mtype);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machine0.Id);
            bge.AddMachine(machine1.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machine0)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new ulong[]{machine1.Id});
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(1), Description("Remove a machine that has an scode that is not a duplicate from a group without specifying an scode.")]
        [CompoundCase("Null", null)]
        [CompoundCase("Empty", "")]
        public void NoSCode_Nonduplicate(TestNode myNode)
        {
            string scode=(string)myNode.MyValues[0];

            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);

            BetaV4.ConsoleInfo []consolesToPass=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};
            BetaV4.ConsoleInfo []consolesExpected=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach)};

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToPass, bge.Id);

            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consolesExpected));
            Utils.VerifyGroupMembership(bge.Id, new ulong[0]);
        }

        [TestCase, TestCasePriority(1), Description("Add an xbox360 that has not been migrated to the new key table without specifying an scode.  Since we don't have a unique differentiator for this machine in the db yet, it is treated as a duplicate, but we're ok with removing all duplicates.")]
        public void NoSCode_LegacyXbox360()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();
            bge.AddMachine(mach.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, null)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consoles));
            Utils.VerifyGroupMembership(bge.Id, new ulong[0]);
        }

        [TestCase, TestCasePriority(1), Description("Remove all 500 machine from a group.")]
        public void Remove500Machines()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            Global.RO.Debug("Creating 500 machines...");
            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[500];
            for (int i=0; i<500; ++i)
            {
                MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                consoles[i]=Utils.MakeConsoleInfo(mach);
                bge.AddMachine(mach.Id);
            }

            Global.RO.Debug("Running...");
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[0]);
            Utils.VerifyGroupMembershipChangeResult(result, Utils.BuildSuccessfulGroupMembershipChangeResult(consoles));
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove a machine that's not in any group from a group.")]
        public void NotInAnyGroup()
        {
            MachineEditor machToRemove=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machUnrelated=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machUnrelated.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machToRemove)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new ulong[]{machUnrelated.Id});

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove a machine that's in a different group from a group.")]
        public void NotInThisGroup()
        {
            MachineEditor machToRemove=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machUnrelated=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(machUnrelated.Id);

            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();
            bgeOther.AddMachine(machToRemove.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machToRemove)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machUnrelated)});
            Utils.VerifyGroupMembership(bgeOther.Id, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machToRemove)});

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Nonexistant but valid console ID")]
        public void NonexistanceConsoleID()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToRemove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360), "0000-0000-0000-0000")};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToRemove, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToRemove);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToRemove, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid SCode")]
        [CompoundCase("BadChars", "XX**ThisIsNotValid*")]
        [CompoundCase("TooShort", "0000")]
        [CompoundCase("TooLong", "0000-0000-0000-0000-0000")]
        //[CompoundCase("Empty", "")] //Note, starting with the 2011 june xsr, we will treat this case as null (which is valid) ONLY FOR SCODE
        public void InvalidSCode(TestNode self)
        {
            string scode=(string)self.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

            BetaV4.ConsoleInfo []consolesToRemove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach.ConsoleId, scode)};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToRemove, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToRemove);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToRemove, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Invalid console ID")]
        [CompoundCase("BadChars", "XE.ABCDEFGHIJHL")]
        [CompoundCase("TooShort", "XE.1")]
        [CompoundCase("TooLong", "XE.1111111111111")]
        [CompoundCase("Empty", "")]
        public void InvalidConsoleID(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaV4.ConsoleInfo []consolesToRemove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(cid, "0000-0000-0000-0000")};
            BetaV4.ConsoleInfo []expectedConsoles=new BetaV4.ConsoleInfo[0];

            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToRemove, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, expectedConsoles);

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToRemove);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consolesToRemove, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(2), Description("Remove 0 machines from a group.")]
        public void RemoveNoMachines()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.RemoveConsoleInfosFromGroup(new BetaV4.ConsoleInfo[0], bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new ulong[]{mach.Id});
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the console list.")]
        public void ConsoleIDsNull()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            BetaV4.GroupMembershipChangeResult []result=client.RemoveConsoleInfosFromGroup(null, bge.Id);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove from the special 0-guid group.")]
        public void ZeroGuid()
        {
            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.CreateNew(MachineType.Xbox360))};

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            BetaV4.GroupMembershipChangeResult []result=client.RemoveConsoleInfosFromGroup(actualConsoles, System.Guid.Empty);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to remove from a group that does not exist.")]
        public void GroupDoesNotExist()
        {
            BetaV4.ConsoleInfo []actualConsoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(MachineEditor.CreateNew(MachineType.Xbox360))};

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            BetaV4.GroupMembershipChangeResult []result=client.RemoveConsoleInfosFromGroup(actualConsoles, System.Guid.NewGuid());
        }

        [TestCase, TestCasePriority(2), Description("Remove a set from a group with one in the middle being in a different group and one in the middle not being valid")]
        public void PartialFailure()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            BetaGroupEditor bgeOther=BetaGroupEditor.CreateNew();

            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360); //will be removed
            MachineEditor mach1=MachineEditor.CreateNew(MachineType.Xbox360); //will be left
            MachineEditor mach2=MachineEditor.CreateNew(MachineType.Xbox360); //in a different group
            string mach3Cid="XE.THISISRLYBAD";
            MachineEditor mach4=MachineEditor.CreateNew(MachineType.Xbox360); //will be removed

            bge.AddMachine(mach0.Id);
            bge.AddMachine(mach1.Id);
            bge.AddMachine(mach4.Id);
            bgeOther.AddMachine(mach2.Id);

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach0), Utils.MakeConsoleInfo(mach2), Utils.MakeConsoleInfo(mach3Cid, "0000-0000-0000-0000"), Utils.MakeConsoleInfo(mach4)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach1)});
            Utils.VerifyGroupMembership(bgeOther.Id, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach2)});

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach2)}, BetaV4.GroupMembershipChangeOutcome.MachineNotInGroup);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach3Cid, "0000-0000-0000-0000")}, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(3), Description("Attempt to pass a bad console ID by masking the end with a null terminator.")]
        public void SpoofedOverlongConsoleId()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();
            bge.AddMachine(mach.Id);
            string spoofyName=mach.ConsoleId+"\0extrastuff";

            BetaV4.ConsoleInfo []consoles=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(spoofyName, "0000-0000-0000-0000")};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consoles, bge.Id);

            Utils.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(mach)});

            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consoles);
            Utils.ChangeGroupMembershipChangeResult(expectedResult, consoles, BetaV4.GroupMembershipChangeOutcome.MachineAccountNotExist);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to remove a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_NoSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            bge.AddMachine(machNormal0.Id);
            bge.AddMachine(machNormal1.Id);
            bge.AddMachine(machDupe0.Id);
            bge.AddMachine(machDupe1.Id);

            //call api
            BetaV4.ConsoleInfo []consolesToRemove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0.ConsoleId, null), Utils.MakeConsoleInfo(machNormal1.ConsoleId, null)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToRemove, bge.Id);

            //verify - Note that we have a problem here.  The order returned from MixBetaManagement is supposed to always deterministically match the order passed in.  Here we don't know which SCode will come back first though, so try validating both orders.  This is a littly hacky but it works.
            bool eitherValidates=false;
            System.Exception exception0=null;
            System.Exception exception1=null;

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception0=e;
            }

            try
            {
                BetaV4.GroupMembershipChangeResult []expectedResult=BetaManagementUtilsV4.BuildSuccessfulGroupMembershipChangeResult(new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)}); //note that there are two results for the duplicate
                expectedResult[1].ConsoleIDWithSCode.SCode=machDupe1.ComputeSCode();
                expectedResult[2].ConsoleIDWithSCode.SCode=machDupe0.ComputeSCode();
                BetaManagementUtilsV4.VerifyGroupMembershipChangeResult(result, expectedResult);
                eitherValidates=true;
            }
            catch (System.Exception e)
            {
                exception1=e;
            }

            if (!eitherValidates)
            {
                throw new UnexpectedTestResultException("Neither order validates.", exception0??exception1);
            }


            //verify group in db
            Utils.VerifyGroupMembership(bge.Id, new BetaV4.ConsoleInfo[0]);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to remove a consoleID that is shared by multiple machines to a group, along with a pair of non-duplicates.")]
        public void DuplicateConsoleId_WithSCode()
        {
            //create machines and group
            MachineEditor machNormal0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machNormal1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor machDupe1=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId);
            MachineEditor machDupe2=MachineEditor.CreateDuplicateXbox360(machDupe0.ConsoleId); //we don't remove this one
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            bge.AddMachine(machNormal0.Id);
            bge.AddMachine(machNormal1.Id);
            bge.AddMachine(machDupe0.Id);
            bge.AddMachine(machDupe1.Id);
            bge.AddMachine(machDupe2.Id);

            //call api
            BetaV4.ConsoleInfo []consolesToRemove=new BetaV4.ConsoleInfo[]{Utils.MakeConsoleInfo(machNormal0), Utils.MakeConsoleInfo(machDupe0), Utils.MakeConsoleInfo(machDupe1), Utils.MakeConsoleInfo(machNormal1)};
            BetaV4.GroupMembershipChangeResult []result=new BetaManagementV4WCFClient().RemoveConsoleInfosFromGroup(consolesToRemove, bge.Id);

            //verify
            BetaV4.GroupMembershipChangeResult []expectedResult=Utils.BuildSuccessfulGroupMembershipChangeResult(consolesToRemove);
            Utils.VerifyGroupMembershipChangeResult(result, expectedResult);

            Utils.VerifyGroupMembership(bge.Id, new ulong[]{machDupe2.Id});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\UpdateGroup.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;
using xonline.common.config;
using xonline.mix.betamanagement.contracts.V4;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), Description("Tests for the UpdateGroup (beta group) API")]
    public class UpdateGroup: TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.UpdateGroup");
        }

        [TestCase, TestCasePriority(1), Description("Positive mainline case.")]
        public void SimpleMainline()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = randomName;

            //call API and verify return value is sane
            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.UpdateGroup(bge.Id, gu);

            //verify the result with the DB
            ValueCheck.Test("Group name in DB", randomName, bge.Name);
        }

        //attempt to update the empty guid... bad bad bad

        [TestCase, TestCasePriority(2), Description("Attempt to update the 0 guid, which should not exist")]
        public void EmptyGuid()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);

            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = randomName;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED;
            client.UpdateGroup(System.Guid.Empty, gu);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to update a guid that does not exist")]
        public void GroupDoesNotExist()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);
            
            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = randomName;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_GROUP_DOES_NOT_EXIST;
            client.UpdateGroup(System.Guid.NewGuid(), gu);
        }

        [TestCase, TestCasePriority(2), Description("Pass null for the name parameter.")]
        public void NullName()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            client.UpdateGroup(bge.Id, null);
        }

        [TestCase, TestCasePriority(2), Description("Pass an empty string for the name parameter.")]
        public void EmptyName()
        {
            BetaGroupEditor bge=BetaGroupEditor.CreateNew();


            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = "";

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
            client.UpdateGroup(bge.Id, gu);
        }

        [TestCase, TestCasePriority(1), Description("Attempt to update a group to a name that already exists.")]
        public void NameAlreadyExists()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(20);

            BetaGroupEditor bgeExisting=BetaGroupEditor.CreateNew();
            bgeExisting.Name=randomName;

            BetaGroupEditor bgeNewer=BetaGroupEditor.CreateNew();
            string newerName=bgeNewer.Name;


            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = randomName;


            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_DUPLICATE_GROUP_NAME_NOT_ALLOWED;
            client.UpdateGroup(bgeNewer.Id, gu);

            //verify that the existing group and the newer group is unscathed
            ValueCheck.Test("Original group still exists", true, bgeExisting.Exists);
            ValueCheck.Test("Original group name", randomName, bgeExisting.Name);

            ValueCheck.Test("Newer group still exists", true, bgeNewer.Exists);
            ValueCheck.Test("Newer group name", newerName, bgeNewer.Name);
        }

        [TestCase, TestCasePriority(2), Description("Attempt to update a group to a name that is too long to store in the DB.")]
        public void NameTooLong()
        {
            string randomName="TestGroup "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(500);
            BetaGroupEditor bge = BetaGroupEditor.CreateNew();

            GroupUpdate gu = new GroupUpdate();
            gu.GroupName = randomName;

            BetaManagementV4WCFClient client=new BetaManagementV4WCFClient();
            client.ExpectedHR=HResult.XONLINE_E_MIX_STRING_TOO_LONG;
            client.UpdateGroup(bge.Id, gu);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\ValidateBetaGroupConsolesV3.cs ===
// Tests for the ValidateBetaGroupConsoles API

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V3;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;



namespace MixTest
{

    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("ValidateBetaGroupConsoles Tests"), TestCasePriority(1)]
    public class ValidateBetaGroupConsolesV3 : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.ValidateBetaGroupConsoles");
        }

        static BetaManagementV3WCFClient client = new BetaManagementV3WCFClient();


        [TestCase, TestCasePriority(1)]
        class P_NoConsoles : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.NoConsoles);
            }
        }

        [TestCase, TestCasePriority(1)]
        class P_OneUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneUpgrade);
            }
        }

        [TestCase]
        class P_OneCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneCorrect);
            }
        }

        [TestCase]
        class P_OneUpgradeOneCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneUpgradeOneCorrect);
            }
        }

        [TestCase]
        class P_OneUpgradeManyCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneUpgradeManyCorrect);
            }
        }

        [TestCase]
        class P_ManyOneHopUpgrades : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.ManyOneHopUpgrades);
            }
        }

        [TestCase]
        class P_ManyMultiHopUpgrades : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.ManyMultiHopUpgrades);
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_ManyMultiHopUpgradesWithInvalidPaths : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.ManyMultiHopUpgradesWithInvalidPaths);
            }
        }

        [TestCase]
        class P_OneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneInvalidDeadEndedConsole : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneInvalidDeadEndedConsole);
            }
        }

        [TestCase]
        class P_OneValidOneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneValidOneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneCorrectOneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneCorrectOneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneInvalidDeadEndManyCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneInvalidDeadEndManyCorrect);
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_OneInvalidDeadendManyUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV3.OneInvalidDeadendManyUpgrade);
            }
        }

        private static void ValidateGroup(ValidityTestsV3 test)
        {
            ConsoleListV3 consoleList = ConsoleListFactoryV3.GenerateConsoleList(test);
            // Set up the beta group
            BetaGroupEditor bg = BetaGroupEditor.CreateNew();
            Global.RO.Debug("group: "+bg.Id);

            TitleEditor te = TitleEditor.FromId(XOn.XENON_DASH_TITLE_ID);

            // Set up the consoles
            foreach (BGMachineEditorV3 me in consoleList.Consoles)
            {
                bg.AddMachine(me.Editor.Id);
                Global.RO.Debug("machine: "+string.Format("0x{0:X}", me.Editor.Id));
            }

            // Add the upgrade versions
            for (int i = 0; i < consoleList.BaseVersions.Count; i++)
            {
                te.AddVersion(consoleList.BaseVersions[i], consoleList.UpgradeVersions[i], 2, bg.Id); //2=xbox360
            }

            bool result = false;

            try
            {
                result = Validate(consoleList, bg.Id);
            }
            finally
            {
                // Tear down consoles
                //foreach (BGMachineEditor me in consoleList.Consoles) me.Editor.CompletelyRemoveMachine();

                // Tear down BetaGroup
                //BetaGroupEditor.NukeGroup(bg.Id);
            }

            if (!result)
            {
                throw new UnexpectedTestResultException("Group result verification failed.");
            }

        }

        private static bool Validate(ConsoleListV3 consoleList, Guid guid)
        {
            IEnumerable<InvalidConsole> expected = consoleList.GetInvalidConsoles();
            InvalidConsole[] actual = client.ValidateBetaGroupConsoles(guid);

            Global.RO.Debug("Returned from server: ");
            foreach (InvalidConsole ret in actual)
            {
                Global.RO.Debug("ConsoleId="+ret.ConsoleId+" FlashVersion="+ret.FlashVersion);
            }

            int actualCount = 0;
            int expectedCount = 0;
            foreach (InvalidConsole ec in expected)
            {
                expectedCount++;
                bool found = false;
                foreach (InvalidConsole ac in actual)
                {
                    if (ec.FlashVersion == ac.FlashVersion && ec.ConsoleId.Equals(ac.ConsoleId))
                    {
                        found = true;
                        actualCount++;
                        break;
                    }
                }
                if (!found)
                {
                    Global.RO.Error("Could not find CID {0} with flash version {1} in the list of invalid consoles found on the server.", ec.ConsoleId, ec.FlashVersion);
                }
            }

            if (actualCount != expectedCount) return false;

            // Now, do the reverse check

            actualCount = 0;
            expectedCount = 0;

            foreach (InvalidConsole ac in actual)
            {
                actualCount++;
                bool found = false;
                foreach (InvalidConsole ec in expected)
                {
                    if (ec.FlashVersion == ac.FlashVersion && ec.ConsoleId.Equals(ac.ConsoleId))
                    {
                        found = true;
                        expectedCount++;
                        break;
                    }
                }
                if (!found)
                {
                    Global.RO.Error("Found unexpected CID {0} with flash version {1}.", ac.ConsoleId, ac.FlashVersion);
                }
            }

            return actualCount == expectedCount;
        }

    }

    public class ConsoleListV3
    {
        public List<uint> BaseVersions = new List<uint>();
        public List<uint> UpgradeVersions = new List<uint>();
        public List<BGMachineEditorV3> Consoles = new List<BGMachineEditorV3>();
        public bool isValid = true;

        public void AddVersion(uint baseVersion, uint upgradeVersion)
        {
            BaseVersions.Add(baseVersion);
            UpgradeVersions.Add(upgradeVersion);
        }
        
        public void AddConsole(uint flashVersion)
        {
            AddConsole(flashVersion, true);
        }

        public void AddConsole(uint flashVersion, bool validConsole)
        {
            BGMachineEditorV3 me = new BGMachineEditorV3(flashVersion, validConsole);
            Consoles.Add(me);
        }

        internal IEnumerable<InvalidConsole> GetInvalidConsoles()
        {
            foreach (BGMachineEditorV3 me in Consoles)
            {
                if (!me.validConsole)
                {
                    InvalidConsole c = new InvalidConsole();
                    c.ConsoleId = me.Editor.ConsoleId;
                    c.FlashVersion = FlashStringToVersion(me.Editor.ClientFlashVersion);
                    yield return c;
                }
            }
        }

        public static uint FlashStringToVersion(string version)
        {
            //break it up and pull out the parts
            string []parts=version.Split(new char[]{'.'});
            if (parts.Length!=4)
            {
                throw new System.Exception("Bad version string.");
            }

            uint qfe=  uint.Parse(parts[3]);
            uint build=uint.Parse(parts[2]);
            uint minor=uint.Parse(parts[1]);
            uint major=uint.Parse(parts[0]);

            //validate ranges
            if ((qfe&  ~0xff)  !=0) throw new System.Exception("Bad value for qfe.");
            if ((build&~0xffff)!=0) throw new System.Exception("Bad value for build.");
            if ((minor&~0xf)   !=0) throw new System.Exception("Bad value for minor.");
            if ((major&~0xf)   !=0) throw new System.Exception("Bad value for major.");

            //build
            uint number=0;
            number|=qfe;
            number|=build<<8;
            number|=minor<<24;
            number|=major<<28;
            return number;
        }
    }

    public class BGMachineEditorV3
    {
        public MachineEditor Editor;
        public bool validConsole = true;

        public BGMachineEditorV3(uint flashVersion, bool validConsole)
        {
            Editor = MachineEditor.CreateNew();
            Editor.ClientFlashVersion = FlashVersionToString(flashVersion);
            this.validConsole = validConsole;
        }

        public static string FlashVersionToString(uint version)
        {
            uint qfe=  (version&0x000000ff);
            uint build=(version&0x00ffff00)>>8;
            uint minor=(version&0x0f000000)>>24;
            uint major=(version&0xf0000000)>>28;
            return string.Format("{0:D2}.{1:D2}.{2:D5}.{3:D3}", major, minor, build, qfe);
        }
    }

    public enum ValidityTestsV3
    {
        NoConsoles,
        OneUpgrade,
        OneCorrect,
        OneUpgradeOneCorrect,
        OneUpgradeManyCorrect,
        ManyOneHopUpgrades,
        ManyMultiHopUpgrades,
        ManyMultiHopUpgradesWithInvalidPaths,
        OneInvalidUpgrade,
        OneInvalidDeadEndedConsole,
        OneValidOneInvalidUpgrade,
        OneCorrectOneInvalidUpgrade,
        OneInvalidDeadEndManyCorrect,
        OneInvalidDeadendManyUpgrade
    }


    public class ConsoleListFactoryV3
    {
        public static ConsoleListV3 GenerateConsoleList(ValidityTestsV3 test)
        {
            ConsoleListV3 cl = new ConsoleListV3();

            switch (test)
            {
                case ValidityTestsV3.NoConsoles: // No consoles, just one valid upgrade path
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(1000, 1000);
                    break;
                case ValidityTestsV3.OneUpgrade: // One console with an upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV3.OneCorrect:// One console that's at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    break;
                case ValidityTestsV3.OneUpgradeOneCorrect: // Two consoles, one at the correct version and one not
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV3.OneUpgradeManyCorrect: // A whole bunch of consoles at the correct version and one that can upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV3.ManyOneHopUpgrades: //A whole bunch of consoles at different versions with valid one-hop upgrades
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(800, 1000);
                    cl.AddVersion(700, 1000);
                    cl.AddVersion(600, 1000);
                    cl.AddVersion(500, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    cl.AddConsole(800);
                    cl.AddConsole(700);
                    cl.AddConsole(600);
                    cl.AddConsole(500);
                    break;
                case ValidityTestsV3.ManyMultiHopUpgrades: // A whole bunch of consoles with multi-hop upgrades
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(800, 900);
                    cl.AddVersion(700, 800);
                    cl.AddVersion(600, 700);
                    cl.AddVersion(500, 600);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(500);
                    cl.AddConsole(600);
                    cl.AddConsole(700);
                    cl.AddConsole(800);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV3.ManyMultiHopUpgradesWithInvalidPaths: // A whole bunch of consoles with multi-hop upgrades, with some invalid paths existing
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(950, 1050);
                    cl.AddVersion(800, 900);
                    cl.AddVersion(850, 950);
                    cl.AddVersion(700, 800);
                    cl.AddVersion(600, 700);
                    cl.AddVersion(650, 750);
                    cl.AddVersion(500, 600);
                    cl.AddVersion(550, 600);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(500);
                    cl.AddConsole(600);
                    cl.AddConsole(700);
                    cl.AddConsole(800);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV3.OneInvalidUpgrade: // One console with an invalid upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(950, false);
                    cl.isValid = false;
                    break;
                case ValidityTestsV3.OneInvalidDeadEndedConsole: // One console on an invalid dead end
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.isValid = false;
                    break;
                case ValidityTestsV3.OneValidOneInvalidUpgrade: // One console on an invalid dead end and one console that's got a valid upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(900);
                    cl.isValid = false;
                    break;
                case ValidityTestsV3.OneCorrectOneInvalidUpgrade: // One console on an invalid dead end and one console that's at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(1000);
                    cl.isValid = false;
                    break;
                case ValidityTestsV3.OneInvalidDeadEndManyCorrect: // One console on an invalid dead end and many consoles that are at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.isValid = false;
                    break;
                case ValidityTestsV3.OneInvalidDeadendManyUpgrade: // One console on an invalid dead end and many consoles that are at a valid upgrade version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.isValid = false;
                    break;
            }

            return cl;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\ValidateBetaGroupConsoles.cs ===
// Tests for the ValidateBetaGroupConsoles API

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using MIXTesting;
using System;
using System.Linq;
using System.Collections;
using xonline.mix.betamanagement.contracts.V4;
using System.Collections.Generic;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.config;



namespace MixTest
{

    [TestGroup, Owner("LukeL"), TestTag("OriginalOwner", "esebeni"), Description("ValidateBetaGroupConsoles Tests"), TestCasePriority(1)]
    public class ValidateBetaGroupConsoles : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            MIXTesting.Config.EnableAPIs(Interface.mixbetamanagement, "Xonline.Mix.BetaManagement.Service", "MixBetaManagement.ValidateBetaGroupConsoles");
        }

        static BetaManagementV4WCFClient client = new BetaManagementV4WCFClient();


        [TestCase, TestCasePriority(1)]
        class P_NoConsoles : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.NoConsoles);
            }
        }

        [TestCase, TestCasePriority(1)]
        class P_OneUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneUpgrade);
            }
        }

        [TestCase]
        class P_OneCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneCorrect);
            }
        }

        [TestCase]
        class P_OneUpgradeOneCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneUpgradeOneCorrect);
            }
        }

        [TestCase]
        class P_OneUpgradeManyCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneUpgradeManyCorrect);
            }
        }

        [TestCase]
        class P_ManyOneHopUpgrades : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.ManyOneHopUpgrades);
            }
        }

        [TestCase]
        class P_ManyMultiHopUpgrades : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.ManyMultiHopUpgrades);
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_ManyMultiHopUpgradesWithInvalidPaths : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.ManyMultiHopUpgradesWithInvalidPaths);
            }
        }

        [TestCase]
        class P_OneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneInvalidDeadEndedConsole : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneInvalidDeadEndedConsole);
            }
        }

        [TestCase]
        class P_OneValidOneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneValidOneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneCorrectOneInvalidUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneCorrectOneInvalidUpgrade);
            }
        }

        [TestCase]
        class P_OneInvalidDeadEndManyCorrect : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneInvalidDeadEndManyCorrect);
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_OneInvalidDeadendManyUpgrade : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.OneInvalidDeadendManyUpgrade);
            }
        }

        [TestCase]
        class P_DuplicateConsolesInvalid : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.DuplicateConsolesInvalid);
            }
        }

        [TestCase]
        class P_DuplicateConsolesValid : WCFTestBase
        {
            public override void Run()
            {
                ValidateGroup(ValidityTestsV4.DuplicateConsolesValid);
            }
        }

        private static void ValidateGroup(ValidityTestsV4 test)
        {
            ConsoleListV4 consoleList = ConsoleListFactoryV4.GenerateConsoleList(test);
            // Set up the beta group
            BetaGroupEditor bg = BetaGroupEditor.CreateNew();
            Global.RO.Debug("group: "+bg.Id);

            TitleEditor te = TitleEditor.FromId(XOn.XENON_DASH_TITLE_ID);

            // Set up the consoles
            foreach (BGMachineEditorV4 me in consoleList.Consoles)
            {
                bg.AddMachine(me.Editor.Id);
                Global.RO.Debug("machine: "+string.Format("0x{0:X}", me.Editor.Id));
            }

            // Add the upgrade versions
            for (int i = 0; i < consoleList.BaseVersions.Count; i++)
            {
                te.AddVersion(consoleList.BaseVersions[i], consoleList.UpgradeVersions[i], 2, bg.Id); //2=xbox360
            }

            bool result = false;

            try
            {
                result = Validate(consoleList, bg.Id);
            }
            finally
            {
                // Tear down consoles
                //foreach (BGMachineEditor me in consoleList.Consoles) me.Editor.CompletelyRemoveMachine();

                // Tear down BetaGroup
                //BetaGroupEditor.NukeGroup(bg.Id);
            }

            if (!result)
            {
                throw new UnexpectedTestResultException("Group result verification failed.");
            }

        }

        private static bool Validate(ConsoleListV4 consoleList, Guid guid)
        {
            IEnumerable<InvalidConsole> expected = consoleList.GetInvalidConsoles();
            InvalidConsole[] actual = client.ValidateBetaGroupConsoles(guid);

            Global.RO.Debug("Returned from server: ");
            foreach (InvalidConsole ret in actual)
            {
                Global.RO.Debug("Console="+BetaManagementUtilsV4.ConsoleInfoString(ret.ConsoleIDWithSCode)+" FlashVersion="+ret.FlashVersion);
            }

            int actualCount = 0;
            int expectedCount = 0;
            foreach (InvalidConsole ec in expected)
            {
                expectedCount++;
                bool found = false;
                foreach (InvalidConsole ac in actual)
                {
                    if (ec.FlashVersion == ac.FlashVersion && BetaManagementUtilsV4.ConsoleInfoEquals(ec.ConsoleIDWithSCode, ac.ConsoleIDWithSCode))
                    {
                        found = true;
                        actualCount++;
                        break;
                    }
                }
                if (!found)
                {
                    Global.RO.Error("Could not find Console {0} with flash version {1} in the list of invalid consoles found on the server.", BetaManagementUtilsV4.ConsoleInfoString(ec.ConsoleIDWithSCode), ec.FlashVersion);
                }
            }

            if (actualCount != expectedCount) return false;

            // Now, do the reverse check

            actualCount = 0;
            expectedCount = 0;

            foreach (InvalidConsole ac in actual)
            {
                actualCount++;
                bool found = false;
                foreach (InvalidConsole ec in expected)
                {
                    if (ec.FlashVersion == ac.FlashVersion && BetaManagementUtilsV4.ConsoleInfoEquals(ec.ConsoleIDWithSCode, ac.ConsoleIDWithSCode))
                    {
                        found = true;
                        expectedCount++;
                        break;
                    }
                }
                if (!found)
                {
                    Global.RO.Error("Found unexpected Console {0} with flash version {1}.", BetaManagementUtilsV4.ConsoleInfoString(ac.ConsoleIDWithSCode), ac.FlashVersion);
                }
            }

            return actualCount == expectedCount;
        }

    }

    public class ConsoleListV4
    {
        public List<uint> BaseVersions = new List<uint>();
        public List<uint> UpgradeVersions = new List<uint>();
        public List<BGMachineEditorV4> Consoles = new List<BGMachineEditorV4>();
        public bool isValid = true;

        public void AddVersion(uint baseVersion, uint upgradeVersion)
        {
            BaseVersions.Add(baseVersion);
            UpgradeVersions.Add(upgradeVersion);
        }
        
        public void AddConsole(uint flashVersion)
        {
            AddConsole(flashVersion, true);
        }

        public void AddConsole(uint flashVersion, bool validConsole)
        {
            BGMachineEditorV4 me = new BGMachineEditorV4(flashVersion, validConsole);
            Consoles.Add(me);
        }

        public void AddConsoleDuplicatesPair(uint flashVersion, bool validConsole)
        {
            BGMachineEditorV4 me0 = new BGMachineEditorV4(flashVersion, validConsole);
            Consoles.Add(me0);

            BGMachineEditorV4 me1 = new BGMachineEditorV4(me0.Editor.ConsoleId, flashVersion, validConsole);
            Consoles.Add(me1);
        }

        internal IEnumerable<InvalidConsole> GetInvalidConsoles()
        {
            foreach (BGMachineEditorV4 me in Consoles)
            {
                if (!me.validConsole)
                {
                    InvalidConsole c = new InvalidConsole();
                    c.ConsoleIDWithSCode = BetaManagementUtilsV4.MakeConsoleInfo(me.Editor);
                    c.FlashVersion = FlashStringToVersion(me.Editor.ClientFlashVersion);
                    yield return c;
                }
            }
        }

        public static uint FlashStringToVersion(string version)
        {
            //break it up and pull out the parts
            string []parts=version.Split(new char[]{'.'});
            if (parts.Length!=4)
            {
                throw new System.Exception("Bad version string.");
            }

            uint qfe=  uint.Parse(parts[3]);
            uint build=uint.Parse(parts[2]);
            uint minor=uint.Parse(parts[1]);
            uint major=uint.Parse(parts[0]);

            //validate ranges
            if ((qfe&  ~0xff)  !=0) throw new System.Exception("Bad value for qfe.");
            if ((build&~0xffff)!=0) throw new System.Exception("Bad value for build.");
            if ((minor&~0xf)   !=0) throw new System.Exception("Bad value for minor.");
            if ((major&~0xf)   !=0) throw new System.Exception("Bad value for major.");

            //build
            uint number=0;
            number|=qfe;
            number|=build<<8;
            number|=minor<<24;
            number|=major<<28;
            return number;
        }
    }

    public class BGMachineEditorV4
    {
        public MachineEditor Editor;
        public bool validConsole = true;

        public BGMachineEditorV4(uint flashVersion, bool validConsole)
        {
            Editor = MachineEditor.CreateNew();
            Editor.ClientFlashVersion = FlashVersionToString(flashVersion);
            this.validConsole = validConsole;
        }

        public BGMachineEditorV4(string duplicateOf, uint flashVersion, bool validConsole)
        {
            Editor = MachineEditor.CreateDuplicateXbox360(duplicateOf);
            Editor.ClientFlashVersion = FlashVersionToString(flashVersion);
            this.validConsole = validConsole;
        }

        public static string FlashVersionToString(uint version)
        {
            uint qfe=  (version&0x000000ff);
            uint build=(version&0x00ffff00)>>8;
            uint minor=(version&0x0f000000)>>24;
            uint major=(version&0xf0000000)>>28;
            return string.Format("{0:D2}.{1:D2}.{2:D5}.{3:D3}", major, minor, build, qfe);
        }
    }

    public enum ValidityTestsV4
    {
        NoConsoles,
        OneUpgrade,
        OneCorrect,
        OneUpgradeOneCorrect,
        OneUpgradeManyCorrect,
        ManyOneHopUpgrades,
        ManyMultiHopUpgrades,
        ManyMultiHopUpgradesWithInvalidPaths,
        OneInvalidUpgrade,
        OneInvalidDeadEndedConsole,
        OneValidOneInvalidUpgrade,
        OneCorrectOneInvalidUpgrade,
        OneInvalidDeadEndManyCorrect,
        OneInvalidDeadendManyUpgrade,
        DuplicateConsolesInvalid,
        DuplicateConsolesValid
    }


    public class ConsoleListFactoryV4
    {
        public static ConsoleListV4 GenerateConsoleList(ValidityTestsV4 test)
        {
            ConsoleListV4 cl = new ConsoleListV4();

            switch (test)
            {
                case ValidityTestsV4.NoConsoles: // No consoles, just one valid upgrade path
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(1000, 1000);
                    break;
                case ValidityTestsV4.OneUpgrade: // One console with an upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV4.OneCorrect:// One console that's at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    break;
                case ValidityTestsV4.OneUpgradeOneCorrect: // Two consoles, one at the correct version and one not
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV4.OneUpgradeManyCorrect: // A whole bunch of consoles at the correct version and one that can upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV4.ManyOneHopUpgrades: //A whole bunch of consoles at different versions with valid one-hop upgrades
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(800, 1000);
                    cl.AddVersion(700, 1000);
                    cl.AddVersion(600, 1000);
                    cl.AddVersion(500, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(900);
                    cl.AddConsole(800);
                    cl.AddConsole(700);
                    cl.AddConsole(600);
                    cl.AddConsole(500);
                    break;
                case ValidityTestsV4.ManyMultiHopUpgrades: // A whole bunch of consoles with multi-hop upgrades
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(800, 900);
                    cl.AddVersion(700, 800);
                    cl.AddVersion(600, 700);
                    cl.AddVersion(500, 600);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(500);
                    cl.AddConsole(600);
                    cl.AddConsole(700);
                    cl.AddConsole(800);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV4.ManyMultiHopUpgradesWithInvalidPaths: // A whole bunch of consoles with multi-hop upgrades, with some invalid paths existing
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(950, 1050);
                    cl.AddVersion(800, 900);
                    cl.AddVersion(850, 950);
                    cl.AddVersion(700, 800);
                    cl.AddVersion(600, 700);
                    cl.AddVersion(650, 750);
                    cl.AddVersion(500, 600);
                    cl.AddVersion(550, 600);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(500);
                    cl.AddConsole(600);
                    cl.AddConsole(700);
                    cl.AddConsole(800);
                    cl.AddConsole(900);
                    break;
                case ValidityTestsV4.OneInvalidUpgrade: // One console with an invalid upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(950, false);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.OneInvalidDeadEndedConsole: // One console on an invalid dead end
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.OneValidOneInvalidUpgrade: // One console on an invalid dead end and one console that's got a valid upgrade
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(900);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.OneCorrectOneInvalidUpgrade: // One console on an invalid dead end and one console that's at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(1000);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.OneInvalidDeadEndManyCorrect: // One console on an invalid dead end and many consoles that are at the correct version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.AddConsole(1000);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.OneInvalidDeadendManyUpgrade: // One console on an invalid dead end and many consoles that are at a valid upgrade version
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsole(960, false);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.AddConsole(900);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.DuplicateConsolesInvalid: //a pair of duplicates that are invalid
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(950, 960);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsoleDuplicatesPair(950, false);
                    cl.isValid = false;
                    break;
                case ValidityTestsV4.DuplicateConsolesValid: //a pair of duplicates that are valid
                    cl.AddVersion(0, 1000);
                    cl.AddVersion(900, 1000);
                    cl.AddVersion(1000, 1000);
                    cl.AddConsoleDuplicatesPair(900, true);
                    break;
            }

            return cl;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\titleversions.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using System.IO;
using System;

// 
// This source code was auto-generated by xsd, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
[System.Xml.Serialization.XmlRootAttribute(Namespace="", IsNullable=false)]
public partial class Version : IEquatable<Version>
{
    
    private uint titleIDField;
    
    private bool titleIDFieldSpecified;
    
    private uint baseField;
    
    private bool baseFieldSpecified;
    
    private uint upgradeField;
    
    private bool upgradeFieldSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public uint titleID {
        get {
            return this.titleIDField;
        }
        set {
            this.titleIDField = value;
        }
    }
    
    /// <remarks/> 
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool titleIDSpecified {
        get {
            return this.titleIDFieldSpecified;
        }
        set {
            this.titleIDFieldSpecified = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public uint baseVersion {
        get {
            return this.baseField;
        }
        set {
            this.baseField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool baseSpecified {
        get {
            return this.baseFieldSpecified;
        }
        set {
            this.baseFieldSpecified = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public uint upgradeVersion {
        get {
            return this.upgradeField;
        }
        set {
            this.upgradeField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool upgradeSpecified {
        get {
            return this.upgradeFieldSpecified;
        }
        set {
            this.upgradeFieldSpecified = value;
        }
    }

    public static explicit operator Version(ServerTestFramework.Database.TitleEditor.TitleVersion tv)
    {
        Version v = new Version();
        v.titleID = 0;
        v.baseVersion = tv.BaseVersion;
        v.upgradeVersion = tv.UpgradeVersion;
        return v;
    }
    
    public bool Equals(Version v)
    {
        return (v.titleID == this.titleID
            && v.upgradeField == this.upgradeField
            && v.baseField == this.baseField);
    }

}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
[System.Xml.Serialization.XmlRootAttribute(Namespace="", IsNullable=false)]
public partial class TitleUpgradeTests {

    private TitleUpgradeTest[] itemsField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("TitleUpgradeTest", typeof(TitleUpgradeTest), Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public TitleUpgradeTest[] Items
    {
        get {
            return this.itemsField;
        }
        set {
            this.itemsField = value;
        }
    }

    public static TitleUpgradeTests Load(string s)
    {
        XmlSerializer xSer = new XmlSerializer(typeof(TitleUpgradeTests));
        using (StreamReader sr = new StreamReader(s))
        {
            return (TitleUpgradeTests)xSer.Deserialize(sr);
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
public partial class TitleUpgradeTest {
    
    private Version[] startVersionsField;
    
    private UpdateVersion updateVersionField;
    
    private Version[] expectedVersionsField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    [System.Xml.Serialization.XmlArrayItemAttribute("Version", IsNullable=false)]
    public Version[] StartVersions {
        get {
            return this.startVersionsField;
        }
        set {
            this.startVersionsField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public UpdateVersion UpdateVersion {
        get {
            return this.updateVersionField;
        }
        set {
            this.updateVersionField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    [System.Xml.Serialization.XmlArrayItemAttribute("Version", IsNullable=false)]
    public Version[] ExpectedVersions {
        get {
            return this.expectedVersionsField;
        }
        set {
            this.expectedVersionsField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
public partial class UpdateVersion {
    
    private Version versionField;
    
    /// <remarks/>
    public Version Version {
        get {
            return this.versionField;
        }
        set {
            this.versionField = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementUnitTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementUnitTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\BetaManagementUnitTest\BetaManagementUnitTest.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using ServerTestFramework;

using xonline.common.service;
using xonline.mix.betamanagement.service;
using ServerTestFramework.Database;

using LiveRegistrySetting = xonline.mix.betamanagement.service.LiveRegistrySetting;

namespace xonline.mix.betamanagement.unittest
{
    internal class BetaManagementDatabaseMockBase : IBetaManagementDatabase
    {
        // Group management...
        public virtual void CreateGroup(Guid betaId, string name, string creator) { throw new NotImplementedException(); }
        public virtual IEnumerable<GroupSummary> GetGroupSummaries() { throw new NotImplementedException(); }        
        public virtual GroupSummary GetGroupSummary(Guid groupId) { throw new NotImplementedException(); }
        public virtual bool DoesGroupDefinitionExist(Guid groupId) { throw new NotImplementedException(); }
        public virtual IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId) { throw new NotImplementedException(); }
        public virtual IEnumerable<LiveRegistrySetting> GetLiveRegistrySettings(Guid groupId) { throw new NotImplementedException(); }
        public virtual void RemoveLiveRegistrySettingsForGroup(Guid groupId) { throw new NotImplementedException(); }
        public virtual void RemoveReleasesForGroup(Guid groupId) { throw new NotImplementedException(); }
        public virtual IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId) { throw new NotImplementedException(); }
        public virtual IEnumerable<string> GetAllGroupNames() { throw new NotImplementedException(); }
        public virtual void RemoveGroupDefinition(Guid groupId) { throw new NotImplementedException(); }
        public virtual void UpdateGroupName(Guid groupId, string name) { throw new NotImplementedException(); }
        public virtual void AssignReleaseToGroup(Guid group, string systemOnlineManifestRevision, string systemManifestRevision, uint version) { throw new NotImplementedException(); }
        public virtual void AddRelease(ReleaseApp app) { throw new NotImplementedException(); }

        // Machine management...
        public virtual IEnumerable<Guid> GetMachineMembership(ulong machinePuid) { throw new NotImplementedException(); }
        public virtual void AddMachinePuidToGroup(ulong machinePuid, Guid groupId) { throw new NotImplementedException(); }
        public virtual void RemoveMachinePuidFromGroup(ulong machinePuid, Guid groupId) { throw new NotImplementedException(); }
        public virtual GroupMembershipChangeOutcome TryLookupMachinePuid(string consoleId, out Puid machinePuid) { throw new NotImplementedException(); }
        public virtual GroupMembershipChangeOutcome TryLookupMachinePuid(string consoleId, string scode, out Puid machinePuid) { throw new NotImplementedException(); }
        public virtual GroupMembershipChangeOutcome TryLookupMachinePuid(ConsoleInfo consoleInfo, out Puid machinePuid) { throw new NotImplementedException(); }
        public virtual GroupMembershipChangeOutcome TryLookupMachinePuids(string consoleId, out Puid[] machinePuids) { throw new NotImplementedException(); }
        public virtual GroupMembershipChangeOutcome TryLookupMachinePuids(ConsoleInfo consoleInfo, out ConsoleInfoDetailed[] consoleInfosDetailed) { throw new NotImplementedException(); }

        public virtual IEnumerable<string> GetConsoleIDsInGroup(Guid groupId) { throw new NotImplementedException(); }
        public virtual IEnumerable<ConsoleInfo> GetConsoleInfosInGroup(Guid groupId) { throw new NotImplementedException(); }
        public virtual bool MoveMachinePuidBetweenGroups (ulong machinePuid, Guid fromGroup, Guid toGroup) { throw new NotImplementedException(); }

        // Title management...
        public virtual void AddTitleVersionInfo(uint minVersion, uint currentFlashVersion, Guid group, uint titleID) { throw new NotImplementedException(); }
        public virtual bool GetIsFlashVersionPropped(uint flashVersion) { throw new NotImplementedException(); }
        public virtual void RemoveTitleVersionForGroup(Guid groupId) { throw new NotImplementedException(); }
}

    internal class GroupSummaryEqualityComparer : IEqualityComparer<GroupSummary>
    {
        public bool Equals(GroupSummary x, GroupSummary y)
        {
            return x.Name == y.Name
                    && x.GroupGuid == y.GroupGuid
                    && x.Creator == y.Creator
                    && x.Created == y.Created
                    && x.FlashVersion == y.FlashVersion;
        }

        public int GetHashCode(GroupSummary obj)
        {
            return obj.GetHashCode();
        }
    }

    internal class UpgradePathEqualityComparer : IEqualityComparer<UpgradePath>
    {
        public bool Equals(UpgradePath x, UpgradePath y)
        {
            return x.TitleId == y.TitleId
                    && x.ConsoleType == y.ConsoleType
                    && x.BaseVersion == y.BaseVersion
                    && x.UpgradeVersion == y.UpgradeVersion;
        }

        public int GetHashCode(UpgradePath obj)
        {
            return obj.GetHashCode();
        }
    }

    internal class ReleaseInfoEqualityComparer : IEqualityComparer<ReleaseInfo>
    {
        public bool Equals(ReleaseInfo x, ReleaseInfo y)
        {
            return x.FlashVersion == y.FlashVersion
                    && x.FlashQfe == y.FlashQfe
                    && x.SMRevision == y.SMRevision
                    && x.SOMRevision == y.SOMRevision;
        }

        public int GetHashCode(ReleaseInfo obj)
        {
            return obj.GetHashCode();
        }
    }

    public static class GroupMgmtTestUtil
    {
        public static GroupSummary MakeGroupSummary(long seed)
        {
            return MakeGroupSummary(seed, 0);
        }

        public static GroupSummary MakeGroupSummary(long seed, uint flashVersion)
        {
            GroupSummary summary = new GroupSummary();
            summary.Name = String.Format("testgroup{0}", seed);
            summary.GroupGuid = MakeGuid(seed);
            summary.Creator = String.Format("testcreator{0}", seed);
            summary.Created = DateTime.MinValue + new TimeSpan(0, 0, (int)seed);
            summary.FlashVersion = flashVersion;

            return summary;
        }

        public static void DumpExpectedGotGroupSummaries(IEnumerable<GroupSummary> expected, IEnumerable<GroupSummary> got)
        {
            Global.RO.Info("Expected:");
            DumpGroupSummaries(expected);
            Global.RO.Info("Got:");
            DumpGroupSummaries(got);
        }

        public static string FormatGroupSummary(GroupSummary groupSummary)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine();
            sb.AppendLine(String.Format("\tName:\t{0}", groupSummary.Name));
            sb.AppendLine(String.Format("\tGroupGuid:\t{0:B}", groupSummary.GroupGuid));
            sb.AppendLine(String.Format("\tCreator:\t{0}", groupSummary.Creator));
            sb.AppendLine(String.Format("\tCreated:\t{0}", groupSummary.Created));
            sb.AppendLine(String.Format("\tFlashVersion:\t{0}", groupSummary.FlashVersion));
            return sb.ToString();
        }

        public static Guid MakeGuid(long lastPart)
        {
            return new Guid(String.Format("DEADBEEF-CAFE-BABE-F00D-{0:X12}", lastPart));
        }

        public static void DumpGroupSummaries(IEnumerable<GroupSummary> groupSummaries)
        {
            int num = 1;
            foreach (GroupSummary groupSummary in groupSummaries)
            {
                Global.RO.Info("Group Summary number {0}", num);
                Global.RO.Info(FormatGroupSummary(groupSummary));
                Global.RO.Info("\n");
                ++num;
            }
        }

        public static UpgradePath MakeUpgradePath(uint baseVersion, uint upgradeVersion)
        {
            UpgradePath upgradePath = new UpgradePath();
            upgradePath.BaseVersion = baseVersion;
            upgradePath.UpgradeVersion = upgradeVersion;
            return upgradePath;
        }

        public static ReleaseInfo MakeReleaseInfo(short flashVersion, short flashQfe)
        {
            ReleaseInfo releaseInfo = new ReleaseInfo();
            releaseInfo.FlashVersion = flashVersion;
            releaseInfo.FlashQfe = flashQfe;
            releaseInfo.SMRevision = String.Format("Fake SMRevision {0}{1}", flashVersion, flashQfe);
            releaseInfo.SOMRevision = String.Format("Fake SOMRevision {0}{1}", flashVersion, flashQfe);
            return releaseInfo;
        }

        public static LiveRegistrySetting MakeSetting(short flashVersion, short flashQfe, string setting, string value)
        {
            LiveRegistrySetting lrs = new LiveRegistrySetting();
            lrs.Build = flashVersion;
            lrs.Qfe = flashQfe;
            lrs.Setting = setting;
            lrs.Value = value;
            return lrs;
        }

        public static void DumpGroups(IEnumerable<Group> groups)
        {
            int num = 1;
            foreach (Group group in groups)
            {
                Global.RO.Info("Group Summary number {0}", num);
                Global.RO.Info(FormatGroupDetails(group));
                Global.RO.Info("\n");
                ++num;
            }
        }

        public static string FormatGroupDetails(Group groupDetails)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("Summary:");
            sb.AppendLine(FormatGroupSummary(groupDetails.Summary));
            sb.AppendLine("Titles:");
            int num = 0;
            foreach (UpgradePath path in groupDetails.Titles)
            {
                sb.AppendLine(String.Format("Upgrade Path number {0}: 0x{1:X8}, {2}, {3}, {4}", num, path.TitleId, path.ConsoleType, path.BaseVersion, path.UpgradeVersion));
                ++num;
            }
            sb.AppendLine("ReleaseInfos:");
            num = 0;
            foreach (ReleaseInfo release in groupDetails.RelInfos)
            {
                sb.AppendLine(string.Format("Release Info number {0}: {1}, {2}, {3}, {4}", num, release.FlashVersion, release.FlashQfe, release.SMRevision, release.SOMRevision));
                ++num;
            }
            return sb.ToString();
        }
    }


    /// <summary>
    /// Unit tests for the Group Management api internals. The intent here is that these are
    /// explicitly not end-to-end tests.
    /// </summary>
    [TestGroup, Owner("TobiasB"), Description("Unit tests for the Group Management apis."), DVT]
    public class BetaManagementUnitTest : TestNode
    {
        /// <summary>
        /// Super-basic tests like object creation to make sure we have the dlls dropped in the correct folder and everything.
        /// </summary>
        [TestGroup, Owner("TobiasB"), Description("Basic unit tests.")]
        public class Basic : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Tests that we can create a BetaManager object at all.")]
            public class GetBetaManagerObject : TestNode
            {
                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMockBase());
                    if (betaManager == null)
                    {
                        throw new UnexpectedTestResultException("Failed to get betaManager object.");
                    }
                    Global.RO.Info("Successfully got a BetaManager: {0}", betaManager);
                }
            }

            [TestCase, Owner("TobiasB"), Description("Tests that you can actually create a UodbBetaManagementDatabase object.")]
            public class GetUodbBetaManagementDatabase : TestNode
            {
                public override void Run()
                {
                    UodbBetaManagementDatabase uodb = new UodbBetaManagementDatabase();

                    // Failure should throw.
                }
            }
        }

        /// <summary>
        /// Tests for BetaManager.GetGroups
        /// </summary>
        [TestGroup, Owner("TobiasB"), Description("Tests for BetaManager.GetGroups.")]
        public class GetGroups : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Mocked testing for BetaManager.GetGroups with upgrade paths.")]
            [CompoundCase("WithUpgradesV1", true, true)]
            [CompoundCase("WithUpgradesV2", false, true)]
            [CompoundCase("NoUpgradesV1", true, false)]
            [CompoundCase("NoUpgradesV2", false, false)]
            public class GetGroupsWithUpgradesMocked : TestNode
            {
                private class BetaManagementDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public const uint FLASHVERSION = 4;
                    public const long NUMGROUPS = 5;

                    public BetaManagementDatabaseMock(bool useUpgrades)
                    {
                        _originalGroups = new List<GroupSummary>();
                        for (long group = 0; group < NUMGROUPS; ++group)
                        {
                            _originalGroups.Add(GroupMgmtTestUtil.MakeGroupSummary(group));
                        }

                        _upgradePaths = new Dictionary<Guid, IEnumerable<UpgradePath>>();
                        for (int idx = 0; idx < _originalGroups.Count; ++idx)
                        {
                            List<UpgradePath> paths = new List<UpgradePath>();
                            if (useUpgrades)
                            {
                                paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 2));
                                paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 2));
                                paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 4));
                                paths.Add(GroupMgmtTestUtil.MakeUpgradePath(3, 3));
                                paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 4));
                            }
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(4, 4));
                            _upgradePaths[_originalGroups[idx].GroupGuid] = paths;
                        }
                    }

                    public override IEnumerable<GroupSummary> GetGroupSummaries()
                    {
                        return _originalGroups;
                    }
                    
                    public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                    {
                        return _upgradePaths[groupId];
                    }

                    private List<GroupSummary> _originalGroups;
                    private Dictionary<Guid, IEnumerable<UpgradePath>> _upgradePaths;
                }

                public override void Run()
                {
                    bool useFlash = (bool)MyValues[0];
                    bool withUpgrades = (bool)MyValues[1];
                    uint expectedFlashVersion = useFlash ? BetaManagementDatabaseMock.FLASHVERSION : 0;

                    List<GroupSummary> expectedGroups = new List<GroupSummary>();
                    for (long group = 0; group < BetaManagementDatabaseMock.NUMGROUPS; ++group)
                    {
                        expectedGroups.Add(GroupMgmtTestUtil.MakeGroupSummary(group, expectedFlashVersion));
                    }

                    BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock(withUpgrades));
                    IEnumerable<GroupSummary> actualGroups = betaManager.GetGroups(useFlash);

                    GroupMgmtTestUtil.DumpExpectedGotGroupSummaries(expectedGroups, actualGroups);

                    // Check sizes...
                    if (Enumerable.Count(actualGroups) != expectedGroups.Count)
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected {0} results, got {1}.", expectedGroups.Count, Enumerable.Count(actualGroups)));
                    }

                    // Now make sure we got everything we expected. Note that we don't expect the order to be perserved necessarily.
                    foreach (GroupSummary groupSummary in expectedGroups)
                    {
                        if (!Enumerable.Contains(actualGroups, groupSummary, new GroupSummaryEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Didn't find group \n{0}\n in results.", GroupMgmtTestUtil.FormatGroupSummary(groupSummary)));
                        }
                    }
                }
            }

            [TestCase, Owner("TobiasB"), Description("Real testing for BetaManager.GetGroups.")]
            [CompoundCase("V1", true)]
            [CompoundCase("V2", false)]
            public class GetGroupsReal : TestNode
            {
                private BetaGroupEditor[] _bges = new BetaGroupEditor[0];
                private TitleEditor _titleEditor;

                private const uint FLASH_TITLE_ID = 0xFFFE07D1;
                private const uint MIN_VERSION = 1;
                private const uint MAX_VERSION = 3;

                public override void PreRun()
                {
                    _titleEditor = TitleEditor.CreateOrUseExistingId(FLASH_TITLE_ID);

                    _bges = new BetaGroupEditor[3];
                    for (int idx = 0; idx < _bges.Length; ++idx)
                    {
                        _bges[idx] = BetaGroupEditor.CreateNew();
                        for (uint ver = MIN_VERSION; ver <= MAX_VERSION; ++ver)
                        {
                            _titleEditor.AddVersion(ver, MAX_VERSION, 2, _bges[idx].Id);
                        }
                    }
                }

                public override void Run()
                {
                    bool useFlash = (bool)MyValues[0];
                    uint expectedFlashVersion = useFlash ? MAX_VERSION : 0;

                    BetaManager betaManager = BetaManager.GetInstance(new UodbBetaManagementDatabase());
                    IEnumerable<GroupSummary> actualGroups = betaManager.GetGroups(useFlash);
                    List<GroupSummary> expectedGroups = new List<GroupSummary>();
                    foreach (BetaGroupEditor bge in _bges)
                    {
                        expectedGroups.Add(GroupSummaryFromBetaGroupEditor(bge, expectedFlashVersion));
                    }
                    GroupMgmtTestUtil.DumpExpectedGotGroupSummaries(expectedGroups, actualGroups);

                    // Check the length is the same.
                    if (Enumerable.Count(actualGroups) < _bges.Length)
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected at least {0} groups, got {1}.", _bges.Length, Enumerable.Count(actualGroups)));
                    }

                    // Check that the items we expect are really there.
                    foreach (GroupSummary expectedGroup in expectedGroups)
                    {
                        if (!Enumerable.Contains(actualGroups, expectedGroup, new GroupSummaryEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected to find group \n{0}\n", GroupMgmtTestUtil.FormatGroupSummary(expectedGroup)));
                        }
                    }
                }

                public override void PostRun()
                {
                    foreach (BetaGroupEditor bge in _bges)
                    {
                        BetaGroupEditor.NukeGroup(bge.Id);
                    }
                }

                private GroupSummary GroupSummaryFromBetaGroupEditor(BetaGroupEditor bge, uint expectedFlashVersion)
                {
                    GroupSummary groupSummary = new GroupSummary();
                    groupSummary.Name = bge.Name;
                    groupSummary.GroupGuid = bge.Id;
                    groupSummary.Creator = bge.Creator;
                    groupSummary.Created = bge.Created;
                    groupSummary.FlashVersion = expectedFlashVersion;

                    return groupSummary;
                }
            }
        }

        /// <summary>
        /// Tests BetaManager.GetGroupDetails.
        /// </summary>
        [TestGroup, Owner("TobiasB"), Description("Tests calls to GetGroupDetails.")]
        public class GetGroupDetails : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Calls GetGroupDetails with a mock object.")]
            public class GetGroupDetailsMocked : TestNode
            {
                private class BetaManagementDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public const uint FLASHVERSION = 4;
                    public const long NUMGROUPS = 5;

                    public BetaManagementDatabaseMock()
                    {
                        _upgradePaths = new Dictionary<Guid, IEnumerable<UpgradePath>>();
                        _settings = new Dictionary<Guid, IEnumerable<LiveRegistrySetting>>();
                        for (int idx = 0; idx < NUMGROUPS; ++idx)
                        {
                            Guid groupId = GroupMgmtTestUtil.MakeGuid(idx);

                            List<UpgradePath> paths = new List<UpgradePath>();
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 2));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 2));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 4));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(3, 3));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 4));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(4, 4));
                            _upgradePaths[groupId] = paths;

                            List<LiveRegistrySetting> set = new List<LiveRegistrySetting>();
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "SMRevision", "Fake SMRevision 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "SOMRevision", "Fake SOMRevision 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "neither", "fake 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "SMRevision", "Fake SMRevision 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "SOMRevision", "Fake SOMRevision 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "neither", "fake 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "SMRevision", "Fake SMRevision 41"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "SOMRevision", "Fake SOMRevision 41"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "neither", "fake 41"));
                            _settings[groupId] = set;
                        }
                    }

                    public override IEnumerable<GroupSummary> GetGroupSummaries()
                    {
                        throw new NotImplementedException();
                    }

                    public override GroupSummary GetGroupSummary(Guid groupId)
                    {
                        return GroupMgmtTestUtil.MakeGroupSummary(0);
                    }

                    public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                    {
                        return _upgradePaths[groupId];
                    }

                    public override IEnumerable<LiveRegistrySetting> GetLiveRegistrySettings(Guid groupId)
                    {
                        return _settings[groupId];
                    }

                    private Dictionary<Guid, IEnumerable<UpgradePath>> _upgradePaths;
                    Dictionary<Guid, IEnumerable<LiveRegistrySetting>> _settings;
                }

                public override void Run()
                {
                    List<GroupSummary> expectedGroups = new List<GroupSummary>();
                    for (long group = 0; group < BetaManagementDatabaseMock.NUMGROUPS; ++group)
                    {
                        expectedGroups.Add(GroupMgmtTestUtil.MakeGroupSummary(group, BetaManagementDatabaseMock.FLASHVERSION));
                    }

                    Dictionary<Guid, IEnumerable<ReleaseInfo>> releaseInfos = new Dictionary<Guid, IEnumerable<ReleaseInfo>>();
                    for (int idx = 0; idx < expectedGroups.Count; ++idx)
                    {
                        List<ReleaseInfo> releases = new List<ReleaseInfo>();
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(2, 1));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(3, 2));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(4, 1));

                        releaseInfos[expectedGroups[idx].GroupGuid] = releases;
                    }

                    BetaManagementDatabaseMock mock = new BetaManagementDatabaseMock();

                    BetaManager betaManager = BetaManager.GetInstance(mock);

                    Group groupDetails = betaManager.GetGroupDetails(expectedGroups[0].GroupGuid);

                    Global.RO.Info("Got group details:\n{0}", GroupMgmtTestUtil.FormatGroupDetails(groupDetails));

                    if (groupDetails == null)
                    {
                        throw new UnexpectedTestResultException("Didn't get a group details back.");
                    }

                    if (!(new GroupSummaryEqualityComparer().Equals(groupDetails.Summary, expectedGroups[0])))
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected group \n{0}\n, but got group \n{1}\n", GroupMgmtTestUtil.FormatGroupSummary(expectedGroups[0]), GroupMgmtTestUtil.FormatGroupSummary(groupDetails.Summary)));
                    }

                    // Make sure all the upgrade versions we put in are present.
                    IEnumerable<UpgradePath> actualUpgradePaths = groupDetails.Titles;
                    foreach (UpgradePath upgradePath in mock.GetFlashUpgradePaths(expectedGroups[0].GroupGuid))
                    {
                        if (!Enumerable.Contains(actualUpgradePaths, upgradePath, new UpgradePathEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected to find upgrade path from version {0} to {1}.", upgradePath.BaseVersion, upgradePath.ConsoleType));
                        }
                    }

                    // Make sure all the release infos we put in are present.
                    IEnumerable<ReleaseInfo> actualReleaseInfos = groupDetails.RelInfos;
                    foreach (ReleaseInfo release in releaseInfos[expectedGroups[0].GroupGuid])
                    {
                        if (!Enumerable.Contains(actualReleaseInfos, release, new ReleaseInfoEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected to find release info with values {0}, {1}, {2}, {3}.", release.FlashVersion, release.FlashQfe, release.SMRevision, release.SOMRevision));
                        }
                    }
                }
            }

            [TestCase, Owner("TobiasB"), Description("Calls GetGroupDetails hitting the real DB.")]
            public class GetGroupDetailsReal : TestNode
            {
                private BetaGroupEditor[] _bges = new BetaGroupEditor[0];
                private TitleEditor _titleEditor;
                private List<UpgradePath> _expectedUpgrades = new List<UpgradePath>();
                Dictionary<Guid, IEnumerable<ReleaseInfo>> _releaseInfos = new Dictionary<Guid, IEnumerable<ReleaseInfo>>();

                private const uint FLASH_TITLE_ID = 0xFFFE07D1;
                private const uint MIN_VERSION = 1;
                private const uint MAX_VERSION = 3;
                private const string MANUAL_INSERT_GROUP = "INSERT INTO t_live_registry_settings (vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value, guid_beta_group_id)"
                                                            + " VALUES ('{0}', '{1}', {2}, {3}, '{4}', '{5}', '{6}')";


                public override void PreRun()
                {
                    _titleEditor = TitleEditor.CreateOrUseExistingId(FLASH_TITLE_ID);

                    _bges = new BetaGroupEditor[3];
                    for (int idx = 0; idx < _bges.Length; ++idx)
                    {
                        _bges[idx] = BetaGroupEditor.CreateNew();
                        for (uint ver = MIN_VERSION; ver <= MAX_VERSION; ++ver)
                        {
                            _titleEditor.AddVersion(ver, MAX_VERSION, 2, _bges[idx].Id);
                            UpgradePath upgrade = new UpgradePath();
                            upgrade.TitleId = _titleEditor.Id;
                            upgrade.ConsoleType = (PlatformType)2;
                            upgrade.BaseVersion = ver;
                            upgrade.UpgradeVersion = MAX_VERSION;
                            _expectedUpgrades.Add(upgrade);
                        }
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 1, 1, "SMRevision", "Fake SMRevision 11", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 1, 1, "SOMRevision", "Fake SOMRevision 11", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 1, 1, "neighter", "Fake 11", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 2, 1, "SMRevision", "Fake SMRevision 21", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 2, 1, "SOMRevision", "Fake SOMRevision 21", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 2, 1, "neighter", "Fake 21", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 3, 1, "SMRevision", "Fake SMRevision 31", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 3, 1, "SOMRevision", "Fake SOMRevision 31", _bges[idx].Id));
                        StaticNpdb.ExecuteNonQuery(String.Format(MANUAL_INSERT_GROUP, "xblob", "xenon", 3, 1, "neighter", "Fake 31", _bges[idx].Id));
                        List<ReleaseInfo> releases = new List<ReleaseInfo>();
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(1, 1));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(2, 1));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(3, 1));
                        _releaseInfos[_bges[idx].Id] = releases;
                    }
                }

                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new UodbBetaManagementDatabase());
                    Group groupDetails = betaManager.GetGroupDetails(_bges[0].Id);

                    Global.RO.Info("Got group details:\n{0}", GroupMgmtTestUtil.FormatGroupDetails(groupDetails));

                    if (groupDetails == null)
                    {
                        throw new UnexpectedTestResultException("Didn't get a group details back.");
                    }

                    if (!(new GroupSummaryEqualityComparer().Equals(groupDetails.Summary, GroupSummaryFromBetaGroupEditor(_bges[0]))))
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected group \n{0}\n, but got group \n{1}\n", GroupMgmtTestUtil.FormatGroupSummary(GroupSummaryFromBetaGroupEditor(_bges[0])), GroupMgmtTestUtil.FormatGroupSummary(groupDetails.Summary)));
                    }

                    // Make sure all the upgrade versions we put in are present.
                    IEnumerable<UpgradePath> actualUpgradePaths = groupDetails.Titles;
                    foreach (UpgradePath upgradePath in _expectedUpgrades)
                    {
                        if (!Enumerable.Contains(actualUpgradePaths, upgradePath, new UpgradePathEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected to find upgrade path from version {0} to {1}.", upgradePath.BaseVersion, upgradePath.ConsoleType));
                        }
                    }

                    // Make sure all the release infos we put in are present.
                    IEnumerable<ReleaseInfo> actualReleaseInfos = groupDetails.RelInfos;
                    foreach (ReleaseInfo release in _releaseInfos[_bges[0].Id])
                    {
                        if (!Enumerable.Contains(actualReleaseInfos, release, new ReleaseInfoEqualityComparer()))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected to find release info with values {0}, {1}, {2}, {3}.", release.FlashVersion, release.FlashQfe, release.SMRevision, release.SOMRevision));
                        }
                    }
                }

                public override void PostRun()
                {
                    foreach (BetaGroupEditor bge in _bges)
                    {
                        BetaGroupEditor.NukeGroup(bge.Id);
                    }
                }

                private GroupSummary GroupSummaryFromBetaGroupEditor(BetaGroupEditor bge)
                {
                    GroupSummary groupSummary = new GroupSummary();
                    groupSummary.Name = bge.Name;
                    groupSummary.GroupGuid = bge.Id;
                    groupSummary.Creator = bge.Creator;
                    groupSummary.Created = bge.Created;
                    groupSummary.FlashVersion = MAX_VERSION;

                    return groupSummary;
                }
            }
        }


        [TestGroup, Owner("TobiasB"), Description("Tests calls to GetGroupsDetails")]
        public class GetGroupsDetails : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Calls GetGroupsDetails with a mock object.")]
            public class GetGroupsDetailsMocked : TestNode
            {
                private class BetaManagementDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public const uint FLASHVERSION = 4;
                    public const long NUMGROUPS = 5;

                    public BetaManagementDatabaseMock()
                    {
                        _upgradePaths = new Dictionary<Guid, IEnumerable<UpgradePath>>();
                        _settings = new Dictionary<Guid, IEnumerable<LiveRegistrySetting>>();
                        _groupSummaries = new Dictionary<Guid, GroupSummary>();
                        for (int idx = 0; idx < NUMGROUPS; ++idx)
                        {
                            Guid groupId = GroupMgmtTestUtil.MakeGuid(idx);
                            _groupSummaries[groupId] = GroupMgmtTestUtil.MakeGroupSummary(idx, FLASHVERSION);

                            List<UpgradePath> paths = new List<UpgradePath>();
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 2));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 2));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(1, 4));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(3, 3));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(2, 4));
                            paths.Add(GroupMgmtTestUtil.MakeUpgradePath(4, 4));
                            _upgradePaths[groupId] = paths;

                            List<LiveRegistrySetting> set = new List<LiveRegistrySetting>();
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "SMRevision", "Fake SMRevision 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "SOMRevision", "Fake SOMRevision 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(2, 1, "neither", "fake 21"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "SMRevision", "Fake SMRevision 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "SOMRevision", "Fake SOMRevision 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(3, 2, "neither", "fake 32"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "SMRevision", "Fake SMRevision 41"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "SOMRevision", "Fake SOMRevision 41"));
                            set.Add(GroupMgmtTestUtil.MakeSetting(4, 1, "neither", "fake 41"));
                            _settings[groupId] = set;
                        }
                    }

                    public override IEnumerable<GroupSummary> GetGroupSummaries()
                    {
                        throw new NotImplementedException();
                    }

                    public override GroupSummary GetGroupSummary(Guid groupId)
                    {
                        return _groupSummaries[groupId];
                    }

                    public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                    {
                        return _upgradePaths[groupId];
                    }

                    public override IEnumerable<LiveRegistrySetting> GetLiveRegistrySettings(Guid groupId)
                    {
                        return _settings[groupId];
                    }

                    private Dictionary<Guid, IEnumerable<UpgradePath>> _upgradePaths;
                    private Dictionary<Guid, IEnumerable<LiveRegistrySetting>> _settings;
                    private Dictionary<Guid, GroupSummary> _groupSummaries;
                }

                public override void Run()
                {
                    List<GroupSummary> expectedGroups = new List<GroupSummary>();
                    for (long group = 0; group < BetaManagementDatabaseMock.NUMGROUPS; ++group)
                    {
                        expectedGroups.Add(GroupMgmtTestUtil.MakeGroupSummary(group, BetaManagementDatabaseMock.FLASHVERSION));
                    }

                    Dictionary<Guid, IEnumerable<ReleaseInfo>> releaseInfos = new Dictionary<Guid, IEnumerable<ReleaseInfo>>();
                    for (int idx = 0; idx < expectedGroups.Count; ++idx)
                    {
                        List<ReleaseInfo> releases = new List<ReleaseInfo>();
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(2, 1));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(3, 2));
                        releases.Add(GroupMgmtTestUtil.MakeReleaseInfo(4, 1));

                        releaseInfos[expectedGroups[idx].GroupGuid] = releases;
                    }

                    BetaManagementDatabaseMock mock = new BetaManagementDatabaseMock();

                    BetaManager betaManager = BetaManager.GetInstance(mock);

                    IEnumerable<Group> groupsDetails = betaManager.GetGroupsDetails(expectedGroups.Select(g => g.GroupGuid));

                    if (groupsDetails == null)
                    {
                        throw new UnexpectedTestResultException("Didn't get a group details back.");
                    }

                    Global.RO.Info("Got group details:\n{0}");
                    GroupMgmtTestUtil.DumpGroups(groupsDetails);

                    if (expectedGroups.Count() != groupsDetails.Count())
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected {0} groups, but got {1}.", expectedGroups.Count(), groupsDetails.Count()));
                    }

                    GroupSummaryEqualityComparer comparer = new GroupSummaryEqualityComparer();
                    foreach (GroupSummary group in expectedGroups)
                    {
                        if (!groupsDetails.Any(x => comparer.Equals(x.Summary, group)))
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected group \n{0}\n", GroupMgmtTestUtil.FormatGroupSummary(group)));
                        }

                        Group g = groupsDetails.First(x => comparer.Equals(x.Summary, group));

                        // Validate the flash version in the details.
                        if (g.FlashVersion != BetaManagementDatabaseMock.FLASHVERSION)
                        {
                            throw new UnexpectedTestResultException(String.Format("Expected group {0:B} to have version {1}, but it has version {2}.", g.Summary.GroupGuid, BetaManagementDatabaseMock.FLASHVERSION, g.FlashVersion));
                        }

                        // Make sure all the upgrade versions we put in are present.
                        IEnumerable<UpgradePath> actualUpgradePaths = g.Titles;
                        foreach (UpgradePath upgradePath in mock.GetFlashUpgradePaths(g.Summary.GroupGuid))
                        {
                            if (!Enumerable.Contains(actualUpgradePaths, upgradePath, new UpgradePathEqualityComparer()))
                            {
                                throw new UnexpectedTestResultException(String.Format("Expected to find upgrade path from version {0} to {1}.", upgradePath.BaseVersion, upgradePath.ConsoleType));
                            }
                        }

                        // Make sure all the release infos we put in are present.
                        IEnumerable<ReleaseInfo> actualReleaseInfos = g.RelInfos;
                        foreach (ReleaseInfo release in releaseInfos[g.Summary.GroupGuid])
                        {
                            if (!Enumerable.Contains(actualReleaseInfos, release, new ReleaseInfoEqualityComparer()))
                            {
                                throw new UnexpectedTestResultException(String.Format("Expected to find release info with values {0}, {1}, {2}, {3}.", release.FlashVersion, release.FlashQfe, release.SMRevision, release.SOMRevision));
                            }
                        }
                    }
                }
            }

        }


        /// <summary>
        /// Tests BetaManager.ValidateBetaGroupConsoles.
        /// </summary>
        [TestGroup, Owner("TobiasB"), Description("Tests calls to ValidateBetaGroupConsoles.")]
        public class ValidateBetaGroupConsoles : TestNode
        {
            private static void DumpInvalidConsoles(InvalidConsole[] consoles)
            {
                Global.RO.Info("Got {0} consoles:", consoles.Length);
                foreach (InvalidConsole console in consoles)
                {
                    Global.RO.Info("\t consoleId: {0}, flashVersion: {1:X8}", console.ConsoleIDWithSCode.ConsoleID, console.FlashVersion);
                }
            }

            private static void ValidatedNumberOfConsoles(InvalidConsole[] consoles, int expected)
            {
                if (consoles.Length != expected)
                {
                    throw new UnexpectedTestResultException(String.Format("Excpected {0} invalid consoles, but got {1}.", expected, consoles.Length));
                }
            }

            [TestGroup, Owner("TobiasB"), Description("Tests calls to ValidateBetaGroupConsoles with a mock DB object.")]
            public class ValidateBetaGroupConsolesMocked : TestNode
            {
                private const uint FLASH_TITLE = 0xFFFE07D1;

                internal abstract class ValidateBetaGroupConsolesDatabaseMockBase : BetaManagementDatabaseMockBase
                {
                    protected static UpgradePath MakeUpgradePath(uint baseVersion, uint upgradeVersion)
                    {
                        UpgradePath path = new UpgradePath();
                        path.ConsoleType = PlatformType.Xbox1;
                        path.TitleId = FLASH_TITLE;
                        path.BaseVersion = baseVersion;
                        path.UpgradeVersion = upgradeVersion;
                        return path;
                    }

                    protected static InvalidConsole MakeInvalidConsole(byte idSuffix, uint version)
                    {
                        InvalidConsole console = new InvalidConsole();
                        console.ConsoleIDWithSCode.ConsoleID = String.Format("XE.0000000000{0:X2}", idSuffix);
                        console.FlashVersion = version;
                        return console;
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with no consoles in the group, on a mock object.")]
                public class GroupWithNoConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            return new List<InvalidConsole>();
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            yield return MakeUpgradePath(1, 1);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 0);
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with only invalid consoles in a group, on a mock object.")]
                public class GroupWithOnlyInvalidConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            yield return MakeInvalidConsole(1, 2);
                            yield return MakeInvalidConsole(2, 2);
                            yield return MakeInvalidConsole(3, 2);
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            yield return MakeUpgradePath(1, 1);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 3 /*ghetto*/);
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with only consoles that have exactly the flash version fro a group, a mock object.")]
                public class GroupWithOnlyExactMatchConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            yield return MakeInvalidConsole(1, 1);
                            yield return MakeInvalidConsole(2, 1);
                            yield return MakeInvalidConsole(3, 1);
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            yield return MakeUpgradePath(0, 1);
                            yield return MakeUpgradePath(1, 1);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 0);
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with a mixture of invalid and exact-match valid consoles, on a mock object.")]
                public class GroupWithMixedInvalidAndExactMatchConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            yield return MakeInvalidConsole(1, 1);
                            yield return MakeInvalidConsole(2, 1);
                            yield return MakeInvalidConsole(3, 1);
                            yield return MakeInvalidConsole(4, 2);
                            yield return MakeInvalidConsole(5, 2);
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            yield return MakeUpgradePath(0, 1);
                            yield return MakeUpgradePath(1, 1);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 2);
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with only valid consoles that rely on an upgrade path, on a mock object.")]
                public class GroupWithOnlyValidPathConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        private const uint MAX_VERSION = 4;
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            for (byte i = 1; i < MAX_VERSION; ++i)
                            {
                                yield return MakeInvalidConsole(i, i);
                            }
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            for (uint i = 0; i < MAX_VERSION; ++i)
                            {
                                yield return MakeUpgradePath(i, i + 1);
                            }
                            yield return MakeUpgradePath(MAX_VERSION, MAX_VERSION);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 0);
                    }
                }

                [TestCase, Owner("TobiasB"), Description("Calls ValidateBetaGroupConsoles with some invalid and some valid consoles that rely on an upgrade path, on a mock object.")]
                public class GroupWithMixedInvalidAndValidPathConsolesMocked : TestNode
                {
                    internal class BetaManagementDatabaseMock : ValidateBetaGroupConsolesDatabaseMockBase
                    {
                        private const uint MAX_VERSION = 4;
                        public override IEnumerable<InvalidConsole> GetConsoleFlashVersionsForBetaGroup(Guid groupId)
                        {
                            // Add valid consoles.
                            for (byte i = 1; i < MAX_VERSION; ++i)
                            {
                                yield return MakeInvalidConsole(i, i);
                            }

                            // Add some invalid consoles.
                            yield return MakeInvalidConsole(5, 7);
                            yield return MakeInvalidConsole(6, 7);
                            yield return MakeInvalidConsole(7, 7);
                        }

                        public override IEnumerable<UpgradePath> GetFlashUpgradePaths(Guid groupId)
                        {
                            for (uint i = 0; i < MAX_VERSION; ++i)
                            {
                                yield return MakeUpgradePath(i, i + 1);
                            }
                            yield return MakeUpgradePath(MAX_VERSION, MAX_VERSION);
                        }
                    }

                    public override void Run()
                    {
                        BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMock());

                        InvalidConsole[] invalidConsoles = betaManager.ValidateBetaGroupConsoles(Guid.Empty);

                        DumpInvalidConsoles(invalidConsoles);
                        ValidatedNumberOfConsoles(invalidConsoles, 3);
                    }
                }
            }
        }

        /// <summary>
        /// Tests BetaManager.CreateGroup.
        /// </summary>
        [TestGroup, Owner("TobiasB"), Description("Tests calls to CreateGroup.")]
        public class CreateGroup : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Test calls to CreateGroup with a mock database object, passing both parameters as null.")]
            public class CreateGroupBothParametersNull : TestNode
            {
                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMockBase());
                    try
                    {
                        Guid groupId = betaManager.CreateGroup(null, null);
                    }
                    catch (ArgumentNullException)
                    {
                        // nothing
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Expected an ArgumentNullException. Got a {0}.", e.GetType().Name);
                        throw;
                    }
                }
            }

            [TestCase, Owner("TobiasB"), Description("Test calls to CreateGroup with a mock database object, passing null for name.")]
            public class CreateGroupNameNull : TestNode
            {
                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMockBase());
                    try
                    {
                        Guid groupId = betaManager.CreateGroup(null, String.Empty);
                    }
                    catch (ArgumentNullException e)
                    {
                        if (e.ParamName != "name")
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected ArgumentNullException specifying 'name' as the argument. Got argument '{0}'.", e.ParamName));
                        }
                        return;
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Expected an ArgumentNullException. Got a {0}.", e.GetType().Name);
                        throw;
                    }

                    throw new UnexpectedTestResultException("Expected call to fail.");
                }
            }

            [TestCase, Owner("TobiasB"), Description("Test calls to CreateGroup with a mock database object, passing null for creator.")]
            public class CreateGroupCreatorNull : TestNode
            {
                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new BetaManagementDatabaseMockBase());
                    try
                    {
                        Guid groupId = betaManager.CreateGroup(String.Empty, null);
                    }
                    catch (ArgumentNullException e)
                    {
                        if (e.ParamName != "creator")
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected ArgumentNullException specifying 'creator' as the argument. Got argument '{0}'.", e.ParamName));
                        }
                        return;
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Expected an ArgumentNullException. Got a {0}.", e.GetType().Name);
                        throw;
                    }

                    throw new UnexpectedTestResultException("Expected call to fail.");
                }
            }

            [TestCase, Owner("TobiasB"), Description("Test calls to CreateGroup with a mock database object, passing a name that already exists.")]
            public class CreateGroupValidMock : TestNode
            {
                private static Guid _groupId = Guid.NewGuid();

                private class CreateGroupConsolesDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public override IEnumerable<string> GetAllGroupNames()
                    {
                        yield return "notname";
                        yield return "real name";
                    }

                    public override void CreateGroup(Guid betaId, string name, string creator) { ; }
                }

                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new CreateGroupConsolesDatabaseMock());
                    try
                    {
                        Guid groupId = betaManager.CreateGroup("real name", "real person");
                    }
                    catch (ArgumentException e)
                    {
                        if (e.ParamName != "name")
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected ArgumentException specifying 'name' as the argument. Got argument '{0}'.", e.ParamName));
                        }
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected call to fail.");
                }
            }

            [TestCase, Owner("TobiasB"), Description("Test calls to CreateGroup with a mock database object, passing valid strings.")]
            public class CreateGroupDuplicateNameMock : TestNode
            {
                private class CreateGroupConsolesDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public override IEnumerable<string> GetAllGroupNames() { return new List<string>(); }
                    public override void CreateGroup(Guid betaId, string name, string creator) { ; }
                }

                public override void Run()
                {
                    BetaManager betaManager = BetaManager.GetInstance(new CreateGroupConsolesDatabaseMock());
                    Guid groupId = betaManager.CreateGroup("real name", "real person");

                    // Didn't throw? Ship it!
                }
            }
        }

        [TestGroup, Owner("TobiasB"), Description("Test get GetConsoleIDsInGroup")]
        public class GetConsoleIDsInGroup : TestNode
        {
            [TestCase, Owner("TobiasB"), Description("Test GetConsoleIDsInGroup with a mock object.")]
            public class GetConsoleIDsInGroupMock : TestNode
            {
                private class GetConsoleIDsInGroupDatabaseMock : BetaManagementDatabaseMockBase
                {
                    public override IEnumerable<string> GetConsoleIDsInGroup(Guid groupId)
                    {
                        for(int i = 0; i < 99; ++i)
                        {
                            yield return String.Format("XE.DDDDDDDDDD{0:D2}", i);
                        }
                    }

                    public override GroupSummary GetGroupSummary(Guid groupId)
                    {
                        GroupSummary group = new GroupSummary();
                        group.GroupGuid = groupId;
                        return group;
                    }
                }

                public override void Run()
                {
                    GetConsoleIDsInGroupDatabaseMock mock = new GetConsoleIDsInGroupDatabaseMock();
                    BetaManager betaManager = BetaManager.GetInstance(mock);
                    IEnumerable<string> consoleIds = betaManager.GetConsoleIDsInGroup(Guid.NewGuid());

                    IEnumerable<string> expected = mock.GetConsoleIDsInGroup(Guid.Empty);

                    if (expected.Count() != consoleIds.Count())
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected {0} consoleIds, but got {1}.", expected.Count(), consoleIds.Count()));
                    }

                    foreach (string consoleId in expected)
                    {
                        if (!consoleIds.Any(s => (s == consoleId)))
                        {
                            throw new UnexpectedTestResultException(String.Format("Didn't find consoleId {0} in output.", consoleId));
                        }
                    }
                }
            }

            [TestCase, Owner("TobiasB"), Description("Test GetConsoleIDsInGroup against the real database.")]
            public class GetConsoleIDsInGroupReal : TestNode
            {
                public override void Run()
                {
                    // Set up console Ids.
                    BetaGroupEditor groupEditor = BetaGroupEditor.CreateNew();
                    List<MachineEditor> machinesCreated = new List<MachineEditor>();
                    for (int i = 0; i < 100; ++i)
                    {
                        MachineEditor machine = MachineEditor.CreateNew(MachineType.Xbox360);
                        groupEditor.AddMachine(machine.Id);
                        machinesCreated.Add(machine);
                    }

                    // Get the consoles Ids.
                    BetaManager betaManager = BetaManager.GetInstance(new UodbBetaManagementDatabase());
                    IEnumerable<string> consoleIds = betaManager.GetConsoleIDsInGroup(groupEditor.Id);

                    // Verify!
                    if (machinesCreated.Count() != consoleIds.Count())
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected {0} consoleIds, but got {1}.", machinesCreated.Count(), consoleIds.Count()));
                    }

                    foreach (MachineEditor machine in machinesCreated)
                    {
                        if (!consoleIds.Any(s => (s == machine.ConsoleId)))
                        {
                            throw new UnexpectedTestResultException(String.Format("Didn't find consoleId {0} in output.", machine.ConsoleId));
                        }
                    }

                    // Clean up database.
                    BetaGroupEditor.NukeGroup(groupEditor.Id);
                    foreach (MachineEditor machine in machinesCreated)
                    {
                        machine.CompletelyRemoveMachine();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MatchTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MatchTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MatchTest\MatchTest.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.titlemanagement.contracts.V1;

using MIXTesting;

namespace MixTest
{
    [TestGroup, Owner("codyluit"), Description("Mix Match Tests")]
    public class MatchTests : TestNode
    {
        public override void PreRun()
        {
            // Enable Match API
            MIXTesting.Config.EnableAPIs(Interface.mixmatch, "Xonline.Mix.Match.Service", "MixMatch.ConfigureMatchmaking");
            // Enable Title APIs
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        static protected XLASTFactory _xlastFactory = new XLASTFactory();
        static protected TitleManagementWCFClient titleClient = new TitleManagementWCFClient();

        static uint defaultTitleId = 0xFFFE040A;
        static uint expectedBuckets = 6;

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added matchmaking attributes which will cause a schema change
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleWithNewSchema(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId.ToString("X") + "-NewSchema"));

            titleClient.AddBaseVersion(titleId, 0, PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added game mode
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleWithNewGameMode(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId.ToString("X") + "-NewMode"));
            
            titleClient.AddBaseVersion(titleId, 0, PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleDefault(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId));

            titleClient.AddBaseVersion(titleId, 0, PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Adds a new bucket to the database so that when we attempt to ConfigureMatchmaking it fails because of inconsistencies
        /// </summary>
        /// <param name="titleId"></param>
        /// <returns></returns>
        static public bool AddNewBucket(uint titleId)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();

                // Lets get what already exists
                InterfaceBucketCollection allbuckets = npdb.GetInterfaceBuckets(titleId, xonline.common.config.Config.Environment);

                InterfaceBucketCollection matchbuckets = new InterfaceBucketCollection();
                foreach (InterfaceBucket ib in allbuckets)
                {
                    if (String.Compare(ib.Interface, "xmatch") == 0)
                    {
                        matchbuckets.Add(ib);
                    }
                }

                // If we had some, lets add a new one so Match gets confused and fails next time
                if (matchbuckets.Count == 0)
                    return false;

                string insertBucketCmd = "insert into t_interface_buckets (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4) " +
                                         "values (@env, @interface, @titleId, @bucket, @server, @nextserver, @migrationStart, @vc_info1, @vc_info2, @vc_info3, @vc_info4)";

                SqlCommand com = npdb.CreateCommand();
                com.CommandText = insertBucketCmd;
                com.Parameters.AddWithValue("@env", xonline.common.config.Config.Environment);
                com.Parameters.AddWithValue("@interface", matchbuckets[0].Interface);
                com.Parameters.AddWithValue("@titleId", (int)titleId);
                com.Parameters.AddWithValue("@bucket", matchbuckets.Count);
                com.Parameters.AddWithValue("@server", matchbuckets[0].Server);
                com.Parameters.AddWithValue("@nextserver", matchbuckets[0].NextServer);
                com.Parameters.AddWithValue("@migrationStart", matchbuckets[0].MigrationStart);
                com.Parameters.AddWithValue("@vc_info1", "''");
                com.Parameters.AddWithValue("@vc_info2", "''");
                com.Parameters.AddWithValue("@vc_info3", "''");
                com.Parameters.AddWithValue("@vc_info4", "''");

                int affected = com.ExecuteNonQuery();
                if (affected == 1)
                    return true;
            }

            return false;
        }

        [TestCase, Description("MixMatchBasicDeployTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchBVT : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        #region titleID

        [TestCase, Description("MixMatchTitleIDTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchTitleIDTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchNonProppedTitleIDTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchNonProppedTitleIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Some nonexistant title ID
                uint titleId = 0x0001;

                try
                {
                    // Deploy the title using MIX API
                    base.matchClient.ConfigureMatchmaking(titleId, false, false, false, false);
                }
                catch(Exception e)
                {
                    if (e.InnerException.Message.Contains("Unable to find live title configuration for title id"))
                        return;
                    else
                        throw new UnexpectedTestResultException("Caught an exception with a different message than expected.");
                }

                // if it didn't throw, we failed
                throw new UnexpectedTestResultException("Unexpectedly succeeded.");
            }
        }

        [TestCase, Description("MixMatchInvalidTitleIDTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchInvalidTitleIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Some nonexistant title ID
                uint titleId = 0;

                try
                {
                    // Deploy the title using MIX API
                    base.matchClient.ConfigureMatchmaking(titleId, false, false, false, false); 
                }
                catch(Exception e)
                {
                    if(e.InnerException.Message.Contains("TitleId of 0 is not supported."))
                        return;
                    else
                        throw new UnexpectedTestResultException("Caught an exception with a different message than expected.");
                }

                // if it didn't throw, we failed
                throw new UnexpectedTestResultException("Unexpectedly succeeded.");
            }
        }

        #endregion

        #region dropTable

        [TestCase, Description("MixMatchDropTableTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchDropTableTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, true, false, false); 

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchDropTableNoFlagTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchDropTableNoFlagTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleWithNewSchema(defaultTitleId);
            }

            public override void Run()
            {
                try
                {
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);
                }
                catch (Exception e)
                {
                    if (e.Message.Contains("Match ConfigureMatchmaking call failed with HR = 0x80176035") &&
                        e.InnerException.Message.Contains("ConfigureMatchmaking encountered a SqlException during execution. This may be caused by dropTable being set to false when true is required."))
                    {
                        return;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("MixMatchDropTableNoFlagTest returned an unknown exception:\r\n" + e.Message);
                    }
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded.");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchDropTableSessionsTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchDropTableSessionsTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // Verify tables and sprocs exist
                ValueCheck.IsTrue(base.matchClient.Verify(defaultTitleId, true, expectedBuckets), "Verify failed on initial deploy");

                Global.RO.Info("Creating sessions...");

                // Now lets create a session
                MatchSession matchSession = new MatchSession();

                Global.RO.Warn("^^^^^ Error Expected...");

                matchSession.TitleID = defaultTitleId;
                matchSession.Create(SessionType.Ranked);

                MatchUtil.SessionDBData sessionData1 = MatchUtil.FindSessionByDirectDBQuery(matchSession, false);

                ValueCheck.IsTrue(sessionData1 != null, "Session not found.");

                Global.RO.Info("Sessions found.");

                // Now lets deploy again with dropTable set to true so all sessions are DESTROYED
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, true, false, false);

                // Try sleeping so the sessions can die slow
                System.Threading.Thread.Sleep(5000);

                MatchUtil.SessionDBData sessionData2 = MatchUtil.FindSessionByDirectDBQuery(matchSession, false);

                ValueCheck.IsTrue(sessionData2 == null, "Sessions were unexpectedly found after configuring match with dropTable set to true.");

                Global.RO.Info("No sessions found after drop table deploy.");

                // Verify tables and sprocs exist
                ValueCheck.IsTrue(base.matchClient.Verify(defaultTitleId, true, expectedBuckets), "Table/sproc verification failed after drop table was used!");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchNonProppedTitleIDDropTableTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchNonProppedTitleIDDropTableTest : CnGWCFTestBase
        {
            public override void Run()
            {
                uint titleId = 0x0001;

                try
                {
                    base.matchClient.ConfigureMatchmaking(titleId, false, true, false, false);
                }
                catch (Exception e)
                {
                    if (!e.InnerException.Message.Contains("Unable to find live title configuration for title id"))
                    {
                        throw new UnexpectedTestResultException("Caught an exception with a different message than expected.");
                    }
                }

               //NOTE: Is this test intended to pass if the call succeeds...?
            }
        }

        [TestCase, Description("MixMatchInvalidTitleIDDropTableTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchInvalidTitleIDDropTableTest : CnGWCFTestBase
        {
            public override void Run()
            {
                uint titleId = 0;

                try
                {
                    base.matchClient.ConfigureMatchmaking(titleId, false, true, false, false);
                }
                catch (Exception e)
                {
                    if (!e.InnerException.Message.Contains("TitleId of 0 is not supported."))
                    {
                        throw new UnexpectedTestResultException("Caught an exception with a different message than expected.");
                    }
                }

                //NOTE: Is this test intended to pass if the call succeeds...?
            }
        }

        #endregion

        #region newModeServer

        // codyluit: Commented out since we removed the newModeServer parameter. I'm sure it will come back some day...
        //[TestCase, Description("MixMatchNewModeServerTest"), TestFrequency("Daily"), TestCasePriority(1)]
        //class MixMatchNewModeServerTest : CnGWCFTestBase
        //{
        //    public override void PreRun()
        //    {
        //        DeployTitleDefault(defaultTitleId);
        //    }

        //    public override void Run()
        //    {
        //        // Configure match for the regular xlast (override buckets to trash anything left over from anything)
        //        base.matchClient.ConfigureMatchmaking(defaultTitleId, null, false, false, false, true); 

        //        // Deploy the title with a new gamemode
        //        DeployTitleWithNewGameMode(defaultTitleId);

        //        string serverName = xonline.common.config.Config.GetSetting("mix_default_MatchServer");

        //        // Configure match with the new servername we get from npdb
        //        base.matchClient.ConfigureMatchmaking(defaultTitleId, serverName, false, false, false, false);

        //        bool pass = false;
        //        // Verify tables and sprocs exist
        //        if (base.matchClient.Verify(defaultTitleId, true, expectedBuckets + 2)) // + 2 because of new mode
        //            pass = true;

        //        if(pass == true)
        //            return TEST_RESULTS.PASSED;
        //        else
        //            return TEST_RESULTS.FAILED;
        //    }

        //    public override void PostRun()
        //    {
        //        base.matchClient.ClearDB(defaultTitleId);
        //        base.titleClient.Cleanup(defaultTitleId);
        //    }
        //}

        [TestCase, Description("MixMatchNewModeServerTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchNewModeServerTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Configure match for the regular xlast (override buckets to trash anything left over from anything)
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, true);

                // Deploy the title with a new gamemode
                DeployTitleWithNewGameMode(defaultTitleId);

                // Get match servers and connect to the event logs
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.xmatchfd_int);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "mixmatch";
                change.Init();

                bool pass = true;
                try
                {
                    // Deploy the title using MIX API
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);
                }
                catch (Exception e)
                {
                    // Note: We used to always throw an exception for this case, but now it is only in production environments

                    pass = false;
                    Global.RO.Error("Got an unexpected exception.");
                    Global.RO.Error(e.Message);
                    Global.RO.Error(e.StackTrace.ToString());
                }
                finally
                {
                    // Lets get this back into the default state...
                    DeployTitleDefault(defaultTitleId);
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, true, true, false, true);
                }

                ValueCheck.IsTrue(pass == true, "An unexpected exception was caught in ConfigureMatchmaking.");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        // codyluit: Commented out since we removed the newModeServer parameter. I'm sure it will come back some day...
        //[TestCase, Description("MixMatchNewModeServerInvalidServerTest"), TestFrequency("Daily"), TestCasePriority(2)]
        //class MixMatchNewModeServerInvalidServerTest : CnGWCFTestBase
        //{
        //    public override void PreRun()
        //    {
        //        DeployTitleDefault(defaultTitleId);
        //    }

        //    public override void Run()
        //    {
        //        // We can assume the title is already propped with the default xlast???
        //        // Configure match for the regular xlast (override buckets to trash anything left over from anything)
        //        base.matchClient.ConfigureMatchmaking(defaultTitleId, null, false, false, false, true); 

        //        // Deploy the title with a new gamemode
        //        DeployTitleWithNewGameMode(defaultTitleId);

        //        bool pass = false;
        //        try
        //        {
        //            // Deploy the title using MIX API
        //            base.matchClient.ConfigureMatchmaking(defaultTitleId, "IHopeThisIsNotAValidServerName", false, false, false, false);
        //        }
        //        catch (Exception e)
        //        {
        //            if (e.InnerException.Message.Contains("Error: Bad server name: 'IHopeThisIsNotAValidServerName'"))
        //                pass = true;
        //            else
        //                Global.RO.Error("An unknown exception was caught.");
        //        }
        //        finally
        //        {
        //            // Lets get this back into the default state...
        //            DeployTitleDefault(defaultTitleId);
        //            base.matchClient.ConfigureMatchmaking(defaultTitleId, null, true, true, false, true);
        //        }

        //        if(pass == true)
        //            return TEST_RESULTS.PASSED;

        //        return TEST_RESULTS.FAILED;
        //    }

        //    public override void PostRun()
        //    {
        //        base.matchClient.ClearDB(defaultTitleId);
        //        base.titleClient.Cleanup(defaultTitleId);
        //    }
        //}

        #endregion

        #region removeMode

        [TestCase, Description("MixMatchRemoveModeTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchRemoveModeTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                // deploying a new mode then the default without the new mode to see if it worked
                DeployTitleWithNewGameMode(defaultTitleId);
            }

            public override void Run()
            {
                // Config match with adding new game mode
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // Deploy regular xlast, with game mode removed
                DeployTitleDefault(defaultTitleId);

                // Config match setting removeMode to true
                base.matchClient.ConfigureMatchmaking(defaultTitleId, true, false, false, false);

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchRemoveModeWithoutRemovingModeTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchRemoveModeWithoutRemovingModeTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Deploy the title default to make sure that version is there
                DeployTitleDefault(defaultTitleId);

                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, true, false, false, false);

                // Note: This flag is only checked if the code detects a difference not the other way around so this should
                //       just pass as normal.

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchRemoveModeWithoutRemovingModeTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchRemoveModeWithRemovingModeFalseFlagTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                // Deploy a title and match with an additional gamemode so we can remove it later
                DeployTitleWithNewGameMode(defaultTitleId);
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);
            }

            public override void Run()
            {
                // Deploy the title default so a mode was removed
                DeployTitleDefault(defaultTitleId);

                try
                {
                    // Deploy the title using MIX API
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);
                }
                catch (Exception e)
                {
                    if (e.Message.Contains("Match ConfigureMatchmaking call failed with HR = 0x80176033") &&
                        e.InnerException.Message.Contains("ConfigureMatchmaking attemped to remove a mode with removeMode set to false. To successfully configure matchmaking for this title you must set removeMode to true."))
                    {
                        return;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("An unexpected exception was caught:" + e.Message);
                    }
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded.");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        #endregion

        #region noReload

        [TestCase, Description("MixMatchNoReloadTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchNoReloadTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Get match servers and connect to the event logs
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.xmatchfd_int);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "xmatchfd";
                change.Init();

                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, true, false);

                // Verify tables and sprocs exist
                if (base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                {
                    // Verify the reloadtitleinfo event didn't occur
                    if (!change.TestForChange("reloadtitleinfo"))
                        return;
                }

                throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchReloadTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchReloadTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Get match servers and connect to the event logs
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.xmatchfd_int);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "xmatchfd";
                change.Init();

                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // Verify tables and sprocs exist
                if (base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                {
                    // Verify the reloadtitleinfo event didn't occur
                    if (change.TestForChange("reloadtitleinfo"))
                        return;
                }

                throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        #endregion

        #region overrideBuckets

        [TestCase, Description("MixMatchOverrideBucketsTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixMatchOverrideBucketsTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // We assume the title is already there, lets add bucket so that override buckets will delete and fix it
                AddNewBucket(defaultTitleId);

                // Deploy the title using MIX API
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, true);

                // Verify tables and sprocs exist
                if (!base.matchClient.Verify(defaultTitleId, true, expectedBuckets))
                    throw new UnexpectedTestResultException("matchClient.Verify failed");
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        [TestCase, Description("MixMatchOverrideBucketsWithoutFlagTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixMatchOverrideBucketsWithoutFlagTest : CnGWCFTestBase
        {
            public override void PreRun()
            {
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Deploy normally
                base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);

                // We assume the title is already there, lets add bucket so that override buckets will delete and fix it
                AddNewBucket(defaultTitleId);

                bool pass = false;

                try
                {
                    // Deploy the title using MIX API
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, false);
                }
                catch (Exception e)
                {
                    if (e.InnerException.Message.Contains("LTC is out of sync with t_interface_buckets."))
                        pass = true;
                    else
                        Global.RO.Error("An unknown exception was caught.");
                }
                finally
                {
                    // Running again with override buckets set to true so the db isn't in a crap state anymore
                    base.matchClient.ConfigureMatchmaking(defaultTitleId, false, false, false, true);
                }

                if (pass)
                    return;

                throw new UnexpectedTestResultException("Did not pass."); //TODO: Make this better...
            }

            public override void PostRun()
            {
                base.matchClient.ClearDB(defaultTitleId);
                base.titleClient.Cleanup(defaultTitleId);
            }
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MatchTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace MixTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\LegacyTestDataFile.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;


namespace MixPropTool
{
    public class LegacyTestDataFile
    {
        #region Public Members
        private FileInfo FileInfo;
        public string FileName
        {
            get
            {
                if (FileInfo != null)
                    return FileInfo.Name;
                return "";
            }
        }

        public string FullName
        {
            get
            {
                if (FileInfo != null)
                    return FileInfo.FullName;
                return "";
            }
        }

        public List<Guid> ExpectedProductList = new List<Guid>();
        public void AddExpectedProduct(Guid productId)
        {
            if (!ExpectedProductList.Contains(productId))
                ExpectedProductList.Add(productId);
        }

        public List<Guid> ExpectedOfferList = new List<Guid>();
        public void AddExpectedOffer(Guid offerId)
        {
            if (!ExpectedOfferList.Contains(offerId))
                ExpectedOfferList.Add(offerId);
        }

        private List<MixResult> MigratedProductResults = new List<MixResult>();
        public void AddMigratedProductResult(MixResult result)
        {
            if (!MigratedProductResults.Contains(result))
                MigratedProductResults.Add(result);
        }
        private List<MixResult> MigratedOfferResults = new List<MixResult>();
        public void AddMigratedOfferResult(MixResult result)
        {
            if (!MigratedOfferResults.Contains(result))
                MigratedOfferResults.Add(result);
        }

        private IEnumerable<Guid> _SuccessfullyMigratedProducts = null;
        public IEnumerable<Guid> SuccessfullyMigratedProducts
        {
            get
            {
                if (_SuccessfullyMigratedProducts == null)
                    _SuccessfullyMigratedProducts = from mixProduct in MigratedProductResults
                                                    where mixProduct.Success
                                                    select mixProduct.Guid;
                return _SuccessfullyMigratedProducts;
            }
        }

        private IEnumerable<Product> _SuccessfullyMigratedProductInstances;
        public IEnumerable<Product> SuccessfullyMigratedProductInstances
        {
            get
            {
                if(_SuccessfullyMigratedProductInstances == null)
                    _SuccessfullyMigratedProductInstances = from mixProduct in MigratedProductResults
                                                            where mixProduct.Success
                                                            select mixProduct.Object as Product;
                return _SuccessfullyMigratedProductInstances;
            }
        }

        private IEnumerable<Guid> _FailedMigrationProducts;
        public IEnumerable<Guid> FailedMigrationProducts
        {
            get
            {
                if (_FailedMigrationProducts == null)
                {
                    _FailedMigrationProducts = from productResult in MigratedProductResults
                                               where productResult.Success == false
                                               select productResult.Guid;
                }
                return _FailedMigrationProducts;
            }
        }

        private IEnumerable<MixResult> _FailedMigrationProductInstances;
        public IEnumerable<MixResult> FailedMigrationProductInstances
        {
            get
            {
                if (_FailedMigrationProductInstances == null)
                {
                    _FailedMigrationProductInstances = from productResult in MigratedProductResults
                                                       where productResult.Success == false
                                                       select productResult;
                }
                return _FailedMigrationProductInstances;
            }
        }

        private IEnumerable<Guid> _MissingMigrationProducts;
        public IEnumerable<Guid> MissingMigrationProducts
        {
            get
            {
                if (_MissingMigrationProducts == null)
                {
                    _MissingMigrationProducts = from productId in ExpectedProductList
                                                where !SuccessfullyMigratedProducts.Contains(productId) && !FailedMigrationProducts.Contains(productId)
                                                select productId;
                }
                return _MissingMigrationProducts;
            }
        }

        private IEnumerable<Guid> _SuccessfullyMigratedOffers = null;
        public IEnumerable<Guid> SuccessfullyMigratedOffers
        {
            get
            {
                if (_SuccessfullyMigratedOffers == null)
                    _SuccessfullyMigratedOffers = from mixOffer in MigratedOfferResults
                                                    where mixOffer.Success
                                                    select mixOffer.Guid;
                return _SuccessfullyMigratedOffers;
            }
        }

        private IEnumerable<Offer> _SuccessfullyMigratedOfferInstances;
        public IEnumerable<Offer> SuccessfullyMigratedOfferInstances
        {
            get
            {
                if (_SuccessfullyMigratedOfferInstances == null)
                    _SuccessfullyMigratedOfferInstances = from mixOffer in MigratedOfferResults
                                                            where mixOffer.Success
                                                            select mixOffer.Object as Offer;
                return _SuccessfullyMigratedOfferInstances;
            }
        }

        private IEnumerable<Guid> _FailedMigrationOffers;
        public IEnumerable<Guid> FailedMigrationOffers
        {
            get
            {
                if (_FailedMigrationOffers == null)
                {
                    _FailedMigrationOffers = from OfferResult in MigratedOfferResults
                                               where OfferResult.Success == false
                                               select OfferResult.Guid;
                }
                return _FailedMigrationOffers;
            }
        }

        private IEnumerable<MixResult> _FailedMigrationOfferInstances;
        public IEnumerable<MixResult> FailedMigrationOfferInstances
        {
            get
            {
                if (_FailedMigrationOfferInstances == null)
                {
                    _FailedMigrationOfferInstances = from OfferResult in MigratedOfferResults
                                                       where OfferResult.Success == false
                                                       select OfferResult;
                }
                return _FailedMigrationOfferInstances;
            }
        }

        private IEnumerable<Guid> _MissingMigrationOffers;
        public IEnumerable<Guid> MissingMigrationOffers
        {
            get
            {
                if (_MissingMigrationOffers == null)
                {
                    _MissingMigrationOffers = from OfferId in ExpectedOfferList
                                                where !SuccessfullyMigratedOffers.Contains(OfferId) && !FailedMigrationOffers.Contains(OfferId)
                                                select OfferId;
                }
                return _MissingMigrationOffers;
            }
        }

        public LegacyTestDataFile(FileInfo newFileInfo)
        {
            this.FileInfo = newFileInfo;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\Program.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Data;
using System.Xml;
using System.Linq;
using System.Data.SqlClient;
using System.IO;
using System.ServiceModel;
using System.Text;

using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

using ServerTestFramework;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace MixPropTool
{
    class MixPropTool
    {
        private static string CatalogServer = "";
        private static string NPDBServer = "";
        private static string CatalogConnectionString
        {
            get
            {
                // Connection string is dynmaically built from the environment name (and/or username and password, in the future)
                return "Data Source=" + CatalogServer + ";Integrated Security=True";
            }
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            int returnValue = 0;
            string readLegacyTestDataPath = "";
            bool getAllProducts = false;
            bool getAllOffers = false;
            bool verboseReport = false;
            bool fixProducts = false;

            var getOfferList = new List<string>();
            var getProductList = new List<string>();
            var propFileList = new List<string>();

            string mixAddress = "";
            string reportPath = "";

            if (args.Length == 0 || (args.Length == 1 && args[0].ToLower() == "/?"))
            {
                Console.WriteLine("Usage:   /environment:<server>       Sets both NPDB and Catalog servers");
                Console.WriteLine("         /catalogserver:<server>     Set Catalog server");
                Console.WriteLine("         /npdbserver:<server>        Set NPDB server");
                Console.WriteLine("         /reportpath:<path>          Path to write reports ");
                Console.WriteLine("         /getproduct:<productid>     Reads product from DB and it writes to XML");
                Console.WriteLine("         /getoffer:<offerid>         Reads offer from DB and it writes to XML");
                Console.WriteLine("         /propfile:<file>            Props all data in a Mix test data file");
                Console.WriteLine("         /propfilelist:<file>        Props all data in a list");
                Console.WriteLine("         /reportpath:<path>          Path to write reports ");
                Console.WriteLine("         /readlegacytestdata:<path>  Reads all legacy test data XML files for");
                Console.WriteLine("                                     offers and products");
                Console.WriteLine("         /getallproducts            Reads all products and writes them to XML");
                Console.WriteLine("         /getalloffers              Reads all offers and writes them to XML");
                Console.WriteLine("         /getall                    Reads all products and offers");
                Console.WriteLine("                                     (same as /readallproducts /readalloffers)");
                Console.WriteLine("         /verbosereports             Writes all reports (found/not found legacy data)");
                Console.WriteLine("         /fixproducts                Attempts to fix some broken product data on prop");
                Environment.Exit(1);
            }

            foreach (var arg in args)
            {
                var argsplit = arg.Split(new char[] { ':' }, 2);
                if (argsplit.Length > 1)
                {
                    argsplit[0] = argsplit[0].ToLower();
                    if (argsplit[0] == "/environment")
                    {
                        CatalogServer = argsplit[1];
                        NPDBServer = argsplit[1];
                    }
                    if (argsplit[0] == "/catalogserver")
                    {
                        CatalogServer = argsplit[1];
                    }
                    if (argsplit[0] == "/npdbserver")
                    {
                        NPDBServer = argsplit[1];
                    }
                    if (argsplit[0] == "/reportpath")
                    {
                        reportPath = argsplit[1];
                        if (reportPath[reportPath.Length - 1] != '\\')
                            reportPath = reportPath + '\\';
                        if (!Directory.Exists(reportPath))
                            Directory.CreateDirectory(reportPath);
                    }

                    if (argsplit[0] == "/getproduct")
                    {
                        getProductList.Add(argsplit[1]);
                    }

                    if (argsplit[0] == "/getoffer")
                    {
                        getOfferList.Add(argsplit[1]);
                    }

                    if (argsplit[0] == "/propfile")
                    {
                        propFileList.Add(argsplit[1]);
                    }

                    if (argsplit[0] == "/propfilelist")
                    {
                        string propFileListFile = argsplit[1];
                        string propFileListDirectory = "";
                        if(propFileListFile.Contains('\\'))
                        {
                            propFileListDirectory = propFileListFile.Substring(0, propFileListFile.LastIndexOf('\\'));
                        }

                        // Read through a list of files to prop
                        try
                        {
                            using (var reader = new StreamReader(propFileListFile))
                            {
                                string line;
                                while ((line = reader.ReadLine()) != null)
                                {
                                    // Skip blank lines
                                    if (line != "")
                                    {
                                        char[] delims = { '\t', ' ' };
                                        propFileList.Add(propFileListDirectory + "\\" + line.Split(delims)[0]);
                                    }
                                }
                            }
                        }catch(Exception e)
                        {
                            Console.WriteLine("Propping file list \"{0}\" failed:", argsplit[1]);
                            Console.WriteLine(e.ToString());
                            returnValue = 1;
                        }
                    }

                    if (argsplit[0] == "/readlegacytestdata")
                        readLegacyTestDataPath = argsplit[1];

                    if (argsplit[0] == "/mixaddress")
                        mixAddress = argsplit[1];
                }

                if (arg == "/readall" || arg == "/getall")
                {
                    getAllProducts = true;
                    getAllOffers = true;
                }

                if (arg == "/readallproducts" || arg == "/getallproducts")
                    getAllProducts = true;

                if (arg == "/readalloffers" || arg == "/getalloffers")
                    getAllOffers = true;

                if (arg == "/verbosereports")
                    verboseReport = true;

                if (arg == "/fixproducts")
                    fixProducts = true;
            }

            if (CatalogServer == "" && mixAddress == "")
            {
                Console.WriteLine("Error: Must provide an environment name (/environmentname:<env>) or mix address (/mixaddress:<address:port>)");
                Environment.Exit(1);
            }

            if (CatalogServer != "")
            {
                Console.WriteLine("Initializing STF");
                MixManagement.InitializeSTF(CatalogServer, NPDBServer);
            }

            if (mixAddress != "")
            {
                MixManagement.MixAddress = mixAddress;
            }

            if (readLegacyTestDataPath != "")
                MixManagement.ReadLegacyTestData(readLegacyTestDataPath);

            // Get all products
            if (getAllProducts)
                MixManagement.GetAllProducts(CatalogConnectionString);

            // Get all offers
            if (getAllOffers)
                MixManagement.GetAllOffers(CatalogConnectionString);

            if (getProductList.Count > 0)
            {
                int count = 0;
                foreach (var getProduct in getProductList)
                {
                    count++;
                    Console.WriteLine("[{0}/{1}]: {2}", count.ToString(), getProductList.Count.ToString(), getProduct);
                    var newProductGuid = new Guid(getProduct);
                    MixManagement.MixProducts.Add(newProductGuid, MixManagement.GetProduct(newProductGuid, ""));
                }
            }

            if (getOfferList.Count > 0)
            {
                int count = 0;
                foreach (var getOffer in getOfferList)
                {
                    count++;
                    Console.WriteLine("[{0}/{1}]: {2}", count.ToString(), getOfferList.Count.ToString(), getOffer);
                    var newOfferGuid = new Guid(getOffer);
                    MixManagement.MixOffers.Add(newOfferGuid, MixManagement.GetOffer(newOfferGuid, @""));
                }
            }

            if (verboseReport)
                MixMigrationReport.WriteReport(reportPath);

            if (propFileList.Count > 0)
            {
                foreach (var propFile in propFileList)
                {
                    // Loop through the files in the list and prop each one
                    try
                    {
                        var mixTestDataFile = MixTestDataFile.Deserialize(propFile);
                        mixTestDataFile.PropAll(fixProducts);
                    }
                    catch (InvalidOperationException)
                    {
                        try
                        {

                            // File is not a MixTestData file, try product and offer
                            var product = MixManagement.ReadProduct(propFile);
                            if (product != null)
                            {
                                MixManagement.ConfigureProduct(product);
                            }
                            else
                            {
                                var offer = MixManagement.ReadOffer(propFile);
                                if (offer != null)
                                {
                                    MixManagement.ConfigureOffer(offer);
                                }
                                else
                                {
                                    Console.WriteLine("Propping test data file \"{0}\" failed:", propFile);
                                    Console.WriteLine("File is not a MixTestData file, Mix Offer or Mix Product.");
                                    returnValue = 1;
                                }
                            }
                        }
                        catch (UnexpectedTestResultException ex)
                        {
                            Console.WriteLine("Propping test data file \"{0}\" failed:", propFile);
                            if (ex.InnerException is FaultException<ValidationFault>)
                            {
                                // Propping item had validation issues, report them to the user
                                FaultException<ValidationFault> validationFault = ex.InnerException as FaultException<ValidationFault>;
                                foreach (ValidationDetail detail in validationFault.Detail.Details)
                                    Console.WriteLine("Error: " + detail.Message);
                            }
                            else
                            {
                                Console.WriteLine(ex.InnerException.Message);
                            }
                            returnValue = 1;
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("Propping test data file \"{0}\" failed:", propFile);
                            Console.WriteLine(e.ToString());
                            returnValue = 1;
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Propping test data file \"{0}\" failed:", propFile);
                        Console.WriteLine(e.ToString());
                        returnValue = 1;
                    }
                }
            }

            Environment.Exit(returnValue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\MixTestDataFile.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.ServiceModel;
using System.Xml;
using System.Xml.Serialization;

using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;

using MIXTesting;

using ServerTestFramework;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace MixPropTool
{

    /// <summary>
    /// Definition for the new Mix test data file.
    /// </summary>
    [XmlRootAttribute("MixTestDataFile", Namespace = "", IsNullable = false)]
    public class MixTestDataFile
    {
        #region Serialized Members
        private List<XmlDocument> _Products = new List<XmlDocument>();
        [XmlArray("MixProductList"), XmlArrayItem(ElementName = "MixProductListItem", Type = typeof(XmlDocument))]
        /// List of products included in the test data file
        public XmlDocument[] Products
        {
            get
            {
                return _Products.ToArray();
            }
            set
            {
                _Products = new List<XmlDocument>(value);
            }
        }

        private List<XmlDocument> _Offers = new List<XmlDocument>();
        [XmlArray("MixOfferList"), XmlArrayItem(ElementName = "MixOfferListItem", Type = typeof(XmlDocument))]
        /// List of offers included in the test data file
        public XmlDocument[] Offers
        {
            get
            {
                return _Offers.ToArray();
            }
            set
            {
                _Offers = new List<XmlDocument>(value);
            }
        }

        [XmlIgnore]
        private string FileName;
        #endregion

        public MixTestDataFile(string fileName)
        {
            this.FileName = fileName;
            var products = MixManagement.LegacyTestDataFiles[fileName].SuccessfullyMigratedProductInstances;
            var offers = MixManagement.LegacyTestDataFiles[fileName].SuccessfullyMigratedOfferInstances;

            foreach (var product in products)
            {
                var doc = DataContractSerialize.ObjectToXml(product);
                _Products.Add(doc);
            }

            foreach (var offer in offers)
            {
                var doc = DataContractSerialize.ObjectToXml(offer);
                _Offers.Add(doc);
            }
        }

        public MixTestDataFile()
        {
        }

        /// <summary>
        /// Props all of the test data defined via MixPropTool.ConfigureProduct and MixPropTool.ConfigureOffer
        /// </summary>
        /// <returns></returns>
        public bool PropAll(bool fixProducts)
        {
            int count = 0;
            int productsCount = Products.Count();
            int offersCount = Offers.Count();
            bool success = true;


            if (fixProducts && !FixProducts())
                this.Serialize();

            foreach (var productXML in Products)
            {
                try
                {
                    count++;
                    Console.Write("Propping product " + count + " of " + productsCount + "...");
                    MixManagement.ConfigureProduct(productXML);
                    Console.WriteLine("Success");
                }
                catch (UnexpectedTestResultException ex)
                {
                    var product = MixManagement.ReadProduct(productXML);
                    if (product != null)
                    {
                        Console.WriteLine("Propping product \"{0}\" failed:", product.ProductId.ToString());

                        // Propping product had validation issues, report them to the user
                        if (ex.InnerException is FaultException<ValidationFault>)
                        {
                            FaultException<ValidationFault> validationFault = ex.InnerException as FaultException<ValidationFault>;
                            foreach (ValidationDetail detail in validationFault.Detail.Details)
                                Console.WriteLine("Error: " + detail.Message);
                        }
                        else
                        {
                            Console.WriteLine(ex.InnerException.ToString());
                        }
                    }
                    else
                    {
                        Console.WriteLine("Product XML is malformed");
                    }
                    success = false;
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Failed");
                    Console.WriteLine(ex.ToString());
                    success = false;
                }
            }

            count= 0;
            foreach (var offerXML in Offers)
            {
                try
                {
                    count++;
                    Console.Write("Propping offer " + count + " of " + offersCount + "...");
                    MixManagement.ConfigureOffer(offerXML);
                    Console.WriteLine("Success");
                }
                catch (UnexpectedTestResultException ex)
                {
                    var offer = (Offer)DataContractSerialize.DeserializeFromXmlDoc(offerXML, typeof(Offer));
                    if (offer != null)
                    {
                        Console.WriteLine("Propping offer \"{0}\" failed:", offer.OfferId.ToString());

                        // Propping offer had validation issues, report them to the user
                        if (ex.InnerException is FaultException<ValidationFault>)
                        {
                            FaultException<ValidationFault> validationFault = ex.InnerException as FaultException<ValidationFault>;
                            foreach (ValidationDetail detail in validationFault.Detail.Details)
                                Console.WriteLine("Error: " + detail.Message);
                        }
                        else
                        {
                            Console.WriteLine(ex.InnerException.ToString());
                        }
                        success = false;
                    }
                    else
                    {
                        Console.WriteLine("Product XML is malformed");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Failed");
                    Console.WriteLine(ex.ToString());
                    success = false;
                }
            }
            return success;
        }

        public void Serialize(string path, string fileName)
        {
            Serialize(path + fileName);
        }

        public void Serialize()
        {
            Serialize(this.FileName);
        }

        public void Serialize(string fileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(MixTestDataFile));
            using (var textWriter = new StreamWriter(fileName))
            {
                serializer.Serialize(textWriter, this);
            }
        }

        public static MixTestDataFile Deserialize(string FileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(MixTestDataFile));
            using (var fs = new FileStream(FileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlReader reader = new XmlTextReader(fs);
                var result = (MixTestDataFile)serializer.Deserialize(reader);
                result.FileName = FileName;
                return result;
            }
        }

        /// <summary>
        /// "Fix" broken test data by passing through each product and updating it if it is broken.  This can possibly create invalid data.
        /// </summary>
        /// <returns></returns>

        public bool FixProducts()
        {
            bool productFixed = false;

            for(int i = 0;i<_Products.Count();i++)
            {
                var productXml = _Products[i];
                var newProduct = MixManagement.FixProduct(productXml);
                if (newProduct != null)
                {
                    productFixed = true;
                    productXml = DataContractSerialize.ObjectToXml(newProduct);
                    _Products[i] = productXml;
                }
            }
            return !productFixed;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\MixManagement.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.ServiceModel;
using System.Text;
using System.Xml;
using MIXTesting;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

using ServerTestFramework;
using System.Xml.Linq;

namespace MixPropTool
{
    class MixManagement
    {
        // Private members for maintaining product/offer management WCF objects
        #region Private Members

        public static string MixAddress = "";

        private static ProductManagementWCFClient ProductManagementClient
        {
            get
            {
                if(MixAddress == "")
                    return new ProductManagementWCFClient();
                return new ProductManagementWCFClient(MixAddress);
            }
        }

        private static OfferManagementWCFClient OfferManagementClient
        {
            get
            {
                if (MixAddress == "")
                    return new OfferManagementWCFClient();
                return new OfferManagementWCFClient(MixAddress);
            }
        }
        #endregion

        // Public members for maintaining product/offer and their relationships with legacy test data
        #region Public Members

        public static Dictionary<Guid, MixResult> MixProducts = new Dictionary<Guid, MixResult>();
        public static Dictionary<Guid, MixResult> MixOffers = new Dictionary<Guid, MixResult>();

        public static Dictionary<Guid, List<LegacyTestDataFile>> ProductTestDataToFileMapping = new Dictionary<Guid, List<LegacyTestDataFile>>();
        public static Dictionary<Guid, List<LegacyTestDataFile>> OfferTestDataToFileMapping = new Dictionary<Guid, List<LegacyTestDataFile>>();

        public static Dictionary<string, LegacyTestDataFile> LegacyTestDataFiles = new Dictionary<string, LegacyTestDataFile>();

        public static Dictionary<Guid, Product> ProductData = new Dictionary<Guid, Product>();
        public static Dictionary<Guid, Offer> OfferData = new Dictionary<Guid, Offer>();

        #endregion


        /// <summary>
        /// Reset STF and set the environment
        /// </summary>
        public static void InitializeSTF(string catalogServer, string NPDBServer)
        {
            var xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(
                new XElement("stf",
                    new XElement("config",
                        new XElement("configenv",
                            new XAttribute("environment", catalogServer),
                            new XAttribute("npdbip", NPDBServer)
                        )
                    )
                ).ToString()
            );

            // Initialize STF, set the environment and reset
            ServerTestFramework.CoreGlobal.Initialize(xmlDocument);
            ServerTestFramework.Global.CurrentEnvironment = ServerTestFramework.Global.EnvironmentList[0];
            ServerTestFramework.Global.ResetEnvironment();
        }

        /// <summary>
        /// Reset 
        /// </summary>
        public static void InitalizeMix(string mixAddress)
        {
            MixAddress = mixAddress;
        }

        #region Add Expected Items
        /// <summary>
        /// Adds an product to the expected products list
        /// </summary>
        /// <param name="ProductId"></param>
        /// <param name="FileName"></param>
        protected static void AddExpectedProduct(Guid productId, string fileName)
        {
            LegacyTestDataFiles[fileName].AddExpectedProduct(productId);
            if (!ProductTestDataToFileMapping.ContainsKey(productId))
                ProductTestDataToFileMapping[productId] = new List<LegacyTestDataFile>();
            ProductTestDataToFileMapping[productId].Add(LegacyTestDataFiles[fileName]);
        }

        /// <summary>
        /// Adds an offer to the expected offers list
        /// </summary>
        /// <param name="OfferId"></param>
        /// <param name="FileName"></param>
        protected static void AddExpectedOffer(Guid offerId, string fileName)
        {
            LegacyTestDataFiles[fileName].AddExpectedOffer(offerId);
            if (!OfferTestDataToFileMapping.ContainsKey(offerId))
                OfferTestDataToFileMapping[offerId] = new List<LegacyTestDataFile>();
            OfferTestDataToFileMapping[offerId].Add(LegacyTestDataFiles[fileName]);
        }
        #endregion

        /// <summary>
        /// Reads all legacy test data from a specified path
        /// </summary>
        /// <param name="Path">Location of legacy test data</param>
        public static void ReadLegacyTestData(string path)
        {

            // Enumerate all test data
            Console.WriteLine("Reading all legacy test data...");

            DirectoryInfo testDataPath = new DirectoryInfo(path);

            Action<string, XmlNode> FindMediaAndOffers = null; // Needed for recurision

            FindMediaAndOffers = (FileName, RootNode) =>
                 {
                     if (RootNode.Name.ToLower() == "media")
                     {
                         foreach (XmlNode childNode in RootNode.ChildNodes)
                         {
                             if (childNode.Name.ToLower() == "mediaid")
                             {
                                 if (childNode.InnerText != null && childNode.InnerText != "")
                                 {
                                     // Product definition found, we expect to find this in Mix
                                     Guid mediaId = new Guid(childNode.InnerText);
                                     AddExpectedProduct(mediaId, FileName);
                                 }
                                 break;
                             }
                         }
                         return;
                     }

                     if (RootNode.Name.ToLower() == "offer")
                     {
                         foreach (XmlNode childNode in RootNode.ChildNodes)
                         {
                             if (childNode.Name.ToLower() == "offerid")
                             {
                                 if (childNode.InnerText != null && childNode.InnerText != "")
                                 {
                                     // Offer definition found, we expect to find this in Mix
                                     Guid offerId = new Guid(childNode.InnerText);
                                     AddExpectedOffer(offerId, FileName);
                                 }
                                 break;
                             }
                         }
                         return;
                     }

                     foreach (XmlNode childNode in RootNode.ChildNodes)
                         FindMediaAndOffers(FileName, childNode);

                 };

            // Get all of the legacy test data files from the path in XML format
            var testFiles = testDataPath.GetFiles("*.xml");

            int count = 0;
            foreach (var testFile in testFiles)
            {
                count++;
                Console.WriteLine("[{0}/{1}] Working on: {2}", count.ToString(), testFiles.Count(), testFile.Name);

                // Add this legacy test data file to the dict
                LegacyTestDataFiles.Add(testFile.Name, new LegacyTestDataFile(testFile));

                // Load the legacy test data and find all of the media and offers
                var xmlDoc = new XmlDocument();
                xmlDoc.Load(testFile.FullName);

                // Loop through each node and find the offers and media
                foreach (XmlNode xmlNodes in xmlDoc.ChildNodes)
                    FindMediaAndOffers(testFile.Name, xmlNodes);
            }

            Console.WriteLine("Completed reading old test data.  Found {0} Products and {1} Offers.", ProductTestDataToFileMapping.Count, OfferTestDataToFileMapping.Count);
        }

        // Product management

        /// <summary>
        /// Get all products from the database
        /// </summary>
        public static void GetAllProducts(string catalogConnectionString)
        {
            using (SqlConnection connection = new SqlConnection(catalogConnectionString + ";Initial Catalog=RawCatalogDB;"))
            {
                connection.Open();

                // Enumerate all MediaIds with the correct mediaTypeId
                string commandText = "SELECT MediaID FROM MEDIA WHERE mediaTypeId in (1, 5, 18, 19, 20, 21, 22, 23, 24, 30, 34, 36, 37, 45, 46, 47)";
                SqlDataAdapter dataAdapter = new SqlDataAdapter(commandText, connection);
                DataTable dataTable = new DataTable();
                int productCount = dataAdapter.Fill(dataTable);

                int count = 0;
                foreach (DataRow result in dataTable.Rows)
                {
                    count++;
                    Console.Write("[{0}/{1}] ", count.ToString(), productCount.ToString());
                    var newProductGuid = new Guid(result[0].ToString());
                    if (!Directory.Exists("Products"))
                        Directory.CreateDirectory("Products");
                    MixProducts.Add(newProductGuid, GetProduct(newProductGuid, @"Products\"));
                }
            }
        }

        /// <summary>
        /// Gets a specific product from Mix
        /// </summary>
        /// <param name="ProductId">Product ID of the product to get</param>
        /// <param name="Path">Output path for the resulting product XML</param>
        /// <returns></returns>
        public static MixResult GetProduct(Guid productId, string path)
        {
            Console.Write("Getting Product: {0}...", productId);
            var result = new MixResult();
            result.Guid = productId;
            result.Name = "Product";
            result.LegacyTestDataMapping = ProductTestDataToFileMapping;
            Product product = null;// Replace with "Product product = ReadProduct(ProductId, Path);" to enable cached reading from disk
            if (product == null)
            {
                try
                {
                    product = ProductManagementClient.GetProduct(productId);
                    ProductData[productId] = product;
                    WriteProduct(path, product);
                    result.Result = "Success";
                }
                catch (UnexpectedTestResultException e)
                {
                    result.Exception = e;
                    result.Result = "Failed";
                    if (e.InnerException is FaultException<ValidationFault>)
                    {
                        // Propping item had validation issues, report them to the user
                        FaultException<ValidationFault> validationFault = e.InnerException as FaultException<ValidationFault>;
                        foreach (ValidationDetail detail in validationFault.Detail.Details)
                            Console.WriteLine("Error: " + detail.Message);
                    }
                }
                catch (Exception e)
                {
                    result.Exception = e;
                    result.Result = "Failed";
                }
            }
            else
            {
                ProductData[productId] = product;
                result.Result = "Success";
            }

            result.Object = product;
            if (ProductTestDataToFileMapping.ContainsKey(productId))
            {
                foreach(var legacyTestDataFile in ProductTestDataToFileMapping[productId])
                    legacyTestDataFile.AddMigratedProductResult(result);
            }

            Console.WriteLine(result.Result);
            return result;
        }

        /// <summary>
        /// Write a product out to XML
        /// </summary>
        /// <param name="FileName"></param>
        /// <param name="NewProduct"></param>
        static void WriteProduct(string fileName, Product newProduct)
        {
            var doc = DataContractSerialize.ObjectToXml(newProduct);
            //Global.RO.Success(MediaOperationsHelper.FormatXml(doc.DocumentElement));

            using (var writer = new XmlTextWriter(fileName + "Product-" + newProduct.ProductId + ".xml", null))
            {
                writer.Formatting = Formatting.Indented;
                doc.Save(writer);
            }
        }

        /// <summary>
        /// Static list of all of the known product types
        /// </summary>
        private static List<Type> _KnownTypes;
        public static List<Type> KnownTypes
        {
            get
            {
                if (_KnownTypes == null)
                {
                    _KnownTypes = new List<Type>();
                    _KnownTypes.Add(typeof(SubscriptionFamily));
                    _KnownTypes.Add(typeof(Subscription));
                    _KnownTypes.Add(typeof(GameConsumable));
                    _KnownTypes.Add(typeof(LiveSubscriptionFamily));
                    _KnownTypes.Add(typeof(GameSubscriptionFamily));
                    _KnownTypes.Add(typeof(ContentSubscriptionFamily));
                    _KnownTypes.Add(typeof(Game));
                    _KnownTypes.Add(typeof(App));
                    _KnownTypes.Add(typeof(Bundle));
                    _KnownTypes.Add(typeof(LiveSubscription));
                    _KnownTypes.Add(typeof(GameSubscription));
                    _KnownTypes.Add(typeof(ContentSubscription));
                    _KnownTypes.Add(typeof(PointsBundle));
                    _KnownTypes.Add(typeof(MediaBase));
                    _KnownTypes.Add(typeof(Image));
                    _KnownTypes.Add(typeof(ProductBase));
                    _KnownTypes.Add(typeof(GameContent));
                    _KnownTypes.Add(typeof(AvatarItem));
                }
                return _KnownTypes;
            }
        }

        /// <summary>
        /// Reads product from XML file
        /// </summary>
        /// <param name="FileName"></param>
        /// <returns></returns>
        public static Product ReadProduct(string fileName)
        {
            if (!System.IO.File.Exists(fileName))
                return null;
            foreach (var knownType in KnownTypes)
            {
                try
                {
                    var doc = DataContractSerialize.DeserializeFromFile(fileName, knownType);
                    return (Product)doc;
                }
                catch { }
            }

            return null;
        }

        /// <summary>
        /// Reads product from XML document
        /// </summary>
        /// <param name="ProductXML"></param>
        /// <returns></returns>
        public static Product ReadProduct(XmlDocument productXML)
        {
            foreach (var knownType in KnownTypes)
            {
                try
                {
                    var doc = DataContractSerialize.DeserializeFromXmlDoc(productXML, knownType);
                    return (Product)doc;
                }
                catch { }
            }

            return null;
        }

        public static void ConfigureProduct(XmlDocument productXML)
        {
            var product = ReadProduct(productXML);
            ProductManagementClient.ConfigureProduct(product);
        }

        public static void ConfigureProduct(Product Product)
        {
            ProductManagementClient.ConfigureProduct(Product);
        }

        public static void ConfigureProduct(string productFile, Type t)
        {
            var product = (Product)DataContractSerialize.DeserializeFromFile(productFile, t);
            ProductManagementClient.ConfigureProduct(product);
        }

        /// <summary>
        /// Fixes a product executable's ContentId, PublickKey and SymKey that are of invalid lenghts.
        /// </summary>
        /// <param name="ProductXML"></param>
        /// <returns></returns>
        public static Product FixProduct(XmlDocument productXML)
        {
            var ok = true;
            var rand = new Random();
            var product = ReadProduct(productXML);
            if (product as Game != null)
            {
                var game = product as Game;
                foreach (var executible in game.Executables)
                {
                    if (executible.ContentId.Length != 20)
                    {
                        Console.WriteLine("{0} has an invalid ContentId length ({1})", game.ProductId, executible.ContentId.Length);

                        // Fill the content id with random data
                        executible.ContentId = new byte[20];
                        rand.NextBytes(executible.ContentId);                     
                        ok = false;
                    }

                    if (executible.Encryption.PublicKey.Length != 284)
                    {
                        Console.WriteLine("{0} has an invalid PublicKey length ({1})", game.ProductId, executible.Encryption.PublicKey.Length);

                        // Fill the public key id with random data
                        executible.Encryption.PublicKey = new byte[284];
                        rand.NextBytes(executible.Encryption.PublicKey);
                        ok = false;
                    }

                    if (executible.Encryption.SymKey.Length != 16)
                    {
                        Console.WriteLine("{0} has an invalid SymKey length ({1})", game.ProductId, executible.Encryption.SymKey.Length);

                        // Fill the public key id with random data
                        executible.Encryption.SymKey = new byte[16];
                        rand.NextBytes(executible.Encryption.SymKey);
                        ok = false;
                    }
                }
            }

            if (product as GameContent != null)
            {
                var gameContent = product as GameContent;
                foreach (var package in gameContent.Packages)
                {
                    if (package.ContentId.Length != 20)
                    {
                        Console.WriteLine("{0} has an invalid ContentId length ({1})", gameContent.ProductId, package.ContentId.Length);
                        package.ContentId = new byte[20];
                        rand.NextBytes(package.ContentId);    
                        ok = false;
                    }
                }
            }
            
            if(ok)
                return null;

            return product;
        }

        // Offer management

        /// <summary>
        /// Gets all offers from the database
        /// </summary>
        /// <returns></returns>
        public static List<MixResult> GetAllOffers(string catalogConnectionString)
        {

            var results = new List<MixResult>();
            using (SqlConnection connection = new SqlConnection(catalogConnectionString + ";Initial Catalog=RawCatalogDB;"))
            {
                connection.Open();
                /// Only retrieve offers that relate specifically to Mix media types
                string commandText = "SELECT OfferID FROM OFFER JOIN MEDIA ON OFFER.mediaId = MEDIA.mediaId WHERE MEDIA.mediaTypeId in (1, 5, 18, 19, 20, 21, 22, 23, 24, 30, 34, 36, 37, 45, 46, 47)";
                SqlDataAdapter dataAdapter = new SqlDataAdapter(commandText, connection);
                DataTable dataTable = new DataTable();
                int offerCount = dataAdapter.Fill(dataTable);

                int count = 0;
                foreach (DataRow result in dataTable.Rows)
                {
                    count++;
                    Console.Write("[{0}/{1}] ", count.ToString(), offerCount.ToString());
                    var newOfferGuid = new Guid(result[0].ToString());
                    if (!Directory.Exists("Offers"))
                        Directory.CreateDirectory("Offers");
                    MixOffers.Add(newOfferGuid, GetOffer(newOfferGuid, @"Offers\"));
                }
            }
            return results;
        }

        /// <summary>
        /// Gets a specific offer from the database
        /// </summary>
        /// <param name="OfferId"></param>
        /// <param name="Path"></param>
        /// <returns></returns>
        public static MixResult GetOffer(Guid offerId, string path)
        {
            Console.Write("Getting Offer: {0}...", offerId);
            var result = new MixResult();
            result.Guid = offerId;
            result.Name = "Offer";
            result.LegacyTestDataMapping = OfferTestDataToFileMapping;
            Offer offer = null; // Replace with "Offer offer = ReadOffer(OfferId, Path);" to enable cached reading from disk
            if (offer == null)
            {
                try
                {
                    offer = OfferManagementClient.GetOffer(offerId);
                    OfferData[offerId] = offer;
                    WriteOffer(path, offer);
                    result.Result = "Success";
                }
                catch (UnexpectedTestResultException e)
                {
                    result.Exception = e;
                    result.Result = "Failed";
                    if (e.InnerException is FaultException<ValidationFault>)
                    {
                        // Propping item had validation issues, report them to the user
                        FaultException<ValidationFault> validationFault = e.InnerException as FaultException<ValidationFault>;
                        foreach (ValidationDetail detail in validationFault.Detail.Details)
                            Console.WriteLine("Error: " + detail.Message);
                    }
                }
                catch (Exception e)
                {
                    result.Exception = e;
                    result.Result = "Failed";
                }
            }
            else
            {
                OfferData[offerId] = offer;
                result.Result = "Success";
            }

            result.Object = offer;
            if (OfferTestDataToFileMapping.ContainsKey(offerId))
            {
                foreach (var legacyTestDataFile in OfferTestDataToFileMapping[offerId])
                    legacyTestDataFile.AddMigratedOfferResult(result);
            }

            Console.WriteLine(result.Result);
            return result;
        }

        /// <summary>
        /// Write an offer out to XML
        /// </summary>
        /// <param name="Path"></param>
        /// <param name="NewOffer"></param>
        public static void WriteOffer(string path, Offer newOffer)
        {
            XmlDocument doc = DataContractSerialize.ObjectToXml(newOffer);
            using (var writer = new XmlTextWriter(path + "Offer - " + newOffer.OfferId + ".xml", null))
            {
                writer.Formatting = Formatting.Indented;
                doc.Save(writer);
            }
        }

        /// <summary>
        /// Read an offer from disk
        /// </summary>
        /// <param name="FileName"></param>
        /// <returns></returns>
        public static Offer ReadOffer(string fileName)
        {
            try
            {
                var doc = (Offer)DataContractSerialize.DeserializeFromFile(fileName, typeof(Offer));
                return doc;
            }
            catch { }
            return null;
        }

        /// <summary>
        /// Read an offer from an XML document
        /// </summary>
        /// <param name="OfferXML"></param>
        /// <returns></returns>
        public static Offer ReadOffer(XmlDocument offerXML)
        {
            var doc = DataContractSerialize.DeserializeFromXmlDoc(offerXML, typeof(Offer));
            return (Offer)doc;
        }

        public static void ConfigureOffer(XmlDocument offerXML)
        {
            OfferManagementClient.ConfigureOffer(ReadOffer(offerXML));
        }

        public static void ConfigureOffer(Offer offer)
        {
            OfferManagementClient.ConfigureOffer(offer);
        }

        public static void ConfigureOffer(string offerFile)
        {
            var offer = (Offer)DataContractSerialize.DeserializeFromFile(offerFile, typeof(Offer));
            OfferManagementClient.ConfigureOffer(offer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\MixResult.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.IO;

namespace MixPropTool
{
    /// <summary>
    /// Definition of a result from Mix
    /// </summary>
    public class MixResult
    {
        #region Public Members
        public Guid Guid
        { get; set; }

        public string Name
        { get; set; }

        public string Result
        { get; set; }

        public object Object
        { get; set; }

        public bool Success
        {
            get
            {
                return Result == "Success";
            }
        }
        public Exception Exception;
        public string ErrorCode
        {
            get
            {
                if (Exception != null)
                {
                    try
                    {
                        var exceptionString = Exception.ToString();
                        string lookup = "call failed with HR =";
                        return exceptionString.Substring(exceptionString.IndexOf(lookup) + lookup.Length, 10);
                    }
                    catch
                    {
                    }
                }
                return "";
            }
        }
        public Dictionary<Guid, List<LegacyTestDataFile>> LegacyTestDataMapping;

        #endregion

        public void WriteResult(StreamWriter writer)
        {
            string errorText = "";
            if (this.Exception != null)
            {
                errorText = this.Exception.ToString();
                if (this.Exception.InnerException != null)
                    errorText += " - " + this.Exception.InnerException.ToString();
            }
            writer.Write(this.Guid + "\t" + this.Name + "\t" + this.Result + "\t");

            // If we have mapping test data, write it out
            if (LegacyTestDataMapping != null && LegacyTestDataMapping.Count > 0)
            {
                if (LegacyTestDataMapping.ContainsKey(Guid))
                {
                    for (int index = 0; index < LegacyTestDataMapping[Guid].Count; index++)
                    {
                        writer.Write(LegacyTestDataMapping[Guid][index]);
                        if (index + 1 < LegacyTestDataMapping[Guid].Count)
                            writer.Write("; ");
                    }
                }
                writer.Write("\t");
            }

            // Write out the error
            writer.WriteLine(errorText.Replace("\r\n", " "));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixPropTool\MixPropTool\MixMigrationReport.cs ===
ï»¿using System.IO;
using System.Linq;

namespace MixPropTool
{
    public static class MixMigrationReport
    {
        public static void WriteReport(string reportPath)
        {
            // Create a new result file
            using (var foundResultsWriter = new StreamWriter(reportPath + "FoundResults.txt"))
            {
                using (var notFoundWriter = new StreamWriter(reportPath + "NotFoundResults.txt"))
                {

                    // Write all results
                    foreach (var result in MixManagement.MixOffers.Values)
                    {
                        result.WriteResult(foundResultsWriter);
                        MixManagement.OfferTestDataToFileMapping.Remove(result.Guid);
                    }

                    foreach (var notFoundOffer in MixManagement.OfferTestDataToFileMapping.Keys)
                    {
                        notFoundWriter.Write("Offer\t" + notFoundOffer + "\t");
                        foreach (var file in MixManagement.OfferTestDataToFileMapping[notFoundOffer])
                            notFoundWriter.Write(file.FileName + "; ");
                        notFoundWriter.WriteLine();
                    }

                    foreach (var result in MixManagement.MixProducts.Values)
                    {
                        result.WriteResult(foundResultsWriter);
                        MixManagement.ProductTestDataToFileMapping.Remove(result.Guid);
                    }

                    foreach (var notFoundProduct in MixManagement.ProductTestDataToFileMapping.Keys)
                    {
                        notFoundWriter.Write("Product\t" + notFoundProduct + "\t");
                        foreach (var file in MixManagement.ProductTestDataToFileMapping[notFoundProduct])
                            notFoundWriter.Write(file.FileName + "; ");
                        notFoundWriter.WriteLine();
                    }

                    using(var migrationReportDataWriter = new StreamWriter(reportPath + "Migration Report.txt"))
                    {
                        migrationReportDataWriter.WriteLine("File\tExpected Products\tMigrated Products\tFailed Products\tMissing Products\tExpected Offers\tMigrated Offers\tFailed Offers\tMissing Offers\t");
                        foreach (var testDataFileName in MixManagement.LegacyTestDataFiles.Keys)
                        {
                            // Create a new test data file
                            var newMixTestDataFile = new MixTestDataFile(testDataFileName);

                            // Write it out
                            newMixTestDataFile.Serialize("", testDataFileName + ".xml");

                            // Build a new report writer
                            using (var testDataReportWriter = new StreamWriter(reportPath + "Report-" + testDataFileName + ".txt"))
                            {

                                // Localize product lists
                                var expectedProducts = MixManagement.LegacyTestDataFiles[testDataFileName].ExpectedProductList;
                                var successfullyMigratedProducts = MixManagement.LegacyTestDataFiles[testDataFileName].SuccessfullyMigratedProducts;
                                var failedMigrationProducts = MixManagement.LegacyTestDataFiles[testDataFileName].FailedMigrationProducts;
                                var failedMigrationProductInstances = MixManagement.LegacyTestDataFiles[testDataFileName].FailedMigrationProductInstances;
                                int missingMigrationProductCount = expectedProducts.Count() - successfullyMigratedProducts.Count() - failedMigrationProducts.Count();

                                // Localize offer lists
                                var expectedOffers = MixManagement.LegacyTestDataFiles[testDataFileName].ExpectedOfferList;
                                var successfullyMigratedOffers = MixManagement.LegacyTestDataFiles[testDataFileName].SuccessfullyMigratedOffers;
                                var failedMigrationOffers = MixManagement.LegacyTestDataFiles[testDataFileName].FailedMigrationOffers;
                                var failedMigrationOfferInstances = MixManagement.LegacyTestDataFiles[testDataFileName].FailedMigrationOfferInstances;
                                int missingMigrationOfferCount = expectedOffers.Count() - successfullyMigratedOffers.Count() - failedMigrationOffers.Count();

                                testDataReportWriter.WriteLine("File: " + testDataFileName + "\t");
                                migrationReportDataWriter.Write(testDataFileName + "\t");

                                testDataReportWriter.WriteLine("Expected Products:\t" + expectedProducts.Count() + "\t");
                                migrationReportDataWriter.Write(expectedProducts.Count() + "\t");
                                testDataReportWriter.WriteLine("Successfully Migrated Products:\t" + successfullyMigratedProducts.Count() + "\t");
                                migrationReportDataWriter.Write(successfullyMigratedProducts.Count() + "\t");
                                testDataReportWriter.WriteLine("Failed Migrated Products:\t" + failedMigrationProducts.Count() + "\t");
                                migrationReportDataWriter.Write(failedMigrationProducts.Count() + "\t");
                                testDataReportWriter.WriteLine("Missing Products:\t" + missingMigrationProductCount + "\t");
                                migrationReportDataWriter.Write(missingMigrationProductCount + "\t");

                                testDataReportWriter.WriteLine("Expected Offers:\t" + expectedOffers.Count() + "\t");
                                migrationReportDataWriter.Write(expectedOffers.Count() + "\t");
                                testDataReportWriter.WriteLine("Successfully Migrated Offers:\t" + successfullyMigratedOffers.Count() + "\t");
                                migrationReportDataWriter.Write(successfullyMigratedOffers.Count() + "\t");
                                testDataReportWriter.WriteLine("Failed Migrated Offers:\t" + failedMigrationOffers.Count() + "\t");
                                migrationReportDataWriter.Write(failedMigrationOffers.Count() + "\t");
                                testDataReportWriter.WriteLine("Missing Offers:\t" + missingMigrationOfferCount + "\t");
                                migrationReportDataWriter.Write(missingMigrationOfferCount + "\t");

                                migrationReportDataWriter.WriteLine();

                                testDataReportWriter.WriteLine("Products");
                                foreach (var expectedProduct in expectedProducts)
                                {
                                    testDataReportWriter.Write(expectedProduct.ToString() + "\t");
                                    if (successfullyMigratedProducts.Contains(expectedProduct))
                                        testDataReportWriter.Write("Success\t");
                                    else if (failedMigrationProducts.Contains(expectedProduct))
                                    {
                                        testDataReportWriter.Write("Failed\t");
                                        var failedMixResult = failedMigrationProductInstances.Where(x => x.Guid == expectedProduct).FirstOrDefault();
                                        if (failedMixResult != null)
                                            testDataReportWriter.Write(failedMixResult.ErrorCode);
                                    }
                                    else
                                        testDataReportWriter.Write("Not Found\t");
                                    testDataReportWriter.WriteLine();
                                }

                                testDataReportWriter.WriteLine("\r\nOffers");
                                foreach (var expectedOffer in expectedOffers)
                                {
                                    testDataReportWriter.Write(expectedOffer.ToString() + "\t");
                                    if (successfullyMigratedOffers.Contains(expectedOffer))
                                        testDataReportWriter.Write("Success\t");
                                    else if (failedMigrationOffers.Contains(expectedOffer))
                                    {
                                        testDataReportWriter.Write("Failed\t");
                                        var failedMixResult = failedMigrationOfferInstances.Where(x => x.Guid == expectedOffer).FirstOrDefault();
                                        if (failedMixResult != null)
                                            testDataReportWriter.Write(failedMixResult.ErrorCode);
                                    }
                                    else
                                        testDataReportWriter.Write("Not Found\t");
                                    testDataReportWriter.WriteLine();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\MixTestHelper.cs ===
using System;
using MIXTesting;

namespace MixTest
{
    public class MixTestHelper<TClientType> : IDisposable
        where TClientType : WCFClientBase, new()
    {
        private Boolean disposed = false;

        public TClientType Client { get; protected set; }

        public MixTestHelper()
        {
            Client = new TClientType();
        }

        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        protected void Dispose(Boolean disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Cleanup();
                }

                disposed = true;
            }
        }

        public virtual void Cleanup() { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Catalog.cs ===
ï»¿//-----------------------------------------------------------------------
// <copyright file="Catalog.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to interact with the catalog
// </summary>
//-----------------------------------------------------------------------
namespace MIXTesting
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.IO;
    using System.Reflection;
    using System.Net;
    using System.Data;
    using System.Xml;
    using System.Xml.XPath;

    using Microsoft.XmlDiffPatch;

    using ServerTestFramework;
    using ServerTestFramework.LiveService;

    using ProductV1 = xonline.mix.productmanagement.contracts.V1;
    
    using OfferV1 = xonline.mix.offermanagement.contracts.V1;

    /// <summary>
    /// Provides access to get, set, and remove objects from the catalog
    /// </summary>
    public class Catalog
    {
        /// <summary>
        /// RawCatalogDb connection string 
        /// </summary>
        static string RawCatalogDbConnectionString = null;

        /// <summary>
        /// sqlGameRemove is the sql script to remove the game and its associated content from the catalog
        /// </summary>
        private string sqlGameRemove;

        /// <summary>
        /// sqlOfferRemove is the sql script to remove the offer from the catalog
        /// </summary>
        private string sqlOfferRemove;

        /// <summary>
        /// Diff report generator
        /// </summary>
        private static XmlDiffReport xmlDiffReport = new XmlDiffReport();

        /// <summary>
        /// Initializes a new instance of the Catalog class
        /// </summary>
       
        public Catalog()
        {
            // Get the RawCatalogDB connection string from info in NPDB
            string[] servers = Global.XEnv.GetServerListByInterface("ContentIngestionCatalogDB");

            string catalogServer = servers[0];
            RawCatalogDbConnectionString = "Server=" + catalogServer + ";Database=RawCatalogDB;Trusted_Connection=sspi";

            // Global.RO.Info("Connection String : " + RawCatalogDbConnectionString);

            // load the game remove sql script
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Resources.GameRemove.sql"))
            {
                using (StreamReader streamReader = new StreamReader(stream))
                {
                    this.sqlGameRemove = streamReader.ReadToEnd();
                }
            }

            // load the offer remove sql script
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Resources.OfferRemove.sql"))
            {
                using (StreamReader streamReader = new StreamReader(stream))
                {
                    this.sqlOfferRemove = streamReader.ReadToEnd();
                }
            }
        }


        public static SqlDataReader RunSqlQuery(string query)
        {
            SqlDataReader reader = null;
            SqlConnection c = new SqlConnection(RawCatalogDbConnectionString);

            try
            {
                c.Open();
                using (SqlCommand cmd = c.CreateCommand())
                {
                    cmd.CommandText = query;
                    cmd.CommandType = System.Data.CommandType.Text;

                    Global.RO.Info("Executing: " + cmd.CommandText);

                    reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);                    
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn(string.Format("Exception to open {0} : {1}", RawCatalogDbConnectionString, e.Message));
            }

            return reader;
        }



        //Add the ability to run sql command on rawcatalog db directly
        public static void RunSqlCommand(string commandTxt)
        {

            using (SqlConnection c = new SqlConnection(RawCatalogDbConnectionString))
            {
                try
                {
                    c.Open();
                    using (SqlCommand cmd = c.CreateCommand())
                    {
                        cmd.CommandText = commandTxt;
                        cmd.CommandType = System.Data.CommandType.Text;
                        Global.RO.Info("Executing: " + cmd.CommandText);

                        Global.RO.Info("Number of rows affected: " + cmd.ExecuteNonQuery());
                        c.Close();
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn(string.Format("Exception to open {0} : {1}", RawCatalogDbConnectionString, e.Message));
                }
            }
        }
        /// <summary>
        /// Returns a query string for selecting the modifiedDate for a specific Media
        /// <param name="mediaId">The media id for the product</param>
        /// </summary>
        public static string SqlQueryGetMediaModifiedDate(Guid mediaId)
        {
            return String.Format("select modifiedDate from Media where mediaId = '{0}'", mediaId);
        }
        /// <summary>
        /// Remove the game and its associated content from the catalog
        /// </summary>
        /// <param name="value">The media id for the game</param>
        public void Remove(Guid value)
        {
            Global.RO.Info("Removing Product " + value.ToString());

            // remove the system update
            using (SqlConnection sqlConnection = new SqlConnection(RawCatalogDbConnectionString))
            {
                sqlConnection.Open();

                // create the sql transaction so we can rollback on any error
                SqlTransaction sqlTransaction = sqlConnection.BeginTransaction();

                // create the sql parameter which is the media id (guid)
                SqlParameter sqlParameter = new SqlParameter();
                sqlParameter.DbType = System.Data.DbType.Guid;
                sqlParameter.ParameterName = "@mediaId";
                sqlParameter.Value = value;

                // create the sql command which is the game remove script
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = this.sqlGameRemove;
                sqlCommand.Parameters.Add(sqlParameter);
                sqlCommand.Transaction = sqlTransaction;
                sqlCommand.CommandTimeout = 300;

                try
                {
                    // execute the sql command
                    sqlCommand.ExecuteNonQuery();

                    // commit the transaction
                    sqlTransaction.Commit();
                }
                catch (SqlException e)
                {
                    try
                    {
                        // attempt to rollback the transaction
                        sqlTransaction.Rollback();
                    }
                    catch (SqlException)
                    {
                    }

                    throw new UnexpectedTestResultException(String.Format("Cannot Remove Game From Catalog.  SqlException: {0}", e.Message));
                }

                sqlCommand.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Save the media to the catalog
        /// </summary>
        public static void ConfigureProduct(out Exception e, Object media, CustomHttpHeader[] headers)
        {
            var client = new ProductManagementWCFClient();
            client.CustomHttpHeaders = headers;
            client.ConfigureProduct((ProductV1.Product)media, out e);
            return;
        }

        /// <summary>
        /// Get the media and its associated content from the catalog
        /// </summary>
        public static Object GetProduct(out Exception e, Guid Id, CustomHttpHeader[] headers)
        {
            var client = new ProductManagementWCFClient();
            client.CustomHttpHeaders = headers;
            return (ProductV1.MediaBase)client.GetProduct(Id, out e);
        }

        /// <summary>
        /// Save offer to catalog
        /// </summary>
        public static void ConfigureOffer(out Exception e, Object offer, CustomHttpHeader[] headers)
        {
            var client = new OfferManagementWCFClient();
            client.CustomHttpHeaders = headers;
            client.ConfigureOffer((OfferV1.Offer)offer, out e);
            return;
        }

        /// <summary>
        /// Get offer from  catalog
        /// </summary>
        public static Object GetOffer(out Exception e, Guid Id, CustomHttpHeader[] headers)
        {
            var client = new OfferManagementWCFClient();
            client.CustomHttpHeaders = headers;
            return client.GetOffer(Id, out e);       
        }

        /// <summary>
        /// Remove the offer from the catalog
        /// </summary>
        /// <param name="offerId">The offer id to remove</param>
        public void RemoveOffer(Guid offerId)
        {
            Global.RO.Info("Removing Offer " + offerId.ToString());

            // remove the system update
            using (SqlConnection sqlConnection = new SqlConnection(RawCatalogDbConnectionString))
            {
                sqlConnection.Open();

                // create the sql transaction so we can rollback on any error
                SqlTransaction sqlTransaction = sqlConnection.BeginTransaction();

                // create the sql parameter which is the media id (guid)
                SqlParameter sqlParameter = new SqlParameter();
                sqlParameter.DbType = System.Data.DbType.Guid;
                sqlParameter.ParameterName = "@offerId";
                sqlParameter.Value = offerId;

                // create the sql command which is the game remove script
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = this.sqlOfferRemove;
                sqlCommand.Parameters.Add(sqlParameter);
                sqlCommand.Transaction = sqlTransaction;
                sqlCommand.CommandTimeout = 300;

                try
                {
                    // execute the sql command
                    sqlCommand.ExecuteNonQuery();

                    // commit the transaction
                    sqlTransaction.Commit();
                }
                catch (SqlException e)
                {
                    try
                    {
                        // attempt to rollback the transaction
                        sqlTransaction.Rollback();
                    }
                    catch (SqlException)
                    {
                    }

                   throw new UnexpectedTestResultException(String.Format("Cannot Remove Offer From Catalog.  SqlException: {0}", e.Message));
                }

                sqlCommand.ExecuteNonQuery();
            }
        }

        public static bool Compare(Object a, Object b)
        {
            XmlDocument xmlDocumentThis = DataContractSerialize.ObjectToXml(a);
            XmlDocument xmlDocumentOther = DataContractSerialize.ObjectToXml(b);
           
            return Compare(xmlDocumentOther, xmlDocumentThis);           
        }

        public static bool Compare(XmlDocument xmlDocumentThis, XmlDocument xmlDocumentOther)
        {
            xmlDiffReport.Compare(xmlDocumentOther, xmlDocumentThis);

            if (xmlDiffReport.Details.Count == 0)
                Global.RO.Success("Two object xml comparison is equal");

            foreach (XmlDiffDetail xmlDiffDetail in xmlDiffReport.Details)
            {
                Global.RO.Warn("XmlDiffDetail:");
                Global.RO.Warn("  Difference: " + xmlDiffDetail.Difference);

                if (null != xmlDiffDetail.Source)
                {
                    Global.RO.Warn("  Source:");
                    Global.RO.Warn("    XPath: " + xmlDiffDetail.Source.XPath);
                    Global.RO.Warn("    XPathLocation: " + xmlDiffDetail.Source.XPathLocation);
                    Global.RO.Warn("    Value: " + xmlDiffDetail.Source.Value);
                }

                if (null != xmlDiffDetail.Destination)
                {
                    Global.RO.Warn("  Destination:");
                    Global.RO.Warn("    XPath: " + xmlDiffDetail.Destination.XPath);
                    Global.RO.Warn("    XPathLocation: " + xmlDiffDetail.Destination.XPathLocation);
                    Global.RO.Warn("    Value: " + xmlDiffDetail.Destination.Value);
                }
            }

            return 0 == xmlDiffReport.Details.Count;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Config.cs ===
ï»¿//-----------------------------------------------------------------------
// <copyright file="Config.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to load the config
// </summary>
//-----------------------------------------------------------------------
namespace MIXTesting
{
    using System;
    using System.Configuration;
    using System.Reflection;
    using ServerTestFramework;
    using ServerTestFramework.Database;
    using xonline.common.config;


    /// <summary>
    /// Provides access to the configuration
    /// </summary>
    public class Config
    {
        /*/// <summary>
        /// catalogServicesPath is the path portion of the web service url
        /// </summary>
        private string catalogServicesPath;*/

        /*/// <summary>
        /// catalogServicesPort is the port portion of the web service url
        /// </summary>
        private string catalogServicesPort;*/

        /*/// <summary>
        /// catalogServicesServer is the server portion of the web service url
        /// </summary>
        private string catalogServicesServer;*/

        /// <summary>
        /// catalogServicesUrl is the web service url
        /// </summary>
        private string catalogServicesUrl =  null;

        /// <summary>
        /// catalogDatabase is the name of the sql database hosting the catalog
        /// </summary>
        private string catalogDatabase =  null;

        /// <summary>
        /// catalogServer is the name of the sql server hosting the catalog
        /// </summary>
        private string catalogServer  =  null;

        /// <summary>
        /// downloadServer is the name of the server hosting the download location
        /// </summary>
        private string downloadServer =  null;

        /// <summary>
        /// environment is the name of the current xbox live environment
        /// </summary>
        private string environment = null;
        

        /// <summary>
        /// Initializes a new instance of the Config class
        /// </summary>
        public Config()
        {
        }

        /// <summary>
        /// Gets the name of sql database hosting the catalog
        /// </summary>
        public string CatalogDatabase
        {
            get { return this.catalogDatabase; }
        }

        /// <summary>
        /// Gets the name of the sql server hosting the catalog
        /// </summary>
        public string CatalogServer
        {
            get { return this.catalogServer; }
        }

        /// <summary>
        /// Gets the url of the web service
        /// </summary>
        public string CatalogServicesUrl
        {
            get { return this.catalogServicesUrl; }
        }

        /// <summary>
        /// Gets the name of the download server
        /// </summary>
        public string DownloadServer
        {
            get { return this.downloadServer; }
        }

        /// <summary>
        /// Gets the name of the current xbox live environment
        /// </summary>
        public string Environment
        {
            get { return this.environment; }
        }

        /// <summary>
        /// Enable DebugPartner on WebSG to use a set of APIs.
        /// </summary>
        /// <param name="inter">Interface of your app</param>
        /// <param name="appname">Name of your app (Xonline.Mix.BetaManagement.Service, for example)</param>
        /// <param name="apis">The APIs you want to enable with DebugPartner</param>
        public static void EnableAPIs(string inter, string appname, params string[] apis)
        {
            foreach (string s in apis)
            {
                Global.RO.Info("Adding API {0} to t_partner_allowed_APIs", s);
                string query = String.Format("exec wsp_MSins_t_partner_allowed_apis {0},'{1}','{2}'", 
                    1, // @i_partner_id
                    s, // @vc_api_name
                    DateTime.UtcNow); // @dt_changed
                StaticWebDB.ExecuteNonQuery(query);
            }

            Global.XEnv.ExecuteXmgmtCommand(inter, "e :" + appname + " reloadpartners");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\FindGamesQueryHelper.cs ===
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using xonline.mix.productmanagement.contracts.V1;

using live.common;
using live.common.next;
using live.protocol;
using live.protocol.next;
using live.client;

using ServerTestFramework;

namespace MIXTesting
{
        /// <summary>
        /// The purpose of the class to help to do end to end verification on ConfigureProduct API
        /// (for DataContract Game, Image, GameContent)based the returns from Catalog FindGames Query. 
        /// To use the class, first initiaze the class by passing mediaId, mediatype (mediatype must be 
        /// in game class), locale and usertype). The class will query FindGames using the parameters passed in. 
        /// If the Object being queried in database and FindGames will return one entry and the associated image will 
        /// also be returned. The three APIs GetGame(), GetGameContent(), GetImage() will return the corresponding
        /// data contract object extracted from the FindGames Query. The returned objects
        /// can be compared with the object that is passed to ConfigureProduct API through XML comparsion.
        /// </summary>
        public class FindGameHelper
        {
            XmlNode root;
            string locale;
            string lcid;
            private static readonly string _liveNS = "http://www.live.com/marketplace";
            private static XmlNamespaceManager _xmlnsManager = null;
            public static XmlNamespaceManager XmlnsManager
            {
                get
                {
                    if (_xmlnsManager == null)
                    {
                        NameTable nt = new NameTable();
                        _xmlnsManager = new XmlNamespaceManager(nt);
                        _xmlnsManager.AddNamespace("live", _liveNS);
                    }
                    return _xmlnsManager;
                }
            }

            private static readonly string _atomNS = "http://www.w3.org/2005/Atom";
            private static XmlNamespaceManager _atomnsManager = null;
            public static XmlNamespaceManager AtomnsManager
            {
                get
                {
                    if (_atomnsManager == null)
                    {
                        NameTable nt = new NameTable();
                        _atomnsManager = new XmlNamespaceManager(nt);
                        _atomnsManager.AddNamespace("atom", _atomNS);
                    }
                    return _atomnsManager;
                }
            }

            public FindGameHelper(Game game, string locale, string lcid)
            {
                this.locale = locale;
                this.lcid = lcid;
                Guid mediaId = game.ProductId;
                int mType = game.GameTypeId;
                
                string response = FindGames(mediaId, mType, locale);

                XmlDocument doc = new XmlDocument();
                doc.LoadXml(response);

                root = doc.LastChild;
                if (root.Name != "feed")
                {
                    throw new Exception(" FindGames returns are not correct! Can not using FindGameHelper to do verification");
                }
            }

            string FindGames(Guid mediaId, int mType, string locale)
            {
                Xbox360Client client = new Xbox360Client();
                live.common.next.FindGamesFilter gameFilters = new FindGamesFilter();
                gameFilters.Locale = locale;
                gameFilters.LegalLocale = locale;
                gameFilters.Store = 1;
                gameFilters.PageNum = 1;
                gameFilters.PageSize = 10;
                gameFilters.DetailView = 5;
                gameFilters.MediaIds = new List<Guid>();
                gameFilters.MediaIds.Add(mediaId);
                gameFilters.OfferFilterLevel = 1;

                gameFilters.UserTypes = new List<int>();
                gameFilters.UserTypes.Add(2);

                gameFilters.MediaTypes = new List<int>();
                gameFilters.MediaTypes.Add(mType);

                gameFilters.OrderBy = 1;
                gameFilters.OrderDirection = 1;
                CatalogResponse resp = live.server.next.Catalog.FindGames(client, gameFilters);
                Global.RO.Info("FindGames Response is: \n" + resp.Response);
                return resp.Response;
            }


            Object ConvertXmlNodes(XmlNode node, string tagName, XmlNamespaceManager nameSpace, Type t)
            {
                XmlNodeList nodeList = node.SelectNodes(tagName, nameSpace);

                ArrayList array = null;
               
                if (nodeList.Count == 0) 
                    return null;

                array = new ArrayList();

                foreach (XmlNode nd in nodeList)
                {
                    if(t == typeof(int))
                            array.Add(int.Parse(nd.InnerText));
                    else { 
                        if(t == typeof(float))                        
                            array.Add(float.Parse(nd.InnerText));
                        else
                            array.Add(nd.InnerText);                            
                    }
                        
                }
                return (object)array.ToArray(t);
             }


            void FillProductBaseInfo(ProductBase productBase)
            {

                string IdStr = root.SelectSingleNode("//atom:entry/atom:id", AtomnsManager).InnerText;
                IdStr = IdStr.Substring(IdStr.LastIndexOf(':') + 1);
                productBase.ProductId = new Guid(IdStr);

                XmlNode nd = root.SelectSingleNode("//live:releaseDate", XmlnsManager);
                if (nd != null)
                    productBase.ReleaseDate = (DateTime)Convert.ChangeType(nd.InnerText, typeof(DateTime));

                nd = root.SelectSingleNode("//live:availabilityDate", XmlnsManager);
                if (nd != null)
                    productBase.VisibilityDate = (DateTime)Convert.ChangeType(nd.InnerText, typeof(DateTime));

                productBase.Ratings = GetProductRatings();     
                productBase.RatingDescriptors = GetProductRatingDescriptors();     
            }

            /// <summary>
            /// Return Game DataContract object if the mediatype of the entry returned from FindGames is Game or ArcadeGame
            /// Otherwise, return null
            /// </summary>
            public Game GetGame()
            {
                Game game = null;

                int numItems = int.Parse(root.SelectSingleNode("//live:numItems", XmlnsManager).InnerText);
                if (numItems == 0) return null;

                int mediaTypeId = int.Parse(root.SelectSingleNode("//live:media/live:mediaType", XmlnsManager).InnerText);

                if (!((MediaTypeEnum)mediaTypeId == MediaTypeEnum.Game360 || (MediaTypeEnum)mediaTypeId == MediaTypeEnum.ArcadeGame))
                {
                    return null;
                }

                game = new Game();
                game.GameTypeId = mediaTypeId;

                FillProductBaseInfo(game);


                game.LiveTitleId = uint.Parse(root.SelectSingleNode("//live:titleId", XmlnsManager).InnerText);
                game.Categories = (int[])ConvertXmlNodes(root, "//live:categoryId", XmlnsManager, typeof(int));


                return game;

            }
            /// <summary>
            /// Return GameContent DataContract object if the mediatype of the entry returned from FindGames is GameContent
            /// Otherwise, return null
            /// </summary>
            public GameContent GetGameContent()
            {
                GameContent content = null;

                int numItems = int.Parse(root.SelectSingleNode("//live:numItems", XmlnsManager).InnerText);
                if (numItems == 0) return null;


                MediaTypeEnum mediaTypeId = (MediaTypeEnum)(int.Parse(root.SelectSingleNode("//live:media/live:mediaType", XmlnsManager).InnerText));

                //check if the return is game content or not
                if (!(mediaTypeId == MediaTypeEnum.GameDemo || mediaTypeId == MediaTypeEnum.GamerTile
                    || mediaTypeId == MediaTypeEnum.ArcadeDemo ||mediaTypeId == MediaTypeEnum.GameTrailer
                    || mediaTypeId == MediaTypeEnum.InGameContent || mediaTypeId == MediaTypeEnum.InGameConsumable
                    ))
                {
                    return null;
                }

                content = new GameContent();

                FillProductBaseInfo(content);

                content.GameContentTypeId = (int)mediaTypeId;

                
                XmlNode nd = root.SelectSingleNode("//live:gameTitleMediaId", XmlnsManager);
                string IdStr = nd.InnerText;
                if (nd != null)
                {
                    content.GameRelationships = new GameRelationship[1];
                    content.GameRelationships[0] = new GameRelationship();
                    content.GameRelationships[0].GameId = new Guid(IdStr.Substring(IdStr.LastIndexOf(':') + 1));
                }

                
                content.Categories = (int[])ConvertXmlNodes(root, "//live:categoryId", XmlnsManager, typeof(int));

                return content;
            }

            /// <summary>
            /// Return Image DataContract objects if images are returned from FindGames
            /// Otherwise, return null
            /// </summary>
            public Image[] GetImages(ProductBase product)
            {                       
                XmlNodeList ndList = root.SelectNodes("//live:image", XmlnsManager);

                if(ndList == null) {
                    return null;                
                }

                Image[] images = new Image[ndList.Count];

                int i = 0;
                foreach( XmlNode node in ndList) {
                    images[i] = new Image();

                    string IdStr = node.SelectSingleNode("live:imageMediaId", XmlnsManager).InnerText;
                    IdStr = IdStr.Substring(IdStr.LastIndexOf(':') + 1);
                    images[i].ProductId = new Guid(IdStr);
                    //FindGame only return each image with only one locale 
                    images[i].LocalizedImageFiles = new LocalizedImageFile[1];
                    images[i].LocalizedImageFiles[0] = new LocalizedImageFile();
                    images[i].LocalizedImageFiles[0].FileUrl = node.SelectSingleNode("live:fileUrl", XmlnsManager).InnerText;
                    images[i].LocalizedImageFiles[0].FormatId = int.Parse(node.SelectSingleNode("live:format", XmlnsManager).InnerText);
                    images[i].LocalizedImageFiles[0].SizeId = int.Parse(node.SelectSingleNode("live:size", XmlnsManager).InnerText);
                    if (node.SelectSingleNode("live:relationshipType", XmlnsManager) != null)
                    {
                        images[i].ProductRelationships = new ProductRelationship [1];
                        images[i].ProductRelationships[0] = new ProductRelationship();
                        images[i].ProductRelationships[0].RelationshipTypeId = int.Parse(node.SelectSingleNode("live:relationshipType", XmlnsManager).InnerText);
                        if (product != null)
                            images[i].ProductRelationships[0].ProductId = product.ProductId;
                    }
                    i++;
                }                                
                return images;
            }


            int[] GetProductRatings()
            {
                int[] ratings = null;

                XmlNode nd = root.SelectSingleNode("//live:ratingId", XmlnsManager);

                if (nd == null) return null;

                //In production,  there is only one game rating Id right now. 
                ratings = new int[1];
                ratings[0] = int.Parse(root.SelectSingleNode("//live:ratingId", XmlnsManager).InnerText);

                return ratings;
            }

            int[] GetProductRatingDescriptors()
            {
                int[] ratingDescriptorIds = (int[])ConvertXmlNodes(root, "//live:ratingDescriptorId", XmlnsManager, typeof(int));
		        return ratingDescriptorIds;	
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\MediaTestGeneration.cs ===
ï»¿

namespace MIXTesting
{
    using System;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Runtime.Serialization;
    using ServerTestFramework;
    using System.IO;
    using System.Text;
    using System.Collections.Generic;
    using System.ServiceModel;
    using System.Collections;

    using xonline.mix.common;
    using ServerTestFramework.Utilities;
    using System.Data.SqlClient;
    using live.common.next;

    using xonline.mix.subscriptionfamily.contracts.v1;

    using ProductV1 = xonline.mix.productmanagement.contracts.V1;    
    
    [DataContract]
    [KnownType(typeof(ProductV1.MediaBase))]
    [KnownType(typeof(ProductV1.ProductBase))]
    public class MediaOperation
    {
        [DataMember(Order = 2)]
        public OperationEnum Operation;

        [DataMember(Order = 1)]
        public Object Media;

        [DataMember(Order = 3, IsRequired = false)]
        public CustomHttpHeader[] CustomHttpHeaders;

        [DataMember(Order = 4, IsRequired = false)]
        public Guid[] CheckDate;

        [DataMember(Order = 5, IsRequired = false)]
        public string Template = string.Empty;

        [XmlIgnore]
        public Guid MediaProductId
        {
            get
            {
                if (Media is ProductV1.Product)
                    return (Media as ProductV1.Product).ProductId;

                return Guid.Empty;
            }

            set
            {
                if (Media is ProductV1.Product)
                {
                    (Media as ProductV1.Product).ProductId = value;
                    return;
                }
            }
        }

    }


    [DataContract(Name = "Operation")]
    public enum OperationEnum
    {   //used in ContentTestCaseInfo class
        [EnumMember]
        //used in ContentTestCaseInfo class
        SaveOnly,
        //used in ContentTestCaseInfo class
        [EnumMember]
        Save,
        [EnumMember]
        SaveImmediateVerify,
        //used in ContentTestCaseInfo class
        [EnumMember]
        Get,
        [EnumMember]
        GetNegative,
        [EnumMember]
        SaveNegative,
        //used in ContentTestCasewithLocaleInfo class 
        [EnumMember]
        TestFindGameHelper,        
    }


    public class MediaOperationsHelper
    {
        public const int XboxOriginalGameEffectiveTitleId = -129070; // 0xFFFE07D2
        public const int XnaCommunityGameEffectiveTitleId = 1481508818; // 0x584E07D2

        public static string FormatXml(XmlNode xmlNode)
        {
            StringBuilder strBuilder = new StringBuilder();

            // use stringWriter to push the formated xml into our StringBuilder 
            using (StringWriter stringWriter = new StringWriter(strBuilder))
            {
                //use the Formatting of our xmlTextWriter to provide the  indentation.
                using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter))
                {
                    xmlTextWriter.Formatting = Formatting.Indented;
                    xmlNode.WriteTo(xmlTextWriter);
                }
            }
            return strBuilder.ToString();
        }

        //Only call this function when call status failed. 
        public static bool VerifyNegativeReturn(OperationEnum op, Exception e, uint expectedHR, bool isRetryable)
        {
            //Only negatvie operation would verfiy the expectpion returned. 
            if (!(op == OperationEnum.GetNegative || op == OperationEnum.SaveNegative))
            {
                Global.RO.Warn("Not a negative operation fail with exception");
                throw e;
            }

            if (e is FaultException<MixClientFault>)
            {
                FaultException<MixClientFault> faultException = (FaultException<MixClientFault>)e;
                Global.RO.Warn(faultException.Detail.Message);
                ValueCheck.TestHR("Check Returned HR:", expectedHR, faultException.Detail.HResult);
                ValueCheck.Test("Check IsRetryable:", isRetryable, faultException.Detail.IsRetryable);
                Global.RO.Success("Negative Return check pass");
                return true;
            }

            Global.RO.Warn("Not a FaultException");
            throw e;

        }


        //Only call this function when call status failed. 
        public static void VerifyNegativeReturn(Exception e, uint expectedHR, bool isRetryable)
        {
            if (e == null) throw new UnexpectedTestResultException("Expected call fail, but it success");
            
            if (e is FaultException<MixClientFault>)
            {
                FaultException<MixClientFault> faultException = (FaultException<MixClientFault>)e;
                Global.RO.Warn(faultException.Detail.Message);
                ValueCheck.TestHR("Check Returned HR:", expectedHR, faultException.Detail.HResult);
                ValueCheck.Test("Check IsRetryable:", isRetryable, faultException.Detail.IsRetryable);
                Global.RO.Success("Negative Return check pass");                
            }

            else throw e;
        }

        public static void DoVerification(MediaOperation mo, bool verboseOutput, uint expectedResult, bool isRetryable)
        {
            Exception e = null;

            string productIdOverride = Environment.GetEnvironmentVariable("PP_STF_PRODUCTID");

            if ((productIdOverride != null) && (productIdOverride != String.Empty))
            {
                Global.RO.Info("Overriding product ID with : " + productIdOverride);
                mo.MediaProductId = new Guid(productIdOverride);
            }

            if (verboseOutput)
            {
                Global.RO.Warn("Expected media:");
                XmlDocument doc = DataContractSerialize.ObjectToXml(mo.Media);
                Global.RO.Info(FormatXml(doc.DocumentElement));

                if (mo.CustomHttpHeaders != null)
                    foreach (CustomHttpHeader header in mo.CustomHttpHeaders)
                        Global.RO.Info("Customer header: Key: " + header.key + "    Value: " + header.value);
            }

            var result = Catalog.GetProduct(out e, mo.MediaProductId, mo.CustomHttpHeaders);

            if (e != null)
            {
                VerifyNegativeReturn(mo.Operation, e, expectedResult, isRetryable);
                // Just return, no need to do further verification
                return;
            }

            if (mo.Operation == OperationEnum.GetNegative)
                throw new UnexpectedTestResultException("Expected call fail, but it success");

            if (result == null)
                throw new UnexpectedTestResultException("GetObject returned NULL for " + mo.MediaProductId);

            Global.RO.Info("Verify Media: " + mo.MediaProductId);

            if (verboseOutput)
            {
                Global.RO.Warn("Media returned from the server: ");
                XmlDocument doc1 = DataContractSerialize.ObjectToXml(result);
                Global.RO.Success(FormatXml(doc1.DocumentElement));
            }
            if (!Catalog.Compare(mo.Media, result))
            {
                throw new UnexpectedTestResultException("Verifiation failed for Id " + mo.MediaProductId);
            }

            // Array of packages will be used to check effectiveLiveTitleIds for Games and 
            // for Encryption on Game and GameContent Product Packages
            Object[] packages = null;

            #region ProductV1

            // Verify the effective Title Id if the product is a game and has a package in it
            if (mo.Media is ProductV1.Game)
            {
                int expectedLiveTitleId = 0;

                ProductV1.Game g = mo.Media as ProductV1.Game;

                expectedLiveTitleId = (int)g.LiveTitleId;
                if (g.GameTypeId == (int)MediaTypeEnum.CommunityGame)
                {
                    expectedLiveTitleId = XnaCommunityGameEffectiveTitleId;
                }
                else if (g.GameTypeId == (int)MediaTypeEnum.Xbox1Game)
                {
                    expectedLiveTitleId = XboxOriginalGameEffectiveTitleId;
                }

                // Assigning Packages if the product is a Game
                packages = g.Executables;

                if ((packages != null) && (packages.Length > 0))
                {
                    int effectiveTitleId = 0;
                    using (SqlDataReader reader = Catalog.RunSqlQuery(String.Format("select effectiveLiveTitleId from GameContent where gameContentMediaId = '{0}'", mo.MediaProductId)))
                    {
                        if ((reader != null) && (reader.HasRows))
                        {
                            reader.Read();
                            effectiveTitleId = reader.GetInt32(0);
                            Global.RO.Info("Effective title Id = " + effectiveTitleId.ToString());
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Could not get effectiveTitleId for " + mo.MediaProductId.ToString());
                        }
                    }

                    if (effectiveTitleId != expectedLiveTitleId)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Expected a EffectiveLiveTitleId of {0} but got {1}",
                                            expectedLiveTitleId, effectiveTitleId));
                    }
                }
            }

            // Assigning Packages if the product is a GameContent
            if (mo.Media is ProductV1.GameContent)
            {
                ProductV1.GameContent gc = mo.Media as ProductV1.GameContent;
                packages = gc.Packages;
            }

            // Verify that Encryption occurs in the catalog only when a ProductPackage requires it
            if (packages != null)
            {
                foreach (ProductV1.ProductPackage package in packages)
                {
                    using (SqlDataReader reader = Catalog.RunSqlQuery(
                        String.Format("select 1 from GameContentInstanceEncryptedKey where gameContentInstanceId = '{0}'", package.PackageId)))
                    {
                        if (reader.HasRows)
                        {
                            // Data in Catalog found, throw error if Encryption in data contract does not exist
                            if (package.Encryption == null)
                            {
                                throw new UnexpectedTestResultException("Database contains EncryptionKey when one should not be found for " + mo.MediaProductId.ToString());
                            }
                            // Else:  Encryption exists in the data contract and rows in GameContentInstanceEncryptedKey found
                        }
                        else
                        {
                            // Data in catalog found, throw error if Encryption in the data contract exists
                            if (package.Encryption != null)
                            {
                                throw new UnexpectedTestResultException("Database does not contains EncryptionKey when one should be found for " + mo.MediaProductId.ToString());
                            }
                        }
                    }
                }
            }

            Global.RO.Success("              Success! ");

            return;
            #endregion
        }



        public static void DoMediaOperations(MediaOperation[] mediaOperations, bool verboseOutput, uint expectedResult, bool isRetryable)
        {
            Exception e = null;

            if (mediaOperations == null)
                return;

            foreach (MediaOperation mo in mediaOperations)
            {
                //Save the Dates here
                DateTime[] checkDates = null;
                if (mo.CheckDate != null)
                {
                    checkDates = new DateTime[mo.CheckDate.Length];
                    for (int i = 0; i < mo.CheckDate.Length; i++)
                    {
                        using (SqlDataReader reader = Catalog.RunSqlQuery(Catalog.SqlQueryGetMediaModifiedDate(mo.CheckDate[i])))
                        {
                            if ((reader != null) && (reader.HasRows))
                            {
                                reader.Read();
                                checkDates[i] = reader.GetDateTime(0);
                                Global.RO.Info("MediaId = " + mo.MediaProductId.ToString() + " Original modifiedDate = " + checkDates[i].ToString());
                            }
                            else
                            {
                                // No value for new configures
                                checkDates[i] = DateTime.MinValue;
                            }
                        }
                    }
                }


                if (mo.Operation == OperationEnum.TestFindGameHelper)
                    throw new UnexpectedTestResultException("ContentXMLTestBase does not supports  such mediaoperation: " + mo.Operation);

                if (   mo.Operation == OperationEnum.Save 
                    || mo.Operation == OperationEnum.SaveOnly
                    || mo.Operation == OperationEnum.SaveImmediateVerify
                    || mo.Operation == OperationEnum.SaveNegative)
                {
                    if (verboseOutput)
                    {
                        Global.RO.Warn("Input media to Save Operation:");
                        XmlDocument doc = DataContractSerialize.ObjectToXml(mo.Media);
                        Global.RO.Info(FormatXml(doc.DocumentElement));

                        if (mo.CustomHttpHeaders != null)
                            foreach (CustomHttpHeader header in mo.CustomHttpHeaders)
                                Global.RO.Info("Customer header: Key: " + header.key + "    Value: " + header.value);

                    }

                    SaveSubscriptionFamilyPrivilegeSet(mo.Media);

                    //Save the object to data
                    Catalog.ConfigureProduct(out e, mo.Media, mo.CustomHttpHeaders);

                    if (e != null)
                    {
                        VerifyNegativeReturn(mo.Operation, e, expectedResult, isRetryable);
                        return;
                    }

                    if (mo.Operation == OperationEnum.SaveNegative)
                        throw new UnexpectedTestResultException("Expected call fail, but it success");

                    if (mo.Operation == OperationEnum.SaveImmediateVerify)
                    {
                        Global.RO.Warn("Do Immediate Verfication:");
                        DoVerification(mo, verboseOutput, expectedResult, false);
                    }

                    if (checkDates != null)
                    {
                        //Get Dates here and compare
                        if (mo.Operation == OperationEnum.Save || mo.Operation == OperationEnum.SaveImmediateVerify)
                        {
                            for (int i = 0; i < mo.CheckDate.Length; i++)
                            {

                                using (SqlDataReader reader = Catalog.RunSqlQuery(Catalog.SqlQueryGetMediaModifiedDate(mo.CheckDate[i])))
                                {
                                    if ((reader != null) && (reader.HasRows))
                                    {
                                        reader.Read();
                                        //checkDates[i] = reader.GetDateTime(0);
                                        if (checkDates[i] != reader.GetDateTime(0))
                                        {
                                            Global.RO.Info("MediaId = " + mo.MediaProductId.ToString() + " Updated modifiedDate = " + reader.GetDateTime(0).ToString());
                                        }
                                        else
                                        {
                                            throw new UnexpectedTestResultException("ModifiedDate for " + mo.MediaProductId.ToString() + " has not been updated as expected");
                                        }
                                    }
                                    else
                                    {
                                        throw new UnexpectedTestResultException("Could not get modifiedDate for " + mo.MediaProductId.ToString());
                                    }
                                }
                            }
                        }
                    }
                }
            }


            foreach (MediaOperation mo in mediaOperations)
            {
                if (mo.Operation == OperationEnum.Save || mo.Operation == OperationEnum.Get
                    || mo.Operation == OperationEnum.GetNegative)
                    DoVerification(mo, verboseOutput, expectedResult, isRetryable);
            }
        }


        private static void SaveSubscriptionFamilyPrivilegeSet(Object marketplaceMedia)
        {
            Guid subFamilyProductId = Guid.Empty;
            string subFamilyName = null;

            if (marketplaceMedia is ProductV1.LiveSubscriptionFamily)
            {
                subFamilyProductId = (marketplaceMedia as ProductV1.LiveSubscriptionFamily).ProductId;
                subFamilyName = (marketplaceMedia as ProductV1.LiveSubscriptionFamily).Name;
            }

            if(subFamilyProductId != Guid.Empty && subFamilyName != null)
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo subFamilyInfo = client.SubscriptionFamilyGet(subFamilyProductId);

                if (subFamilyInfo == null)
                {

                    int serviceType = 1;

                    int subscriptionType = 1;

                    int tierId = 6;

                    int servicePrivilegeSet = 101;

                    //create subscriptionfamily through mix
                    client.SubscriptionFamilyConfigure(subFamilyProductId, subFamilyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
                }
                System.Threading.Thread.Sleep(10000);

                SubscriptionFamilyInfo sfRet = client.SubscriptionFamilyGet(subFamilyProductId);

                if (sfRet == null)
                {
                    throw new UnexpectedTestResultException("Expected Subscription family to offer Instance mapping call to succeed.");
                }
            }
        }

        public static void RemoveMedia(MediaOperation[] mediaOperations)
        {
            if (mediaOperations == null)
            {
                return;
            }

            // Cleanup all products created in this test case
            Dictionary<Guid, int> addedProductIds = new Dictionary<Guid, int>();

            // Get all the unique product Ids created in this test case
            foreach (MediaOperation mo in mediaOperations)
            {
                if ((mo.Operation == OperationEnum.Save) || (mo.Operation == OperationEnum.SaveOnly) || (mo.Operation == OperationEnum.SaveImmediateVerify) || (mo.Operation == OperationEnum.SaveNegative))
                {
                    addedProductIds[mo.MediaProductId] = 1;
                }
            }

            Catalog catalog = new Catalog();
            foreach (Guid g in addedProductIds.Keys)
            {
                catalog.Remove(g);
            }
        }
    }

    [DataContract]
    [KnownType(typeof(MediaOperation))]
    [KnownType(typeof(TestCaseInfo))]
    public class ContentTestCaseInfo : TestCaseInfo
    {
        [DataMember]
        public MediaOperation[] MediaOperations;
        [DataMember]
        public bool VerboseOutput = false;
        public ContentTestCaseInfo()
        {

        }
        //create testcase using the testcase info, which will add the test to the test suite
        public override TestNode Create()
        {
            TestNode node = new ContentXMLTestBase(this);
            return node;
        }
    }


    public class ContentXMLTestBase : TestNode
    {

        protected MediaOperation[] mediaOperations;
        public uint ExpectedResult;
        public bool VerboseOutput;
        public bool isRetryable = false;

        public ContentXMLTestBase(ContentTestCaseInfo testInfo)
            : base(testInfo.Name)
        {
            mediaOperations = testInfo.MediaOperations;
            ExpectedResult = testInfo.ExpectedResult;
            Desc = testInfo.Description;
            FunctionalData = new FunctionalNodeData(this);
            TaggingData.AddTagValue("Priority", testInfo.Priority.ToString());
            if (testInfo.TestFrequency == null)
                TaggingData.AddTagValue("Frequency", "Regression");
            else
                TaggingData.AddTagValue("Frequency", testInfo.TestFrequency.ToString());

            TaggingData.AddTagValue("Requirement", "Catalog");
            TaggingData.AddTagValue("Owner", testInfo.Owner);
            VerboseOutput = testInfo.VerboseOutput;
            isRetryable = testInfo.IsRetryable;

            if (testInfo.KnownBug != 0)
            {
                FunctionalData.BugID = testInfo.KnownBug;
            }

#if DEBUG
            if (testInfo.RetailOnly)
            {
                Global.RO.Info("Ignoring '" + testInfo.Name + "' because it is RetailOnly and current binary is Debug");
                TaggingData.AddTag("RetailOnly");
                FunctionalData.Ignored = true;
            }
#endif
        }



        public override void Run()
        {
            MediaOperationsHelper.DoMediaOperations(mediaOperations, VerboseOutput, ExpectedResult, isRetryable);
        }

        public override void PreRun()
        {
            if (mediaOperations != null)
            {
                // Clear all media which are going to be used in this test case
                MediaOperationsHelper.RemoveMedia(mediaOperations);
            }
        }

        public override void PostRun()
        {
            if (mediaOperations != null)
            {
                // Clear all media after the test cases finish
                MediaOperationsHelper.RemoveMedia(mediaOperations);
            }
        }
    }



    [DataContract]
    [KnownType(typeof(MediaOperation))]
    [KnownType(typeof(TestCaseInfo))]
    public class ContentTestCasewithLocaleInfo : ContentTestCaseInfo
    {
        [DataMember]
        public string lcid;
        [DataMember]
        public string locale;

        public ContentTestCasewithLocaleInfo()
        {

        }
        //create testcase using the testcase info, which will add the test to the test suite
        public override TestNode Create()
        {
            return new ContentXMLWithLocaleTestBase(this);
        }
    }



    public class ContentXMLWithLocaleTestBase : ContentXMLTestBase
    {
        string locale;
        string lcid;

        public ContentXMLWithLocaleTestBase(ContentTestCasewithLocaleInfo testInfo)
            : base(testInfo)
        {
            this.locale = testInfo.locale;
            this.lcid = testInfo.lcid;

        }

        public override void Run()
        {
            foreach (MediaOperation mo in mediaOperations)
            {
                if (mo.Operation == OperationEnum.TestFindGameHelper)
                {
                    Global.RO.Info("Verify Media: " + mo.MediaProductId);

                    if (mo.Media is ProductV1.Game)
                    {
                        FindGameHelper helper = new FindGameHelper((ProductV1.Game)mo.Media, locale, lcid);

                        ProductV1.Game g = helper.GetGame();

                        if (g == null)
                            throw new UnexpectedTestResultException("FindGames return nothing for " + mo.MediaProductId);

                        if (!Catalog.Compare((ProductV1.Game)mo.Media, g))
                        {
                            throw new UnexpectedTestResultException("Verifiation failed for Id " + mo.MediaProductId);
                        }
                        Global.RO.Success("              Success! ");
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException("ContentXMLWithLocaleTestBase does not supports  such mediaoperation: " + mo.Operation);
                }
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Serializer.cs ===
ï»¿//-----------------------------------------------------------------------
// <copyright file="Serializer.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to build a serialize and deserialize an object to and from an xml document
// </summary>
//-----------------------------------------------------------------------
namespace  MIXTesting
{
    using System;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to handle Serializing and deserializes data contract objects
    /// </summary>
    public class DataContractSerialize
    {

        /// <summary>
        /// Serializes a datacontract object into a xml documents
        /// </summary>
        public static XmlDocument ObjectToXml(Object obj)
        {
            
            DataContractSerializer dcSerializer = new DataContractSerializer(obj.GetType());
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;
            xmlWriterSettings.Indent = true;

            //xmlWriterSettings.OmitXmlDeclaration = true;                 
            StringBuilder stringBuilder = new StringBuilder();


            using (XmlWriter xWriter = XmlWriter.Create(stringBuilder, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, obj);
                xWriter.Flush();

                XmlDocument xDoc = new XmlDocument();
                xDoc.LoadXml(stringBuilder.ToString());

                return xDoc;
            }
            
        }

        /// <summary>
        /// Deserialize the xml file to a specified object type
        /// </summary>
        /// <param name="fileName">The xml file representing the specified object type</param>
        /// <param name="type">The specified object type</param>
        /// <returns>The object represented by the xml document</returns>
        public static object DeserializeFromFile(string fileName, Type type)
        {
            try
            {
                // load and deserialize the xml document specified by the fileName
                using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    XmlDictionaryReader reader = XmlDictionaryReader.CreateTextReader(
                                                     fileStream, new XmlDictionaryReaderQuotas());
                    DataContractSerializer ser = new DataContractSerializer(type);
                    return ser.ReadObject(reader, true);
                }
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException e)
            {
                throw e;
                     
            }
            return null;
        }

        /// <summary>
        /// Deserialize from xmldocment to a specified object type
        /// </summary>
        /// <param name="xmlDoc">Xmldocument object which is from the serilization of a data contract </param>
        /// <param name="type">The specified object type</param>
        /// <returns>The object represented by the xml document</returns>    
        public static object DeserializeFromXmlDoc(XmlDocument xmlDoc, Type type)
        {
            try
            {                
                    XmlTextReader reader = new XmlTextReader(new StringReader(xmlDoc.OuterXml));
                   
                    DataContractSerializer ser = new DataContractSerializer(type);
                    return ser.ReadObject(reader, true);
                
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException)
            {
            }
            return null;
        }         
    }
    /// <summary>
    /// Serializes and deserializes objects into and from xml documents
    /// </summary>
    public static class Serializer
    {
                
        /// <summary>
        /// Deserialize the xml file to a specified object type
        /// </summary>
        /// <param name="fileName">The xml file representing the specified object type</param>
        /// <param name="type">The specified object type</param>
        /// <returns>The object represented by the xml document</returns>
        public static object DeserializeFromFile(string fileName, Type type)
        {
            try
            {
                // load and deserialize the xml document specified by the fileName
                using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    XmlSerializer xmlSerializer = new XmlSerializer(type);
                    return xmlSerializer.Deserialize(fileStream);
                }
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException)
            {
            }

            return null;
        }

        /// <summary>
        /// Serialize the specified object to an xml document
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <returns>The xml document representing the object</returns>
        public static XmlDocument Serialize(object obj)
        {
            XmlDocument xmlDocument = new XmlDocument();

            if (null == obj)
            {
                return xmlDocument;
            }

            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriter = new StringWriterUTF8(stringBuilder))
            {
                XmlSerializer xmlSerializer = new XmlSerializer(obj.GetType());
                xmlSerializer.Serialize(stringWriter, obj);
            }

            xmlDocument.PreserveWhitespace = true;
            xmlDocument.LoadXml(stringBuilder.ToString());

            return xmlDocument;
        }

        /// <summary>
        /// Serialize the specified object to an xml file
        /// </summary>
        /// <param name="obj">The specified object</param>
        /// <param name="fileName">The xml file representing the specified object type</param>
        public static void SerializeToFile(object obj, string fileName)
        {
            XmlDocument xmlDocument = Serializer.Serialize(obj);

            // save the xml document
            xmlDocument.Save(fileName);
        }

        /// <summary>
        /// Implements a StringWriter for writing an xml document to a UTF8 string
        /// </summary>
        internal class StringWriterUTF8 : StringWriter
        {
            /// <summary>
            /// encoding is the encoding in which the output is written
            /// </summary>
            private Encoding encoding = Encoding.UTF8;

            /// <summary>
            /// Initializes a new instance of the StringWriterUTF8 class
            /// </summary>
            /// <param name="stringBuilder">The StringBuilder to write to</param>
            public StringWriterUTF8(StringBuilder stringBuilder)
                : base(stringBuilder)
            {
            }

            /// <summary>
            /// Gets the encoding in which the output is written
            /// </summary>
            public override Encoding Encoding
            {
                get { return this.encoding; }
            }

            /// <summary>
            /// Releases the unmanaged resources used by the StringWriterUTF8 and optionally releases the managed resources
            /// </summary>
            /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\OfferTestGeneration.cs ===
ï»¿
namespace MIXTesting
{
    using OfferV1 = xonline.mix.offermanagement.contracts.V1;
    using System;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Runtime.Serialization;
    using ServerTestFramework;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Collections;

    public delegate void CustomizedOperationDelegate(OfferOperation[] offerOperations);

    [DataContract]
    [KnownType(typeof(OfferV1.Offer))]
    public class OfferOperation
    {
        [DataMember(Order = 1)]
        public OperationEnum Operation;
        [DataMember(Order = 3)]
        public Object ProcessedOffer;

        [XmlIgnore]
        public Guid ProcessedOfferOfferId
        {
            get
            {
                if (ProcessedOffer is OfferV1.Offer)
                    return (ProcessedOffer as OfferV1.Offer).OfferId;

                return Guid.Empty;
            }

            set
            {
                if (ProcessedOffer is OfferV1.Offer)
                {
                    (ProcessedOffer as OfferV1.Offer).OfferId = value;
                    return;
                }
            }
        }

        [XmlIgnore]
        public Guid ProcessedOfferProductId
        {
            get
            {
                if (ProcessedOffer is OfferV1.Offer)
                    return (ProcessedOffer as OfferV1.Offer).ProductId;

                return Guid.Empty;
            }

            set
            {
                if (ProcessedOffer is OfferV1.Offer)
                {
                    (ProcessedOffer as OfferV1.Offer).ProductId = value;
                    return;
                }
            }
        }

        [DataMember(Order = 2, IsRequired = false)]
        public CustomHttpHeader[] CustomHttpHeaders;
        [DataMember(Order = 4, IsRequired = false)]
        public Guid[] CheckDate;
        [DataMember(Order = 5, IsRequired = false)]
        public string Template = string.Empty;

    }


    [DataContract]
    [KnownType(typeof(TestCaseInfo))]
    [KnownType(typeof(ContentTestCaseInfo))]
    public class OfferTestCaseInfo : ContentTestCaseInfo
    {
        [DataMember (Order = 1)]
        public OfferOperation[] OfferOperations;

        [DataMember (Order = 2)]
        public string CustomizedOperation;

        public OfferTestCaseInfo()
        {    
        }   

        // Create testcase using the testcase info, which will add the test to the test suite
        public override TestNode Create()
        {
            TestNode node = new OfferXMLTestBase(this);  
            return node;
        }
    }

    public static class CustomizedOperationManager 
    {
        static private Hashtable customizedOperatons = null;
  

       public static CustomizedOperationDelegate GetOperation(string operationName) {
           
           if (customizedOperatons == null) return null;

           return (CustomizedOperationDelegate)customizedOperatons[operationName];
       }

       public static void AddOperation(String operationName, Object obj)
       {

            if (customizedOperatons == null)
            {
                customizedOperatons = new Hashtable();
            }

            if (customizedOperatons[operationName] == null)
            {
                customizedOperatons.Add(operationName, obj);
            }
        }
    }



    public class OfferXMLTestBase : ContentXMLTestBase
    {

        protected OfferOperation[] offerOperations;
        CustomizedOperationDelegate testPDelegate =  null;
        
        private OfferTestCaseInfo testInfo;

        public OfferXMLTestBase(OfferTestCaseInfo testInfo)
            : base((ContentTestCaseInfo)testInfo)
        {
            offerOperations = testInfo.OfferOperations;

            this.testInfo = testInfo;

        }

        // Array fields when sent in as null will return back as empty arrays
        // So adjust the expected value for that
        public static void FixNullArrays(object offer)
        {
            if (offer is OfferV1.Offer)
            {
                var offerV1 = offer as OfferV1.Offer;
                foreach (OfferV1.OfferInstance instance in offerV1.Instances)
                {
                    if (instance.OfferProducts == null)
                    {
                        instance.OfferProducts = new OfferV1.OfferProduct[0];
                    }

                    if (instance.Packages == null)
                    {
                        instance.Packages = new OfferV1.OfferPackage[0];
                    }

                }
                offerV1.OfferRelationShips = new OfferV1.OfferRelationShip[0];
            }
        }

        void DoVerification(OfferOperation offerOp)
        {
            string productIdOverride = Environment.GetEnvironmentVariable("PP_STF_PRODUCTID");
            if ((productIdOverride != null) && (productIdOverride != String.Empty))
            {
                Global.RO.Info("Overriding offer product ID with : " + productIdOverride);
                offerOp.ProcessedOfferProductId = new Guid(productIdOverride);
            }

            string offerIdOverride = Environment.GetEnvironmentVariable("PP_STF_OFFERID");
            if ((offerIdOverride != null) && (offerIdOverride != String.Empty))
            {
                Global.RO.Info("Overriding offer ID with : " + offerIdOverride);
                offerOp.ProcessedOfferOfferId = new Guid(offerIdOverride);
            }

            if (VerboseOutput)
            {
                /*Global.RO.Warn("Expected offer:");
                XmlDocument doc = DataContractSerialize.ObjectToXml(offerOp.ProcessedOffer);
                Global.RO.Info(MediaOperationsHelper.FormatXml(doc.DocumentElement));*/

                if (offerOp.CustomHttpHeaders != null)
                    foreach (CustomHttpHeader header in offerOp.CustomHttpHeaders)
                        Global.RO.Info("Customer header: Key: " + header.key + "    Value: " + header.value);

            }

            Exception e = null;
            var offerFromDb = Catalog.GetOffer(out e, offerOp.ProcessedOfferOfferId, offerOp.CustomHttpHeaders);

            //Assuming one test case only have one negative operation
            if (e != null)
            {
                MediaOperationsHelper.VerifyNegativeReturn(offerOp.Operation, e, ExpectedResult, isRetryable);
                //just return, no need to do further verification.
                return;
            }

            if (offerOp.Operation == OperationEnum.GetNegative)
                throw new UnexpectedTestResultException("Expected call fail, but it success");


            if (offerFromDb == null)
                throw new UnexpectedTestResultException("GetObject returned NULL for " + offerOp.ProcessedOfferOfferId);

            // Fix the expected offer to convert null arrays to empty arrays
            FixNullArrays(offerOp.ProcessedOffer);

            Global.RO.Info("Verify Offer: " + offerOp.ProcessedOfferOfferId);

            if (VerboseOutput)
            {
                Global.RO.Warn("Returned offer from server:");
                XmlDocument doc = DataContractSerialize.ObjectToXml(offerFromDb);
                Global.RO.Success(MediaOperationsHelper.FormatXml(doc.DocumentElement));
            }

            if (!Catalog.Compare(offerFromDb, offerOp.ProcessedOffer))
            {
                throw new UnexpectedTestResultException("Verifiation failed for Id " + offerOp.ProcessedOfferOfferId);
            }
            Global.RO.Success("              Success! ");
        }

        public override void Run()
        {
            Exception e = null;
            DateTime[] checkDates = null;

            base.Run();


            foreach (OfferOperation offerOp in offerOperations)
            {

                if (offerOp.Operation == OperationEnum.Save || offerOp.Operation == OperationEnum.SaveOnly
                      || offerOp.Operation == OperationEnum.SaveImmediateVerify
                      || offerOp.Operation == OperationEnum.SaveNegative)
                {
                    if (VerboseOutput)
                    {
                        Global.RO.Warn("Input Offer to Save Operation:");
                        XmlDocument doc = DataContractSerialize.ObjectToXml(offerOp.ProcessedOffer);
                        Global.RO.Info(MediaOperationsHelper.FormatXml(doc.DocumentElement));

                        if (offerOp.CustomHttpHeaders != null)
                            foreach (CustomHttpHeader header in offerOp.CustomHttpHeaders)
                                Global.RO.Info("Customer header: Key: " + header.key + "    Value: " + header.value);

                    }

                    //Save the Dates here
                    if (offerOp.CheckDate != null)
                    {
                        checkDates = new DateTime[offerOp.CheckDate.Length];
                        for (int i = 0; i < offerOp.CheckDate.Length; i++)
                        {
                            using (SqlDataReader reader = Catalog.RunSqlQuery(Catalog.SqlQueryGetMediaModifiedDate(offerOp.CheckDate[i])))
                            {
                                if ((reader != null) && (reader.HasRows))
                                {
                                    reader.Read();
                                    checkDates[i] = reader.GetDateTime(0);
                                    Global.RO.Info("MediaId = " + offerOp.CheckDate[i].ToString() + " Original modifiedDate = " + checkDates[i].ToString());
                                }
                                else
                                {
                                    // No value for new configures
                                    checkDates[i] = DateTime.MinValue;
                                }
                            }
                        }
                    }

                    Catalog.ConfigureOffer(out e, offerOp.ProcessedOffer, offerOp.CustomHttpHeaders);
                    if (e != null)
                    {
                        MediaOperationsHelper.VerifyNegativeReturn(offerOp.Operation, e, ExpectedResult, isRetryable);
                        continue;
                    }

                    if (offerOp.Operation == OperationEnum.SaveNegative)
                        throw new UnexpectedTestResultException("Expected call fail, but it success");

                    if (offerOp.Operation == OperationEnum.SaveImmediateVerify)
                    {
                        Global.RO.Warn("Do Immediate Verfication:");
                        DoVerification(offerOp);

                    }

                    //Get Dates here and compare
                    if (offerOp.Operation == OperationEnum.Save || offerOp.Operation == OperationEnum.SaveImmediateVerify)
                    {
                        if (checkDates != null)
                        {
                            for (int i = 0; i < offerOp.CheckDate.Length; i++)
                            {

                                using (SqlDataReader reader = Catalog.RunSqlQuery(Catalog.SqlQueryGetMediaModifiedDate(offerOp.CheckDate[i])))
                                {
                                    if ((reader != null) && (reader.HasRows))
                                    {
                                        reader.Read();
                                        if (checkDates[i] != reader.GetDateTime(0))
                                        {
                                            Global.RO.Info("MediaId = " + offerOp.CheckDate[i].ToString() + " Updated modifiedDate = " + reader.GetDateTime(0).ToString());
                                        }
                                        else
                                        {
                                            throw new UnexpectedTestResultException("ModifiedDate for " + offerOp.CheckDate[i].ToString() + " has not been updated as expected");
                                        }
                                    }
                                    else
                                    {
                                        throw new UnexpectedTestResultException("Could not get modifiedDate for " + offerOp.CheckDate[i].ToString());
                                    }
                                }
                            }
                        }
                    }
                }
            }


            foreach (OfferOperation offerOp in offerOperations)
            {
                if (offerOp.Operation == OperationEnum.Save || offerOp.Operation == OperationEnum.Get
                    || offerOp.Operation == OperationEnum.GetNegative)
                {
                    DoVerification(offerOp);
                }
            }

            if (testInfo.CustomizedOperation != null)
            {
                testPDelegate = CustomizedOperationManager.GetOperation(testInfo.CustomizedOperation);

                if (testPDelegate != null)
                    testPDelegate(offerOperations);
            }
        }

        public override void PreRun()
        {
            base.PreRun();

            if (this.offerOperations != null)
            {
                // Remove all the offers that is going to be used in this test
                RemoveOffers(this.offerOperations);
            }
        }

        public override void PostRun()
        {
            if (this.offerOperations != null)
            {
                // Remove all the offers create in the test
                RemoveOffers(this.offerOperations);
            }

            base.PostRun();
        }

        public static void RemoveOffers(OfferOperation[] offerOperations)
        {
            if (offerOperations == null)
            {
                return;
            }

            // Cleanup all products created in this test case
            Dictionary<Guid, int> addedOfferIds = new Dictionary<Guid, int>();

            // Get all the unique offer Ids created in this test case
            foreach (OfferOperation offer in offerOperations)
            {
                if ((offer.Operation == OperationEnum.Save) || (offer.Operation == OperationEnum.SaveOnly) || (offer.Operation == OperationEnum.SaveImmediateVerify) || (offer.Operation == OperationEnum.SaveNegative))
                {
                    addedOfferIds[offer.ProcessedOfferOfferId] = 1;
                }
            }

            Catalog catalog = new Catalog();
            foreach (Guid offerId in addedOfferIds.Keys)
            {
                catalog.RemoveOffer(offerId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\TitleManagementHelper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

using MixTest;
using MIXTesting;
using ServerTestFramework.Utilities;
using xonline.mix.titlemanagement.contracts.V3;
using MixTest.SettingsManagement;
using ServerTestFramework;

namespace MixTest.TitleManagement
{
    /// <summary>
    /// 
    /// </summary>
    public class TitleManagementHelperV3 : MixTestHelper<TitleManagementV3WCFClient>
    {
        public Guid BusinessPartnerId
        {
            get
            {
                if (SettingsHelper.BusinessPartner == null)
                {
                    // Generate a random one
                    SettingsHelper.SetBusinessPartner();

                    // And an applies to that we can use
                    SettingsHelper.SetAppliesToInfo();
                }
                return SettingsHelper.BusinessPartner.BusinessPartnerID;
            }
        }

        public UInt32[] TitleIds { get; set; }
        public Dictionary<UInt32, List<TitleEndpoint>> TitleEndpoints { get; set; }
        public MixSettingsHelperV3 SettingsHelper { get; set; }

        public TitleManagementHelperV3()
        {
            TitleEndpoints = new Dictionary<uint, List<TitleEndpoint>>();
            SettingsHelper = new MixSettingsHelperV3();
        }

        public void Initialize()
        {
            SetBusinessPartnerTitleIDs(1);
        }

        public void Initialize(Int32 titleIdCount)
        {
            SetBusinessPartnerTitleIDs(titleIdCount);
        }

        public void SetBusinessPartnerTitleIDs(Int32 titleIdCount)
        {
            TitleIds = GenerateTitleIds(titleIdCount);
            SetBusinessPartnerTitleIDs(BusinessPartnerId, TitleIds);
        }

        public void SetBusinessPartnerTitleIDs(UInt32[] titleIDs)
        {
            SetBusinessPartnerTitleIDs(BusinessPartnerId, titleIDs);
        }

        public void SetBusinessPartnerTitleIDs(Guid businessPartnerID, UInt32[] titleIDs)
        {
            Client.SetBusinessPartnerTitleIDs(businessPartnerID, titleIDs);
        }

        public UInt32[] GetBusinessPartnerTitleIDs()
        {
            return Client.GetBusinessPartnerTitleIDs(BusinessPartnerId);
        }

        public void SetNetworkSecurityList(IEnumerable<TitleEndpoint> endpoints)
        {
            SetNetworkSecurityList(TitleIds[0], endpoints);
        }

        public void SetNetworkSecurityList(UInt32 titleId, IEnumerable<TitleEndpoint> endpoints)
        {
            Client.SetNetworkSecurityList(titleId, endpoints.ToArray());
        }

        public TitleEndpointInfo[] GetNetworkSecurityList()
        {
            return Client.GetNetworkSecurityList(TitleIds[0], false);
        }

        public TitleEndpointInfo[] GetNetworkSecurityList(UInt32 titleId)
        {
            return Client.GetNetworkSecurityList(titleId, false);
        }

        public TitleEndpointInfo[] GetNetworkSecurityList(UInt32 titleId, Boolean fullHistory)
        {
            return Client.GetNetworkSecurityList(titleId, fullHistory);
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(String appliesTo)
        {
            return Client.GetNetworkSecurityListByAppliesTo(appliesTo, false);
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByEndpoint(String endpoint)
        {
            return Client.GetNetworkSecurityListByEndpointAddress(endpoint, false);
        }

        public List<TitleEndpoint> GenerateNetworkSecurityList()
        {
            return GenerateNetworkSecurityList(TitleIds[0], 10);
        }

        public List<TitleEndpoint> GenerateNetworkSecurityList(Int32 endpointCount)
        {
            return GenerateNetworkSecurityList(TitleIds[0], endpointCount);
        }

        public List<TitleEndpoint> GenerateNetworkSecurityList(UInt32 titleId, Int32 endpointCount)
        {
            String appliesToUri = SettingsHelper.AppliesTos[0].AppliesToUri;

            List<TitleEndpoint> endpoints = new List<TitleEndpoint>();
            for (int i = 0; i < endpointCount; i++)
            {
                endpoints.Add(GenerateEndpoint());
            }

            TitleEndpoints[titleId] = endpoints;

            //if (loadList)
            {
                SetNetworkSecurityList(titleId, endpoints);
            }

            return endpoints;
        }

        /// <summary>
        /// Generate a random valid endpoint
        /// </summary>
        /// <returns></returns>
        public TitleEndpoint GenerateEndpoint()
        {
            String appliesToUri = SettingsHelper.AppliesTos[0].AppliesToUri;

            return GenerateEndpoint(
                String.Format("http://www.xbox.com/test/{0}", Guid.NewGuid()), 
                appliesToUri);
        }

        public TitleEndpoint GenerateEndpoint(String uri, String appliesTo)
        {
            return GenerateEndpoint(new Uri(uri), appliesTo);
        }

        public TitleEndpoint GenerateEndpoint(Uri uri, String appliesTo)
        {
            return GenerateEndpoint(uri.Scheme, uri.Host, uri.Port, uri.AbsolutePath, appliesTo);
        }

        public TitleEndpoint GenerateEndpoint(String protocol, String server, Int32 port, String path, String appliesTo)
        {
            return new TitleEndpoint
            {
                Protocol = protocol,
                Hostname = server,
                FromIP = 0,
                ToIP = 0,
                Port = port,
                Path = path,
                AppliesToUri = appliesTo,
            };
        }

        public TitleEndpoint GenerateEndpoint(String protocol, UInt32 fromIp, UInt32 toIp, Int32 port, String path, String appliesTo)
        {
            return new TitleEndpoint
            {
                Protocol = protocol,
                Hostname = null,
                FromIP = fromIp,
                ToIP = toIp,
                Port = port,
                Path = path,
                AppliesToUri = appliesTo,
            };
        }

        public UInt32[] GenerateTitleIds(Int32 titleIdCount)
        {
            UInt32[] titleIds = new UInt32[titleIdCount];
            for (int i = 0; i < titleIdCount; i++)
            {
                titleIds[i] = (UInt32)RandomEx.GlobalRandGen.Next(Int32.MinValue, Int32.MaxValue);
            }

            return titleIds;
        }

        public void VerifyTitleIds(IEnumerable<UInt32> titleIds)
        {
            ValueCheck.TestAllUnordered("TitleIDs", TitleIds, titleIds,
                (a, b) => a == b,
                titleId => "0x" + titleId.ToString("X8"));
        }

        public void VerifyEndpoints(IEnumerable<TitleEndpointInfo> endpoints)
        {
            VerifyEndpoints(TitleIds[0], endpoints.Select(e => e.EndpointInfo));
        }

        public void VerifyEndpoints(UInt32 titleId, IEnumerable<TitleEndpointInfo> endpoints)
        {
            VerifyEndpoints(this.TitleEndpoints[titleId], endpoints.Select(e => e.EndpointInfo));
        }

        public void VerifyEndpoints(IEnumerable<TitleEndpoint> endpoints)
        {
            VerifyEndpoints(this.TitleEndpoints[this.TitleIds[0]], endpoints);
        }

        public void VerifyEndpoints(UInt32 titleId, IEnumerable<TitleEndpoint> endpoints)
        {
            VerifyEndpoints(this.TitleEndpoints[titleId], endpoints);
        }
        
        public void VerifyEndpoints(IEnumerable<TitleEndpoint> expectedEndpoints, IEnumerable<TitleEndpoint> endpoints)
        {
            ValueCheck.TestAllUnordered("Endpoints", expectedEndpoints, endpoints,
                (a, b) => a.Protocol == b.Protocol &&
                          a.Hostname == b.Hostname &&
                          a.FromIP == b.FromIP &&
                          a.ToIP == b.ToIP &&
                          a.Port == b.Port &&
                          a.Path == b.Path &&
                          a.AppliesToUri == b.AppliesToUri,
                endpoint => String.Format("{0}://{1}:{2}{3}", endpoint.Protocol, GetServerString(endpoint), endpoint.Port, endpoint.Path));
        }

        public override void Cleanup()
        {
            // Set an empty network security list for each title
            if (TitleIds != null)
            {
                foreach (var titleId in TitleIds)
                {
                    List<TitleEndpoint> endpoints;
                    if (TitleEndpoints.TryGetValue(titleId, out endpoints) && endpoints.Count > 0)
                    {
                        try
                        {
                            SetNetworkSecurityList(titleId, new TitleEndpoint[0]);
                        }
                        catch (Exception e)
                        {
                            Global.RO.Warn("There was a problem cleaning up the NACL for 0x{0:X8}.\n{1}", titleId, e.ToString());
                        }
                    }
                }
            }

            try
            {
                // Then clear out the business partner title id mapping
                SetBusinessPartnerTitleIDs(BusinessPartnerId, new UInt32[0]);
            }
            catch (Exception e)
            {
                Global.RO.Warn("There was a problem cleaning up the BusinessPartnerTitleIDs for {0}.\n{1}", BusinessPartnerId, e.ToString());
            }

            SettingsHelper.Cleanup();
        }

        public static String GetServerString(TitleEndpoint endpoint)
        {
            String server = null;

            if (!String.IsNullOrEmpty(endpoint.Hostname))
            {
                server = endpoint.Hostname;
            }
            else
            {
                IPAddress from = new IPAddress(endpoint.FromIP);
                IPAddress to = new IPAddress(endpoint.ToIP);

                if (from == to)
                {
                    server = from.ToString();
                }
                else
                {
                    server = from + "-" + to;
                }
            }

            return server;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\XmlTestCaseGeneration.cs ===
ï»¿
namespace MIXTesting
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using System.Xml.Serialization;
    using ServerTestFramework;
    using ServerTestFramework.Utilities;
    using xonline.mix.productmanagement.contracts.V1;

    /// <summary>
    /// Class to get the path info of testcase xml files
    /// </summary>
    public class ConfigureDataProvider : DataProvider
    {
        string configFilePath;
        public ConfigureDataProvider(string configFilePath)
            : base(configFilePath)
        {
            this.configFilePath = configFilePath;
        }

        public  class Keys
        {
            public static readonly string TestCaseFileNames = "TestCaseFileNames";
            public static readonly string TestCaseFolder = "TestCaseFolder";
        }


        public string[] GetTestCasePaths()
        {
            string[] fileNames = GetSingleValue(Keys.TestCaseFileNames).Split(';');
            string[] filePaths = new string[fileNames.Length];

            int i = 0;
            foreach (string fileName in fileNames)
            {
                filePaths[i++] = GetSingleValue(Keys.TestCaseFolder) + "\\" + fileName.Trim();
            }
            return filePaths;
        }

    }
    // Base Group class for all tests. Contains extra logic to create and remove group level test media data
    public class ContentTestBaseGroup : TestNode
    {
        private MediaOperation[] mediaOperations = null;

        public ContentTestBaseGroup(string name, MediaOperation[] GroupMediaOperations, 
                                    IEnumerable<TestNode> children, bool addFunctionalData, bool addStressData)
            : base(name, children, addFunctionalData, addStressData)
        {
            mediaOperations = GroupMediaOperations;
        }

        public override void PreRun()
        {
            if (mediaOperations != null)
            {
                // Remove all the game media that is going to be used in this test
                MediaOperationsHelper.RemoveMedia(mediaOperations);

                // Setup the Media requird for this group
                MediaOperationsHelper.DoMediaOperations(mediaOperations, true,0, false);
            }
        }

        public override void PostRun()
        {
            if (mediaOperations != null)
            {
                // Remove all the game media that is going to be used in this test
                MediaOperationsHelper.RemoveMedia(mediaOperations);
            }
            
        }
    }

    /// <summary>
    /// Class to generate stf test case
    /// </summary>
    [DataContract]
    [KnownType(typeof(OfferTestCaseInfo))]
    [KnownType(typeof(ContentTestCaseInfo))]
    [KnownType(typeof(TestCaseInfo))]
    public class TestCaseInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [DataMember (Order = 3)]
        public string Name = "";
        [DataMember (Order = 4)]
        public int Priority = 3;
        [DataMember (Order = 1)]
        public string Description = "";
        [DataMember(Order = 2)]
        public uint ExpectedResult = 0;
        [DataMember(Order = 5, IsRequired = false)]
        public bool  IsRetryable = false;
        [DataMember(Order = 6, IsRequired = false)]
        public string TestFrequency = "Regression";
        [DataMember(Order = 7, IsRequired = false)]
        public bool RetailOnly = false;
        [DataMember (Order=8)]
        public string Owner = "";
        [DataMember(Order = 9, IsRequired = false)]
        public int KnownBug = 0;
        [DataMember(Order = 15)]
        public string EnvRequirement = "Catalog";

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        public TestCaseInfo()
        {
        }

        public virtual TestNode Create() 
        {
            TestNode node =  new TestNode(Name);          
            return node;
        }

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
    }



    /// <summary>
    /// Class to generate stf test group
    /// </summary>
    [DataContract]
    [KnownType(typeof(ContentTestCaseInfo))]
    [KnownType(typeof(TestCaseInfo))]
    public class TestGroupInfo
    {
        [DataMember(Order = 0)]
        public string GroupName = "";

        [DataMember(IsRequired = false, Order = 1)]
        public MediaOperation[] GroupMediaOperations;

        [DataMember(Order = 2)]
        public TestCaseInfo[] TestCases;

        public TestNode Create(List<TestNode> tests)
        {
            return new ContentTestBaseGroup(GroupName, GroupMediaOperations, tests, true, false);
        }
    }


    /// <summary>
    /// Class to generate stf tests from a xml input file
    /// </summary>
    [DataContract]    
    [KnownType(typeof(ContentTestCaseInfo))]
    [KnownType(typeof(ContentTestCasewithLocaleInfo))]
    [KnownType(typeof(TestCaseInfo))]
    [KnownType(typeof(TestGroupInfo))]
    [KnownType(typeof(MediaBase))]
    [KnownType(typeof(Game))]
    [KnownType(typeof(LocalizedData))]
    public class TestData
    {
        [DataMember]
        public TestGroupInfo[] TestGroups;

        /// <summary>
        /// Each individual test suite call this function to generate stf tests.
        /// "testcaseFilePath" is the path of test case xml file
        /// "groupList" is where the generated test cases are going to be added. 
        /// </summary>
        public static void CreateTests(string testcaseFilePath, System.Collections.Generic.List<TestNode> groupList)
        {
            Template.ProcessFileToApplyTemplate(testcaseFilePath);
            TestData testData = (TestData)DataContractSerialize.DeserializeFromFile(testcaseFilePath, typeof(TestData));
            Template.RevertProcessedFile(testcaseFilePath);


            if (testData == null) {
                throw new Exception("Failed to  deserialize test data object from " + testcaseFilePath);
            }

            //generate test case from test data and initialze the test data          
            foreach (TestGroupInfo grpInfo in testData.TestGroups)
            {
                List<TestNode> tests = new List<TestNode>();
                foreach (TestCaseInfo testcaseInfo in grpInfo.TestCases)
                {
                    //Added productmanagement testcase
                    if (testcaseInfo is ContentTestCasewithLocaleInfo)
                    {
                        tests.Add(testcaseInfo.Create());
                    }
                    //Added productmanagement testcase
                    else if (testcaseInfo is ContentTestCaseInfo)
                    {
                        tests.Add(testcaseInfo.Create());
                    }
                    //OfferTestCaseInfo
                    else if (testcaseInfo is OfferTestCaseInfo)
                    {
                        tests.Add(testcaseInfo.Create());
                    }
                }

                // Create Test Group
                foreach (TestNode grp in groupList)
                    if (grp.Name.Equals(grpInfo.GroupName))
                    {
                       Global.RO.Error("Tests in group \"" + grpInfo.GroupName + "\" are not in same xml file.");
                       Global.RO.Error("Please either put the tests in same file or remove the duplcate group name");
                       throw new Exception();
                    }

                TestNode newGrp = grpInfo.Create(tests);
                groupList.Add(newGrp);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\SettingsManagementHelper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;


using MIXTesting;
using ServerTestFramework.Utilities;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.config;

namespace MixTest.SettingsManagement
{
    using xonline.mix.settingsmanagement.contracts.V3;
    public class FullBusinessPartnerV3
    {
        public class BusinessPartnerKey
        {
            public int KeyVersion { get; set; }
            public int MasterKeyVersion { get; set; }
            public byte[] EncryptedKey { get; set; }
            public byte[] EncryptedIv { get; set; }
        }

        public Guid BusinessPartnerID { get; set; }
        public string FriendlyName { get; set; }
        public string AnonymizingSalt { get; set; }
        public BusinessPartnerConnectionInfo[] ConnectionInfos { get; set; }
        public BusinessPartnerKey[] Keys { get; set; }

        /// <summary>
        /// Load business partner data from the database.
        /// </summary>
        public FullBusinessPartnerV3 (Guid businessPartnerID)
        {
            using (var wsClient = MixSettingsHelperV3.GetSecDBClient())
            {
                // t_sts_business_partner
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner where uid_business_partner_id = @bp";
                wsClient.AddParameter("bp", businessPartnerID);
                var reader = wsClient.Execute();

                if (!reader.Read())
                {
                    // could not find the given partner id
                    throw new ArgumentException("Business partner not found: " + businessPartnerID, "businessPartnerID");
                }

                BusinessPartnerID = reader.GetValue<Guid>("uid_business_partner_id");
                FriendlyName = reader.GetString("vc_friendly_name");
                AnonymizingSalt = reader.GetString("vc_anonymizing_salt");

                reader.Close();

                // t_sts_business_partner_connection_info
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner_connection_info where uid_business_partner_id = @bp";
                reader = wsClient.Execute();

                List<BusinessPartnerConnectionInfo> connInfos = new List<BusinessPartnerConnectionInfo>();

                while (reader.Read())
                {
                    connInfos.Add(new BusinessPartnerConnectionInfo()
                    {
                        FriendlyName = reader.GetString("vc_friendly_name"),
                        BusinessPartnerSGCertificate = reader.GetString("vc_partner_sg_cert"),
                    });
                }

                ConnectionInfos = connInfos.ToArray();

                reader.Close();

                // t_sts_business_partner_keys
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner_keys where uid_business_partner_id = @bp";
                reader = wsClient.Execute();

                List<BusinessPartnerKey> keys = new List<BusinessPartnerKey>();

                while (reader.Read())
                {
                    keys.Add(new BusinessPartnerKey()
                    {
                        KeyVersion = reader.GetValue<int>("i_key_version"),
                        MasterKeyVersion = reader.GetValue<int>("i_master_key_version"),
                        EncryptedKey = reader.GetBytes("vb_encrypted_key"),
                        EncryptedIv = reader.GetBytes("vb_encrypted_iv"),
                    });
                }

                Keys = keys.ToArray();

                reader.Close();
            }
        }
    }

    public class MixSettingsHelperV3 : MixTestHelper<SettingsManagementV3WCFClient>
    {
        public const string OtherCert = "MIIFpjCCA46gAwIBAgIKGJ5pPAAAAAAAgDANBgkqhkiG9w0BAQUFADA2MTQwMgYDVQQDEytNaWNyb3NvZnQgR2VudWluZSBXaW5kb3dzIFBob25lIFRlc3RpbmcgQ0ExMB4XDTEwMDQxOTE3MzYwMFoXDTExMDQxOTE3NDYwMFowRTFDMEEGA1UEAxM6dXJuOndwLWFjLWhhc2g6YmNIZFFtS2RQd0FtWmsxdW14QUdab1ZpWFkybXdQOC1COXZmRUVhOWwyYzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALSLBq2cBWbfKgcaGIeG3z/Jn8wv/6/KMsMbGCvCcJFM6m9HFmtzZoF2dS6PmQSjKZUxxkDtCd6a/KPPkLWZ0RaYtkvQWh6Faei8V2xUy94y5QMv4tJPYqwTk/ioyAKSrUxkvVScJCJClW3gkHrUpTBEXpQsic9elefLvQUhSNLDJ+LKDOib2+CpJyxf08qd/Y9f0hPNMnAxRmwXbPm97QbJ+EdhsQnC0IOOKR5212MCPNbFFvIl1L/mYF6ycZ7ZOudq1/OvgZ5h9zJvdUpcMqfqjWTfTJyJKPriK46SYLxmecjxXSmF42wntoPqDR/brNKFYudfvHLZfa5uUP1hG48CAwEAAaOCAaUwggGhMA4GA1UdDwEB/wQEAwIE8DAfBgNVHSUEGDAWBggrBgEFBQcDAgYKKwYBBAGCN0cBATAdBgNVHQ4EFgQU67+Qxkzd/k5jAlK6fNGQGiPCalkwHwYDVR0jBBgwFoAUAzV583hXeUKZv9bZjxSQYiazm3kwegYDVR0fBHMwcTBvoG2ga4ZpZmlsZTovL2ZzdHVncmVuLXZtMi5yZWRtb25kLmNvcnAubWljcm9zb2Z0LmNvbS9DZXJ0RW5yb2xsL01pY3Jvc29mdCBHZW51aW5lIFdpbmRvd3MgUGhvbmUgVGVzdGluZyBDQTEuY3JsMIGxBggrBgEFBQcBAQSBpDCBoTCBngYIKwYBBQUHMAKGgZFmaWxlOi8vZnN0dWdyZW4tdm0yLnJlZG1vbmQuY29ycC5taWNyb3NvZnQuY29tL0NlcnRFbnJvbGwvZnN0dWdyZW4tdm0yLnJlZG1vbmQuY29ycC5taWNyb3NvZnQuY29tX01pY3Jvc29mdCBHZW51aW5lIFdpbmRvd3MgUGhvbmUgVGVzdGluZyBDQTEuY3J0MA0GCSqGSIb3DQEBBQUAA4ICAQATi1BCEcPUUbMpo6S1xzzP/O33fNjEhNdmh2tyVXBvhlG8ndcn2cG4DKKZlX6Accz++84NAlhuJCyDczCSyh5XuP5c/XUf4AhgMwx+CkMqQMJQHD6DXoeLS2Vom21CMzHPyzsjiikUJawyA+BPnAfTYn+ZauvZKTn7xZeiYQIUKXSxDaC+xRnpgkPMy8x3gl/Ww8QQ1yc7R88b+ukC9KLm8K3I8OW9jAKfR2F7SCTgwXf9iV+I9rg5AdjSAzu6wbLMESCDSHRLJy63wccphCAJAWI7rmKVUlW9THO7LQwGB8mo5hqN4JrH0Ow63kHlg7i1etfhxCnMfbQDY+eIBptI1UVYMdl38EPv7CWL6LtMJ8fwjUuUIGLVRsvnxcMM9nSgV884A256xUJvP9nj2VSe9k0QgptGsp1zq3XQOko9HMWeYEWTF7ON7GZ9MstblwYsEzOTFEHctlDmvKUIDVfcdnr9CPD8AiVCjj6Uu6MbNRTJdNlgLQchn7tgVdtSab+o2igEKOSpDuU2nOEwDnIBImgq8BBKEGOAxdYI4fwyQPsth9nkj5LaO76agBhHfbX5YCf6OjQmd4/t5Q8wbqECyA7Umw8ZoC93B5nubkKGmUWqXaBpBBnQa/kK1oTIE/NF9M9Wi4Nn6AH40d8Su0TdMBkJaQIBAdjd6ew2nEZjGw==";

        public static Dictionary<String, Dictionary<string, STSClaimTypeInfo>> ClaimTypes { get; protected set; }
        public static List<string> BusinessPartnerTypes { get; protected set; }
        public static List<String> TokenTypes { get; protected set; }

        public BusinessPartner BusinessPartner { get; set; }
        //public Dictionary<String, STSAppliesTo> AppliesTos { get; set; }
        public List<STSAppliesTo> AppliesTos { get; set; }

        public MixSettingsHelperV3()
        {
            //AppliesTos = new Dictionary<String, STSAppliesTo>();
            AppliesTos = new List<STSAppliesTo>();
        }

        public void SetBusinessPartner()
        {
            // Create a new one, and save it for later
            BusinessPartner = GenerateBusinessPartner();

            // Add it to the database
            SetBusinessPartner(BusinessPartner);
        }

        public void SetBusinessPartner(BusinessPartner bp)
        {
            Client.SetBusinessPartner(bp);
        }

        public void SetAppliesToInfo()
        {
            STSAppliesTo appliesTo = GenerateAppliesTo();
            //AppliesTos.Add(appliesTo.AppliesToUri, appliesTo);
            AppliesTos.Add(appliesTo);

            SetAppliesToInfo(appliesTo);
        }

        public void SetAppliesToInfo(STSAppliesTo appliesTo)
        {
            Client.SetAppliesToInfo(appliesTo);
        }

        public STSAppliesTo GetAppliesToInfo(String appliesToUri)
        {
            return Client.GetAppliesToInfo(appliesToUri);
        }

        public void RemoveAppliesToInfo(String appliesToUri)
        {
            Client.RemoveAppliesToInfo(appliesToUri);

            if (AppliesTos.Count(a => a.AppliesToUri == appliesToUri) > 0)
            {
                STSAppliesTo appliesToRemove = AppliesTos.First(a => a.AppliesToUri == appliesToUri);
                AppliesTos.Remove(appliesToRemove);
            }
        }

        public BusinessPartner GenerateBusinessPartner()
        {
            return GenerateBusinessPartner(1);
        }

        public BusinessPartner GenerateBusinessPartner(Int32 connectionInfoCount)
        {         
            Guid bpid = Guid.NewGuid();

            BusinessPartnerConnectionInfo[] connectionInfos = new BusinessPartnerConnectionInfo[connectionInfoCount];
            for (int i = 0; i < connectionInfoCount; i++)
            {
                connectionInfos[i] = GenerateBusinessPartnerConnectionInfo(bpid, i != 0 ? i.ToString() : "");
            }

            return new BusinessPartner
            {
                BusinessPartnerID = bpid,
                FriendlyName = "MixSettingsTestBusinessPartner_" + bpid,
                ConnectionInfos = connectionInfos,
            };
        }

        public BusinessPartnerConnectionInfo GenerateBusinessPartnerConnectionInfo(Guid businessPartnerId)
        {
            return GenerateBusinessPartnerConnectionInfo(businessPartnerId, null);
        }

        public BusinessPartnerConnectionInfo GenerateBusinessPartnerConnectionInfo(Guid businessPartnerId, String suffix)
        {
            String friendlyName = "MixSettingsTestBusinessPartnerConnectionInfo_" + businessPartnerId;
            if (!String.IsNullOrEmpty(suffix))
            {
                friendlyName += "_" + suffix;
            }

            return new BusinessPartnerConnectionInfo
            {
                FriendlyName = friendlyName,
                BusinessPartnerSGCertificate = "MIIF6TCCBNGgAwIBAgIKI5IpWAAFAAELsjANBgkqhkiG9w0BAQUFADCBizETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEUMBIGCgmSJomT8ixkARkWBGNvcnAxFzAVBgoJkiaJk/IsZAEZFgdyZWRtb25kMSowKAYDVQQDEyFNaWNyb3NvZnQgU2VjdXJlIFNlcnZlciBBdXRob3JpdHkwHhcNMDkwMzAyMjAyMzQ3WhcNMTAwMzAyMjAyMzQ3WjBrMQswCQYDVQQGEwJVUzELMAkGA1UECBMCV0ExEDAOBgNVBAcTB1JlZG1vbmQxEjAQBgNVBAoTCU1pY3Jvc29mdDESMBAGA1UECxMJWGJveCBMaXZlMRUwEwYDVQQDEwx3d3cueGJveC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAI/XKJl0Q73EDc7t0GLR+9KhZDbVo3liZVXqSPsCGHRf/v0DYbc9kOI6ZDQvPJ0ykqZl23ww43kyw2ANuVol2p7EB+GlxlqgnzU6UEt7kwU2Jx+Niq/FQ/WFzpACQ7X//1ecek7G7aFDEFO8FCjikMciaOVDMqzod6nbg4vaqVhLAgMBAAGjggLwMIIC7DALBgNVHQ8EBAMCBLAwRAYJKoZIhvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMHMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAdBgNVHQ4EFgQUDFktSehtvdyvr3edmeAxvdV4RcMwHwYDVR0jBBgwFoAUFFXEOeA9LtFVLkiWsNh+FCIGk7wwggEKBgNVHR8EggEBMIH+MIH7oIH4oIH1hlhodHRwOi8vbXNjcmwubWljcm9zb2Z0LmNvbS9wa2kvbXNjb3JwL2NybC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3JshlZodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9jcmwvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNybIZBaHR0cDovL2NvcnBwa2kvY3JsL01pY3Jvc29mdCUyMFNlY3VyZSUyMFNlcnZlciUyMEF1dGhvcml0eSg1KS5jcmwwgb8GCCsGAQUFBwEBBIGyMIGvMF4GCCsGAQUFBzAChlJodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3J0ME0GCCsGAQUFBzAChkFodHRwOi8vY29ycHBraS9haWEvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNydDA/BgkrBgEEAYI3FQcEMjAwBigrBgEEAYI3FQiDz4lNrfIChaGfDIL6yn2B4ft0gU+Dwu2FCI6p0oVjAgFkAgEGMCcGCSsGAQQBgjcVCgQaMBgwCgYIKwYBBQUHAwIwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEFBQADggEBADI74KksprLMaSXuRyx0Zh7+bzpTj6qR6Uq/9TyowVI5QaJFTusncHzoYgPzTRj9hQx6ur2gs+bfIxdH9v9sreulBfEcrSag54Q19V0qeiHesMShwyO+L8KHFI/AHpo++JDOKOBnScjGmX5uO6XdwA5+rcSBwM+5WLMORyA2WFbLo/cCScegeWtaJNTe5SNIjUyd6kEUoe/D7er55PRRTjhcvg/gTPUPsh+/pE6AmP/hZXYAAmHItG+IDKDdw6T45uXR+b+dMePV1IS0vZ9RzHhgZYk85I9NkDo3ClH65S1guaO5m83YGKi4ziqTYtVWNQ8YtVf32z/agCCMCy4B0MA=",
            };
        }

        public STSAppliesTo GenerateAppliesTo()
        {
            // Get a random claim set
            Int32 claimCount = RandomEx.GlobalRandGen.Next(1, ClaimTypes.Count);
            return GenerateAppliesTo(claimCount);
        }

        public STSAppliesTo GenerateAppliesTo (int claimTypeCount)
        {            
            var claimTypes = ClaimTypes["Partner"].Values.OrderBy(c => Guid.NewGuid())
                                              .Take(claimTypeCount)
                                              .Select(c => new STSAppliesToClaimType
                                              {
                                                  ClaimTypeUri = c.ClaimTypeUri,
                                                  Required = RandomEx.GlobalRandGen.NextBool(),
                                              });

            return new STSAppliesTo
            {
                BusinessPartnerID = BusinessPartner.BusinessPartnerID,
                AppliesToUri = String.Format("http://www.xbox.com/BP_{0}/{1}/", BusinessPartner.BusinessPartnerID, Guid.NewGuid()),
                ClaimTypes = claimTypes.ToArray(),
                ValidityInterval = TimeSpan.FromHours(4),
                TokenType = TokenTypes[RandomEx.GlobalRandGen.Next(TokenTypes.Count)],
                AppliesToCertificate = "MIIF6TCCBNGgAwIBAgIKI5IpWAAFAAELsjANBgkqhkiG9w0BAQUFADCBizETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEUMBIGCgmSJomT8ixkARkWBGNvcnAxFzAVBgoJkiaJk/IsZAEZFgdyZWRtb25kMSowKAYDVQQDEyFNaWNyb3NvZnQgU2VjdXJlIFNlcnZlciBBdXRob3JpdHkwHhcNMDkwMzAyMjAyMzQ3WhcNMTAwMzAyMjAyMzQ3WjBrMQswCQYDVQQGEwJVUzELMAkGA1UECBMCV0ExEDAOBgNVBAcTB1JlZG1vbmQxEjAQBgNVBAoTCU1pY3Jvc29mdDESMBAGA1UECxMJWGJveCBMaXZlMRUwEwYDVQQDEwx3d3cueGJveC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAI/XKJl0Q73EDc7t0GLR+9KhZDbVo3liZVXqSPsCGHRf/v0DYbc9kOI6ZDQvPJ0ykqZl23ww43kyw2ANuVol2p7EB+GlxlqgnzU6UEt7kwU2Jx+Niq/FQ/WFzpACQ7X//1ecek7G7aFDEFO8FCjikMciaOVDMqzod6nbg4vaqVhLAgMBAAGjggLwMIIC7DALBgNVHQ8EBAMCBLAwRAYJKoZIhvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMHMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAdBgNVHQ4EFgQUDFktSehtvdyvr3edmeAxvdV4RcMwHwYDVR0jBBgwFoAUFFXEOeA9LtFVLkiWsNh+FCIGk7wwggEKBgNVHR8EggEBMIH+MIH7oIH4oIH1hlhodHRwOi8vbXNjcmwubWljcm9zb2Z0LmNvbS9wa2kvbXNjb3JwL2NybC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3JshlZodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9jcmwvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNybIZBaHR0cDovL2NvcnBwa2kvY3JsL01pY3Jvc29mdCUyMFNlY3VyZSUyMFNlcnZlciUyMEF1dGhvcml0eSg1KS5jcmwwgb8GCCsGAQUFBwEBBIGyMIGvMF4GCCsGAQUFBzAChlJodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3J0ME0GCCsGAQUFBzAChkFodHRwOi8vY29ycHBraS9haWEvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNydDA/BgkrBgEEAYI3FQcEMjAwBigrBgEEAYI3FQiDz4lNrfIChaGfDIL6yn2B4ft0gU+Dwu2FCI6p0oVjAgFkAgEGMCcGCSsGAQQBgjcVCgQaMBgwCgYIKwYBBQUHAwIwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEFBQADggEBADI74KksprLMaSXuRyx0Zh7+bzpTj6qR6Uq/9TyowVI5QaJFTusncHzoYgPzTRj9hQx6ur2gs+bfIxdH9v9sreulBfEcrSag54Q19V0qeiHesMShwyO+L8KHFI/AHpo++JDOKOBnScjGmX5uO6XdwA5+rcSBwM+5WLMORyA2WFbLo/cCScegeWtaJNTe5SNIjUyd6kEUoe/D7er55PRRTjhcvg/gTPUPsh+/pE6AmP/hZXYAAmHItG+IDKDdw6T45uXR+b+dMePV1IS0vZ9RzHhgZYk85I9NkDo3ClH65S1guaO5m83YGKi4ziqTYtVWNQ8YtVf32z/agCCMCy4B0MA=",
            };
        }

        public static void CleanTestData()
        {
            using (var secDb = GetSecDBClient())
            {
                //Clean up claim mappings
                secDb.CommandSql = @"delete from t_sts_applies_to_claim where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //Title endpoints    
                secDb.CommandSql = @"delete from t_sts_title_endpoint where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //With the above dependencies gone, obliterate the appTos                
                secDb.CommandSql = @"delete from t_sts_applies_to where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //Now we can move on to business partner dependencies - connection infos                
                secDb.CommandSql = @"delete from t_sts_business_partner_connection_info where vc_friendly_name like 'MixSettingsTestBusinessPartnerConnectionInfo_%'";
                secDb.ExecuteNonQuery();

                //And titleids                
                secDb.CommandSql = @"delete from t_sts_business_partner_title where uid_business_partner_id in (select uid_business_partner_id from t_sts_business_partner where vc_friendly_name like 'MixSettingsTestBusinessPartner_%')";
                secDb.ExecuteNonQuery();

                //And finally, nuke the BP.                
                secDb.CommandSql = @"delete from t_sts_business_partner where vc_friendly_name like 'MixSettingsTestBusinessPartner_%'";
                secDb.ExecuteNonQuery();
            }
        }
        
        public override void Cleanup()
        {
            MixSettingsHelperV3.CleanTestData();            
        }

        internal static WSClient GetSecDBClient()
        {
            return new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
        }

        public static void Initialize()
        {
            BusinessPartnerTypes = new List<string>();
            ClaimTypes = new Dictionary<String, Dictionary<string, STSClaimTypeInfo>>();            
            TokenTypes = new List<String>();

            LoadClaimTypes();
            LoadTokenTypes();
        }

        /// <summary>
        /// Load all the available claim types from the database
        /// </summary>
        public static void LoadClaimTypes()
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;

                // Ignore any of the test claims since they may be leftover.
                wsClient.CommandSql = "select vc_friendly_name from t_sts_business_partner_type";                
                var reader = wsClient.Execute();

                while (reader.Read())
                {
                    string type = reader.GetString("vc_friendly_name");
                    BusinessPartnerTypes.Add(type);
                    ClaimTypes.Add(type, new Dictionary<string, STSClaimTypeInfo>());
                }

                reader.Close();

                foreach (string s in BusinessPartnerTypes)
                {
                    wsClient.StoredProc = null;
                    wsClient.CommandSql = "select * from t_sts_business_partner_type_claim_type, t_sts_business_partner_type, t_sts_claim"
                        + " where t_sts_business_partner_type_claim_type.i_business_partner_type = t_sts_business_partner_type.i_business_partner_type"
                        + " and t_sts_business_partner_type_claim_type.vc_claim_uri = t_sts_claim.vc_claim_uri"
                        + " and vc_friendly_name = '" + s + "'";

                    reader = wsClient.Execute();

                    while (reader.Read())
                    {
                        STSClaimTypeInfo claim = new STSClaimTypeInfo
                        {
                            ClaimTypeUri = reader.GetString("vc_claim_uri"),
                            Title = reader.GetString("vc_friendly_title"),
                            Description = reader.GetString("vc_friendly_description"),
                            Encrypted = reader.GetValue<bool>("b_encrypted"),
                            ValueType = reader.GetString("vc_value_type"),
                        };

                        ClaimTypes[s].Add(claim.ClaimTypeUri, claim);
                    }

                    reader.Close();
                }
            }
        }

        /// <summary>
        /// Load all the available token types from the database
        /// </summary>
        public static void LoadTokenTypes()
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select vc_token_type_uri from t_sts_token_type";

                var reader = wsClient.Execute();

                while (reader.Read())
                {
                    TokenTypes.Add(reader.GetString("vc_token_type_uri"));
                }
            }
        }

        public static STSAppliesToClaimType[] FirstPartnerClaimTypes (int count)
        {
            return ClaimTypes["Partner"].Keys.Take(count).Select(c => new STSAppliesToClaimType
            {
                ClaimTypeUri = c,
                Required = RandomEx.GlobalRandGen.NextBool(),
            }).ToArray();
        }

        public static STSAppliesToClaimType[] FirstPrivateClaimTypes (int count)
        {
            return ClaimTypes["Private"].Keys.Take(count).Select(c => new STSAppliesToClaimType
            {
                ClaimTypeUri = c,
                Required = RandomEx.GlobalRandGen.NextBool(),
            }).ToArray();
        }

        public static Boolean ClaimTypeEquals(STSClaimTypeInfo claim, STSClaimTypeInfo otherClaim)
        {
            return claim.ClaimTypeUri == otherClaim.ClaimTypeUri &&
                   claim.Title == otherClaim.Title &&
                   claim.Description == otherClaim.Description &&
                   claim.Encrypted == otherClaim.Encrypted &&
                   claim.ValueType == otherClaim.ValueType;
        }

        public static Boolean AppliesToClaimTypeEquals (STSAppliesToClaimType claim, STSAppliesToClaimType otherClaim)
        {
            return claim.ClaimTypeUri == otherClaim.ClaimTypeUri &&
                   claim.Required == otherClaim.Required;
        }

        public static Boolean AppliesToEquals(STSAppliesTo appliesTo, STSAppliesTo otherAppliesTo)
        {
            return appliesTo.AppliesToUri == otherAppliesTo.AppliesToUri &&
                   appliesTo.BusinessPartnerID == otherAppliesTo.BusinessPartnerID && 
                   appliesTo.TokenType == otherAppliesTo.TokenType &&
                   appliesTo.ValidityInterval == otherAppliesTo.ValidityInterval &&
                   appliesTo.AppliesToCertificate == otherAppliesTo.AppliesToCertificate;

            // Do Claim Types
        }
    }    

    public static class WstDataReaderExtensions
    {
        public static T GetValue<T>(this WstDataReader reader, String columnName)
        {
            Int32 ordinal = reader.GetOrdinal(columnName);
            return (T)reader.GetValue(ordinal);
        }

        public static String GetString(this WstDataReader reader, String columnName)
        {
            Int32 ordinal = reader.GetOrdinal(columnName);
            return reader.GetString(ordinal);
        }

        public static byte[] GetBytes (this WstDataReader reader, String columnName)
        {
            Int32 ordinal = reader.GetOrdinal(columnName);
            return reader.GetSqlBinary(ordinal).Value;
        }
    }
}

namespace MixTest.SettingsManagement
{
    using xonline.mix.settingsmanagement.contracts.V4;
    public class FullBusinessPartnerV4
    {
        public class BusinessPartnerKey
        {
            public int KeyVersion { get; set; }
            public int MasterKeyVersion { get; set; }
            public byte[] EncryptedKey { get; set; }
            public byte[] EncryptedIv { get; set; }
        }

        public Guid BusinessPartnerID { get; set; }
        public string FriendlyName { get; set; }
        public string AnonymizingSalt { get; set; }
        //public int BPTypeId { get; set; }
        public string Type { get; set; }
        public BusinessPartnerConnectionInfo[] ConnectionInfos { get; set; }
        public BusinessPartnerKey[] Keys { get; set; }

        /// <summary>
        /// Load business partner data from the database.
        /// </summary>
        public FullBusinessPartnerV4(Guid businessPartnerID)
        {
            using (var wsClient = MixSettingsHelperV4.GetSecDBClient())
            {
                // t_sts_business_partner
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner where uid_business_partner_id = @bp";
                wsClient.AddParameter("bp", businessPartnerID);
                var reader = wsClient.Execute();

                if (!reader.Read())
                {
                    // could not find the given partner id
                    throw new ArgumentException("Business partner not found: " + businessPartnerID, "businessPartnerID");
                }

                BusinessPartnerID = reader.GetValue<Guid>("uid_business_partner_id");
                FriendlyName = reader.GetString("vc_friendly_name");
                AnonymizingSalt = reader.GetString("vc_anonymizing_salt");
                int typeId = reader.GetValue<int>("i_business_partner_type");
                Type = FullBusinessPartnerV4.GetBusinessPartnerTypeFriendlyName(typeId);
                reader.Close();

                // t_sts_business_partner_connection_info
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner_connection_info where uid_business_partner_id = @bp";
                reader = wsClient.Execute();

                List<BusinessPartnerConnectionInfo> connInfos = new List<BusinessPartnerConnectionInfo>();

                while (reader.Read())
                {
                    connInfos.Add(new BusinessPartnerConnectionInfo()
                    {
                        FriendlyName = reader.GetString("vc_friendly_name"),
                        BusinessPartnerSGCertificate = reader.GetString("vc_partner_sg_cert"),
                    });
                }

                ConnectionInfos = connInfos.ToArray();

                reader.Close();

                // t_sts_business_partner_keys
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner_keys where uid_business_partner_id = @bp";
                reader = wsClient.Execute();

                List<BusinessPartnerKey> keys = new List<BusinessPartnerKey>();

                while (reader.Read())
                {
                    keys.Add(new BusinessPartnerKey()
                    {
                        KeyVersion = reader.GetValue<int>("i_key_version"),
                        MasterKeyVersion = reader.GetValue<int>("i_master_key_version"),
                        EncryptedKey = reader.GetBytes("vb_encrypted_key"),
                        EncryptedIv = reader.GetBytes("vb_encrypted_iv"),
                    });
                }

                Keys = keys.ToArray();

                reader.Close();
            }
        }

        public static string GetBusinessPartnerTypeFriendlyName(int typeid)
        {             
            using (var wsClient = MixSettingsHelperV4.GetSecDBClient())
            {
                // t_sts_business_partner
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select * from t_sts_business_partner_type where i_business_partner_type = " + typeid;
                
                var reader = wsClient.Execute();

                if (!reader.Read())
                {
                    // could not find the given partner id
                    throw new ArgumentException("Business partner type not found: " + typeid, "businessPartner type ID");
                }

                return reader.GetString("vc_friendly_name");
            }
        }

    }

    public class MixSettingsHelperV4 : MixTestHelper<SettingsManagementV4WCFClient>
    {
        public const string OtherCert = "MIIFpjCCA46gAwIBAgIKGJ5pPAAAAAAAgDANBgkqhkiG9w0BAQUFADA2MTQwMgYDVQQDEytNaWNyb3NvZnQgR2VudWluZSBXaW5kb3dzIFBob25lIFRlc3RpbmcgQ0ExMB4XDTEwMDQxOTE3MzYwMFoXDTExMDQxOTE3NDYwMFowRTFDMEEGA1UEAxM6dXJuOndwLWFjLWhhc2g6YmNIZFFtS2RQd0FtWmsxdW14QUdab1ZpWFkybXdQOC1COXZmRUVhOWwyYzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALSLBq2cBWbfKgcaGIeG3z/Jn8wv/6/KMsMbGCvCcJFM6m9HFmtzZoF2dS6PmQSjKZUxxkDtCd6a/KPPkLWZ0RaYtkvQWh6Faei8V2xUy94y5QMv4tJPYqwTk/ioyAKSrUxkvVScJCJClW3gkHrUpTBEXpQsic9elefLvQUhSNLDJ+LKDOib2+CpJyxf08qd/Y9f0hPNMnAxRmwXbPm97QbJ+EdhsQnC0IOOKR5212MCPNbFFvIl1L/mYF6ycZ7ZOudq1/OvgZ5h9zJvdUpcMqfqjWTfTJyJKPriK46SYLxmecjxXSmF42wntoPqDR/brNKFYudfvHLZfa5uUP1hG48CAwEAAaOCAaUwggGhMA4GA1UdDwEB/wQEAwIE8DAfBgNVHSUEGDAWBggrBgEFBQcDAgYKKwYBBAGCN0cBATAdBgNVHQ4EFgQU67+Qxkzd/k5jAlK6fNGQGiPCalkwHwYDVR0jBBgwFoAUAzV583hXeUKZv9bZjxSQYiazm3kwegYDVR0fBHMwcTBvoG2ga4ZpZmlsZTovL2ZzdHVncmVuLXZtMi5yZWRtb25kLmNvcnAubWljcm9zb2Z0LmNvbS9DZXJ0RW5yb2xsL01pY3Jvc29mdCBHZW51aW5lIFdpbmRvd3MgUGhvbmUgVGVzdGluZyBDQTEuY3JsMIGxBggrBgEFBQcBAQSBpDCBoTCBngYIKwYBBQUHMAKGgZFmaWxlOi8vZnN0dWdyZW4tdm0yLnJlZG1vbmQuY29ycC5taWNyb3NvZnQuY29tL0NlcnRFbnJvbGwvZnN0dWdyZW4tdm0yLnJlZG1vbmQuY29ycC5taWNyb3NvZnQuY29tX01pY3Jvc29mdCBHZW51aW5lIFdpbmRvd3MgUGhvbmUgVGVzdGluZyBDQTEuY3J0MA0GCSqGSIb3DQEBBQUAA4ICAQATi1BCEcPUUbMpo6S1xzzP/O33fNjEhNdmh2tyVXBvhlG8ndcn2cG4DKKZlX6Accz++84NAlhuJCyDczCSyh5XuP5c/XUf4AhgMwx+CkMqQMJQHD6DXoeLS2Vom21CMzHPyzsjiikUJawyA+BPnAfTYn+ZauvZKTn7xZeiYQIUKXSxDaC+xRnpgkPMy8x3gl/Ww8QQ1yc7R88b+ukC9KLm8K3I8OW9jAKfR2F7SCTgwXf9iV+I9rg5AdjSAzu6wbLMESCDSHRLJy63wccphCAJAWI7rmKVUlW9THO7LQwGB8mo5hqN4JrH0Ow63kHlg7i1etfhxCnMfbQDY+eIBptI1UVYMdl38EPv7CWL6LtMJ8fwjUuUIGLVRsvnxcMM9nSgV884A256xUJvP9nj2VSe9k0QgptGsp1zq3XQOko9HMWeYEWTF7ON7GZ9MstblwYsEzOTFEHctlDmvKUIDVfcdnr9CPD8AiVCjj6Uu6MbNRTJdNlgLQchn7tgVdtSab+o2igEKOSpDuU2nOEwDnIBImgq8BBKEGOAxdYI4fwyQPsth9nkj5LaO76agBhHfbX5YCf6OjQmd4/t5Q8wbqECyA7Umw8ZoC93B5nubkKGmUWqXaBpBBnQa/kK1oTIE/NF9M9Wi4Nn6AH40d8Su0TdMBkJaQIBAdjd6ew2nEZjGw==";

        public static Dictionary<String, Dictionary<string, STSClaimTypeInfo>> ClaimTypes { get; protected set; }
        public static List<string> BusinessPartnerTypes { get; protected set; }
        public static List<String> TokenTypes { get; protected set; }

        public BusinessPartner BusinessPartner { get; set; }
        //public Dictionary<String, STSAppliesTo> AppliesTos { get; set; }
        public List<STSAppliesTo> AppliesTos { get; set; }        

        public MixSettingsHelperV4()
        {
            //AppliesTos = new Dictionary<String, STSAppliesTo>();
            AppliesTos = new List<STSAppliesTo>();
            BusinessPartnerTypes = new List<String>();
        }        

        public void SetBusinessPartner()
        {
            // Create a new one, and save it for later
            BusinessPartner = GenerateBusinessPartner();

            // Add it to the database
            SetBusinessPartner(BusinessPartner);
        }

        public void SetBusinessPartner(BusinessPartner bp)
        {
            Client.SetBusinessPartner(bp);
        }

        public void SetAppliesToInfo()
        {
            STSAppliesTo appliesTo = GenerateAppliesTo();
            //AppliesTos.Add(appliesTo.AppliesToUri, appliesTo);
            AppliesTos.Add(appliesTo);

            SetAppliesToInfo(appliesTo);
        }

        public void SetAppliesToInfo(STSAppliesTo appliesTo)
        {
            Client.SetAppliesToInfo(appliesTo);
        }

        public STSAppliesTo GetAppliesToInfo(String appliesToUri)
        {
            return Client.GetAppliesToInfo(appliesToUri);            
        }

        public string[] GetBusinessPartnerTypes()
        {
            return Client.GetBusinessPartnerTypes();
        }

        public void RemoveAppliesToInfo(String appliesToUri)
        {
            Client.RemoveAppliesToInfo(appliesToUri);

            if (AppliesTos.Count(a => a.AppliesToUri == appliesToUri) > 0)
            {
                STSAppliesTo appliesToRemove = AppliesTos.First(a => a.AppliesToUri == appliesToUri);
                AppliesTos.Remove(appliesToRemove);
            }
        }

        public BusinessPartner GenerateBusinessPartner()
        {
            return GenerateBusinessPartner(1);
        }

        public BusinessPartner GenerateBusinessPartner(Int32 connectionInfoCount)
        {
            Guid bpid = Guid.NewGuid();

            BusinessPartnerConnectionInfo[] connectionInfos = new BusinessPartnerConnectionInfo[connectionInfoCount];
            for (int i = 0; i < connectionInfoCount; i++)
            {
                connectionInfos[i] = GenerateBusinessPartnerConnectionInfo(bpid, i != 0 ? i.ToString() : "");
            }

            return new BusinessPartner
            {
                BusinessPartnerID = bpid,
                Type = "Partner",
                FriendlyName = "MixSettingsTestBusinessPartner_" + bpid,
                ConnectionInfos = connectionInfos,
            };
        }

        public BusinessPartnerConnectionInfo GenerateBusinessPartnerConnectionInfo(Guid businessPartnerId)
        {
            return GenerateBusinessPartnerConnectionInfo(businessPartnerId, null);
        }

        public BusinessPartnerConnectionInfo GenerateBusinessPartnerConnectionInfo(Guid businessPartnerId, String suffix)
        {
            String friendlyName = "MixSettingsTestBusinessPartnerConnectionInfo_" + businessPartnerId;
            if (!String.IsNullOrEmpty(suffix))
            {
                friendlyName += "_" + suffix;
            }

            return new BusinessPartnerConnectionInfo
            {
                FriendlyName = friendlyName,
                BusinessPartnerSGCertificate = "MIIF6TCCBNGgAwIBAgIKI5IpWAAFAAELsjANBgkqhkiG9w0BAQUFADCBizETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEUMBIGCgmSJomT8ixkARkWBGNvcnAxFzAVBgoJkiaJk/IsZAEZFgdyZWRtb25kMSowKAYDVQQDEyFNaWNyb3NvZnQgU2VjdXJlIFNlcnZlciBBdXRob3JpdHkwHhcNMDkwMzAyMjAyMzQ3WhcNMTAwMzAyMjAyMzQ3WjBrMQswCQYDVQQGEwJVUzELMAkGA1UECBMCV0ExEDAOBgNVBAcTB1JlZG1vbmQxEjAQBgNVBAoTCU1pY3Jvc29mdDESMBAGA1UECxMJWGJveCBMaXZlMRUwEwYDVQQDEwx3d3cueGJveC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAI/XKJl0Q73EDc7t0GLR+9KhZDbVo3liZVXqSPsCGHRf/v0DYbc9kOI6ZDQvPJ0ykqZl23ww43kyw2ANuVol2p7EB+GlxlqgnzU6UEt7kwU2Jx+Niq/FQ/WFzpACQ7X//1ecek7G7aFDEFO8FCjikMciaOVDMqzod6nbg4vaqVhLAgMBAAGjggLwMIIC7DALBgNVHQ8EBAMCBLAwRAYJKoZIhvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMHMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAdBgNVHQ4EFgQUDFktSehtvdyvr3edmeAxvdV4RcMwHwYDVR0jBBgwFoAUFFXEOeA9LtFVLkiWsNh+FCIGk7wwggEKBgNVHR8EggEBMIH+MIH7oIH4oIH1hlhodHRwOi8vbXNjcmwubWljcm9zb2Z0LmNvbS9wa2kvbXNjb3JwL2NybC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3JshlZodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9jcmwvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNybIZBaHR0cDovL2NvcnBwa2kvY3JsL01pY3Jvc29mdCUyMFNlY3VyZSUyMFNlcnZlciUyMEF1dGhvcml0eSg1KS5jcmwwgb8GCCsGAQUFBwEBBIGyMIGvMF4GCCsGAQUFBzAChlJodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3J0ME0GCCsGAQUFBzAChkFodHRwOi8vY29ycHBraS9haWEvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNydDA/BgkrBgEEAYI3FQcEMjAwBigrBgEEAYI3FQiDz4lNrfIChaGfDIL6yn2B4ft0gU+Dwu2FCI6p0oVjAgFkAgEGMCcGCSsGAQQBgjcVCgQaMBgwCgYIKwYBBQUHAwIwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEFBQADggEBADI74KksprLMaSXuRyx0Zh7+bzpTj6qR6Uq/9TyowVI5QaJFTusncHzoYgPzTRj9hQx6ur2gs+bfIxdH9v9sreulBfEcrSag54Q19V0qeiHesMShwyO+L8KHFI/AHpo++JDOKOBnScjGmX5uO6XdwA5+rcSBwM+5WLMORyA2WFbLo/cCScegeWtaJNTe5SNIjUyd6kEUoe/D7er55PRRTjhcvg/gTPUPsh+/pE6AmP/hZXYAAmHItG+IDKDdw6T45uXR+b+dMePV1IS0vZ9RzHhgZYk85I9NkDo3ClH65S1guaO5m83YGKi4ziqTYtVWNQ8YtVf32z/agCCMCy4B0MA=",
            };
        }

        public STSAppliesTo GenerateAppliesTo()
        {
            // Get a random claim set
            Int32 claimCount = RandomEx.GlobalRandGen.Next(1, ClaimTypes.Count);
            return GenerateAppliesTo(claimCount);
        }

        public STSAppliesTo GenerateAppliesTo(int claimTypeCount)
        {
            var claimTypes = ClaimTypes["Partner"].Values.OrderBy(c => Guid.NewGuid())
                                              .Take(claimTypeCount)
                                              .Select(c => new STSAppliesToClaimType
                                              {
                                                  ClaimTypeUri = c.ClaimTypeUri,
                                                  Required = RandomEx.GlobalRandGen.NextBool(),
                                              });

            return new STSAppliesTo
            {
                BusinessPartnerID = BusinessPartner.BusinessPartnerID,
                AppliesToUri = String.Format("http://www.xbox.com/BP_{0}/{1}/", BusinessPartner.BusinessPartnerID, Guid.NewGuid()),
                ClaimTypes = claimTypes.ToArray(),
                ValidityInterval = TimeSpan.FromHours(4),
                TokenType = TokenTypes[RandomEx.GlobalRandGen.Next(TokenTypes.Count)],
                AppliesToCertificate = "MIIF6TCCBNGgAwIBAgIKI5IpWAAFAAELsjANBgkqhkiG9w0BAQUFADCBizETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEUMBIGCgmSJomT8ixkARkWBGNvcnAxFzAVBgoJkiaJk/IsZAEZFgdyZWRtb25kMSowKAYDVQQDEyFNaWNyb3NvZnQgU2VjdXJlIFNlcnZlciBBdXRob3JpdHkwHhcNMDkwMzAyMjAyMzQ3WhcNMTAwMzAyMjAyMzQ3WjBrMQswCQYDVQQGEwJVUzELMAkGA1UECBMCV0ExEDAOBgNVBAcTB1JlZG1vbmQxEjAQBgNVBAoTCU1pY3Jvc29mdDESMBAGA1UECxMJWGJveCBMaXZlMRUwEwYDVQQDEwx3d3cueGJveC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAI/XKJl0Q73EDc7t0GLR+9KhZDbVo3liZVXqSPsCGHRf/v0DYbc9kOI6ZDQvPJ0ykqZl23ww43kyw2ANuVol2p7EB+GlxlqgnzU6UEt7kwU2Jx+Niq/FQ/WFzpACQ7X//1ecek7G7aFDEFO8FCjikMciaOVDMqzod6nbg4vaqVhLAgMBAAGjggLwMIIC7DALBgNVHQ8EBAMCBLAwRAYJKoZIhvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMHMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAdBgNVHQ4EFgQUDFktSehtvdyvr3edmeAxvdV4RcMwHwYDVR0jBBgwFoAUFFXEOeA9LtFVLkiWsNh+FCIGk7wwggEKBgNVHR8EggEBMIH+MIH7oIH4oIH1hlhodHRwOi8vbXNjcmwubWljcm9zb2Z0LmNvbS9wa2kvbXNjb3JwL2NybC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3JshlZodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9jcmwvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNybIZBaHR0cDovL2NvcnBwa2kvY3JsL01pY3Jvc29mdCUyMFNlY3VyZSUyMFNlcnZlciUyMEF1dGhvcml0eSg1KS5jcmwwgb8GCCsGAQUFBwEBBIGyMIGvMF4GCCsGAQUFBzAChlJodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3J0ME0GCCsGAQUFBzAChkFodHRwOi8vY29ycHBraS9haWEvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNydDA/BgkrBgEEAYI3FQcEMjAwBigrBgEEAYI3FQiDz4lNrfIChaGfDIL6yn2B4ft0gU+Dwu2FCI6p0oVjAgFkAgEGMCcGCSsGAQQBgjcVCgQaMBgwCgYIKwYBBQUHAwIwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEFBQADggEBADI74KksprLMaSXuRyx0Zh7+bzpTj6qR6Uq/9TyowVI5QaJFTusncHzoYgPzTRj9hQx6ur2gs+bfIxdH9v9sreulBfEcrSag54Q19V0qeiHesMShwyO+L8KHFI/AHpo++JDOKOBnScjGmX5uO6XdwA5+rcSBwM+5WLMORyA2WFbLo/cCScegeWtaJNTe5SNIjUyd6kEUoe/D7er55PRRTjhcvg/gTPUPsh+/pE6AmP/hZXYAAmHItG+IDKDdw6T45uXR+b+dMePV1IS0vZ9RzHhgZYk85I9NkDo3ClH65S1guaO5m83YGKi4ziqTYtVWNQ8YtVf32z/agCCMCy4B0MA=",
            };
        }

        public static void CleanTestData()
        {
            using (var secDb = GetSecDBClient())
            {
                //Clean up claim mappings
                secDb.CommandSql = @"delete from t_sts_applies_to_claim where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //Title endpoints    
                secDb.CommandSql = @"delete from t_sts_title_endpoint where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //With the above dependencies gone, obliterate the appTos                
                secDb.CommandSql = @"delete from t_sts_applies_to where vc_applies_to_uri like 'http://www.xbox.com/BP_%'";
                secDb.ExecuteNonQuery();

                //Now we can move on to business partner dependencies - connection infos                
                secDb.CommandSql = @"delete from t_sts_business_partner_connection_info where vc_friendly_name like 'MixSettingsTestBusinessPartnerConnectionInfo_%'";
                secDb.ExecuteNonQuery();

                //And titleids                
                secDb.CommandSql = @"delete from t_sts_business_partner_title where uid_business_partner_id in (select uid_business_partner_id from t_sts_business_partner where vc_friendly_name like 'MixSettingsTestBusinessPartner_%')";
                secDb.ExecuteNonQuery();

                //And finally, nuke the BP.                
                secDb.CommandSql = @"delete from t_sts_business_partner where vc_friendly_name like 'MixSettingsTestBusinessPartner_%'";
                secDb.ExecuteNonQuery();
            }
        }

        public override void Cleanup()
        {
            MixSettingsHelperV4.CleanTestData();
        }

        internal static WSClient GetSecDBClient()
        {
            return new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
        }

        public static void Initialize()
        {
            ClaimTypes = new Dictionary<string, Dictionary<string, STSClaimTypeInfo>>();
            BusinessPartnerTypes = new List<string>();            
            TokenTypes = new List<String>();

            LoadClaimTypes();
            LoadTokenTypes();
        }

        /// <summary>
        /// Load all the available claim types from the database
        /// </summary>
        public static void LoadClaimTypes()
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select vc_friendly_name from t_sts_business_partner_type";
                var reader = wsClient.Execute();

                while (reader.Read())
                {
                    string type = reader.GetString("vc_friendly_name");
                    BusinessPartnerTypes.Add(type);
                    ClaimTypes.Add(type, new Dictionary<string, STSClaimTypeInfo>());
                }

                reader.Close();

                foreach (string s in BusinessPartnerTypes)
                {
                    wsClient.StoredProc = null;
                    wsClient.CommandSql = "select * from t_sts_business_partner_type_claim_type, t_sts_business_partner_type, t_sts_claim"
                        + " where t_sts_business_partner_type_claim_type.i_business_partner_type = t_sts_business_partner_type.i_business_partner_type"
                        + " and t_sts_business_partner_type_claim_type.vc_claim_uri = t_sts_claim.vc_claim_uri"
                        + " and vc_friendly_name = '" + s + "'";

                    reader = wsClient.Execute();

                    while (reader.Read())
                    {
                        STSClaimTypeInfo claim = new STSClaimTypeInfo
                        {
                            ClaimTypeUri = reader.GetString("vc_claim_uri"),
                            Title = reader.GetString("vc_friendly_title"),
                            Description = reader.GetString("vc_friendly_description"),
                            Encrypted = reader.GetValue<bool>("b_encrypted"),
                            ValueType = reader.GetString("vc_value_type"),
                        };

                        ClaimTypes[s].Add(claim.ClaimTypeUri, claim);
                    }

                    reader.Close();
                }
            }
        }

        /// <summary>
        /// Load all the available token types from the database
        /// </summary>
        public static void LoadTokenTypes()
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = "select vc_token_type_uri from t_sts_token_type";

                var reader = wsClient.Execute();

                while (reader.Read())
                {
                    TokenTypes.Add(reader.GetString("vc_token_type_uri"));
                }
            }
        }

        public static STSAppliesToClaimType[] FirstPartnerClaimTypes(int count)
        {
            return ClaimTypes["Partner"].Keys.Take(count).Select(c => new STSAppliesToClaimType
            {
                ClaimTypeUri = c,
                Required = RandomEx.GlobalRandGen.NextBool(),
            }).ToArray();
        }

        public static STSAppliesToClaimType[] FirstPrivateClaimTypes(int count)
        {
            return ClaimTypes["Private"].Keys.Take(count).Select(c => new STSAppliesToClaimType
            {
                ClaimTypeUri = c,
                Required = RandomEx.GlobalRandGen.NextBool(),
            }).ToArray();
        }

        public static Boolean ClaimTypeEquals(STSClaimTypeInfo claim, STSClaimTypeInfo otherClaim)
        {
            return claim.ClaimTypeUri == otherClaim.ClaimTypeUri &&
                   claim.Title == otherClaim.Title &&
                   claim.Description == otherClaim.Description &&
                   claim.Encrypted == otherClaim.Encrypted &&
                   claim.ValueType == otherClaim.ValueType;
        }

        public static Boolean AppliesToClaimTypeEquals(STSAppliesToClaimType claim, STSAppliesToClaimType otherClaim)
        {
            return claim.ClaimTypeUri == otherClaim.ClaimTypeUri &&
                   claim.Required == otherClaim.Required;
        }

        public static Boolean AppliesToEquals(STSAppliesTo appliesTo, STSAppliesTo otherAppliesTo)
        {
            return appliesTo.AppliesToUri == otherAppliesTo.AppliesToUri &&
                   appliesTo.BusinessPartnerID == otherAppliesTo.BusinessPartnerID &&
                   appliesTo.TokenType == otherAppliesTo.TokenType &&
                   appliesTo.ValidityInterval == otherAppliesTo.ValidityInterval &&
                   appliesTo.AppliesToCertificate == otherAppliesTo.AppliesToCertificate;

            // Do Claim Types
        }

        public static STSAppliesTo ConvertAppToV3toV4(xonline.mix.settingsmanagement.contracts.V3.STSAppliesTo appTo)
        {
            STSAppliesTo newAppTo = new STSAppliesTo();
            newAppTo.AppliesToCertificate = appTo.AppliesToCertificate;
            newAppTo.AppliesToUri = appTo.AppliesToUri;
            newAppTo.BusinessPartnerID = appTo.BusinessPartnerID;
            
            List<STSAppliesToClaimType> claimTypes = new List<STSAppliesToClaimType>();
            foreach (xonline.mix.settingsmanagement.contracts.V3.STSAppliesToClaimType ct in appTo.ClaimTypes)
            {                
                claimTypes.Add(ConvertClaimTypeV3toV4(ct));
            }            

            newAppTo.ClaimTypes = claimTypes.ToArray();
            newAppTo.TokenType = appTo.TokenType;
            newAppTo.ValidityInterval = appTo.ValidityInterval;
            
            return newAppTo;
        }

        public static STSAppliesToClaimType ConvertClaimTypeV3toV4(xonline.mix.settingsmanagement.contracts.V3.STSAppliesToClaimType claimType)
        {
            STSAppliesToClaimType newClaimType = new STSAppliesToClaimType();
            newClaimType.ClaimTypeUri = claimType.ClaimTypeUri;
            newClaimType.Required = newClaimType.Required;
            return newClaimType;
        }
    }   
}

namespace xonline.mix.settingsmanagement.contracts.V3
{
    public partial class STSAppliesToClaimType
    {
        public override string ToString ()
        {
            return ClaimTypeUri + "(" + (Required ? "" : "Not ") + "Required)";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\TestBase.cs ===
ï»¿using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;

using ServerTestFramework;
using MIXTesting;
using ServerTestFramework.LiveService;

using xonline.common.config;

namespace MIXTesting
{
    /// <summary>
    /// The test base for WCF test cases
    /// </summary>
    public abstract class WCFTestBase : TestNode
    {
        protected virtual void Execute()
        {
        }

        public virtual void Verify()
        {
        }

        /// <summary>
        /// Print out the values of the Mix data member object
        /// It can handle an array of objects
        /// </summary>
        /// <param name="mixObj"></param>
        public static void PrintObject(Object mixObj)
        {
            if (mixObj == null)
                return;

            Type type = mixObj.GetType();
            Global.RO.Info("Mix Object values for " + mixObj.ToString());
            if (type.IsArray)
            {
                Array mixArray = (Array)mixObj;
                foreach (Object element in mixArray)
                {
                    PrintObject(element);
                }
                return;
            }

            foreach (PropertyInfo property in type.GetProperties())
            {
                if (property.GetCustomAttributes(typeof(DataMemberAttribute), false).Length == 1)
                {
                    Object subObj = property.GetValue(mixObj, null);
                    if (subObj != null)
                    {
                        Type subType = subObj.GetType();
                        if (subType.IsPrimitive || subType == typeof(string) || subType == typeof(Guid) ||
                            subType == typeof(DateTime) || subType == typeof(byte[]) || subType.IsEnum)
                            Global.RO.Info("\t" + property.Name + " = " + subObj);
                        else
                            PrintObject(subObj);
                    }
                }
            }
        }
    }

    public abstract class CnGWCFTestBase : WCFTestBase
    {
        public MatchWCFClient matchClient = new MatchWCFClient();
        public StatsWCFClient statsClient = new StatsWCFClient();
        public StorageWCFClient storageClient = new StorageWCFClient();
        public TitleManagementWCFClient titleClient = new TitleManagementWCFClient();

        public CnGWCFTestBase()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Template.cs ===
ï»¿using System;
using System.Xml;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.Xml.XPath;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

namespace MIXTesting
{
	public class Template
	{
        enum GameTypes { Game =1, GameConsumable =24, AvatarItem =47, Image =14, GameContent = 18};

        /// <summary>
        /// Process the input file, parse for the template to apply, generate template, and then save the proccessed file in the orignal location
        /// </summary>
        /// <param name="testCaseFilePath">path to file to be processed</param>
        public static void ProcessFileToApplyTemplate(string testCaseFilePath)
        {

            XElement input = XElement.Load(testCaseFilePath);
            input.Save(testCaseFilePath + ".original");
            ProcessMediaTemplate(input);
            ProcessOfferTemplate(input);
            input.Save(testCaseFilePath);
           
        }
     
        /// <summary>
        /// Process Media template
        /// </summary>
        /// <param name="input">the xml to apply template to</param>
        public static void ProcessMediaTemplate(XElement input)
        {
            ProcessTemplate(input, "MediaOperation", "Media");
        }
        /// <summary>
        /// Process Offer template
        /// </summary>
        /// <param name="input">the xml to apply template to</param>
        public static void ProcessOfferTemplate(XElement input)
        {
            ProcessTemplate(input, "OfferOperation", "ProcessedOffer");
        }

        /// <summary>
        /// Process the Media or Offer template, and send the list of media/ offer operation to ApplyTemplate
        /// </summary>
        /// <param name="input">the xml you wanted to process</param>
        /// <param name="operationKeyword">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
        /// <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        private static void ProcessTemplate(XElement input, string operationKeyword, string keyword)
        {
            XNamespace nameSpace = "http://schemas.datacontract.org/2004/07/MIXTesting";
            
            IEnumerable<XElement> operationList =

             operationList = input.Descendants(nameSpace + operationKeyword);

            foreach (XElement operation in operationList)
            {
                XElement template = operation.Element(nameSpace + "Template");
                if (template != null)
                {
                    ApplyTemplate(GetTemplate(template.Value), operation, keyword);
                }
            }
        }

        /// <summary>
        /// Reads the saves the input file as .templated, and then replace it with the original file
        /// </summary>
        /// <param name="testcaseFilePath">path to file to be reverted</param>
        public static void RevertProcessedFile(string testcaseFilePath)
        {
            System.IO.File.Copy(testcaseFilePath, testcaseFilePath+".templated",true);
            System.IO.File.Copy(testcaseFilePath + ".original", testcaseFilePath, true);
        }
        /// <summary>
        /// Gets the appropiate Template with provided templateTag
        /// </summary>
        /// <param name="templateTag">tag to indicate which template to use</param>
        /// <returns>an Xelement representing the template requested</returns>
        public static XElement GetTemplate(string templateTag)
        {
            XmlDocument template;

            switch (templateTag)
            {
                case "AppV1":
                    template = DataContractSerialize.ObjectToXml(CreateAppTemplateV1());
                    break;
                case "GameV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameTemplateV1());
                    break;

                case "LiveSubscriptionV1":
                    template = DataContractSerialize.ObjectToXml(CreateDefaultLiveSubscriptionV1());
                    break;

                case "GameConsumableV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameConsumableTemplateV1());
                    break;

                case "AvatarItemV1":
                    template = DataContractSerialize.ObjectToXml(CreateAvatarItemTemplateV1());
                    break;

                case "ImageV1":
                    template = DataContractSerialize.ObjectToXml(CreateImageTemplateV1());
                    break;

                case "GameContentV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameContentTemplateV1());
                    break;

                case "BundleV1":
                    template = DataContractSerialize.ObjectToXml(CreateBundleTemplateV1());
                    break;

                case "OfferV1":
                    template = DataContractSerialize.ObjectToXml(CreateOfferTemplateV1());
                    break;

                case "BundleOfferV1":
                    template = DataContractSerialize.ObjectToXml(CreateBundleOfferTemplateV1());
                    break;

                // extend here to allow more template options

                default:
                    throw new ArgumentException("Invalid Template");
            }
            return XElement.Load(new XmlNodeReader(template));
            
        }

        /// <summary>
        /// Applies template to each individual operation for media/ offer operation
        /// </summary>
        /// <param name="template">the template to apply</param>
        /// <param name="operation">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
        /// <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        public static void ApplyTemplate(XElement template, XElement operation, string keyword)
        {
            XNamespace nameSpace = "http://schemas.datacontract.org/2004/07/MIXTesting";
            XElement localTemplate = new XElement(template);
            XElement element = operation.Element(nameSpace + keyword);
            if (element == null)
            {
                throw new InvalidOperationException("There is no " + keyword + " in " + operation);
            }
            foreach (XElement overRide in element.Elements())
            {

                IEnumerable<XElement> toBeReplaced = from templateChild in localTemplate.Elements()
                                                     where templateChild.Name == overRide.Name
                                                     select templateChild;
                //only look in decendent if the element to be replaced is not found in the first level
                if (toBeReplaced.Count() == 0)
                {
                    toBeReplaced = from templateDecendent in localTemplate.Descendants()
                                   where templateDecendent.Name == overRide.Name
                                   select templateDecendent;
                }
                toBeReplaced.First().ReplaceWith(overRide);
            }
            operation.Element(nameSpace + keyword).ReplaceNodes(localTemplate.Elements());

        }

        #region Media Templates


        readonly static DateTime dateTime = Convert.ToDateTime("2005-01-01 00:00:00.000");

        #region Game Template
    
        public static object CreateGameTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game game = new xonline.mix.productmanagement.contracts.V1.Game();

            game.ProductId = Guid.NewGuid();
            game.VisibilityDate = dateTime;
            game.ReleaseDate = dateTime;
            game.GeoCheckPolicy = false;
            game.GameTypeId = (int) GameTypes.Game;
            game.LiveTitleId = 6666661;
            game.VisibilityStatus = 3;
            game.Sku = "XBX-00005";
            
            #endregion

            #region Categories

            game.Categories = new int[] { 1001, 12001 };

            #endregion

            #region GameLocalizedData

            game.GameLocalizedData = new xonline.mix.productmanagement.contracts.V1.GameLocalizedData[1];
            game.GameLocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.GameLocalizedData();
            game.GameLocalizedData[0].CustomGenre = "Test.CustomGenre";
            game.GameLocalizedData[0].Locale = "en-US";
            game.GameLocalizedData[0].Title = "Test.Title";
            game.GameLocalizedData[0].TitleSort = "Test.TitleSort";
            game.GameLocalizedData[0].TitleReduced = "Test.TitleReduced";
            game.GameLocalizedData[0].Description = "Test.Description";
            game.GameLocalizedData[0].DescriptionReduced = "Test.DescriptionReduced";
            game.GameLocalizedData[0].Publisher = "Test.Publisher";
            game.GameLocalizedData[0].Developer = "Test.Developer";
            game.GameLocalizedData[0].VoiceDisplayTitle = "Test.VoiceDisplayTitle";



            #region EquivalentLocales

            game.GameLocalizedData[0].EquivalentLocales = new string[] { "en-US"};

            #endregion
     
            #endregion
            #region SearchInformation
            game.SearchInformation = new xonline.mix.productmanagement.contracts.V1.SearchInformation[1];
            game.SearchInformation[0] = new xonline.mix.productmanagement.contracts.V1.SearchInformation();
            game.SearchInformation[0].AlternateTitles = new string [] {"Test.AlternateTitles"};
            game.SearchInformation[0].Keywords = new string [] {"Test.Keywords"};
            game.SearchInformation[0].Locale = "en-US";
            #endregion

            #region GameAttributes

            game.GameAttributes = new xonline.mix.productmanagement.contracts.V1.GameAttribute[1];
            game.GameAttributes[0] = new xonline.mix.productmanagement.contracts.V1.GameAttribute();
            game.GameAttributes[0].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[1];
            game.GameAttributes[0].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            game.GameAttributes[0].Attributes[0].AttributeName = "offlinePlayersMax";
            game.GameAttributes[0].Attributes[0].Value = "2";
            game.GameAttributes[0].Country = "US";
            game.GameAttributes[0].EquivalentCountries = new string[] { "US"};

            #endregion

            #region Executables

            game.Executables = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            game.Executables[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            game.Executables[0].PackageId = Guid.NewGuid();
            game.Executables[0].InstallSize = 100;
            game.Executables[0].PackageSize = 200;
            game.Executables[0].PackageType = 1;
            game.Executables[0].SupportedGameRegionMask = 255;
            game.Executables[0].Encryption = new Encryption();
            game.Executables[0].Encryption.PublicKey = new byte[284];
            game.Executables[0].Encryption.SymKey = new byte[16];
            game.Executables[0].Encryption = new Encryption();
            game.Executables[0].Encryption.SymKey = new byte[16];
            game.Executables[0].Encryption.PublicKey = new byte[284];
            game.Executables[0].ContentId = new byte[20];
            //if seed is not specified, system time will be used causing random to generate the same bytes if 2 calls are really close
            //use packageId hash as seed since contentId is related to packageId
            new Random(game.Executables[0].PackageId.GetHashCode()).NextBytes(game.Executables[0].ContentId);

            #region Files

            game.Executables[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            game.Executables[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            game.Executables[0].Files[0].FileUrl = "http://test.fileurl.com/file.xex";
            game.Executables[0].Files[0].SortOrder = 1;

            #endregion

            #region ClientTypes

            game.Executables[0].ClientTypes = new int[] { 1 };

            #endregion

            #endregion

            #region Ratings and RatingDescriptors

            game.Ratings = new int[1];
            game.Ratings[0] = 0;

            game.RatingDescriptors = new int[1];
            game.RatingDescriptors[0] = 1;

            #endregion

            #region VideoPreviews


            game.VideoPreviews = new xonline.mix.productmanagement.contracts.V1.VideoPreview[0];

            /*
            game.VideoPreviews[0] = new xonline.mix.productmanagement.contracts.V1.VideoPreview();
            game.VideoPreviews[0].Country = "US";
            game.VideoPreviews[0].FileUrl = "http://test.videopreview.com/test.wmv";
            game.VideoPreviews[0].PackageId = Guid.NewGuid();
             
	    disabled because it was disabled in Mix V1
            */ 
            #endregion

  
            return game;
        }


        #endregion


        #region App Template

        public static object CreateAppTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.App app = new xonline.mix.productmanagement.contracts.V1.App();

            app.ProductId = Guid.NewGuid();
            app.VisibilityDate = dateTime;
            app.ReleaseDate = dateTime; ;
            app.GeoCheckPolicy = false;
            app.AppTypes = new int[] {1};
            
            app.LiveTitleId = 6666661;
            app.VisibilityStatus = 3;
            app.Sku = "XBX-00005";
            app.TypeId = 61;
            
            #endregion

            #region Categories

            app.Categories = new int[] { 12001};

            #endregion

            #region AppLocalizedData

            app.AppLocalizedData = new xonline.mix.productmanagement.contracts.V1.AppLocalizedData[1];
            app.AppLocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.AppLocalizedData();
            app.AppLocalizedData[0].Locale = "en-US";
            app.AppLocalizedData[0].Title = "Test.Title";
            app.AppLocalizedData[0].TitleSort = "Test.TitleSort";
            app.AppLocalizedData[0].TitleReduced = "Test.TitleReduced";
            app.AppLocalizedData[0].Description = "Test.Description";
            app.AppLocalizedData[0].DescriptionReduced = "Test.DescriptionReduced";
            app.AppLocalizedData[0].Publisher = "Test.Publisher";
            app.AppLocalizedData[0].Developer = "Test.Developer";
            app.AppLocalizedData[0].VoiceDisplayTitle = "Test.VoiceDisplayTitle";

            #region EquivalentLocales

            app.AppLocalizedData[0].EquivalentLocales = new string[] { "en-US" };

            #endregion

            #endregion

            #region SearchInformation
            app.SearchInformation = new xonline.mix.productmanagement.contracts.V1.SearchInformation[1];
            app.SearchInformation[0] = new xonline.mix.productmanagement.contracts.V1.SearchInformation();
            app.SearchInformation[0].AlternateTitles = new string[] { "AlternateTitles" };
            app.SearchInformation[0].Keywords = new string[] { "Keywords" };
            app.SearchInformation[0].Locale = "en-US";
            #endregion


            #region AppAttributes
            
            app.ProductAttributes = new xonline.mix.productmanagement.contracts.V1.ProductAttribute[1];
            app.ProductAttributes[0] = new xonline.mix.productmanagement.contracts.V1.ProductAttribute();
            app.ProductAttributes[0].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[1];
            app.ProductAttributes[0].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            app.ProductAttributes[0].Attributes[0].AttributeName = "offlinePlayersMax";
            app.ProductAttributes[0].Attributes[0].Value = "2";
            app.ProductAttributes[0].Attributes[0].AttributeUnitType = 1;
            app.ProductAttributes[0].Country = "US";
         
            #endregion

           
            #region Executables

       
            app.Packages = new xonline.mix.productmanagement.contracts.V1.AppPackage[1];
            app.Packages[0] = new xonline.mix.productmanagement.contracts.V1.AppPackage();
            app.Packages[0].PackageId = Guid.NewGuid();
            app.Packages[0].InstallSize = 100;
            app.Packages[0].PackageSize = 200;
            app.Packages[0].PackageType = 1;
            app.Packages[0].Encryption = new Encryption();
            app.Packages[0].Encryption.PublicKey = new byte[284];
            app.Packages[0].Encryption.SymKey = new byte[16];
            app.Packages[0].Encryption = new Encryption();
            app.Packages[0].Encryption.SymKey = new byte[16];
            app.Packages[0].Encryption.PublicKey = new byte[284];
            app.Packages[0].ContentId = new byte[20];

            //if seed is not specified, system time will be used causing random to generate the same bytes if 2 calls are really close
            //use packageId hash as seed since contentId is related to packageId
            new Random(app.Packages[0].PackageId.GetHashCode()).NextBytes(app.Packages[0].ContentId);
            
            #region Files

            app.Packages[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            app.Packages[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            app.Packages[0].Files[0].FileUrl = "http://test.fileurl.com/file.xex";
            app.Packages[0].Files[0].SortOrder = 1;
            
            #endregion
            
            #region ClientTypes

            app.Packages[0].ClientTypes = new int[] { 1 };

            #endregion

            #endregion
            
            #region Ratings and RatingDescriptors

            app.Ratings = new int[1];
            app.Ratings[0] = 0;

            app.RatingDescriptors = new int[1];
            app.RatingDescriptors[0] = 1;

            #endregion


            return app;
        }


        #endregion




        #region GameContent Template

        public static object CreateGameContentTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.GameContent gameContent = new xonline.mix.productmanagement.contracts.V1.GameContent();

            gameContent.ProductId = Guid.NewGuid();
            gameContent.VisibilityDate = baseGame.VisibilityDate;
            gameContent.VisibilityStatus = baseGame.VisibilityStatus;
            gameContent.ReleaseDate = baseGame.ReleaseDate;
            gameContent.GeoCheckPolicy = false;
            gameContent.Sku = baseGame.Sku;
            gameContent.GameContentTypeId = (int) GameTypes.GameContent;

            gameContent.EffectiveLiveTitle = 6666662;
            gameContent.InheritRating = false;

            #endregion

            #region Categories

            gameContent.Categories = baseGame.Categories;

            #endregion

            #region GameRelationships

            gameContent.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            gameContent.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            gameContent.GameRelationships[0].GameId = baseGame.ProductId;
            gameContent.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            gameContent.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            gameContent.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            gameContent.LocalizedData[0].Description = baseGame.GameLocalizedData[0].Description;
            gameContent.LocalizedData[0].DescriptionReduced = baseGame.GameLocalizedData[0].DescriptionReduced;
            gameContent.LocalizedData[0].Locale = baseGame.GameLocalizedData[0].Locale;
            gameContent.LocalizedData[0].Title = baseGame.GameLocalizedData[0].Title;
            gameContent.LocalizedData[0].TitleReduced = baseGame.GameLocalizedData[0].TitleReduced;
            gameContent.LocalizedData[0].TitleSort = baseGame.GameLocalizedData[0].TitleSort;
            gameContent.LocalizedData[0].VoiceDisplayTitle = baseGame.GameLocalizedData[0].VoiceDisplayTitle;

            #region Equivalent Locales

            gameContent.LocalizedData[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;

            #endregion

            #endregion

            #region SearchInformation
            gameContent.SearchInformation = new xonline.mix.productmanagement.contracts.V1.SearchInformation[1];
            gameContent.SearchInformation[0] = new xonline.mix.productmanagement.contracts.V1.SearchInformation();
            gameContent.SearchInformation[0].AlternateTitles = new string[] { "AlternateTitles" };
            gameContent.SearchInformation[0].Keywords = new string[] { "Keywords" };
            gameContent.SearchInformation[0].Locale = "en-US";
                
            #endregion

            #region Packages

            gameContent.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            gameContent.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            gameContent.Packages[0].ContentId = baseGame.Executables[0].ContentId;
            gameContent.Packages[0].ClientTypes = baseGame.Executables[0].ClientTypes;
            gameContent.Packages[0].Files = baseGame.Executables[0].Files;
            gameContent.Packages[0].InstallSize = baseGame.Executables[0].InstallSize;
            gameContent.Packages[0].PackageId = baseGame.Executables[0].PackageId;
            gameContent.Packages[0].PackageSize = baseGame.Executables[0].PackageSize;
            gameContent.Packages[0].PackageType = baseGame.Executables[0].PackageType;
            gameContent.Packages[0].SupportedGameRegionMask = baseGame.Executables[0].SupportedGameRegionMask;
            gameContent.Packages[0].Encryption = baseGame.Executables[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            gameContent.Ratings = baseGame.Ratings;

            gameContent.RatingDescriptors = baseGame.RatingDescriptors;

            #endregion

            return (gameContent);
        }

        #endregion

        #region Bundle Template

        // This is for stub testing only: full feature testing will require fleshing out the entire object
        public static object CreateBundleTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.Bundle bundle = new xonline.mix.productmanagement.contracts.V1.Bundle();

            bundle.ProductId = Guid.NewGuid();
            bundle.VisibilityDate = baseGame.VisibilityDate;
            bundle.VisibilityStatus = baseGame.VisibilityStatus;

            #endregion

            #region BundleLocalizedData

            bundle.BundleLocalizedData = new BundleLocalizedData[1];
            bundle.BundleLocalizedData[0] = new BundleLocalizedData();
            bundle.BundleLocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.BundleLocalizedData();
            bundle.BundleLocalizedData[0].Locale = "en-US";
            bundle.BundleLocalizedData[0].Title = "Test.Title";
            bundle.BundleLocalizedData[0].TitleSort = "Test.TitleSort";
            bundle.BundleLocalizedData[0].TitleReduced = "Test.TitleReduced";
            bundle.BundleLocalizedData[0].Description = "Test.Description";
            bundle.BundleLocalizedData[0].DescriptionReduced = "Test.DescriptionReduced";
            bundle.BundleLocalizedData[0].Publisher = "Test.Publisher";
            bundle.BundleLocalizedData[0].Developer = "Test.Developer";

            #endregion

            #region SearchInformation
            bundle.SearchInformation = new xonline.mix.productmanagement.contracts.V1.SearchInformation[1];
            bundle.SearchInformation[0] = new xonline.mix.productmanagement.contracts.V1.SearchInformation();
            bundle.SearchInformation[0].AlternateTitles = new string[] { "AlternateTitles" };
            bundle.SearchInformation[0].Keywords = new string[] { "Keywords" };
            bundle.SearchInformation[0].Locale = "en-US";
            #endregion

            #region ProductIds

            bundle.ProductIds = new Guid[1];
            bundle.ProductIds[0] = Guid.NewGuid();

            #endregion

            return (bundle);
        }

        #endregion

        #region Image Template
        
        public static object CreateImageTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.Image image = new xonline.mix.productmanagement.contracts.V1.Image();

            image.ProductId = Guid.NewGuid();
            image.VisibilityDate = baseGame.VisibilityDate;
            image.VisibilityStatus = baseGame.VisibilityStatus;

            #endregion

            #region LocalizedImageFiles

            image.LocalizedImageFiles = new xonline.mix.productmanagement.contracts.V1.LocalizedImageFile[1];
            image.LocalizedImageFiles[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedImageFile();
            image.LocalizedImageFiles[0].Locale = baseGame.GameLocalizedData[0].Locale;
            image.LocalizedImageFiles[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;
            image.LocalizedImageFiles[0].FileUrl = "http://www.xbox.com/NR/rdonlyres/3EC74CDC-841C-4135-81F4-DFB1448C01EB/0/simbandofbugsxboxlivearcade001.jpg";
            image.LocalizedImageFiles[0].FormatId = 4;
            image.LocalizedImageFiles[0].LocalizedFileId = Guid.NewGuid();
            image.LocalizedImageFiles[0].SizeId = 27;

            #endregion

            #region ProductRelationships

            image.ProductRelationships = new ProductRelationship[1];
            image.ProductRelationships[0] = new ProductRelationship();
            image.ProductRelationships[0].ProductId = baseGame.ProductId;
            image.ProductRelationships[0].RelationshipTypeId = 33;
            image.ProductRelationships[0].SortOrder = 0;

            #endregion

            return (image);
        }

        #endregion

        #region GameConsumable Template


        public static GameConsumable CreateGameConsumableTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.GameConsumable gameConsumable = new xonline.mix.productmanagement.contracts.V1.GameConsumable();

            gameConsumable.ProductId = Guid.NewGuid();
            gameConsumable.VisibilityDate = baseGame.VisibilityDate;
            gameConsumable.VisibilityStatus = baseGame.VisibilityStatus;
            gameConsumable.ReleaseDate = baseGame.ReleaseDate;
            gameConsumable.GeoCheckPolicy = false;
            gameConsumable.Sku = baseGame.Sku;
            gameConsumable.GameContentTypeId = (int)GameTypes.GameConsumable;

            gameConsumable.EffectiveLiveTitle = 6666663;
            gameConsumable.InheritRating = false;

            gameConsumable.AssetId = 7777771;

            #endregion

            #region Categories

            gameConsumable.Categories = baseGame.Categories;

            #endregion

            #region GameRelationships

            gameConsumable.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            gameConsumable.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            gameConsumable.GameRelationships[0].GameId = baseGame.ProductId;
            gameConsumable.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            gameConsumable.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            gameConsumable.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            gameConsumable.LocalizedData[0].Description = baseGame.GameLocalizedData[0].Description;
            gameConsumable.LocalizedData[0].DescriptionReduced = baseGame.GameLocalizedData[0].DescriptionReduced;
            gameConsumable.LocalizedData[0].Locale = baseGame.GameLocalizedData[0].Locale;
            gameConsumable.LocalizedData[0].Title = baseGame.GameLocalizedData[0].Title;
            gameConsumable.LocalizedData[0].TitleReduced = baseGame.GameLocalizedData[0].TitleReduced;
            gameConsumable.LocalizedData[0].TitleSort = baseGame.GameLocalizedData[0].TitleSort;
            gameConsumable.LocalizedData[0].VoiceDisplayTitle = baseGame.GameLocalizedData[0].VoiceDisplayTitle;

            #region Equivalent Locales

            gameConsumable.LocalizedData[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;

            #endregion

            #endregion


            #region SearchInformation
            gameConsumable.SearchInformation = new xonline.mix.productmanagement.contracts.V1.SearchInformation[1];
            gameConsumable.SearchInformation[0] = new xonline.mix.productmanagement.contracts.V1.SearchInformation();
            gameConsumable.SearchInformation[0].AlternateTitles = new string[] { "AlternateTitles" };
            gameConsumable.SearchInformation[0].Keywords = new string[] { "Keywords" };
            gameConsumable.SearchInformation[0].Locale = "en-US";
            #endregion
            #region Packages

            gameConsumable.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            gameConsumable.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            gameConsumable.Packages[0].ContentId = baseGame.Executables[0].ContentId;
            gameConsumable.Packages[0].ClientTypes = baseGame.Executables[0].ClientTypes;
            gameConsumable.Packages[0].Files = baseGame.Executables[0].Files;
            gameConsumable.Packages[0].InstallSize = baseGame.Executables[0].InstallSize;
            gameConsumable.Packages[0].PackageId = baseGame.Executables[0].PackageId;
            gameConsumable.Packages[0].PackageSize = baseGame.Executables[0].PackageSize;
            gameConsumable.Packages[0].PackageType = baseGame.Executables[0].PackageType;
            gameConsumable.Packages[0].SupportedGameRegionMask = baseGame.Executables[0].SupportedGameRegionMask;
            gameConsumable.Packages[0].Encryption = baseGame.Executables[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            gameConsumable.Ratings = baseGame.Ratings;

            gameConsumable.RatingDescriptors = baseGame.RatingDescriptors;

            #endregion

            return (gameConsumable);
        }

        #endregion

        #region AvatarItem Template


        public static object CreateAvatarItemTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.GameConsumable baseGameConsumable = CreateGameConsumableTemplateV1() as xonline.mix.productmanagement.contracts.V1.GameConsumable;

            xonline.mix.productmanagement.contracts.V1.AvatarItem avatarItem = new xonline.mix.productmanagement.contracts.V1.AvatarItem();

            avatarItem.ProductId = Guid.NewGuid();
            avatarItem.VisibilityDate = baseGameConsumable.VisibilityDate;
            avatarItem.VisibilityStatus = baseGameConsumable.VisibilityStatus;
            avatarItem.ReleaseDate = baseGameConsumable.ReleaseDate;
            avatarItem.GeoCheckPolicy = false;
            avatarItem.Sku = baseGameConsumable.Sku;
            avatarItem.GameContentTypeId = (int) GameTypes.AvatarItem;

            avatarItem.EffectiveLiveTitle = 6666664;
            avatarItem.InheritRating = false;

            avatarItem.AssetId = Guid.NewGuid();
            avatarItem.BodyType = 1;

            #endregion

            #region Categories

            avatarItem.Categories = baseGameConsumable.Categories;

            #endregion

            #region GameRelationships

            avatarItem.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            avatarItem.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            avatarItem.GameRelationships[0].GameId = baseGameConsumable.ProductId;
            avatarItem.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            avatarItem.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            avatarItem.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            avatarItem.LocalizedData[0].Description = baseGameConsumable.LocalizedData[0].Description;
            avatarItem.LocalizedData[0].DescriptionReduced = baseGameConsumable.LocalizedData[0].DescriptionReduced;
            avatarItem.LocalizedData[0].Locale = baseGameConsumable.LocalizedData[0].Locale;
            avatarItem.LocalizedData[0].Title = baseGameConsumable.LocalizedData[0].Title;
            avatarItem.LocalizedData[0].TitleReduced = baseGameConsumable.LocalizedData[0].TitleReduced;
            avatarItem.LocalizedData[0].TitleSort = baseGameConsumable.LocalizedData[0].TitleSort;

            #region Equivalent Locales

            avatarItem.LocalizedData[0].EquivalentLocales = baseGameConsumable.LocalizedData[0].EquivalentLocales;

            #endregion

            #endregion

            #region Packages

            avatarItem.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            avatarItem.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            avatarItem.Packages[0].ContentId = baseGameConsumable.Packages[0].ContentId;
            avatarItem.Packages[0].ClientTypes = baseGameConsumable.Packages[0].ClientTypes;
            avatarItem.Packages[0].Files = baseGameConsumable.Packages[0].Files;
            avatarItem.Packages[0].InstallSize = baseGameConsumable.Packages[0].InstallSize;
            avatarItem.Packages[0].PackageId = baseGameConsumable.Packages[0].PackageId;
            avatarItem.Packages[0].PackageSize = baseGameConsumable.Packages[0].PackageSize;
            avatarItem.Packages[0].PackageType = baseGameConsumable.Packages[0].PackageType;
            avatarItem.Packages[0].SupportedGameRegionMask = baseGameConsumable.Packages[0].SupportedGameRegionMask;
            avatarItem.Packages[0].Encryption = baseGameConsumable.Packages[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            avatarItem.Ratings = baseGameConsumable.Ratings;

            avatarItem.RatingDescriptors = baseGameConsumable.RatingDescriptors;

            #endregion

            return (avatarItem);
        }



        #endregion

        #region LiveSubscription

        public static LiveSubscription CreateDefaultLiveSubscriptionV1()
        {
            LiveSubscription liveSubscription = new LiveSubscription();
            liveSubscription.ProductId = new Guid();
            liveSubscription.BillingFrequency = 1;
            liveSubscription.IsCancelable = false;
            liveSubscription.GeoCheckPolicy = false;
            liveSubscription.RatingDescriptors = new int[1]; 
            liveSubscription.RatingDescriptors[0] = 1;
            liveSubscription.Ratings = new int[1];
            liveSubscription.Ratings [0] = 0;
            liveSubscription.Name = "default subscription";
            liveSubscription.SellType = 1;
            liveSubscription.ServiceComponentId = new Guid().ToString();
            liveSubscription.Sku = "DefaultSKU";
            liveSubscription.SubscriptionDuration = 30;
            liveSubscription.SubscriptionDurationType = 1;
            //need to provide the guid, otherwise, the deserilze would fail.
            liveSubscription.SubscriptionFamily = new Guid();
            liveSubscription.LocalizedData = new LocalizedData[1];
            liveSubscription.LocalizedData[0] = new LocalizedData();
            liveSubscription.LocalizedData[0].Description = "Default Description";
            liveSubscription.LocalizedData[0].DescriptionReduced = "DefaultDescriptionReduced";
            liveSubscription.LocalizedData[0].EquivalentLocales = new string[] { "en-US" };
            liveSubscription.LocalizedData[0].Locale = "en-US";
            liveSubscription.LocalizedData[0].Title = "Default Title";
            liveSubscription.LocalizedData[0].TitleReduced = "Default Title Reduced";
            liveSubscription.LocalizedData[0].TitleSort = "Default Title Sort";

            liveSubscription.ReleaseDate = dateTime;
            liveSubscription.VisibilityDate = dateTime;
            liveSubscription.VisibilityStatus = 3;

            return liveSubscription;
        }
        #endregion

        #endregion


        
        #region Offer Template
        public static readonly Guid PackageId = System.Guid.NewGuid();
        public static readonly Guid ProductId = System.Guid.NewGuid();

        public static Offer CreateOfferTemplateV1()
        {
            #region base
            Offer newOffer = new Offer();
            newOffer.OfferId = System.Guid.NewGuid();
            newOffer.LiveOfferId = new Random().Next();
            newOffer.Name = "Test Offer";
            newOffer.ProductId = Template.ProductId;
            #endregion

            #region Offer Instances
            newOffer.Instances = new OfferInstance[1];
            newOffer.Instances[0] = new OfferInstance();
            newOffer.Instances[0].CountryCode = "US";
            newOffer.Instances[0].StartDate = new DateTime (2000,10,29, 14,7,25,613);
            newOffer.Instances[0].EndDate = new DateTime(2099, 10, 29, 14, 7, 25, 613);
            newOffer.Instances[0].OfferInstanceId = System.Guid.NewGuid();
            newOffer.Instances[0].PaymentPrice = 1234.0000M;
            newOffer.Instances[0].WholeSalePrice = 1234.0000M;
            newOffer.Instances[0].SuggestedRetailPrice = 1234.0000M;
            newOffer.Instances[0].PaymentPriceCurrencyCode = "MPT";
            newOffer.Instances[0].PaymentTypeId = 1;
            newOffer.Instances[0].Packages = new OfferPackage[1];
            newOffer.Instances[0].Packages[0] = new OfferPackage();
            newOffer.Instances[0].Packages[0].PackageId = Template.PackageId;
            newOffer.Instances[0].Packages[0].ProviderId = 7;
            newOffer.Instances[0].Packages[0].LicenseExtensionBits = 1;
            newOffer.Instances[0].Packages[0].LicenseTypeId = 14;
            newOffer.Instances[0].Packages[0].Quantity = 0; 
            newOffer.Instances[0].Packages[0].VisibilityStatusId = 3;
            newOffer.Instances[0].UserTypeIds = new int[1];
            newOffer.Instances[0].UserTypeIds[0] = 3;
            newOffer.Instances[0].VisibilityLevelId = 1;
            newOffer.Instances[0].OfferProducts = new OfferProduct [1];
            newOffer.Instances[0].OfferProducts[0] = new OfferProduct();
            newOffer.Instances[0].OfferProducts[0].ProductId = Template.ProductId;
            newOffer.Instances[0].OfferProducts[0].LicenseTypeId = 14;
            newOffer.Instances[0].OfferProducts[0].ProviderId = 7;
            newOffer.Instances[0].OfferProducts[0].VisibilityStatusId = 3;
            newOffer.Instances[0].ExternalOfferInstanceId = "ExternalOfferInstanceId";
            

            #endregion

            #region storeId and offerType
            newOffer.StoreIds = new int[1];
            newOffer.StoreIds[0] = 1;
            newOffer.OfferType = 1;
            #endregion

            #region OfferRelationships

            newOffer.OfferRelationShips = new OfferRelationShip[1];
            newOffer.OfferRelationShips[0]= new OfferRelationShip();
            newOffer.OfferRelationShips[0].RelatedOfferId = newOffer.OfferId;
            #endregion
            
            return newOffer;
        }
        #endregion

        #region Offer Template
        public static Offer CreateBundleOfferTemplateV1()
        {
            #region base
            var baseOffer = CreateOfferTemplateV1();
            baseOffer.Instances[0].Packages[0].BundleFinancial = new BundleFinancial();
            baseOffer.Instances[0].Packages[0].BundleFinancial.ProductId = System.Guid.NewGuid();
            baseOffer.Instances[0].Packages[0].BundleFinancial.PaymentPrice = 20;
            baseOffer.Instances[0].Packages[0].BundleFinancial.SuggestedRetailPrice = 20;
            baseOffer.Instances[0].Packages[0].BundleFinancial.WholeSalePrice = 20;
            #endregion

            return baseOffer;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\BetaManagementV2WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.betamanagement.contracts.V2;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{
    /// <summary>
    /// The Beta Management WCF client.
    /// This is the one location that contains all API calls for the Stats component.
    /// </summary>
    public class BetaManagementV2WCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixbetamanagement/mixbetamanagementV2.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixBetaManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixBetaManagementV2Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixbetamanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixBetaManagementV2Client client = new MixBetaManagementV2Client(wsb, epa);
            return client;
        }

        #region APIs


        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseVersion"></param>
        /// <param name="currentFlashVersion"></param>
        /// <param name="systemOnlineManifest"></param>
        /// <param name="SystemManifest"></param>
        /// <param name="group"></param>
        /// <param name="titleID"></param>
        /// <param name="addUpgradePaths"></param>
        public void AssignReleaseToGroup(uint baseVersion, uint currentFlashVersion, string systemOnlineManifest, string SystemManifest, Guid group, uint titleID, bool addUpgradePaths)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignReleaseToGroup", baseVersion, currentFlashVersion, systemOnlineManifest, SystemManifest, group, titleID, addUpgradePaths);
            VerifyHR(hr, ex);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="baseVersion"></param>
        /// <param name="currentVersion"></param>
        /// <param name="group"></param>
        public void AssignTitleUpdateToGroup(uint titleID, uint baseVersion, uint currentVersion, Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignTitleUpdateToGroup", titleID, baseVersion, currentVersion, group);
            VerifyHR(hr, ex);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="version"></param>
        /// <returns></returns>
        public bool IsTitleVersionPropped(uint titleID, uint version)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            bool result = Invoke<bool>(CreateNewClient(), out hr, out retryable, out ex, "IsTitleVersionPropped", titleID, version);
            VerifyHR(hr, ex);

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public GroupSummary[] GetGroups()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummary[] result = Invoke<GroupSummary[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroups");
            VerifyHR(hr, ex);

            return result;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Group GetGroupDetails(Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Group result = Invoke<Group>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupDetails", group);
            VerifyHR(hr, ex);

            return result;
        }

        public System.Guid CreateGroup(string name, string creator)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            System.Guid result = Invoke<System.Guid>(CreateNewClient(), out hr, out retryable, out ex, "CreateGroup", name, creator);
            VerifyHR(hr, ex);

            return result;
        }

        public void UpdateGroup(System.Guid group, string name, string creator)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "UpdateGroup", group, name, creator);
            VerifyHR(hr, ex);
        }

        public InvalidConsole[] ValidateBetaGroupConsoles(Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            InvalidConsole[] result = Invoke<InvalidConsole[]>(CreateNewClient(), out hr, out retryable, out ex, "ValidateBetaGroupConsoles", betaGroup);
            VerifyHR(hr, ex);

            return result; // This will be updated as the final data structures are checked in
        }

        public GroupMembershipChangeResult[] AddConsoleIDsToGroup(string[] consoleIDs, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "AddConsoleIDsToGroup", consoleIDs, group);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupMembershipChangeResult[] RemoveConsoleIDsFromGroup(string[] consoleIDs, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "RemoveConsoleIDsFromGroup", consoleIDs, group);
            VerifyHR(hr, ex);

            return result;
        }

        public string[] GetConsoleIDsInGroup(System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            string []result=Invoke<string[]>(CreateNewClient(), out hr, out retryable, out ex, "GetConsoleIDsInGroup", group);
            VerifyHR(hr, ex);

            return result;
        }
        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\BetaManagementV4WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.betamanagement.contracts.V4;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{
    /// <summary>
    /// The Beta Management WCF client.
    /// This is the one location that contains all API calls for the Stats component.
    /// </summary>
    public class BetaManagementV4WCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixbetamanagement/mixbetamanagementV4.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixBetaManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        protected static MixBetaManagementV4Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixbetamanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixBetaManagementV4Client client = new MixBetaManagementV4Client(wsb, epa);
            return client;
        }

        #region APIs

        public void AssignReleaseToGroup(uint baseVersion, uint currentFlashVersion, string systemOnlineManifest, string SystemManifest, Guid group, uint titleID, bool addUpgradePaths, ReleaseApp []apps)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignReleaseToGroup", baseVersion, currentFlashVersion, systemOnlineManifest, SystemManifest, group, titleID, addUpgradePaths, apps);
            VerifyHR(hr, ex);
        }

        public void AssignTitleUpdateToGroup(uint titleID, uint baseVersion, uint currentVersion, Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignTitleUpdateToGroup", titleID, baseVersion, currentVersion, group);
            VerifyHR(hr, ex);
        }

        public void AssignTitleUpdateToGroups(uint titleID, uint baseVersion, uint currentVersion, Guid[] groups, bool noReload)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignTitleUpdateToGroups", titleID, baseVersion, currentVersion, groups, noReload);
            VerifyHR(hr, ex);
        }

        public bool IsTitleVersionPropped(uint titleID, uint version)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            bool result = Invoke<bool>(CreateNewClient(), out hr, out retryable, out ex, "IsTitleVersionPropped", titleID, version);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupSummary[] GetGroups()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummary[] result = Invoke<GroupSummary[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroups");
            VerifyHR(hr, ex);

            return result;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Group GetGroupDetails(Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Group result = Invoke<Group>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupDetails", group);
            VerifyHR(hr, ex);

            return result;
        }

        public System.Guid CreateGroup(string name, string creator)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            System.Guid result = Invoke<System.Guid>(CreateNewClient(), out hr, out retryable, out ex, "CreateGroup", name, creator);
            VerifyHR(hr, ex);

            return result;
        }

        public void UpdateGroup(System.Guid group, GroupUpdate gu)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "UpdateGroup", group, gu);
            VerifyHR(hr, ex);
        }

        public InvalidConsole[] ValidateBetaGroupConsoles(Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            InvalidConsole[] result = Invoke<InvalidConsole[]>(CreateNewClient(), out hr, out retryable, out ex, "ValidateBetaGroupConsoles", betaGroup);
            VerifyHR(hr, ex);

            return result; // This will be updated as the final data structures are checked in
        }

        public GroupMembershipChangeResult[] AddConsoleInfosToGroup(ConsoleInfo[] consoleInfos, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "AddConsoleInfosToGroup", consoleInfos, group);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupMembershipChangeResult[] RemoveConsoleInfosFromGroup(ConsoleInfo[] consoleInfos, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "RemoveConsoleInfosFromGroup", consoleInfos, group);
            VerifyHR(hr, ex);

            return result;
        }

        public ConsoleInfo[] GetConsoleInfosInGroup(System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            ConsoleInfo []result=Invoke<ConsoleInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetConsoleInfosInGroup", group);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupSummaryForConsole[] GetGroupsForConsoleInfos(ConsoleInfo[] consoleInfos)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummaryForConsole []result=Invoke<GroupSummaryForConsole[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupsForConsoleInfos", (object)consoleInfos);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupMembershipChangeResult[] MigrateConsoleInfosToGroup(ConsoleInfo[] consoleInfos, System.Guid fromGroup, System.Guid toGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult[] result = Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "MigrateConsoleInfosToGroup", consoleInfos, fromGroup, toGroup);
            VerifyHR(hr, ex);

            return result;
        }

        public void RemoveGroup(System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveGroup", group);
            VerifyHR(hr, ex);
        }

        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\BetaManagementV3WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.betamanagement.contracts.V3;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{
    /// <summary>
    /// The Beta Management WCF client.
    /// This is the one location that contains all API calls for the Stats component.
    /// </summary>
    public class BetaManagementV3WCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixbetamanagement/mixbetamanagementV3.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixBetaManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        protected static MixBetaManagementV3Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixbetamanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixBetaManagementV3Client client = new MixBetaManagementV3Client(wsb, epa);
            return client;
        }

        #region APIs

        public void AssignReleaseToGroup(uint baseVersion, uint currentFlashVersion, string systemOnlineManifest, string SystemManifest, Guid group, uint titleID, bool addUpgradePaths, ReleaseApp []apps)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignReleaseToGroup", baseVersion, currentFlashVersion, systemOnlineManifest, SystemManifest, group, titleID, addUpgradePaths, apps);
            VerifyHR(hr, ex);
        }

        public void AssignTitleUpdateToGroup(uint titleID, uint baseVersion, uint currentVersion, Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignTitleUpdateToGroup", titleID, baseVersion, currentVersion, group);
            VerifyHR(hr, ex);
        }

        public void AssignTitleUpdateToGroups(uint titleID, uint baseVersion, uint currentVersion, Guid[] groups, bool noReload)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignTitleUpdateToGroups", titleID, baseVersion, currentVersion, groups, noReload);
            VerifyHR(hr, ex);
        }

        public bool IsTitleVersionPropped(uint titleID, uint version)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            bool result = Invoke<bool>(CreateNewClient(), out hr, out retryable, out ex, "IsTitleVersionPropped", titleID, version);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupSummary[] GetGroups()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummary[] result = Invoke<GroupSummary[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroups");
            VerifyHR(hr, ex);

            return result;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Group GetGroupDetails(Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Group result = Invoke<Group>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupDetails", group);
            VerifyHR(hr, ex);

            return result;
        }

        public System.Guid CreateGroup(string name, string creator)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            System.Guid result = Invoke<System.Guid>(CreateNewClient(), out hr, out retryable, out ex, "CreateGroup", name, creator);
            VerifyHR(hr, ex);

            return result;
        }

        public void UpdateGroup(System.Guid group, GroupUpdate gu)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "UpdateGroup", group, gu);
            VerifyHR(hr, ex);
        }

        public InvalidConsole[] ValidateBetaGroupConsoles(Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            InvalidConsole[] result = Invoke<InvalidConsole[]>(CreateNewClient(), out hr, out retryable, out ex, "ValidateBetaGroupConsoles", betaGroup);
            VerifyHR(hr, ex);

            return result; // This will be updated as the final data structures are checked in
        }

        public GroupMembershipChangeResult[] AddConsoleIDsToGroup(string[] consoleIDs, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "AddConsoleIDsToGroup", consoleIDs, group);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupMembershipChangeResult[] RemoveConsoleIDsFromGroup(string[] consoleIDs, System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult []result=Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "RemoveConsoleIDsFromGroup", consoleIDs, group);
            VerifyHR(hr, ex);

            return result;
        }

        public string[] GetConsoleIDsInGroup(System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            string []result=Invoke<string[]>(CreateNewClient(), out hr, out retryable, out ex, "GetConsoleIDsInGroup", group);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupSummaryForConsole[] GetGroupsForConsoleIDs(string[] consoleIDs)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummaryForConsole []result=Invoke<GroupSummaryForConsole[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupsForConsoleIDs", (object)consoleIDs);
            VerifyHR(hr, ex);

            return result;
        }

        public GroupMembershipChangeResult[] MigrateConsoleIDsToGroup(string[] consoleIDs, System.Guid fromGroup, System.Guid toGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupMembershipChangeResult[] result = Invoke<GroupMembershipChangeResult[]>(CreateNewClient(), out hr, out retryable, out ex, "MigrateConsoleIDsToGroup", consoleIDs, fromGroup, toGroup);
            VerifyHR(hr, ex);

            return result;
        }

        public void RemoveGroup(System.Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<string[]>(CreateNewClient(), out hr, out retryable, out ex, "RemoveGroup", group);
            VerifyHR(hr, ex);
        }

        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\ValidatorCommon.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections.Generic;
using xonline.mix.productmanagement.contracts.V1;

using System.Reflection;
using System.Reflection.Emit;
using MIXTesting;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.common;

namespace MIXTesting
{

    /// <summary>
    /// Static class which defines string lengths to be used in validators
    /// </summary>
    public static class StringLengths
    {
        public const int LocaleMin = 1;
        public const int LocaleMax = 10;
        public const int TitleMin = 1;
        public const int TitleMax = 255;
        public const int TitleSortMin = 0;
        public const int TitleSortMax = 255;
        public const int TitleReducedMin = 1;
        public const int TitleReducedMax = 50;
        public const int DescriptionMin = 1;
        public const int DescriptionMax = 4000;
        public const int DescriptionReducedMin = 1;
        public const int DescriptionReducedMax = 500;
        public const int CountryMin = 2;
        public const int CountryMax = 2;
        public const int FileUrlMin = 1;
        public const int FileUrlMax = 512;
        public const int SkuMin = 1;
        public const int SkuMax = 50;
        public const int CustomGenreMin = 0;
        public const int CustomGenreMax = 80;
        public const int DeveloperMin = 1;
        public const int DeveloperMax = 80;
        public const int PublisherMin = 1;
        public const int PublisherMax = 255;
        public const int OfferNameMin = 1;
        public const int OfferNameMax = 255;
        public const int CurrencyCodeMin = 3;
        public const int CurrencyCodeMax = 3;
        public const int AttributeNameMin = 1;
        public const int AttributeNameMax = 50;
        public const int TermsMin = 1;
        public const int TermsMax = 255;
        public const int VoiceDisplayTitleMin = 1;
        public const int VoiceDisplayTitleMax = 25;



        public static string GetString(int length, string txt)
        {
            return GetString(length, txt, '.');
        }

        public static string GetString(int length, string txt, char appendString)
        {
            StringBuilder strBuilder = new StringBuilder(length);

            strBuilder.Append(txt.Substring(0, txt.Length <= length ? txt.Length : length));

            for (int i = txt.Length; i < length; i++)
            {
                strBuilder.Append(appendString);
            }
            return strBuilder.ToString();
        }
    }

    public enum ValidationType
    {
        None,
        Max,
        Min,
        StrLenMin,
        StrLenMax,
        Error,
        LessMin,
        BiggerMax,
        LessStrLenMin,// the input not allow Null 
        BiggerLenStrMax,
        NullException,
        NullExceptionAlsoBoundary,
        ArrayNullException,
        RegularExpression,
        NotInBoundary,
        InvalidUri
    }


    public static class TemplateMessages
    {
        public const string RangeStringAllowNull = "The value ({0}) at key ({2})/({1}) should either be null or within the lower bound {3}(Inclusive) and upper bound {4}(Inclusive)";
        public const string InvalidString = "The value ({0}) at key ({2})/({1}) is not within the lower bound {3}({4}) and upper bound {5}({6})";
        public const string NullObjectString = "The value at key ({1})/({0}) is null";
    }

    /// <summary>
    /// Static class which defines the Tags in the validators
    /// </summary>
    public static class Tags
    {
        public const string LocalizedDataTag = "LocalizedData";
        public const string GameRatingDescriptorTag = "GameRatingDescriptor";
        public const string GameRatingTag = "GameRating";
        public const string GameAttributeTag = "GameAttribute";
        public const string EncryptionTag = "Encryption";
        public const string FileTag = "File";
        public const string LocalizedFileTag = "LocalizedFile";
        public const string GameRelationshipTag = "GameRelationship";
        public const string ProductRelationshipTag = "ProductRelationship";
        public const string PackageTag = "Package";
        public const string ProductPackageTag = "ProductPackage";
        public const string GameExecutableTag = "GameExecutable";
        public const string ProductTag = "Product";
        public const string MediaBaseTag = "MediaBase";
        public const string ImageTag = "Image";
        public const string LocalizedImageFileTag = "LocalizedImageFile";
        public const string ProductBaseTag = "ProductBase";
        public const string GameTag = "Game";
        public const string PreviewPackageTag = "PreviewPackage";
        public const string VideoPreviewTag = "VideoPreview";
        public const string GameLocalizedDataTag = "GameLocalizedData";
        public const string GameContentTag = "GameContent";
        public const string GameConsumableTag = "GameConsumable";
        public const string AvatarItemTag = "AvatarItem";
        public const string BundleTag = "Bundle";
        public const string OfferTag = "Offer";
        public const string OfferInstanceTag = "OfferInstance";
        public const string OfferPackageTag = "OfferPackage";
    }

    /// <summary>
    /// Each Input object includes ValidationType, Value that can be used to set a Product 
    /// and the ErrorMessagor corresponding to that Value. Each Input object can be retrieved and used to create
    /// a test case to verfiy the corresponding validator. 
    /// </summary>
    public class Input
    {
        public string ErrMessage;
        public Object Value;
        public ValidationType ValidationType;

        public bool Verified;

        public Input(Object value, ValidationType vType, string err)
        {
            ErrMessage = err;
            this.Value = value;
            ValidationType = vType;
            Verified = false;
        }

        public Input(Object value, ValidationType vType, string key1, string key2, int lowerBound, int upperBound, bool notNull)
        {
            Input0(value, vType, key1, key2, lowerBound, upperBound, notNull);
        }

        public Input(Object value, ValidationType vType, string key1, string key2, int lowerBound, int upperBound)
        {
            Input0(value, vType, key1, key2, lowerBound, upperBound, true);
        }

        public void Input0(Object value, ValidationType vType, string key1, string key2, int lowerBound, int upperBound, bool notNull)
        {

            this.Value = value;
            ValidationType = vType;
            Verified = false;

            switch (vType)
            {
                case ValidationType.LessMin:
                case ValidationType.BiggerMax:
                    ErrMessage = String.Format(TemplateMessages.InvalidString, (string)value, key2, key1, lowerBound, "Inclusive", upperBound, "Inclusive");
                    break;
                case ValidationType.BiggerLenStrMax:
                case ValidationType.LessStrLenMin:
                case ValidationType.NullExceptionAlsoBoundary:
                    if (notNull)
                        ErrMessage = String.Format(TemplateMessages.InvalidString, (string)value, key2, key1, lowerBound, "Inclusive", upperBound, "Inclusive");
                    else
                        ErrMessage = String.Format(TemplateMessages.RangeStringAllowNull, (string)value, key2, key1, lowerBound, upperBound);
                    break;
                case ValidationType.StrLenMax:
                case ValidationType.StrLenMin:
                    ErrMessage = "";
                    break;
            }
        }
    }

    /// <summary>
    /// A hash table is used to store info about individual validators. The key is the name of the validator and 
    /// the value of the  entry is an array of  objects that can be used to set the data member of a contract  
    /// and the error  message corresponding to the server returned when passing that value.
    /// </summary>
    public class ValidatorExceptionTable
    {
        public Hashtable ExceptionTbl;

        public ValidatorExceptionTable()
        {

            ExceptionTbl = new Hashtable();

            AddEntry();
        }

        /// <summary>
        /// Generate the Input object array used to veirfy the StringLength Validator
        /// 1.Add  Input object to verify ValidationType.BiggerLenStrMax to the Input array
        /// 2.if string length lowerBound >0, add Input object to verify ValidationType.LessStrLenMin to Input array
        /// 3. If the datamember can not be null, add  Input object to veirfy ValidationType.NullException to the Input array
        /// </summary>
        public static Input[] AddStringLenthValidatorInput(string key1, string key2, int lowerBound, int upperBound, bool notNull, bool noBoundary)
        {
            List<Input> inputList = new List<Input>();
            //greater than max length exception
            inputList.Add(new Input(RandomEx.GlobalRandGen.GenerateRandomString(upperBound + 1), ValidationType.BiggerLenStrMax, key1, key2, lowerBound, upperBound, notNull));
            inputList.Add(new Input(RandomEx.GlobalRandGen.GenerateRandomString(upperBound), ValidationType.StrLenMax, key1, key2, lowerBound, upperBound));

            if (lowerBound > 0 /*&& notNull*/)
            { //LessStrLenMin  exception
                inputList.Add(new Input(RandomEx.GlobalRandGen.GenerateRandomString(lowerBound - 1), ValidationType.LessStrLenMin, key1, key2, lowerBound, upperBound, notNull));
            };

            inputList.Add(new Input(lowerBound == 0 ? "" : RandomEx.GlobalRandGen.GenerateRandomString(lowerBound), ValidationType.StrLenMin, key1, key2, lowerBound, upperBound));

            //if the datamember can not be null          
            if (notNull)
            {
                if (noBoundary)
                {
                    inputList.Add(new Input(null, ValidationType.NullException,
                         string.Format(TemplateMessages.NullObjectString, key2, key1)));
                }
                else
                    inputList.Add(new Input(null, ValidationType.NullExceptionAlsoBoundary, key1, key2, lowerBound, upperBound));
            }

            return inputList.ToArray();

        }

        public static Input[] AddStringLenthValidatorInput(string key1, string key2, int lowerBound, int upperBound, bool notNull)
        {
            return AddStringLenthValidatorInput(key1, key2, lowerBound, upperBound, notNull, true);
        }

        public virtual void AddEntry()
        {

        }

        public virtual string UpdateDataMember(Object p, string key, ValidationType vType)
        {
            return null;
        }

        public virtual Object GetDefaultObject()
        {
            return null;
        }

        ///<summary>
        /// retrieve Input object for the specified validation type and key.
        /// </summary>
        public Input GetInput(string key, ValidationType vType)
        {
            Input[] inputs = (Input[])ExceptionTbl[key];
            foreach (Input input in inputs)
            {
                if (input.ValidationType == vType)
                {
                    input.Verified = true;
                    return input;
                }
            }
            return null;
        }
    }

    ///<summary>
    /// Class to help retrieving certain value and crosponding error message from hash table 
    /// </summary>
    public class SetValueHelper<T>
    {
        public static T GetValue(ValidatorExceptionTable tbl, string key, ValidationType vType)
        {
            Input input = tbl.GetInput(key, vType);

            if (input.Value == null) return default(T);
            return (T)input.Value;
        }

        public static string GetErrorMessage(ValidatorExceptionTable tbl, string key, ValidationType vType)
        {
            Input input = tbl.GetInput(key, vType);
            return input.ErrMessage;
        }
    }

    ///<summary>
    /// Base class to generate tests from the hash table which stores the validator infomation. 
    /// </summary>
    public class ValidateTestBase : TestNode
    {
        string key;
        ValidationType vType;
        Object defaultObject;
        ValidatorExceptionTable vExceptionTbl;
        public ValidateTestBase(string key, ValidationType vType, ValidatorExceptionTable vExceptionTbl, int index)
        {
            this.key = key;
            this.vType = vType;
            defaultObject = vExceptionTbl.GetDefaultObject();
            Name = key + "_" + vType + "_" + index.ToString();
            this.vExceptionTbl = vExceptionTbl;
        }

        public ValidateTestBase(string key, ValidationType vType, ValidatorExceptionTable vExceptionTbl) :
            this(key, vType, vExceptionTbl, 0)
        {

        }

        public override void Run()
        {
            string expectedMessage = vExceptionTbl.UpdateDataMember(defaultObject, key, vType);


            Exception e = null;

            if (defaultObject is Product)
            {
                ProductManagementWCFClient client = new ProductManagementWCFClient();
                client.ConfigureProduct((Product)defaultObject, out e);
            }
            else if (defaultObject is Offer)
            {
                OfferManagementWCFClient client1 = new OfferManagementWCFClient();
                client1.ConfigureOffer((Offer)defaultObject, out e);
            }
            else throw new UnexpectedTestResultException("this object type can not be handled");

            if (e == null) throw new UnexpectedTestResultException("Expects  exception but API call returns successfully");

            FaultException<ValidationFault> validationFault = e as FaultException<ValidationFault>;


            if (validationFault != null)
            {
                if (vType != ValidationType.NullException)
                {
                    ValueCheck.Test("number of validation error", 1, validationFault.Detail.Details.Length);
                    ValueCheck.IsTrue(validationFault.Detail.Details[0].Message.Contains(expectedMessage), "Expected error message is\r\n: " + expectedMessage);
                }
                else
                {
                    foreach (ValidationDetail detail in validationFault.Detail.Details)
                    {
                        if (detail.Message.Contains(expectedMessage))
                            return;
                    }
                    throw new UnexpectedTestResultException("Expected err message is: " + expectedMessage);
                }
            }
            else
            {
                if (e is FaultException<MixClientFault>)
                {
                    ValueCheck.IsTrue(e.Message.Contains(expectedMessage), "Expected error message is\r\n: " + expectedMessage);
                }
                else
                {
                    throw new UnexpectedTestResultException("Unexpected error was encountered: {0}" + e.Message);
                }
            }
        }

        static public bool DiffErrorMessage(List<string> errorList, ValidationDetail[] details)
        {
            bool found = false;
            bool diff = false;
            for (int i = 0; i < errorList.Count; i++)
            {
                found = false;
                foreach (ValidationDetail detail in details)
                {
                    if (detail.Message.Contains(errorList[i]))
                    {
                        found = true;
                        break;
                    };
                }
                if (!found)
                {
                    Global.RO.Error("not find in one list in returned error meesage\r\n:" + errorList[i]);
                    diff = true;
                }
            }



            foreach (ValidationDetail detail in details)
            {
                found = false;
                foreach (string s in errorList)
                {
                    if (detail.Message.Contains(s))
                    {
                        found = true;
                        break;
                    };
                }
                if (!found)
                {
                    Global.RO.Error("-------not find in the other list" + detail.Message);
                    diff = true;
                }
            }

            return diff;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\BetaManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.betamanagement.contracts.V1;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{
    /// <summary>
    /// The Beta Management WCF client.
    /// This is the one location that contains all API calls for the Stats component.
    /// </summary>
    public class BetaManagementWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixbetamanagement/mixbetamanagementV1.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixBetaManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixBetaManagementClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixbetamanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixBetaManagementClient client = new MixBetaManagementClient(wsb, epa);
            return client;
        }

        #region APIs


        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseVersion"></param>
        /// <param name="currentFlashVersion"></param>
        /// <param name="systemOnlineManifest"></param>
        /// <param name="SystemManifest"></param>
        /// <param name="group"></param>
        /// <param name="titleID"></param>
        /// <param name="addUpgradePaths"></param>
        public void AssignReleaseToGroup(uint baseVersion, uint currentFlashVersion, string systemOnlineManifest, string SystemManifest, Guid group, uint titleID, bool addUpgradePaths)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AssignReleaseToGroup", baseVersion, currentFlashVersion, systemOnlineManifest, SystemManifest, group, titleID, addUpgradePaths);
            VerifyHR(hr, ex);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="version"></param>
        /// <returns></returns>
        public bool IsTitleVersionPropped(uint titleID, uint version)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            bool result = Invoke<bool>(CreateNewClient(), out hr, out retryable, out ex, "IsTitleVersionPropped", titleID, version);
            VerifyHR(hr, ex);

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public GroupSummary[] GetGroups()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            GroupSummary[] result = Invoke<GroupSummary[]>(CreateNewClient(), out hr, out retryable, out ex, "GetGroups");
            VerifyHR(hr, ex);

            return result;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Group GetGroupDetails(Guid group)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Group result = Invoke<Group>(CreateNewClient(), out hr, out retryable, out ex, "GetGroupDetails", group);
            VerifyHR(hr, ex);

            return result;
        }
        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\OfferManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.offermanagement.contracts.V1;
using System.ServiceModel.Channels;

namespace MIXTesting
{
    /// <summary>
    /// The OfferManagement WCF client. 
    /// This is the one location that contains all API calls for OfferManagement component.
    /// </summary>
    public class OfferManagementWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixoffermanagement/mixoffermanagementV1.svc";

        MixOfferManagementClient client;

        public OfferManagementWCFClient()
        {
            client = CreateNewClient();
        }

        public OfferManagementWCFClient(string wcfAddress)
        {
            client = CreateNewClient(wcfAddress);
        }

        /// <summary>
        /// Create a new MixOfferManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixOfferManagementClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixoffermanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            Global.RO.Info("Url: " + uri);
            EndpointAddress epa = new EndpointAddress(uri);
            MixOfferManagementClient client = new MixOfferManagementClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// Create a new MixOfferManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixOfferManagementClient CreateNewClient(string wcfAddress)
        {
            string uri = "http://" + wcfAddress + Url;
            Global.RO.Info("Url: " + uri);
            EndpointAddress epa = new EndpointAddress(uri);
            MixOfferManagementClient client = new MixOfferManagementClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureOffer. This is for normal use or positive tests.
        /// </summary>
        /// <param name="offer"></param>
        public void ConfigureOffer(Offer offer)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(client, out hr, out retryable, out ex, "ConfigureOffer", offer);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("ConfigureOffer call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        /// <summary>
        /// API ConfigureOffer. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR, a Retryable flag and the exception itself are returned as out parameters.
        /// No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public void ConfigureOffer(Offer offer, out Exception ex)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Invoke<NoReturn>(client, out hr, out retryable, out ex, "ConfigureOffer", offer);
        }

        /// <summary>
        /// API GetOffer. This is for normal use or positive tests.
        /// </summary>
        /// <param name="offerId"></param>
        public Offer GetOffer(Guid offerId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Offer offer = Invoke<Offer>(client, out hr, out retryable, out ex, "GetOffer", offerId);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetOffer call failed with HR = 0x" + hr.ToString("X"), ex);
            }
            return offer;
        }

        /// <summary>
        /// API GetOffer. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR, a Retryable flag and the exception itself are returned as out parameters.
        /// No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public Offer GetOffer(Guid offerId, out Exception ex)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            return Invoke<Offer>(client, out hr, out retryable, out ex, "GetOffer", offerId);
        }

        /// <summary>
        /// API GetSignedHeader.
        /// </summary>
        public byte[] GetSignedHeader (uint fileSize, uint fileType, byte[] fileHash)
        {
            uint hr = HResult.S_OK;
            Exception ex = null;

            byte[] ans = GetSignedHeader(fileSize, fileType, fileHash, out hr, out ex);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetOffer call failed with HR = 0x" + hr.ToString("X"), ex);
            }

            return ans;
        }

        /// <summary>
        /// API GetSignedHeader.
        /// </summary>
        public byte[] GetSignedHeader (uint fileSize, uint fileType, byte[] fileHash, out uint hr, out Exception ex)
        {
            bool retryable = false;
            return Invoke<byte[]>(client, out hr, out retryable, out ex, "GetSignedHeader", fileSize, fileType, fileHash);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\ProductManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.productmanagement.contracts.V1;

using   System.ServiceModel.Channels;


namespace MIXTesting
{
    /// <summary>
    /// The ProductManagement WCF client. 
    /// This is the one location that contains all API calls for ProductManagement component.
    /// </summary>
    public class ProductManagementWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixproductmanagement/MixProductManagementV1.svc";

        public MixProductManagementClient client;

        /// <summary>
        /// Create a new MixProductManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected  MixProductManagementClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixproductmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            Global.RO.Info("Url: " + uri);
            EndpointAddress epa = new EndpointAddress(uri);

            client = new MixProductManagementClient(wsb, epa);

            return client;
        }

        /// <summary>
        /// Create a new MixProductManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixProductManagementClient CreateNewClient(string wcfAddress)
        {
            string uri = "http://" + wcfAddress + Url;
            Global.RO.Info("Url: " + uri);
            EndpointAddress epa = new EndpointAddress(uri);

            client = new MixProductManagementClient(wsb, epa);

            return client;
        }

        public  ProductManagementWCFClient()
        {
            client = CreateNewClient();
        }

        public ProductManagementWCFClient(string wcfAddress)
        {
            client = CreateNewClient(wcfAddress);
        }

        /// <summary>
        /// API ConfigureProduct. This is for normal use or positive tests.
        /// </summary>
        /// <param name="product"></param>
        public  void ConfigureProduct(Product product)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;



            Invoke<NoReturn>(client, out hr, out retryable, out ex, "ConfigureProduct", product);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("ConfigureProduct call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        /// <summary>
        /// API ConfigureProduct. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, the exception itself is returned as out parameter.
        /// No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public  void ConfigureProduct(Product product, out Exception ex)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Invoke<NoReturn>(client, out hr, out retryable, out ex, "ConfigureProduct", product);
        }

        /// <summary>
        /// API GetProduct. This is for normal use or positive tests.
        /// </summary>
        public  Product GetProduct(Guid id)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Product product = Invoke<Product>(client, out hr, out retryable, out ex, "GetProduct", id);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetProduct call failed with HR = 0x" + hr.ToString("X"), ex);
            }
            return product;
        }

        /// <summary>
        /// API GetProduct. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, the exception itself is returned as out parameter.
        /// No exception is thrown here. Test cases normally need to verify the HR and Retryable are as expected.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public  Product GetProduct(Guid id, out Exception ex)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            return Invoke<Product>(client, out hr, out retryable, out ex, "GetProduct", id);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\MatchWCFClient.cs ===
using System;
using System.Data.SqlClient;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.match.contracts.V1;
using System.ServiceModel.Channels;

namespace MIXTesting
{
    /// <summary>
    /// The Match WCF client. 
    /// This is the one location that contains all API calls for Match component.
    /// </summary>
    public class MatchWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixmatch/mixmatchV1.svc";

        private XMatch xmatch = new XMatch(); // Used for verification

        public MatchWCFClient()
        {
            xmatch.ConnectToServer(Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.xmatch));
        }

        /// <summary>
        /// Create a new MixMatchClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixMatchClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixmatch);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixMatchClient client = new MixMatchClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureTitle
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="removeMode"></param>
        /// <param name="dropTable"></param>
        /// <param name="noReload"></param>
        /// <param name="overrideBuckets"></param>
        public bool ConfigureMatchmaking(uint titleId, bool removeMode, bool dropTable, bool noReload, bool overrideBuckets)
        {
            return ConfigureMatchmaking(titleId, removeMode, dropTable, noReload, overrideBuckets, ConfigureMatchResult.Success);
        }

        /// <summary>
        /// API Deploy. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="removeMode"></param>
        /// <param name="dropTable"></param>
        /// <param name="noReload"></param>
        /// <param name="overrideBuckets"></param>
        /// <param name="expectedResult"></param>
        public bool ConfigureMatchmaking(uint titleId, bool removeMode, bool dropTable, bool noReload, bool overrideBuckets, ConfigureMatchResult expectedResult)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            ConfigureMatchResult result = Invoke<ConfigureMatchResult>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureMatchmaking", titleId, removeMode, dropTable, noReload, overrideBuckets);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("Match ConfigureMatchmaking call failed with HR = 0x" + hr.ToString("X"), ex);
            }
            else if (result != expectedResult)
            {
                throw new UnexpectedTestResultException("Match ConfigureMatchmaking call failed with result " + result + " when " + expectedResult + " was expected.", ex);
            }

            return true;
        }



        /////////////////////////////////////////////////
        // HELPERS below
        /////////////////////////////////////////////////


        /// <summary>
        /// Clears all match tables, sprocs, and empties t_interface_buckets from the db
        /// </summary>
        /// <param name="titleId"></param>
        public void ClearDB(uint titleId)
        {
            XMatch matchDb = new XMatch();
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.xmatch);
            if (servers[0].Trim() != "")
            {
                foreach (string server in servers)
                {
                    matchDb.ConnectToServer(server);
                    matchDb.ClearMatchConfiguration(titleId);
                    matchDb.Close();
                }
            }

            // Remove entries from t_interface_buckets
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            npdb.IssueCommand("delete from t_interface_buckets where vc_interface = 'xmatch' and i_title_id = " + (int)titleId);
            npdb.Close();
        }

        /// <summary>
        /// Verifies all tables and sprocs
        /// </summary>
        /// <param name="titleId"></param>
        /// <returns></returns>
        public bool Verify(uint titleId)
        {
            return Verify(titleId, false, 0);
        }

        public bool Verify(uint titleId, bool verifyBuckets, uint expectedBuckets)
        {
            bool verified = true;
            string matchServers = GetMatchServers(titleId);

            string[] servers = matchServers.Split(",;".ToCharArray());
            if (servers[0].Trim() != "")
            {
                foreach (string server in servers)
                {
                    xmatch.Close();
                    xmatch.ConnectToServer(server);

                    verified = verified && VerifyTables(server, titleId) && VerifyProcs(server, titleId);
                }
            }

            if (verifyBuckets)
            {
                // Verify the correct number of buckets in t_interface_buckets
                verified = verified && VerifyBuckets(titleId, expectedBuckets);
            }

            return verified;
        }

        /// <summary>
        /// Gets the list of Match Servers for the titleid from the t_interface_buckets vc_server column.
        /// </summary>
        protected string GetMatchServers(uint matchTitleID)
        {
            string matchServers = "";
            Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            InterfaceBucketCollection buckets = npdb.GetInterfaceBuckets(matchTitleID, Global.CurrentEnvironment.Environment);
            npdb.Close();

            // Loop through the buckets for the titleid and find all the xmatch servers used.
            foreach (InterfaceBucket bucket in buckets)
            {
                if ((!matchServers.Contains(bucket.Server.ToLower())) && (bucket.Interface == "xmatch"))
                    matchServers += bucket.Server.ToLower() + ";";
            }

            // Trim off the last ; or otherwise it will try to find a blank server later.
            matchServers = matchServers.TrimEnd(';');

            npdb = null;

            return matchServers;
        }

        /// <summary>
        /// Verifies the tables were created
        /// </summary>
        /// <returns>If the tables were created</returns>
        protected bool VerifyTables(string server, uint titleId)
        {
            bool verified = false;
            string table1, table2;
            string[] tables;

            string tableNames = xmatch.GetMatchTables(titleId);

            // Check to see if we have any tables...
            if (tableNames != "")
            {
                Global.RO.Info("VerifyTables: Found Match Tables on " + server + ": " + tableNames);
                // Have tables, now check them...
                tables = tableNames.Split(',');
                if (tables.Length != 2)
                {
                    Global.RO.Warn("VerifyTables: Not 2 tables on " + server);
                }

                // Right now will just check to see if the tables were created the same...
                table1 = xmatch.GetTableColumns(tables[0]);
                table2 = xmatch.GetTableColumns(tables[1]);

                verified = (table1 == table2);
            }
            else
            {
                Global.RO.Warn("VerifyTables: Could not find match tables on " + server);
            }
            return verified;
        }

        /// <summary>
        /// Verifies that Match stored procs were created for Title
        /// </summary>
        /// <returns></returns>not
        protected bool VerifyProcs(string server, uint titleId)
        {
            bool verified = false;
            string procNames = xmatch.GetStoredProcs(titleId);

            if (procNames != "")
            {
                Global.RO.Info("VerifyProcs: Found Match Procs on " + server + ": " + procNames);

                XmlDocument xmlDoc = new XmlDocument();

                // Get # of queries from XLAST that is in NPBD
                NpdbUtility npdb = new ServerTestFramework.Database.NpdbUtility();
                npdb.ConnectToServer();
                GameConfigRow gameConfig = null;
                npdb.GetGameConfig(titleId, out gameConfig);
                ServerTestFramework.STFTools.ConfigFiles.XboxGameConfig xlast = new ServerTestFramework.STFTools.ConfigFiles.XboxGameConfig();
                xmlDoc.LoadXml(gameConfig.XmlConfig);
                npdb = null;

                XmlNamespaceManager nsmgr = new XmlNamespaceManager(xmlDoc.NameTable);
                nsmgr.AddNamespace("xl", "http://www.xboxlive.com/xlast");

                int queries = xmlDoc.SelectNodes("//xl:Query", nsmgr).Count;
                xmlDoc = null;

                // see http://xblwiki/default.aspx/XboxLive/LiveMatch.html for why this works
                // Fall Release 2006 - p_match_session_<titleid>_search_findbyid_list added
                // Fall Release 2007 - p_match_session_<version>_<titleid>_updatecomplete, p_match_session_<version>_<titleid>_lock_and_read
                //                     p_match_session_<version>_<titleid>_release_lock added.
                int numProcs = (queries * 5) + 10;
                if (procNames.Split(',').Length == numProcs)
                {
                    verified = true;
                }
                else
                {
                    Global.RO.Warn("VerifyProcs: Number of Procs different on " + server + ":" + procNames.Split(',').Length.ToString() + " != " + numProcs.ToString());
                    verified = false;
                }

            }
            else
            {
                Global.RO.Warn("VerifyProcs: No Stored Procs found on " + server);
            }
            return verified;
        }

        protected bool VerifyBuckets(uint titleId, uint expectedBuckets)
        {
            string bucketQuery = "select COUNT(i_bucket) from t_interface_buckets where vc_interface = 'xmatch' and i_title_id = " + (int)titleId;

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(bucketQuery, out reader);

                if (!reader.Read())
                {
                    Global.RO.Error("t_interface_buckets returned no buckets.");
                    return false;
                }

                if ((int)reader[0] != expectedBuckets)
                {
                    Global.RO.Error("t_interface_buckets returned " + (int)reader[0] + " buckets when " + expectedBuckets + " were expected.");
                    return false;
                }

                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SettingsManagementV2WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V2;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{

    //
    public class SettingsManagementV2WCFClient: WCFClientBase
    {
        public readonly static string Url = "/mixsettingsmanagement/mixsettingsmanagementV2.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixClientSettingsManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixSettingsManagementV2Client CreateNewClient ()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsettingsmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixSettingsManagementV2Client client = new MixSettingsManagementV2Client(wsb, epa);
            return client;
        }

        #region APIs

        public LiveHiveSetting[] GetSettings (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup)
        {
            return GetSettings(new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup });
        }

        public LiveHiveSetting[] GetSettings (LiveHiveConfig config)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            LiveHiveSetting[] result = Invoke<LiveHiveSetting[]>(CreateNewClient(), out hr, out retryable, out ex, "GetSettings", config);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetSetting (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup, string name, string value)
        {
            SetSetting(
                new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup },
                new LiveHiveSetting() { Name = name, Value = value }
                );
        }

        public void SetSetting (LiveHiveConfig config, LiveHiveSetting setting)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetSetting", config, setting);
            VerifyHR(hr, ex);
        }

        public string IngestEtxManifest (string xmlManifest)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            string result = Invoke<string>(CreateNewClient(), out hr, out retryable, out ex, "IngestEtxManifest", xmlManifest);
            VerifyHR(hr, ex);

            return result;
        }

        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SettingsManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V1;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{

    //
    public class SettingsManagementWCFClient: WCFClientBase
    {
        public readonly static string Url = "/mixsettingsmanagement/mixsettingsmanagementV1.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixClientSettingsManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixSettingsManagementClient CreateNewClient ()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsettingsmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixSettingsManagementClient client = new MixSettingsManagementClient(wsb, epa);
            return client;
        }

        #region APIs

        public LiveHiveSetting[] GetSettings (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup)
        {
            return GetSettings(new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup });
        }

        public LiveHiveSetting[] GetSettings (LiveHiveConfig config)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            LiveHiveSetting[] result = Invoke<LiveHiveSetting[]>(CreateNewClient(), out hr, out retryable, out ex, "GetSettings", config);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetSetting (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup, string name, string value)
        {
            SetSetting(
                new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup },
                new LiveHiveSetting() { Name = name, Value = value }
                );
        }

        public void SetSetting (LiveHiveConfig config, LiveHiveSetting setting)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<LiveHiveSetting[]>(CreateNewClient(), out hr, out retryable, out ex, "SetSetting", config, setting);
            VerifyHR(hr, ex);
        }

        #endregion

        #region Utils

        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR==HResult.S_OK && (hr!=HResult.S_OK || ex!=null))
            {
                throw new UnexpectedTestResultException("Call failed with HR="+Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR!=hr)
            {
                throw new UnexpectedTestResultException("Expected HR="+Global.XErrToString(ExpectedHR)+", got HR="+Global.XErrToString(hr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SettingsManagementV4WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V4;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{   //
    public class SettingsManagementV4WCFClient: WCFClientBase
    {
        public readonly static string Url = "/mixsettingsmanagement/mixsettingsmanagementV4.svc";

        /// <summary>
        /// Create a new MixClientSettingsManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixSettingsManagementV4Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsettingsmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixSettingsManagementV4Client client = new MixSettingsManagementV4Client(wsb, epa);
            return client;
        }

        #region APIs

        public LiveHiveSetting[] GetSettings (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup)
        {
            return GetSettings(new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup });
        }

        public LiveHiveSetting[] GetSettings (LiveHiveConfig config)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            LiveHiveSetting[] result = Invoke<LiveHiveSetting[]>(CreateNewClient(), out hr, out retryable, out ex, "GetSettings", config);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetSetting (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup, string name, string value)
        {
            SetSetting(
                new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup },
                new LiveHiveSetting() { Name = name, Value = value }
                );
        }

        public void SetSetting (LiveHiveConfig config, LiveHiveSetting setting)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetSetting", config, setting);
            VerifyHR(hr, ex);
        }

        public string IngestEtxManifest (string xmlManifest)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            string result = Invoke<string>(CreateNewClient(), out hr, out retryable, out ex, "IngestEtxManifest", xmlManifest);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetBusinessPartner(BusinessPartner businessPartner)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetBusinessPartner", businessPartner);
            VerifyHR(hr, ex);
        }
        
        public void SetBusinessPartnerType(BusinessPartner businessPartner)
        {            
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetBusinessPartner", businessPartner);
            VerifyHR(hr, ex);
        }

        public void SetAppliesToInfo(STSAppliesTo appliesTo)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetAppliesToInfo", appliesTo);
            VerifyHR(hr, ex);
        }

        public void RemoveAppliesToInfo(String appliesToUri)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveAppliesToInfo", appliesToUri);
            VerifyHR(hr, ex);
        }

        public STSAppliesTo GetAppliesToInfo(String appliesToUri)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            STSAppliesTo appliesTo = Invoke<STSAppliesTo>(CreateNewClient(), out hr, out retryable, out ex, "GetAppliesToInfo", appliesToUri);
            VerifyHR(hr, ex);

            return appliesTo;
        }

        public STSClaimTypeInfo[] GetClaimTypes(string businessPartnerType)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            STSClaimTypeInfo[] claimTypes = Invoke<STSClaimTypeInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetClaimTypes", businessPartnerType);
            VerifyHR(hr, ex);

            return claimTypes;
        }

        public String[] GetTokenTypes()
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            String[] tokenTypes = Invoke<String[]>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenTypes");
            VerifyHR(hr, ex);

            return tokenTypes;
        }

        public String[] GetBusinessPartnerTypes()
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            String[] businessPartnerTypes = Invoke<String[]>(CreateNewClient(), out hr, out retryable, out ex, "GetBusinessPartnerTypes");
            VerifyHR(hr, ex);

            return businessPartnerTypes;
        }
        #endregion

        #region Utils

        private void VerifyHR(uint actualHr, Exception ex)
        {
            VerifyHR(HResult.S_OK, actualHr, ex);
        }

        private void VerifyHR(uint expectedHr, uint actualHr, System.Exception ex)
        {
            if (expectedHr == HResult.S_OK && (actualHr != HResult.S_OK || ex != null))
            {
                throw new UnexpectedTestResultException("Call failed with HR=" + Global.XErrToString(actualHr), ex);
            }
            else if (expectedHr != actualHr)
            {
                throw new UnexpectedTestResultException("Expected HR=" + Global.XErrToString(expectedHr) + ", got HR=" + Global.XErrToString(actualHr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SettingsManagementV3WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V3;
using Microsoft.Webstore.WstClient;

namespace MIXTesting
{

    //
    public class SettingsManagementV3WCFClient: WCFClientBase
    {
        public readonly static string Url = "/mixsettingsmanagement/mixsettingsmanagementV3.svc";

        /// <summary>
        /// Create a new MixClientSettingsManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixSettingsManagementV3Client CreateNewClient ()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsettingsmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixSettingsManagementV3Client client = new MixSettingsManagementV3Client(wsb, epa);
            return client;
        }

        #region APIs

        public LiveHiveSetting[] GetSettings (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup)
        {
            return GetSettings(new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup });
        }

        public LiveHiveSetting[] GetSettings (LiveHiveConfig config)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            LiveHiveSetting[] result = Invoke<LiveHiveSetting[]>(CreateNewClient(), out hr, out retryable, out ex, "GetSettings", config);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetSetting (PlatformType platform, ushort? build, ushort? qfe, Guid betaGroup, string name, string value)
        {
            SetSetting(
                new LiveHiveConfig() { PlatformType = platform, Build = build, Qfe = qfe, BetaGroupId = betaGroup },
                new LiveHiveSetting() { Name = name, Value = value }
                );
        }

        public void SetSetting (LiveHiveConfig config, LiveHiveSetting setting)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetSetting", config, setting);
            VerifyHR(hr, ex);
        }

        public string IngestEtxManifest (string xmlManifest)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            string result = Invoke<string>(CreateNewClient(), out hr, out retryable, out ex, "IngestEtxManifest", xmlManifest);
            VerifyHR(hr, ex);

            return result;
        }

        public void SetBusinessPartner(BusinessPartner businessPartner)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetBusinessPartner", businessPartner);
            VerifyHR(hr, ex);
        }

        public void SetAppliesToInfo(STSAppliesTo appliesTo)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetAppliesToInfo", appliesTo);
            VerifyHR(hr, ex);
        }

        public void RemoveAppliesToInfo(String appliesToUri)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveAppliesToInfo", appliesToUri);
            VerifyHR(hr, ex);
        }

        public STSAppliesTo GetAppliesToInfo(String appliesToUri)
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            STSAppliesTo appliesTo = Invoke<STSAppliesTo>(CreateNewClient(), out hr, out retryable, out ex, "GetAppliesToInfo", appliesToUri);
            VerifyHR(hr, ex);

            return appliesTo;
        }

        public STSClaimTypeInfo[] GetClaimTypes()
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            STSClaimTypeInfo[] claimTypes = Invoke<STSClaimTypeInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetClaimTypes");
            VerifyHR(hr, ex);

            return claimTypes;
        }

        public String[] GetTokenTypes()
        {
            uint hr;
            bool retryable = false;
            Exception ex = null;
            String[] tokenTypes = Invoke<String[]>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenTypes");
            VerifyHR(hr, ex);

            return tokenTypes;
        }

        #endregion

        #region Utils

        private void VerifyHR(uint actualHr, Exception ex)
        {
            VerifyHR(HResult.S_OK, actualHr, ex);
        }

        private void VerifyHR(uint expectedHr, uint actualHr, System.Exception ex)
        {
            if (expectedHr == HResult.S_OK && (actualHr != HResult.S_OK || ex != null))
            {
                throw new UnexpectedTestResultException("Call failed with HR=" + Global.XErrToString(actualHr), ex);
            }
            else if (expectedHr != actualHr)
            {
                throw new UnexpectedTestResultException("Expected HR=" + Global.XErrToString(expectedHr) + ", got HR=" + Global.XErrToString(actualHr), ex);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\StatsVerifier.cs ===
using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveStatsTest
{
    /// <summary>
	/// Base class for the leaderboard verification classes. This class should not be used directly.
	/// </summary>
	public class StatsVerifier
	{
        protected static Report report = new Report("StatsVerifier");

        protected StatsVerifier() {}

        public static TEST_RESULTS VerifyLTCLeaderboardAssignments(string lbServer, LiveTitleConfig ltc, LeaderboardConfigCollection existingAssignments)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            if (ltc == null)
            {
                report.Error("The LiveTitleConfig object passed to VerifyLTCLeaderboardAssignments can't be NULL.");
                return TEST_RESULTS.FAILED;
            }

            if (existingAssignments != null && existingAssignments.Count > 0)
            {
                // Verify an existing LTC by making sure that all existing assignments are the same
                // and that any new leaderboard assignments match the server name.

                bool found;
                foreach (LeaderboardConfig actLb in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    found = false;
                    foreach (LeaderboardConfig expLb in existingAssignments)
                    {
                        if (actLb.LeaderboardID == expLb.LeaderboardID &&
                            actLb.IsCompetition == expLb.IsCompetition)
                        {
                            found = true;
                            if (actLb.HostingLbs != expLb.HostingLbs)
                            {
                                ReportVerificationFailure(expLb.HostingLbs, actLb.HostingLbs,
                                    "The server name for the existing leaderboard {0}{1} doesn't match.",
                                    actLb.LeaderboardID, (actLb.IsCompetition ? " (Competition Template)" : ""));
                                result = TEST_RESULTS.FAILED;
                            }
                            break;
                        }
                    }

                    if (!found)
                    {
                        if (String.Compare(lbServer, actLb.HostingLbs, true) != 0)
                        {
                            ReportVerificationFailure(lbServer, actLb.HostingLbs,
                                "Leaderboard server mismatch in LTC file for leaderboard {0}{1}.",
                                actLb.LeaderboardID, (actLb.IsCompetition ? " (Competition Template)" : ""));
                            result = TEST_RESULTS.FAILED;
                        }
                    }
                }
            }
            else
            {
                // Verify a new LTC
                foreach (LeaderboardConfig lb in ltc.LeaderboardConfigs.LeaderboardConfigCollection)
                {
                    if (String.Compare(lb.HostingLbs, lbServer, true) != 0)
                    {
                        ReportVerificationFailure(lbServer, lb.HostingLbs,
                            "Leaderboard server mismatch in LTC file for leaderboard {0}{1}.",
                            lb.LeaderboardID, (lb.IsCompetition ? " (Competition Template)" : ""));
                        result = TEST_RESULTS.FAILED;
                    }
                }
            }

            return result;
        }

        public static void ReportVerificationFailure(object expVal, object actVal, string message, params object[] args)
        {
            report.Error("Verification failure! {0}\r\n  Expected: |{1}|\r\n  Actual:   |{2}|",
                string.Format(message, args), expVal == null ? "null" : expVal.ToString(),
                actVal == null ? "null" : actVal.ToString());
        }
    }


    /// <summary>
    /// Verification class for Xbox 360 leaderboards.
    /// </summary>
    public class Xbox360StatsVerifier : StatsVerifier
    {
        protected Xbox360StatsVerifier() {}

        /// <summary>
        /// Verifies the User-Defined and TrueSkill leaderboards in a given XLAST file with what's in the service.
        /// </summary>
        /// <param name="xlast">The XLAST file containing the leaderboard definitions.</param>
        /// <param name="actData">The actual data from the Live Service.</param>
        /// <returns>
        /// If the verifications succeeded, TEST_RESULTS.PASSED is returned.
        /// If a verification fails, TEST_RESULTS.FAILED is returned.
        /// </returns>
        public static TEST_RESULTS VerifyLeaderboards(XboxLiveSubmissionProject xlast, Xbox360Stats actData)
        {
            Hashtable expLbs = SVLeaderboard.GetLeaderboardsFromXlast(xlast);
            TEST_RESULTS result = TEST_RESULTS.PASSED, tmpResult;

            // First make sure that the number of leaderboards match between NPDB, WEbDB, and the XLAST file
            if (actData.Leaderboards.Count != expLbs.Count ||
                actData.WebLeaderboards.Count != expLbs.Count)
            {
                report.Error("The number of leaderboards doesn't match:\r\n" +
                              "    Expected (XLAST): {0}\r\n" +
                              "    Actual (NPDB)   : {1}\r\n" +
                              "    Actual (WebDB)  : {2}",
                    expLbs.Count, actData.Leaderboards.Count, actData.WebLeaderboards.Count);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the leaderboard configuration data in NPDB
            foreach (ServerTestFramework.Database.Leaderboard actLb in actData.Leaderboards)
            {
                SVLeaderboard expLb = expLbs[(uint)actLb.LeaderboardId] as SVLeaderboard;
                if (expLb == null)
                {
                    report.Error("Leaderboard {0} is defined in NPDB, but not in the XLAST file.",
                        actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                    continue;
                }

                tmpResult = VerifyNPDBLeaderboard(expLb, actLb);
                result = result == TEST_RESULTS.PASSED ? tmpResult : result;
            }

            // Verify the data in the WebDB
            foreach (WebdbLeaderboard actLb in actData.WebLeaderboards)
            {
                SVLeaderboard expLb = expLbs[(uint)actLb.LeaderboardId] as SVLeaderboard;
                if (expLb == null)
                {
                    report.Error("Leaderboard {0} is defined in WebDB, but not in the XLAST file.",
                        actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                    continue;
                }

                tmpResult = VerifyWebDbLeaderboard(expLb, actLb);
                result = result == TEST_RESULTS.PASSED ? tmpResult : result;
            }

            return result;
        }

        public static TEST_RESULTS VerifyLeaderboardLocation(LiveTitleConfig expVal, Xbox360Stats actVal)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool found;

            foreach (LeaderboardConfig lbc in expVal.LeaderboardConfigs.LeaderboardConfigCollection)
            {
                found = false;
                foreach (InterfaceBucket ib in actVal.InterfaceBuckets)
                {
                    // The bucket value is the leaderboard ID
                    if (lbc.LeaderboardID == ib.Bucket)
                    {
                        found = true;
                        if (lbc.HostingLbs != ib.Server)
                        {
                            ReportVerificationFailure(lbc.HostingLbs, ib.Server,
                                "Leaderboard location mismatch.");
                            result = TEST_RESULTS.FAILED;
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find a leaderboard server for leaderboard {0}", lbc.LeaderboardID);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }
        

        #region Private Verification Methods
        private static TEST_RESULTS VerifyNPDBLeaderboard(SVLeaderboard expLb, ServerTestFramework.Database.Leaderboard actLb)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            //report.Info("Verifying NPDB Leaderboard data for leaderboard 0x{0:x}", expLb.LeaderboardId);

            if (actLb.RequiresArbitration != expLb.Arbitrated)
            {
                ReportVerificationFailure(expLb.Arbitrated, actLb.RequiresArbitration,
                    "Arbitration mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.DecayDays != expLb.DecayDays)
            {
                ReportVerificationFailure(expLb.DecayDays, actLb.DecayDays,
                    "Decay Days mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.ResetType != expLb.ResetType)
            {
                ReportVerificationFailure(expLb.ResetType, actLb.ResetType,
                    "Reset Type mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.Top100 != expLb.Top100)
            {
                ReportVerificationFailure(expLb.Top100, actLb.Top100,
                    "Top 100 mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // All of these settings don't apply to Xbox 360 leaderboards,
            // so they must contain the default values
            if (actLb.AttachCount != expLb.MaxAttachments)
            {
                ReportVerificationFailure(0, actLb.AttachCount,
                    "Attach Count mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.MaxAttachSize != 0)
            {
                ReportVerificationFailure(0, actLb.MaxAttachSize,
                    "Max Attach Size mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.IsTeamLb)
            {
                ReportVerificationFailure(0, actLb.IsTeamLb,
                    "Teams flag mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloBase != "10")
            {
                ReportVerificationFailure("10", actLb.EloBase,
                    "ELO Base mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloK != 100)
            {
                ReportVerificationFailure(100, actLb.EloK,
                    "ELO K value mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloNew != 500)
            {
                ReportVerificationFailure(500, actLb.EloNew,
                    "ELO New value mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EloCTable != "0:40")
            {
                ReportVerificationFailure(100, actLb.EloCTable,
                    "ELO Max Weight Rating Range Array mismatch for leaderboard {0}", expLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            return result;
        }

        private static TEST_RESULTS VerifyWebDbLeaderboard(SVLeaderboard expLb, WebdbLeaderboard actLb)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            //report.Info("Verifying WebDB Leaderboard data for leaderboard 0x{0:x}", expLb.LeaderboardId);

            // None of the main leaderboard settings in WebDB apply to Xbox 360 leaderboards,
            // so they must all be the default values.
            if (actLb.ResetType != expLb.ResetType)
            {
                ReportVerificationFailure(expLb.ResetType, actLb.ResetType,
                    "Web leaderboard Reset Type mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.EntriesPerCacheLine != 50)
            {
                ReportVerificationFailure(50, actLb.EntriesPerCacheLine,
                    "Web leaderboard Entries per cache line mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.ExpirationSeconds != 900)
            {
                ReportVerificationFailure(900, actLb.ExpirationSeconds,
                    "web leaderboard Expiration seconds mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.LeaderboardType != 0)
            {
                ReportVerificationFailure(0, actLb.LeaderboardType,
                    "Web Leaderboard type mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            if (actLb.DontList != false)
            {
                ReportVerificationFailure(0, actLb.DontList,
                    "Web leaderboard don't list flag mismatch for leaderboard id {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the localized leaderboard names
            SVLocalizedDescription [] actNames = GetWebdbLeaderboardLocalizedNames(actLb);
            bool found = false;
            if (actNames != null)
            {
                if (expLb.Names.Length != actNames.Length)
                {
                    report.Error("The number of localized names for Web leaderboard {0} is different:\r\n" +
                                  "    Expected (XLAST) : {1}\r\n" +
                                  "    Actual (WebDB)   : {2}",
                        expLb.LeaderboardId, expLb.Names.Length, actNames.Length);
                    result = TEST_RESULTS.FAILED;
                }

                foreach (SVLocalizedDescription expName in expLb.Names)
                {
                    found = false;
                    foreach (SVLocalizedDescription actName in actNames)
                    {
                        if (expName.Locale.Equals(actName.Locale))
                        {
                            found = true;
                            if (expName.Description != actName.Description)
                            {
                                ReportVerificationFailure(expName.Description, actName.Description,
                                    "Web leaderboard name mismatch for locale {0} in leaderboard {1}",
                                    actName.Locale, actLb.LeaderboardId);
                                result = TEST_RESULTS.FAILED;
                            }
                            break;
                        }
                    }

                    if (!found)
                    {
                        report.Error("Unable to find a {0} name string for leaderboard {1} in Webdb",
                            expName.Locale, actLb.LeaderboardId);
                        result = TEST_RESULTS.FAILED;
                    }
                }
            }
            else
            {
                report.Error("No localized names esit in Webdb for leaderboard {0}", actLb.LeaderboardId);
                result = TEST_RESULTS.FAILED;
            }

            // Verify the Raw Attributes
            if (expLb.RawAttributes.Length != actLb.RawAttributes.Count)
            {
                report.Error("The number of raw attributes for Web leaderboard {0} is different:\r\n" +
                              "    Expected (XLAST) : {1}\r\n" +
                              "    Actual (WebDB)   : {2}",
                    expLb.LeaderboardId, expLb.RawAttributes.Length, actLb.RawAttributes.Count);
                result = TEST_RESULTS.FAILED;
            }

            foreach (SVRawAttribute expAttrib in expLb.RawAttributes)
            {
                found = false;
                foreach (WebdbRawAttribute actAttrib in actLb.RawAttributes)
                {
                    if (expAttrib.Id == actAttrib.RawAttributeId)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find raw attribute {0} for leaderboard {1} in Webdb",
                        expAttrib.Id, actLb.LeaderboardId);
                    result = TEST_RESULTS.FAILED;
                }
            }

            // Verify the Formatted Attributes by munging the database data into an array
            // of SVLeaderboardColumn objects so that it's similar to the expected values.
            SVLeaderboardColumn [] actColumns = GetColumnsFromWebdb(actLb);
            TEST_RESULTS tmpResult = VerifyFormattedAttributes(actLb.LeaderboardId, expLb.Columns, actColumns);
            result = result == TEST_RESULTS.PASSED ? tmpResult : result;

            return result;
        }

        private static TEST_RESULTS VerifyFormattedAttributes(int lbId, SVLeaderboardColumn [] expColumns, SVLeaderboardColumn [] actColumns)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            bool found, descFound;

            foreach (SVLeaderboardColumn expCol in expColumns)
            {
                found = false;
                foreach (SVLeaderboardColumn actCol in actColumns)
                {
                    if (expCol.AttributeId == actCol.AttributeId)
                    {
                        found = true;
                        if (expCol.ReturnType != actCol.ReturnType)
                        {
                            ReportVerificationFailure(expCol.ReturnType, actCol.ReturnType,
                                "Return type mismatch for column {0} in leaderboard {1}",
                                expCol.AttributeId, lbId);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expCol.Formula != actCol.Formula)
                        {
                            ReportVerificationFailure(expCol.Formula, actCol.Formula,
                                "Formula mismatch for column {0} in leaderboard {1}",
                                expCol.AttributeId, lbId);
                            result = TEST_RESULTS.FAILED;
                        }

                        // Now for the localized descriptions
                        foreach (SVLocalizedDescription expDesc in expCol.Descriptions)
                        {
                            descFound = false;
                            foreach (SVLocalizedDescription actDesc in actCol.Descriptions)
                            {
                                if (expDesc.Locale == actDesc.Locale)
                                {
                                    descFound = true;
                                    if (expDesc.Description != actDesc.Description)
                                    {
                                        ReportVerificationFailure(expDesc.Description, actDesc.Description,
                                            "The {0} description for the attribute {1} of leaderboard {2} doesn't match.",
                                            expDesc.Locale, expCol.AttributeId, lbId);
                                        result = TEST_RESULTS.FAILED;
                                    }
                                    break;
                                }
                            }

                            if (!descFound)
                            {
                                report.Error("Unable to find a {0} description string for attribute {1} of leaderboard {2}",
                                    expDesc.Locale, expCol.AttributeId, lbId);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find a formatted attribute with the id {0} for leaderboard {1}",
                        expCol.AttributeId, lbId);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        private static SVLocalizedDescription [] GetWebdbLeaderboardLocalizedNames(WebdbLeaderboard webLb)
        {
            SVLocalizedDescription [] names = new SVLocalizedDescription[webLb.Names.Count];
            int i = 0;

            foreach (WebdbLeaderboardName lbName in webLb.Names)
            {
                names[i++] = new SVLocalizedDescription(lbName.Locale, lbName.DisplayName);
            }

            return names;
        }

        private static SVLeaderboardColumn [] GetColumnsFromWebdb(WebdbLeaderboard webLb)
        {
            SVLeaderboardColumn [] attributes = new SVLeaderboardColumn[webLb.FormattedAttributes.Count];
            
            ArrayList descriptions = new ArrayList();
            int i = 0, j = 0;

            foreach (WebdbFormattedAttribute attrib in webLb.FormattedAttributes)
            {
                attributes[i] = new SVLeaderboardColumn(attrib.FriendlyName, uint.Parse(attrib.FriendlyName) , attrib.Formula);
                attributes[i].Descriptions = new SVLocalizedDescription[attrib.Names.Count];
                j = 0;

                // build the list of localized descriptions for this column
                foreach (WebdbFormattedAttributeName desc in attrib.Names)
                {
                    attributes[i].Descriptions[j++] = new SVLocalizedDescription(desc.Locale, desc.DisplayName);
                }
                i++;
            }

            return attributes;
        }
        #endregion

    }

    /// <summary>
    /// Verifier class for Xbox 1 leaderboards.
    /// </summary>
    public class Xbox1StatsVerifier : StatsVerifier
    {
        protected Xbox1StatsVerifier() {}

        public static TEST_RESULTS VerifyAllLeaderboards(XscLeaderboardContainerCollection expLbs, Xbox1Stats stats)
        {
            TEST_RESULTS tmpResult, result = TEST_RESULTS.PASSED;

            foreach (XscLeaderboardContainer container in expLbs)
            {
                if (container.Type != ContainerType.Units)
                {
                    report.Info("Verifying leaderboards in the {0} container...", container.Type);
                    tmpResult = VerifyLeaderboards(container, stats);
                    if (result == TEST_RESULTS.PASSED) result = tmpResult;
                }
                else
                {
                    report.Info("Ignoring Unit leaderboards...");
                }
            }

            return result;
        }

        public static TEST_RESULTS VerifyLeaderboards(XscLeaderboardContainer expLbs, Xbox1Stats stats)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;
            LeaderboardCollection actLbs;
            bool found, isCompTemplate = expLbs.Type == ContainerType.Competitions;

            // The actual leaderboards are either leaderboards or competition templates
            actLbs = (isCompTemplate) ? stats.CompetitionTemplates : stats.Leaderboards;

            foreach (XscLeaderboard expLb in expLbs.Leaderboards)
            {
                found = false;
                foreach (ServerTestFramework.Database.Leaderboard actLb in actLbs)
                {
                    if (expLb.Id == actLb.LeaderboardId)
                    {
                        found = true;
                        if (isCompTemplate != actLb.IsCompetitionTemplate)
                        {
                            ReportVerificationFailure(isCompTemplate, actLb.IsCompetitionTemplate,
                                "Leaderboard {0} should {1}be a competition template!",
                                expLb.Id, isCompTemplate ? "" : "not ");
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.DecayDays != actLb.DecayDays)
                        {
                            ReportVerificationFailure(expLb.DecayDays, actLb.DecayDays,
                                "Decay Days mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.Reset != actLb.ResetType)
                        {
                            ReportVerificationFailure(expLb.Reset, actLb.ResetType,
                                "Reset Type mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        if (expLb.TeamsLeaderboard != actLb.IsTeamLb)
                        {
                            ReportVerificationFailure(expLb.TeamsLeaderboard, actLb.IsTeamLb,
                                "Team leaderboard flag mismatch in leaderboard {0}", expLb.Id);
                            result = TEST_RESULTS.FAILED;
                        }

                        // The Top 100 setting for competition templates is forced to True
                        // no matter what is set in the XSC file.
                        if (isCompTemplate)
                        {
                            if (!actLb.Top100)
                            {
                                ReportVerificationFailure(true, actLb.Top100,
                                    "Top 100 flag mismatch in competition template {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if (expLb.TopOneHundred != actLb.Top100)
                            {
                                ReportVerificationFailure(expLb.TopOneHundred, actLb.Top100,
                                    "Top 100 flag mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }

                        if (expLb.Attachments != null)
                        {
                            if (expLb.Attachments.Uploads != actLb.AttachCount)
                            {
                                ReportVerificationFailure(expLb.Attachments.Uploads, actLb.AttachCount,
                                    "Attachment count mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Attachments.Size != actLb.MaxAttachSize)
                            {
                                ReportVerificationFailure(expLb.Attachments.Size, actLb.MaxAttachSize,
                                    "Maximum attachment size mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if (actLb.AttachCount != 0)
                            {
                                ReportVerificationFailure(0, actLb.AttachCount,
                                    "Attachment count mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (actLb.MaxAttachSize != 0)
                            {
                                ReportVerificationFailure(0, actLb.MaxAttachSize,
                                    "Maximum attachment size mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }

                        if (expLb.Elo != null)
                        {
                            if (String.Compare(expLb.Elo.ExponentialBase, actLb.EloBase.TrimEnd(), true) != 0)
                            {
                                ReportVerificationFailure(expLb.Elo.ExponentialBase, actLb.EloBase,
                                    "ELO Exponent Base mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Elo.InitialPlayerRating != actLb.EloNew)
                            {
                                ReportVerificationFailure(expLb.Elo.InitialPlayerRating, actLb.EloNew,
                                    "ELO Initial Player Rating mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (expLb.Elo.RatingScaleFactor != actLb.EloK)
                            {
                                ReportVerificationFailure(expLb.Elo.RatingScaleFactor, actLb.EloK,
                                    "ELO Rating Scale Factor mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            string eloArray = EloArrayToString(expLb.Elo.MaxWeightRatingRangeArray.MaxWeightRatingRanges);
                            if (eloArray != actLb.EloCTable)
                            {
                                ReportVerificationFailure(eloArray, actLb.EloCTable,
                                    "ELO Max Weight Rating Range mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if ("10" != actLb.EloBase)
                            {
                                ReportVerificationFailure("10", actLb.EloBase,
                                    "ELO Exponent Base mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (500 != actLb.EloNew)
                            {
                                ReportVerificationFailure(500, actLb.EloNew,
                                    "ELO Initial Player Rating mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if (100 != actLb.EloK)
                            {
                                ReportVerificationFailure(100, actLb.EloK,
                                    "ELO Rating Scale Factor mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }

                            if ("0:40" != actLb.EloCTable)
                            {
                                ReportVerificationFailure("0:40", actLb.EloCTable,
                                    "ELO Max Weight Rating Range mismatch in leaderboard {0}", expLb.Id);
                                result = TEST_RESULTS.FAILED;
                            }
                        }
                        break;
                    }
                }

                if (!found)
                {
                    report.Error("Unable to find leaderboard {0} in the service.", expLb.Id);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        private static string EloArrayToString(XscMaxWeightRatingRangeCollection eloArray)
        {
            StringBuilder eloArrayString = new StringBuilder();

            foreach (XscMaxWeightRatingRange range in eloArray)
            {
                eloArrayString.AppendFormat("{0}:{1},", range.Start, range.MaxWeight);
            }

            if (eloArrayString.Length > 0)
            {
                eloArrayString.Length--;
            }

            return eloArrayString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\StatsWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;

using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using System.ServiceModel.Channels;
using xonline.stats.admin;

using LiveStatsTest;

namespace MIXTesting
{
    /// <summary>
    /// The Stats WCF client. 
    /// This is the one location that contains all API calls for the Stats component.
    /// </summary>
    public class StatsWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixstats/mixstatsV1.svc";
        private DbLeaderboard lb = new DbLeaderboard(); // Used for verification
        //private SqlConnection _conn;

        public StatsWCFClient()
        {
            //string[] servers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.xstatsfd);
            //ConnectToServer(servers[0]);
        }

        /// <summary>
        /// Create a new MixStatsClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static MixStatsClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixstats);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixStatsClient client = new MixStatsClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureLeaderboards. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        public void ConfigureLeaderboards(uint titleId)
        {
            ConfigureLeaderboards(titleId, false);
        }

        /// <summary>
        /// API ConfigureLeaderboards. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="force"></param>
        public void ConfigureLeaderboards(uint titleId, bool force)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureLeaderboards", titleId, force);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("Stats ConfigureLeaderboards call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        /// <summary>
        /// API ResetLeaderboard. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="leaderboardId"></param>
        public void ResetLeaderboard(uint titleId, ulong leaderboardId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ResetLeaderboard", titleId, (int)leaderboardId);
            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("Stats ResetLeaderboards call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }
        
        /// <summary>
        /// API DeleteLoeaderboards. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        public void DeleteLeaderboards(uint titleId)
        {
            DbLeaderboard.DeleteTitlesLeaderboards(titleId);
        }

        #region Helpers

        /// <summary>
        /// Verifies all leaderboard configuration data in the service matches the XLAST and LTC files.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="verifyLocation">Flag indicating whether or not the leaderboard locations should be verified.</param>
        /// <returns></returns>
        public TEST_RESULTS VerifyXbox360StatsData(uint titleId, bool verifyLocation)
        {
            string xlastLoc = "SuitesData\\MixTitleManagementTest\\" + titleId.ToString("X") + ".xlast";
            return VerifyXbox360StatsData(titleId, xlastLoc, verifyLocation);
        }
            

        /// <summary>
        /// Verifies all leaderboard configuration data in the service matches the XLAST and LTC files.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="path">Path to the xlast file to verify</param>
        /// <param name="verifyLocation">Flag indicating whether or not the leaderboard locations should be verified.</param>
        /// <returns></returns>
        public TEST_RESULTS VerifyXbox360StatsData(uint titleId, string path, bool verifyLocation)
        {
            TEST_RESULTS res;

            // This pulls leaderboard information from the service
            Xbox360Stats stats = Xbox360Stats.Create(titleId);
            ServerTestFramework.STFTools.ConfigFiles.XboxLiveSubmissionProject xlast = (ServerTestFramework.STFTools.ConfigFiles.XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                (typeof(ServerTestFramework.STFTools.ConfigFiles.XboxLiveSubmissionProject), path);

            // Get the LTC file from the server, then save it as a file so the test LTC file can use it
            string ltcLoc = titleId.ToString("X") + ".ltc";
            StreamWriter sw = new StreamWriter(ltcLoc);
            sw.WriteLine(xonline.common.livetitleconfig.LiveTitleConfig.Get(titleId).ToXml());
            if (sw != null)
                sw.Close();

            LiveTitleConfig ltc = (LiveTitleConfig)ConfigFileSerializer.FromXml
                (typeof(LiveTitleConfig), ltcLoc);

            res = Xbox360StatsVerifier.VerifyLeaderboards(xlast, stats);
            if (res == TEST_RESULTS.PASSED && verifyLocation == true)
            {
                // Verify the leaderboards are where they should be
                res = Xbox360StatsVerifier.VerifyLeaderboardLocation(ltc, stats);
            }

            return res;
        }

        ///// <summary>
        ///// Connects to the stats Database
        ///// </summary>
        ///// <param name="serverName">Name of stats server</param>
        //public void ConnectToServer(string serverName)
        //{
        //    try
        //    {
        //        // TODO: what DB to call into?
        //        _conn = new SqlConnection("server=" + serverName + ";database=xmatch;Integrated Security=SSPI");
        //        _conn.Open();
        //    }
        //    catch (SqlException sqlex)
        //    {
        //        throw new DatabaseException(_conn, sqlex);
        //    }
        //}

        /// <summary>
        /// Clears all stats tables and sprocs from the db
        /// </summary>
        /// <param name="titleId"></param>
        public void ClearDB(uint titleId)
        {
            DbLeaderboard.DeleteTitlesLeaderboards(titleId);
        }

        ///// <summary>
        ///// Closes the connection to stats
        ///// </summary>
        //public void CloseConnection()
        //{
        //    lock (_conn)
        //    {
        //        // m_SqlConnection could be null
        //        if (_conn != null && _conn.State != ConnectionState.Closed)
        //        {
        //            try
        //            {
        //                _conn.Close();
        //            }
        //            catch
        //            {
        //                // do nothing
        //            }
        //            _conn = null;
        //        }
        //    }
        //}

        ///// <summary>
        ///// Allows you to pass a query to stats and get a data reader back.
        ///// </summary>
        ///// <param name="sql">SQL Query</param>
        ///// <param name="reader">Data returned from query</param>
        //public void ReadData(string sql, out SqlDataReader reader)
        //{
        //    try
        //    {
        //        SqlCommand command = new SqlCommand(sql, _conn);
        //        reader = command.ExecuteReader();

        //        if (reader == null)
        //        {
        //            throw new DatabaseException(_conn, "Execute reader failed");
        //        }
        //    }
        //    catch (SqlException sqlex)
        //    {
        //        throw new DatabaseException(_conn, sqlex);
        //    }
        //}

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SVLeaderboard.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.protocol;

namespace LiveStatsTest
{
	/// <summary>
	/// This class represents a standard method of defining a leaderboard within
	/// the Stats Verification methods.
	/// </summary>
	/// <remarks>
	/// This class and it's supporting SV* classes are needed to normalize StatsView
	/// leaderboard definitions from an XLAST file with TrueSkill leaderboard definitions.
	/// </remarks>
	public class SVLeaderboard
	{
        /*
                Byte    Server thinks       Tools think

                0       Never               Weekly
                1       Weekly              Biweekly
                2       Monthly             Monthly
                3       BiMonthly           BiMonthly
                4       Quarterly           Annually
                5       SemiAnnually        Never
                6       Annually            NA
        */
        private static int [] resetTypeMapping = new int [] {1,4,2,3,6,0};
        public const uint ContextGameType = 0x0000800A;
        public const uint ContextGameMode = 0x0000800B;
        public const int GameTypeContextRanked = 0;
        public const int GameTypeContextUnranked = 1;

        private uint _leaderboardId;
        private int _resetType;
        private bool _top100;
        private bool _arbitrated;
        private int _decayDays;
        private int _maxAttachments;
        private SVLocalizedDescription [] _names;
        private SVLeaderboardColumn [] _columns;
        private SVRawAttribute [] _rawAttributes;

        protected SVLeaderboard() {}

		public SVLeaderboard(uint lbId) : this()
		{
            _leaderboardId = lbId;
		}

        #region Properties
        public uint LeaderboardId
        {
            get { return _leaderboardId; }
            set { _leaderboardId = value; }
        }

        public bool IsTrueSkill
        {
            get { return (_leaderboardId & 0xFFFF0000) == 0xFFFF0000; }
        }

        public int ResetType
        {
            get { return _resetType; }
            set { _resetType = value; }
        }

        public bool Top100
        {
            get { return _top100; }
            set { _top100 = value; }
        }

        public bool Arbitrated
        {
            get { return _arbitrated; }
            set { _arbitrated = value; }
        }

        public int DecayDays
        {
            get { return _decayDays; }
            set { _decayDays = value; }
        }

        public int MaxAttachments
        {
            get { return _maxAttachments; }
            set { _maxAttachments = value; }
        }

        public SVLocalizedDescription [] Names
        {
            get { return _names; }
            set { _names = value; }
        }

        public SVLeaderboardColumn [] Columns
        {
            get { return _columns; }
            set { _columns = value; }
        }

        public SVRawAttribute [] RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }
        #endregion

        /// <summary>
        /// Static method to extract user-defined and TrueSkill leaderboards from an XLAST file.
        /// </summary>
        /// <param name="xlast">An XboxLiveSubmissionProject object representing an XLAST file.</param>
        /// <returns>A hashtable containing all user-defined and TrueSkill leaderboards from the XLAST file.</returns>
        public static Hashtable GetLeaderboardsFromXlast(XboxLiveSubmissionProject xlast)
        {
            Hashtable userLbs, trueSkillLbs;

            // First munge the StatsViews into SVLeaderboard objects
            userLbs = GetUserLeaderboards(xlast);

            // Now create TrueSkill leaderboards from the GameModes
            trueSkillLbs = GetTrueSkillLeaderboards(xlast);

            // Finally, combine the two hashtables
            foreach (DictionaryEntry lb in trueSkillLbs)
            {
                userLbs.Add(lb.Key, lb.Value);
            }

            return userLbs;
        }

        private static Hashtable GetUserLeaderboards(XboxLiveSubmissionProject xlast)
        {
            SVLeaderboard lb;
            Hashtable userLbs = new Hashtable();
            int i;

            foreach (StatsView userLb in xlast.GameConfigProject.StatsViews.StatsViewCollection)
            {
                lb = new SVLeaderboard(userLb.id);
                lb.Arbitrated = userLb.arbitrated;
                lb.DecayDays = userLb.entryExpiration;
                lb.ResetType = MapResetType(userLb.resetType);
                lb.Top100 = (userLb.topEntries == 100);
                lb.MaxAttachments = userLb.maxAttachments;
                lb.Names = GetLocalizedStrings(userLb.stringId, xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);

                // Process the columns
                i = 0;
                lb.Columns = new SVLeaderboardColumn[userLb.Columns.Count];
                foreach (ViewFieldType column in userLb.Columns.FieldCollection)
                {
                    lb.Columns[i] = new SVLeaderboardColumn(((uint)column.attributeId).ToString(), (uint)column.attributeId,
                        string.Format("attr[{0}]!=null?attr[{0}]:0", (uint)column.attributeId));
                    lb.Columns[i++].Descriptions = GetLocalizedStrings(column.stringId,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                }

                lb.RawAttributes = GetRawAttributesFromLbColumn(lb.Columns);
                userLbs.Add(userLb.id, lb);
            }

            return userLbs;
        }

        private static Hashtable GetTrueSkillLeaderboards(XboxLiveSubmissionProject xlast)
        {
            uint lbID;
            SVLeaderboard lb;
            Hashtable trueSkillLeaderboards = new Hashtable();

            foreach (ServerTestFramework.STFTools.ConfigFiles.GameMode gm in xlast.GameConfigProject.GameModes.GameModeCollection)
            {
                Context c = FindGameTypeContext(xlast.GameConfigProject.Contexts.ContextCollection);

                /*
                    The enumeration for this special GameType context is guaranteed to be 
                        0 - Ranked
                        1 - Standard
                */
                foreach (ContextValue cv in c.ContextValueCollection)
                {
                    if (cv.value == GameTypeContextRanked)
                    {
                        if (cv.friendlyName == "RANKED")
                        {
                            lbID = 0xFFFF0000 + (uint)gm.value;
                        }
                        else
                        {
                            throw new StfException("GAME_TYPE Context 0 is not RANKED - Has it been hand edited?");
                        }
                    }
                    else if (cv.value == GameTypeContextUnranked)
                    {
                        if (cv.friendlyName == "STANDARD")
                        {
                            lbID = 0xFFFE0000 + (uint)gm.value;
                        }
                        else
                        {
                            throw new StfException("GAME_TYPE Context 1 is not STANDARD - Has it been hand edited");     
                        }
                    }
                    else
                    {
                        continue; //not supported
                    }

                    lb = new SVLeaderboard(lbID);
                    lb.Arbitrated = (lbID & 0xFFFF0000) == 0xFFFF0000;
                    lb.Columns = GetTrueSkillColumns(xlast.GameConfigProject.LocalizedStrings.defaultLocale);

                    SVLocalizedDescription [] localizedGameModes = GetLocalizedStrings(gm.stringId,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);
                    lb.Names = GetLocalizedTrueSkillDescriptions(localizedGameModes, cv,
                        xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection);

                    lb.RawAttributes = GetRawAttributesFromLbColumn(lb.Columns);
                    trueSkillLeaderboards.Add(lbID, lb);
                }
            }

            return trueSkillLeaderboards;
        }

        private static int MapResetType(resetType xlastResetType)
        {
            return resetTypeMapping[(int)xlastResetType];
        }

        private static Context FindGameTypeContext(ContextCollection contexts)
        {
            foreach (Context context in contexts)
            {
                if (uint.Parse(context.id.Substring(2), System.Globalization.NumberStyles.HexNumber) == ContextGameType)
                {
                    return context;
                }
            }

            return null;
        }

        private static SVRawAttribute [] GetRawAttributesFromLbColumn(SVLeaderboardColumn [] columns)
        {
            SVRawAttribute [] attributes = null;

            attributes = new SVRawAttribute[columns.Length];

            for (int i = 0; i < attributes.Length; i++)
            {
                attributes[i] = new SVRawAttribute((int)columns[i].AttributeId, false);
            }

            return attributes;
        }

        private static SVLocalizedDescription [] GetLocalizedStrings(ushort stringId, LocalizedStringCollection xlastStrings)
        {
            SVLocalizedDescription [] strings = null;

            foreach (LocalizedString str in xlastStrings)
            {
                if (str.id == stringId)
                {
                    strings = new SVLocalizedDescription[str.TranslationCollection.Count];
                    for (int i = 0; i < strings.Length; i++)
                    {
                        strings[i] = new SVLocalizedDescription(
                            str.TranslationCollection[i].locale,
                            str.TranslationCollection[i].Value);
                    }
                    break;
                }
            }

            return strings;
        }

        private static SVLocalizedDescription [] GetLocalizedTrueSkillDescriptions(SVLocalizedDescription [] gameModes, ContextValue cv, LocalizedStringCollection xlastStrings)
        {
            SVLocalizedDescription [] localizedContexts = GetLocalizedStrings(cv.stringId, xlastStrings);
            
            foreach (SVLocalizedDescription localizedDes in gameModes)
            {
                string context = cv.friendlyName; //give it a default of friendly name
                foreach (SVLocalizedDescription localizedCon in localizedContexts)
                {
                    if (localizedDes.Locale == localizedCon.Locale)
                    {
                        context = localizedCon.Description;
                        break;
                    }
                }
                
                localizedDes.Description = String.Format("{0}-{1} TrueSkill", localizedDes.Description, context);
            }
            
            return gameModes;
        }

        enum SpecialAttribEnum
        {
            Rank                = SpecialAttrib.Rank,
            Rating              = SpecialAttrib.Rating,
            Nickname            = SpecialAttrib.Nickname,
            Skill               = SpecialAttrib.Skill,
            GamesPlayed         = SpecialAttrib.GamesPlayed,
            Mu                  = SpecialAttrib.Mu,
            Sigma               = SpecialAttrib.Sigma
        }

        private static SVLeaderboardColumn [] GetTrueSkillColumns(string defaultLocale)
        {
            /*
              TRUSKILL have 4 columns

                public const ushort Skill               = 61;
                public const ushort GamesPlayed         = 62;
                public const ushort Mu                  = 63;
                public const ushort Sigma               = 64;

              On top of usual:

                public const ushort Rank                = 0xFFFF;
                public const ushort Rating              = 0xFFFE;
                public const ushort Nickname            = 0xFFFD;
            */
            int [] arrValues = (int [])Enum.GetValues(typeof(SpecialAttribEnum));
            SVLeaderboardColumn [] arrRet = new SVLeaderboardColumn[arrValues.Length];

            for (int i = 0; i < arrRet.Length; i++)
            {
                SpecialAttribEnum mapValue = (SpecialAttribEnum)arrValues[i];
                arrRet[i] = new SVLeaderboardColumn(((uint)mapValue).ToString(), (uint)mapValue,
                    string.Format("attr[{0}]!=null?attr[{0}]:0", (uint)mapValue));
                arrRet[i].Descriptions    = new SVLocalizedDescription[1];
                arrRet[i].Descriptions[0] = new SVLocalizedDescription(defaultLocale, mapValue.ToString());
                arrRet[i].ReturnType = 12;  // it's always 12
            }

            return arrRet;
        }
    }

    /// <summary>
    /// Leaderboard column definition class for both user-defined and TrueSkill leaderboards.
    /// </summary>
    public class SVLeaderboardColumn
    {
        public string Name;
        public int ReturnType;
        public string Formula;
        public SVLocalizedDescription [] Descriptions;

        // xlast fields
        public uint AttributeId;
        public uint PropertyId;
        public string Aggregation;

        /// <summary>
        /// Creates an SVLeaderboardColumn object with the given name, attribute Id and formula
        /// </summary>
        /// <param name="name">The friendly name of the column</param>
        /// <param name="attributeId">The attribute ID of the column</param>
        /// <param name="formula">The column formula.</param>
        public SVLeaderboardColumn(string name, uint attributeId, string formula)
        {
            Name = name;
            AttributeId = attributeId;
            Formula = formula;
            ReturnType = 12;
        }

        public SVLeaderboardColumn() {}
    }

    /// <summary>
    /// This class represents a single string translation from an XLAST file.
    /// </summary>
    public class SVLocalizedDescription
    {
        public string Locale;
        public string Description;

        public SVLocalizedDescription(string locale, string description)
        {
            Locale = locale;
            Description = description;
        }

        public SVLocalizedDescription() {}
    }

    /// <summary>
    /// This class represents the raw attributes for an Xbox 1 leaderboard.
    /// </summary>
    public class SVRawAttribute
    {
        public int Id;
        public bool IsPUID;

        public SVRawAttribute(int id, bool isPuid)
        {
            Id = id;
            IsPUID = isPuid;
        }

        public SVRawAttribute() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\SubscriptionFamilyClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Xml;
using System.IO;
using System.ServiceModel.Channels;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFTools.ConfigFiles;

using xonline.common.config;
using Microsoft.Webstore.WstClient;

using xonline.mix.subscriptionfamily.contracts.v1;

namespace MIXTesting
{
    /// <summary>
    /// The subscriptionfamily  WCF client.
    /// This is the one location that contains all API calls for the subscriptionfamily component.
    /// </summary>
    public class SubscriptionFamilyWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixsubscriptionfamily/subscriptionfamilyV1.svc";

        /// <summary> HR result expected by the call. </summary>
        public uint ExpectedHR=HResult.S_OK;

        /// <summary>
        /// Create a new MixsubscriptionfamilyClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected static SubscriptionFamilyClient CreateNewClient()
        {                                                           //to do
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsubscriptionfamily);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            SubscriptionFamilyClient client = new SubscriptionFamilyClient(wsb, epa);
            return client;
        }



        /// <summary>
        /// 
        /// </summary>       
        public NameValue[] ServicePrivilegeSetEnumerate()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
           
            NameValue[] sets = Invoke<NameValue[]>(CreateNewClient(), out hr, out retryable, out ex, "ServicePrivilegeSetEnumerate");
            VerifyHR(hr, ex);
            return sets;
        }
       
            
     
        /// <summary>
        /// 
        /// </summary>       
        public NameValue[] SubscriptionTypeEnumerate()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            
            NameValue[] sets = Invoke<NameValue[]>(CreateNewClient(), out hr, out retryable, out ex, "SubscriptionTypeEnumerate");
            VerifyHR(hr, ex);
            return sets;
        }

        /// <summary>
        /// 
        /// </summary>        
        public NameValue[] ServiceTypeEnumerate()
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            NameValue[] subTypes = Invoke<NameValue[]>(CreateNewClient(), out hr, out retryable, out ex, "ServiceTypeEnumerate");
            VerifyHR(hr, ex);

            return subTypes;
        }     


        /// <summary>
        /// 
        /// </summary>        
        public SubscriptionFamilyInfo SubscriptionFamilyGet(Guid familyId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            SubscriptionFamilyInfo subFamily = Invoke<SubscriptionFamilyInfo>(CreateNewClient(), out hr, out retryable, out ex, "SubscriptionFamilyGet", familyId);
            VerifyHR(hr, ex);

            return subFamily;
        }     


        /// <summary>
        /// 
        /// </summary>        
        public void SubscriptionFamilyConfigure(Guid familyId, string familyName, int serviceType,
                             int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SubscriptionFamilyConfigure",
                                                 familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
            VerifyHR(hr, ex);           
        }



        private void VerifyHR(uint hr, System.Exception ex)
        {
            if (ExpectedHR == HResult.S_OK && (hr != HResult.S_OK || ex != null))
            {
                throw new UnexpectedTestResultException("Call failed with HR=" + Global.XErrToString(hr), ex);
            }
            else if (ExpectedHR != hr)
            {
                throw new UnexpectedTestResultException("Expected HR=" + Global.XErrToString(ExpectedHR) + ", got HR=" + Global.XErrToString(hr), ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\TitleManagementV2WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Linq;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Data;
using System.Text;
using System.Xml.Serialization;

using ServerTestFramework;
//using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.StringServer;
using ServerTestFramework.Reporting;
using xonline.mix.common;

using xonline.common.config;
using xonline.common.tools.stutilcore;
//using xonline.mix.titlemanagement.contract;
using xonline.mix.titlemanagement.contracts.V2;
using xonline.common.xlastutil;

using Microsoft.Webstore.WstClient;

using MIXTestingUtilsV2;
using XHResult = xonline.common.service.HResult;
using TitleVersions = xonline.mix.titlemanagement.contracts.V2.TitleVersions;
using ServerTestFramework.Database;
using TUPData = ServerTestFramework.Database.TitleEditor.TitleUpdatePackageData;
using System.Collections.Generic;

namespace MIXTesting
{
    /// <summary>
    /// The TitleManagement WCF client. 
    /// This is the one location that contains all API calls for TitleManagement component.
    /// </summary>
    public class TitleManagementV2WCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixtitlemanagement/mixtitlemanagementv2.svc";

        public TitleManagementV2WCFClient()
        {
        }

        /// <summary>
        /// Create a new MixTitleManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixTitleManagementV2Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixtitlemanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixTitleManagementV2Client client = new MixTitleManagementV2Client(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureTitle. This is for normal use or positive tests.
        /// </summary>
        /// <param name="xlast"></param>
        public void ConfigureTitle(byte[] xlast)
        {
            ConfigureTitle(xlast, false, HResult.S_OK, false);
        }

        public void ConfigureTitle(byte[] xlast, bool noReload)
        {
            ConfigureTitle(xlast, noReload, HResult.S_OK, false);
        }

        /// <summary>
        /// API ConfigureTitle. This is for negative tests.
        /// </summary>
        /// <param name="xlast"></param>
        /// <param name="noReload"></param>
        /// <param name="expectedHR"></param>
        /// <param name="expectedRetryable"></param>
        public void ConfigureTitle(byte[] xlast, bool noReload, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureTitle", xlast, noReload);

            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        public void AddBaseVersion(TitleVersionInstance titleVersion)
        {
            AddBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            AddBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AddBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("AddBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        public void RemoveBaseVersion(TitleVersionInstance titleVersion)
        {
            RemoveBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            RemoveBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("RemoveBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }

        }

        public TitleVersions GetTitleVersions(uint titleId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleVersions versions = Invoke<TitleVersions>(CreateNewClient(), out hr, out retryable, out ex, "GetTitleVersions", titleId);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetTitleVersions call failed with HR = 0x" + hr.ToString("X"), ex);
            }

            return versions;
        }

        public void SetTitleUpdatePackages(
            uint titleId,
            int baseVersion,
            int updateVersion,
            PlatformType consoleType,
            TitleUpdatePackageInformation packageInformation,
            TitleUpdatePackageLocation[] updateLocations)
        {
            SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations, HResult.S_OK);
        }

        public void SetTitleFacebookAppId(
            uint titleId,
            string appId)
        {
            SetTitleFacebookAppId(titleId, appId, HResult.S_OK);
        }

        public void SetTitleUpdatePackages(
            uint titleId,
            int baseVersion,
            int updateVersion,
            PlatformType consoleType,
            TitleUpdatePackageInformation packageInformation,
            TitleUpdatePackageLocation[] updateLocations,
            XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetTitleUpdatePackages", titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);

            if (hr != expectedHR)
            {
                throw new UnexpectedTestResultException("SetTitleUpdatePackages call failed with HR = 0x" + hr.ToString("X"), ex);
            }

        }

        public void SetTitleFacebookAppId(
            uint titleId,
            string appId,
            XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetTitleFacebookAppId", titleId, appId);

            if (hr != expectedHR)
            {
                throw new UnexpectedTestResultException("SetTitleFacebookAppId call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        #region Utils

        public byte[] CompressXlast(string xlast)
        {
            return Gzip.Compress(xlast);
        }

        public string GetDropXlast(string file)
        {
            StreamReader streamReader = new StreamReader(file);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();
            return xlast;
        }

        public string GetXlast(string filename)
        {
            StreamReader streamReader = new StreamReader(filename);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();

            //Check if it is mobile title
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);
            string locFile = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";

            Dictionary<string, string> colLocalizationData =
            MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(locFile);

            //If MobileTitle convert it to general format where each FriendStatsView is mapped to two StatsView leaderboard nodes
            if (isMobileTitle)
            {
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, colLocalizationData);
            }

            XmlSerializer serializer = new XmlSerializer(xlsp.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, xlsp);
                xlast = writer.ToString();
            }

            return xlast;
        }

        public string GetXlast(uint titleID)
        {
            StreamReader streamReader = new StreamReader(string.Format("SuitesData\\MixTitleManagementTest\\{0:X}.xlast", titleID));
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();

            //Check if it is mobile title
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);
            string locFile = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";

            Dictionary<string, string> colLocalizationData =
            MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(locFile);

            //If MobileTitle convert it to general format where each FriendStatsView is mapped to two StatsView leaderboard nodes
            if (isMobileTitle)
            {
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, colLocalizationData);
            }

            XmlSerializer serializer = new XmlSerializer(xlsp.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, xlsp);
                xlast = writer.ToString();
            }
           
            return xlast;
        }

        public string BulkTitlePath = @"\\shailesh1\mix\production_all\";
        public string[] GetBulkTitlesList()
        {
            //return BadTitles;
            return Directory.GetFiles(BulkTitlePath, "*.xlast", SearchOption.AllDirectories);
        }

        public string GetBulkXlast(string file)
        {
            string result = "";
            StreamReader streamReader = new StreamReader(file);
            result = streamReader.ReadToEnd();
            streamReader.Close();
            return result;
        }

        private TitleStringData[] GetLocalesFromXLSP(XboxLiveSubmissionProject xlsp)
        {
            TitleStringData[] results;

            LocalizedString titleName = XlastUtil.GetTitleNameLocalizeString(xlsp.GameConfigProject.LocalizedStrings);
            results = new TitleStringData[titleName.Translation.Length];

            for (int i = 0; i < titleName.Translation.Length; i++)
            {
                results[i] = new TitleStringData();
                results[i].index = titleName.id;
                results[i].locale = titleName.Translation[i].locale;
                results[i].title = Unescape(titleName.Translation[i].Value);
            }

            return results;
        }

        private string Unescape(string p)
        {
            string result = p;
            result = result.Replace("'", "''");

            return result;
        }

        public void Cleanup(uint titleID)
        {
            string deleteString = "delete from {0} where i_title_id=0x{1:X}";

            //Create NPDB object
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            // Perform NPDB deletes
            npdb.ExecuteScalar(string.Format(deleteString, "t_stringsvr_strings", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_live_title_config", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_game_config", titleID));
            // Clean up NPDB object
            npdb.Close();

            //Create WebDB object
            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            // Perform WebDB deletes
            webdb.IssueCommand(string.Format(deleteString, "t_title_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_raw_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_title_info", titleID));
            // Clean up WebDB object
            webdb.Close();

            //UODB does everything statically
            ExecuteUODBScalar(string.Format(deleteString, "t_title_trust_constants", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_info", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_alternate_titleids", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_offers", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_locations", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_packages", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_ratings", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_genres", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_culture_details", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_versions", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_titles", titleID));

        }

        public TEST_RESULTS propTitle(uint titleID)
        {
            // Get the byte array
            string xlast = GetXlast(titleID);
            byte[] compressedXLast = CompressXlast(xlast);

            // Set up the reload watcher
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
            change.Source = "Xkdc";
            change.Init();

            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);

            // Validate and clean up.
            bool success = ValidateSuccessfulProp(titleID, xlast);
            Cleanup(titleID);

            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            if (success)
            {
                bool reset = change.TestForChange("Reinitialize: completed reinitialization.");

                tr = (reset) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
            }

            return tr;
        }

        public TEST_RESULTS propTitle(uint titleID, string xlastPath)
        {
            // Get the byte array
            string xlast = GetXlast(xlastPath);

            byte[] compressedXLast = CompressXlast(xlast);

            // Set up the reload watcher
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
            change.Source = "Xkdc";
            change.Init();

            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);

            // Validate and clean up.
            bool success = ValidateSuccessfulProp(titleID, xlast);
            Cleanup(titleID);

            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            if (success)
            {
                bool reset = change.TestForChange("Reinitialize: completed reinitialization.");

                tr = (reset) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
            }

            return tr;
        }


        public TEST_RESULTS propTitle_WithoutCleaning(uint titleID, string xlastPath)
        {
            // Get the byte array
            string xlast = GetXlast(xlastPath);

            byte[] compressedXLast = CompressXlast(xlast);

            // Set up the reload watcher
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
            change.Source = "Xkdc";
            change.Init();

            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);

            // Validate and clean up.
            bool success = ValidateSuccessfulProp(titleID, xlast);
            //Cleanup(titleID);

            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            if (success)
            {
                bool reset = change.TestForChange("Reinitialize: completed reinitialization.");

                tr = (reset) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
            }

            return tr;
        }


        public void DeployTitle(uint titleID, uint baseVersion)
        {
            // Get the byte array
            string xlast = GetXlast(titleID);
            byte[] compressedXLast = CompressXlast(xlast);
            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);
        }


        public bool ValidateXlastAndCleanUp(uint titleID, string xlast)
        {
            bool tr = true;
            try
            {
                tr = ValidateSuccessfulProp(titleID, xlast);
                Cleanup(titleID);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                tr = false;
            }
            return tr;
        }

        public bool AddAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                AddBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersions(titleId, versions))
            {
                Global.RO.Error("Failed to successfully add versions!!");
                return false;
            }
            return true;
        }

        public bool RemoveAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersionsNotPresent(titleId, versions))
            {
                Global.RO.Error("Failed to successfully remove versions!");
                return false;
            }

            return true;
        }


        public void RemoveAllVersions(uint titleID)
        {
            TitleVersions actualVersions = GetTitleVersions(titleID);
            for (int i = 0; i < actualVersions.Versions.Length; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)actualVersions.Versions[i]);
            }
        }

        #endregion

        #region Validations

        public bool ValidateSuccessfulProp(uint titleID, string xlast)
        {
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);

            if (!validateNPDB(titleID, xlast, xlsp))
            {
                return false;
            }

            if (!validateWebDB(titleID, xlsp))
            {
                return false;
            }

            // Add StringSrv string validation
            if (!validateStringServer(titleID, xlsp))
            {
                return false;
            }

            return validateUODB(titleID, xlsp);
        }

        public bool validateStringServer(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            // We will issue the cacheflush to stringserver so it loads everything from the cache
            Global.XEnv.ExecuteXmgmtCommand(Interface.stringsvr, "e :stringsvr cacheflush");

            LocalizedStrings strings = xlsp.GameConfigProject.LocalizedStrings;
            if (strings != null)
            {
                LocalizedString ls = XlastUtil.GetTitleNameLocalizeString(strings);
                if ((null != ls) && (null != ls.Translation) && (ls.Translation.Length > 0))
                {
                    foreach (Translation t in ls.Translation)
                    {
                        XRLGet2String request = new XRLGet2String();
                        XRLGetStringResponse response;

                        request.dwTitleID = titleID;
                        request.wNumStrings = 1;
                        request.wLocaleLen = (ushort)t.locale.Length;
                        request.szLocale = t.locale;
                        request.rgdwStringIDs = new uint[1];
                        request.rgdwStringIDs[0] = 0x0;

                        // Let's make sure this is correctly loaded into string server
                        if (!request.Execute(out response))
                        {
                            return false;
                        }

                        int expectedLength = t.Value.Length;
                        if (t.locale == "zh-CHT" && titleID == 0x4D530888) // TODO: Make this less stupid for Lips
                        {
                            expectedLength *= 3;
                        }

                        if (response.wNumStrings != request.wNumStrings ||
                            response.rgStringData[0].wStringSize != expectedLength ||
                            response.rgStringData[0].szString != t.Value)
                            return false;
                    }
                }
            }

            return true;
        }

        public bool ValidateTitleVersions(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions actualVersions = GetTitleVersions(titleId);
            ArrayList actualVersionsDup = new ArrayList(actualVersions.Versions); // Temp dup so we can remove easily

            Global.RO.Info("Versions found for title:" + titleId.ToString("X"));
            for (int i = 0; i < actualVersionsDup.Count; ++i)
            {
                TitleVersionInstance titleVer = (TitleVersionInstance)actualVersionsDup[i];

                Global.RO.Info(String.Format("Title Id:{0}, Base Version:{1}, Update Version:{2}, Console Type:{3}, Beta Group:{4}", titleVer.TitleId.ToString("X"), titleVer.BaseVersion, titleVer.UpdateVersion, titleVer.PlatformType, titleVer.BetaGroup.ToString()));
            }

            if (actualVersionsDup.Count != expectedVersions.Count)
                return false;

            // Doing this manually since we are using the proxy which doesn't like our equals operator
            for (int evi = 0; evi < expectedVersions.Count; ++evi)
            {
                for (int avi = 0; avi < actualVersionsDup.Count; ++avi)
                {
                    if ((((TitleVersionInstance)actualVersionsDup[avi]).BaseVersion == ((TitleVersionInstance)expectedVersions[evi]).BaseVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).UpdateVersion == ((TitleVersionInstance)expectedVersions[evi]).UpdateVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).TitleId == ((TitleVersionInstance)expectedVersions[evi]).TitleId) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).PlatformType == ((TitleVersionInstance)expectedVersions[evi]).PlatformType) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).BetaGroup == ((TitleVersionInstance)expectedVersions[evi]).BetaGroup))
                    {
                        actualVersionsDup.RemoveAt(avi);
                        break;
                    }
                }

                //if (actualVersionsDup.Contains(expectedVersions[i]))
                //    actualVersionsDup.Remove(expectedVersions[i]);
            }

            if (actualVersionsDup.Count == 0)
                return true;

            return false;
        }

        public bool ValidateTitleVersionsNotPresent(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions existingVersions = GetTitleVersions(titleId);

            for (int i = 0; i < expectedVersions.Count; i++)
            {
                if (existingVersions.Versions.Contains(expectedVersions[i]))
                {
                    Global.RO.Warn("Removal of added versions FAILED.  Other tests may fail due to this failure.");
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region NPDB Validations
        private bool validateNPDB(uint titleID, string xlast, XboxLiveSubmissionProject xlsp)
        {
            string getTitleConfigQuery = string.Format("select xml_config from t_game_config where i_title_id=0x{0:X}", titleID);
            string titleString = "select * from t_stringsvr_strings where i_title_id=0x{0:X} and vc_locale='{1}' and i_string_id={2}";

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(getTitleConfigQuery, out reader);

                if (!reader.Read())
                {
                    Global.RO.Error("There was no game config saves to NPDB for " + titleID);
                    return false;
                }

                string proppedXlast = (string)reader.GetValue(reader.GetOrdinal("xml_config"));
                if (!proppedXlast.Equals(xlast))
                {
                    Global.RO.Error("The xlast stored in t_game_config did not match the one that wasd placed there!");
                    return false;
                }

                reader.Close();
                TitleStringData[] strings = GetLocalesFromXLSP(xlsp);
                foreach (TitleStringData tsd in strings)
                {
                    npdb.ReadData(String.Format(titleString, titleID, tsd.locale, 0), out reader);
                    if (!reader.Read())
                    {
                        Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in NPDB.  Expected: id=" + tsd.index);
                        reader.Close();
                        return false;
                    }
                    reader.Close();
                }
            }

            return true;

        }

        #endregion

        #region WebDB Validations

        private bool validateWebDB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (!ValidateWebDBTitleInfo(titleID, xlsp))
            {
                return false;
            }


            return ValidateWebDBTitleNameInfo(titleID, xlsp);
        }

        private bool ValidateWebDBTitleNameInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleNameQuery = "select * from t_title_name_info where i_title_id=0x{0:X} and vc_locale_id='{1}' and vc_display_name=N'{2}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();

            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            TitleStringData[] strings = GetLocalesFromXLSP(xlsp);

            foreach (TitleStringData tsd in strings)
            {

                SqlDataReader reader;
                webdb.ReadData(string.Format(titleNameQuery, titleID, tsd.locale, tsd.title), out reader);
                if (!reader.Read())
                {
                    Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in Webdb.  Expected: " + tsd.title);
                    reader.Close();
                    webdb.Close();
                    return false;
                }
                reader.Close();
            }
            webdb.Close();
            return true;
        }

        private bool ValidateWebDBTitleInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and vc_default_locale='{1}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            SqlDataReader reader;
            webdb.ReadData(string.Format(titleQuery, titleID, xlsp.GameConfigProject.LocalizedStrings.defaultLocale), out reader);
            if (!reader.Read())
            {
                webdb.Close();
                Global.RO.Error("The titleInfo was not present or was incorrect in WebDB.");
                return false;
            }

            webdb.Close();

            return true;
        }

        #endregion

        #region UODB Validations

        private bool validateUODB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (xlsp.GameConfigProject.ProductInformation != null)
            {
                if (xlsp.GameConfigProject.ProductInformation.Platform != null)
                {
                    if (!ValidateUODBTitle(titleID, xlsp))
                    {
                        return false;
                    }
                }


                if (xlsp.GameConfigProject.ProductInformation.Feature != null)
                {
                    bool? bRequiresValidation = GetRequiresValidation(xlsp);
                    if (null != bRequiresValidation)
                    {
                        if (!ValidateUODBRequiresActivation(titleID, xlsp, bRequiresValidation))
                        {
                            return false;
                        }
                    }
                }
            }

            return ValidateUODBTrustConstants(titleID);
        }

        private bool? GetRequiresValidation(XboxLiveSubmissionProject xlsp)
        {
            foreach (Feature f in xlsp.GameConfigProject.ProductInformation.Feature)
            {
                if (f.name == "pcServerSideActivation")
                {
                    return f.enabled;
                }
            }
            return null;
        }

        private bool ValidateUODBTrustConstants(uint titleID)
        {
            string titleQuery = "select * from t_title_trust_constants where i_title_id=0x{0:X}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
            {
                Global.RO.Error("The titleID was not inserted into uodb.dbo.t_title_trust_constants.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBRequiresActivation(uint titleID, XboxLiveSubmissionProject xlsp, bool? requiresActivation)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and ti_console_type_id={1} and f_requires_activation={2}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID, (byte)ConsoleTypeEnum.PC, ((bool)requiresActivation) ? 1 : 2), null))
            {
                Global.RO.Error("The RequiresValidation field in UODB either was not present or was incorrect.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBTitle(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_titles where i_title_id=0x{0:X}";

            ConsoleTypeEnum[] types = GetConsoleTypes(xlsp);

            foreach (ConsoleTypeEnum cte in types)
            {
                if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
                {
                    Global.RO.Error("The title was not present in UODB.");
                    return false;
                }
            }

            return true;
        }

        private ConsoleTypeEnum[] GetConsoleTypes(XboxLiveSubmissionProject xlsp)
        {
            ConsoleTypeEnum[] consoleTypes = new ConsoleTypeEnum[xlsp.GameConfigProject.ProductInformation.Platform.Length];

            for (int i = 0; i < xlsp.GameConfigProject.ProductInformation.Platform.Length; i++)
            {
                consoleTypes[i] = (ConsoleTypeEnum)xlsp.GameConfigProject.ProductInformation.Platform[i].id;
            }

            return consoleTypes;
        }

        #endregion

        #region SQLUtils

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be Scalar
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public static void ExecuteUODBScalar(string command)
        {
            int partitionCount;
            //get partition count
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList = new ArrayList();

            try
            {
                //open a connection for each partition
                for (int physicalPartition = 0; physicalPartition < partitionCount; physicalPartition++)
                {

                    WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(command, conn, physicalPartition);

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType = CommandType.Text;
                    cmd.PartitionType = WstPartitionType.Physical;

                    cmd.ExecuteScalar();

                }// for each partition

            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach (WstConnection conn in connectionList)
                {
                    conn.Close();
                }
            }
        }
        #endregion

        string[] BadTitles = new string[]
        {
@"\\shailesh1\mix\production_all\535007e3\535007E3.xlast"
        };
    }
}

namespace MIXTestingUtilsV2
{
    #region Classes

    public enum TM_Titles : uint
    {
        LIPS = 0x4D530888,
        BASIC = 0xFFFE1800,
        NULL_TITLE_ID = 0xFFFE1801,
        BASIC_REPROP = 0xFFFE1802,
        EXCEPTIONS = 0xFFFE1804
    }

    class TitleStringData
    {
        public string title = "";
        public int index = 0;
        public string locale = "";
    }

    public class Versions
    {
        public static ArrayList Basic = new ArrayList();
        public static ArrayList MultiVersion = new ArrayList();
        public static ArrayList MultiVersion_SecondHalf = new ArrayList();
        public static ArrayList MultiPlatform = new ArrayList();
        public static ArrayList MultiPlatform_SecondHalf = new ArrayList();
        public static ArrayList Lips = new ArrayList();
        public static ArrayList InvalidPlatform = new ArrayList();
        public static ArrayList Marketplace = new ArrayList();
        public static ArrayList InvalidTitle = new ArrayList();
        private static bool initialized = false;

        public static void Initialize()
        {
            if (!initialized)
            {
                initialized = true;

                // Basic
                TitleVersionInstance titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Basic.Add(titleVer);

                // MultiVersion
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                // MultiVersion_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion_SecondHalf.Add(titleVer);

                // MultiPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                // MultiPlatform_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform_SecondHalf.Add(titleVer);

                // Lips
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.LIPS;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Lips.Add(titleVer);

                // InvalidPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = (PlatformType)255;
                titleVer.BetaGroup = Guid.Empty;
                InvalidPlatform.Add(titleVer);

                // Marketplace
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Marketplace;
                titleVer.BetaGroup = Guid.Empty;
                Marketplace.Add(titleVer);

                // InvalidTitle
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = 0;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                InvalidTitle.Add(titleVer);
            }
        }
    }

    public class TitleUpdateUtils
    {
        public static readonly uint DefaultTitle = (uint)(TM_Titles.BASIC);
        public static readonly int DefaultBaseVersion = 0x20100000; // 2.0.1000.00
        public static readonly int DefaultUpgradeVersion = 0x20100100; //2.0.1001.00
        public static TitleUpdatePackageInformation DefaultPackage()
        {
            TitleUpdatePackageInformation package = new TitleUpdatePackageInformation();
            Random r = new Random();
            package.ContentId = RandomByte(20);
            package.InstallSize = 1234;
            package.PackageSize = 1235;
            package.PublicKey = RandomByte(2);
            package.UpdateSymmetricKey = RandomByte(2);

            return package;
        }

        private static byte[] RandomByte(int i)
        {
            Random r = new Random();
            byte[] result = new byte[i];
            r.NextBytes(result);
            return result;
        }

        public static TitleUpdatePackageLocation[] DefaultLocations()
        {
            TitleUpdatePackageLocation[] locations = new TitleUpdatePackageLocation[2];

            locations[0] = new TitleUpdatePackageLocation();
            locations[0].Rank = 0;
            locations[0].Xrl = "test/xrl/0";

            locations[1] = new TitleUpdatePackageLocation();
            locations[1].Rank = 1;
            locations[1].Xrl = "test/xrl/1";

            return locations;
        }

        public static TitleUpdateTestInfo DefaultTestInfo()
        {
            TitleUpdateTestInfo testInfo = new TitleUpdateTestInfo();
            testInfo.Locations = DefaultLocations();
            testInfo.PackageInfo = DefaultPackage();
            testInfo.TitleID = DefaultTitle; // We're ok with integer overflow in this scenario, because we just care about the bits.
            testInfo.BaseVersion = DefaultBaseVersion;      // 2.0.1000.00
            testInfo.UpdateVersion = DefaultUpgradeVersion; //2.0.1001.00
            testInfo.expectedHR = XHResult.XONLINE_E_MIX_UNKNOWNERROR;
            testInfo.Platform = PlatformType.Xenon;

            return testInfo;

        }

        static uint NONPROPPED_TITLE = 0x1;

        public static TitleUpdateTestInfo BuildTitleUpdateTest(TitleUpdateTests test)
        {
            TitleUpdateTestInfo testInfo = DefaultTestInfo();

            switch (test)
            {
                case TitleUpdateTests.Basic:
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroTitleID:
                    testInfo.TitleID = 0;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_INVALID_TITLE_ID;
                    break;
                case TitleUpdateTests.UnproppedTitleID:
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_INVALID_TITLE_ID;
                    testInfo.TitleID = NONPROPPED_TITLE;
                    break;
                case TitleUpdateTests.ZeroUpgradeVersion:
                    testInfo.UpdateVersion = 0;
                    testInfo.expectedHR = HResult.XONLINE_E_MIX_INVALID_VERSION;
                    break;
                case TitleUpdateTests.UpgradedBelowBase:
                    testInfo.BaseVersion = 0;
                    testInfo.expectedHR = HResult.XONLINE_E_MIX_INVALID_VERSION;
                    break;
                case TitleUpdateTests.NullPackage:
                    testInfo.PackageInfo = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.NullSymKey:
                    testInfo.PackageInfo.UpdateSymmetricKey = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthSymKey:
                    testInfo.PackageInfo.UpdateSymmetricKey = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.NullPubKey:
                    testInfo.PackageInfo.PublicKey = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthPubKey:
                    testInfo.PackageInfo.PublicKey = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.ZeroInstallSize:
                    testInfo.PackageInfo.InstallSize = 0;
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroPackageSize:
                    testInfo.PackageInfo.PackageSize = 0;
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.NullContentID:
                    testInfo.PackageInfo.ContentId = null;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroLengthContentID:
                    testInfo.PackageInfo.ContentId = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.NullLocations:
                    testInfo.Locations = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthLocations:
                    testInfo.Locations = new TitleUpdatePackageLocation[0]; ;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.DuplicateRank:
                    testInfo.Locations[1].Rank = testInfo.Locations[0].Rank;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_DUPLICATE_RANK_NOT_ALLOWED;
                    break;
                case TitleUpdateTests.NullXRL:
                    testInfo.Locations[0].Xrl = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.EmptyXRL:
                    testInfo.Locations[0].Xrl = "";
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.NullLocation:
                    testInfo.Locations[0] = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.DupePackage:
                    break;
                case TitleUpdateTests.DupeLocation:
                    testInfo.Locations[1].Xrl = testInfo.Locations[0].Xrl;
                    testInfo.Locations[1].Rank = 99;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_DUPLICATE_XRL_NOT_ALLOWED;
                    break;
                case TitleUpdateTests.MobileNullPackages:
                    testInfo.Locations = null;
                    testInfo.Platform = PlatformType.Mobile;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;
                case TitleUpdateTests.MobileZeroPackages:
                    testInfo.Locations = new TitleUpdatePackageLocation[0];
                    testInfo.Platform = PlatformType.Mobile;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;

            }


            return testInfo;

        }

        public static void PerformTest(TitleUpdateTests test, MIXTesting.TitleManagementV2WCFClient client)
        {
            PerformTest(test, client, true);
        }

        public static void PerformTest(TitleUpdateTests test, MIXTesting.TitleManagementV2WCFClient client, bool cleanUp)
        {
            TitleUpdateTestInfo testInfo = BuildTitleUpdateTest(test);

            PerformTest(testInfo, client, cleanUp);
        }

        public static void PerformTest(TitleUpdateTestInfo testInfo, MIXTesting.TitleManagementV2WCFClient client, bool cleanUp)
        {
            TUPData[] currentPackages = null;

            try
            {
                if ((testInfo.TitleID != 0) && (testInfo.TitleID != NONPROPPED_TITLE))
                {
                    client.DeployTitle((uint)testInfo.TitleID, (uint)testInfo.BaseVersion);

                    TitleEditor title = TitleEditor.FromId((uint)testInfo.TitleID);
                    currentPackages = title.GetUpdatePackages(); // Save this for verification later.
                    client.AddBaseVersion((uint)testInfo.TitleID, testInfo.UpdateVersion, testInfo.Platform);
                }


                client.SetTitleUpdatePackages(
                    testInfo.TitleID,
                    testInfo.BaseVersion,
                    testInfo.UpdateVersion,
                    testInfo.Platform,
                    testInfo.PackageInfo,
                    testInfo.Locations,
                    testInfo.expectedHR);

                if (testInfo.expectedHR == HResult.S_OK) // We expect a pass, so we should verify the packages
                    VerifyUpgrades(testInfo, currentPackages);
            }
            finally
            {
                client.Cleanup((uint)testInfo.TitleID);
            }

        }

        private static void VerifyUpgrades(TitleUpdateTestInfo testInfo, TitleEditor.TitleUpdatePackageData[] currentPackages)
        {
            bool success = true;
            TitleEditor title = TitleEditor.FromId((uint)testInfo.TitleID);
            TitleEditor.TitleUpdateLocationData[] foundLocs = title.GetUpdateLocations();

            if (testInfo.Locations != null)
            {
                foreach (TitleUpdatePackageLocation loc in testInfo.Locations)
                {
                    bool found = false;
                    foreach (TitleEditor.TitleUpdateLocationData foundLoc in foundLocs)
                    {
                        if (CompareLocations(loc, foundLoc))
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        success = false;
                        Global.RO.Error("Did not find the expected location for title {0}, Rank {1}, XRL {2}", testInfo.TitleID, loc.Rank, loc.Xrl);
                    }
                }
            }

            TUPData[] foundPackages = title.GetUpdatePackages();

            TUPData[] expectedPackages = GetExpectedPackages(currentPackages, testInfo);

            if (!ComparePackages(foundPackages, expectedPackages)) // Don't mark it as true if the packages are correct
                success = false;

            if (!success) throw new Exception("One or more errors were found.");

        }

        private static bool ComparePackages(TUPData[] foundPackages, TUPData[] expectedPackages)
        {
            bool success = true;

            foreach (TUPData foundPackage in foundPackages)
            {
                bool found = false;

                foreach (TUPData expectedPackage in expectedPackages)
                {
                    if (ComparePackages(foundPackage, expectedPackage))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    Global.RO.Error("Found unexpected Title Update Package:  {0}", foundPackage.ToString());
                    success = false;
                }
            }

            foreach (TUPData expectedPackage in expectedPackages)
            {
                bool found = false;

                foreach (TUPData foundPackage in foundPackages)
                {
                    if (ComparePackages(foundPackage, expectedPackage))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    Global.RO.Error("Expected Title Update Package Missing:  {0}", expectedPackage.ToString());
                    success = false;
                }
            }

            return success;
        }

        private static bool ComparePackages(TitleEditor.TitleUpdatePackageData f, TitleEditor.TitleUpdatePackageData e)
        {
            if (f.BaseVersion != e.BaseVersion)
            {
                Global.RO.Error("Base Version Mismatch.  Expected:  {0}, Actual:  {1}", f.BaseVersion, e.BaseVersion);
                return false;
            }
            if (f.ConsoleType != e.ConsoleType)
            {
                Global.RO.Error("Console Type Mismatch.  Expected:  {0}, Actual:  {1}", f.ConsoleType, e.ConsoleType);
                return false;
            }

            if ((f.ContentId != e.ContentId) && (!f.ContentId.SequenceEqual(e.ContentId)))
            {
                Global.RO.Error("Content Id Mismatch.  Expected:  {0}, Actual:  {1}", f.ContentId, e.ContentId);
                return false;
            }
            if (f.InstallSize != e.InstallSize)
            {
                Global.RO.Error("Install Size Mismatch.  Expected:  {0}, Actual:  {1}", f.InstallSize, e.InstallSize);
                return false;
            }
            if (f.PackageSize != e.PackageSize)
            {
                Global.RO.Error("Package Size Mismatch.  Expected:  {0}, Actual:  {1}", f.PackageSize, e.PackageSize);
                return false;
            }
            if (!f.PublicKey.SequenceEqual(e.PublicKey))
            {
                Global.RO.Error("Public Key Mismatch.  Expected:  {0}, Actual:  {1}", f.PublicKey.ToString(), e.PublicKey.ToString());
                return false;
            }
            if (!f.UpdateSymmetricKey.SequenceEqual(e.UpdateSymmetricKey))
            {
                Global.RO.Error("Symmetric Key Mismatch.  Expected:  {0}, Actual:  {1}", f.UpdateSymmetricKey.ToString(), e.UpdateSymmetricKey.ToString());
                return false;
            }
            if (f.UpgradeVersion != e.UpgradeVersion)
            {
                Global.RO.Error("Upgrade Version Mismatch.  Expected:  {0}, Actual:  {1}", f.UpgradeVersion, e.UpgradeVersion);
                return false;
            }

            return true;
        }

        private static TUPData[] GetExpectedPackages(TUPData[] currentPackages, TitleUpdateTestInfo testInfo)
        {
            List<TUPData> results = new List<TUPData>();

            results.Add(ConvertTUPData(testInfo));

            foreach (TUPData data in currentPackages)
            {
                // First, check to see if it's an existing package below the one we're inserting.
                if ((data.BaseVersion < testInfo.UpdateVersion) &&
                    (data.ConsoleType == (byte)testInfo.Platform) &&
                    ((data.BaseVersion & 0xFF) == (testInfo.BaseVersion & 0xFF)) &&
                    (data.UpgradeVersion != (uint)testInfo.UpdateVersion) &&
                    (data.BaseVersion != (uint)testInfo.BaseVersion))
                {
                    TUPData newData = ConvertTUPData(testInfo);
                    newData.BaseVersion = data.BaseVersion;
                    results.Add(newData);
                }
                // Now check for any versions above the on we're inserting that we might upgrade to.
                else if ((data.UpgradeVersion > testInfo.UpdateVersion) &&
                         (data.ConsoleType == (byte)testInfo.Platform) &&
                         ((data.BaseVersion & 0xFF) == (testInfo.BaseVersion & 0xFF)) &&
                         (data.BaseVersion != (uint)testInfo.UpdateVersion))
                {
                    TUPData newData = data;
                    newData.BaseVersion = (uint)testInfo.BaseVersion;
                    results.Add(newData);
                }
            }

            return results.ToArray();
        }

        private static TitleEditor.TitleUpdatePackageData ConvertTUPData(TitleUpdateTestInfo testInfo)
        {
            if (testInfo.PackageInfo == null) return null;

            TUPData data = new TUPData();
            data.UpgradeVersion = (uint)testInfo.UpdateVersion;
            data.UpdateSymmetricKey = testInfo.PackageInfo.UpdateSymmetricKey;
            data.PublicKey = testInfo.PackageInfo.PublicKey;
            data.PackageSize = testInfo.PackageInfo.PackageSize;
            data.InstallSize = testInfo.PackageInfo.InstallSize;
            data.ContentId = testInfo.PackageInfo.ContentId;
            data.ConsoleType = (byte)testInfo.Platform;
            data.BaseVersion = (uint)testInfo.BaseVersion;
            return data;
        }

        private static bool CompareLocations(TitleUpdatePackageLocation loc, TitleEditor.TitleUpdateLocationData foundLoc)
        {
            return loc.Xrl.Equals(foundLoc.Xrl) && loc.Rank.Equals(foundLoc.Rank);
        }

    }

    public enum TitleUpdateTests
    {
        Basic,
        ZeroTitleID,
        UnproppedTitleID,
        ZeroUpgradeVersion,
        UpgradedBelowBase,
        InvalidPlatform,
        NullPackage,
        EmptyPackage,
        NullSymKey,
        ZeroLengthSymKey,
        NullPubKey,
        ZeroLengthPubKey,
        ZeroInstallSize,
        ZeroPackageSize,
        NullContentID,
        ZeroLengthContentID,
        NullLocations,
        ZeroLengthLocations,
        DuplicateRank,
        NullXRL,
        EmptyXRL,
        NullLocation,
        DupePackage,
        DupeLocation,
        MobileNullPackages,
        MobileZeroPackages
    }

    public class TitleUpdateTestInfo
    {
        public TitleUpdatePackageLocation[] Locations;
        public TitleUpdatePackageInformation PackageInfo;
        public uint TitleID;
        public int BaseVersion;
        public int UpdateVersion;
        public PlatformType Platform;
        public XHResult expectedHR;
    }




    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\TitleManagementV3WCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Linq;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Data;
using System.Text;

using ServerTestFramework;
//using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.StringServer;
using ServerTestFramework.Reporting;
using xonline.mix.common;

using xonline.common.config;
using xonline.common.tools.stutilcore;
//using xonline.mix.titlemanagement.contract;
using xonline.mix.titlemanagement.contracts.V3;
using xonline.common.xlastutil;

using Microsoft.Webstore.WstClient;

using MIXTestingUtilsV3;
using XHResult = xonline.common.service.HResult;
using TitleVersions = xonline.mix.titlemanagement.contracts.V3.TitleVersions;
using ServerTestFramework.Database;
using TUPData = ServerTestFramework.Database.TitleEditor.TitleUpdatePackageData;
using System.Collections.Generic;

namespace MIXTesting
{
    /// <summary>
    /// The TitleManagement WCF client. 
    /// This is the one location that contains all API calls for TitleManagement component.
    /// </summary>
    public class TitleManagementV3WCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixtitlemanagement/mixtitlemanagementv3.svc";

        public TitleManagementV3WCFClient()
        {
        }

        /// <summary>
        /// Create a new MixTitleManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixTitleManagementV3Client CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixtitlemanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixTitleManagementV3Client client = new MixTitleManagementV3Client(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureTitle. This is for normal use or positive tests.
        /// </summary>
        /// <param name="xlast"></param>
        public void ConfigureTitle(byte[] xlast)
        {
            ConfigureTitle(xlast, false, HResult.S_OK, false);
        }

        public void ConfigureTitle(byte[] xlast, bool noReload)
        {
            ConfigureTitle(xlast, noReload, HResult.S_OK, false);
        }

        /// <summary>
        /// API ConfigureTitle. This is for negative tests.
        /// </summary>
        /// <param name="xlast"></param>
        /// <param name="noReload"></param>
        /// <param name="expectedHR"></param>
        /// <param name="expectedRetryable"></param>
        public void ConfigureTitle(byte[] xlast, bool noReload, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureTitle", xlast, noReload);

            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        public void AddBaseVersion(TitleVersionInstance titleVersion)
        {
            AddBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            AddBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AddBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("AddBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        public void RemoveBaseVersion(TitleVersionInstance titleVersion)
        {
            RemoveBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            RemoveBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("RemoveBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }

        }

        public TitleVersions GetTitleVersions(uint titleId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleVersions versions = Invoke<TitleVersions>(CreateNewClient(), out hr, out retryable, out ex, "GetTitleVersions", titleId);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetTitleVersions call failed with HR = 0x" + hr.ToString("X"), ex);
            }

            return versions;
        }

        public void SetTitleUpdatePackages(
            uint titleId,
            int baseVersion,
            int updateVersion,
            PlatformType consoleType,
            TitleUpdatePackageInformation packageInformation,
            TitleUpdatePackageLocation[] updateLocations)
        {
            SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations, HResult.S_OK);
        }

        public void SetTitleUpdatePackages(
            uint titleId,
            int baseVersion,
            int updateVersion,
            PlatformType consoleType,
            TitleUpdatePackageInformation packageInformation,
            TitleUpdatePackageLocation[] updateLocations,
            XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetTitleUpdatePackages", titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);

            if (hr != expectedHR)
            {
                throw new UnexpectedTestResultException("SetTitleUpdatePackages call failed with HR = 0x" + hr.ToString("X"), ex);
            }

        }

        public UInt32[] GetBusinessPartnerTitleIDs(Guid businessPartnerID)
        {
            return GetBusinessPartnerTitleIDs(businessPartnerID, HResult.S_OK);
        }

        public UInt32[] GetBusinessPartnerTitleIDs(Guid businessPartnerID, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            UInt32[] titleIDs = Invoke<UInt32[]>(CreateNewClient(), out hr, out retryable, out ex, "GetBusinessPartnerTitleIDs", businessPartnerID);

            if (hr != expectedHR || ex != null)
            {
                throw new UnexpectedTestResultException("GetBusinessPartnerTitleIDs call failed  with HR = 0x" + hr.ToString("X8"), ex);
            }

            return titleIDs;
        }

        public void SetBusinessPartnerTitleIDs(Guid businessPartnerID, UInt32[] titleIDs)
        {
            SetBusinessPartnerTitleIDs(businessPartnerID, titleIDs, HResult.S_OK);
        }

        public void SetBusinessPartnerTitleIDs(Guid businessPartnerID, UInt32[] titleIDs, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetBusinessPartnerTitleIDs", businessPartnerID, titleIDs);

            if (hr != expectedHR || ex != null)
            {
                throw new UnexpectedTestResultException("SetBusinessPartnerTitleIDs call failed  with HR = 0x" + hr.ToString("X8"), ex);
            }
        }

        public TitleEndpointInfo[] GetNetworkSecurityList(UInt32 titleID, Boolean fullHistory)
        {
            return GetNetworkSecurityList(titleID, fullHistory, HResult.S_OK);
        }

        public TitleEndpointInfo[] GetNetworkSecurityList(UInt32 titleID, Boolean fullHistory, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleEndpointInfo[] endpoints = Invoke<TitleEndpointInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetNetworkSecurityList", titleID, fullHistory);

            if (hr != expectedHR || ex != null)
            {
                throw new UnexpectedTestResultException("GetNetworkSecurityList call failed  with HR = 0x" + hr.ToString("X8"), ex);
            }

            return endpoints;
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(String appliesTo, Boolean fullHistory)
        {
            return GetNetworkSecurityListByAppliesTo(appliesTo, fullHistory, HResult.S_OK);
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(String appliesTo, Boolean fullHistory, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleEndpointInfo[] endpoints = Invoke<TitleEndpointInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetNetworkSecurityListByAppliesTo", appliesTo, fullHistory);

            if (hr != expectedHR || ex != null)
            {
                throw new UnexpectedTestResultException("GetNetworkSecurityListByAppliesTo call failed  with HR = 0x" + hr.ToString("X8"), ex);
            }

            return endpoints;
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByEndpointAddress(String endpointAddress, Boolean fullHistory)
        {
            return GetNetworkSecurityListByEndpointAddress(endpointAddress, fullHistory, HResult.S_OK);
        }

        public TitleEndpointInfo[] GetNetworkSecurityListByEndpointAddress(String endpointAddress, Boolean fullHistory, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleEndpointInfo[] endpoints = Invoke<TitleEndpointInfo[]>(CreateNewClient(), out hr, out retryable, out ex, "GetNetworkSecurityListByEndpointAddress", endpointAddress, fullHistory);

            if (hr != expectedHR || ex != null)
            {
                throw new UnexpectedTestResultException("GetNetworkSecurityListByEndpointAddress call failed  with HR = 0x" + hr.ToString("X8"), ex);
            }

            return endpoints;
        }

        public void SetNetworkSecurityList(UInt32 titleID, TitleEndpoint[] allowedEndpoints)
        {
            SetNetworkSecurityList(titleID, allowedEndpoints, HResult.S_OK);
        }

        public void SetNetworkSecurityList(UInt32 titleID, TitleEndpoint[] allowedEndpoints, XHResult expectedHR)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SetNetworkSecurityList", titleID, allowedEndpoints);

            if (hr != expectedHR)
            {
                throw new UnexpectedTestResultException("SetNetworkSecurityList call failed with HR = 0x" + hr.ToString("X8"), ex);
            }
        }

        #region Utils

        public byte[] CompressXlast(string xlast)
        {
            return Gzip.Compress(xlast);
        }

        public string GetDropXlast(string file)
        {
            StreamReader streamReader = new StreamReader(file);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();
            return xlast;
        }

        public string GetXlast(string filename)
        {
            StreamReader streamReader = new StreamReader(string.Format("SuitesData\\MixTitleManagementTest\\{0}.xlast", filename));
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();
            return xlast;
        }

        public string GetXlast(uint titleID)
        {
            StreamReader streamReader = new StreamReader(string.Format("SuitesData\\MixTitleManagementTest\\{0:X}.xlast", titleID));
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();
            return xlast;
        }

        public string BulkTitlePath = @"\\shailesh1\mix\production_all\";
        public string[] GetBulkTitlesList()
        {
            //return BadTitles;
            return Directory.GetFiles(BulkTitlePath, "*.xlast", SearchOption.AllDirectories);
        }

        public string GetBulkXlast(string file)
        {
            string result = "";
            StreamReader streamReader = new StreamReader(file);
            result = streamReader.ReadToEnd();
            streamReader.Close();
            return result;
        }

        private TitleStringData[] GetLocalesFromXLSP(XboxLiveSubmissionProject xlsp)
        {
            TitleStringData[] results;

            LocalizedString titleName = XlastUtil.GetTitleNameLocalizeString(xlsp.GameConfigProject.LocalizedStrings);
            results = new TitleStringData[titleName.Translation.Length];

            for (int i = 0; i < titleName.Translation.Length; i++)
            {
                results[i] = new TitleStringData();
                results[i].index = titleName.id;
                results[i].locale = titleName.Translation[i].locale;
                results[i].title = Unescape(titleName.Translation[i].Value);
            }

            return results;
        }

        private string Unescape(string p)
        {
            string result = p;
            result = result.Replace("'", "''");

            return result;
        }

        public void Cleanup(uint titleID)
        {
            string deleteString = "delete from {0} where i_title_id=0x{1:X}";

            //Create NPDB object
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            // Perform NPDB deletes
            npdb.ExecuteScalar(string.Format(deleteString, "t_stringsvr_strings", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_live_title_config", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_game_config", titleID));
            // Clean up NPDB object
            npdb.Close();

            //Create WebDB object
            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            // Perform WebDB deletes
            webdb.IssueCommand(string.Format(deleteString, "t_title_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_raw_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_title_info", titleID));
            // Clean up WebDB object
            webdb.Close();

            //UODB does everything statically
            ExecuteUODBScalar(string.Format(deleteString, "t_title_trust_constants", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_info", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_alternate_titleids", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_offers", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_locations", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_packages", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_ratings", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_genres", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_culture_details", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_versions", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_titles", titleID));

        }

        public TEST_RESULTS propTitle(uint titleID)
        {
            // Get the byte array
            string xlast = GetXlast(titleID);
            byte[] compressedXLast = CompressXlast(xlast);

            // Set up the reload watcher
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
            change.Source = "Xkdc";
            change.Init();

            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);

            // Validate and clean up.
            bool success = ValidateSuccessfulProp(titleID, xlast);
            Cleanup(titleID);

            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            if (success)
            {
                bool reset = change.TestForChange("Reinitialize: completed reinitialization.");

                tr = (reset) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
            }

            return tr;
        }

        public void DeployTitle(uint titleID, uint baseVersion)
        {
            // Get the byte array
            string xlast = GetXlast(titleID);
            byte[] compressedXLast = CompressXlast(xlast);
            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);
        }


        public bool ValidateXlastAndCleanUp(uint titleID, string xlast)
        {
            bool tr = true;
            try
            {
                tr = ValidateSuccessfulProp(titleID, xlast);
                Cleanup(titleID);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                tr = false;
            }
            return tr;
        }

        public bool AddAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                AddBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersions(titleId, versions))
            {
                Global.RO.Error("Failed to successfully add versions!!");
                return false;
            }
            return true;
        }

        public bool RemoveAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersionsNotPresent(titleId, versions))
            {
                Global.RO.Error("Failed to successfully remove versions!");
                return false;
            }

            return true;
        }


        public void RemoveAllVersions(uint titleID)
        {
            TitleVersions actualVersions = GetTitleVersions(titleID);
            for (int i = 0; i < actualVersions.Versions.Length; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)actualVersions.Versions[i]);
            }
        }

        #endregion

        #region Validations

        public bool ValidateSuccessfulProp(uint titleID, string xlast)
        {
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);

            if (!validateNPDB(titleID, xlast, xlsp))
            {
                return false;
            }

            if (!validateWebDB(titleID, xlsp))
            {
                return false;
            }

            // Add StringSrv string validation
            if (!validateStringServer(titleID, xlsp))
            {
                return false;
            }

            return validateUODB(titleID, xlsp);
        }

        public bool validateStringServer(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            // We will issue the cacheflush to stringserver so it loads everything from the cache
            Global.XEnv.ExecuteXmgmtCommand(Interface.stringsvr, "e :stringsvr cacheflush");

            LocalizedStrings strings = xlsp.GameConfigProject.LocalizedStrings;
            if (strings != null)
            {
                LocalizedString ls = XlastUtil.GetTitleNameLocalizeString(strings);
                if ((null != ls) && (null != ls.Translation) && (ls.Translation.Length > 0))
                {
                    foreach (Translation t in ls.Translation)
                    {
                        XRLGet2String request = new XRLGet2String();
                        XRLGetStringResponse response;

                        request.dwTitleID = titleID;
                        request.wNumStrings = 1;
                        request.wLocaleLen = (ushort)t.locale.Length;
                        request.szLocale = t.locale;
                        request.rgdwStringIDs = new uint[1];
                        request.rgdwStringIDs[0] = 0x0;

                        // Let's make sure this is correctly loaded into string server
                        if (!request.Execute(out response))
                        {
                            return false;
                        }

                        int expectedLength = t.Value.Length;
                        if (t.locale == "zh-CHT" && titleID == 0x4D530888) // TODO: Make this less stupid for Lips
                        {
                            expectedLength *= 3;
                        }

                        if (response.wNumStrings != request.wNumStrings ||
                            response.rgStringData[0].wStringSize != expectedLength ||
                            response.rgStringData[0].szString != t.Value)
                            return false;
                    }
                }
            }

            return true;
        }

        public bool ValidateTitleVersions(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions actualVersions = GetTitleVersions(titleId);
            ArrayList actualVersionsDup = new ArrayList(actualVersions.Versions); // Temp dup so we can remove easily

            Global.RO.Info("Versions found for title:" + titleId.ToString("X"));
            for (int i = 0; i < actualVersionsDup.Count; ++i)
            {
                TitleVersionInstance titleVer = (TitleVersionInstance)actualVersionsDup[i];

                Global.RO.Info(String.Format("Title Id:{0}, Base Version:{1}, Update Version:{2}, Console Type:{3}, Beta Group:{4}", titleVer.TitleId.ToString("X"), titleVer.BaseVersion, titleVer.UpdateVersion, titleVer.PlatformType, titleVer.BetaGroup.ToString()));
            }

            if (actualVersionsDup.Count != expectedVersions.Count)
                return false;

            // Doing this manually since we are using the proxy which doesn't like our equals operator
            for (int evi = 0; evi < expectedVersions.Count; ++evi)
            {
                for (int avi = 0; avi < actualVersionsDup.Count; ++avi)
                {
                    if ((((TitleVersionInstance)actualVersionsDup[avi]).BaseVersion == ((TitleVersionInstance)expectedVersions[evi]).BaseVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).UpdateVersion == ((TitleVersionInstance)expectedVersions[evi]).UpdateVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).TitleId == ((TitleVersionInstance)expectedVersions[evi]).TitleId) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).PlatformType == ((TitleVersionInstance)expectedVersions[evi]).PlatformType) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).BetaGroup == ((TitleVersionInstance)expectedVersions[evi]).BetaGroup))
                    {
                        actualVersionsDup.RemoveAt(avi);
                        break;
                    }
                }

                //if (actualVersionsDup.Contains(expectedVersions[i]))
                //    actualVersionsDup.Remove(expectedVersions[i]);
            }

            if (actualVersionsDup.Count == 0)
                return true;

            return false;
        }

        public bool ValidateTitleVersionsNotPresent(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions existingVersions = GetTitleVersions(titleId);

            for (int i = 0; i < expectedVersions.Count; i++)
            {
                if (existingVersions.Versions.Contains(expectedVersions[i]))
                {
                    Global.RO.Warn("Removal of added versions FAILED.  Other tests may fail due to this failure.");
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region NPDB Validations
        private bool validateNPDB(uint titleID, string xlast, XboxLiveSubmissionProject xlsp)
        {
            string getTitleConfigQuery = string.Format("select xml_config from t_game_config where i_title_id=0x{0:X}", titleID);
            string titleString = "select * from t_stringsvr_strings where i_title_id=0x{0:X} and vc_locale='{1}' and i_string_id={2}";

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(getTitleConfigQuery, out reader);

                if (!reader.Read())
                {
                    Global.RO.Error("There was no game config saves to NPDB for " + titleID);
                    return false;
                }

                string proppedXlast = (string)reader.GetValue(reader.GetOrdinal("xml_config"));
                if (!proppedXlast.Equals(xlast))
                {
                    Global.RO.Error("The xlast stored in t_game_config did not match the one that wasd placed there!");
                    return false;
                }

                reader.Close();
                TitleStringData[] strings = GetLocalesFromXLSP(xlsp);
                foreach (TitleStringData tsd in strings)
                {
                    npdb.ReadData(String.Format(titleString, titleID, tsd.locale, 0), out reader);
                    if (!reader.Read())
                    {
                        Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in NPDB.  Expected: id=" + tsd.index);
                        reader.Close();
                        return false;
                    }
                    reader.Close();
                }
            }

            return true;

        }

        #endregion

        #region WebDB Validations

        private bool validateWebDB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (!ValidateWebDBTitleInfo(titleID, xlsp))
            {
                return false;
            }


            return ValidateWebDBTitleNameInfo(titleID, xlsp);
        }

        private bool ValidateWebDBTitleNameInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleNameQuery = "select * from t_title_name_info where i_title_id=0x{0:X} and vc_locale_id='{1}' and vc_display_name=N'{2}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();

            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            TitleStringData[] strings = GetLocalesFromXLSP(xlsp);

            foreach (TitleStringData tsd in strings)
            {

                SqlDataReader reader;
                webdb.ReadData(string.Format(titleNameQuery, titleID, tsd.locale, tsd.title), out reader);
                if (!reader.Read())
                {
                    Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in Webdb.  Expected: " + tsd.title);
                    reader.Close();
                    webdb.Close();
                    return false;
                }
                reader.Close();
            }
            webdb.Close();
            return true;
        }

        private bool ValidateWebDBTitleInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and vc_default_locale='{1}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            SqlDataReader reader;
            webdb.ReadData(string.Format(titleQuery, titleID, xlsp.GameConfigProject.LocalizedStrings.defaultLocale), out reader);
            if (!reader.Read())
            {
                webdb.Close();
                Global.RO.Error("The titleInfo was not present or was incorrect in WebDB.");
                return false;
            }

            webdb.Close();

            return true;
        }

        #endregion

        #region UODB Validations

        private bool validateUODB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (xlsp.GameConfigProject.ProductInformation != null)
            {
                if (xlsp.GameConfigProject.ProductInformation.Platform != null)
                {
                    if (!ValidateUODBTitle(titleID, xlsp))
                    {
                        return false;
                    }
                }


                if (xlsp.GameConfigProject.ProductInformation.Feature != null)
                {
                    bool? bRequiresValidation = GetRequiresValidation(xlsp);
                    if (null != bRequiresValidation)
                    {
                        if (!ValidateUODBRequiresActivation(titleID, xlsp, bRequiresValidation))
                        {
                            return false;
                        }
                    }
                }
            }

            return ValidateUODBTrustConstants(titleID);
        }

        private bool? GetRequiresValidation(XboxLiveSubmissionProject xlsp)
        {
            foreach (Feature f in xlsp.GameConfigProject.ProductInformation.Feature)
            {
                if (f.name == "pcServerSideActivation")
                {
                    return f.enabled;
                }
            }
            return null;
        }

        private bool ValidateUODBTrustConstants(uint titleID)
        {
            string titleQuery = "select * from t_title_trust_constants where i_title_id=0x{0:X}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
            {
                Global.RO.Error("The titleID was not inserted into uodb.dbo.t_title_trust_constants.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBRequiresActivation(uint titleID, XboxLiveSubmissionProject xlsp, bool? requiresActivation)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and ti_console_type_id={1} and f_requires_activation={2}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID, (byte)ConsoleTypeEnum.PC, ((bool)requiresActivation) ? 1 : 2), null))
            {
                Global.RO.Error("The RequiresValidation field in UODB either was not present or was incorrect.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBTitle(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_titles where i_title_id=0x{0:X}";

            ConsoleTypeEnum[] types = GetConsoleTypes(xlsp);

            foreach (ConsoleTypeEnum cte in types)
            {
                if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
                {
                    Global.RO.Error("The title was not present in UODB.");
                    return false;
                }
            }

            return true;
        }

        private ConsoleTypeEnum[] GetConsoleTypes(XboxLiveSubmissionProject xlsp)
        {
            ConsoleTypeEnum[] consoleTypes = new ConsoleTypeEnum[xlsp.GameConfigProject.ProductInformation.Platform.Length];

            for (int i = 0; i < xlsp.GameConfigProject.ProductInformation.Platform.Length; i++)
            {
                consoleTypes[i] = (ConsoleTypeEnum)xlsp.GameConfigProject.ProductInformation.Platform[i].id;
            }

            return consoleTypes;
        }

        #endregion

        #region SQLUtils

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be Scalar
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public static void ExecuteUODBScalar(string command)
        {
            int partitionCount;
            //get partition count
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList = new ArrayList();

            try
            {
                //open a connection for each partition
                for (int physicalPartition = 0; physicalPartition < partitionCount; physicalPartition++)
                {

                    WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(command, conn, physicalPartition);

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType = CommandType.Text;
                    cmd.PartitionType = WstPartitionType.Physical;

                    cmd.ExecuteScalar();

                }// for each partition

            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach (WstConnection conn in connectionList)
                {
                    conn.Close();
                }
            }
        }
        #endregion

        string[] BadTitles = new string[]
        {
            @"\\shailesh1\mix\production_all\535007e3\535007E3.xlast"
        };
    }
}

namespace MIXTestingUtilsV3
{
    public enum TM_Titles : uint
    {
        LIPS = 0x4D530888,
        BASIC = 0xFFFE1800,
        NULL_TITLE_ID = 0xFFFE1801,
        BASIC_REPROP = 0xFFFE1802,
        EXCEPTIONS = 0xFFFE1804
    }

    class TitleStringData
    {
        public string title = "";
        public int index = 0;
        public string locale = "";
    }

    public class Versions
    {
        public static ArrayList Basic = new ArrayList();
        public static ArrayList MultiVersion = new ArrayList();
        public static ArrayList MultiVersion_SecondHalf = new ArrayList();
        public static ArrayList MultiPlatform = new ArrayList();
        public static ArrayList MultiPlatform_SecondHalf = new ArrayList();
        public static ArrayList Lips = new ArrayList();
        public static ArrayList InvalidPlatform = new ArrayList();
        public static ArrayList Marketplace = new ArrayList();
        public static ArrayList InvalidTitle = new ArrayList();
        private static bool initialized = false;

        public static void Initialize()
        {
            if (!initialized)
            {
                initialized = true;

                // Basic
                TitleVersionInstance titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Basic.Add(titleVer);

                // MultiVersion
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                // MultiVersion_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion_SecondHalf.Add(titleVer);

                // MultiPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                // MultiPlatform_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform_SecondHalf.Add(titleVer);

                // Lips
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.LIPS;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Lips.Add(titleVer);

                // InvalidPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = (PlatformType)255;
                titleVer.BetaGroup = Guid.Empty;
                InvalidPlatform.Add(titleVer);

                // Marketplace
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Marketplace;
                titleVer.BetaGroup = Guid.Empty;
                Marketplace.Add(titleVer);

                // InvalidTitle
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = 0;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                InvalidTitle.Add(titleVer);
            }
        }
    }

    public class TitleUpdateUtils
    {
        public static readonly uint DefaultTitle = (uint)(TM_Titles.BASIC);
        public static readonly int DefaultBaseVersion = 0x20100000; // 2.0.1000.00
        public static readonly int DefaultUpgradeVersion = 0x20100100; //2.0.1001.00
        public static TitleUpdatePackageInformation DefaultPackage()
        {
            TitleUpdatePackageInformation package = new TitleUpdatePackageInformation();
            Random r = new Random();
            package.ContentId = RandomByte(20);
            package.InstallSize = 1234;
            package.PackageSize = 1235;
            package.PublicKey = RandomByte(2);
            package.UpdateSymmetricKey = RandomByte(2);

            return package;
        }

        private static byte[] RandomByte(int i)
        {
            Random r = new Random();
            byte[] result = new byte[i];
            r.NextBytes(result);
            return result;
        }

        public static TitleUpdatePackageLocation[] DefaultLocations()
        {
            TitleUpdatePackageLocation[] locations = new TitleUpdatePackageLocation[2];

            locations[0] = new TitleUpdatePackageLocation();
            locations[0].Rank = 0;
            locations[0].Xrl = "test/xrl/0";

            locations[1] = new TitleUpdatePackageLocation();
            locations[1].Rank = 1;
            locations[1].Xrl = "test/xrl/1";

            return locations;
        }

        public static TitleUpdateTestInfo DefaultTestInfo()
        {
            TitleUpdateTestInfo testInfo = new TitleUpdateTestInfo();
            testInfo.Locations = DefaultLocations();
            testInfo.PackageInfo = DefaultPackage();
            testInfo.TitleID = DefaultTitle; // We're ok with integer overflow in this scenario, because we just care about the bits.
            testInfo.BaseVersion = DefaultBaseVersion;      // 2.0.1000.00
            testInfo.UpdateVersion = DefaultUpgradeVersion; //2.0.1001.00
            testInfo.expectedHR = XHResult.XONLINE_E_MIX_UNKNOWNERROR;
            testInfo.Platform = PlatformType.Xenon;

            return testInfo;

        }

        static uint NONPROPPED_TITLE = 0x1;

        public static TitleUpdateTestInfo BuildTitleUpdateTest(TitleUpdateTests test)
        {
            TitleUpdateTestInfo testInfo = DefaultTestInfo();

            switch (test)
            {
                case TitleUpdateTests.Basic:
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroTitleID:
                    testInfo.TitleID = 0;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_INVALID_TITLE_ID;
                    break;
                case TitleUpdateTests.UnproppedTitleID:
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_INVALID_TITLE_ID;
                    testInfo.TitleID = NONPROPPED_TITLE;
                    break;
                case TitleUpdateTests.ZeroUpgradeVersion:
                    testInfo.UpdateVersion = 0;
                    testInfo.expectedHR = HResult.XONLINE_E_MIX_INVALID_VERSION;
                    break;
                case TitleUpdateTests.UpgradedBelowBase:
                    testInfo.BaseVersion = 0;
                    testInfo.expectedHR = HResult.XONLINE_E_MIX_INVALID_VERSION;
                    break;
                case TitleUpdateTests.NullPackage:
                    testInfo.PackageInfo = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.NullSymKey:
                    testInfo.PackageInfo.UpdateSymmetricKey = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthSymKey:
                    testInfo.PackageInfo.UpdateSymmetricKey = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.NullPubKey:
                    testInfo.PackageInfo.PublicKey = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthPubKey:
                    testInfo.PackageInfo.PublicKey = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.ZeroInstallSize:
                    testInfo.PackageInfo.InstallSize = 0;
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroPackageSize:
                    testInfo.PackageInfo.PackageSize = 0;
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.NullContentID:
                    testInfo.PackageInfo.ContentId = null;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;
                case TitleUpdateTests.ZeroLengthContentID:
                    testInfo.PackageInfo.ContentId = new byte[0];
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.NullLocations:
                    testInfo.Locations = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.ZeroLengthLocations:
                    testInfo.Locations = new TitleUpdatePackageLocation[0]; ;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_EMPTY;
                    break;
                case TitleUpdateTests.DuplicateRank:
                    testInfo.Locations[1].Rank = testInfo.Locations[0].Rank;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_DUPLICATE_RANK_NOT_ALLOWED;
                    break;
                case TitleUpdateTests.NullXRL:
                    testInfo.Locations[0].Xrl = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.EmptyXRL:
                    testInfo.Locations[0].Xrl = "";
                    testInfo.expectedHR = HResult.S_OK;
                    break;
                case TitleUpdateTests.NullLocation:
                    testInfo.Locations[0] = null;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_ARGUMENT_NULL;
                    break;
                case TitleUpdateTests.DupePackage:
                    break;
                case TitleUpdateTests.DupeLocation:
                    testInfo.Locations[1].Xrl = testInfo.Locations[0].Xrl;
                    testInfo.Locations[1].Rank = 99;
                    testInfo.expectedHR = XHResult.XONLINE_E_MIX_DUPLICATE_XRL_NOT_ALLOWED;
                    break;
                case TitleUpdateTests.MobileNullPackages:
                    testInfo.Locations = null;
                    testInfo.Platform = PlatformType.Mobile;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;
                case TitleUpdateTests.MobileZeroPackages:
                    testInfo.Locations = new TitleUpdatePackageLocation[0];
                    testInfo.Platform = PlatformType.Mobile;
                    testInfo.expectedHR = XHResult.S_OK;
                    break;

            }


            return testInfo;

        }

        public static void PerformTest(TitleUpdateTests test, MIXTesting.TitleManagementV3WCFClient client)
        {
            PerformTest(test, client, true);
        }

        public static void PerformTest(TitleUpdateTests test, MIXTesting.TitleManagementV3WCFClient client, bool cleanUp)
        {
            TitleUpdateTestInfo testInfo = BuildTitleUpdateTest(test);

            PerformTest(testInfo, client, cleanUp);
        }

        public static void PerformTest(TitleUpdateTestInfo testInfo, MIXTesting.TitleManagementV3WCFClient client, bool cleanUp)
        {
            TUPData[] currentPackages = null;

            try
            {
                if ((testInfo.TitleID != 0) && (testInfo.TitleID != NONPROPPED_TITLE))
                {
                    client.DeployTitle((uint)testInfo.TitleID, (uint)testInfo.BaseVersion);

                    TitleEditor title = TitleEditor.FromId((uint)testInfo.TitleID);
                    currentPackages = title.GetUpdatePackages(); // Save this for verification later.
                    client.AddBaseVersion((uint)testInfo.TitleID, testInfo.UpdateVersion, testInfo.Platform);
                }


                client.SetTitleUpdatePackages(
                    testInfo.TitleID,
                    testInfo.BaseVersion,
                    testInfo.UpdateVersion,
                    testInfo.Platform,
                    testInfo.PackageInfo,
                    testInfo.Locations,
                    testInfo.expectedHR);

                if (testInfo.expectedHR == HResult.S_OK) // We expect a pass, so we should verify the packages
                    VerifyUpgrades(testInfo, currentPackages);
            }
            finally
            {
                client.Cleanup((uint)testInfo.TitleID);
            }

        }

        private static void VerifyUpgrades(TitleUpdateTestInfo testInfo, TitleEditor.TitleUpdatePackageData[] currentPackages)
        {
            bool success = true;
            TitleEditor title = TitleEditor.FromId((uint)testInfo.TitleID);
            TitleEditor.TitleUpdateLocationData[] foundLocs = title.GetUpdateLocations();

            if (testInfo.Locations != null)
            {
                foreach (TitleUpdatePackageLocation loc in testInfo.Locations)
                {
                    bool found = false;
                    foreach (TitleEditor.TitleUpdateLocationData foundLoc in foundLocs)
                    {
                        if (CompareLocations(loc, foundLoc))
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        success = false;
                        Global.RO.Error("Did not find the expected location for title {0}, Rank {1}, XRL {2}", testInfo.TitleID, loc.Rank, loc.Xrl);
                    }
                }
            }

            TUPData[] foundPackages = title.GetUpdatePackages();

            TUPData[] expectedPackages = GetExpectedPackages(currentPackages, testInfo);

            if (!ComparePackages(foundPackages, expectedPackages)) // Don't mark it as true if the packages are correct
                success = false;

            if (!success) throw new Exception("One or more errors were found.");

        }

        private static bool ComparePackages(TUPData[] foundPackages, TUPData[] expectedPackages)
        {
            bool success = true;

            foreach (TUPData foundPackage in foundPackages)
            {
                bool found = false;

                foreach (TUPData expectedPackage in expectedPackages)
                {
                    if (ComparePackages(foundPackage, expectedPackage))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    Global.RO.Error("Found unexpected Title Update Package:  {0}", foundPackage.ToString());
                    success = false;
                }
            }

            foreach (TUPData expectedPackage in expectedPackages)
            {
                bool found = false;

                foreach (TUPData foundPackage in foundPackages)
                {
                    if (ComparePackages(foundPackage, expectedPackage))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    Global.RO.Error("Expected Title Update Package Missing:  {0}", expectedPackage.ToString());
                    success = false;
                }
            }

            return success;
        }

        private static bool ComparePackages(TitleEditor.TitleUpdatePackageData f, TitleEditor.TitleUpdatePackageData e)
        {
            if (f.BaseVersion != e.BaseVersion)
            {
                Global.RO.Error("Base Version Mismatch.  Expected:  {0}, Actual:  {1}", f.BaseVersion, e.BaseVersion);
                return false;
            }
            if (f.ConsoleType != e.ConsoleType)
            {
                Global.RO.Error("Console Type Mismatch.  Expected:  {0}, Actual:  {1}", f.ConsoleType, e.ConsoleType);
                return false;
            }

            if ((f.ContentId != e.ContentId) && (!f.ContentId.SequenceEqual(e.ContentId)))
            {
                Global.RO.Error("Content Id Mismatch.  Expected:  {0}, Actual:  {1}", f.ContentId, e.ContentId);
                return false;
            }
            if (f.InstallSize != e.InstallSize)
            {
                Global.RO.Error("Install Size Mismatch.  Expected:  {0}, Actual:  {1}", f.InstallSize, e.InstallSize);
                return false;
            }
            if (f.PackageSize != e.PackageSize)
            {
                Global.RO.Error("Package Size Mismatch.  Expected:  {0}, Actual:  {1}", f.PackageSize, e.PackageSize);
                return false;
            }
            if (!f.PublicKey.SequenceEqual(e.PublicKey))
            {
                Global.RO.Error("Public Key Mismatch.  Expected:  {0}, Actual:  {1}", f.PublicKey.ToString(), e.PublicKey.ToString());
                return false;
            }
            if (!f.UpdateSymmetricKey.SequenceEqual(e.UpdateSymmetricKey))
            {
                Global.RO.Error("Symmetric Key Mismatch.  Expected:  {0}, Actual:  {1}", f.UpdateSymmetricKey.ToString(), e.UpdateSymmetricKey.ToString());
                return false;
            }
            if (f.UpgradeVersion != e.UpgradeVersion)
            {
                Global.RO.Error("Upgrade Version Mismatch.  Expected:  {0}, Actual:  {1}", f.UpgradeVersion, e.UpgradeVersion);
                return false;
            }

            return true;
        }

        private static TUPData[] GetExpectedPackages(TUPData[] currentPackages, TitleUpdateTestInfo testInfo)
        {
            List<TUPData> results = new List<TUPData>();

            results.Add(ConvertTUPData(testInfo));

            foreach (TUPData data in currentPackages)
            {
                // First, check to see if it's an existing package below the one we're inserting.
                if ((data.BaseVersion < testInfo.UpdateVersion) &&
                    (data.ConsoleType == (byte)testInfo.Platform) &&
                    ((data.BaseVersion & 0xFF) == (testInfo.BaseVersion & 0xFF)) &&
                    (data.UpgradeVersion != (uint)testInfo.UpdateVersion) &&
                    (data.BaseVersion != (uint)testInfo.BaseVersion))
                {
                    TUPData newData = ConvertTUPData(testInfo);
                    newData.BaseVersion = data.BaseVersion;
                    results.Add(newData);
                }
                // Now check for any versions above the on we're inserting that we might upgrade to.
                else if ((data.UpgradeVersion > testInfo.UpdateVersion) &&
                         (data.ConsoleType == (byte)testInfo.Platform) &&
                         ((data.BaseVersion & 0xFF) == (testInfo.BaseVersion & 0xFF)) &&
                         (data.BaseVersion != (uint)testInfo.UpdateVersion))
                {
                    TUPData newData = data;
                    newData.BaseVersion = (uint)testInfo.BaseVersion;
                    results.Add(newData);
                }
            }

            return results.ToArray();
        }

        private static TitleEditor.TitleUpdatePackageData ConvertTUPData(TitleUpdateTestInfo testInfo)
        {
            if (testInfo.PackageInfo == null) return null;

            TUPData data = new TUPData();
            data.UpgradeVersion = (uint)testInfo.UpdateVersion;
            data.UpdateSymmetricKey = testInfo.PackageInfo.UpdateSymmetricKey;
            data.PublicKey = testInfo.PackageInfo.PublicKey;
            data.PackageSize = testInfo.PackageInfo.PackageSize;
            data.InstallSize = testInfo.PackageInfo.InstallSize;
            data.ContentId = testInfo.PackageInfo.ContentId;
            data.ConsoleType = (byte)testInfo.Platform;
            data.BaseVersion = (uint)testInfo.BaseVersion;
            return data;
        }

        private static bool CompareLocations(TitleUpdatePackageLocation loc, TitleEditor.TitleUpdateLocationData foundLoc)
        {
            return loc.Xrl.Equals(foundLoc.Xrl) && loc.Rank.Equals(foundLoc.Rank);
        }

    }

    public enum TitleUpdateTests
    {
        Basic,
        ZeroTitleID,
        UnproppedTitleID,
        ZeroUpgradeVersion,
        UpgradedBelowBase,
        InvalidPlatform,
        NullPackage,
        EmptyPackage,
        NullSymKey,
        ZeroLengthSymKey,
        NullPubKey,
        ZeroLengthPubKey,
        ZeroInstallSize,
        ZeroPackageSize,
        NullContentID,
        ZeroLengthContentID,
        NullLocations,
        ZeroLengthLocations,
        DuplicateRank,
        NullXRL,
        EmptyXRL,
        NullLocation,
        DupePackage,
        DupeLocation,
        MobileNullPackages,
        MobileZeroPackages
    }

    public class TitleUpdateTestInfo
    {
        public TitleUpdatePackageLocation[] Locations;
        public TitleUpdatePackageInformation PackageInfo;
        public uint TitleID;
        public int BaseVersion;
        public int UpdateVersion;
        public PlatformType Platform;
        public XHResult expectedHR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\TitleStats.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LiveStatsTest
{
	/// <summary>
	/// Base class for storing leaderboard data from the Xbox Live service.
	/// This class should not be used directly.
	/// </summary>
	public class TitleStatsBase
	{
        protected uint _titleId;
        protected string _gameConfigXml;
        protected string _ltcXml;
        protected LeaderboardCollection _leaderboards;
        protected InterfaceBucketCollection _interfaceBuckets;
        protected WebdbLeaderboardCollection _webLeaderboards;

		protected TitleStatsBase(uint titleId)
		{
            _titleId = titleId;
            _gameConfigXml = null;
            _ltcXml = null;
            _leaderboards = null;
            _interfaceBuckets = null;
            _webLeaderboards = null;
		}

        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        public string GameConfigXml
        {
            get { return _gameConfigXml; }
            set { _gameConfigXml = value; }
        }

        public string LiveTitleConfigXml
        {
            get { return _ltcXml; }
            set { _ltcXml = value; }
        }

        public LeaderboardCollection Leaderboards
        {
            get { return (_leaderboards == null ? new LeaderboardCollection() : _leaderboards); }
            set { _leaderboards = value; }
        }

        public InterfaceBucketCollection InterfaceBuckets
        {
            get { return (_interfaceBuckets == null ? new InterfaceBucketCollection() : _interfaceBuckets); }
            set { _interfaceBuckets = value; }
        }

        public WebdbLeaderboardCollection WebLeaderboards
        {
            get { return (_webLeaderboards == null ? new WebdbLeaderboardCollection() : _webLeaderboards); }
            set { _webLeaderboards = value; }
        }

        public virtual void Refresh()
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                GameConfigRow gc;
                LiveTitleConfigRow ltc;

                npdb.GetGameConfig(_titleId, out gc);
                _gameConfigXml = gc.XmlConfig;
                ltc = npdb.GetLiveTitleConfig(_titleId);
                _ltcXml = ltc.XmlTitleConfig;
                _leaderboards = npdb.GetLeaderboards(_titleId);
                _interfaceBuckets = npdb.GetInterfaceBuckets(_titleId);
            }
            finally
            {
                npdb.Close();
            }

            Webdb webdb = new Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            try
            {
                _webLeaderboards = webdb.GetLeaderboards(_titleId);
            }
            finally
            {
                webdb.Close();
            }
        }
	}

    /// <summary>
    /// Class used for retrieving leaderboard data from the Xbox Live service for Xbox 360 titles.
    /// </summary>
    public class Xbox360Stats : TitleStatsBase
    {
        public Xbox360Stats(uint titleId) : base(titleId) {}
        public static Xbox360Stats Create(uint titleId)
        {
            Xbox360Stats stats = new Xbox360Stats(titleId);
            stats.Refresh();
            return stats;
        }
    }

    /// <summary>
    /// Class used for retrieving leaderboard data from the Xbox Live service for Xbox 1 titles.
    /// </summary>
    public class Xbox1Stats : TitleStatsBase
    {
        protected LeaderboardCollection _templates;

        public Xbox1Stats(uint titleId) : base(titleId) {}
        public static Xbox1Stats Create(uint titleId)
        {
            Xbox1Stats stats = new Xbox1Stats(titleId);
            stats.Refresh();
            return stats;
        }

        public LeaderboardCollection CompetitionTemplates
        {
            get { return (_templates == null ? new LeaderboardCollection() : _templates); }
            set { _templates = value; }
        }

        public override void Refresh()
        {
            base.Refresh();

            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                _templates = npdb.GetCompetitionTemplates(_titleId);
            }
            finally
            {
                npdb.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\TokenManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.tokenmanagement.contracts.V1;

namespace MIXTesting
{
    /// <summary>
    /// The TokenManagement WCF client.
    /// This is the one location that contains all API calls for TokenManagement component.
    /// </summary>
    public class TokenManagementWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixtokenmanagement/mixtokenmanagementV1.svc";

        /// <summary>
        /// Create a new MixTokenManagementClient for each API call.
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixTokenManagementClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixtokenmanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            Global.RO.Info("Url: " + uri);
            EndpointAddress epa = new EndpointAddress(uri);
            MixTokenManagementClient client = new MixTokenManagementClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureTokenCategory. This is for normal use or positive tests.
        /// </summary>
        /// <param name="tokenCategory"></param>
        public void ConfigureTokenCategory(TokenCategory tokenCategory)
        {
            ConfigureTokenCategory(tokenCategory, HResult.S_OK, false);
        }

        /// <summary>
        /// API ConfigureTokenCategory. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public void ConfigureTokenCategory(TokenCategory tokenCategory, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureTokenCategory", tokenCategory);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        /// <summary>
        /// API GetTokenCategoryById. This is for normal use or positive tests.
        /// </summary>
        public TokenCategory GetTokenCategoryById(Guid id)
        {
            return GetTokenCategoryById(id, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenCategoryById. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenCategory GetTokenCategoryById(Guid id, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenCategory tokenCategory =
                Invoke<TokenCategory>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenCategoryById", id);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenCategory;
        }


        /// <summary>
        /// API GetTokenCategoryByName. This is for normal use or positive tests.
        /// </summary>
        public TokenCategory GetTokenCategoryByName(string name)
        {
            return GetTokenCategoryByName(name, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenCategoryByName. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenCategory GetTokenCategoryByName(string name, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenCategory tokenCategory =
                Invoke<TokenCategory>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenCategoryByName", name);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenCategory;
        }


        /// <summary>
        /// API GetTokenCategoryByOffer. This is for normal use or positive tests.
        /// </summary>
        public TokenCategory[] GetTokenCategoryByOffer(Guid offerId)
        {
            return GetTokenCategoryByOffer(offerId, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenCategoryByOffer. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenCategory[] GetTokenCategoryByOffer(Guid offerId, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenCategory[] tokenCategories =
                Invoke<TokenCategory[]>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenCategoryByOffer", offerId);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenCategories;
        }

        /// <summary>
        /// API GetTokenInfoByToken. This is for normal use or positive tests.
        /// </summary>
        public TokenInfo GetTokenInfoByToken(string token)
        {
            return GetTokenInfoByToken(token, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenInfoByToken. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenInfo GetTokenInfoByToken(string token, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenInfo tokenInfo =
                Invoke<TokenInfo>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenInfoByToken", token);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenInfo;
        }

        /// <summary>
        /// API GetTokenInfoByHash. This is for normal use or positive tests.
        /// </summary>
        public TokenInfo GetTokenInfoByHash(byte[] tokenHash)
        {
            return GetTokenInfoByHash(tokenHash, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenInfoByHash. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenInfo GetTokenInfoByHash(byte[] tokenHash, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenInfo tokenInfo =
                Invoke<TokenInfo>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenInfoByHash", tokenHash);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenInfo;
        }

        /// <summary>
        /// API GenerateTokens. This is for normal use or positive tests.
        /// </summary>
        public TokenJob GenerateTokens(Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest)
        {
            return GenerateTokens(tokenCategoryId, numTokens, key, HResult.S_OK, false, isTest);
        }

        /// <summary>
        /// API GenerateTokens. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenJob GenerateTokens(Guid tokenCategoryId, uint numTokens, byte[] key, uint expectedHR, bool expectedRetryable, bool isTest)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenJob tokenJob =
                Invoke<TokenJob>(CreateNewClient(), out hr, out retryable, out ex, "GenerateTokens", tokenCategoryId, numTokens, key, isTest);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenJob;
        }

        /// <summary>
        /// API GetTokenJobStatus. This is for normal use or positive tests.
        /// </summary>
        public TokenJobStatus GetTokenJobStatus(Guid jobId)
        {
            return GetTokenJobStatus(jobId, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenJobStatus. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenJobStatus GetTokenJobStatus(Guid jobId, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenJobStatus tokenJobStatus =
                Invoke<TokenJobStatus>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenJobStatus", jobId);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenJobStatus;
        }

        /// <summary>
        /// API GetTokenJobStatusByCategory. This is for normal use or positive tests.
        /// </summary>
        public TokenJobStatus[] GetTokenJobStatusByCategory(Guid tokenCategoryId)
        {
            return GetTokenJobStatusByCategory(tokenCategoryId, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokenJobStatusByCategory. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenJobStatus[] GetTokenJobStatusByCategory(Guid tokenCategoryId, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            TokenJobStatus[] tokenJobStatuses =
                Invoke<TokenJobStatus[]>(CreateNewClient(), out hr, out retryable, out ex, "GetTokenJobStatusByCategory", tokenCategoryId);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokenJobStatuses;
        }

        /// <summary>
        /// API GetTokens. This is for normal use or positive tests.
        /// </summary>
        public TokenEntry[] GetTokens(Guid jobId, byte[] key, int start, int count)
        {
            return GetTokens(jobId, key, start, count, HResult.S_OK, false);
        }

        /// <summary>
        /// API GetTokens 
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        ///
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public TokenEntry[] GetTokens(Guid jobId, byte[] key, int start, int count, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;
            object[] parameters = new object[4]{jobId, key, start, count};

            TokenEntry[] tokens =
            Invoke<TokenEntry[]>(CreateNewClient(), out hr, out retryable, out ex, "GetTokens", parameters);
            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
            return tokens;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\StorageWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Linq;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.common.tools.stutilcore;
using xonline.mix.storage.contracts.V1;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

using ServerTestFramework.LiveService.Storage;
using ServerTestFramework.Reporting;
using System.Threading;
using System.IO;

namespace MIXTesting
{
    /// <summary>
    /// The Storage WCF client. 
    /// This is the one location that contains all API calls for Storage component.
    /// </summary>
    public class StorageWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixstorage/mixstoragev1.svc";
        MixStorageClient client;

        public StorageWCFClient()
        {
            client = CreateNewClient();
        }
        /// <summary>
        /// Create a new MixStorageClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixStorageClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixstorage);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixStorageClient client = new MixStorageClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API SubmitItemToStorage. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="type"></param>
        /// <param name="imageID"></param>
        /// <param name="imageBlob"></param>
        public void SubmitItemToStorage(uint titleId, MIXFileType type, ulong imageID, byte[] imageBlob)
        {
            SubmitItemToStorage(titleId, type, imageID, imageBlob, HResult.S_OK, false);
        }

        /// <summary>
        /// API SubmitItemToStorage. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public void SubmitItemToStorage(uint titleId, MIXFileType type, ulong imageID, byte[] imageBlob, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SubmitFileToStorage", titleId, type, imageID, imageBlob);

            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        /// <summary>
        /// API SubmitAvatarImageToStorage. This is for normal use or positive tests.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="type"></param>
        /// <param name="avatarItemGuid"></param>
        /// <param name="imageBlob"></param>
        public void SubmitAvatarImageToStorage(uint titleId, MIXFileType type, Guid avatarItemGuid, byte[] imageBlob)
        {
            SubmitAvatarImageToStorage(titleId, type, avatarItemGuid, imageBlob, HResult.S_OK, false);
        }

        /// <summary>
        /// API SubmitAvatarImageToStorage. This is for negative tests.
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned as out parameters.
        /// Then verify the HR and Retryable are as expected. If not, an UnexpectedTestResultException is thrown.
        /// 
        /// For all other exceptions, an UnexpectedTestResultException is thrown.
        /// </summary>
        public void SubmitAvatarImageToStorage(uint titleId, MIXFileType type, Guid avatarItemGuid, byte[] imageBlob, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "SubmitAvatarImageToStorage", titleId, type, avatarItemGuid, imageBlob);

            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        #region Utils


        public readonly uint FakeTitleID = 0xFFFFFFFF;

        public bool SubmitFakeItem(MIXFileType type)
        {
            return SubmitFakeItem(type, true);
        }

        public bool SubmitFakeItem(MIXFileType type, bool verifyImage)
        {
            return SubmitFakeItem(FakeTitleID, type, RandomImageID(), RandomImage(), verifyImage);
        }

        public bool SubmitFakeItem(uint fakeTitle, MIXFileType type, ulong fakeImageID, byte[] image, bool verifyImage)
        {
            string path = GenerateFilePath(fakeTitle, type, fakeImageID);
            StUtil.Remove(0, 0, path, fakeTitle); // Make sure our slate is clean before we start

            SubmitItemToStorage(fakeTitle, type, fakeImageID, image);


            bool result = true;
            if (verifyImage)
            {
                result = VerifyFile(path, fakeTitle, image);
            }

            StUtil.Remove(0, 0, path, fakeTitle); // Clean up after ourselves

            return result;
        }

        public bool SubmitFakeAvatarItem()
        {
            return SubmitFakeAvatarItem(true);
        }

        public bool SubmitFakeAvatarItem(MIXFileType type)
        {
            return SubmitFakeAvatarItem(FakeTitleID, type, Guid.NewGuid(), RandomImage(), true);
        }

        public bool SubmitFakeAvatarItem(bool verifyImage)
        {
            return SubmitFakeAvatarItem(FakeTitleID, MIXFileType.Avatar64, Guid.NewGuid(), RandomImage(), verifyImage);
        }

        public bool SubmitFakeAvatarItem(uint fakeTitle, MIXFileType type, Guid fakeGuid, byte[] image, bool verifyImage)
        {
            string path = GenerateFilePath(fakeTitle, type, fakeGuid);
            StUtil.Remove(0, 0, path, fakeTitle); // Make sure our slate is clean before we start

            SubmitAvatarImageToStorage(fakeTitle, type, fakeGuid, image);

            bool result = true;
            if (verifyImage)
            {
                result = VerifyFile(path, fakeTitle, image);
            }

            StUtil.Remove(0, 0, path, fakeTitle); // Clean up after ourselves

            return result;
        }

        public bool VerifyFile(string path, uint title, byte[] image)
        {
            byte[] retrieved = StUtil.Read(0, 0, path, title);
            return (image.SequenceEqual(retrieved));
        }

        public string GenerateFilePath(uint titleId, MIXFileType type, ulong imageID)
        {
            string target = "";
            string strImageID = imageID.ToString("x");

            switch (type)
            {
                case MIXFileType.Avatar64:
                    target = "ach";
                    break;
                case MIXFileType.Achievement:
                    target = "ach";
                    break;
                case MIXFileType.GameIcon:
                    target = "icon";
                    strImageID = "8000";
                    break;
                case MIXFileType.Gamertile:
                    target = "tile";
                    break;
                case MIXFileType.MarketplaceIcon:
                    target = "marketplace";
                    strImageID = "1";
                    break;
                case MIXFileType.InGameMarketplaceBanner:
                    target = "marketplace";
                    break;
                default:
                    throw new Exception("Invalid image type specified.");

            }

            return String.Format("//global/t:{0:x}/{1}/0/{2}", titleId, target, strImageID);
        }

        public string GenerateFilePath(uint titleId, MIXFileType type, Guid avatarItemGuid)
        {
            string suffix = "";
            switch (type)
            {
                case MIXFileType.Avatar64:
                    suffix = "64";
                    break;
                case MIXFileType.Avatar128:
                    suffix = "128";
                    break;
                case MIXFileType.Avatar300:
                    suffix = "300";
                    break;
                case MIXFileType.AvatarDetails0:
                    suffix = "0";
                    break;
                case MIXFileType.AvatarDetails1:
                    suffix = "1";
                    break;
                case MIXFileType.AvatarDetails2:
                    suffix = "2";
                    break;
                case MIXFileType.AvatarDetails3:
                    suffix = "3";
                    break;
                case MIXFileType.AvatarDetails4:
                    suffix = "4";
                    break;
                case MIXFileType.AvatarDetails5:
                    suffix = "5";
                    break;
                case MIXFileType.AvatarDetails6:
                    suffix = "6";
                    break;
                case MIXFileType.AvatarDetails7:
                    suffix = "7";
                    break;
                case MIXFileType.AvatarDetails8:
                    suffix = "8";
                    break;
                case MIXFileType.AvatarDetails9:
                    suffix = "9";
                    break;
                default:
                    throw new Exception("Invalid image type specified.");
            }

            return String.Format("//global/t:{0:x}/avataritem/{1}/{2}", titleId, avatarItemGuid, suffix);
        }

        public byte[] RandomImage()
        {
            return RandomImage(1);
        }

        public byte[] RandomImage(ulong count)
        {
            Random r = new Random();
            byte[] result = new byte[count];
            for (ulong i = 0; i < count; i++)
            {
                result[i] = (byte)(r.Next() % 256);
            }

            return result;
        }

        private static Random r = new Random();
        public ulong RandomImageID()
        {
            ulong result = (ulong)r.Next();
            result <<= 32;
            result += (ulong)r.Next();
            return result;
        }

        public ulong retrieveFileCountQuota(uint titleID)
        {

            return getQuotas(titleID).totalFilesMax;
        }

        public ulong retrieveFileSizeQuota(uint titleID)
        {
            return getQuotas(titleID).totalBytesMax;
        }

        private XRLGetQuotaResponse getQuotas(uint titleID)
        {
            XRLGetQuota quota = new XRLGetQuota(6, titleID, 0, 0);
            XRLGetQuotaResponse response = null;
            quota.Execute(out response);
            return response;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Token\MixTokenHelper.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Text.RegularExpressions;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.ServiceModel;
using System.Text;
using System.Threading;
using System.Xml;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.billing;
using xonline.mix.tokenmanagement.contracts.V1;

namespace MIXTesting
{
    /// <summary>
    /// A simple class that creates some one use tokens and can be retrieved one by one. 
    /// </summary>
    public class TokenGenerator
    {
        int tokenIndex = 0;
        Guid tokenCategoryId;
        uint tokenCount = 0;
        List<string> tokenList = new List<string>();
        object lockObj = new object();

        public TokenGenerator(Guid tokenCategoryId, uint tokenCount)
        {
            this.tokenCategoryId = tokenCategoryId;
            this.tokenCount = tokenCount;
        }

        private void GenerateAndGetTokens()
        {
            if (tokenList == null || tokenList.Count == 0)
            {
                lock (lockObj)
                {
                    if (tokenList == null || tokenList.Count == 0)
                    {
                        // generate some tokens
                        Guid jobId = MixTokenHelper.GenerateTestTokens(tokenCategoryId, tokenCount, MixTokenHelper.Key, true, false);

                        // retrieve the tokens
                        TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                        if (tokenCount != tokens.Length)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expecting token count = {0}, but got = {1}", tokenCount, tokens.Length));
                        }

                        foreach (TokenEntry token in tokens)
                        {
                            tokenList.Add(token.Token);
                        }
                    }
                }
            }
        }

        public string GetNextToken()
        {
            GenerateAndGetTokens();

            lock (lockObj)
            {
                if (tokenIndex >= tokenList.Count)
                {
                    throw new UnexpectedTestResultException("Not enough tokens are created. Need to increase the value of TokenCount.");
                }

                return tokenList[tokenIndex++];
            }
        }
    }

    /// <summary>
    /// A helper class includes validation code, creating various objects
    /// and common data members
    /// </summary>
    public static class MixTokenHelper
    {
        public readonly static string AllZeroToken = "00000-00000-00000-00000-00000"; // used for some negatvie tests
        public readonly static byte[] Key = new byte[] { 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf };
        public readonly static int WaitTimeout = 600;   // 10 minutes

        private readonly static byte[] _fakeHash = new byte[] { 0x46, 0x0D, 0x1A, 0xBD, 0x93, 0x38, 0x33, 0xBA, 0xD5, 0x4F, 0x47, 0xBC, 0x83, 0xB0, 0x42, 0x26, 0xE9, 0xC9, 0x62, 0x23 };

        public readonly static Guid TexasHoldemArcadeOfferId = new Guid("00000001-0000-4000-8000-0000584107F6"); // BVT title 0x584107F6, Texas Holdem, full game
        public readonly static Guid ThreeMonthLiveSubscriptionOfferId = new Guid("80000019-0000-4000-8000-0000FFFE07D1"); // 3 month prepaid Live Subscription, 0xfffe07d180000019
        public readonly static string ThreeMonthLiveSubToken = "XRGRP-H3764-RRQPH-KPTX2-67R9Z"; // hash 0x35C3354784DDF9A633B5702F5136306F7730CB32 in TokenDB, 0xB3BFF59A36C57A2F52FACC9CB30EC7C0EF5A35C8 in CTP hash
        public readonly static string ThreeMonthLiveSubTokenOneTimeToken = "32KY3-XP7V3-7GJ23-RJ6W9-DWGMZ"; //hash 0xFBCE87737F089342BA52C21938B36720D5DD2863 in TokenDB, 0x35E7FC158A5E8E31F988C7054126ADD7E0A72C02
        public readonly static Guid ThreeMonthLiveSubTC = new Guid("771D76EB-2B88-4442-9C43-56FF8F97A194");
        public readonly static Guid PointsBundle1600OfferId = new Guid("0FF00021-0000-4000-8000-0000FFFE07D1"); // token-based 1600 Points Bundle Offer
        public readonly static Guid PointsBundle1600LiveTC = new Guid("5978B2E3-F3AA-4233-97C2-C310870D1C75");
        public readonly static string PointsBundle1600LiveToken = "997MY-HTVFD-66WQG-97D34-DYRDZ"; // hash 0x99802A6338C8B2731239A5839BBE38680F37473E in TokenDB, 0x7C8169514F5BCF62230B1F587935CD8DEECAD3EF in CTP hash
        public readonly static string PointsBundle1600LiveTokenOneTimeToken = "7T6FQ-TQMKW-JD4M3-F2XM9-WGM3Z"; //hash 0x47776CB526DF7F6D85FAD8371AF116EBFE2C05B5 in TokenDB, 0x0685CDDDC0025B56B0540BA0448AD96EF96FB220 in CTP hash
        public readonly static string InvalidToken = "6HK6X-T3G6W-77G7X-F7HM6-WRKDN";
        private static bool _importPointsOffersJobRanAlready = false;
        private static object _checkJobStatusLock = new object();

        /// <summary>
        /// Create a global token category shared by all the tests
        /// </summary>
        private static TokenCategory _tc = null;

        private static object lockObj = new object();
        public static TokenCategory GlobalTC
        {
            get
            {
                if (null == _tc)
                {
                    lock (lockObj)
                    {
                        if (null == _tc)
                        {
                            _tc = NewTokenCategory();
                            TokenManagementWCFClient client = new TokenManagementWCFClient();
                            client.ConfigureTokenCategory(_tc);
                        }
                    }
                }
                return _tc;
            }
        }

        /// <summary>
        /// Create new WebSG headers in the order
        /// 0 - Subject Name
        /// 1 - Client IP and Port
        /// 2 - Request Id
        /// </summary>
        /// <returns></returns>
        public static CustomHttpHeader[] CreateNewWebSGHeaders()
        {
            CustomHttpHeader header1 = new CustomHttpHeader(WCFClientBase.SubjectName, "DebugPartner");
            CustomHttpHeader header2 = new CustomHttpHeader(WCFClientBase.ClientIPPort, "1.1.1.1:1000");
            CustomHttpHeader header3 = new CustomHttpHeader(WCFClientBase.RequestId, WCFClientBase.GetRandomRequestId());
            CustomHttpHeader[] headers = new CustomHttpHeader[] { header1, header2, header3 };
            return headers;
        }

        /// <summary>
        /// create a new ChannelSKU object
        /// </summary>
        /// <param name="pkpn">the PKPN</param>
        /// <returns></returns>
        public static ChannelSKU NewChannelSKUObject(string pkpn)
        {
            ChannelSKU channelSku = new ChannelSKU();
            RandomEx randomEx = new RandomEx();
            channelSku.ID = "YYY-" + randomEx.GenerateNumberString(5);    // format of Channel SKU ID, XXX-01234

            channelSku.BOMQuantity = 10;
            channelSku.MaxPriceUSD = 10;
            channelSku.MinPriceUSD = 10;
            channelSku.PercentageAllocation = 1;

            return channelSku;
        }

        /// <summary>
        /// Create a new token category object. It is for Xbox only game tokens.
        /// TokenCategoryId, TokenCategoryName, PromotionId and PKPN are different each time
        /// </summary>
        /// <returns></returns>
        public static TokenCategory NewTokenCategory()
        {
            TokenCategory tc = new TokenCategory();
            tc.TokenCategoryId = Guid.NewGuid();
            tc.TokenCategoryName = "Arcade Token Category:" + tc.TokenCategoryId.ToString();
            tc.ExpirationDate = new DateTime(2099, 12, 31, 00, 00, 00);
            tc.OfferId = TexasHoldemArcadeOfferId;
            tc.PromotionId = Guid.NewGuid();
            tc.ProductTypeId = MediaTypeInfo.ArcadeGame;              // Arcade Game
            tc.InCsat = false;
            tc.IsRsm = true;
            RandomEx randomEx = new RandomEx();
            tc.Pkpn = "XXX-" + randomEx.GenerateNumberString(5);    // format of PKPN, XXX-01234
            tc.ChannelTypeId = 1;               // 0 - Etailer, 1 - retailer, 2 - POSA
            tc.IsRevenueBearing = false;
            tc.TokenType = "Fake Token Type";   // not used
            tc.IsRoyaltyBearing = false;
            tc.ChannelSKUArray = null;
            tc.IsRedeemable = true;             // set so that we can redeem these tokens by default

            return tc;
        }

        /// <summary>
        /// Create a new token category object In Csat. It is for game tokens in Csat (CIS tokens).
        /// Set up the ChannelSKU which needs to be sent to CTP
        /// </summary>
        /// <returns></returns>
        public static TokenCategory NewTokenCategoryInCsatArcadeGame()
        {
            TokenCategory tc = NewTokenCategory();
            tc.InCsat = true;
            tc.IsRevenueBearing = true;
            tc.IsRoyaltyBearing = true;
            tc.ChannelSKUArray = new ChannelSKU[2];
            tc.ChannelSKUArray[0] = NewChannelSKUObject(tc.Pkpn);
            tc.ChannelSKUArray[1] = NewChannelSKUObject(tc.Pkpn);

            return tc;
        }

        /// <summary>
        /// Create a new token category object In Csat. It is for Live Subscription in Csat.
        /// Set up the ChannelSKU which needs to be sent to CTP
        /// </summary>
        /// <returns></returns>
        public static TokenCategory NewTokenCategoryInCsatLiveSubscription()
        {
            TokenCategory tc = NewTokenCategory();
            tc.InCsat = true;
            tc.IsRevenueBearing = true;
            tc.IsRoyaltyBearing = true;
            tc.TokenCategoryName = "Xbox LIVE Gold: " + tc.TokenCategoryId.ToString();
            tc.OfferId = MixTokenHelper.ThreeMonthLiveSubscriptionOfferId;
            tc.ProductTypeId = MediaTypeInfo.LiveSubscription;
            tc.Pkpn = "X11-54809";

            return tc;
        }

        /// <summary>
        /// Create a new token category object In Csat. It is for Points Bundle in Csat.
        /// Set up the ChannelSKU which needs to be sent to CTP
        /// </summary>
        /// <returns></returns>
        public static TokenCategory NewTokenCategoryInCsatPointsBundle()
        {
            TokenCategory tc = NewTokenCategory();
            tc.InCsat = true;
            tc.IsRevenueBearing = true;
            tc.IsRoyaltyBearing = true;
            tc.TokenCategoryName = "Points Bundle 1600: " + tc.TokenCategoryId.ToString();
            tc.OfferId = MixTokenHelper.PointsBundle1600OfferId;
            tc.ProductTypeId = MediaTypeInfo.PointsBundle;
            tc.Pkpn = "x11-54823";

            return tc;
        }

        /// <summary>
        /// Make a copy of the token category object
        /// </summary>
        /// <param name="tc"></param>
        /// <returns></returns>
        public static TokenCategory CreateTokenCategoryFrom(TokenCategory tc)
        {
            TokenCategory newTC = new TokenCategory();
            newTC.TokenCategoryId = tc.TokenCategoryId;
            newTC.TokenCategoryName = tc.TokenCategoryName;
            newTC.ExpirationDate = tc.ExpirationDate;
            newTC.OfferId = tc.OfferId;
            newTC.PromotionId = tc.PromotionId;
            newTC.ProductTypeId = tc.ProductTypeId;
            newTC.InCsat = tc.InCsat;
            newTC.IsRsm = tc.IsRsm;
            newTC.Pkpn = tc.Pkpn;
            newTC.ChannelTypeId = tc.ChannelTypeId;
            newTC.IsRevenueBearing = tc.IsRevenueBearing;
            newTC.TokenType = tc.TokenType;
            newTC.ChannelSKUArray = tc.ChannelSKUArray;
            newTC.IsRoyaltyBearing = tc.IsRoyaltyBearing;
            newTC.IsRedeemable = tc.IsRedeemable;

            return newTC;
        }

        /// <summary>
        /// Verify the token category does not exist
        /// </summary>
        /// <param name="tc"></param>
        public static void VerifyTokenCategoryNotExist(TokenCategory tc)
        {
            // Verify by calling GetTokenCategoryById
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            client = new TokenManagementWCFClient();
            client.GetTokenCategoryById(tc.TokenCategoryId, HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
        }

        /// <summary>
        /// Verify one single token category
        /// </summary>
        /// <param name="tc"></param>
        public static void VerifyTokenCategory(TokenCategory tc)
        {
            VerifyTokenCategory(new TokenCategory[] { tc });
        }

        /// <summary>
        /// Verify if the Token Categories are the same as expected. The order is not enforced.
        /// If there are more than 1 in the array, all the Token Categories must be from the same OfferId
        /// </summary>
        public static void VerifyTokenCategory(TokenCategory[] tcs)
        {
            // Verify by calling both GetTokenCategoryByName and GetTokenCategoryById
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            foreach (TokenCategory tc in tcs)
            {
                TokenCategory tcGetBy;

                // Verify by calling GetTokenCategoryByName
                tcGetBy = client.GetTokenCategoryByName(tc.TokenCategoryName);
                CompareTwoTokenCategories(tc, tcGetBy);

                // Verify by calling GetTokenCategoryById
                client = new TokenManagementWCFClient();
                tcGetBy = client.GetTokenCategoryById(tc.TokenCategoryId);
                CompareTwoTokenCategories(tc, tcGetBy);
            }

            // Verify by calling GetTokenCategoryByOffer
            client = new TokenManagementWCFClient();
            TokenCategory[] tcsGetByOffer = client.GetTokenCategoryByOffer(tcs[0].OfferId);
            if (tcsGetByOffer.Length < tcs.Length)
            {
                    throw new UnexpectedTestResultException(string.Format("tcsGetByOffer.Length = {0} is smaller than tcs.Length = {1}", tcsGetByOffer.Length, tcs.Length));
            }
            foreach (TokenCategory tc in tcs)
            {
                bool bFound = false;
                foreach (TokenCategory tcGetByOffer in tcsGetByOffer)
                {
                    if (tcGetByOffer.TokenCategoryId == tc.TokenCategoryId)
                    {
                        CompareTwoTokenCategories(tc, tcGetByOffer);
                        bFound = true;
                        break;
                    }
                }
                if (!bFound)
                {
                    throw new UnexpectedTestResultException("Expecting Token Category with id = " + tc + ". But none found in the Mix Token Category array.");
                }
            }
        }

        /// <summary>
        /// Compare if two Token Categories are the same
        /// Two fields in TokenCategory are not saved in TokenDB, TokenType and ChannelSKUObject
        /// </summary>
        public static void CompareTwoTokenCategories(TokenCategory expectedTC, TokenCategory mixTC)
        {
            Global.RO.Info("Inside CompareTwoTokenCategories");
            ValueCheck.Test("TokenCategoryId", expectedTC.TokenCategoryId, mixTC.TokenCategoryId);
            ValueCheck.Test("TokenCategoryName", expectedTC.TokenCategoryName, mixTC.TokenCategoryName);
            ValueCheck.Test("Expireation Date", expectedTC.ExpirationDate, mixTC.ExpirationDate);
            ValueCheck.Test("Offer Id", expectedTC.OfferId, mixTC.OfferId);
            ValueCheck.Test("Promotion Id", expectedTC.PromotionId, mixTC.PromotionId);
            ValueCheck.Test("ProductTypeId", expectedTC.ProductTypeId, mixTC.ProductTypeId);
            ValueCheck.Test("InCSAT", expectedTC.InCsat, mixTC.InCsat);
            ValueCheck.Test("IsRsm", expectedTC.IsRsm, mixTC.IsRsm);
            ValueCheck.Test("PKPN", expectedTC.Pkpn, mixTC.Pkpn);
            ValueCheck.Test("ChannelTypeId", expectedTC.ChannelTypeId, mixTC.ChannelTypeId);
            ValueCheck.Test("IsRevenueBearing", expectedTC.IsRevenueBearing, mixTC.IsRevenueBearing);
            ValueCheck.Test("IsRoyaltyBearing", expectedTC.IsRoyaltyBearing, mixTC.IsRoyaltyBearing);
            ValueCheck.Test("IsRedeemable", expectedTC.IsRedeemable, mixTC.IsRedeemable);

            Global.RO.Info("CompareTwoTokenCategories passed ...");
        }


        /// <summary>
        /// Verify Token format
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        public static bool VerifyTokenFormat(string token)
        {
            // The valid token format is ?????-?????-?????-?????-????N format. (Last character must be N).
            // Where ? is 0-9, A-Z without 0,1,2,5,A,E,I,O,U,N,L,S,Z
            return (Regex.IsMatch(token, @"^[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{4}N$"));
        }

        /// <summary>
        ///  Verify an array of tokens
        /// </summary>
        public static void VerifyTokens(int tokenCount, TokenEntry[] tokenEntries, TokenCategory tc)
        {
            VerifyTokens(tokenCount, tokenEntries, tokenCount, tc);
        }
        
        /// <summary>
        ///  Verify only some of an array of tokens
        /// </summary>
        public static void VerifyTokens(int tokenCount, TokenEntry[] tokenEntries, int verifyCount, TokenCategory tc)
        {
            // verify the number of tokens returned is correct
            ValueCheck.Test("Total number of tokens returned", tokenCount, tokenEntries.Length);

            int index = 0;
            foreach (TokenEntry t in tokenEntries)
            {
                if (index >= verifyCount)
                {
                    Global.RO.Warn("Verify Token stopped at {0}, total count {1} -----", index, tokenCount);
                    break;
                }

                Global.RO.Warn("----- Verify Token #{0}/{1} -----", index, tokenCount);
                VerifyTokenFormat(t.Token);
                VerifyToken(t, tc);
                index++;
            }
        }

        /// <summary>
        ///  Verify one Token
        /// </summary>
        public static void VerifyToken(TokenEntry tokenEntry, TokenCategory tc)
        {
            // Print the TokenEntry first
            WCFTestBase.PrintObject(tokenEntry);

            TokenManagementWCFClient client = new TokenManagementWCFClient();
            TokenInfo tokenInfo1 = client.GetTokenInfoByToken(tokenEntry.Token);
            Global.RO.Info("Token = " + tokenEntry.Token);
            WCFTestBase.PrintObject(tokenInfo1);

            // Get TokenInfo for tokenHash value
            Global.RO.Info("Getting TokenInfo for tokenHash ");
            int hashLength = _fakeHash.Length;
            byte[] tokenHash = new byte[hashLength];

            using (SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider())
            {
                UnicodeEncoding enc = new UnicodeEncoding();
                byte[] keyBytes = enc.GetBytes(tokenEntry.Token + "\0");

                byte[] sha256Hash = sha256.ComputeHash(keyBytes);

                // _fakeHash contains the SHA1 hash of the "11111-11111-11111-11111-11111" token
                if (sha256Hash.Length > hashLength)
                {
                    Array.Copy(sha256Hash, tokenHash, hashLength);
                }
                else
                {
                    tokenHash = sha256Hash;
                }
            }

            StringBuilder hashText = new StringBuilder();
            foreach (byte b in tokenHash)
            {
                hashText.AppendFormat("{0:X}", b);
            }
            Global.RO.Info("Token Hash = " + hashText.ToString());

            client = new TokenManagementWCFClient();
            TokenInfo tokenInfo2 = client.GetTokenInfoByHash(tokenHash);
            WCFTestBase.PrintObject(tokenInfo2);

            // Compare both tokenInfo1 (derived by token) and tokenInfo2 (derived by hash)
            CompareTwoTokenInfo(tokenInfo1, tokenInfo2, tokenEntry);

            // Compare tokenInfo1 against tc (TokenCategory)
            CompareTwoTokenCategories(tokenInfo1.Category, tc);

            // Compare tokenInfo2 against tc (TokenCategory)
            CompareTwoTokenCategories(tokenInfo2.Category, tc);
        }

        /// <summary>
        ///  Compare two TokenInfo objects
        /// </summary>
        public static void CompareTwoTokenInfo(TokenInfo tokenInfo1, TokenInfo tokenInfo2, TokenEntry tokenEntry)
        {
            Global.RO.Info("Inside CompareTwoTokenInfo");
            // first compare the PKPN and Sequence number from token file
            ValueCheck.Test("SequenceNumber from Encrypted Token File", tokenInfo1.SequenceNumber, tokenEntry.SequenceNumber);
            ValueCheck.Test("PKPN from Encrypted Token File", tokenInfo1.Category.Pkpn, tokenEntry.Pkpn);

            // compare the two TokenInfo
            CompareTwoTokenCategories(tokenInfo1.Category, tokenInfo2.Category);
            ValueCheck.Test("ConsoleVersion", tokenInfo1.ConsoleVersion, tokenInfo2.ConsoleVersion);
            ValueCheck.Test("Hash", tokenInfo1.Hash, tokenInfo2.Hash);
            CompareTwoTokenRedemptions(tokenInfo1.Redemptions, tokenInfo2.Redemptions);
            ValueCheck.Test("SequenceNumber", tokenInfo1.SequenceNumber, tokenInfo2.SequenceNumber);
            ValueCheck.Test("StatusId", tokenInfo1.StatusId, tokenInfo2.StatusId);
            ValueCheck.Test("UseCount", tokenInfo1.UseCount, tokenInfo2.UseCount);

            Global.RO.Info("CompareTwoTokenInfo passed...");
        }

        /// <summary>
        /// Compare two TokenRedemptions array
        /// </summary>
        /// <param name="redemptions1"></param>
        /// <param name="redemptions2"></param>
        public static void CompareTwoTokenRedemptions(TokenRedemption[] redemptions1, TokenRedemption[] redemptions2)
        {
            Global.RO.Info("Inside CompareTwoTokenRedemptions");
            ValueCheck.Test("Size of TokenRedemptions array", redemptions1.Length, redemptions2.Length);
            for (int i = 0; i < redemptions1.Length; i++)
            {
                ValueCheck.Test("DateRedeemed", redemptions1[i].DateRedeemed, redemptions2[i].DateRedeemed);
                ValueCheck.Test("UserPuid", redemptions1[i].UserPuid, redemptions2[i].UserPuid);
            }
            Global.RO.Info("CompareTwoTokenRedemptions passed...");
        }

        /// <summary>
        /// Generate Tokens for the Test purposes
        /// </summary>
        public static Guid GenerateTestTokens(Guid tokenCategoryId, uint NumTestTokens, byte[] key, bool cronHealthCheck, bool isTest)
        {
            // Run health check URL
            if (cronHealthCheck)
                RunCronHealthCheck();

            Guid jobId = Guid.Empty;
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            TokenJob tokenJob = client.GenerateTokens(tokenCategoryId, NumTestTokens, key, isTest);
            Global.RO.Info("Got Token Job");
            WCFTestBase.PrintObject(tokenJob);

            return tokenJob.TokenJobId;
        }

        /// <summary>
        /// Generate Tokens for the Test purposes, with the specified token category
        /// </summary>
        public static Guid GenerateTestTokensWithNewTokenCategory(TokenCategory tokenCategory, uint NumTestTokens, byte[] key, bool cronHealthCheck, bool isTest)
        {
            // Run health check URL
            if (cronHealthCheck)
                RunCronHealthCheck();

            Guid jobId = Guid.Empty;
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            client.ConfigureTokenCategory(tokenCategory);
            TokenJob tokenJob = client.GenerateTokens(tokenCategory.TokenCategoryId, NumTestTokens, key, isTest);
            Global.RO.Info("Got Token Job");
            WCFTestBase.PrintObject(tokenJob);

            return tokenJob.TokenJobId;
        }


        /// <summary>
        /// Generate Tokens for more then one job for the Test purposes
        /// The fuction will wait until the Tokens are delivered
        /// </summary>
        public static Guid[] GenerateTestTokens(Guid tokenCategoryId, uint NumTestTokens, byte[] key, bool cronHealthCheck, int pendingJobCount, int staleJobCount, int waitTime, bool isTest)
        {
            TokenJob[] pendingTokenJobs = new TokenJob[pendingJobCount];
            TokenJob[] staleTokenJobs = new TokenJob[staleJobCount];
            int finishedJobCount = pendingJobCount + staleJobCount;
            Guid[] JobFinished = new Guid[finishedJobCount];
            int j = 0;
            int count = 0;


            TokenManagementWCFClient client = new TokenManagementWCFClient();

            for (int i = 0; i < staleTokenJobs.Length; i++)
            {
                staleTokenJobs[i] = client.GenerateTokens(tokenCategoryId, NumTestTokens, Key, isTest);
                Global.RO.Info("Got Token Job");
                WCFTestBase.PrintObject(staleTokenJobs[i]);

                //Change the Job Status to In Progress

                StaticNpdb.ExecuteNonQuery(String.Format("Update t_token_jobs set ti_job_status_id = 2 where uid_job_id = '{0}'", staleTokenJobs[i].TokenJobId));
                DateTime time = Convert.ToDateTime(StaticNpdb.ExecuteScalar(String.Format("Select dt_date_last_activity from t_token_jobs where uid_job_id = '{0}'", staleTokenJobs[i].TokenJobId)));
                DateTime newTime = time.AddMinutes(-60);

                //Change the Last Activity timestamp to an hour older
                StaticNpdb.ExecuteNonQuery(String.Format("Update t_token_jobs set dt_date_last_activity = '{0}'", newTime));
            }

            for (int i = 0; i < pendingTokenJobs.Length; i++)
            {
                pendingTokenJobs[i] = client.GenerateTokens(tokenCategoryId, NumTestTokens, key, false);
                Global.RO.Info("Got Token Job");
                WCFTestBase.PrintObject(pendingTokenJobs[i]);
            }

            Thread.Sleep(1000);

            // Run health check URL
            if (cronHealthCheck)
                RunCronHealthCheck();

            // Wait until the Pending Jobs are Delivered
            for (j = 0; j < pendingTokenJobs.Length; j++)
            {
                JobFinished[j] = CheckStatus(pendingTokenJobs[j].TokenJobId, client, waitTime);
            }

            //Wait until the Stale Jobs are Delivered
            while (j < finishedJobCount)
            {
                JobFinished[j++] = CheckStatus(staleTokenJobs[count].TokenJobId, client, waitTime);
                count++;
            }

            return JobFinished;
        }

        public static Guid CheckStatus(Guid tokenJobId, TokenManagementWCFClient client, int waitTime)
        {
            int tryTimes = 120;
            for ( int i = 0; i < tryTimes; i++ )
            {
                TokenJobStatus tokenJobStatus = client.GetTokenJobStatus(tokenJobId);
                Global.RO.Info("Querying token job {0} status @{1}:", tokenJobId, DateTime.Now);
                WCFTestBase.PrintObject(tokenJobStatus);

                if (tokenJobStatus.Status == TokenJobStatusEnum.Delivered)
                {
                    Global.RO.Info("Tokens Delivered");
                    return tokenJobId;
                }
                Thread.Sleep(waitTime);
            }
            throw new UnexpectedTestResultException("Job " + tokenJobId +  " didn't finished within the testing timeframe " + (tryTimes * waitTime) / 1000 + " seconds");
        }

        public static int GetFailedTokenJobStatus(Guid jobId, uint numFailures, int seconds)
        {
            return GetFailedTokenJobStatus(jobId, numFailures, seconds, TokenJobStatusEnum.Pending);
        }

        public static int GetFailedTokenJobStatus(Guid jobId, uint numFailures, int seconds, TokenJobStatusEnum tokenJobStatusEnum)
        {
            TokenManagementWCFClient client;
            TokenJobStatus tokenJobStatus;
            int interval = 10000;  // 10 seconds
            int count = (seconds * 1000 / interval) + 1;

            // Wait for the specified timeout value
            for (int i = 0; i < count; i++)
            {
                client = new TokenManagementWCFClient();
                tokenJobStatus = client.GetTokenJobStatus(jobId);
                Global.RO.Info("Querying token job status @{0} for JobId {1}:", DateTime.Now, jobId);
                WCFTestBase.PrintObject(tokenJobStatus);

                if (tokenJobStatus.Status == tokenJobStatusEnum && tokenJobStatus.NumFailures == numFailures)
                {
                    int hr = (int)StaticNpdb.ExecuteScalar("select i_hresult from dbo.t_token_jobs where uid_job_id = '" + jobId.ToString() + "'");
                    return hr;
                }

                // sleep
                Thread.Sleep(interval);
            }
            throw new UnexpectedTestResultException(string.Format("GetFailedTokenJobStatus, Job didn't finish within the testing timeframe: {0} seconds.", seconds));
        }

        /// <summary>
        /// Wait all jobs become delivered. Return the token count List
        /// </summary>
        /// <param name="jobs">job id array</param>
        /// <param name="seconds">timeout value</param>
        /// <returns>List of token count</returns>
        public static List<uint> WaitOnTokenJobs(Guid[] jobs, int seconds)
        {
            TokenManagementWCFClient client;
            TokenJobStatus tokenJobStatus;
            List<uint> tokenCounts = new List<uint>();
            List<Guid> deliveredJobs = new List<Guid>();
            int interval = 10000;  // 10 seconds
            int count = (seconds * 1000 / interval) + 1;

            // Wait until all the token jobs Delivered
            for (int i = 0; i < count; i++)
            {
                for (int jobNum = 0; jobNum < jobs.Length; jobNum++)
                {
                    // only query the jobs that have not done yet
                    if (deliveredJobs.Contains(jobs[jobNum]))
                        continue;

                    client = new TokenManagementWCFClient();
                    tokenJobStatus = client.GetTokenJobStatus(jobs[jobNum]);
                    Global.RO.Info("Querying token job status @{0} for JobId {1}:", DateTime.Now, jobs[jobNum]);
                    WCFTestBase.PrintObject(tokenJobStatus);

                    if (tokenJobStatus.Status == TokenJobStatusEnum.Delivered)
                    {
                        Global.RO.Info("Tokens Delivered for JobId {0}", jobs[jobNum]);
                        deliveredJobs.Add(jobs[jobNum]);
                        tokenCounts.Add(tokenJobStatus.NumTokensCompleted);
                        if (deliveredJobs.Count == jobs.Length)
                            return tokenCounts;
                    }
                }

                // sleep
                Thread.Sleep(interval);
            }
            throw new UnexpectedTestResultException(string.Format("Job didn't finish within the testing timeframe: {0} seconds.", seconds));
        }

        public static void WaitOnTokenJobs(Guid tokenCategoryId, int seconds)
        {
            TokenManagementWCFClient client;
            TokenJobStatus[] tokenJobStatuses;
            List<Guid> deliveredJobs = new List<Guid>();
            int interval = 10000;  // 10 seconds
            int count = (seconds * 1000 / interval) + 1;

            // Wait until all the token jobs Delivered
            for (int i = 0; i < count; i++)
            {
                client = new TokenManagementWCFClient();
                tokenJobStatuses = client.GetTokenJobStatusByCategory(tokenCategoryId);
                Global.RO.Info("Querying token job statuses @{0} for TokenCategoryId {1}:", DateTime.Now, tokenCategoryId);

                for (int jobNum = 0; jobNum < tokenJobStatuses.Length; jobNum++)
                {
                    // only inspect the jobs that have not done yet
                    if (deliveredJobs.Contains(tokenJobStatuses[jobNum].TokenJobId))
                        continue;

                    WCFTestBase.PrintObject(tokenJobStatuses[jobNum]);

                    if (tokenJobStatuses[jobNum].Status == TokenJobStatusEnum.Delivered)
                    {
                        Global.RO.Info("Tokens Delivered for JobId {0}",tokenJobStatuses[jobNum].TokenJobId);
                        deliveredJobs.Add(tokenJobStatuses[jobNum].TokenJobId);
                        if (deliveredJobs.Count == tokenJobStatuses.Length)
                            return;
                    }
                }

                // sleep
                Thread.Sleep(interval);
            }
            throw new UnexpectedTestResultException(string.Format("Job(s) didn't finish within the testing timeframe: {0} seconds.", seconds));
        }

        /// <summary>
        /// This job will wait until all the token jobs are marked as Failed within the specified time
        /// </summary>
        /// <param name="jobs"></param>
        /// <param name="seconds"></param>
        /// <returns>Array containing number of failures for the Jobs</returns>
        public static uint[] WaitOnFailedTokenJob(Guid[] jobs, int seconds)
        {
            TokenManagementWCFClient client;
            TokenJobStatus tokenJobStatus;
            List<Guid> failedJobs = new List<Guid>();
            int interval = 10000;  // 10 seconds
            int count = (seconds * 1000 / interval) + 1;
            uint[] numFailure = new uint[jobs.Length];

            // Wait until all the token jobs are marked as Failed
            for (int i = 0; i < count; i++)
            {
                for (int jobNum = 0; jobNum < jobs.Length; jobNum++)
                {
                    // only query the jobs that have not marked as Failed yet
                    if (failedJobs.Contains(jobs[jobNum]))
                        continue;

                    client = new TokenManagementWCFClient();
                    tokenJobStatus = client.GetTokenJobStatus(jobs[jobNum]);
                    Global.RO.Info("Querying token job status @{0} for JobId {1}:", DateTime.Now, jobs[jobNum]);
                    WCFTestBase.PrintObject(tokenJobStatus);

                    if (tokenJobStatus.Status == TokenJobStatusEnum.Failed)
                    {
                        Global.RO.Info("JobId {0} Failed", jobs[jobNum]);
                        failedJobs.Add(jobs[jobNum]);
                        numFailure[jobNum] = tokenJobStatus.NumFailures;
                        if (failedJobs.Count == jobs.Length)
                            return numFailure;
                    }
                }
                // sleep
                Thread.Sleep(interval);
            }
            throw new UnexpectedTestResultException(string.Format("Job didn't mrked as Failed within the testing timeframe: {0} seconds.", seconds));
        }

        /// <summary>
        /// This job will wait until all the token jobs are marked as Failed within the specified time
        /// </summary>
        /// <param name="tokenCategoryId"></param>
        /// <param name="seconds"></param>
        /// <returns>Array containing number of failures for the Jobs</returns>
        public static uint[] WaitOnFailedTokenJob(Guid tokenCategoryId, int seconds)
        {
            TokenManagementWCFClient client;
            TokenJobStatus[] tokenJobStatuses;
            List<Guid> failedJobs = new List<Guid>();
            int interval = 10000;  // 10 seconds
            int count = (seconds * 1000 / interval) + 1;
            uint[] numFailure = new uint[0];

            // Wait until all the token jobs are marked as Failed
            for (int i = 0; i < count; i++)
            {
                client = new TokenManagementWCFClient();
                tokenJobStatuses = client.GetTokenJobStatusByCategory(tokenCategoryId);
                Global.RO.Info("Querying token job statuses @{0} for TokenCategoryId {1}:", DateTime.Now, tokenCategoryId);

                if(numFailure.Length != tokenJobStatuses.Length)
                {
                    numFailure = new uint[tokenJobStatuses.Length];
                }

                for (int jobNum = 0; jobNum < tokenJobStatuses.Length; jobNum++)
                {
                    // only query the jobs that have not marked as Failed yet
                    if (failedJobs.Contains(tokenJobStatuses[jobNum].TokenJobId))
                        continue;

                    WCFTestBase.PrintObject(tokenJobStatuses[jobNum]);

                    if (tokenJobStatuses[jobNum].Status == TokenJobStatusEnum.Failed)
                    {
                        Global.RO.Info("JobId {0} Failed", tokenJobStatuses[jobNum].TokenJobId);
                        failedJobs.Add(tokenJobStatuses[jobNum].TokenJobId);
                        numFailure[jobNum] = tokenJobStatuses[jobNum].NumFailures;
                        if (failedJobs.Count == tokenJobStatuses.Length)
                            return numFailure;
                    }
                }
                // sleep
                Thread.Sleep(interval);
            }
            throw new UnexpectedTestResultException(string.Format("Job(s) didn't mrked as Failed within the testing timeframe: {0} seconds.", seconds));
        }

        public static string GetTokenFilePath(Guid jobId)
        {
            // Need to work around the Temporary hardcoded output directory in npdb (C:\TokenOutput)
            string path = Global.XEnv.GetSetting("tokenservice_finalOutputDirectory");
            if (path.Contains(":"))
            {
                path = path.Replace(':', '$');
                IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int);
                path = string.Format(@"\\{0}\{1}\{2}.xtx", ipEndPoint.Address.ToString(), path, jobId.ToString());
            }
            else
            {
                path = Path.Combine(path, jobId.ToString() + ".xtx");
            }

            return path;
        }

        public static void VerifyEncryptedTokenFileExist(Guid jobId, bool expectExist)
        {
            Global.RO.Info("Verify if encrypted token file exists");
            bool hasTokenFile = File.Exists(GetTokenFilePath(jobId));
            if (hasTokenFile != expectExist)
            {
                throw new UnexpectedTestResultException(string.Format("Encrypted Token file: expect exist = {0}, got exist ={1}. JobId = {2}", expectExist, hasTokenFile, jobId.ToString()));
            }
        }

        public static void VerifyTokenHashFileExist(Guid jobId, bool expectExist)
        {
            Global.RO.Info("Verify if token hash file exists");
            string tokenFileFolder = GetTokenFilePath(jobId).Replace((jobId.ToString() + ".xtx"), "");
            DirectoryInfo directoryInfo = new DirectoryInfo(tokenFileFolder);

            bool hasTokenHashFile = false;
            foreach (FileInfo file in directoryInfo.GetFiles())
            {
                if (file.Name.Contains(jobId.ToString() + "_Hash"))
                {
                    hasTokenHashFile = true;
                }
            }

            if (hasTokenHashFile != expectExist)
            {
                throw new UnexpectedTestResultException(string.Format("Token Hash file: expect exist = {0}, got exist ={1}. JobId = {2}", expectExist, hasTokenHashFile, jobId.ToString()));
            }
        }

        /// <summary>
        /// GetTokenEntries - This function will extract the list of tokens along with
        /// PKPN and sequence numbers associated with the jobId from the encrypted .xtx file
        /// </summary>
        public static TokenEntry[] GetTokenEntries( Guid jobId, byte[] key )
        {
            return GetTokenEntries( jobId, key, WaitTimeout );
        }

        /// <summary>
        /// GetTokenEntries - This function will extract the list of tokens along with
        /// PKPN and sequence numbers associated with the jobId from the encrypted .xtx file
        /// </summary>
        public static TokenEntry[] GetTokenEntries(Guid jobId, byte[] key, int timeout)
        {
            // wait for the token job to finish first
            List<uint> tokenCounts = WaitOnTokenJobs(new Guid[] { jobId }, timeout);

            // get all tokens by calling GetTokens multiple times
            int totalCount = (int)tokenCounts[0];
            int getTokensMaxCount = Global.XEnv.GetIntSetting("tokenService_maxNumTokens");
            TokenManagementWCFClient client = new TokenManagementWCFClient();

            List<TokenEntry> tokenEntries = new List<TokenEntry>(totalCount);
            int index = 1;
            int count = 1;
            while (index <= totalCount)
            {
                // GetTokens API the start is 1 based.
                count = totalCount - index + 1;
                if (count > getTokensMaxCount)
                    count = getTokensMaxCount;

                Global.RO.Warn(string.Format("------ Call Mix GetTokens, start={0}, count={1}, totalCount={2} ----", index, count, totalCount));
                TokenEntry[] tempEntries = client.GetTokens(jobId, key, index, count);
                tokenEntries.AddRange(tempEntries);
                index = index + count;
            }
            return tokenEntries.ToArray();
        }

        /// <summary>
        /// Validate Number of retires for the failure jobs is as expected
        /// </summary>
        /// <param name="numOfFailures">Number of failures returned by API GetTokenJobStatus</param>
        /// <param name="expectedFailureCount">Expected number of failures</param>
        /// <param name="jobs">Jobid's</param>
        public static void ThresholdValidation(uint[] numOfFailures, uint expectedFailureCount, Guid[] jobs)
        {
            for (int i = 0; i < jobs.Length; i++)
            {

                int failureInDB = Convert.ToInt32(StaticNpdb.ExecuteScalar(String.Format("SELECT COUNT(tjh.i_hresult) AS i_num_failures FROM dbo.t_token_jobs tj1 INNER JOIN dbo.t_token_job_history tjh ON (tjh.uid_job_id = tj1.uid_job_id) WHERE tj1.ti_job_status_id = 4 AND tjh.i_hresult IS NOT NULL and tjh.i_hresult <> 0 AND tjh.uid_job_id = '{0}' GROUP BY tjh.uid_job_id", jobs[i])));

                if (numOfFailures[i] != failureInDB)
                {
                    throw new UnexpectedTestResultException(String.Format("For JobId: {0} Number of failure returned by GetTokenJobStatus: {1} is not equal to the number of failures in t_token_job_history table: {2}", jobs[i], numOfFailures[i], failureInDB));
                }
                if (failureInDB != expectedFailureCount)
                {
                    throw new UnexpectedTestResultException(String.Format("For JobId: {0} Number of failure returned by GetTokenJobStatus: {1} and number of failure in t_token_job_history table: {2} is not equal to max threshold value: {3}", jobs[i], numOfFailures[i], failureInDB, expectedFailureCount));
                }
            }
        }

        #region CRON and Job Table Related Methods

        /// <summary>
        /// Run Cron Health Check URI
        /// </summary>
        public static void RunCronHealthCheck()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + "/cron/health.ashx?op=status";
            Global.RO.Info("Cron Health Check Url: " + uri);

            WebRequest req = WebRequest.Create(uri);
            WebResponse resp = req.GetResponse();
            Stream stream = resp.GetResponseStream();
            StreamReader sr = new StreamReader(stream);
            string s = sr.ReadToEnd();
            sr.Close();
            Global.RO.Info("Cron Started...");
        }

        private static Dictionary<string, string> _oldBucketInfo;
        private static List<string> _newBucketInfo = new List<string>();

        //Add new Cron Jobs(Buckets)
        public static void IncreaseNumberOfBucket(int bucketCount)
        {
            int i = 0;

            //fetch the existing buckets Info
            List<string[]> buckets = StaticNpdb.ExecuteQueryGetMultiple("Select vc_name, txt_args from t_cron_jobs where vc_assembly = 'TokenGeneratePlugIns.dll' order by vc_name asc");

            _oldBucketInfo = new Dictionary<string, string>();

            foreach (string[] bucket in buckets)
            {
                _oldBucketInfo.Add(bucket[0], bucket[1]);
            }

            //Update txt_args for the existing buckets(cron jobs) with new total number of buckets
            foreach (KeyValuePair<string, string> bucketInfo in _oldBucketInfo)
            {
                StaticNpdb.ExecuteNonQuery(String.Format("Update t_cron_jobs set txt_args = '<PluginContext>    <attribute name=\"bucketnumber\" type=\"System.Int32\">{0}</attribute>    <attribute name=\"totalbuckets\" type=\"System.Int32\">{1}</attribute>  </PluginContext>' where vc_name = '{2}'", i++, bucketCount, bucketInfo.Key));
            }

            int j = _oldBucketInfo.Count;

            //Add new Buckets
            while (j < bucketCount)
            {
                string txt_args = String.Format("'<PluginContext>    <attribute name=\"bucketnumber\" type=\"System.Int32\">{0}</attribute>    <attribute name=\"totalbuckets\" type=\"System.Int32\">{1}</attribute>  </PluginContext>'", j, bucketCount);
                string vc_name = String.Format("'TokenGeneration0{0}'", j);
                StaticNpdb.ExecuteNonQuery(String.Format("Insert into t_cron_jobs values ({0},-129071,'TokenGeneratePlugIns.dll','xonline.server.cron.plugins.TokenGeneratePlugIns.TokenGeneratePlugIn', {1}, '', '', 120, 2147483647, 120, '',1, '')", vc_name, txt_args));
                _newBucketInfo.Add(vc_name);
                j++;
            }
        }

        //Remove added Cron Jobs(Buckets)
        public static void RevertBackNumberOfBucket()
        {
            //Update txt_args for existing cron jobs to old state
            foreach (KeyValuePair<string, string> bukets in _oldBucketInfo)
            {
                StaticNpdb.ExecuteNonQuery(String.Format("Update t_cron_jobs set txt_args = '{0}' where vc_name = '{1}'", bukets.Value, bukets.Key));
            }

            //Delete newly added buckets
            foreach (string vcName in _newBucketInfo)
            {
                StaticNpdb.ExecuteNonQuery(String.Format("Delete from t_cron_jobs where vc_name = {0}", vcName));
            }
        }

        //Disables Cron by setting b_enabled = 0
        public static void DisableCron()
        {
            StaticNpdb.ExecuteNonQuery("UPDATE [dbo].[t_cron_jobs] SET b_enabled = 0 WHERE vc_assembly = 'TokenGeneratePlugIns.dll'");
        }

        //Enables Cron by setting b_enabled = 1
        public static void EnableCron()
        {
            StaticNpdb.ExecuteNonQuery("UPDATE [dbo].[t_cron_jobs] SET b_enabled = 1 WHERE vc_assembly = 'TokenGeneratePlugIns.dll'");
        }

        public static void SetTokenJobBIFField(Guid jobId, string behaviorInjection)
        {
            StaticNpdb.ExecuteNonQuery("update dbo.t_token_jobs set vc_behavior_injection = '" + behaviorInjection + "' where uid_job_id = '" + jobId.ToString() + "'");
        }

        #endregion

        public static void EnsureImportPointsJobIsRun()
        {
            //Don't run the job on every test - just the first time will import all the points offers into RawCatalogDB
            if (!_importPointsOffersJobRanAlready)
            {
                lock (_checkJobStatusLock)
                {
                    if (!_importPointsOffersJobRanAlready)
                    {
                        _importPointsOffersJobRanAlready = true;

                        //The job shouldn't take more than 30 seconds to run - even on production data because it only imports the offers
                        System.DateTime timeoutAt = System.DateTime.UtcNow.Add(new TimeSpan(0, 0, 30));
                        bool JobCompletedOK = false;

                        try
                        {
                            //Create a connection to RawCatalogDB for running the ImportOffersFromUODB job
                            IInterfaceInfo catalogConfig = xonline.common.config.Config.GetSingleInterface(xonline.common.config.Interface.ContentIngestionCatalogDB);
                            using (SqlConnection connection = new SqlConnection(catalogConfig.SqlConnectionString))
                            {
                                //Call the system proc to start the import job
                                connection.Open();
                                SqlCommand startCommand = new SqlCommand("msdb.dbo.sp_start_job @job_name=N'ImportOffersFromUODB'", connection);
                                startCommand.ExecuteNonQuery();
                                Global.RO.Info("Started the ImportOffersFromUODB job.");

                                //Keep checking the job status until the job completes (successfully or unsuccessfully)
                                // or the 'timeout' period elapses
                                while (System.DateTime.UtcNow < timeoutAt && !JobCompletedOK)
                                {
                                    SqlCommand statusCommand = new SqlCommand("msdb.dbo.sp_help_jobactivity @job_name=N'ImportOffersFromUODB'", connection);
                                    using (SqlDataReader reader = statusCommand.ExecuteReader())
                                    {
                                        //Query for the status of the SQL job
                                        reader.Read();
                                        if (reader.IsDBNull(reader.GetOrdinal("run_status")))
                                        {
                                            //The job isn't complete yet, wait one second before checking again
                                            Global.RO.Info("The ImportOffersFromUODB job has not completed yet, checking again in five seconds...");
                                            System.Threading.Thread.Sleep(5000);
                                        }
                                        else
                                        {
                                            //Ther job has completed, check whether it's successful or not
                                            if (reader.GetInt32(reader.GetOrdinal("run_status")) == 1)
                                            {
                                                JobCompletedOK = true;
                                            }
                                            else
                                            {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            Global.RO.Warn("Encountered an exception running the ImportOffersFromUODB job: " + ex.Message);
                        }

                        if (JobCompletedOK)
                        {
                            Global.RO.Info("The ImportOffersFromUODB job has completed.");
                        }
                        else
                        {
                            Global.RO.Info("The ImportOffersFromUODB job did not complete successfully, please see the job history for more details.");
                        }

                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\TitleManagementWCFClient.cs ===
using System;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.Xml.Serialization;
using System.ServiceModel;
using System.Linq;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Text;

using ServerTestFramework;
//using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Reporting;
using xonline.mix.common;

using xonline.common.config;
using xonline.common.tools.stutilcore;
//using xonline.mix.titlemanagement.contract;
using xonline.mix.titlemanagement.contracts.V1;
using xonline.common.xlastutil;

using Microsoft.Webstore.WstClient;

using MIXTestingUtilsV1;

namespace MIXTesting
{
    /// <summary>
    /// The TitleManagement WCF client. 
    /// This is the one location that contains all API calls for TitleManagement component.
    /// </summary>
    public class TitleManagementWCFClient : WCFClientBase
    {
        public readonly static string Url = "/mixtitlemanagement/mixtitlemanagementv1.svc";

        public TitleManagementWCFClient()
        {
        }

        /// <summary>
        /// Create a new MixTitleManagementClient for each API call. 
        /// When the API returns, the client is closed.
        /// We don't reuse client or proxy.
        /// </summary>
        /// <returns></returns>
        protected MixTitleManagementClient CreateNewClient()
        {
            IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixtitlemanagement);
            string uri = "http://" + ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString() + Url;
            EndpointAddress epa = new EndpointAddress(uri);
            MixTitleManagementClient client = new MixTitleManagementClient(wsb, epa);
            return client;
        }

        /// <summary>
        /// API ConfigureTitle. This is for normal use or positive tests.
        /// </summary>
        /// <param name="xlast"></param>
        public void ConfigureTitle(byte[] xlast)
        {
            ConfigureTitle(xlast, false, HResult.S_OK, false);
        }

        public void ConfigureTitle(byte[] xlast, bool noReload)
        {
            ConfigureTitle(xlast, noReload, HResult.S_OK, false);
        }

        /// <summary>
        /// API ConfigureTitle. This is for negative tests.
        /// </summary>
        /// <param name="xlast"></param>
        /// <param name="noReload"></param>
        /// <param name="expectedHR"></param>
        /// <param name="expectedRetryable"></param>
        public void ConfigureTitle(byte[] xlast, bool noReload, uint expectedHR, bool expectedRetryable)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "ConfigureTitle", xlast, noReload);

            if (hr != expectedHR || retryable != expectedRetryable)
            {
                throw new UnexpectedTestResultException(string.Format("Expected HR = 0x{0:X}, got = 0x{1:X}; Expected Retryable = {2}, got = {3}",
                    expectedHR, hr, expectedRetryable, retryable));
            }
        }

        public void AddBaseVersion(TitleVersionInstance titleVersion)
        {
            AddBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            AddBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "AddBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("AddBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }
        }

        public void RemoveBaseVersion(TitleVersionInstance titleVersion)
        {
            RemoveBaseVersion(titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.PlatformType, titleVersion.BetaGroup);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType)
        {
            RemoveBaseVersion(titleId, version, platformType, Guid.Empty);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            Invoke<NoReturn>(CreateNewClient(), out hr, out retryable, out ex, "RemoveBaseVersion", titleId, version, platformType, betaGroup);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("RemoveBaseVersion call failed with HR = 0x" + hr.ToString("X"), ex);
            }

        }

        public TitleVersions GetTitleVersions(uint titleId)
        {
            uint hr = HResult.S_OK;
            bool retryable = false;
            Exception ex = null;

            TitleVersions versions = Invoke<TitleVersions>(CreateNewClient(), out hr, out retryable, out ex, "GetTitleVersions", titleId);

            if (hr != HResult.S_OK || ex != null)
            {
                throw new UnexpectedTestResultException("GetTitleVersions call failed with HR = 0x" + hr.ToString("X"), ex);
            }

            return versions;
        }

        #region Utils

        public byte[] CompressXlast(string xlast)
        {
            return Gzip.Compress(xlast);
        }

        public string GetDropXlast(string file)
        {
            StreamReader streamReader = new StreamReader(file);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();
            return xlast;
        }

        public string GetXlast(string filename)
        {
            StreamReader streamReader = new StreamReader(filename);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();

            //Check if it is mobile title
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);
            string locFile = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";

            Dictionary<string, string> colLocalizationData =
            MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(locFile);

            //If MobileTitle convert it to general format where each FriendStatsView is mapped to two StatsView leaderboard nodes
            if (isMobileTitle)
            {
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, colLocalizationData);
            }

            XmlSerializer serializer = new XmlSerializer(xlsp.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, xlsp);
                xlast = writer.ToString();
            }

            return xlast;
        }


        public string GetXlast_WithoutMobileConversion(string filename)
        {
            StreamReader streamReader = new StreamReader(filename);
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();

            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
            
            XmlSerializer serializer = new XmlSerializer(xlsp.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, xlsp);
                xlast = writer.ToString();
            }

            return xlast;
        }

        public string GetXlast(uint titleID)
        {
            StreamReader streamReader = new StreamReader(string.Format("SuitesData\\MixTitleManagementTest\\{0:X}.xlast", titleID));
            string xlast = streamReader.ReadToEnd();
            streamReader.Close();

            //Check if it is mobile title
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);
            string locFile = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";

            Dictionary<string, string> colLocalizationData =
            MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(locFile);

            //If MobileTitle convert it to general format where each FriendStatsView is mapped to two StatsView leaderboard nodes
            if (isMobileTitle)
            {
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, colLocalizationData);
            }

            XmlSerializer serializer = new XmlSerializer(xlsp.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, xlsp);
                xlast = writer.ToString();
            }

            return xlast;
        }

        public string BulkTitlePath = @"\\shailesh1\mix\production_all\";
        public string[] GetBulkTitlesList()
        {
            //return BadTitles;
            return Directory.GetFiles(BulkTitlePath, "*.xlast", SearchOption.AllDirectories);
        }

        public string GetBulkXlast(string file)
        {
            string result = "";
            StreamReader streamReader = new StreamReader(file);
            result = streamReader.ReadToEnd();
            streamReader.Close();
            return result;
        }

        private TitleStringData[] GetLocalesFromXLSP(XboxLiveSubmissionProject xlsp)
        {
            TitleStringData[] results;

            LocalizedString titleName = XlastUtil.GetTitleNameLocalizeString(xlsp.GameConfigProject.LocalizedStrings);
            results = new TitleStringData[titleName.Translation.Length];

            for (int i = 0; i < titleName.Translation.Length; i++)
            {
                results[i] = new TitleStringData();
                results[i].index = titleName.id;
                results[i].locale = titleName.Translation[i].locale;
                results[i].title = Unescape(titleName.Translation[i].Value);
            }

            return results;
        }

        private string Unescape(string p)
        {
            string result = p;
            result = result.Replace("'", "''");

            return result;
        }

        public void Cleanup(uint titleID)
        {
            string deleteString = "delete from {0} where i_title_id=0x{1:X}";

            //Create NPDB object
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            // Perform NPDB deletes
            npdb.ExecuteScalar(string.Format(deleteString, "t_stringsvr_strings", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_live_title_config", titleID));
            npdb.ExecuteScalar(string.Format(deleteString, "t_game_config", titleID));
            // Clean up NPDB object
            npdb.Close();

            //Create WebDB object
            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));
            // Perform WebDB deletes
            webdb.IssueCommand(string.Format(deleteString, "t_title_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_raw_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_name_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_formatted_attribute_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_leaderboard_info", titleID));
            webdb.IssueCommand(string.Format(deleteString, "t_title_info", titleID));
            // Clean up WebDB object
            webdb.Close();

            //UODB does everything statically
            ExecuteUODBScalar(string.Format(deleteString, "t_title_trust_constants", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_info", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_alternate_titleids", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_offers", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_locations", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_update_packages", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_ratings", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_genres", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_culture_details", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_title_versions", titleID));
            ExecuteUODBScalar(string.Format(deleteString, "t_titles", titleID));

        }

        public TEST_RESULTS propTitle(uint titleID)
        {
            // Get the byte array
            string xlast = GetXlast(titleID);
            byte[] compressedXLast = CompressXlast(xlast);

            // Set up the reload watcher
            string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
            ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
            change.Source = "Xkdc";
            change.Init();

            // Add a version

            AddBaseVersion(titleID, 1, PlatformType.Xenon);

            // Configure the title
            ConfigureTitle(compressedXLast);

            // Validate and clean up.
            bool success = ValidateSuccessfulProp(titleID, xlast);
            Cleanup(titleID);

            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            if (success)
            {
                bool reset = change.TestForChange("Reinitialize: completed reinitialization.");

                tr = (reset) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
            }
            
            return tr;
        }

        public bool ValidateXlastAndCleanUp(uint titleID, string xlast)
        {
            bool tr = true;
            try
            {
                tr = ValidateSuccessfulProp(titleID, xlast);
                Cleanup(titleID);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                tr = false;
            }
            return tr;
        }

        public bool AddAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                AddBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersions(titleId, versions))
            {
                Global.RO.Error("Failed to successfully add versions!!");
                return false;
            }
            return true;
        }

        public bool RemoveAndVerifyVersions(uint titleId, ArrayList versions)
        {
            for (int i = 0; i < versions.Count; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)versions[i]);
            }

            if (!ValidateTitleVersionsNotPresent(titleId, versions))
            {
                Global.RO.Error("Failed to successfully remove versions!");
                return false;
            }

            return true;
        }


        public void RemoveAllVersions(uint titleID)
        {
            TitleVersions actualVersions = GetTitleVersions(titleID);
            for (int i = 0; i < actualVersions.Versions.Length; i++)
            {
                RemoveBaseVersion((TitleVersionInstance)actualVersions.Versions[i]);
            }
        }

        #endregion

        #region Validations

        public bool ValidateSuccessfulProp(uint titleID, string xlast)
        {
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);

            if (!validateNPDB(titleID, xlast, xlsp))
            {
                return false;
            }

            if (!validateWebDB(titleID, xlsp))
            {
                return false;
            }

            return validateUODB(titleID, xlsp);
        }

        public bool ValidateTitleVersions(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions actualVersions = GetTitleVersions(titleId);
            ArrayList actualVersionsDup = new ArrayList(actualVersions.Versions); // Temp dup so we can remove easily

            Global.RO.Info("Versions found for title:" + titleId.ToString("X"));
            for (int i = 0; i < actualVersionsDup.Count; ++i)
            {
                TitleVersionInstance titleVer = (TitleVersionInstance)actualVersionsDup[i];

                Global.RO.Info(String.Format("Title Id:{0}, Base Version:{1}, Update Version:{2}, Console Type:{3}, Beta Group:{4}", titleVer.TitleId.ToString("X"), titleVer.BaseVersion, titleVer.UpdateVersion, titleVer.PlatformType, titleVer.BetaGroup.ToString()));
            }

            if (actualVersionsDup.Count != expectedVersions.Count)
                return false;

            // Doing this manually since we are using the proxy which doesn't like our equals operator
            for (int evi = 0; evi < expectedVersions.Count; ++evi)
            {
                for (int avi = 0; avi < actualVersionsDup.Count; ++avi)
                {
                    if ((((TitleVersionInstance)actualVersionsDup[avi]).BaseVersion == ((TitleVersionInstance)expectedVersions[evi]).BaseVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).UpdateVersion == ((TitleVersionInstance)expectedVersions[evi]).UpdateVersion) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).TitleId == ((TitleVersionInstance)expectedVersions[evi]).TitleId) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).PlatformType == ((TitleVersionInstance)expectedVersions[evi]).PlatformType) &&
                        (((TitleVersionInstance)actualVersionsDup[avi]).BetaGroup == ((TitleVersionInstance)expectedVersions[evi]).BetaGroup))
                    {
                        actualVersionsDup.RemoveAt(avi);
                        break;
                    }
                }

                //if (actualVersionsDup.Contains(expectedVersions[i]))
                //    actualVersionsDup.Remove(expectedVersions[i]);
            }

            if (actualVersionsDup.Count == 0)
                return true;

            return false;
        }

        public bool ValidateTitleVersionsNotPresent(uint titleId, ArrayList expectedVersions)
        {
            TitleVersions existingVersions = GetTitleVersions(titleId);

            for (int i = 0; i < expectedVersions.Count; i++)
            {
                if (existingVersions.Versions.Contains(expectedVersions[i]))
                {
                    Global.RO.Warn("Removal of added versions FAILED.  Other tests may fail due to this failure.");
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region NPDB Validations
        private bool validateNPDB(uint titleID, string xlast, XboxLiveSubmissionProject xlsp)
        {
            string getTitleConfigQuery = string.Format("select xml_config from t_game_config where i_title_id=0x{0:X}", titleID);
            string titleString = "select * from t_stringsvr_strings where i_title_id=0x{0:X} and vc_locale='{1}' and i_string_id={2}";

            using (ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(getTitleConfigQuery, out reader);

                if (!reader.Read())
                {
                    Global.RO.Error("There was no game config saves to NPDB for " + titleID);
                    return false;
                }

                string proppedXlast = (string)reader.GetValue(reader.GetOrdinal("xml_config"));
                if (!proppedXlast.Equals(xlast))
                {
                    Global.RO.Error("The xlast stored in t_game_config did not match the one that wasd placed there!");
                    return false;
                }

                reader.Close();
                TitleStringData[] strings = GetLocalesFromXLSP(xlsp);
                foreach (TitleStringData tsd in strings)
                {
                    npdb.ReadData(String.Format(titleString, titleID, tsd.locale, tsd.index), out reader);
                    if (!reader.Read())
                    {
                        Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in NPDB.  Expected: id=" + tsd.index);
                        reader.Close();
                        return false;
                    }
                    reader.Close();
                }
            }

            return true;

        }

        #endregion

        #region WebDB Validations

        private bool validateWebDB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (!ValidateWebDBTitleInfo(titleID, xlsp))
            {
                return false;
            }


            return ValidateWebDBTitleNameInfo(titleID, xlsp);
        }

        private bool ValidateWebDBTitleNameInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleNameQuery = "select * from t_title_name_info where i_title_id=0x{0:X} and vc_locale_id='{1}' and vc_display_name=N'{2}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();

            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            TitleStringData[] strings = GetLocalesFromXLSP(xlsp);

            foreach (TitleStringData tsd in strings)
            {

                SqlDataReader reader;
                webdb.ReadData(string.Format(titleNameQuery, titleID, tsd.locale, tsd.title), out reader);
                if (!reader.Read())
                {
                    Global.RO.Error("The string for locale '" + tsd.locale + "' was not present or was not correct in Webdb.  Expected: " + tsd.title);
                    reader.Close();
                    webdb.Close();
                    return false;
                }
                reader.Close();
            }
            webdb.Close();
            return true;
        }

        private bool ValidateWebDBTitleInfo(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and vc_default_locale='{1}'";

            ServerTestFramework.Database.Webdb webdb = new ServerTestFramework.Database.Webdb();
            webdb.ConnectToServer(Global.XEnv.GetServerListByInterface(Interface.webdb));

            SqlDataReader reader;
            webdb.ReadData(string.Format(titleQuery, titleID, xlsp.GameConfigProject.LocalizedStrings.defaultLocale), out reader);
            if (!reader.Read())
            {
                webdb.Close();
                Global.RO.Error("The titleInfo was not present or was incorrect in WebDB.");
                return false;
            }

            webdb.Close();

            return true;
        }

        #endregion

        #region UODB Validations

        private bool validateUODB(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            if (xlsp.GameConfigProject.ProductInformation != null)
            {
                if (xlsp.GameConfigProject.ProductInformation.Platform != null)
                {
                    if (!ValidateUODBTitle(titleID, xlsp))
                    {
                        return false;
                    }
                }


                if (xlsp.GameConfigProject.ProductInformation.Feature != null)
                {
                    bool? bRequiresValidation = GetRequiresValidation(xlsp);
                    if (null != bRequiresValidation)
                    {
                        if (!ValidateUODBRequiresActivation(titleID, xlsp, bRequiresValidation))
                        {
                            return false;
                        }
                    }
                }
            }

            return ValidateUODBTrustConstants(titleID);
        }

        private bool? GetRequiresValidation(XboxLiveSubmissionProject xlsp)
        {
            foreach (Feature f in xlsp.GameConfigProject.ProductInformation.Feature)
            {
                if (f.name == "pcServerSideActivation")
                {
                    return f.enabled;
                }
            }
            return null;
        }

        private bool ValidateUODBTrustConstants(uint titleID)
        {
            string titleQuery = "select * from t_title_trust_constants where i_title_id=0x{0:X}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
            {
                Global.RO.Error("The titleID was not inserted into uodb.dbo.t_title_trust_constants.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBRequiresActivation(uint titleID, XboxLiveSubmissionProject xlsp, bool? requiresActivation)
        {
            string titleQuery = "select * from t_title_info where i_title_id=0x{0:X} and ti_console_type_id={1} and f_requires_activation={2}";

            if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID, (byte)ConsoleTypeEnum.PC, ((bool)requiresActivation)?1:2), null))
            {
                Global.RO.Error("The RequiresValidation field in UODB either was not present or was incorrect.");
                return false;
            }

            return true;
        }

        private bool ValidateUODBTitle(uint titleID, XboxLiveSubmissionProject xlsp)
        {
            string titleQuery = "select * from t_titles where i_title_id=0x{0:X}";
                
            ConsoleTypeEnum[] types = GetConsoleTypes(xlsp);

            foreach (ConsoleTypeEnum cte in types)
            {
                if (null == ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(string.Format(titleQuery, titleID), null))
                {
                    Global.RO.Error("The title was not present in UODB.");
                    return false;
                }
            }

            return true;
        }

        private ConsoleTypeEnum[] GetConsoleTypes(XboxLiveSubmissionProject xlsp)
        {
            ConsoleTypeEnum[] consoleTypes = new ConsoleTypeEnum[xlsp.GameConfigProject.ProductInformation.Platform.Length];

            for (int i = 0; i < xlsp.GameConfigProject.ProductInformation.Platform.Length; i++)
            {
                consoleTypes[i] = (ConsoleTypeEnum)xlsp.GameConfigProject.ProductInformation.Platform[i].id;
            }

            return consoleTypes;
        }

        #endregion

        #region SQLUtils

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be Scalar
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public static void ExecuteUODBScalar(string command)
        {
            int partitionCount;
            //get partition count
            using (WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList = new ArrayList();

            try
            {
                //open a connection for each partition
                for (int physicalPartition = 0; physicalPartition < partitionCount; physicalPartition++)
                {

                    WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(command, conn, physicalPartition);

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType = CommandType.Text;
                    cmd.PartitionType = WstPartitionType.Physical;

                    cmd.ExecuteScalar();

                }// for each partition

            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach (WstConnection conn in connectionList)
                {
                    conn.Close();
                }
            }
        }
        #endregion

        string[] BadTitles = new string[]
        {
@"\\shailesh1\mix\production_all\535007e3\535007E3.xlast"
        };
    }
}

namespace MIXTestingUtilsV1
{
    #region Classes

    public enum TM_Titles : uint
    {
        LIPS            = 0x4D530888,
        BASIC           = 0xFFFE1800,
        NULL_TITLE_ID   = 0xFFFE1801,
        BASIC_REPROP    = 0xFFFE1802,
        EXCEPTIONS      = 0xFFFE1804
    }

    class TitleStringData
    {
        public string title = "";
        public int index = 0;
        public string locale = "";
    }

    public class Versions
    {
        public static ArrayList Basic = new ArrayList();
        public static ArrayList MultiVersion = new ArrayList();
        public static ArrayList MultiVersion_SecondHalf = new ArrayList();
        public static ArrayList MultiPlatform = new ArrayList();
        public static ArrayList MultiPlatform_SecondHalf = new ArrayList();
        public static ArrayList Lips = new ArrayList();
        public static ArrayList InvalidPlatform = new ArrayList();
        public static ArrayList Marketplace = new ArrayList();
        public static ArrayList InvalidTitle = new ArrayList();
        private static bool initialized = false;

        public static void Initialize()
        {
            if (!initialized)
            {
                initialized = true;

                // Basic
                TitleVersionInstance titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Basic.Add(titleVer);

                // MultiVersion
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion.Add(titleVer);

                // MultiVersion_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiVersion_SecondHalf.Add(titleVer);

                // MultiPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform.Add(titleVer);

                // MultiPlatform_SecondHalf
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Mobile;
                titleVer.BetaGroup = Guid.Empty;
                MultiPlatform_SecondHalf.Add(titleVer);

                // Lips
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.LIPS;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                Lips.Add(titleVer);

                // InvalidPlatform
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = (PlatformType)999;
                titleVer.BetaGroup = Guid.Empty;
                InvalidPlatform.Add(titleVer);

                // Marketplace
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = (uint)TM_Titles.BASIC;
                titleVer.BaseVersion = 2;
                titleVer.UpdateVersion = 2;
                titleVer.PlatformType = PlatformType.Marketplace;
                titleVer.BetaGroup = Guid.Empty;
                Marketplace.Add(titleVer);

                // InvalidTitle
                titleVer = new TitleVersionInstance();
                titleVer.TitleId = 0;
                titleVer.BaseVersion = 1;
                titleVer.UpdateVersion = 1;
                titleVer.PlatformType = PlatformType.Xenon;
                titleVer.BetaGroup = Guid.Empty;
                InvalidTitle.Add(titleVer);
            }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\OfferManagementTest\GetSignedHeader.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.mix.offermanagement.contracts.V1;

using MIXTesting;

namespace OfferManagementTesting
{

    #region Validators

    [TestGroup, Owner("johnmcp"), TestCasePriority(2), TestFrequency("Regression")]
    public class GetSignedHeader : TestNode
    {
        public const uint LegalFileType = GetSignedHeaderRequest.ONLY_LEGAL_FILE_TYPE;
        public const int HashSize = GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE;

        public class GetSignedHeaderBase : TestNode
        {
            public void CompareResults (uint fileSize, uint fileType, byte[] fileHash)
            {
                // call MIX api
                OfferManagementWCFClient client = new OfferManagementWCFClient();
                byte[] mixResp = client.GetSignedHeader(fileSize, fileType, fileHash);

                // call XSig directly
                XRLGetSignedHeader xrl = new XRLGetSignedHeader();

                if (!xrl.Execute(fileHash, fileSize, fileType) || xrl.XErr != 0)
                {
                    throw new UnexpectedTestResultException("GetSignedHeader direct call failed.");
                }

                byte[] directResp = xrl.Response.header;

                // compare the results (length, and everything except the timestamp and signature)
                // In the future it would be nice to be able to inject the timestamp from mix into 
                // the direct response so we can compare the whole thing
                ValueCheck.Test("Response length", directResp.Length, mixResp.Length);
                ValueCheck.TestSubset("Direct response is expected, MIX is got", directResp, 0, mixResp, 0, 12);
                ValueCheck.TestSubset("Direct response is expected, MIX is got", directResp, 20, mixResp, 20, 28);
            }

            public void CallExpectError (uint fileSize, uint fileType, byte[] fileHash, uint hr)
            {
                uint mixHr;
                Exception mixEx;

                OfferManagementWCFClient client = new OfferManagementWCFClient();
                byte[] mixResp = client.GetSignedHeader(fileSize, fileType, fileHash, out mixHr, out mixEx);

                //ValueCheck.Test("GetSignedHeader HR", hr, mixHr);

                // for now, any incorrect hr will get us this bug reference
                // when the bug is fixed, we can go back to the ValueCheck above
                if (hr != mixHr)
                {
                    throw new KnownBugException(141839, "Xbox 360 Console Software", "HR from calling GetSignedHeader was incorrect.");
                }
            }

            public override void Run ()
            {
                RunTest();
            }

            public virtual void RunTest ()
            {
            }
        }

        [TestCase, Description("Mainline test to exercise framework.")]
        public class Mainline : GetSignedHeaderBase
        {
            public override void RunTest ()
            {
                CompareResults(100, LegalFileType, RandomEx.GlobalRandGen.GenerateRandomBlob(HashSize));
            }
        }

        [TestCase, Description("Positive test cases.")]
        [CompoundCase("FileSizeSmall", 1, LegalFileType)]
        [CompoundCase("FileSizeMedium", 634234, LegalFileType)]
        [CompoundCase("FileSizeLarge", 3476453897, LegalFileType)]
        [CompoundCase("FileTypeZero", 54543, 0)]
        [CompoundCase("FileTypeOne", 7844254, 1)]
        [CompoundCase("FileTypeLarge", 34354, 67567643)]
        public class Positive : GetSignedHeaderBase
        {
            public override void RunTest ()
            {
                uint fileSize = Convert.ToUInt32(MyValues[0]);
                uint fileType = Convert.ToUInt32(MyValues[1]);
                byte[] fileHash = RandomEx.GlobalRandGen.GenerateRandomBlob(HashSize);
                CompareResults(fileSize, fileType, fileHash);
            }
        }

        [TestCase, Description("Negative test cases.")]
        [CompoundCase("FileSizeZero", 0, LegalFileType, HashSize, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        [CompoundCase("FileHashNull", 378963, LegalFileType, -1, HResult.XONLINE_E_MIX_ARGUMENT_NULL)]
        [CompoundCase("FileHashEmpty", 6745, LegalFileType, 0, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        [CompoundCase("FileHashOne", 67834, LegalFileType, 1, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        [CompoundCase("FileHashOneLess", 34165, LegalFileType, HashSize - 1, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        [CompoundCase("FileHashOneMore", 95212, LegalFileType, HashSize + 1, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        [CompoundCase("FileHashLarge", 345, LegalFileType, 45783, HResult.XONLINE_E_MIX_ARGUMENT_EMPTY)]
        public class Negative : GetSignedHeaderBase
        {
            public override void RunTest ()
            {
                uint fileSize = Convert.ToUInt32(MyValues[0]);
                uint fileType = Convert.ToUInt32(MyValues[1]);
                int fileHashSize = Convert.ToInt32(MyValues[2]);
                byte[] fileHash = (fileHashSize == -1 ? null : RandomEx.GlobalRandGen.GenerateRandomBlob(fileHashSize));
                uint hr = Convert.ToUInt32(MyValues[3]);
                CallExpectError(fileSize, fileType, fileHash, hr);
            }
        }
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Client\WCFClientBase.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Security.Cryptography;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.match.contract;
using xonline.mix.stats.contract;
using xonline.mix.storage.contract;

using xonline.mix.common;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace MIXTesting
{
    /// <summary>
    /// The custom http header for WebSG and Behaviour Injection
    /// </summary>
    [DataContract(Name = "CustomHttpHeader")]
    public class CustomHttpHeader
    {
        public CustomHttpHeader()
        {
        }

        public CustomHttpHeader(string key, string value)
        {
            this.key = key;
            this.value = value;
        }

        private string _key = null;
        private string _value = null;

        [DataMember]
        public string key
        {
            get
            {
                return _key;
            }
            set
            {
                _key = value;
            }
        }

        [DataMember]
        public string value
        {
            get
            {
                return _value;
            }
            set
            {
                _value = value;
            }
        }
    }

    /// <summary>
    /// Base WCF client for all Mix components
    /// </summary>
    public class WCFClientBase
    {
        /// <summary>
        /// An empty class used to distinguish a method call without a return
        /// </summary>
        protected class NoReturn
        {
        }

        private static RNGCryptoServiceProvider cryptoProvider = new RNGCryptoServiceProvider();
        
        /// <summary>
        /// Generates Random Request ID
        /// </summary>
        /// <returns></returns>
        public static string GetRandomRequestId()
        {            
            byte[] randomBytes = new byte[8];
            cryptoProvider.GetBytes(randomBytes);
            StringBuilder sb = new StringBuilder(randomBytes.Length * 2);
            foreach (byte b in randomBytes)
            {
                sb.AppendFormat("{0:x2}", b);
            }
            return sb.ToString();
        }

        // constant strings for WebSG headers
        public const string SubjectName = "Subject-Name";
        public const string ClientIPPort = "Client-IP-Port";
        public const string RequestId = "RequestId";

        public CustomHttpHeader[] CustomHttpHeaders = null;
        // only support WSHttpBinding for now
        protected static BasicHttpBinding wsb = DefaultBasicHttpBinding("BasicHttpBinding_Mix");

        protected static BasicHttpBinding DefaultBasicHttpBinding(string wsbName)
        {
            BasicHttpBinding wsb = new BasicHttpBinding();
            wsb.Name = wsbName;
            wsb.CloseTimeout = TimeSpan.Parse("00:01:00");
            wsb.OpenTimeout = TimeSpan.Parse("00:01:00");
            wsb.ReceiveTimeout = TimeSpan.Parse("00:10:00");
            wsb.SendTimeout = TimeSpan.Parse("00:01:00");

            wsb.BypassProxyOnLocal = false;
            wsb.HostNameComparisonMode =
                System.ServiceModel.HostNameComparisonMode.StrongWildcard;
            wsb.MaxBufferPoolSize = 524288;
            wsb.MaxReceivedMessageSize = 6553600;
            wsb.MessageEncoding =
                System.ServiceModel.WSMessageEncoding.Text;
            wsb.TextEncoding = System.Text.Encoding.UTF8;
            wsb.UseDefaultWebProxy = true;
            wsb.AllowCookies = false;

            wsb.Security.Transport.ProxyCredentialType = HttpProxyCredentialType.None;
            wsb.Security.Mode = BasicHttpSecurityMode.None;
            //wsb.Security.Message.AlgorithmSuite 

            return wsb;
        }

        /// <summary>
        /// Use reflection to call Mix APIs. All the exception handling is in this method.
        /// 
        /// For FaultException<MixClientFault/> exception, a HR and a Retryable flag are returned and no exception is thrown.
        /// The FaultException is also returned as a out parameter. 
        /// For all other exceptions, a UnexpectedTestResultException is thrown.
        /// </summary>
        /// <typeparam name="ReturnObjectType">The return type for APIs with a return. Use NoReturn class if an API does not have a return.</typeparam>
        /// <param name="client">The clientbase from WCF proxy</param>
        /// <param name="hr">The HR from FaultException<MixClientFault/></param>
        /// <param name="retryable">The Retryable flag from FaultException<MixClientFault/></param>
        /// <param name="exception">The FaultException<MixClientFault/> exception</param>
        /// <param name="methodName">The API name</param>
        /// <param name="parameters">Input parameters for this API</param>
        /// <returns></returns>
        protected ReturnObjectType Invoke<ReturnObjectType>(object client, out uint hr,
            out bool retryable, out Exception exception, string methodName, params object[] parameters)
        {
            hr = HResult.S_OK;
            retryable = false;
            exception = null;
            bool bReturn = true;

            ReturnObjectType retObject = default(ReturnObjectType);
            if (retObject is NoReturn)
                bReturn = false;
            
            // get the proxy client InnerChannel
            IClientChannel innerChannel;
            PropertyInfo innerChannelProperty = client.GetType().GetProperty("InnerChannel");
            if (innerChannelProperty == null)
            {
                throw new UnexpectedTestResultException("Proxy client type is not supported!");
            }
            else
            {
                innerChannel = (IClientChannel)innerChannelProperty.GetValue(client, null);
            }

            /*
            if (client is MixTokenManagementClient)
            {
                MixTokenManagementClient tokenClient = client as MixTokenManagementClient;
                innerChannel = tokenClient.InnerChannel;
            }
            else if (client is MixProductManagementClient)
            {
                MixProductManagementClient contentClient = client as MixProductManagementClient;
                innerChannel = contentClient.InnerChannel;
            }
            else if (client is MixOfferManagementClient)
            {
                MixOfferManagementClient offerClient = client as MixOfferManagementClient;
                innerChannel = offerClient.InnerChannel;
            }
            else if (client is MixMatchClient)
            {
                MixMatchClient matchClient = client as MixMatchClient;
                innerChannel = matchClient.InnerChannel;
            }
            else if (client is MixStatsClient)
            {
                MixStatsClient statsClient = client as MixStatsClient;
                innerChannel = statsClient.InnerChannel;
            }
            else if (client is MixStorageClient)
            {
                MixStorageClient storageClient = client as MixStorageClient;
                innerChannel = storageClient.InnerChannel;
            }
            else if (client is MixTitleManagementClient)
            {
                MixTitleManagementClient titleClient = client as MixTitleManagementClient;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixTitleManagementV2Client)
            {
                MixTitleManagementV2Client titleClient = client as MixTitleManagementV2Client;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixBetaManagementClient)
            {
                MixBetaManagementClient titleClient = client as MixBetaManagementClient;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixSettingsManagementClient)
            {
                MixSettingsManagementClient smClient = client as MixSettingsManagementClient;
                innerChannel = smClient.InnerChannel;
            }
            else if (client is SubscriptionFamilyClient)
            {
                SubscriptionFamilyClient sfClient = client as SubscriptionFamilyClient;
                innerChannel = sfClient.InnerChannel;
            }
            else if (client is MixBetaManagementV2Client)
            {
                MixBetaManagementV2Client titleClient = client as MixBetaManagementV2Client;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixBetaManagementV3Client)
            {
                MixBetaManagementV3Client titleClient = client as MixBetaManagementV3Client;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixBetaManagementV4Client)
            {
                MixBetaManagementV4Client titleClient = client as MixBetaManagementV4Client;
                innerChannel = titleClient.InnerChannel;
            }
            else if (client is MixSettingsManagementV2Client)
            {
                MixSettingsManagementV2Client smClient = client as MixSettingsManagementV2Client;
                innerChannel = smClient.InnerChannel;
            }
            else
            {
                throw new UnexpectedTestResultException("Proxy client type is not supported!");
            }
            */

            try
            {
                Global.RO.Debug("Invoke " + methodName + " on client " + client.GetType().ToString());
                using (OperationContextScope scope = new OperationContextScope(innerChannel))
                {
                    HttpRequestMessageProperty msgProperty = new HttpRequestMessageProperty();
                    // add the custom http headers first
                    if (CustomHttpHeaders != null)
                    {
                        foreach (CustomHttpHeader header in CustomHttpHeaders)
                        {
                            if (header != null)
                                msgProperty.Headers.Add(header.key, header.value);
                        }
                    }

                    // if all 3 WebSG http headers don't exist, add the default ones
                    List<string> allKeys = new List<string>(msgProperty.Headers.AllKeys);
                    if (!(allKeys.Contains(SubjectName) || allKeys.Contains(ClientIPPort) || allKeys.Contains(RequestId)))
                    {
                        msgProperty.Headers.Add(SubjectName, "DebugPartner");
                        msgProperty.Headers.Add(ClientIPPort, "1.1.1.1:1000");
                        msgProperty.Headers.Add(RequestId, GetRandomRequestId());
                    }
                    OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = msgProperty;

                    Type type = client.GetType();
                    MethodInfo methodInfo = type.GetMethod(methodName);

                    if (methodInfo==null)
                    {
                        throw new System.Exception("Method "+methodName+" not found in type "+type.ToString());
                    }

                    if (bReturn)
                    {
                        retObject = (ReturnObjectType)methodInfo.Invoke(client, parameters);
                    }
                    else
                    {
                        methodInfo.Invoke(client, parameters);
                    }

                    // close the WCF client
                    ((ICommunicationObject)client).Close();
                    return retObject;
                }
            }
            catch (TargetInvocationException targetEx)
            {
                // close the WCF client
                ((ICommunicationObject)client).Close();

                Exception ex = targetEx.InnerException as Exception;
                if (ex == null)
                {
                    throw new UnexpectedTestResultException("A TargetInvocationException without the underling inner exception.\r\n" + targetEx.Message, targetEx);
                }
                else if (ex is System.TimeoutException)
                {
                    System.TimeoutException timeoutEx = ex as System.TimeoutException;
                    throw new UnexpectedTestResultException("The service operation timed out.\r\n " + timeoutEx.Message, timeoutEx);
                }
                else if (ex is FaultException<MixClientFault>)
                {
                    // MIX APIs only throw one kind of exception, FaultException<MixClientFault>
                    // and we only hanlde this exception to get HR and Retryable flag
                    FaultException<MixClientFault> faultMixEx = ex as FaultException<MixClientFault>;
                    hr = faultMixEx.Detail.HResult;
                    retryable = faultMixEx.Detail.IsRetryable;
                    exception = faultMixEx;
                    Global.RO.Warn("Got FaultException<MixClientFault>, HR = 0x{0:X}, Retryable = {1}, message = {2}", hr, retryable, faultMixEx.Detail.Message);
                    return default(ReturnObjectType);
                }
                else if (ex is FaultException<ValidationFault>)
                {
                    FaultException<ValidationFault> validationFault = ex as FaultException<ValidationFault>;
                    foreach (ValidationDetail detail in validationFault.Detail.Details)
                    {
                        Global.RO.Error("Validation failure.Error message is : " + detail.Message);
                    }

                    exception = ex;
                    return default(ReturnObjectType);

                }
                else if (ex is FaultException)
                {
                    FaultException faultEx = ex as FaultException;
                    throw new UnexpectedTestResultException("An unknown Fault exception was received.\r\n" + faultEx.Message, faultEx);
                }
                else if (ex is CommunicationException)
                {
                    CommunicationException commEx = ex as CommunicationException;
                    throw new UnexpectedTestResultException("There are a communication problem.\r\n" + commEx.Message, commEx);
                }
                else
                {
                    throw new UnexpectedTestResultException("An unknown exception was received.\r\n" + ex.Message, ex);
                }
            }
            catch (Exception ex)
            {
                throw new UnexpectedTestResultException("Method Invocation Exception.\r\n" + ex.Message, ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\OfferManagementTest\StressTests.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using MIXTesting;
using OfferManagementTesting;
using ServerTestFramework;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;

namespace ContentTesting
{
    [TestGroup, Owner("achang"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class OfferManagmentStressGroup
    {

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("achang"), TestCasePriority(2), Description("Stress test for OfferManagement 'Game' content type")]
        public class OfferManagement_Game_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA50000104");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA50000104");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 5, 0, 0, 0, 0, 1, 0, 4 };
                

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                Offer o = OfferManagementSuite.CreateTempleteOffer();
                o.OfferId = new Guid("01234567-89AB-CDEF-0000-CCCC50000104");
                o.LiveOfferId = 5764608639744820583;
                o.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA50000104");
                o.Instances[0].Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA50000104");
                o.Instances[0].OfferInstanceId = new Guid("01234567-89AB-CDEF-0000-BAAC50000104");

                // Field that will trigger an update for stress runs
                o.Name = DateTime.Now.ToString();

                #endregion

                #region Execution

                OfferManagementSuite.ConfigureOfferOrFail(o);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("achang"), TestCasePriority(2), Description("Stress test for OfferManagement 'GameContent' content type")]
        public class OfferManagement_GameContent_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload 1

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA50000203");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA50000203");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 5, 0, 0, 0, 0, 2, 0, 3 };
                

                #endregion

                #region Payload 2

                GameContent gc = ProductManagementSuite.CreateGameContentTemplate();
                gc.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAE50000203");
                gc.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAE50000203");
                gc.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 69, 5, 0, 0, 0, 0, 2, 0, 3 };

                //From group media operation
                gc.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA50000203");

                // Field that will trigger an update for stress runs
                gc.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution 1

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation 1");

                #endregion

                #region Execution 2

                ProductManagementSuite.ConfigureProductOrThrow(gc, "Error performing the Group Media Operation 2");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                Offer o = OfferManagementSuite.CreateTempleteOffer();
                o.OfferId = new Guid("01234567-89AB-CDEF-0000-CCCC50000203");
                o.LiveOfferId = 5764609734961481063;
                o.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAE50000203");
                o.Instances[0].Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAE50000203");
                o.Instances[0].OfferInstanceId = new Guid("01234567-89AB-CDEF-0000-BAAC50000203");

                // Field that will trigger an update for stress runs
                o.Name = DateTime.Now.ToString();

                #endregion

                #region Execution

                OfferManagementSuite.ConfigureOfferOrFail(o);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("achang"), TestCasePriority(2), Description("Stress test for OfferManagement 'AvatarItem' content type")]
        public class OfferManagement_AvatarItem_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload 1

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA50000303");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA50000303");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 5, 0, 0, 0, 0, 3, 0, 3 };
                

                #endregion

                #region Payload 2

                AvatarItem ai = ProductManagementSuite.CreateAvatarItemTemplate();

                ai.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAD50000303");
                ai.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAD50000303");
                ai.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 68, 5, 0, 0, 0, 0, 3, 0, 3 };

                //From group media operation
                ai.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA50000303");

                // Field that will trigger an update for stress runs
                ai.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution 1

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation 1");

                #endregion

                #region Execution 2

                ProductManagementSuite.ConfigureProductOrThrow(ai, "Error performing the Group Media Operation 2");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                Offer o = OfferManagementSuite.CreateTempleteOffer();
                o.OfferId = new Guid("01234567-89AB-CDEF-0000-CCCC50000303");
                o.LiveOfferId = 5764610834473108839;
                o.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAD50000303");
                o.Instances[0].Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAD50000303");
                o.Instances[0].OfferInstanceId = new Guid("01234567-89AB-CDEF-0000-BAAC50000303");

                // Field that will trigger an update for stress runs
                o.Name = DateTime.Now.ToString();

                #endregion

                #region Execution

                OfferManagementSuite.ConfigureOfferOrFail(o);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("achang"), TestCasePriority(2), Description("Stress test for OfferManagement 'GameConsumable' content type")]
        public class OfferManagement_GameConsumable_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload 1

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA50000503");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA50000503");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 5, 0, 0, 0, 0, 5, 0, 3 };
                

                #endregion

                #region Payload 2

                GameConsumable gc = ProductManagementSuite.CreateGameConsumableTemplate();

                gc.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAF50000503");
                gc.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAF50000503");
                gc.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 70, 5, 0, 0, 0, 0, 5, 0, 3 };
                gc.AssetId = 50000503;

                //From group media operation
                gc.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA50000503");

                // Field that will trigger an update for stress runs
                gc.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution 1

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation 1");

                #endregion

                #region Execution 2

                ProductManagementSuite.ConfigureProductOrThrow(gc, "Error performing the Group Media Operation 2");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                Offer o = OfferManagementSuite.CreateTempleteOffer();
                o.OfferId = new Guid("01234567-89AB-CDEF-0000-CCCC50000503");
                o.LiveOfferId = 5764613033496364391;
                o.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAF50000503");
                o.Instances[0].Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAF50000503");
                o.Instances[0].OfferInstanceId = new Guid("01234567-89AB-CDEF-0000-BAAC50000503");

                // Field that will trigger an update for stress runs
                o.Name = DateTime.Now.ToString();

                #endregion

                #region Execution

                OfferManagementSuite.ConfigureOfferOrFail(o);

                #endregion

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\MixTestFramework\Proxy\ValidationProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1873
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF
{
    using System.Runtime.Serialization;


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ValidationDetail", Namespace = "http://schemas.datacontract.org/2004/07/Microsoft.Practices.EnterpriseLibrary.Val" +
        "idation.Integration.WCF")]
    public partial class ValidationDetail : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string KeyField;

        private string MessageField;

        private string TagField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Key
        {
            get
            {
                return this.KeyField;
            }
            set
            {
                this.KeyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Message
        {
            get
            {
                return this.MessageField;
            }
            set
            {
                this.MessageField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Tag
        {
            get
            {
                return this.TagField;
            }
            set
            {
                this.TagField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ValidationFault", Namespace = "http://www.microsoft.com/practices/EnterpriseLibrary/2007/01/wcf/validation")]
    public partial class ValidationFault : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationDetail[] DetailsField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationDetail[] Details
        {
            get
            {
                return this.DetailsField;
            }
            set
            {
                this.DetailsField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\OfferManagementTest\ValidatorTest.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Text;
using System.Collections.Generic;

using System.Reflection;
using System.Reflection.Emit;

using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

using MIXTesting;

namespace OfferManagementTesting
{

    #region Validators

    ///<summary>
    /// Test group to verify validators on Offer
    /// </summary>
    [TestGroup, Owner("achang"), TestCasePriority(2),TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class ValidatorOfferTestGroup : TestNode
    {
        OfferValidatorExceptionTable vExceptionTbl;

        public ValidatorOfferTestGroup()
        {
            vExceptionTbl = new OfferValidatorExceptionTable();
            IDictionaryEnumerator enumerator = vExceptionTbl.ExceptionTbl.GetEnumerator();

            while (enumerator.MoveNext())
            {
                string key = (string)enumerator.Key;
                foreach (Input input in (Input[])enumerator.Value)
                {
                    if (input.ValidationType >= ValidationType.Error && input.ValidationType != ValidationType.ArrayNullException)
                        AddChild(new ValidateTestBase(key, input.ValidationType, vExceptionTbl), true, false);
                }
            }
        }
    }

    #endregion

    #region Exception Tables

    ///<summary>
    /// hash table to store all validators used by Offer 
    /// </summary>
    class OfferValidatorExceptionTable : ValidatorExceptionTable
    {
        ///<summary>
        /// Add entries to verify validators used by Offers 
        /// </summary>
        public override void AddEntry()
        {
            //---------------------LocalizedDataV1---------------------------------------------------------
            ExceptionTbl.Add("offer.Name",
                AddStringLenthValidatorInput("Offer", "Name", StringLengths.OfferNameMin, StringLengths.OfferNameMax, true, false));

            ExceptionTbl.Add("OfferInstanceV1[]",new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (LocalizedData)/(Copyright) is null"),
            });

            ExceptionTbl.Add("StoreIds", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (LocalizedData)/(Copyright) is null"),
            });

            ExceptionTbl.Add("CountryCode", new Input[] {
                new Input("USA",ValidationType.NotInBoundary,"The value (USA) at key (OfferInstance)/(CountryCode) does not match the RegularExpression ^[a-zA-Z]{2}$"),
                new Input("U1", ValidationType.RegularExpression, "The value (U1) at key (OfferInstance)/(CountryCode) does not match the RegularExpression ^[a-zA-Z]{2}$"),
            });

            ExceptionTbl.Add("PaymentPriceCurrencyCode", new Input[] {
                new Input("USAA", ValidationType.NotInBoundary,"The value (USAA) at key (OfferInstance)/(PaymentPriceCurrencyCode) does not match the RegularExpression ^[a-zA-Z]{3}$"),
                new Input("U1", ValidationType.RegularExpression, "The value (U1) at key (OfferInstance)/(PaymentPriceCurrencyCode) does not match the RegularExpression ^[a-zA-Z]{3}$"),
            });

            ExceptionTbl.Add("Packages", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (LocalizedData)/(Copyright) is null"),
            });


            ExceptionTbl.Add("UserTypeIds", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (LocalizedData)/(Copyright) is null"),
            });

            ExceptionTbl.Add("VisibilityLevelId", new Input[] {
                new Input(0, ValidationType.LessMin,"The value (0) at key (OfferInstance)/(VisibilityLevelId) is not within the allowed list"),
                new Input(4, ValidationType.BiggerMax, "The value (4) at key (OfferInstance)/(VisibilityLevelId) is not within the allowed list"),
            });

            ExceptionTbl.Add("Quantity", new Input[] {
                new Input(-1, ValidationType.LessMin,"The value (-1) at key (OfferPackage)/(Quantity) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)"),
            });

            /* TFS 10132
            ExceptionTbl.Add("ExternalOfferInstanceId", new Input[] {
                //the error message needs to be udpated once the service gives the more accurate message back. 
                new Input("", ValidationType.LessStrLenMin,"ExternalOfferInstanceId input is wrong"),
            });
             */
      }

        ///<summary>
        /// Define how to use the input object in each entry to set Game object 
        /// </summary>
        public override string UpdateDataMember(Object o, string key, ValidationType vType)
        {
            Offer offer = (Offer)o;
            switch (key)
            {
                case "offer.Name":
                    //StrLenMax
                    offer.Name = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "OfferInstanceV1[]":
                    offer.Instances = null;
                    break;                    
                case "StoreIds":
                    //BiggerLenStrMax
                    offer.StoreIds = null;
                    break;
                case "CountryCode":
                    offer.Instances[0].CountryCode = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "PaymentPriceCurrencyCode":
                    offer.Instances[0].PaymentPriceCurrencyCode = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "Packages":
                    offer.Instances[0].Packages = null;
                    break;
                case "VisibilityLevelId":
                    //???? null exception, no string constrain.
                    offer.Instances[0].VisibilityLevelId = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "UserTypeIds":
                    //???? no string constrain
                    offer.Instances[0].UserTypeIds = null;
                    break;
                case "Quantity":
                    offer.Instances[0].Packages[0].Quantity = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "ExternalOfferInstanceId":
                    offer.Instances[0].ExternalOfferInstanceId = SetValueHelper<string>.GetValue(this, key, vType);
                    break;



                default:
                    throw new UnexpectedTestResultException("Could not find the specified exception in the table:" + key + " " + vType);
            }

            return SetValueHelper<string>.GetErrorMessage(this, key, vType);
        }

        ///<summary>
        /// Create a defalut offer value that can be overrided later using the Value from Input object. 
        /// </summary>
        public  override Object GetDefaultObject()
        {
            Offer o = new Offer();

            return OfferManagementSuite.CreateTempleteOffer();

        }
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\OfferManagementTest\TestSuite.cs ===
using System;
using System.Net;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.IO;
using System.Text;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using MIXTesting;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.offermanagement.service;
using xonline.common.config;
using System.Reflection;
using System.Threading;

[assembly: RootNode(typeof(OfferManagementTesting.OfferManagementSuite))]

namespace OfferManagementTesting
{
    //Entry point of the tests. 
    public class OfferManagementSuite : TestNode
    {

        public override void PostRun()
        {

            //delete the game that was created during pre-Run
            Catalog catalog = new Catalog();
            catalog.Remove(Template.ProductId);
        }

        ConfigureDataProvider ConfigureProvider = new ConfigureDataProvider(@"SuitesData\OfferManagementTest\SuiteConfig.xml");
        bool needConfigCustomizedOperation = true; 

        public OfferManagementSuite()
        {
            //create tests from xml file
            System.Collections.Generic.List<TestNode> TestGroups=new System.Collections.Generic.List<TestNode>();

            InsertTestServices();
            foreach (string filePath in ConfigureProvider.GetTestCasePaths())
                TestData.CreateTests(filePath, TestGroups);

            foreach (TestNode n in TestGroups)
            {
                AddChild(n);
            }
        }

        #region Miscelaneous

        /// <summary>
        /// Attempts to save a Offer. If it is successful it will return a test pass
        /// otherwise it will return a test fail
        /// </summary>
        /// <param name="offer">Offer to save</param>
        public static void ConfigureOfferOrFail(Offer offer)
        {
            Exception x = null;

            OfferManagementWCFClient client = new OfferManagementWCFClient();
            client.ConfigureOffer(offer, out x);

            if (x != null)
            {
                StringBuilder errorMessage = new StringBuilder();
                errorMessage.AppendFormat("Unexpected error: {0}", x.Message);

                if (x.InnerException != null)
                {
                    errorMessage.AppendFormat("\nInnerException: {0}", x.InnerException.Message);
                }

                throw new UnexpectedTestResultException(errorMessage.ToString());
            }
        }

        #endregion

        #region Offer Template

        public static Offer CreateTempleteOffer() {
            Offer newOffer = new Offer();
            newOffer.OfferId = System.Guid.NewGuid();
            newOffer.LiveOfferId = 1154240922855342083;
            Console.WriteLine("New offer: " + newOffer.OfferId.ToString());
            newOffer.Name = "mattlott test offer " + newOffer.OfferId.ToString();
            newOffer.ProductId = Template.ProductId;
            newOffer.Instances = new OfferInstance[1];
            newOffer.Instances[0] = new OfferInstance();
            newOffer.Instances[0].CountryCode = "US";
            newOffer.Instances[0].StartDate = DateTime.Now;
            newOffer.Instances[0].EndDate = DateTime.Now;
            newOffer.Instances[0].OfferInstanceId = System.Guid.NewGuid();
            Console.WriteLine("New offer instance: " + newOffer.Instances[0].OfferInstanceId);
            newOffer.Instances[0].PaymentPrice = 1234;
            newOffer.Instances[0].WholeSalePrice = 1234;
            newOffer.Instances[0].SuggestedRetailPrice = 1234;
            newOffer.Instances[0].PaymentPriceCurrencyCode = "MPT";
            newOffer.Instances[0].PaymentTypeId = 1;
            newOffer.Instances[0].Packages = new OfferPackage[1];
            newOffer.Instances[0].Packages[0] = new OfferPackage();
            newOffer.Instances[0].Packages[0].PackageId = Template.PackageId;
            newOffer.Instances[0].Packages[0].ProviderId = 7;
            newOffer.Instances[0].Packages[0].LicenseExtensionBits = 1;
            newOffer.Instances[0].Packages[0].LicenseTypeId = 14;
            newOffer.Instances[0].Packages[0].Quantity = 1;
            newOffer.Instances[0].Packages[0].VisibilityStatusId = 3;
            newOffer.Instances[0].UserTypeIds = new int[1];
            newOffer.Instances[0].UserTypeIds[0] = 3;
            newOffer.Instances[0].VisibilityLevelId = 1;
            newOffer.StoreIds = new int[1];
            newOffer.StoreIds[0] = 1;
            newOffer.OfferType = 1;
            return newOffer;
        } 

        public static string  CreateOffertestTemplate()
        {
            TestData t = new TestData();
            t.TestGroups = new TestGroupInfo[1];
            t.TestGroups[0] = new TestGroupInfo();
            t.TestGroups[0].TestCases = new TestCaseInfo[1];
            t.TestGroups[0].TestCases[0] = new TestCaseInfo();
            OfferTestCaseInfo tcase = new OfferTestCaseInfo();
            t.TestGroups[0].TestCases[0] = tcase;
            tcase.MediaOperations = new MediaOperation[1];
            tcase.VerboseOutput = true;

            tcase.MediaOperations[0] = new MediaOperation();

            Game g = new Game();
            MediaBase b = (MediaBase)g;

           
            //test case
            tcase.MediaOperations[0].Media = b;
            tcase.MediaOperations[0].Operation = OperationEnum.Save;

            //offer
            tcase.OfferOperations = new OfferOperation[1];
            tcase.OfferOperations[0] = new OfferOperation();

            tcase.OfferOperations[0].ProcessedOffer = CreateTempleteOffer();

            tcase.OfferOperations[0].Operation = OperationEnum.Save;

            MemoryStream memoryStream = new MemoryStream();
            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(TestData));
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;
            xmlWriterSettings.Indent = true;

            //xmlWriterSettings.OmitXmlDeclaration = true;                 
            string a = string.Empty;
            using (XmlWriter xWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, t);
                xWriter.Flush();

                //return Encoding.UTF8.GetString(memoryStream.ToArray()); 

                memoryStream.Position = 0;

                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(memoryStream);
                a = xDoc.OuterXml;

            }

            return a;
        }

        #endregion

        //Read configure file and do initialization.
        public override void PreRun(RUN_TYPE runType)
        {

            //create a game for offer template to refer to
            Game    templateProduct = (Game) Template.CreateGameTemplateV1();
            templateProduct.ProductId = Template.ProductId;
            templateProduct.Executables[0].PackageId = Template.PackageId;
            
            Exception e;
            Catalog.ConfigureProduct(out e, templateProduct, null);
            if (e != null) 
            {
                throw e;
            }

            if (runType==RUN_TYPE.FUNCTIONAL && needConfigCustomizedOperation)
            {
                CustomizedOperationManager.AddOperation("DeleteSkuforMediaWithOffer", new CustomizedOperationDelegate(DeleteSkuforMediaWithOffer));
                needConfigCustomizedOperation = false;
            }
        }

        static void DeleteSkuforMediaWithOffer(OfferOperation[] offerOperations)
        {
            uint expectedHR = HResult.XONLINE_E_MIX_INVALID_SKU_DELETE;

            Exception e;
            Product media = (Product)Catalog.GetProduct(out e, new Guid("792D8109-1234-48B0-A069-F8D7C02EB278"), null);

            // TODO: Check for exception?
            ((PointsBundle)media).Sku = null;

            Global.RO.Info("Try delete the sku");

            Catalog.ConfigureProduct(out e, media, null);
            MediaOperationsHelper.VerifyNegativeReturn(e, expectedHR, false);
        }

        //Need this for now since this is no service domain data having be created in database. 
        public void InsertTestServices()
        {
            string cmd = @"If Not EXISTS (SELECT *  from Service where serviceId = 1001)
                            Insert Into Service
		                    Values  (1001, 'test service 2', GETUTCDATE()), 
				                    (1002, 'test service 2', GETUTCDATE()), 
				                    (1003, 'test service 3', GETUTCDATE())";
            Catalog c = new Catalog();
            Catalog.RunSqlCommand(cmd);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\ProductManagementTest\func.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;
using xonline.mix.productmanagement.contracts.V1;


namespace MIXTest
{

    [TestGroup]
    public class DemoGroup : TestNode
	{

        [TestCase, Description("Sample test using GameRatingDescriptor contract")]
        class P_GetGameRatingDescriptor : WCFTestBase
		{
            GameRatingDescriptor rating;


             protected override  void Invoke(MixClient client)
             {
                 rating = (GameRatingDescriptor)client.GetGameRatingDescriptor();
             }

            //print out the xml of returned ratingdescriptor
			protected override bool Verify()
            {
                DataContractSerializer ser = new DataContractSerializer(typeof(GameRatingDescriptor));

                System.IO.MemoryStream stream = new System.IO.MemoryStream();

                System.Xml.XmlTextWriter xmlWriter = new System.Xml.XmlTextWriter(stream, Encoding.UTF8);

                ser.WriteObject(xmlWriter, rating);
                xmlWriter.Flush();
                Global.RO.Info("Xml output:");
                Global.RO.Success(Encoding.UTF8.GetString(stream.ToArray()));
                xmlWriter.Close();
                stream.Close();
                return true;
            }
		}

        [TestCase, Description("Sampe test case using game contract")]
        //this test fails right now.  More  service implementation is needed. 
        class P_GetMarketplaceItem : WCFTestBase
        {
            Game game;

            protected override  void Invoke(MixClient client)
            {
                game = (Game)client.GetMarketplaceItem(Guid.NewGuid());
            }

            //print out the xml of returned game 
            protected override bool Verify()
            {
                DataContractSerializer ser = new DataContractSerializer(typeof(Game));

                System.IO.MemoryStream stream = new System.IO.MemoryStream();

                System.Xml.XmlTextWriter xmlWriter = new System.Xml.XmlTextWriter(stream, Encoding.UTF8);

                ser.WriteObject(xmlWriter, game);
                xmlWriter.Flush();
                Global.RO.Info("Xml output:");
                Global.RO.Success(Encoding.UTF8.GetString(stream.ToArray()));
                xmlWriter.Close();
                stream.Close();
                return true;
            }
        }
        
    
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\ProductManagementTest\StressTests.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using MIXTesting;
using ServerTestFramework;
using xonline.mix.productmanagement.contracts.V1;

namespace ContentTesting
{
    [TestGroup]
    public class ProductManagmentStressGroup
    {

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("gpeszek"), TestCasePriority(2), Description("Stress test for ProductManagement 'Game' content type")]
        public class ProductManagement_Game_Stress : TestNode
        {
            public override void Run()
            {

                #region Payload

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000102");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000102");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 1, 0, 2 };
                

                // Field that will trigger an update for stress runs
                g.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(g);

                #endregion

            }
        }

        [StressTest(TargetTPS = 0.1f, Priority = 2)]
        [TestCase, Owner("achang"), TestCasePriority(2), Description("Stress test for ProductManagement 'Apps' content type")]
        public class ProductManagement_App_Stress : TestNode
        {
            public override void Run()
            {

                #region Payload

                App app = (App)Template.CreateAppTemplateV1();
                
                app.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000102");
                app.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000102");
                app.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 1, 0, 2 };
                
                // Field that will trigger an update for stress runs
                app.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(app);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("gpeszek"), TestCasePriority(2), Description("Stress test for ProductManagement 'GameContent' content type")]
        public class ProductManagement_GameContent_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload
                
                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000202");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000202");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 2, 0, 2 };
                

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {
      
                #region Payload

                GameContent gc = ProductManagementSuite.CreateGameContentTemplate();
                gc.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAE40000202");
                gc.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAE40000202");
                gc.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 69, 4, 0, 0, 0, 0, 2, 0, 2 };

                //From group media operation
                gc.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA40000202"); 

                // Field that will trigger an update for stress runs
                gc.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(gc);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("gpeszek"), TestCasePriority(2), Description("Stress test for ProductManagement 'AvatarItem' content type")]
        public class ProductManagement_AvatarItem_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000304");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000304");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 3, 0, 4 };
                

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }


            public override void Run()
            {

                #region Payload

                AvatarItem ai = ProductManagementSuite.CreateAvatarItemTemplate();

                ai.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAD40000304");
                ai.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAD40000304");
                ai.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 68, 4, 0, 0, 0, 0, 3, 0, 4 };
                ai.AssetId = new Guid("01234567-89AB-CDEF-0000-DAAD40000304");

                //From group media operation
                ai.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA40000304");

                // Field that will trigger an update for stress runs
                ai.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(ai);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("gpeszek"), TestCasePriority(2), Description("Stress test for ProductManagement 'Image' content type")]
        public class ProductManagement_Image_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000403");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000403");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 4, 0, 3 };
                

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                Image i = ProductManagementSuite.CreateImageTemplate();

                i.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAB40000403");
                i.LocalizedImageFiles[0].LocalizedFileId = new Guid("01234567-89AB-CDEF-0000-BAAF40000403");
 
                //From group media operation
                i.ProductRelationships[0].ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000403");

                // Field that will trigger an update for stress runs
                i.VisibilityDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(i);

                #endregion

            }
        }

        [StressTest(TargetTPS=0.1f, Priority=2)]
        [TestCase, Owner("gpeszek"), TestCasePriority(2), Description("Stress test for ProductManagement 'GameConsumable' content type")]
        public class ProductManagement_GameConsumable_Stress : TestNode
        {
            public override void OneTimeSetup()
            {
                base.OneTimeSetup();

                #region Group Media Operation

                Global.RO.Info("One Time Media Operation: Start");

                #region Payload

                Game g = ProductManagementSuite.CreateGameTemplete();

                g.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAA40000504");
                g.Executables[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAA40000504");
                g.Executables[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 65, 4, 0, 0, 0, 0, 5, 0, 4 };
                

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrThrow(g, "Error performing the Group Media Operation");

                #endregion

                Global.RO.Info("One Time Media Operation: End");

                #endregion
            }

            public override void Run()
            {

                #region Payload

                GameConsumable gc = ProductManagementSuite.CreateGameConsumableTemplate();

                gc.ProductId = new Guid("01234567-89AB-CDEF-0000-AAAF40000504");
                gc.Packages[0].PackageId = new Guid("01234567-89AB-CDEF-0000-BAAF40000504");
                gc.Packages[0].ContentId = new byte[20] { 0, 0, 0, 0, 0, 0, 0, 0, 66, 65, 65, 70, 4, 0, 0, 0, 0, 5, 0, 4 };
                gc.AssetId = 40000504;

                //From group media operation
                gc.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA40000504");

                // Field that will trigger an update for stress runs
                gc.ReleaseDate = DateTime.Now;

                #endregion

                #region Execution

                ProductManagementSuite.ConfigureProductOrFail(gc);

                #endregion

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\ProductManagementTest\TestSuite.cs ===
using System;
using System.Net;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.IO;
using System.Text;
using System.ServiceModel;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using MIXTesting;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.common;

[assembly: RootNode(typeof(ContentTesting.ProductManagementSuite))]

namespace ContentTesting
{
    //Entry point of the tests. 
    public class ProductManagementSuite : TestNode
    {
       
        ConfigureDataProvider ConfigureProvider = new ConfigureDataProvider(@"SuitesData\ProductManagementTest\SuiteConfig.xml");
        public ProductManagementSuite()
        {
            InsertTestServices();
            //CreateGameContentTestTemplate();
            //CreateAvatarItemTestTemplate();
            //CreateGameImagetestTemplete();
            //CreateGameTemplete();
            //CreateDefaultLiveSubscription();

            //programatically add tests
            System.Collections.Generic.List<TestNode> TestGroups=new System.Collections.Generic.List<TestNode>();
            foreach (string filePath in ConfigureProvider.GetTestCasePaths())
            {
                if (filePath.EndsWith(".xml"))
                {
                    TestData.CreateTests(filePath, TestGroups);
                }
            }
            foreach (TestNode n in TestGroups)
            {
                AddChild(n);
            }
        }

        #region Miscelaneous

        /// <summary>
        /// Attempts to save a Product or throws an exception if unsuccessful with
        /// the error information and a custom message.
        /// </summary>
        /// <param name="product">Product to save</param>
        /// <param name="onErrorMessage">Custom message on error</param>
        public static void ConfigureProductOrThrow(Product product, string onErrorMessage)
        {
            Exception x = null;

            ProductManagementWCFClient client = new ProductManagementWCFClient();
            client.ConfigureProduct(product, out x);

            if (x != null)
            {
                StringBuilder errorMessage = new StringBuilder();
                errorMessage.AppendFormat("{0} : {1}", onErrorMessage, x.Message);

                if (x.InnerException != null)
                {
                    errorMessage.AppendFormat("\nInnerException: {0}", x.InnerException.Message);
                }

                Global.RO.Error(errorMessage.ToString());

                throw (x);
            }
        }

        /// <summary>
        /// Attempts to save a Product or throws an exception if unsuccessful with
        /// the error information and a custom message.
        /// </summary>
        /// <param name="product">Product to save</param>
        public static void ConfigureProductOrFail(Product product)
        {
            ConfigureProductOrThrow(product, "Unexpected error");
        }

        //Need this for now since this is no service domain data having be created in database. 
        public void InsertTestServices()
        {
            string cmd = @"If Not EXISTS (SELECT *  from Service where serviceId = 1001)
                            Insert Into Service
		                    Values  (1001, 'test service 2', GETUTCDATE()), 
				                    (1002, 'test service 2', GETUTCDATE()), 
				                    (1003, 'test service 3', GETUTCDATE())";
            Catalog c = new Catalog();
            Catalog.RunSqlCommand(cmd);
        }
        //The function generates FullGameImageTeplete.xml which include one full game
        //and one image. Every time when the server data contracts are change, this function should 
        //be updated and called to generate the new template. Based on the changes to the template,
        //the game and image test case should be updated accordingly.

        #endregion

        #region Content Templates

        public static Game CreateGameTemplete()
        {
            Game g = new Game();
            
            // not required
            g.Categories = new int[2];
            g.Categories[0] = 10;
            g.Categories[1] = 12001;

            //-------------- LocalizedDataV1------------------------
            g.GameLocalizedData = new GameLocalizedData[1];
            g.GameLocalizedData[0] = new GameLocalizedData();
            g.GameLocalizedData[0].CustomGenre = "123";

            //StrLenMax
            g.GameLocalizedData[0].Locale = "en-US";

            g.GameLocalizedData[0].Title = "abc";
            //BiggerLenStrMax
            g.GameLocalizedData[0].TitleSort = "1";
            g.GameLocalizedData[0].TitleReduced = "abc";

            g.GameLocalizedData[0].Description = "Description for title abc";
            g.GameLocalizedData[0].DescriptionReduced = "reduced Description for title abc";

            g.GameLocalizedData[0].EquivalentLocales = new string[1];
            //???? no string constrain
            g.GameLocalizedData[0].EquivalentLocales[0] = "en-US";

            //---------------------------GameLocalizedDataV1----------------------------------------------------
            g.GameLocalizedData[0].CustomGenre = "family";

            g.GameLocalizedData[0].Publisher = "xyz";
            g.GameLocalizedData[0].Developer = "edf";

            //---------------------------MediaBaseV1----------------------------------------------------
            g.ProductId = Guid.NewGuid();

            g.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            g.VisibilityStatus = 3;
            //??????????
            g.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            g.GeoCheckPolicy = true;

            g.GameTypeId = 1;
            g.LiveTitleId = 1;
            g.Sku = "sku??";

            //-----------------------GameAttribute-------------------------------------------------

            g.GameAttributes = new GameAttribute[2];
            g.GameAttributes[0] = new GameAttribute();
            g.GameAttributes[0].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[2];
            g.GameAttributes[0].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            g.GameAttributes[0].Attributes[0].AttributeName = "offlinePlayersMin";
            g.GameAttributes[0].Attributes[0].Value = "1";
            g.GameAttributes[0].Attributes[1] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            g.GameAttributes[0].Attributes[1].AttributeName = "offlinePlayersMax";
            g.GameAttributes[0].Attributes[1].Value = "2";
            g.GameAttributes[0].Country = "US";
            g.GameAttributes[0].EquivalentCountries = new string[] { "US", "AT" };

            g.GameAttributes[1] = new GameAttribute();
            g.GameAttributes[1].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[2];
            g.GameAttributes[1].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            g.GameAttributes[1].Attributes[0].AttributeName = "offlinePlayersMin";
            g.GameAttributes[1].Attributes[0].Value = "1";
            g.GameAttributes[1].Attributes[1] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            g.GameAttributes[1].Attributes[1].AttributeName = "offlinePlayersMax";
            g.GameAttributes[1].Attributes[1].Value = "2";
            g.GameAttributes[1].Country = "BN";
            g.GameAttributes[1].EquivalentCountries = new string[] { "CB", "CL" };

            g.Categories = new int[2];
            g.Categories[0] = 3001;
            g.Categories[1] = 12001;

            //-----------------------GameExecutable-------------------------------------------------              
            g.Executables = new ProductPackage[1];
            g.Executables[0] = new ProductPackage();
            g.Executables[0].PackageId = Guid.NewGuid();

            g.Executables[0].InstallSize = 100;
            g.Executables[0].PackageSize = 200;
            g.Executables[0].PackageType = 1;
            g.Executables[0].SupportedGameRegionMask = -1;
            g.Executables[0].Encryption = new Encryption();
            g.Executables[0].Encryption.PublicKey = new byte[284];
            g.Executables[0].Encryption.SymKey = new byte[16];

            g.Executables[0].Encryption = new Encryption();
            g.Executables[0].Encryption.SymKey = new byte[16];
            g.Executables[0].Encryption.PublicKey = new byte[284];

            g.Executables[0].ContentId = new byte[20];
            new Random().NextBytes(g.Executables[0].ContentId);

            g.Executables[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            g.Executables[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();

            //------------------------------------------FileV1-----------------------
            g.Executables[0].Files[0].FileUrl = "http://someurl";
            g.Executables[0].Files[0].SortOrder = 1;

            g.Executables[0].ClientTypes = new int[1];
            //??? range for client types.
            g.Executables[0].ClientTypes[0] = 1;


            g.Ratings = new int[1];
            g.Ratings[0] = 0;

            g.RatingDescriptors = new int[1];
            g.RatingDescriptors[0] = 1;

            return g;
        }

        public static GameContent CreateGameContentTemplate()
        {
            GameContent gc = new GameContent();
            gc.ProductId = new Guid("5841082F-0000-4003-8000-000000000022");
            gc.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            gc.VisibilityStatus = 3;
            gc.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            gc.GeoCheckPolicy = true;

            gc.Categories = new int[] { 1001, 12001 };
            gc.GameContentTypeId = 18;
            gc.GameRelationships = new GameRelationship[1];
            gc.GameRelationships[0] = new GameRelationship();
            gc.GameRelationships[0].GameId = new Guid("01234567-89AB-CDEF-0000-AAAA40000304"); 
            gc.GameRelationships[0].SortOrder = 0;

            gc.GeoCheckPolicy = true;
            gc.LocalizedData = new LocalizedData[2];
            gc.LocalizedData[0] = new LocalizedData();
            gc.LocalizedData[0].Description = "Description";
            gc.LocalizedData[0].DescriptionReduced = "DescriptionReduced";
            gc.LocalizedData[0].EquivalentLocales = new string[] { "da-DK", "de-DE", "en-US", "nl-NL" };
            gc.LocalizedData[0].Locale = "nl-NL";
            gc.LocalizedData[0].Title = "Title";
            gc.LocalizedData[0].TitleReduced = "TitleReduced";
            gc.LocalizedData[0].TitleSort = "TitleSort";
            gc.LocalizedData[1] = new LocalizedData();
            gc.LocalizedData[1].Description = "Description1";
            gc.LocalizedData[1].DescriptionReduced = "DescriptionReduced1";
            gc.LocalizedData[1].EquivalentLocales = new string[] { "ru-RU", "es-MX" };
            gc.LocalizedData[1].Locale = "es-MX";
            gc.LocalizedData[1].Title = "Title1";
            gc.LocalizedData[1].TitleReduced = "TitleReduced1";
            gc.LocalizedData[1].TitleSort = "TitleSort1";

            gc.Packages = new ProductPackage[1];
            gc.Packages[0] = new ProductPackage();
            gc.Packages[0].ClientTypes = new int[] { 1, 2 };
            gc.Packages[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            gc.Packages[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            gc.Packages[0].Files[0].FileUrl = "http://someurl";
            gc.Packages[0].Files[0].SortOrder = 1;
            gc.Packages[0].InstallSize = 1234;
            gc.Packages[0].PackageId = new Guid("5841082F-0000-4003-8000-000000000001");
            gc.Packages[0].ContentId = new byte[20];
            new Random().NextBytes(gc.Packages[0].ContentId);

            gc.Packages[0].PackageSize = 1234;
            gc.Packages[0].PackageType = 1;
            gc.Packages[0].SupportedGameRegionMask = (long)255;
            gc.Packages[0].Encryption = new Encryption();
            gc.Packages[0].Encryption.PublicKey = new byte[284];
            gc.Packages[0].Encryption.SymKey = new byte[16];


            gc.EffectiveLiveTitle = 12345;
            gc.InheritRating = false;
            gc.ReleaseDate = DateTime.Now;
            gc.Ratings = new int[1];
            gc.Ratings[0] = 0;
            gc.RatingDescriptors = new int[1];
            gc.RatingDescriptors[0] = 0;
            gc.Sku = "sku";
            gc.VisibilityDate = DateTime.Now;
            gc.VisibilityStatus = 3;

            return (gc);
        }

        public static Image CreateImageTemplate()
        {
            Image img = new Image();
            img.ProductId = new Guid("5841082F-0000-4003-8000-000000000000");

            img.LocalizedImageFiles = new LocalizedImageFile[1];
            img.LocalizedImageFiles[0] = new LocalizedImageFile();
            img.LocalizedImageFiles[0].FileUrl = "http://www.xbox.com/NR/rdonlyres/3EC74CDC-841C-4135-81F4-DFB1448C01EB/0/simbandofbugsxboxlivearcade001.jpg";
            img.LocalizedImageFiles[0].FormatId = 4;
            img.LocalizedImageFiles[0].Locale = "en-US";
            img.LocalizedImageFiles[0].EquivalentLocales = new string[] { "en-US" };
            img.LocalizedImageFiles[0].LocalizedFileId = new Guid("5841082F-0000-4003-8000-000000055720");
            img.LocalizedImageFiles[0].SizeId = 27;

            img.ProductRelationships = new ProductRelationship[1];
            img.ProductRelationships[0] = new ProductRelationship();
            img.ProductRelationships[0].ProductId = new Guid("66ACD000-77FE-1000-9115-D8025841082F");
            img.ProductRelationships[0].RelationshipTypeId = 32;
            img.ProductRelationships[0].SortOrder = 0;

            img.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            img.VisibilityStatus = 3;

            return img;
        }

        public static AvatarItem CreateAvatarItemTemplate()
        {
            AvatarItem ai = new AvatarItem();
            ai.ProductId = new Guid("5841082F-0000-4003-8000-000000000023");
            ai.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            ai.VisibilityStatus = 3;
            ai.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            ai.GeoCheckPolicy = false;

            ai.AssetId = Guid.NewGuid();
            ai.BodyType = 1;

            ai.Categories = new int[] { 1001, 12001 };
            ai.GameContentTypeId = 47;
            ai.GameRelationships = new GameRelationship[1];
            ai.GameRelationships[0] = new GameRelationship();
            ai.GameRelationships[0].GameId = new Guid("5841082F-0000-4003-8000-000000000003");
            ai.GameRelationships[0].SortOrder = 0;

            ai.GeoCheckPolicy = true;
            ai.LocalizedData = new LocalizedData[2];
            ai.LocalizedData[0] = new LocalizedData();
            ai.LocalizedData[0].Description = "Description";
            ai.LocalizedData[0].DescriptionReduced = "DescriptionReduced";
            ai.LocalizedData[0].EquivalentLocales = new string[] { "da-DK", "de-DE", "en-US", "nl-NL" };
            ai.LocalizedData[0].Locale = "nl-NL";
            ai.LocalizedData[0].Title = "Title";
            ai.LocalizedData[0].TitleReduced = "TitleReduced";
            ai.LocalizedData[0].TitleSort = "TitleSort";
            ai.LocalizedData[1] = new LocalizedData();
            ai.LocalizedData[1].Description = "Description1";
            ai.LocalizedData[1].DescriptionReduced = "DescriptionReduced1";
            ai.LocalizedData[1].EquivalentLocales = new string[] { "ru-RU", "es-MX" };
            ai.LocalizedData[1].Locale = "es-MX";
            ai.LocalizedData[1].Title = "Title1";
            ai.LocalizedData[1].TitleReduced = "TitleReduced1";
            ai.LocalizedData[1].TitleSort = "TitleSort1";

            ai.Packages = new ProductPackage[1];
            ai.Packages[0] = new ProductPackage();
            ai.Packages[0].ClientTypes = new int[] { 1, 2 };
            ai.Packages[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            ai.Packages[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            ai.Packages[0].Files[0].FileUrl = "http://someurl";
            ai.Packages[0].Files[0].SortOrder = 1;
            ai.Packages[0].InstallSize = 1234;
            ai.Packages[0].PackageId = new Guid("5841082F-0000-4003-8000-000000000003");
            ai.Packages[0].ContentId = new byte[20];
            new Random().NextBytes(ai.Packages[0].ContentId);

            ai.Packages[0].PackageSize = 1234;
            ai.Packages[0].PackageType = 1;
            ai.Packages[0].SupportedGameRegionMask = (long)255;

            ai.EffectiveLiveTitle = 12345;
            ai.InheritRating = false;
            ai.ReleaseDate = DateTime.Now;
            ai.Ratings = new int[1];
            ai.Ratings[0] = 0;
            ai.RatingDescriptors = new int[1];
            ai.RatingDescriptors[0] = 0;
            ai.Sku = "sku";
            ai.VisibilityDate = DateTime.Now;
            ai.VisibilityStatus = 3;

            return (ai);
        }

        public static GameConsumable CreateGameConsumableTemplate()
        {
            GameConsumable gc = new GameConsumable();
            gc.ProductId = new Guid("5841082F-0000-4003-8000-000000000024");
            gc.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            gc.VisibilityStatus = 3;
            gc.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            gc.GeoCheckPolicy = true;

            gc.AssetId = 1010123;

            gc.Categories = new int[] { 1001, 12001 };
            gc.GameContentTypeId = 24;
            gc.GameRelationships = new GameRelationship[1];
            gc.GameRelationships[0] = new GameRelationship();
            gc.GameRelationships[0].GameId = new Guid("5841082F-0000-4003-8000-000000000004");
            gc.GameRelationships[0].SortOrder = 0;

            gc.GeoCheckPolicy = true;
            gc.LocalizedData = new LocalizedData[2];
            gc.LocalizedData[0] = new LocalizedData();
            gc.LocalizedData[0].Description = "Description";
            gc.LocalizedData[0].DescriptionReduced = "DescriptionReduced";
            gc.LocalizedData[0].EquivalentLocales = new string[] { "da-DK", "de-DE", "en-US", "nl-NL" };
            gc.LocalizedData[0].Locale = "nl-NL";
            gc.LocalizedData[0].Title = "Title";
            gc.LocalizedData[0].TitleReduced = "TitleReduced";
            gc.LocalizedData[0].TitleSort = "TitleSort";
            gc.LocalizedData[1] = new LocalizedData();
            gc.LocalizedData[1].Description = "Description1";
            gc.LocalizedData[1].DescriptionReduced = "DescriptionReduced1";
            gc.LocalizedData[1].EquivalentLocales = new string[] { "ru-RU", "es-MX" };
            gc.LocalizedData[1].Locale = "es-MX";
            gc.LocalizedData[1].Title = "Title1";
            gc.LocalizedData[1].TitleReduced = "TitleReduced1";
            gc.LocalizedData[1].TitleSort = "TitleSort1";

            gc.Packages = new ProductPackage[1];
            gc.Packages[0] = new ProductPackage();
            gc.Packages[0].ClientTypes = new int[] { 1, 2 };
            gc.Packages[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            gc.Packages[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            gc.Packages[0].Files[0].FileUrl = "http://someurl";
            gc.Packages[0].Files[0].SortOrder = 1;
            gc.Packages[0].InstallSize = 1234;
            gc.Packages[0].PackageId = new Guid("5841082F-0000-4003-8000-000000000004");
            gc.Packages[0].ContentId = new byte[20];
            new Random().NextBytes(gc.Packages[0].ContentId);

            gc.Packages[0].PackageSize = 1234;
            gc.Packages[0].PackageType = 1;
            gc.Packages[0].SupportedGameRegionMask = (long)255;

            gc.EffectiveLiveTitle = 12345;
            gc.InheritRating = false;
            gc.ReleaseDate = DateTime.Now;
            gc.Ratings = new int[1];
            gc.Ratings[0] = 0;
            gc.RatingDescriptors = new int[1];
            gc.RatingDescriptors[0] = 0;
            gc.Sku = "sku";
            gc.VisibilityDate = DateTime.Now;
            gc.VisibilityStatus = 3;

            return (gc);
        }

        #endregion

        #region Defaults


        public static LiveSubscriptionFamily CreateDefaultLiveSubscriptionFamily()
        {
            LiveSubscriptionFamily s = new LiveSubscriptionFamily();
            s.ProductId = Guid.NewGuid();
            s.GeoCheckPolicy = false;
            s.LocalizedData = new LocalizedData[1];
            s.LocalizedData[0] = new LocalizedData();
            s.LocalizedData[0].Locale = "de-DE";

            s.LocalizedData[0].Title = "abc";
            //BiggerLenStrMax
            s.LocalizedData[0].TitleSort = "1";
            s.LocalizedData[0].TitleReduced = "abc";

            s.LocalizedData[0].Description = "Description for title abc";
            s.LocalizedData[0].DescriptionReduced = "reduced Description for title abc";

            s.LocalizedData[0].EquivalentLocales = new string[1];
            //???? no string constrain
            s.LocalizedData[0].EquivalentLocales[0] = "en-US";

            s.Name = "default subscription name";
            s.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            s.ProductRelationships = null;
            s.Sku = "xsdsdfsf";
            s.Tier = 1;
            s.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            s.VisibilityStatus = 3;
            s.Services = null;
            return s;
        }

        public static GameSubscriptionFamily CreateDefaultGameSubscriptionFamily()
        {
            GameSubscriptionFamily s = new GameSubscriptionFamily();
            s.ProductId = new Guid();
            s.GeoCheckPolicy = false;
            s.LocalizedData = new LocalizedData[1];
            s.LocalizedData[0] = new LocalizedData();
            s.Name = "default subscription name";
            s.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            s.ProductRelationships = null;
            s.Sku = "xsdsdfsf";

            s.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            s.VisibilityStatus = 3;
            s.Services = null;


            XmlDocument doc = DataContractSerialize.ObjectToXml(s);
            Global.RO.Success(MediaOperationsHelper.FormatXml(doc));
            return s;
        }


        public static LiveSubscription CreateDefaultLiveSubscription()
        {
            LiveSubscription s = new LiveSubscription();
            s.ProductId = new Guid();
            s.BillingFrequency = 1;
            s.IsCancelable = false;
            s.GeoCheckPolicy = false;
            s.Name = "default subscription";
            s.SellType = 1;
            s.ServiceComponentId = new Guid().ToString();
            s.Sku = "dadadsa";
            s.SubscriptionDuration = 30;
            s.SubscriptionDurationType = 1;
            //need to provide the guid, otherwise, the deserilze would fail.
            s.SubscriptionFamily = new Guid();

            s.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            s.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            s.VisibilityStatus = 3;

            XmlDocument doc = DataContractSerialize.ObjectToXml(s);
            Global.RO.Success(MediaOperationsHelper.FormatXml(doc));

            return s;
        }

        #endregion

        #region Test Templates

        public static void CreateGameContentTestTemplate()
        {
            TestData t = new TestData();
            t.TestGroups = new TestGroupInfo[1];
            t.TestGroups[0] = new TestGroupInfo();
            t.TestGroups[0].TestCases = new TestCaseInfo[1];
            t.TestGroups[0].TestCases[0] = new TestCaseInfo();
            ContentTestCaseInfo tcase = new ContentTestCaseInfo();
            t.TestGroups[0].TestCases[0] = tcase;
            tcase.MediaOperations = new MediaOperation[2];
            tcase.VerboseOutput = true;

            tcase.MediaOperations[0] = new MediaOperation();
            tcase.MediaOperations[1] = new MediaOperation();

            Game g = CreateGameTemplete();
            tcase.MediaOperations[0].Media = g;
            tcase.MediaOperations[0].CheckDate = new Guid[] {new Guid("5841082f-0000-4003-8000-000000000000"), new Guid("66ACD000-77FE-1000-9115-D802584109F8")};
            tcase.MediaOperations[0].CustomHttpHeaders = new CustomHttpHeader[1];
            tcase.MediaOperations[0].CustomHttpHeaders[0] = new CustomHttpHeader();
            tcase.MediaOperations[0].CustomHttpHeaders[0].key = "testkey";
            tcase.MediaOperations[0].CustomHttpHeaders[0].value = "testvalue";

            GameContent gc = CreateGameContentTemplate();

            MediaBase b = (MediaBase)gc;

            //create image templete
            tcase.MediaOperations[1].Media = b;
            tcase.MediaOperations[1].Operation = OperationEnum.Get;


            MemoryStream memoryStream = new MemoryStream();
            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(TestData));
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;
            xmlWriterSettings.Indent = true;

            //xmlWriterSettings.OmitXmlDeclaration = true;                 

            using (XmlWriter xWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, t);
                xWriter.Flush();

                //return Encoding.UTF8.GetString(memoryStream.ToArray()); 

                memoryStream.Position = 0;

                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(memoryStream);
                string a = xDoc.OuterXml;

                Global.RO.Info(a);
            }
        }

        public static void CreateAvatarItemTestTemplate()
        {
            TestData t = new TestData();
            t.TestGroups = new TestGroupInfo[1];
            t.TestGroups[0] = new TestGroupInfo();
            t.TestGroups[0].TestCases = new TestCaseInfo[1];
            t.TestGroups[0].TestCases[0] = new TestCaseInfo();
            ContentTestCaseInfo tcase = new ContentTestCaseInfo();
            t.TestGroups[0].TestCases[0] = tcase;
            tcase.MediaOperations = new MediaOperation[2];
            tcase.VerboseOutput = true;

            tcase.MediaOperations[0] = new MediaOperation();


            Game g = CreateGameTemplete();
            tcase.MediaOperations[0].Media = g;
            tcase.MediaOperations[0].CustomHttpHeaders = new CustomHttpHeader[1];
            tcase.MediaOperations[0].CustomHttpHeaders[0] = new CustomHttpHeader();
            tcase.MediaOperations[0].CustomHttpHeaders[0].key = "testkey";
            tcase.MediaOperations[0].CustomHttpHeaders[0].value = "testvalue";



            tcase.MediaOperations[1] = new MediaOperation();

            AvatarItem ai = CreateAvatarItemTemplate();
            ai.ProductId = new Guid("5841082F-0000-4003-8000-fffd00000100");
            ai.GameRelationships[0].GameId = new Guid("5841082F-0000-4003-8000-000000000000");
            ai.Packages[0].PackageId = new Guid("5841082F-0000-4003-8000-000000000001");

            MediaBase b = (MediaBase)ai;

            //create image templete
            tcase.MediaOperations[1].Media = b;
            tcase.MediaOperations[1].Operation = OperationEnum.Get;


            MemoryStream memoryStream = new MemoryStream();
            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(TestData));
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;
            xmlWriterSettings.Indent = true;

            //xmlWriterSettings.OmitXmlDeclaration = true;                 

            using (XmlWriter xWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, t);
                xWriter.Flush();

                //return Encoding.UTF8.GetString(memoryStream.ToArray()); 

                memoryStream.Position = 0;

                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(memoryStream);
                string a = xDoc.OuterXml;

                Global.RO.Info(a);
            }
        }

        void CreateGameImagetestTemplete()
        {
            TestData t = new TestData();
            t.TestGroups = new TestGroupInfo[1];
            t.TestGroups[0] = new TestGroupInfo();
            t.TestGroups[0].TestCases = new TestCaseInfo[1];
            t.TestGroups[0].TestCases[0] = new TestCaseInfo();
            ContentTestCaseInfo tcase = new ContentTestCaseInfo();
            t.TestGroups[0].TestCases[0] = tcase;
            tcase.MediaOperations = new MediaOperation[2];
            tcase.VerboseOutput = true;

            tcase.MediaOperations[0] = new MediaOperation();


            Game g = CreateGameTemplete();
            tcase.MediaOperations[0].Media = g;
            tcase.MediaOperations[0].CustomHttpHeaders = new CustomHttpHeader[1];
            tcase.MediaOperations[0].CustomHttpHeaders[0] = new CustomHttpHeader();
            tcase.MediaOperations[0].CustomHttpHeaders[0].key = "testkey";
            tcase.MediaOperations[0].CustomHttpHeaders[0].value = "testvalue";



            tcase.MediaOperations[1] = new MediaOperation();
            Image img = CreateImageTemplate();


            MediaBase b = (MediaBase)img;

            //create image templete
            tcase.MediaOperations[1].Media = b;
            tcase.MediaOperations[1].Operation = OperationEnum.Get;


            MemoryStream memoryStream = new MemoryStream();
            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(TestData));
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;
            xmlWriterSettings.Indent = true;

            //xmlWriterSettings.OmitXmlDeclaration = true;                 

            using (XmlWriter xWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, t);
                xWriter.Flush();

                //return Encoding.UTF8.GetString(memoryStream.ToArray()); 

                memoryStream.Position = 0;

                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(memoryStream);
                string a = xDoc.OuterXml;

                Global.RO.Info(a);
            }
        }

        #endregion

        

    }

    ///<summary>
    /// Test group to verify Subscription validator
    /// </summary>
    [TestGroup, Owner("jbch"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class ProductTestGroup : TestNode
    {
        [TestCase, Description("Test deletion of a sku with a dependent offer")]
        public class DeleteSkuWithRelatedOffer : TestNode
        {

            public DeleteSkuWithRelatedOffer()
            {


            }

            public override void Run()
            {
                Exception exception;

                // Create initial product with sku
                Game newProduct = new Game();
                newProduct.ProductId = new Guid("097D53C5-5B37-4d76-BCD1-125C4EE17E20");
                newProduct.Sku = "65T-00005";
                newProduct.VisibilityDate = Convert.ToDateTime("2009-10-13T17:18:55.46");
                newProduct.VisibilityStatus = 3;
                newProduct.GeoCheckPolicy = false;
                newProduct.ReleaseDate = Convert.ToDateTime("2009-10-13T17:18:55.46");
                newProduct.GameLocalizedData = new GameLocalizedData[1];
                newProduct.GameLocalizedData[0] = new GameLocalizedData();
                newProduct.GameLocalizedData[0].Description = "description";
                newProduct.GameLocalizedData[0].DescriptionReduced = "description reduced";
                newProduct.GameLocalizedData[0].Locale = "en-US";
                newProduct.GameLocalizedData[0].EquivalentLocales = new string[] { "en-US" };
                newProduct.GameLocalizedData[0].Title = "title";
                newProduct.GameLocalizedData[0].TitleReduced = "title reduced";
                newProduct.GameLocalizedData[0].TitleSort = "title sort";
                newProduct.GameTypeId = 23;
                newProduct.LiveTitleId = 1480656943;

                // Save product
                ProductManagementWCFClient productClient = new ProductManagementWCFClient();
                productClient.ConfigureProduct((Product)newProduct, out exception);

                // Create offer related to game
                Offer offer = new Offer();
                offer.ProductId = newProduct.ProductId;
                offer.OfferId = new Guid("6B9C672E-C272-4db9-8B32-17D0DC4B6E84");
                offer.Name = "name";
                offer.Instances = new OfferInstance[1];
                offer.Instances[0] = new OfferInstance();
                offer.Instances[0].OfferInstanceId = new Guid("DF516862-AEF3-4b5e-ABE8-8B5EAF68AE9F");
                offer.Instances[0].CountryCode = "US";
                offer.Instances[0].PaymentPrice = 8;
                offer.Instances[0].PaymentPriceCurrencyCode = "MPT";
                offer.Instances[0].PaymentTypeId = 1;
                offer.Instances[0].StartDate = Convert.ToDateTime("2009-10-29T14:07:25.613");
                offer.Instances[0].EndDate = Convert.ToDateTime("2009-10-29T14:07:25.613");
                offer.Instances[0].UserTypeIds = new int[1];
                offer.Instances[0].UserTypeIds[0] = 3;
                offer.Instances[0].VisibilityLevelId = 1;
                offer.StoreIds = new int[1];
                offer.StoreIds[0] = 1;
                offer.OfferType = 1;

                // Save offer
                OfferManagementWCFClient offerClient = new OfferManagementWCFClient();
                offerClient.ConfigureOffer(offer, out exception);

                // Update product sku
                Game updateProduct = new Game();
                updateProduct.ProductId = newProduct.ProductId;
                updateProduct.VisibilityDate = Convert.ToDateTime("2009-10-13T17:18:55.46");
                updateProduct.VisibilityStatus = 3;
                updateProduct.GeoCheckPolicy = false;
                updateProduct.ReleaseDate = Convert.ToDateTime("2009-10-13T17:18:55.46");
                updateProduct.GameLocalizedData = new GameLocalizedData[1];
                updateProduct.GameLocalizedData[0] = new GameLocalizedData();
                updateProduct.GameLocalizedData[0].Description = "description";
                updateProduct.GameLocalizedData[0].DescriptionReduced = "description reduced";
                updateProduct.GameLocalizedData[0].Locale = "en-US";
                updateProduct.GameLocalizedData[0].EquivalentLocales = new string[] {"en-US"};
                updateProduct.GameLocalizedData[0].Title = "title";
                updateProduct.GameLocalizedData[0].TitleReduced = "title reduced";
                updateProduct.GameLocalizedData[0].TitleSort = "title sort";
                updateProduct.GameTypeId = 23;
                updateProduct.LiveTitleId = 1480656943;

                // Save product again
                ProductManagementWCFClient productClient2 = new ProductManagementWCFClient();
                productClient2.ConfigureProduct((Product)updateProduct, out exception);

                FaultException<MixClientFault> validationFault = exception as FaultException<MixClientFault>;

                if (validationFault.Detail.HResult == 2149015596)
                {
                    return;
                }
                throw new UnexpectedTestResultException("HResult != 2149015596");
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\ProductManagementTest\ValidatorTest.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;

using System.Text;
using System.Collections.Generic;

using System.Reflection;
using System.Reflection.Emit;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

using xonline.mix.productmanagement.contracts.V1;

using MIXTesting;



namespace ContentTesting
{

    #region Validators

    ///<summary>
    /// Test group to verify validators on game
    /// </summary>
    [TestGroup, Owner("gpeszek"), TestFrequency("Regression"), EnvRequirement("Catalog"), TestCasePriority(2)]
    public class ValidatorGameTestGroup : TestNode
    {
        GameValidatorExceptionTable vExceptionTbl;

        public ValidatorGameTestGroup()
        {
            vExceptionTbl = new GameValidatorExceptionTable();
            IDictionaryEnumerator enumerator = vExceptionTbl.ExceptionTbl.GetEnumerator();

            while (enumerator.MoveNext())
            {
                string key = (string)enumerator.Key;
                foreach (Input input in (Input[])enumerator.Value)
                {
                    if (input.ValidationType >= ValidationType.Error)
                        AddChild(new ValidateTestBase(key, input.ValidationType, vExceptionTbl), true, false);
                }
            }
        }

        ///<summary>
        /// Test case to cover:
        /// 1. multiple parameter validation exceptions in one single call
        /// 2. when passing valid upper/lower bound parameters, no exception throw
        /// 3. Same parameter validation exceptions happen on the two array elements.
        /// </summary>
        [TestCase, Description("multiple parameter validation exceptions in one single call, positive boundry test")]
        public class P_Game_Miscellaneous : TestNode
        {
            GameValidatorExceptionTable tbl;
            public P_Game_Miscellaneous()
            {

                tbl = new GameValidatorExceptionTable();
            }

            public override void Run()
            {
                Game g = new Game();
                List<string> errorList = new List<string>();

                // not required
                g.Categories = new int[2];
                g.Categories[0] = 10;
                g.Categories[1] = 10;

                //-------------- LocalizedDataV1------------------------
                g.GameLocalizedData = new GameLocalizedData[2];
                g.GameLocalizedData[0] = new GameLocalizedData();
                g.GameLocalizedData[0].CustomGenre = StringLengths.GetString(StringLengths.CustomGenreMax, "CustomGenreMax"); ;

                //StrLenMax
                g.GameLocalizedData[0].Locale = "USA";
                Global.RO.Info("Verfiy String Validator works on a string with max length");

                g.GameLocalizedData[0].Title = SetValueHelper<string>.GetValue(tbl, "g.GameLocalizedData[0].Title", ValidationType.StrLenMax);
                //BiggerLenStrMax
                g.GameLocalizedData[0].TitleSort = SetValueHelper<string>.GetValue(tbl, "g.GameLocalizedData[0].TitleSort", ValidationType.BiggerLenStrMax);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.GameLocalizedData[0].TitleSort", ValidationType.BiggerLenStrMax));

                Global.RO.Info("Verfiy String Validator works on a string with min length");
                g.GameLocalizedData[0].TitleReduced = SetValueHelper<string>.GetValue(tbl, "g.GameLocalizedData[0].TitleReduced", ValidationType.StrLenMin);

                g.GameLocalizedData[0].Description = null;
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.GameLocalizedData[0].Description", ValidationType.NullExceptionAlsoBoundary));

                g.GameLocalizedData[0].DescriptionReduced = "sdfasf";


                g.GameLocalizedData[0].EquivalentLocales = new string[1];
                //???? no string constrain
                g.GameLocalizedData[0].EquivalentLocales[0] = "Sdfsfs";

                //---------------------------GameLocalizedDataV1----------------------------------------------------
                g.GameLocalizedData[0].CustomGenre = "sdfs";

                g.GameLocalizedData[0].Publisher = SetValueHelper<string>.GetValue(tbl, "g.GameLocalizedData[0].Publisher", ValidationType.BiggerLenStrMax);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.GameLocalizedData[0].Publisher", ValidationType.BiggerLenStrMax));
                g.GameLocalizedData[0].Developer = null;

                //---------------------------MediaBaseV1----------------------------------------------------
                g.ProductId = new Guid("66ACD000-77FE-1000-9115-D80254540828");

                g.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");

                //??????????
                g.ReleaseDate = null;
                errorList.Add("The value at key (ProductBase)/(ReleaseDate) is null");

                g.GeoCheckPolicy = true;

                g.GameTypeId = 1;
                g.LiveTitleId = 1;
                g.Sku = SetValueHelper<string>.GetValue(tbl, "g.Sku", ValidationType.BiggerLenStrMax);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Sku", ValidationType.BiggerLenStrMax));
                //-----------------------GameAttribute-------------------------------------------------

                g.GameAttributes = new GameAttribute[2];

                g.GameAttributes[1] = new GameAttribute();
                g.GameAttributes[1].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[2];
                g.GameAttributes[1].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
                g.GameAttributes[1].Attributes[0].AttributeName = "offlinePlayersMin";
                g.GameAttributes[1].Attributes[0].Value = "1";
                g.GameAttributes[1].Attributes[1] = new xonline.mix.contentingestion.contracts.V1.Attribute();
                g.GameAttributes[1].Attributes[1].AttributeName = "offlinePlayersMax";
                g.GameAttributes[1].Attributes[1].Value = "2";
                g.GameAttributes[1].Country = "BN";
                g.GameAttributes[1].EquivalentCountries = new string[] { "CB", "CL" };

                g.GameAttributes[0] = new GameAttribute();
                g.GameAttributes[0].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[1];
                g.GameAttributes[0].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
                //???? no string validator                                
                g.GameAttributes[0].Attributes[0].AttributeName = null;
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Attributes[0].AttributeName", ValidationType.NullException));
                errorList.Add("value () at key (Attribute)/(AttributeName) is not within the lower bound 1(Inclusive) and upper bound 50(Inclusive)");

                //?????
                g.GameAttributes[0].Attributes[0].Value = "sfasf";
                //regular express failed
                //ValidationType.RegularExpression
                g.GameAttributes[0].Country = SetValueHelper<string>.GetValue(tbl, "g.Attributes[0].Country", ValidationType.RegularExpression);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Attributes[0].Country", ValidationType.RegularExpression));
                //regular express
                g.GameAttributes[1].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[1];
                g.GameAttributes[1].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
                //verify null
                Global.RO.Info("Verfiy same error messages come from 2 elements twice");
                g.GameAttributes[1].Attributes[0].AttributeName = null;
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Attributes[0].AttributeName", ValidationType.NullException));
                errorList.Add("value () at key (Attribute)/(AttributeName) is not within the lower bound 1(Inclusive) and upper bound 50(Inclusive)");

                g.GameAttributes[1].Attributes[0].Value = "dsfsfsf";
                //regular express failed
                g.GameAttributes[1].Country = SetValueHelper<string>.GetValue(tbl, "g.Attributes[0].Country", ValidationType.NotInBoundary);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Attributes[0].Country", ValidationType.NotInBoundary));
                g.GameAttributes[1].EquivalentCountries = new string[1];

                //g.Attributes[1].EquivalentCountries[0] = Convert.ChangeType(ValidatorExceptionTable.GetInput("GameAttribute/Country").value, typeof(string));                
                g.GameAttributes[1].EquivalentCountries[0] = SetValueHelper<string>.GetValue(tbl, "g.Attributes[1].EquivalentCountries[0]", ValidationType.NotInBoundary);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Attributes[1].EquivalentCountries[0]", ValidationType.NotInBoundary));
                g.Categories = new int[2];
                g.Categories[0] = 10;
                g.Categories[1] = 10;

                //-----------------------GameExecutable-------------------------------------------------              
                g.Executables = new ProductPackage[3];
                g.Executables[0] = new ProductPackage();
                g.Executables[0].PackageId = new Guid("BBACD000-77FE-1000-9115-D80254540827");

                g.Executables[0].InstallSize = 100;
                g.Executables[0].PackageSize = 200;
                //??? packageType??
                g.Executables[0].PackageType = 1;
                g.Executables[0].SupportedGameRegionMask = 100;
                g.Executables[0].Encryption = new Encryption();
                g.Executables[0].Encryption.PublicKey = null;
            
                errorList.Add("The count of items in the collection (Encryption)/(PublicKey) must fall within the range 284(Inclusive) - 284(Inclusive)");              
                g.Executables[0].Encryption.SymKey = null;
                errorList.Add("The count of items in the collection (Encryption)/(SymKey) must fall within the range 16(Inclusive) - 16(Inclusive)");
                //null exception
                g.Executables[0].Files = null;// SetValueHelper<string>.GetValue("g.Attributes[1].EquivalentCountries[0]", ValidationType.NotInBoundary); ;
                errorList.Add("The value at key (ProductPackage)/(Files) is null");
                //null exception
                g.Executables[0].ClientTypes = null;
                errorList.Add("The value at key (ProductPackage)/(ClientTypes) is null");

                g.Executables[0].ContentId = new byte[19] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
                errorList.Add("The count of items in the collection (ProductPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)");

                g.Executables[1] = new ProductPackage();
                g.Executables[1].PackageId = new Guid("BBACD000-77FE-1000-9115-D80254540828");

                g.Executables[1].InstallSize = 100;
                g.Executables[1].PackageSize = 200;
                g.Executables[1].SupportedGameRegionMask = 100;
                g.Executables[1].Encryption = new Encryption();
                //null exception
                g.Executables[1].Encryption.SymKey = new byte[16];
                g.Executables[1].Encryption.PublicKey = new byte[284];

                g.Executables[1].Files = new xonline.mix.productmanagement.contracts.V1.File[3];
                g.Executables[1].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();

                g.Executables[1].ContentId = null;
                errorList.Add("The count of items in the collection (ProductPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)");


                //------------------------------------------FileV1-----------------------
                g.Executables[1].Files[0].FileUrl = SetValueHelper<string>.GetValue(tbl, "g.Executables[1].FileUrl", ValidationType.InvalidUri);
                errorList.Add(SetValueHelper<string>.GetErrorMessage(tbl, "g.Executables[1].FileUrl", ValidationType.InvalidUri));

                g.Executables[1].Files[0].SortOrder = SetValueHelper<int>.GetValue(tbl, "g.Executables[1].SortOrder", ValidationType.LessMin);
                errorList.Add(SetValueHelper<int>.GetErrorMessage(tbl, "g.Executables[1].SortOrder", ValidationType.LessMin));

                g.Executables[1].Files[1] = new xonline.mix.productmanagement.contracts.V1.File();
                g.Executables[1].Files[1].FileUrl = SetValueHelper<string>.GetValue(tbl, "g.Executables[1].FileUrl", ValidationType.InvalidUri);
                g.Executables[1].ClientTypes = new int[2];
                //??? range for client types.
                g.Executables[1].ClientTypes[0] = 1;
                g.Executables[1].ClientTypes[0] = -1;


                g.Executables[1].Files[2] = new xonline.mix.productmanagement.contracts.V1.File();
                g.Executables[1].Files[2].FileUrl = "http://localhost";
                //duplicate sort order
                g.Executables[1].Files[2].SortOrder = SetValueHelper<int>.GetValue(tbl, "g.Executables[1].SortOrder", ValidationType.LessMin);
                g.Executables[1].ClientTypes = new int[1];


                g.Executables[2] = new ProductPackage();
                g.Executables[2].PackageId = new Guid("BBACD000-77FE-1000-9115-D80254540829");

                g.Executables[2].InstallSize = 100;
                g.Executables[2].PackageSize = 200;
                g.Executables[2].SupportedGameRegionMask = 100;
                g.Executables[2].Encryption = new Encryption();
                //null exception
                g.Executables[2].Encryption.SymKey = new byte[16];
                g.Executables[2].Encryption.PublicKey = new byte[284];
                
                g.Executables[2].Files = null;// SetValueHelper<string>.GetValue("g.Attributes[1].EquivalentCountries[0]", ValidationType.NotInBoundary); ;
                errorList.Add("The value at key (ProductPackage)/(Files) is null");
                //null exception
                g.Executables[0].ClientTypes = null;
                errorList.Add("The value at key (ProductPackage)/(ClientTypes) is null");

                g.Executables[2].ContentId = new byte[21] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
                errorList.Add("The count of items in the collection (ProductPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)");


                // TODO : Need new validation tests
                g.Ratings = new int[1];
                g.Ratings[0] = 0;

                g.RatingDescriptors = new int[1];
                g.RatingDescriptors[0] = 0;

                ProductManagementWCFClient client = new ProductManagementWCFClient();

                Exception e;
                client.ConfigureProduct((Product)g, out e);


                FaultException<ValidationFault> validationFault = e as FaultException<ValidationFault>;

                if (ValidateTestBase.DiffErrorMessage(errorList, validationFault.Detail.Details))
                    throw new UnexpectedTestResultException("DiffErrorMessage failed");

            }
        }

    }


    ///<summary>
    /// Test group to verify validators on app
    /// </summary>
    [TestGroup, Owner("achang"), TestFrequency("Regression"), EnvRequirement("Catalog"), TestCasePriority(2)]
    public class ValidatorAppTestGroup : TestNode
    {
        AppValidatorExceptionTable vExceptionTbl;

        public ValidatorAppTestGroup()
        {
            vExceptionTbl = new AppValidatorExceptionTable();
            IDictionaryEnumerator enumerator = vExceptionTbl.ExceptionTbl.GetEnumerator();

            while (enumerator.MoveNext())
            {
                string key = (string)enumerator.Key;
                foreach (Input input in (Input[])enumerator.Value)
                {
                    if (input.ValidationType >= ValidationType.Error)
                        AddChild(new ValidateTestBase(key, input.ValidationType, vExceptionTbl), true, false);
                }
            }
        }
    }


    ///<summary>
    /// Test group to verify Image validators
    /// </summary>
    [TestGroup, Owner("gpeszek"), TestFrequency("Regression"), EnvRequirement("Catalog"), TestCasePriority(2)]
    public class ValidatorImageTestGroup : TestNode
    {
        ImageValidatorExceptionTable imageExceptionTbl;

        public ValidatorImageTestGroup()
        {
            imageExceptionTbl = new ImageValidatorExceptionTable();


            IDictionaryEnumerator enumerator = imageExceptionTbl.ExceptionTbl.GetEnumerator();

            while (enumerator.MoveNext())
            {
                string key = (string)enumerator.Key;
                int i = 0;
                foreach (Input input in (Input[])enumerator.Value)
                {
                    if (input.ValidationType >= ValidationType.Error)
                    {
                        AddChild(new ValidateTestBase(key, input.ValidationType, imageExceptionTbl, i++), true, false);
                    }
                }
            }
        }
    }

    ///<summary>
    /// Test group to verify validator on gamecontent, gameconsumable, avartarItem and bundle.
    /// </summary>
    [TestGroup, Owner("gpeszek"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class ValidatorContentTestGroup : TestNode
    {
        static ContentValidatorExceptionTable tbl;

        public ValidatorContentTestGroup()
        {           
            tbl = new ContentValidatorExceptionTable();
        }

        [TestCase, Description("test"), Ignore("GameContent Validation not implemented")]
        public class GameContentValidator : TestNode
        {

            public GameContentValidator()
            {

            }

            public override void Run()
            {
                GameContent g = new GameContent();

                tbl.SetDefaultContent(g);

                ProductManagementWCFClient client = new ProductManagementWCFClient();

                Exception e;
                client.ConfigureProduct(g, out e);
                if (e == null || !(e is FaultException<ValidationFault>))
                    throw new UnexpectedTestResultException("Expected ValidationFault did not get return");
            }
        }

        [TestCase, Description("test")]
        public class GameConsumableValidator : TestNode
        {
            string[] expectedMessage = {
                "The value (-1) at key (GameConsumable)/(AssetId) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)",
                "The value (-1) at key (GameRatingDescriptor)/(Id) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)",
                "The value (-1) at key (GameRatingDescriptor)/(Level) is not within the lower bound 0(Inclusive) and upper bound 3.402823E+38(Inclusive)",
                "The value at key (ProductPackage)/(Files) is null",
                "The value at key (ProductPackage)/(ClientTypes) is null",
                "The value at key (GameContent)/(GameRelationships) is null",
                "The value at key (LocalizedData)/(Copyright) is null"
            }

            ;
            public GameConsumableValidator()
            {


            }

            public override void Run()
            {
                GameConsumable g = new GameConsumable();

                tbl.SetDefaultContent(g);
                g.AssetId = -1;
                ProductManagementWCFClient client = new ProductManagementWCFClient();

                Exception e;
                client.ConfigureProduct(g, out e);
                if (e == null || !(e is FaultException<ValidationFault>))
                    throw new UnexpectedTestResultException("Expected ValidationFault did not get return");
            }
        }

        [TestCase, Description("test")]
        public class AvatarItemValidator : TestNode
        {
            public AvatarItemValidator()
            {


            }

            public override void Run()
            {
                AvatarItem g = new AvatarItem();

                tbl.SetDefaultContent(g);
                g.BodyType = -1;
                ProductManagementWCFClient client = new ProductManagementWCFClient();

                Exception e;
                client.ConfigureProduct(g, out e);
                if (e == null || !(e is FaultException<ValidationFault>))
                    throw new UnexpectedTestResultException("Expected ValidationFault did not get return");
            }
        }
        

        [TestCase, Description("test")]
        public class BundleValidator : TestNode
        {
            Bundle b;
            public BundleValidator()
            {
                b = new Bundle();
                b.ProductId = new Guid();
                b.ProductIds = null;
                b.Sku = null;
                b.BundleLocalizedData = new BundleLocalizedData[1];
                b.BundleLocalizedData[0] = new BundleLocalizedData();
            }

            public override void Run()
            {

                ProductManagementWCFClient client = new ProductManagementWCFClient();

                Exception e;
                client.ConfigureProduct(b, out e);
                if (e == null || !(e is FaultException<ValidationFault>))
                    throw new UnexpectedTestResultException("Expected ValidationFault did not get return");
            }
        }
    }
    
    ///<summary>
    /// Test group to verify Subscription validator
    /// </summary>
    [TestGroup, Owner("pefan"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class ValidatorSubscriptionTestGroup : TestNode
    {
        //This test case tests domain validator, ignore the test case untill the service implements the domain vaildator
        //the test case then needs to be udpated with right error message then. 
        [TestCase, Description("test the validator of LiveSubscriptionFamily")]
        public class LiveSubscriptionFamilyValidator : TestNode
        {

            public LiveSubscriptionFamilyValidator()
            {


            }



            public override void Run()
            {
                List<string> errorList = new List<string>();
                errorList.Add("The value () at key (SubscriptionFamily)/(InternalName) is not within the lower bound 1(Inclusive) and upper bound 50(Inclusive)");

                LiveSubscriptionFamily g = ProductManagementSuite.CreateDefaultLiveSubscriptionFamily();

                g.Sku = null; //expect error return, sku can not be null 
                g.Name = "";
                g.Tier = 10; // not existed tier, domain validator
                g.VisibilityStatus = 3;
                g.Services = new int[1];
                g.Services[0] = 10;  // not existed service Id, domain validator
               
                ProductManagementWCFClient client = new ProductManagementWCFClient();
                Exception e;
                client.ConfigureProduct((Product)g, out e);


                FaultException<ValidationFault> validationFault = e as FaultException<ValidationFault>;

                if (ValidateTestBase.DiffErrorMessage(errorList, validationFault.Detail.Details))
                    throw new UnexpectedTestResultException("DiffErrorMessage failed");
            }
        }

        //This test case tests domain validator, ignore the test case untill the service implements the domain vaildator
        //the test case then needs to be udpated with right error message then.         
        [TestCase, Description("test the validator of LiveSubscriptionFamily")]
        public class LiveSubscriptionValidator : TestNode
        {

            public LiveSubscriptionValidator()
            {


            }

            public override void Run()
            {
                List<string> errorList = new List<string>();
                errorList.Add("The value () at key (Subscription)/(InternalName) is not within the lower bound 1(Inclusive) and upper bound 50(Inclusive)");
                errorList.Add("The value at key (Subscription)/(LocalizedData) is null");
                LiveSubscription s = ProductManagementSuite.CreateDefaultLiveSubscription();
                s.SubscriptionFamily = new Guid();
                s.Sku = null; //expect error return, sku can not be null 
                s.Name = null;
                s.BillingFrequency = 100;  //invalid domain data.
                s.SubscriptionDurationType = 100; //invalid domain data.
                s.ServiceComponentId = new Guid().ToString();
                s.SellType = 100; //invalid domain data.

                ProductManagementWCFClient client = new ProductManagementWCFClient();
                Exception e;
                client.ConfigureProduct((Product)s, out e);


                FaultException<ValidationFault> validationFault = e as FaultException<ValidationFault>;

                if (ValidateTestBase.DiffErrorMessage(errorList, validationFault.Detail.Details))
                    throw new UnexpectedTestResultException("DiffErrorMessage failed");
            }
        }
    }

    ///<summary>
    /// Test group to verify validators on game
    /// </summary>
    [TestGroup, Owner("gpeszek"), TestFrequency("Regression"), EnvRequirement("Catalog"), TestCasePriority(2)]
    public class ValidatorGameContentTestGroup : TestNode
    {        
        GameContentValidatorExceptionTable vExceptionTbl;
        

        public ValidatorGameContentTestGroup()
        {
            vExceptionTbl = new GameContentValidatorExceptionTable();
            IDictionaryEnumerator enumerator = vExceptionTbl.ExceptionTbl.GetEnumerator();

            while (enumerator.MoveNext())
            {
                string key = (string)enumerator.Key;
                foreach (Input input in (Input[])enumerator.Value)
                {
                    if (input.ValidationType >= ValidationType.Error)
                        AddChild(new ValidateTestBase(key, input.ValidationType, vExceptionTbl), true, false);
                }
            }
        }
    }

    #endregion


    #region Exception Tables

    ///<summary>
    /// hash table to store all validators used by Game 
    /// </summary>
    class GameValidatorExceptionTable : ValidatorExceptionTable
    {
        ///<summary>
        /// Added  entrys to verify validators used by Game 
        /// </summary>
        public override void AddEntry()
        {
            //---------------------ProductBaseV1---------------------------------------------------------
            ExceptionTbl.Add("g.RatingsId", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (ProductBase)/(Ratings) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)")       
            });

            ExceptionTbl.Add("g.GameRatingDescriptorsId", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (ProductBase)/(RatingDescriptors) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)")
            });


            //---------------------LocalizedDataV1---------------------------------------------------------

            ExceptionTbl.Add("g.GameLocalizedData", new Input[] {
                new Input(null, ValidationType.NullException, "The count of items in the collection (Game)/(GameLocalizedData) must fall within the range 1(Inclusive) - 2147483647(Inclusive)"),        
                new Input(new GameLocalizedData[0], ValidationType.LessMin, "The count of items in the collection (Game)/(GameLocalizedData) must fall within the range 1(Inclusive) - 2147483647(Inclusive)"),
            });
           
            ExceptionTbl.Add("g.GameLocalizedData[0].Locale",
                AddStringLenthValidatorInput("LocalizedData", "Locale", StringLengths.LocaleMin, StringLengths.LocaleMax, true, false));

            ExceptionTbl.Add("g.GameLocalizedData[0].Title",
                AddStringLenthValidatorInput("LocalizedData", "Title", StringLengths.TitleMin, StringLengths.TitleMax, true, false));


            ExceptionTbl.Add("g.GameLocalizedData[0].TitleSort",
                  AddStringLenthValidatorInput("LocalizedData", "TitleSort", StringLengths.TitleSortMin, StringLengths.TitleSortMax, true, false));

            ExceptionTbl.Add("g.GameLocalizedData[0].TitleReduced",
                 AddStringLenthValidatorInput("LocalizedData", "TitleReduced", StringLengths.TitleReducedMin, StringLengths.TitleReducedMax, true, false));


            ExceptionTbl.Add("g.GameLocalizedData[0].Description",
                 AddStringLenthValidatorInput("LocalizedData", "Description", StringLengths.DescriptionMin, StringLengths.DescriptionMax, true, false));

            ExceptionTbl.Add("g.GameLocalizedData[0].DescriptionReduced",
                AddStringLenthValidatorInput("LocalizedData", "DescriptionReduced", StringLengths.DescriptionReducedMin, StringLengths.DescriptionReducedMax, true, false));


            //ExceptionTbl.Add("g.GameLocalizedData[0].Copyright", new Input[] {
            //    new Input(null, ValidationType.NullException, "The value at key (LocalizedData)/(Copyright) is null"),        
            //});

            ExceptionTbl.Add("g.GameLocalizedData[0].EquivalentLocales[0]",
                AddStringLenthValidatorInput("LocalizedData", "EquivalentLocales", StringLengths.LocaleMin, StringLengths.LocaleMax, true));


            //---------------------GameLocalizedData---------------------------------------------------------
            ExceptionTbl.Add("g.GameLocalizedData[0].CustomGenre",
                AddStringLenthValidatorInput("GameLocalizedData", "CustomGenre", StringLengths.CustomGenreMin, StringLengths.CustomGenreMax, false, false)
            );

            ExceptionTbl.Add("g.GameLocalizedData[0].Developer",
                AddStringLenthValidatorInput("GameLocalizedData", "Developer", StringLengths.DeveloperMin, StringLengths.DeveloperMax, false, false)
            );

            ExceptionTbl.Add("g.GameLocalizedData[0].Publisher",
                AddStringLenthValidatorInput("GameLocalizedData", "Publisher", StringLengths.PublisherMin, StringLengths.PublisherMax, false, false)
             );
            //  AddStringLenthValidatorInput("VideoPreview", "FileUrl", StringLengths.FileUrlMin, StringLengths.FileUrlMax, false));

            //------------------------GameAttribute------------------------------------------------------------------------------
            ExceptionTbl.Add("g.Attributes[0].Country", new Input[] {
                new Input("USA", ValidationType.NotInBoundary,"The value (USA) at key (GameAttribute)/(Country) does not match the RegularExpression ^[a-zA-Z]{2}$"),
                new Input("U1", ValidationType.RegularExpression, "The value (U1) at key (GameAttribute)/(Country) does not match the RegularExpression ^[a-zA-Z]{2}$"),
            });

            ExceptionTbl.Add("g.Attributes[0].AttributeName",
                 AddStringLenthValidatorInput("Attribute", "AttributeName", StringLengths.AttributeNameMin, StringLengths.AttributeNameMax, true, true));

                //new Input(null, ValidationType.NullException, "The value at key (Attribute)/(AttributeName) is null"),
    
            ExceptionTbl.Add("g.Attributes[0].Value", new Input[] {
                new Input(null, ValidationType.NullException,"The value at key (Attribute)/(Value) is null")
            });//GameAttribute)/(EquivalentCountries

            ExceptionTbl.Add("g.Attributes[1].EquivalentCountries[0]", new Input[] {
                new Input("USA", ValidationType.NotInBoundary, "The value (USA) at key (GameAttribute)/(EquivalentCountries) does not match the RegularExpression ^[a-zA-Z]{2}$")
            });

            //------------------------ProductPackageV1------------------------------------------------------------------------------
            ExceptionTbl.Add("g.Executables[0].Files", new Input[] {
                new Input(null, ValidationType.ArrayNullException,"The value at key (ProductPackage)/(Files) is null")
            });

            ExceptionTbl.Add("g.Executables[0].ClientTypes", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (ProductPackage)/(ClientTypes) is null")
            });

            ExceptionTbl.Add("g.Executables[0].ContentId", new Input[] {
                 new Input(null, ValidationType.LessMin, "The count of items in the collection (ProductPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)"),
                new Input(new byte[21], ValidationType.BiggerMax, "The count of items in the collection (ProductPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)")
            });

            ////--------------------------EncryptionV1-------------------------------------------------------------------------

            ExceptionTbl.Add("g.Executables[0].Encryption.SymKey", new Input[] {
                new Input(null, ValidationType.LessMin, "The count of items in the collection (Encryption)/(SymKey) must fall within the range 16(Inclusive) - 16(Inclusive)"),
                new Input(new byte[18], ValidationType.BiggerMax, "The count of items in the collection (Encryption)/(SymKey) must fall within the range 16(Inclusive) - 16(Inclusive)")
            });

            ExceptionTbl.Add("g.Executables[0].Encryption.PublicKey", new Input[] {
                new Input(null, ValidationType.LessMin, "The count of items in the collection (Encryption)/(PublicKey) must fall within the range 284(Inclusive) - 284(Inclusive)"),
                new Input(new byte[300], ValidationType.BiggerMax, "The count of items in the collection (Encryption)/(PublicKey) must fall within the range 284(Inclusive) - 284(Inclusive)")
            });
                       
            //--------------------------FileV1-------------------------------------------------------------------------
            ExceptionTbl.Add("g.Executables[1].FileUrl", new Input[] {
                new Input("testInvalidUrl", ValidationType.InvalidUri,"The value (testInvalidUrl) at key (File)/(FileUrl) is not a well formed Uri string/exceeds maximum allowed length/null"),
                new Input("", ValidationType.LessStrLenMin,"The value () at key (File)/(FileUrl) is not a well formed Uri string/exceeds maximum allowed length/null"),

            });


            ExceptionTbl.Add("g.Executables[1].SortOrder", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (File)/(SortOrder) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)"),
            });

            //--------------------------FileV1-------------------------------------------------------------------------


            ExceptionTbl.Add("g.ReleaseDate", new Input[] {
                new Input(null, ValidationType.NullException, "The value at key (ProductBase)/(ReleaseDate) is null")
            });

            ExceptionTbl.Add("g.Sku", new Input[] {
                new Input("123456789012345678901234567890123456789012345678901", ValidationType.BiggerLenStrMax, "The value (123456789012345678901234567890123456789012345678901) at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)"),
                new Input(string.Empty, ValidationType.LessStrLenMin, "The value () at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)"),
            });
            //--------------------------------------Preview--------------------------------------------------------------
            //--------------------------------------Preview--------------------------------------------------------------


        }

        ///<summary>
        /// Define how to use the input object in each entry to set Game object 
        /// </summary>
        public override string UpdateDataMember(Object p, string key, ValidationType vType)
        {
            Game g = (Game)p;
            g.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            //??????????
            g.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");

            switch (key)
            {
                case "g.ReleaseDate":
                    g.ReleaseDate = SetValueHelper<DateTime>.GetValue(this, key, vType);
                    if (vType == ValidationType.NullException) g.ReleaseDate = null;
                    break;

                case "g.GameLocalizedData":
                    g.GameLocalizedData = SetValueHelper<GameLocalizedData[]>.GetValue(this, key, vType);
                    break;                    

                case "g.GameLocalizedData[0].Locale":
                    //StrLenMax
                    g.GameLocalizedData[0].Locale = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].Title":

                    g.GameLocalizedData[0].Title = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].TitleSort":
                    //BiggerLenStrMax
                    g.GameLocalizedData[0].TitleSort = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].TitleReduced":
                    g.GameLocalizedData[0].TitleReduced = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].Description":
                    g.GameLocalizedData[0].Description = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].DescriptionReduced":
                    g.GameLocalizedData[0].DescriptionReduced = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].EquivalentLocales[0]":
                    //???? no string constrain
                    g.GameLocalizedData[0].EquivalentLocales[0] = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].CustomGenre":
                    //---------------------------GameLocalizedDataV1----------------------------------------------------
                    g.GameLocalizedData[0].CustomGenre = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].Publisher":
                    g.GameLocalizedData[0].Publisher = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.GameLocalizedData[0].Developer":
                    g.GameLocalizedData[0].Developer = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.VisibilityStatus":
                    g.VisibilityStatus = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                //---------------------------MediaBaseV1----------------------------------------------------                
                case "g.Sku":
                    g.Sku = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                //-----------------------GameAttribute-------------------------------------------------
                case "g.Attributes[0].AttributeName":
                    g.GameAttributes[0].Attributes[0].AttributeName = SetValueHelper<string>.GetValue(this, key, vType);                    
                    break;
                //?????
                case "g.Attributes[0].Value":
                    g.GameAttributes[0].Attributes[0].Value = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                //regular express failed
                //ValidationType.RegularExpression
                case "g.Attributes[0].Country":
                    g.GameAttributes[0].Country = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                //g.Attributes[1].EquivalentCountries[0] = Convert.ChangeType(ValidatorExceptionTable.GetInput("GameAttribute/Country").value, typeof(string));                
                case "g.Attributes[1].EquivalentCountries[0]":
                    g.GameAttributes[0].EquivalentCountries[0] = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                    
                ////--------------------------EncryptionV1-------------------------------------------------------------------------

                case "g.Executables[0].Encryption.SymKey":                                        
                    g.Executables[0].Encryption.SymKey = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;

                case "g.Executables[0].Encryption.PublicKey":
                    g.Executables[0].Encryption.PublicKey = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;

                //------------------------------------------FileV1-----------------------
                case "g.Executables[0].ContentId":
                    g.Executables[0].ContentId = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;

                case "g.Executables[1].FileUrl":
                    g.Executables[0].Files[0].FileUrl = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.Executables[1].SortOrder":
                    g.Executables[0].Files[0].SortOrder = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "g.Executables[0].Files":
                    g.Executables[0].Files = SetValueHelper<xonline.mix.productmanagement.contracts.V1.File[]>.GetValue(this, key, vType);
                    break;
                case "g.Executables[0].ClientTypes":
                    g.Executables[0].ClientTypes = SetValueHelper<int[]>.GetValue(this, key, vType);
                    break;
                    
                //?????
                case "g.RatingsId":
                    g.Ratings[0] = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "g.GameRatingDescriptorsId":
                    g.RatingDescriptors[0] = SetValueHelper<int>.GetValue(this, key, vType);
                    break;


                default:
                    throw new UnexpectedTestResultException("Could not find the specified exception in the table:" + key + " " + vType);
            }

            return SetValueHelper<string>.GetErrorMessage(this, key, vType);
        }

        ///<summary>
        /// Create a defalut game value that can be override later using the Value from Input object. 
        /// </summary>
        public override Object GetDefaultObject()
        {
            Game g = ProductManagementSuite.CreateGameTemplete();
            return g;
        }
    }



    ///<summary>
    /// hash table to store all validators used by Game 
    /// </summary>
    class AppValidatorExceptionTable : ValidatorExceptionTable
    {
        ///<summary>
        /// Added  entrys to verify validators used by Game 
        /// </summary>
        public override void AddEntry()
        {

            ExceptionTbl.Add("app.Sku", new Input[] {
                new Input("123456789012345678901234567890123456789012345678901", ValidationType.BiggerLenStrMax, "The value (123456789012345678901234567890123456789012345678901) at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)"),
                new Input(string.Empty, ValidationType.LessStrLenMin, "The value () at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)"),
            });

            ExceptionTbl.Add("app.AppTypes", new Input[] {
                new Input(null, ValidationType.NullException, "The count of items in the collection (App)/(AppTypes) must fall within the range 1(Inclusive) - 2147483647(Inclusive)"),        
                new Input(new int[0], ValidationType.LessMin, "The count of items in the collection (App)/(AppTypes) must fall within the range 1(Inclusive) - 2147483647(Inclusive)")
            });

            //---------------------AppLocalizedData---------------------------------------------------------
            ExceptionTbl.Add("app.AppLocalizedData", new Input[] {
                new Input(null, ValidationType.NullException, "The count of items in the collection (App)/(AppLocalizedData) must fall within the range 1(Inclusive) - 2147483647(Inclusive)"),        
                new Input(new AppLocalizedData[0], ValidationType.LessMin, "The count of items in the collection (App)/(AppLocalizedData) must fall within the range 1(Inclusive) - 2147483647(Inclusive)")
            });

            ExceptionTbl.Add("app.AppLocalizedData[0].Developer",
                AddStringLenthValidatorInput("AppLocalizedData", "Developer", StringLengths.DeveloperMin, StringLengths.DeveloperMax, false, false)
            );

            ExceptionTbl.Add("app.AppLocalizedData[0].Publisher",
                AddStringLenthValidatorInput("AppLocalizedData", "Publisher", StringLengths.PublisherMin, StringLengths.PublisherMax, false, false)
            );

            //------------------------AppAttribute------------------------------------------------------------------------------
            ExceptionTbl.Add("app.ProductAttributes[0].Country", new Input[] {
                new Input("USA", ValidationType.NotInBoundary,"The value (USA) at key (ProductAttribute)/(Country) does not match the RegularExpression ^[a-zA-Z]{2}$"),
                new Input("U1", ValidationType.RegularExpression, "The value (U1) at key (ProductAttribute)/(Country) does not match the RegularExpression ^[a-zA-Z]{2}$"),
            });

            //------------------------AppPackageV1------------------------------------------------------------------------------
            ExceptionTbl.Add("app.Packages[0].Files", new Input[] {
                new Input(null, ValidationType.ArrayNullException,"The value at key (AppPackage)/(Files) is null")
            });

            ExceptionTbl.Add("app.Packages[0].ClientTypes", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (AppPackage)/(ClientTypes) is null")
            });

            ExceptionTbl.Add("app.Packages[0].ContentId", new Input[] {
                 new Input(null, ValidationType.LessMin, "The count of items in the collection (AppPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)"),
                new Input(new byte[21], ValidationType.BiggerMax, "The count of items in the collection (AppPackage)/(ContentId) must fall within the range 20(Inclusive) - 20(Inclusive)")
            });


            ExceptionTbl.Add("app.SearchInformation[0].Keywords",
                AddStringLenthValidatorInput("SearchInformationData", "Keywords", StringLengths.TitleMin, StringLengths.TitleMax, true, false));

            ExceptionTbl.Add("app.SearchInformation[0].AlternateTitles",
                AddStringLenthValidatorInput("SearchInformationData", "AlternateTitles", StringLengths.TitleMin, StringLengths.TitleMax, true, false));

            ExceptionTbl.Add("app.AppLocalizedData[0].VoiceDisplayTitle",
               AddStringLenthValidatorInput("LocalizedData", "VoiceDisplayTitle", StringLengths.VoiceDisplayTitleMin, StringLengths.VoiceDisplayTitleMax, false, false));
     
            //--------------------------------------Preview--------------------------------------------------------------



        }

        ///<summary>
        /// Define how to use the input object in each entry to set App object 
        /// </summary>
        public override string UpdateDataMember(Object p, string key, ValidationType vType)
        {
            App app = (App)p;

            switch (key)
            {
                case "app.AppTypes":
                    app.AppTypes = SetValueHelper<int[]>.GetValue(this, key, vType);
                    break;

                case "app.AppLocalizedData":
                    app.AppLocalizedData = SetValueHelper<AppLocalizedData[]>.GetValue(this, key, vType);
                    break;

                case "app.AppLocalizedData[0].Developer":
                    //StrLenMax
                    app.AppLocalizedData[0].Developer = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "app.AppLocalizedData[0].Publisher":
                    app.AppLocalizedData[0].Publisher = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                case "app.ProductAttributes[0].Country":
                    //BiggerLenStrMax
                    app.ProductAttributes[0].Country = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "app.Packages[0].Files":
                    app.Packages[0].Files = SetValueHelper<xonline.mix.productmanagement.contracts.V1.File[]>.GetValue(this, key, vType);
                    break;
                case "app.Packages[0].ClientTypes":
                    app.Packages[0].ClientTypes = SetValueHelper<int[]>.GetValue(this, key, vType);
                    break;
                case "app.Packages[0].ContentId":
                    app.Packages[0].ContentId = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;

                //---------------------------MediaBaseV1----------------------------------------------------                
                case "app.Sku":
                    app.Sku = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                case "app.SearchInformation[0].Keywords":
                    app.SearchInformation[0].Keywords[0] = SetValueHelper<string>.GetValue(this, key,vType);
                    break;

                case "app.SearchInformation[0].AlternateTitles":
                    app.SearchInformation[0].AlternateTitles[0] = SetValueHelper<string>.GetValue(this, key, vType);
                    break;


                case "app.AppLocalizedData[0].VoiceDisplayTitle":
                    app.AppLocalizedData[0].VoiceDisplayTitle = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                    
                default:
                    throw new UnexpectedTestResultException("Could not find the specified exception in the table:" + key + " " + vType);
            }

            return SetValueHelper<string>.GetErrorMessage(this, key, vType);
        }

        ///<summary>
        /// Create a defalut game value that can be override later using the Value from Input object. 
        /// </summary>
        public override Object GetDefaultObject()
        {
            App app = (App)Template.CreateAppTemplateV1();
            return app;
        }
    }


    ///<summary>
    /// hash table to store all validators used by Image 
    /// </summary>
    class ImageValidatorExceptionTable : ValidatorExceptionTable
    {
        public override string UpdateDataMember(Object p, string key, MIXTesting.ValidationType vType)
        {
            Image img = (Image)p;
            switch (key)
            {

                case "img.LocalizedImageFiles":
                    img.LocalizedImageFiles = SetValueHelper<xonline.mix.productmanagement.contracts.V1.LocalizedImageFile[]>.GetValue(this, key, vType);
                    break;
                case "img.ProductRelationships":
                    img.ProductRelationships = SetValueHelper<xonline.mix.productmanagement.contracts.V1.ProductRelationship[]>.GetValue(this, key, vType);
                    break;
                case "img.LocalizedImageFiles[0].Locale":
                    img.LocalizedImageFiles[0].Locale = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "img.LocalizedImageFiles[0].FileUrl":
                    img.LocalizedImageFiles[0].FileUrl = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "img.ProductRelationships[0].SortOrder":
                    img.ProductRelationships[0].SortOrder = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "img.VisibilityStatus":
                    img.VisibilityStatus = SetValueHelper<int>.GetValue(this, key, vType);
                    break;

                default:
                    throw new UnexpectedTestResultException("Could not find the specified exception in the table:" + key + " " + vType);
            }

            return SetValueHelper<string>.GetErrorMessage(this, key, vType);
        }

        public override void AddEntry()
        {

            ExceptionTbl.Add("img.ProductRelationships[0].SortOrder", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (ProductRelationship)/(SortOrder) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)"),
            });

            ExceptionTbl.Add("img.LocalizedImageFiles", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (Image)/(LocalizedImageFiles) is null")               
            });

            ExceptionTbl.Add("img.ProductRelationships", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (Image)/(ProductRelationships) is null")
            });

            ExceptionTbl.Add("img.LocalizedImageFiles[0].FileUrl", new Input[] {
                new Input(StringLengths.GetString(StringLengths.FileUrlMax+1, "FileUrlMax+1"), ValidationType.InvalidUri, "(FileUrlMax+1.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................) at key (LocalizedFile)/(FileUrl) is not a well formed Uri string/exceeds maximum allowed length/null"),
                new Input(null, ValidationType.InvalidUri, "The value () at key (LocalizedFile)/(FileUrl) is not a well formed Uri string/exceeds maximum allowed length/null"),
            });

            ExceptionTbl.Add("img.LocalizedImageFiles[0].Locale",
               AddStringLenthValidatorInput("LocalizedFile", "Locale", StringLengths.LocaleMin, StringLengths.LocaleMax, true, false));

        }


        public override Object GetDefaultObject()
        {
            Image img = new Image();

            img.LocalizedImageFiles = new LocalizedImageFile[1];
            img.LocalizedImageFiles[0] = new LocalizedImageFile();
            img.LocalizedImageFiles[0].FileUrl = "http://www.xbox.com/NR/rdonlyres/3EC74CDC-841C-4135-81F4-DFB1448C01EB/0/simbandofbugsxboxlivearcade001.jpg";
            img.LocalizedImageFiles[0].FormatId = 4;
            img.LocalizedImageFiles[0].Locale = "en-US";
            img.LocalizedImageFiles[0].LocalizedFileId = Guid.NewGuid();
            img.ProductId = Guid.NewGuid();
            img.ProductRelationships = new ProductRelationship[1];
            img.ProductRelationships[0] = new ProductRelationship();
            img.ProductRelationships[0].ProductId = Guid.NewGuid();
            img.ProductRelationships[0].RelationshipTypeId = 32;
            img.ProductRelationships[0].SortOrder = 1;
            img.VisibilityStatus = 3;
            img.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            img.Sku = null;

            return (Product)img;
        }
    }
    ///<summary>
    /// hash table to store all validators used by gamecontent 
    /// </summary>
    class ContentValidatorExceptionTable : ValidatorExceptionTable
    {
        public void SetDefaultContent(GameContent content)
        {
            content.Categories = new int[2];
            content.Categories[0] = 10;
            content.Categories[1] = 10;

            content.EffectiveLiveTitle = 0xfff7000;
            content.GameContentTypeId = 18;
            content.GameRelationships = null;
            content.GeoCheckPolicy = false;
            content.InheritRating = false;

            content.ProductId = Guid.NewGuid();

            content.Ratings = new int[1];
            content.Ratings[0] = 0;

            content.RatingDescriptors = new int[1];
            content.RatingDescriptors[0] = 1;

            content.LocalizedData = new LocalizedData[1];
            content.LocalizedData[0] = new LocalizedData();
            content.LocalizedData[0].EquivalentLocales = new string[1];
            content.LocalizedData[0].EquivalentLocales[0] = "";
            content.LocalizedData[0].Description = "joipoipo";
            content.LocalizedData[0].DescriptionReduced = "sdfsf";
            content.LocalizedData[0].Locale = "kijljk";
            content.LocalizedData[0].Title = "kjljl";
            content.LocalizedData[0].TitleReduced = "ikujoiluj";
            content.LocalizedData[0].TitleSort = "ikujoiluj";

            content.Packages = new ProductPackage[1];
            content.Packages[0] = new ProductPackage();
            content.Sku = null;
            content.VisibilityStatus = 3;
            content.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            content.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000");

        }
    }

    ///<summary>
    /// hash table to store all validators used by GameContent
    /// </summary>
    class GameContentValidatorExceptionTable : ValidatorExceptionTable
    {
        ///<summary>
        /// Added  entrys to verify validators used by GameContent
        /// </summary>
        public override void AddEntry()
        {
            //---------------------ProductBaseV1---------------------------------------------------------
            ExceptionTbl.Add("g.RatingsId", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (ProductBase)/(Ratings) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)")       
            });

            ExceptionTbl.Add("g.GameRatingDescriptorsId", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (ProductBase)/(RatingDescriptors) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)")
            });


            //---------------------LocalizedDataV1---------------------------------------------------------
            ExceptionTbl.Add("g.LocalizedData[0].Locale",
                AddStringLenthValidatorInput("LocalizedData", "Locale", StringLengths.LocaleMin, StringLengths.LocaleMax, true, false));

            ExceptionTbl.Add("g.LocalizedData[0].Title",
                AddStringLenthValidatorInput("LocalizedData", "Title", StringLengths.TitleMin, StringLengths.TitleMax, true, false));


            ExceptionTbl.Add("g.LocalizedData[0].TitleSort",
                  AddStringLenthValidatorInput("LocalizedData", "TitleSort", StringLengths.TitleSortMin, StringLengths.TitleSortMax, true, false));

            ExceptionTbl.Add("g.LocalizedData[0].TitleReduced",
                 AddStringLenthValidatorInput("LocalizedData", "TitleReduced", StringLengths.TitleReducedMin, StringLengths.TitleReducedMax, true, false));


            ExceptionTbl.Add("g.LocalizedData[0].Description",
                 AddStringLenthValidatorInput("LocalizedData", "Description", StringLengths.DescriptionMin, StringLengths.DescriptionMax, true, false));


            //------------------------ProductPackageV1------------------------------------------------------------------------------
            ExceptionTbl.Add("g.Packages[0].Files", new Input[] {
                new Input(null, ValidationType.ArrayNullException,"The value at key (ProductPackage)/(Files) is null")
            });

            ExceptionTbl.Add("g.Packages[0].ClientTypes", new Input[] {
                new Input(null, ValidationType.ArrayNullException, "The value at key (ProductPackage)/(ClientTypes) is null")
            });

            ExceptionTbl.Add("g.Packages[0].Encryption.SymKey", new Input[] {
                new Input(null, ValidationType.LessMin, "The count of items in the collection (Encryption)/(SymKey) must fall within the range 16(Inclusive) - 16(Inclusive)"),
                new Input(new byte[18], ValidationType.BiggerMax, "The count of items in the collection (Encryption)/(SymKey) must fall within the range 16(Inclusive) - 16(Inclusive)")             
            });

            ExceptionTbl.Add("g.Packages[0].Encryption.PublicKey", new Input[] {
                new Input(null, ValidationType.LessMin, "The count of items in the collection (Encryption)/(PublicKey) must fall within the range 284(Inclusive) - 284(Inclusive)"),
                new Input(new byte[300], ValidationType.BiggerMax, "The count of items in the collection (Encryption)/(PublicKey) must fall within the range 284(Inclusive) - 284(Inclusive)")
            });


            //--------------------------FileV1-------------------------------------------------------------------------
            ExceptionTbl.Add("g.Packages[0].Files[0].FileUrl", new Input[] {
                new Input("testInvalidUrl", ValidationType.InvalidUri,"The value (testInvalidUrl) at key (File)/(FileUrl) is not a well formed Uri string/exceeds maximum allowed length/null"),
            });


            ExceptionTbl.Add("g.Packages[0].Files[0].SortOrder", new Input[] {
                new Input(-1, ValidationType.LessMin, "The value (-1) at key (File)/(SortOrder) is not within the lower bound 0(Inclusive) and upper bound 2147483647(Inclusive)"),
            });

            //--------------------------Main-------------------------------------------------------------------------

            ExceptionTbl.Add("g.ReleaseDate", new Input[] {
                new Input(null, ValidationType.NullException, "The value at key (ProductBase)/(ReleaseDate) is null")
            });

            ExceptionTbl.Add("g.Sku", new Input[] {
                new Input("123456789012345678901234567890123456789012345678901", ValidationType.BiggerLenStrMax, "The value (123456789012345678901234567890123456789012345678901) at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)"),
                new Input(string.Empty, ValidationType.LessStrLenMin, "The value () at key (MediaBase)/(Sku) should either be null or within the lower bound 1(Inclusive) and upper bound 50(Inclusive)")
            });
        }

        ///<summary>
        /// Define how to use the input object in each entry to set GameContent object 
        /// </summary>
        public override string UpdateDataMember(Object p, string key, ValidationType vType)
        {
            GameContent g = (GameContent)p;
            g.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00");

            g.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00");
            g.Packages[0].ClientTypes = new int[1];
            g.Packages[0].ClientTypes[0] = 1;

            switch (key)
            {
                case "g.ReleaseDate":
                    g.ReleaseDate = SetValueHelper<DateTime>.GetValue(this, key, vType);
                    if (vType == ValidationType.NullException) g.ReleaseDate = null;
                    break;
                case "g.LocalizedData[0].Locale":
                    g.LocalizedData[0].Locale = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].Title":
                    g.LocalizedData[0].Title = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].TitleSort":
                    g.LocalizedData[0].TitleSort = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].TitleReduced":
                    g.LocalizedData[0].TitleReduced = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].Description":
                    g.LocalizedData[0].Description = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].DescriptionReduced":
                    g.LocalizedData[0].DescriptionReduced = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.LocalizedData[0].EquivalentLocales[0]":
                    g.LocalizedData[0].EquivalentLocales[0] = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.VisibilityStatus":
                    g.VisibilityStatus = SetValueHelper<int>.GetValue(this, key, vType);
                    break;

                //---------------------------MediaBaseV1----------------------------------------------------                
                case "g.Sku":
                    g.Sku = SetValueHelper<string>.GetValue(this, key, vType);
                    break;

                //------------------------------------------EncryptionV1-----------------------
                case "g.Packages[0].Encryption.SymKey":
                    g.Packages[0].Encryption.SymKey = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;

                case "g.Packages[0].Encryption.PublicKey":
                    g.Packages[0].Encryption.PublicKey = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;
                    
                //------------------------------------------FileV1-----------------------
                case "g.Packages[0].ContentId":
                    g.Packages[0].ContentId = SetValueHelper<byte[]>.GetValue(this, key, vType);
                    break;
                case "g.Packages[0].Files":
                    g.Packages[0].Files = SetValueHelper<xonline.mix.productmanagement.contracts.V1.File[]>.GetValue(this, key, vType);
                    break;
                case "g.Packages[0].Files[0].FileUrl":
                    g.Packages[0].Files[0].FileUrl = SetValueHelper<string>.GetValue(this, key, vType);
                    break;
                case "g.Packages[0].Files[0].SortOrder":
                    g.Packages[0].Files[0].SortOrder = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "g.RatingsId":
                    g.Ratings[0] = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "g.GameRatingDescriptorsId":
                    g.RatingDescriptors[0] = SetValueHelper<int>.GetValue(this, key, vType);
                    break;
                case "g.Packages[0].ClientTypes":
                    g.Packages[0].ClientTypes = SetValueHelper<int[]>.GetValue(this, key, vType);
                    break;

                    

                default:
                    throw new UnexpectedTestResultException("Could not find the specified exception in the table:" + key + " " + vType);
            }

            return SetValueHelper<string>.GetErrorMessage(this, key, vType);
        }

        ///<summary>
        /// Create a defalut game value that can be override later using the Value from Input object. 
        /// </summary>
        public override Object GetDefaultObject()
        {
            GameContent g = ProductManagementSuite.CreateGameContentTemplate();
            return g;
        }
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\Common.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using xonline.mix.settingsmanagement.contracts.V1;

namespace MixTest
{
    public enum ConfigSource
    {
        Unknown,
        Client,
        Build,
        Beta
    }

    public class SettingsGroup
    {
        public ushort Build { get; set; }
        public ushort Qfe { get; set; }
        public Guid Group { get; set; }
        public int Value { get; set; }

        public override string ToString ()
        {
            return ToString("{0}.{1}.{2}");
        }

        public string ToString (string format)
        {
            return string.Format(format, Build, Qfe, Group, Value);
        }
    }

    public class SettingsGroupListTestChild : TestNode
    {
        protected SettingsGroup TheGroup;

        public SettingsGroupListTestChild () { }

        public void SetSettingsGroup (SettingsGroup sg)
        {
            TheGroup = sg;
            Name = sg.ToString("{0}.{1}.{3}");
        }
    }

    /// <summary>
    /// A test group for a list of SettingsGroup objects.
    /// </summary>
    public class SettingsGroupListTestNode<T> : TestNode where T : SettingsGroupListTestChild, new()
    {
        public SettingsGroupListTestNode ()
        {
            foreach (SettingsGroup sg in GetSettingsGroupList())
            {
                T tn = new T();
                tn.SetSettingsGroup(sg);
                AddChild(tn, true, false);
            }
        }

        public virtual SettingsGroup[] GetSettingsGroupList () { return new SettingsGroup[0]; }
    }

    public static class SettingsManagementCommon
    {
        public const string TestSettingName = "MixSettingsManagementTestSetting";

        public static SettingsGroup[] BetaGroups { get; set; }
        public static SettingsGroup[] Builds { get; set; }

        static SettingsManagementCommon ()
        {
            int val = 1;

            BetaGroups = new SettingsGroup[]{
                // these overlap with the builds
                CreateSettingsGroup(146, 0, true, val++),
                CreateSettingsGroup(146, 18, true, val++),
                CreateSettingsGroup(146, 18, true, val++),
                CreateSettingsGroup(843, 0, true, val++),
                // these do not
                CreateSettingsGroup(147, 0, true, val++),
                CreateSettingsGroup(147, 18, true, val++),
                CreateSettingsGroup(844, 0, true, val++)
            };

            Builds = new SettingsGroup[]{
                // these overlap with the groups
                CreateSettingsGroup(146, 0, false, val++),
                CreateSettingsGroup(146, 18, false, val++),
                CreateSettingsGroup(843, 0, false, val++),
                // these do not
                CreateSettingsGroup(5904, 0, false, val++),
                CreateSettingsGroup(5904, 1, false, val++),
                CreateSettingsGroup(5904, 564, false, val++),
                CreateSettingsGroup(9082, 445, false, val++)
            };
        }

        public static SettingsGroup CreateSettingsGroup (ushort build, ushort qfe, bool createGroup, int value)
        {
            SettingsGroup ans = new SettingsGroup();
            ans.Build = build;
            ans.Qfe = qfe;
            ans.Group = (createGroup ? Guid.NewGuid() : Guid.Empty);
            ans.Value = value;

            return ans;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\IngestEtxManifest.cs ===
using System;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V2;

namespace MixTest
{
    // ==============================================
    // Positive cases are covered by the Vortex tests
    // ==============================================
    [TestGroup, Owner("johnmcp"), Description("Tests for the IngestEtxManifest mix API")]
    public class IngestEtxManifest : TestNode
    {
        #region Utils

        // calls the API and verifies the result
        public static void CallAndVerify (string etxManifest)
        {
            CallAndVerify(etxManifest, null);
        }

        // calls the API and verifies the result
        public static void CallAndVerify (string etxManifest, string errorMessage)
        {
            //make the request
            SettingsManagementV2WCFClient client = new SettingsManagementV2WCFClient();
            client.ExpectedHR = HResult.S_OK;
            string mixResults = client.IngestEtxManifest(etxManifest);

            // always make sure we get proper XML back on a successful call
            if (string.IsNullOrEmpty(mixResults))
            {
                throw new UnexpectedTestResultException("MIX result was null or empty.");
            }

            XmlDocument resultDoc = new XmlDocument();
            resultDoc.LoadXml(mixResults);

            if (errorMessage != null)
            {
                ValueCheck.Test("Error message", errorMessage, resultDoc.SelectSingleNode("/result/errors/item/description").InnerText);
            }
        }

        #endregion

        #region Setup

        public override void OneTimeSetup ()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.IngestEtxManifest");
        }

        #endregion

        #region Negative

        [TestCase, TestCasePriority(3), Description("The manifest is null.")]
        public void ManifestNull ()
        {
            CallAndVerify(null, "Etx manifest cannot be null or empty.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is empty.")]
        public void ManifestEmpty ()
        {
            CallAndVerify("", "Etx manifest cannot be null or empty.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is a single space.")]
        public void ManifestSpace ()
        {
            CallAndVerify(" ", "Error parsing input etx manifest.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is not xml.")]
        public void ManifestNotXml ()
        {
            CallAndVerify("Not xml", "Error parsing input etx manifest.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is some random xml.")]
        public void ManifestNotEtxXml ()
        {
            CallAndVerify("<store><item name=\"stuff\" /></store>", "Error parsing input etx manifest.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is empty etx xml.")]
        public void ManifestEmptyEtxXml ()
        {
            CallAndVerify("<etxmanifest><instrumentation><globaleventproducers></globaleventproducers></instrumentation></etxmanifest>");
        }

        #endregion

        #region Limits

        public const int MaxManifestSize = 4194085;

        [TestCase, TestCasePriority(2), Description("The manifest is the largest supported size.")]
        public void ManifestMaxSize ()
        {
            CallAndVerify(new string('A', MaxManifestSize), "Error parsing input etx manifest.");
        }

        [TestCase, TestCasePriority(3), Description("The manifest is larger than supported.")]
        public void ManifestTooLarge ()
        {
            try
            {
                CallAndVerify(new string('C', MaxManifestSize + 1), "Error parsing input etx manifest.");
                throw new Exception("Expected an exception from a manifest that is too large.");
            }
            catch (UnexpectedTestResultException)
            {
                // it is unfortunate that this is the type of exception thrown by the MIX framework...
            }
        }

        [TestCase, TestCasePriority(3), Description("Find the maximum length of the manifest string by binary searching.")]
        public void ManifestMaxLengthBinarySearch ()
        {
            int top = MaxManifestSize * 2;
            int bottom = 0;
            int current = MaxManifestSize;
            int change = 0;

            do
            {
                bool up = true;

                try
                {
                    Global.RO.Debug("Trying {0} [{1} - {2})", current, bottom, top);
                    CallAndVerify(new string('C', current));
                }
                catch
                {
                    up = false;
                }

                if (up)
                {
                    bottom = current;
                    change = (top - current) / 2;
                }
                else
                {
                    top = current;
                    change = (bottom - current - 1) / 2;
                }
                current += change;
            } while (change != 0);

            Global.RO.Info("Max size was " + current);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\GetLiveRegistrySettings.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V1;

namespace MixTest
{
    [TestGroup, Owner("johnmcp"), Description("Tests for the GetSettings mix API")]
    public class GetSettings: TestNode
    {
        #region Utils

        public static void CallAndVerify (uint expectedHResult, PlatformType platform, ushort? build, ushort? qfe, Guid group, ConfigSource source, int value)
        {
            CallAndVerify(expectedHResult, platform, build, qfe, group, source, (value == 0 ? "" : value.ToString()));
        }

        //calls the API and verifies the result against liveinfo
        public static void CallAndVerify (uint expectedHResult, PlatformType platform, ushort? build, ushort? qfe, Guid group, ConfigSource source, 
            string value)
        {
            //make the request
            SettingsManagementWCFClient client = new SettingsManagementWCFClient();
            client.ExpectedHR=expectedHResult;
            LiveHiveSetting[] mixResults = client.GetSettings(platform, build, qfe, group);

            if (expectedHResult==HResult.S_OK) //verify the response against what the liveinfo service thinks
            {
                //set up a machine to use for the call
                MachineEditor mach=MachineEditor.CreateNew();
                if (group != Guid.Empty)
                {
                    BetaGroupEditor.FromId(group).AddMachine(mach.Id); //todo: check if it exists?
                }

                //call the api
                XRLGetLiveConfig xrl=new XRLGetLiveConfig();
                xrl.Request.configname = platform.ToString().ToLower();
                xrl.Slot.machinePuid=mach.Id;
                xrl.SetClientVersion(2, 0, (build ?? ushort.MaxValue), (qfe ?? ushort.MaxValue));
                xrl.SetBetaGroupFlag(group != Guid.Empty);

                if (!xrl.Execute())
                {
                    throw new UnexpectedTestResultException("LiveInfo request failed.  XRLGetLiveConfig response: "+xrl.ErrorStatusMessage); //this may indicate that the test should be expecting failure from the mix API call
                }

                Dictionary<string, string> hiveResults = xrl.ParseResponseSettings(false);

                //first verify that both results have the same list of settings
                LinkedList<string> mixResultSettings = new LinkedList<string>();
                foreach (LiveHiveSetting lhs in mixResults)
                {
                    mixResultSettings.AddLast(lhs.Name);
                }

                try
                {
                    ValueCheck.TestAllUnordered("Mix reply", hiveResults.Keys, mixResultSettings);
                }
                catch
                {
                    // because i get confused
                    Global.RO.Debug("Liveinfo results are expect, Mix results are got");
                    throw;
                }

                //then verify that each setting has the same value
                string badSettings = "\n";
                foreach (LiveHiveSetting lhs in mixResults)
                {
                    if (hiveResults[lhs.Name] != lhs.Value)
                    {
                        badSettings += "Value for setting " + lhs.Name + " is incorrect.  LiveInfo: " + hiveResults[lhs.Name] + 
                            ", Mix: " + lhs.Value + "\n";
                    }
                }

                if (badSettings.Length > 1)
                {
                    throw new UnexpectedTestResultException(badSettings);
                }

                // make sure config source is as expected
                if (source != ConfigSource.Unknown)
                {
                    LiveHiveConfig mixSource = mixResults[0].Config;

                    ValueCheck.Test("Config source: Client", PlatformType.Xenon, mixSource.PlatformType);

                    if (source == ConfigSource.Build || source == ConfigSource.Beta)
                    {
                        ValueCheck.Test("Config source: Build", build, mixSource.Build);
                        ValueCheck.Test("Config source: Qfe", qfe, mixSource.Qfe);
                        ValueCheck.Test("Config source: BetaGroupId",
                            (source == ConfigSource.Build ? Guid.Empty : group), mixSource.BetaGroupId);
                    }
                    else
                    {
                        // make sure that everything is empty
                        ValueCheck.Test("Config source: Build", (uint?)null, mixSource.Build);
                        ValueCheck.Test("Config source: Qfe", (uint?)null, mixSource.Qfe);
                        ValueCheck.Test("Config source: BetaGroupId", Guid.Empty, mixSource.BetaGroupId);
                    }
                }

                // make sure value of our setting is as expected
                if (value != "")
                {
                    bool found = false;

                    foreach (LiveHiveSetting lhs in mixResults)
                    {
                        if (lhs.Name == SettingsManagementCommon.TestSettingName)
                        {
                            // we were supposed to remove the setting!
                            if (value == null)
                            {
                                throw new UnexpectedTestResultException("Found our test setting in the Mix results.  It should have been removed.");
                            }

                            ValueCheck.Test("SettingsGroup Value", value, lhs.Value);
                            found = true;
                            break;
                        }
                    }

                    if (!found && value != null)
                    {
                        throw new UnexpectedTestResultException("Did not find our test setting in the Mix results.");
                    }
                }
            }
        }

        public class GetSettingsGroupListTestChild : SettingsGroupListTestChild
        {
            public override void Run()
            {
                CallAndVerify(HResult.S_OK, PlatformType.Xenon, TheGroup.Build, TheGroup.Qfe, TheGroup.Group,
                    (TheGroup.Group == Guid.Empty ? ConfigSource.Build : ConfigSource.Beta),
                    TheGroup.Value);
            }
        }

        #endregion

        #region Setup

        public override void OneTimeSetup ()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetSettings");
        }

        public override void PreRun ()
        {
            foreach (SettingsGroup sg in SettingsManagementCommon.BetaGroups)
            {
                SetupSettingsGroup(sg);
            }

            foreach (SettingsGroup sg in SettingsManagementCommon.Builds)
            {
                SetupSettingsGroup(sg);
            }

            // reload liveinfo
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);
        }

        public override void PostRun ()
        {
            // clean up the settings mess that we have made
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.ExecuteScalar("Delete from t_live_registry_settings where vc_setting = '" + SettingsManagementCommon.TestSettingName + "'");
            }

            // reload liveinfo
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);
        }

        public void SetupSettingsGroup (SettingsGroup sg)
        {
            BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(sg.Group);

            // add the setting for this setup
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.ExecuteScalar(string.Format("exec p_live_registry_set_setting '{0}', 'xenon', '{1}', '{2}', {3}, {4}, 0, '{5}'",
                    xonline.common.config.Config.Environment, SettingsManagementCommon.TestSettingName, sg.Value,
                    sg.Build, sg.Qfe, sg.Group
                    ));
            }
        }

        #endregion

        #region Mainline

        [TestCase, TestCasePriority(1), Description("Positive mainline case.")]
        public void SimpleMainline()
        {
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, 7371, 0, Guid.Empty, ConfigSource.Unknown, 0);
        }

        #endregion

        #region Platform

        [TestCase, TestCasePriority(1), Description("Platforms other than Xenon are not supported right now.")]
        public void NonXenonPlatform ()
        {
            CallAndVerify(HResult.XONLINE_E_MIX_INVALID_PLATFORM, PlatformType.PC, 7371, 0, Guid.Empty, ConfigSource.Unknown, 0);
        }

        #endregion

        #region Build

        [TestCase, TestCasePriority(1), Description("Different builds.")]
        public class Build : SettingsGroupListTestNode<GetSettingsGroupListTestChild>
        {
            public override SettingsGroup[] GetSettingsGroupList ()
            {
                return SettingsManagementCommon.Builds;
            }
        }

        /* Obselete after changing data types, there's no build or qfe that is too big.
        [TestCase, TestCasePriority(3), Description("Build and/or qfe are null.")]
        [CompoundCase("Build", 12039834, 0)]
        [CompoundCase("Qfe", 7371, 9664554)]
        [CompoundCase("BuildAndQfe", 3454354, 678732213)]
        public class LargeBuilds : TestNode
        {
            public override TEST_RESULTS Run ()
            {
                ushort build = (ushort)(int)MyValues[0];
                ushort qfe = (ushort)(int)MyValues[1];
                CallAndVerify(HResult.S_OK, PlatformType.Xenon, build, qfe, Guid.Empty, ConfigSource.Unknown, 0);

                return TEST_RESULTS.PASSED;
            }
        }
        */

        [TestCase, TestCasePriority(3), Description("Build and/or qfe are null.")]
        [CompoundCase("Build", true, false)]
        [CompoundCase("Qfe", false, true)]
        [CompoundCase("BuildAndQfe", true, true)]
        public class NullBuilds : TestNode
        {
            public override void Run()
            {
                bool build = (bool)MyValues[0];
                bool qfe = (bool)MyValues[1];

                SettingsGroup sg = null;
                foreach (SettingsGroup s in SettingsManagementCommon.BetaGroups)
                {
                    if (s.Qfe != 0)
                    {
                        sg = s;
                        break;
                    }
                }

                if(build && qfe)
                {
                    // Test the case where the builds are null, and you're getting just xenon settings.
                    CallAndVerify(HResult.S_OK, PlatformType.Xenon, null, null, Guid.Empty, ConfigSource.Client, 0);
                }
                else
                {
                    CallAndVerify(HResult.XONLINE_E_MIX_INVALID_CONFIG, PlatformType.Xenon, (build ? null : (ushort?)sg.Build), (qfe ? null : (ushort?)sg.Qfe), sg.Group, ConfigSource.Client, 0);
                }
            }
        }

        #endregion

        #region Beta Group

        [TestCase, TestCasePriority(1), Description("Different beta groups.")]
        public class BetaGroup : SettingsGroupListTestNode<GetSettingsGroupListTestChild>
        {
            public override SettingsGroup[] GetSettingsGroupList ()
            {
                return SettingsManagementCommon.BetaGroups;
            }
        }

        [TestCase, TestCasePriority(2), Description("Guid.NewGuid() [random] given for beta group.")]
        public void BetaNewGuid ()
        {
            SettingsGroup sg = SettingsManagementCommon.Builds[0];
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, sg.Build, sg.Qfe, Guid.NewGuid(), ConfigSource.Build, sg.Value);
        }

        [TestCase, TestCasePriority(3), Description("Guid.MaxValue given for beta group.")]
        public void BetaMaxGuid ()
        {
            SettingsGroup sg = SettingsManagementCommon.Builds[0];
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, sg.Build, sg.Qfe, new Guid("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"), 
                ConfigSource.Build, sg.Value);
        }

        #endregion

        #region Negative

        [TestCase, TestCasePriority(3), Description("Send a null value to the mix api.")]
        public void NullLiveHiveConfig ()
        {
            SettingsManagementWCFClient client = new SettingsManagementWCFClient();
            client.ExpectedHR = HResult.XONLINE_E_MIX_ARGUMENT_NULL;
            LiveHiveSetting[] mixResults = client.GetSettings(null);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\TestSuite.cs ===
using ServerTestFramework;

[assembly:RootNode(typeof(MixClientSettingsManagementTest.MixClientSettingsManagementTest))]

namespace MixClientSettingsManagementTest
{
    public class MixClientSettingsManagementTest: TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StatsTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace MixTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\NetworkAuth.cs ===
using System;
using System.Linq;

using ServerTestFramework;
using xonline.common.config;
using MIXTesting;
using ServerTestFramework.Utilities;
using xonline.mix.settingsmanagement.contracts.V3;
using xonline.common.sql.webstore;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;

namespace MixTest.SettingsManagement.V3
{
    /// <summary>
    /// BVTs are sufficient for the zero parameter APIs:
    /// GetClaimTypes
    /// GetTokenTypes
    /// 
    /// GetAppliesToInfo is tested by every positive SetAppliesToInfo and RemoveAppliesToInfo test.
    /// </summary>
    [TestGroup, Owner("benran"), Description("Tests for the NetworkAuth mix API")]
    public class STSConfigurationV3 : TestNode
    {
        public override void PreRun()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.SetBusinessPartner");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.SetAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.RemoveAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetClaimTypes");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetTokenTypes");

            MixSettingsHelperV3.Initialize();
            if (MixSettingsHelperV3.ClaimTypes.Count == 0)
            {
                Global.RO.Warn("Unable to load any claim types.  Verify that secdb is properly populated.");
            }
        }

        public override void PostRun()
        {
            MixSettingsHelperV3.CleanTestData();
        }

        #region ValueCheck Helpers

        #region BusinessPartner

        public static void ValueCheckBusinessPartners (BusinessPartner expected, FullBusinessPartnerV3 actual)
        {
            ValueCheckBusinessPartners("BusinessPartner", expected, actual);
        }

        public static void ValueCheckBusinessPartners (string description, BusinessPartner expected, FullBusinessPartnerV3 actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheckConnectionInfos(description + ".ConnectionInfos", expected.ConnectionInfos, actual.ConnectionInfos);
        }

        public static void ValueCheckBusinessPartners (FullBusinessPartnerV3 expected, FullBusinessPartnerV3 actual)
        {
            ValueCheckBusinessPartners("FullBusinessPartner", expected, actual);
        }

        public static void ValueCheckBusinessPartners (string description, FullBusinessPartnerV3 expected, FullBusinessPartnerV3 actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheck.Test(description + ".AnonymizingSalt", expected.AnonymizingSalt, actual.AnonymizingSalt);
            ValueCheckConnectionInfos(description + ".ConnectionInfos", expected.ConnectionInfos, actual.ConnectionInfos);
            ValueCheckBusinessPartnerKeys(description + ".Keys", expected.Keys, actual.Keys);
        }

        public static void ValueCheckConnectionInfos (string description, BusinessPartnerConnectionInfo[] expected,
            BusinessPartnerConnectionInfo[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckConnectionInfo(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckConnectionInfo (string description, BusinessPartnerConnectionInfo expected,
            BusinessPartnerConnectionInfo actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheck.Test(description + ".BusinessPartnerSGCertificate", expected.BusinessPartnerSGCertificate,
                actual.BusinessPartnerSGCertificate);
        }

        public static void ValueCheckBusinessPartnerKeys (string description, FullBusinessPartnerV3.BusinessPartnerKey[] expected,
            FullBusinessPartnerV3.BusinessPartnerKey[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckBusinessPartnerKey(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckBusinessPartnerKey (string description, FullBusinessPartnerV3.BusinessPartnerKey expected,
            FullBusinessPartnerV3.BusinessPartnerKey actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".KeyVersion", expected.KeyVersion, actual.KeyVersion);
            ValueCheck.Test(description + ".MasterKeyVersion", expected.MasterKeyVersion, actual.MasterKeyVersion);
            ValueCheck.Test(description + ".EncryptedKey", expected.EncryptedKey, actual.EncryptedKey);
            ValueCheck.Test(description + ".EncryptedIv", expected.EncryptedIv, actual.EncryptedIv);
        }

        #endregion

        #region AppliesTo

        public static void ValueCheckSTSAppliesTo (STSAppliesTo expected, STSAppliesTo actual)
        {
            ValueCheckSTSAppliesTo("STSAppliesTo", expected, actual);
        }

        public static void ValueCheckSTSAppliesTo (string description, STSAppliesTo expected, STSAppliesTo actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".AppliesToUri", expected.AppliesToUri, actual.AppliesToUri);
            ValueCheck.Test(description + ".ValidityInterval", expected.ValidityInterval, actual.ValidityInterval);
            ValueCheck.Test(description + ".TokenType", expected.TokenType, actual.TokenType);
            ValueCheck.Test(description + ".AppliesToCertificate", expected.AppliesToCertificate, actual.AppliesToCertificate);
            ValueCheckSTSAppliesToClaimTypes(description + ".ClaimTypes", expected.ClaimTypes, actual.ClaimTypes);
        }

        public static void ValueCheckSTSAppliesToClaimTypes (string description, STSAppliesToClaimType[] expected,
            STSAppliesToClaimType[] actual)
        {
            ValueCheck.TestAllUnordered(description, expected, actual, MixSettingsHelperV3.AppliesToClaimTypeEquals);
        }

        public static void ValueCheckSTSAppliesToClaimType (string description, STSAppliesToClaimType expected,
            STSAppliesToClaimType actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".ClaimTypeUri", expected.ClaimTypeUri, actual.ClaimTypeUri);
            ValueCheck.Test(description + ".Required", expected.Required, actual.Required);
        }

        #endregion

        #region ClaimTypeInfo

        public static void ValueCheckSTSClaimTypeInfos (string description, STSClaimTypeInfo[] expected,
            STSClaimTypeInfo[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckSTSClaimTypeInfo(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckSTSClaimTypeInfo (string description, STSClaimTypeInfo expected,
            STSClaimTypeInfo actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".ClaimTypeUri", expected.ClaimTypeUri, actual.ClaimTypeUri);
            ValueCheck.Test(description + ".Encrypted", expected.Encrypted, actual.Encrypted);
            ValueCheck.Test(description + ".Title", expected.Title, actual.Title);
            ValueCheck.Test(description + ".Description", expected.Description, actual.Description);
            ValueCheck.Test(description + ".ValueType", expected.ValueType, actual.ValueType);
        }

        #endregion

        #endregion

        public class CreateBusinessPartnerBase : TestNode
        {
            protected MixSettingsHelperV3 Helper;

            public override void PreRun ()
            {
                base.PreRun();

                Helper = new MixSettingsHelperV3();
                Helper.SetBusinessPartner();
            }
        }

        public class SetAppliesToBase : CreateBusinessPartnerBase
        {
            public override void PreRun ()
            {
                base.PreRun();

                Helper.SetAppliesToInfo();
            }
        }

        [TestGroup]
        public class BVT : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetClaimTypes ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                var claimTypes = helper.Client.GetClaimTypes();
                ValueCheckSTSClaimTypeInfos("ClaimTypes", MixSettingsHelperV3.ClaimTypes["Partner"].Values.ToArray(), claimTypes);

                Global.RO.Success("{0} Claim(s) Successfully Retrieved", claimTypes.Length);
                foreach (var claim in claimTypes)
                {
                    Global.RO.Success("{0}: {1} ({2}) Encrypted: {3}", claim.Description, claim.ClaimTypeUri, claim.Encrypted ? "True" : "False", claim.Title);
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetTokenTypes ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                var tokenTypes = helper.Client.GetTokenTypes();
                ValueCheck.TestAllUnordered("TokenTypes", MixSettingsHelperV3.TokenTypes, tokenTypes);

                Global.RO.Success("{0} Token Type(s) Successfully Retrieved", tokenTypes.Length);
                foreach (var token in tokenTypes)
                {
                    Global.RO.Success(token);
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void SetBusinessPartner ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();
                helper.SetBusinessPartner();

                Global.RO.Success("SetBusinessPartner call succeeded");
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void SetAppliesToInfo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();
                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                helper.SetAppliesToInfo();

                Global.RO.Success("SetAppliesToInfo call succeeded");
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetAppliesTo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();
                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                //STSAppliesTo appliesTo = helper.GenerateAppliesTo();
                helper.SetAppliesToInfo();

                STSAppliesTo expectedAppliesTo = helper.AppliesTos[0];
                STSAppliesTo actualAppliesTo = helper.GetAppliesToInfo(expectedAppliesTo.AppliesToUri);

                ValueCheckSTSAppliesTo(expectedAppliesTo, actualAppliesTo);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void RemoveAppliesTo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                helper.SetAppliesToInfo();

                STSAppliesTo appliesTo = helper.AppliesTos[0];

                helper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                bool failed = false;
                try
                {
                    helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                    failed = true;
                }
                catch
                {
                    Global.RO.Success("RemoveAppliesToInfo successfully removed the applies to info");
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                }
            }

        }

        [TestGroup]
        public class SetBusinessPartner : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Verifies that SetBusinessPartner succeeds and verifies the results.")]
            public void Mainline ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 inDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, inDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that setting the same partner again works.")]
            public void SetSameAgain ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("First", bp, firstDB);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Second", bp, secondDB);

                // check the two db pulls against each other
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that changing the name doesn't change anything else.")]
            public void ChangeFriendlyName ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                // change the name
                bp.FriendlyName = "MixSettingsTestBusinessPartner_" + Guid.NewGuid().ToString();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.FriendlyName = secondDB.FriendlyName;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that adding a connection info works.")]
            public void AddConnectionInfo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                List<BusinessPartnerConnectionInfo> cis = new List<BusinessPartnerConnectionInfo>(bp.ConnectionInfos);
                cis.Add(new BusinessPartnerConnectionInfo()
                {
                    FriendlyName = "MixSettingsTestBusinessPartnerConnectionInfo_NewConnectionInfo",
                    BusinessPartnerSGCertificate = MixSettingsHelperV3.OtherCert
                });
                bp.ConnectionInfos = cis.ToArray();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that changing a connection info cert works.")]
            public void ChangeConnectionInfoCert ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                bp.ConnectionInfos[0].BusinessPartnerSGCertificate = MixSettingsHelperV3.OtherCert;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that changing a connection info name works.")]
            public void ChangeConnectionInfoName ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Created", bp, firstDB);

                bp.ConnectionInfos[0].FriendlyName += "!";

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Modified", bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that removing a single connection info works.")]
            public void RemoveConnectionInfo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner(2);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                List<BusinessPartnerConnectionInfo> cis = new List<BusinessPartnerConnectionInfo>(bp.ConnectionInfos);
                cis.RemoveAt(0);
                bp.ConnectionInfos = cis.ToArray();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that removing all connection infos works.")]
            public void RemoveAllConnectionInfo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner(2);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0];

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 secondDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null name fails.")]
            public void NullFriendlyName ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.FriendlyName = null;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Friendly name is null or empty.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null name fails.")]
            public void EmptyFriendlyName ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.FriendlyName = "";

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Something about a bad param.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list works.")]
            public void NullConnectionInfo ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos = null;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list member works.")]
            public void NullConnectionInfoMember ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[] { null };

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list member field works.")]
            public void NullConnectionInfoMemberField ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos[0].FriendlyName = null;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a zero guid fails.")]
            public void ZeroGuid ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.BusinessPartnerID = Guid.Empty;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "00000000-0000-0000-0000-000000000000 Xbox LIVE is a private Business Partner.  You cannot modify.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that setting a second business partner with the same name keeps the old one.")]
            public void SameNameDifferentGuid ()
            {
                MixSettingsHelperV3 helper = new MixSettingsHelperV3();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV3 firstDB = new FullBusinessPartnerV3(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                // create another partner with the same name
                BusinessPartner bp2 = helper.GenerateBusinessPartner();
                bp2.FriendlyName = bp.FriendlyName;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp2);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Something about that partner name already existing.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a private business partner cannot be updated")]
            public class PrivatePartner : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // Make the business partner private
                    using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        client.CommandSql = String.Format(
                            "update t_sts_business_partner set i_business_partner_type = 0 where uid_business_partner_id = '{0}'",
                            Helper.BusinessPartner.BusinessPartnerID);

                        client.ExecuteNonQuery();
                    }

                    Boolean success = false;
                    try
                    {
                        Helper.SetBusinessPartner(Helper.BusinessPartner);
                        success = true;
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("{0} {1} is a private Business Partner.  You cannot modify.",
                            Helper.BusinessPartner.BusinessPartnerID, Helper.BusinessPartner.FriendlyName);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                        Global.RO.Success("Request failed as expecetd with private business partner.");
                    }

                    if (success)
                    {
                        throw new UnexpectedTestResultException("Request should have failed with private business partner.");
                    }
                }
            }
        }

        [TestGroup]
        public class SetAppliesToInfo : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Calls SetAppliesToInfo and verifies the result.")]
            public class Mainline : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo gat = Helper.GetAppliesToInfo(sat.AppliesToUri);

                    ValueCheckSTSAppliesTo(sat, gat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Sets the same thing twice.")]
            public class SetSameAgain : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // again
                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Creates two AppliesTos and validates both.")]
            public class TwoAppliesTos : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    STSAppliesTo sat2 = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);
                    Helper.SetAppliesToInfo(sat2);

                    STSAppliesTo gat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    STSAppliesTo gat2 = Helper.GetAppliesToInfo(sat2.AppliesToUri);

                    ValueCheckSTSAppliesTo(sat, gat);
                    ValueCheckSTSAppliesTo(sat2, gat2);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null applies to uri.")]
            public class NullAppliesToUri : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToUri = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an empty applies to uri.")]
            public class EmptyAppliesToUri : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToUri = "";

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Changes business partner and verifies the change.")]
            public class ChangeBusinessPartner : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    BusinessPartner bp = Helper.GenerateBusinessPartner();
                    Helper.SetBusinessPartner(bp);
                    sat.BusinessPartnerID = bp.BusinessPartnerID;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid business partner.")]
            public class InvalidBusinessPartner : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.BusinessPartnerID = Guid.NewGuid();

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes validity interval and verifies the change.")]
            public class ChangeValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ValidityInterval = sat.ValidityInterval.Add(TimeSpan.FromHours(1));

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an a zero validity interval.")]
            public class ZeroValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ValidityInterval = TimeSpan.Zero;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an a negative validity interval.")]
            public class NegativeValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ValidityInterval = TimeSpan.FromHours(-4);

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes token type and verifies the change.")]
            public class ChangeTokenType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.TokenType = MixSettingsHelperV3.TokenTypes[(MixSettingsHelperV3.TokenTypes.IndexOf(sat.TokenType) + 1) % 
                        MixSettingsHelperV3.TokenTypes.Count];

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid token type.")]
            public class InvalidTokenType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.TokenType = "InvalidTokenType";

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null token type.")]
            public class NullTokenType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.TokenType = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes the cert and verifies the change.")]
            public class ChangeCert : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.AppliesToCertificate = MixSettingsHelperV3.OtherCert;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid cert.")]
            public class InvalidCert : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToCertificate = "NotACert";

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null cert.")]
            public class NullCert : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToCertificate = null;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);

                    //throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes the claim type and verifies the change.")]
            public class ChangeClaimType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes[0] = MixSettingsHelperV3.FirstPartnerClaimTypes(2)[1];

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Adds a claim type and verifies the change.")]
            public class AddClaimType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Removes a claim type and verifies the change.")]
            public class RemoveClaimType : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Removes all claim types and verifies the change.")]
            public class RemoveAllClaimTypes : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV3.FirstPartnerClaimTypes(0);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list.")]
            public class NullClaimTypes : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list member.")]
            public class NullClaimTypeMember : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = new STSAppliesToClaimType[] { null };

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list member field.")]
            public class NullClaimTypeMemberField : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes[0].ClaimTypeUri = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempts to modify applies to info associated with a private business partner")]
            public class PrivatePartner : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // Make the business partner private
                    using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        client.CommandSql = String.Format(
                            "update t_sts_business_partner set i_business_partner_type = 0 where uid_business_partner_id = '{0}'",
                            Helper.BusinessPartner.BusinessPartnerID);

                        client.ExecuteNonQuery();
                    }

                    STSAppliesTo at = Helper.GenerateAppliesTo(1);

                    bool success = false;
                    try
                    {
                        Helper.SetAppliesToInfo(at);
                        success = true;
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("{0} {1} is a private Business Partner.  You cannot modify.", 
                            Helper.BusinessPartner.BusinessPartnerID, Helper.BusinessPartner.FriendlyName);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                        Global.RO.Success("Request failed as expecetd with private business partner.");
                    }

                    if (success)
                    {
                        throw new UnexpectedTestResultException("Request should have failed with private business partner.");
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Attempts to use a private claim.")]
            public class PrivateClaim : CreateBusinessPartnerBase
            {
                public override void Run ()
                {
                    STSAppliesTo sat = Helper.GenerateAppliesTo(1);
                    var privateOnly = MixSettingsHelperV3.ClaimTypes["Private"].Keys.Except(MixSettingsHelperV3.ClaimTypes["Partner"].Keys).Take(1).Select(c => new STSAppliesToClaimType
                    {
                        ClaimTypeUri = c,
                        Required = RandomEx.GlobalRandGen.NextBool(),
                    }).ToArray();
                    sat.ClaimTypes = privateOnly;

                    bool success = false;
                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        success = true;
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", sat.ClaimTypes[0].ClaimTypeUri + " is a private claim type.  You cannot use it.", 
                            e.InnerException.Message);
                    }

                    if (success)
                    {
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                }
            }
        }

        [TestGroup]
        public class RemoveAppliesToInfo : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Removes a valid applies to.")]
            public class Mainline : SetAppliesToBase
            {
                public override void Run ()
                {
                    STSAppliesTo appliesTo = Helper.AppliesTos[0];

                    Helper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    bool failed = false;
                    try
                    {
                        Helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                        failed = true;
                    }
                    catch(UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("The appliesto url: {0} isn't configured.",
                            appliesTo.AppliesToUri);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Removes an applies to that does not exist.")]
            public class DoesNotExist : SetAppliesToBase
            {
                public override void Run ()
                {
                    STSAppliesTo appliesTo = Helper.AppliesTos[0];

                    Helper.RemoveAppliesToInfo("http://doesnotexist/");

                    STSAppliesTo inDB = Helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                    ValueCheckSTSAppliesTo(appliesTo, inDB);
                }
            }

            [TestCase(BugID=223113, BugDatabase="ISSAll"), TestCasePriority(1), Description("Attempts to remove an AppliesTo with endpoints.")]
            public class HasEndpoints : TestNode
            {
                public override void Run ()
                {
                    // add endpoints
                    MixTest.TitleManagement.TitleManagementHelperV3 titleHelper = new MixTest.TitleManagement.TitleManagementHelperV3();
                    titleHelper.Initialize();

                    titleHelper.GenerateNetworkSecurityList();

                    // attempt to remove it
                    STSAppliesTo appliesTo = titleHelper.SettingsHelper.AppliesTos[0];

                    try
                    {
                        titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);
                    }
                    catch
                    {
                        Global.RO.Info("Unable to remove AppliesTo associated with endpoints");
                    }

                    STSAppliesTo got = titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri);

                    // make sure they are the same
                    ValueCheckSTSAppliesTo(appliesTo, got);
                }
            }

            [TestCase(BugID = 223113, BugDatabase = "ISSAll"), TestCasePriority(1), Description("Attempts to remove an AppliesTo that had endpoints, but they are gone.")]
            public class HasEndpointsNoMore : TestNode
            {
                public override void Run ()
                {
                    // add endpoints
                    MixTest.TitleManagement.TitleManagementHelperV3 titleHelper = new MixTest.TitleManagement.TitleManagementHelperV3();
                    titleHelper.Initialize();

                    titleHelper.GenerateNetworkSecurityList();

                    // attempt to remove it
                    STSAppliesTo appliesTo = titleHelper.SettingsHelper.AppliesTos[0];

                    try
                    {
                        titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);
                    }
                    catch
                    {
                        Global.RO.Info("Unable to remove AppliesTo associated with endpoints");
                    }

                    STSAppliesTo got = titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri);

                    // make sure they are the same
                    ValueCheckSTSAppliesTo("HadEndpoints", appliesTo, got);

                    // remove the endpoints
                    titleHelper.SetNetworkSecurityList(new xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[0]);

                    // remove the applies to again
                    titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    bool failed = false;
                    try
                    {
                        titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri);
                        failed = true;
                    }
                    catch
                    {
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StatsTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\NetworkAuthV4.cs ===
using System;
using System.Linq;

using ServerTestFramework;
using xonline.common.config;
using MIXTesting;
using ServerTestFramework.Utilities;
using xonline.common.sql.webstore;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;

namespace MixTest.SettingsManagement.V4
{
    using xonline.mix.settingsmanagement.contracts.V4;
    /// <summary>
    /// BVTs are sufficient for the zero parameter APIs:
    /// GetClaimTypes
    /// GetTokenTypes
    /// 
    /// GetAppliesToInfo is tested by every positive SetAppliesToInfo and RemoveAppliesToInfo test.
    /// </summary>
    [TestGroup, Owner("benran"), Description("Tests for the NetworkAuth mix API")]
    public class STSConfigurationV4 : TestNode
    {
        public override void PreRun()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.SetBusinessPartner");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.SetAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.RemoveAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetAppliesToInfo");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetClaimTypes");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetTokenTypes");
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.GetBusinessPartnerTypes");

            MixSettingsHelperV4.Initialize();
            if (MixSettingsHelperV4.ClaimTypes.Count == 0)
            {
                Global.RO.Warn("Unable to load any claim types.  Verify that secdb is properly populated.");
            }
        }

        public override void PostRun()
        {
            MixSettingsHelperV3.CleanTestData();
        }

        #region ValueCheck Helpers

        #region BusinessPartner

        public static void ValueCheckBusinessPartners(BusinessPartner expected, FullBusinessPartnerV4 actual)
        {
            ValueCheckBusinessPartners("BusinessPartner", expected, actual);
        }

        public static void ValueCheckBusinessPartners(string description, BusinessPartner expected, FullBusinessPartnerV4 actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheck.Test(description + ".Type", expected.Type, actual.Type);
            ValueCheckConnectionInfos(description + ".ConnectionInfos", expected.ConnectionInfos, actual.ConnectionInfos);
        }

        public static void ValueCheckBusinessPartners(FullBusinessPartnerV4 expected, FullBusinessPartnerV4 actual)
        {
            ValueCheckBusinessPartners("FullBusinessPartner", expected, actual);
        }

        public static void ValueCheckBusinessPartners(string description, FullBusinessPartnerV4 expected, FullBusinessPartnerV4 actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheck.Test(description + ".AnonymizingSalt", expected.AnonymizingSalt, actual.AnonymizingSalt);
            ValueCheck.Test(description + ".Type", expected.Type, actual.Type);
            ValueCheckConnectionInfos(description + ".ConnectionInfos", expected.ConnectionInfos, actual.ConnectionInfos);
            ValueCheckBusinessPartnerKeys(description + ".Keys", expected.Keys, actual.Keys);
        }

        public static void ValueCheckConnectionInfos(string description, BusinessPartnerConnectionInfo[] expected,
            BusinessPartnerConnectionInfo[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckConnectionInfo(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckConnectionInfo(string description, BusinessPartnerConnectionInfo expected,
            BusinessPartnerConnectionInfo actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".FriendlyName", expected.FriendlyName, actual.FriendlyName);
            ValueCheck.Test(description + ".BusinessPartnerSGCertificate", expected.BusinessPartnerSGCertificate,
                actual.BusinessPartnerSGCertificate);
        }

        public static void ValueCheckBusinessPartnerKeys(string description, FullBusinessPartnerV4.BusinessPartnerKey[] expected,
            FullBusinessPartnerV4.BusinessPartnerKey[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckBusinessPartnerKey(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckBusinessPartnerKey(string description, FullBusinessPartnerV4.BusinessPartnerKey expected,
            FullBusinessPartnerV4.BusinessPartnerKey actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".KeyVersion", expected.KeyVersion, actual.KeyVersion);
            ValueCheck.Test(description + ".MasterKeyVersion", expected.MasterKeyVersion, actual.MasterKeyVersion);
            ValueCheck.Test(description + ".EncryptedKey", expected.EncryptedKey, actual.EncryptedKey);
            ValueCheck.Test(description + ".EncryptedIv", expected.EncryptedIv, actual.EncryptedIv);
        }

        #endregion

        #region AppliesTo

        public static void ValueCheckSTSAppliesTo(STSAppliesTo expected, STSAppliesTo actual)
        {
            ValueCheckSTSAppliesTo("STSAppliesTo", expected, actual);
        }

        public static void ValueCheckSTSAppliesTo(string description, STSAppliesTo expected, STSAppliesTo actual)
        {
            ValueCheck.Test(description + ".BusinessPartnerID", expected.BusinessPartnerID, actual.BusinessPartnerID);
            ValueCheck.Test(description + ".AppliesToUri", expected.AppliesToUri, actual.AppliesToUri);
            ValueCheck.Test(description + ".ValidityInterval", expected.ValidityInterval, actual.ValidityInterval);
            ValueCheck.Test(description + ".TokenType", expected.TokenType, actual.TokenType);
            ValueCheck.Test(description + ".AppliesToCertificate", expected.AppliesToCertificate, actual.AppliesToCertificate);
            ValueCheckSTSAppliesToClaimTypes(description + ".ClaimTypes", expected.ClaimTypes, actual.ClaimTypes);
        }

        public static void ValueCheckSTSAppliesToClaimTypes(string description, STSAppliesToClaimType[] expected,
            STSAppliesToClaimType[] actual)
        {
            ValueCheck.TestAllUnordered(description, expected, actual, MixSettingsHelperV4.AppliesToClaimTypeEquals);
        }

        public static void ValueCheckSTSAppliesToClaimType(string description, STSAppliesToClaimType expected,
            STSAppliesToClaimType actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".ClaimTypeUri", expected.ClaimTypeUri, actual.ClaimTypeUri);
            ValueCheck.Test(description + ".Required", expected.Required, actual.Required);
        }

        #endregion

        #region ClaimTypeInfo

        public static void ValueCheckSTSClaimTypeInfos(string description, STSClaimTypeInfo[] expected,
            STSClaimTypeInfo[] actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".Length", expected.Length, actual.Length);
            for (int i = 0; i < expected.Length; ++i)
            {
                ValueCheckSTSClaimTypeInfo(description + "[" + i + "]", expected[i], actual[i]);
            }
        }

        public static void ValueCheckSTSClaimTypeInfo(string description, STSClaimTypeInfo expected,
            STSClaimTypeInfo actual)
        {
            ValueCheck.IsFalse((expected == null) ^ (actual == null), description + "<nullness>");
            if (expected == null) return;

            ValueCheck.Test(description + ".ClaimTypeUri", expected.ClaimTypeUri, actual.ClaimTypeUri);
            ValueCheck.Test(description + ".Encrypted", expected.Encrypted, actual.Encrypted);
            ValueCheck.Test(description + ".Title", expected.Title, actual.Title);
            ValueCheck.Test(description + ".Description", expected.Description, actual.Description);
            ValueCheck.Test(description + ".ValueType", expected.ValueType, actual.ValueType);
        }

        #endregion

        #endregion

        public class CreateBusinessPartnerBase : TestNode
        {
            protected MixSettingsHelperV4 Helper;

            public override void PreRun()
            {
                base.PreRun();

                Helper = new MixSettingsHelperV4();
                Helper.SetBusinessPartner();
            }
        }

        public class SetAppliesToBase : CreateBusinessPartnerBase
        {
            public override void PreRun()
            {
                base.PreRun();

                Helper.SetAppliesToInfo();
            }
        }

        [TestGroup]
        public class BVT : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetClaimTypes()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                var claimTypes = helper.Client.GetClaimTypes("Partner");
                ValueCheckSTSClaimTypeInfos("ClaimTypes", MixSettingsHelperV4.ClaimTypes["Partner"].Values.ToArray(), claimTypes);

                Global.RO.Success("{0} Claim(s) Successfully Retrieved", claimTypes.Length);
                foreach (var claim in claimTypes)
                {
                    Global.RO.Success("{0}: {1} ({2}) Encrypted: {3}", claim.Description, claim.ClaimTypeUri, claim.Encrypted ? "True" : "False", claim.Title);
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetTokenTypes()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                var tokenTypes = helper.Client.GetTokenTypes();
                ValueCheck.TestAllUnordered("TokenTypes", MixSettingsHelperV4.TokenTypes, tokenTypes);

                Global.RO.Success("{0} Token Type(s) Successfully Retrieved", tokenTypes.Length);
                foreach (var token in tokenTypes)
                {
                    Global.RO.Success(token);
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void SetBusinessPartner()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();
                helper.SetBusinessPartner();

                Global.RO.Success("SetBusinessPartner call succeeded");
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void SetAppliesToInfo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();
                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                helper.SetAppliesToInfo();

                Global.RO.Success("SetAppliesToInfo call succeeded");
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void GetAppliesTo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();
                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                //STSAppliesTo appliesTo = helper.GenerateAppliesTo();
                helper.SetAppliesToInfo();

                STSAppliesTo expectedAppliesTo = helper.AppliesTos[0];
                STSAppliesTo actualAppliesTo = helper.GetAppliesToInfo(expectedAppliesTo.AppliesToUri);

                ValueCheckSTSAppliesTo(expectedAppliesTo, actualAppliesTo);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that the ____ API succeeds with valid input")]
            public void RemoveAppliesTo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // Make a business partner
                helper.SetBusinessPartner();

                // Generate a random applies to
                helper.SetAppliesToInfo();

                STSAppliesTo appliesTo = helper.AppliesTos[0];

                helper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                bool failed = false;
                try
                {
                    helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                    failed = true;
                }
                catch
                {
                    Global.RO.Success("RemoveAppliesToInfo successfully removed the applies to info");
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                }
            }

        }

        [TestGroup]
        public class SetBusinessPartner : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Verifies that SetBusinessPartner succeeds and verifies the results.")]
            public void Mainline()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 inDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, inDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that setting the same partner again works.")]
            public void SetSameAgain()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("First", bp, firstDB);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Second", bp, secondDB);

                // check the two db pulls against each other
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that changing the name doesn't change anything else.")]
            public void ChangeFriendlyName()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                // change the name
                bp.FriendlyName = "MixSettingsTestBusinessPartner_" + Guid.NewGuid().ToString();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.FriendlyName = secondDB.FriendlyName;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that adding a connection info works.")]
            public void AddConnectionInfo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                List<BusinessPartnerConnectionInfo> cis = new List<BusinessPartnerConnectionInfo>(bp.ConnectionInfos);
                cis.Add(new BusinessPartnerConnectionInfo()
                {
                    FriendlyName = "MixSettingsTestBusinessPartnerConnectionInfo_NewConnectionInfo",
                    BusinessPartnerSGCertificate = MixSettingsHelperV4.OtherCert
                });
                bp.ConnectionInfos = cis.ToArray();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that changing a connection info cert works.")]
            public void ChangeConnectionInfoCert()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                bp.ConnectionInfos[0].BusinessPartnerSGCertificate = MixSettingsHelperV4.OtherCert;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that changing a connection info name works.")]
            public void ChangeConnectionInfoName()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Created", bp, firstDB);

                bp.ConnectionInfos[0].FriendlyName += "!";

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners("Modified", bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(1), Description("Verifies that removing a single connection info works.")]
            public void RemoveConnectionInfo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner(2);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                List<BusinessPartnerConnectionInfo> cis = new List<BusinessPartnerConnectionInfo>(bp.ConnectionInfos);
                cis.RemoveAt(0);
                bp.ConnectionInfos = cis.ToArray();

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that removing all connection infos works.")]
            public void RemoveAllConnectionInfo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner(2);

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0];

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 secondDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, secondDB);

                // check the two db pulls against each other, disregarding the name
                firstDB.ConnectionInfos = secondDB.ConnectionInfos = null;
                ValueCheckBusinessPartners(firstDB, secondDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null name fails.")]
            public void NullFriendlyName()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.FriendlyName = null;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Friendly name is null or empty.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null name fails.")]
            public void EmptyFriendlyName()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.FriendlyName = "";

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Friendly name is null or empty.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list works.")]
            public void NullConnectionInfo()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos = null;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list member works.")]
            public void NullConnectionInfoMember()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[] { null };

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a null connection info list member field works.")]
            public void NullConnectionInfoMemberField()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.ConnectionInfos[0].FriendlyName = null;

                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                bp.ConnectionInfos = new BusinessPartnerConnectionInfo[0]; // for valuecheck
                ValueCheckBusinessPartners(bp, firstDB);
            }

            [TestCase, TestCasePriority(2), Description("Verifies that a zero guid fails.")]
            public void ZeroGuid()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                bp.BusinessPartnerID = Guid.Empty;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "00000000-0000-0000-0000-000000000000 Xbox LIVE is a private Business Partner.  You cannot modify.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that setting a second business partner with the same name keeps the old one.")]
            public void SameNameDifferentGuid()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                // create the partner
                BusinessPartner bp = helper.GenerateBusinessPartner();
                helper.SetBusinessPartner(bp);

                FullBusinessPartnerV4 firstDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                ValueCheckBusinessPartners(bp, firstDB);

                // create another partner with the same name
                BusinessPartner bp2 = helper.GenerateBusinessPartner();
                bp2.FriendlyName = bp.FriendlyName;

                bool failed = false;
                try
                {
                    helper.SetBusinessPartner(bp2);
                    failed = true;
                }
                catch (UnexpectedTestResultException e)
                {
                    ValueCheck.Test("ErrorMessage", "Encountered an error writing the business partner and its connection infos to the database.  See inner exception for more details.", e.InnerException.Message);
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that SetBusinessPartner succeeds and verifies the results.")]            
            public void BusinessPartnerTypes()
            {
                MixSettingsHelperV4 helper = new MixSettingsHelperV4();

                string[] defaultTypes = { "Private", "Partner", "Legacy" }; 

                foreach (string defaultType in defaultTypes)
                {
                    BusinessPartner bp = helper.GenerateBusinessPartner();
                    bp.Type = defaultType;

                    helper.SetBusinessPartner(bp);

                    FullBusinessPartnerV4 inDB = new FullBusinessPartnerV4(bp.BusinessPartnerID);
                    ValueCheckBusinessPartners(bp, inDB);
                }
            }

        }

        [TestGroup]
        public class SetAppliesToInfo : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Calls SetAppliesToInfo and verifies the result.")]
            public class Mainline : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo gat = Helper.GetAppliesToInfo(sat.AppliesToUri);

                    ValueCheckSTSAppliesTo(sat, gat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Sets the same thing twice.")]
            public class SetSameAgain : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // again
                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Creates two AppliesTos and validates both.")]
            public class TwoAppliesTos : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    STSAppliesTo sat2 = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);
                    Helper.SetAppliesToInfo(sat2);

                    STSAppliesTo gat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    STSAppliesTo gat2 = Helper.GetAppliesToInfo(sat2.AppliesToUri);

                    ValueCheckSTSAppliesTo(sat, gat);
                    ValueCheckSTSAppliesTo(sat2, gat2);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null applies to uri.")]
            public class NullAppliesToUri : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToUri = null;

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", "Invalid URI: The URI is empty.", e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an empty applies to uri.")]
            public class EmptyAppliesToUri : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToUri = "";

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", "Invalid URI: The URI is empty.", e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an applies to uri without a trailing /.")]
            public class NoTrailingSlash : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToUri = "http://www.xbox.com/BP_notrail";

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo gat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    //We expect the system to correct itself.
                    sat.AppliesToUri = "http://www.xbox.com/BP_notrail/";
                    ValueCheckSTSAppliesTo(sat, gat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Changes business partner and verifies the change.")]
            public class ChangeBusinessPartner : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    BusinessPartner bp = Helper.GenerateBusinessPartner();
                    Helper.SetBusinessPartner(bp);
                    sat.BusinessPartnerID = bp.BusinessPartnerID;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid business partner.")]
            public class InvalidBusinessPartner : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.BusinessPartnerID = Guid.NewGuid();

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("The business partner with ID {0} doesn't exist.", sat.BusinessPartnerID);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes validity interval and verifies the change.")]
            public class ChangeValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ValidityInterval = sat.ValidityInterval.Add(TimeSpan.FromHours(1));

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an a zero validity interval.")]
            public class ZeroValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ValidityInterval = TimeSpan.Zero;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an a negative validity interval.")]
            public class NegativeValidityInterval : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ValidityInterval = TimeSpan.FromHours(-4);

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes token type and verifies the change.")]
            public class ChangeTokenType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.TokenType = MixSettingsHelperV4.TokenTypes[(MixSettingsHelperV4.TokenTypes.IndexOf(sat.TokenType) + 1) %
                        MixSettingsHelperV4.TokenTypes.Count];

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid token type.")]
            public class InvalidTokenType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.TokenType = "InvalidTokenType";

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("The token type {0} is unsupported", sat.TokenType);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null token type.")]
            public class NullTokenType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.TokenType = null;

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", "Value cannot be null.", e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes the cert and verifies the change.")]
            public class ChangeCert : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.AppliesToCertificate = MixSettingsHelperV4.OtherCert;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use an invalid cert.")]
            public class InvalidCert : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToCertificate = "NotACert";

                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", "Cannot find the requested object.", e.InnerException.Message);
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null cert.")]
            public class NullCert : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.AppliesToCertificate = null;

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);

                    //throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Changes the claim type and verifies the change.")]
            public class ChangeClaimType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes[0] = MixSettingsHelperV4.FirstPartnerClaimTypes(2)[1];

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Adds a claim type and verifies the change.")]
            public class AddClaimType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(1), Description("Removes a claim type and verifies the change.")]
            public class RemoveClaimType : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(1);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Removes all claim types and verifies the change.")]
            public class RemoveAllClaimTypes : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(2);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo firstGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, firstGat);

                    // change
                    sat.ClaimTypes = MixSettingsHelperV4.FirstPartnerClaimTypes(0);

                    Helper.SetAppliesToInfo(sat);

                    STSAppliesTo secondGat = Helper.GetAppliesToInfo(sat.AppliesToUri);
                    ValueCheckSTSAppliesTo(sat, secondGat);
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list.")]
            public class NullClaimTypes : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list member.")]
            public class NullClaimTypeMember : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes = new STSAppliesToClaimType[] { null };

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(2), Description("Use a null claim type list member field.")]
            public class NullClaimTypeMemberField : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // create
                    STSAppliesTo sat = Helper.GenerateAppliesTo();
                    sat.ClaimTypes[0].ClaimTypeUri = null;

                    Helper.SetAppliesToInfo(sat);

                    throw new UnexpectedTestResultException("This should probably fail.");
                }
            }

            [TestCase, TestCasePriority(1), Description("Attempts to use a private claim.")]
            public class PrivateClaim : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    STSAppliesTo sat = Helper.GenerateAppliesTo(1);
                    var privateOnly = MixSettingsHelperV4.ClaimTypes["Private"].Keys.Except(MixSettingsHelperV4.ClaimTypes["Partner"].Keys).Take(1).Select(c => new STSAppliesToClaimType
                    {
                        ClaimTypeUri = c,
                        Required = RandomEx.GlobalRandGen.NextBool(),
                    }).ToArray();
                    sat.ClaimTypes = privateOnly;

                    bool failed = false;
                    try
                    {
                        Helper.SetAppliesToInfo(sat);
                        failed = true;
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        ValueCheck.Test("ErrorMessage", sat.ClaimTypes[0].ClaimTypeUri + " is a private claim type.  You cannot use it.",
                            e.InnerException.Message);
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("This should probably fail.");
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempts to modify applies to info associated with a private business partner")]
            public class PrivatePartner : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    // Make the business partner private
                    using (WSClient client = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        client.CommandSql = String.Format(
                            "update t_sts_business_partner set i_business_partner_type = 0 where uid_business_partner_id = '{0}'",
                            Helper.BusinessPartner.BusinessPartnerID);

                        client.ExecuteNonQuery();
                    }

                    STSAppliesTo at = Helper.GenerateAppliesTo(1);

                    bool success = false;
                    try
                    {
                        Helper.SetAppliesToInfo(at);
                        success = true;
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        String expMsg = String.Format("{0} {1} is a private Business Partner.  You cannot modify.",
                            Helper.BusinessPartner.BusinessPartnerID, Helper.BusinessPartner.FriendlyName);
                        ValueCheck.Test("ErrorMessage", expMsg, e.InnerException.Message);
                        Global.RO.Success("Request failed as expecetd with private business partner.");
                    }

                    if (success)
                    {
                        throw new UnexpectedTestResultException("Request should have failed with private business partner.");
                    }
                }
            }
        }

        [TestGroup]
        public class GetBusinessPartnerTypes : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Calls SetAppliesToInfo and verifies the result.")]
            public class Mainline : CreateBusinessPartnerBase
            {
                public override void Run()
                {
                    string[] expectedStringsPresent = new string[] { "Partner", "Legacy" };
                    string[] results = Helper.GetBusinessPartnerTypes();                    

                    foreach (string expected in expectedStringsPresent)
                    {
                        Global.RO.Debug("Looking for business partner type " + expected + " in the results.");
                        bool found = false;
                        foreach (string r in results)
                        {
                            if (r == expected)
                            {
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                            throw new UnexpectedTestResultException("Expected to find all 3 defined business partner types in the results, but we were unable to find '" + expected + "'");
                    }
                    Global.RO.Success("Found all expected strings.");
                }
            }
        }

        [TestGroup]
        public class RemoveAppliesToInfo : TestNode
        {

            [TestCase, TestCasePriority(1), Description("Removes a valid applies to.")]
            public class Mainline : SetAppliesToBase
            {
                public override void Run()
                {
                    STSAppliesTo appliesTo = Helper.AppliesTos[0];

                    Helper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    bool failed = false;
                    try
                    {
                        Helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                        failed = true;
                    }
                    catch
                    {
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Removes an applies to that does not exist.")]
            public class DoesNotExist : SetAppliesToBase
            {
                public override void Run()
                {
                    STSAppliesTo appliesTo = Helper.AppliesTos[0];

                    Helper.RemoveAppliesToInfo("http://doesnotexist/");

                    STSAppliesTo inDB = Helper.GetAppliesToInfo(appliesTo.AppliesToUri);
                    ValueCheckSTSAppliesTo(appliesTo, inDB);
                }
            }

            [TestCase, TestCasePriority(1), Description("Attempts to remove an AppliesTo with endpoints.")]
            public class HasEndpoints : TestNode
            {
                public override void Run()
                {
                    // add endpoints
                    MixTest.TitleManagement.TitleManagementHelperV3 titleHelper = new MixTest.TitleManagement.TitleManagementHelperV3();
                    titleHelper.Initialize();

                    titleHelper.GenerateNetworkSecurityList();

                    // attempt to remove it
                    STSAppliesTo appliesTo = MixSettingsHelperV4.ConvertAppToV3toV4(titleHelper.SettingsHelper.AppliesTos[0]);

                    titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    STSAppliesTo got = MixSettingsHelperV4.ConvertAppToV3toV4(titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri));

                    // make sure they are the same
                    ValueCheckSTSAppliesTo(appliesTo, got);
                }
            }

            [TestCase, TestCasePriority(1), Description("Attempts to remove an AppliesTo that had endpoints, but they are gone.")]
            public class HasEndpointsNoMore : TestNode
            {
                public override void Run()
                {
                    // add endpoints
                    MixTest.TitleManagement.TitleManagementHelperV3 titleHelper = new MixTest.TitleManagement.TitleManagementHelperV3();
                    MixSettingsHelperV4 settingsHelper = new MixSettingsHelperV4();

                    titleHelper.Initialize();                    

                    titleHelper.GenerateNetworkSecurityList();

                    // attempt to remove it
                    STSAppliesTo appliesTo = MixSettingsHelperV4.ConvertAppToV3toV4(titleHelper.SettingsHelper.AppliesTos[0]);

                    titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    STSAppliesTo got = MixSettingsHelperV4.ConvertAppToV3toV4(titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri));

                    // make sure they are the same
                    ValueCheckSTSAppliesTo("HadEndpoints", appliesTo, got);

                    // remove the endpoints
                    titleHelper.SetNetworkSecurityList(new xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[0]);

                    // remove the applies to again
                    titleHelper.SettingsHelper.RemoveAppliesToInfo(appliesTo.AppliesToUri);

                    bool failed = false;
                    try
                    {
                        titleHelper.SettingsHelper.GetAppliesToInfo(appliesTo.AppliesToUri);
                        failed = true;
                    }
                    catch
                    {
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("We could still get the AppliesTo after removing it!?: " + appliesTo.AppliesToUri);
                    }
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StatsTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StatsTest\StatsTest.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

using LiveStatsTest;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.titlemanagement.contract;
using xonline.common.xlastutil;

using MIXTesting;

namespace MixTest
{
    [TestGroup, Owner("codyluit"), Description("Mix Stats Tests")]
    public class StatsTests : TestNode
    {
        public override void PreRun()
        {
            // Enable Stats APIs
            MIXTesting.Config.EnableAPIs(Interface.mixstats, "Xonline.Mix.Stats.Service", "MixStats.ConfigureLeaderboards", "MixStats.ResetLeaderboard");
            // Enable Title APIs
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
            Global.RO.Info("Deploying our default title so our tests can assume it is propped.");

            // Deploy the title
            DeployTitleDefault(defaultTitleId);

            DeployTitleDefault(defaultTitleIdWithPlatformLeaderboards);
        }


        static protected XLASTFactory _xlastFactory = new XLASTFactory();
        static protected TitleManagementWCFClient titleClient = new TitleManagementWCFClient();
        static protected StatsWCFClient statsClient = new StatsWCFClient();

        // aka -129053
        static uint defaultTitleId = 0xFFFE1003;

        // aka -129055 (or 4294840325 unsigned)
        static uint defaultTitleIdWithPlatformLeaderboards = 0xFFFE1005;        

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added game mode
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleWithPlatformVisibleLeaderboardEdits(uint titleId)
        {
            string newFile = string.Format("SuitesData\\MixTitleManagementTest\\{0}-NewPlatformVisible.xlast", titleId.ToString("X"));
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(newFile));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added game mode
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleWithNewGameMode(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId.ToString("X") + "-NewMode"));
 
            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title with an updated xlast which has removed a leaderboard
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleDeleteLeaderboard(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast("SuitesData\\MixTitleManagementTest\\"+titleId.ToString("X") + "-DelBoard.xlast"));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitleDefault(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Adds a new bucket to the database so that when we attempt to ConfigureMatchmaking it fails because of inconsistencies
        /// </summary>
        /// <param name="titleId"></param>
        /// <returns></returns>
        static public bool AddNewBucket(uint titleId)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();

                // Lets get what already exists
                InterfaceBucketCollection buckets = npdb.GetInterfaceBuckets(titleId, xonline.common.config.Config.Environment);

                // If we had some, lets add a new one so Match gets confused and fails next time
                if (buckets.Count == 0)
                    return false;

                string insertBucketCmd = "insert into t_interface_buckets (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4) " +
                                         "values (@env, @interface, @titleId, @bucket, @server, @nextserver, @migrationStart, @vc_info1, @vc_info2, @vc_info3, @vc_info4)";

                SqlCommand com = npdb.CreateCommand();
                com.CommandText = insertBucketCmd;
                com.Parameters.AddWithValue("@env", xonline.common.config.Config.Environment);
                com.Parameters.AddWithValue("@interface", buckets[0].Interface);
                com.Parameters.AddWithValue("@titleId", (int)titleId);
                com.Parameters.AddWithValue("@bucket", buckets.Count);
                com.Parameters.AddWithValue("@server", buckets[0].Server);
                com.Parameters.AddWithValue("@nextserver", buckets[0].NextServer);
                com.Parameters.AddWithValue("@migrationStart", buckets[0].MigrationStart);
                com.Parameters.AddWithValue("@vc_info1", "''");
                com.Parameters.AddWithValue("@vc_info2", "''");
                com.Parameters.AddWithValue("@vc_info3", "''");
                com.Parameters.AddWithValue("@vc_info4", "''");

                int affected = com.ExecuteNonQuery();
                if (affected == 1)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns a char [] of the xlast
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns></returns>
        static protected string GetXlast(uint titleId)
        {
            string xlastLoc = "SuitesData\\MixTitleManagementTest\\" + titleId.ToString("X") + ".xlast";
            StreamReader sr = new StreamReader(xlastLoc);

            string buff = sr.ReadToEnd();

            sr.Close();

            return buff;
        }

        /// <summary>
        /// Deploys the title
        /// </summary>
        /// <param name="titleId"></param>
        static public ulong GetLBID(uint titleId)
        {
            
            string xlastLoc = "SuitesData\\MixTitleManagementTest\\" + titleId.ToString("X") + ".xlast";
            StreamReader sr = new StreamReader(xlastLoc);
            xonline.common.xlastutil.XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(sr.ReadToEnd());

            sr.Close();

            return xlsp.GameConfigProject.StatsViews.StatsView[0].id;
        }

        [TestCase, Description("MixStatsBasicDeployTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsBasicDeployTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleId);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(defaultTitleId, true);

                base.statsClient.DeleteLeaderboards(defaultTitleId);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("MixStatsDeleteLeaderboard"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsDeleteLeaderboard : CnGWCFTestBase
        {
            public override void PreRun()
            {
                // Make sure we've got the default title propped (in case of multple test runs)
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleId);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                DeployTitleDeleteLeaderboard(defaultTitleId);

                base.statsClient.ConfigureLeaderboards(defaultTitleId, true);

                tr = statsClient.VerifyXbox360StatsData(defaultTitleId, @"SuitesData\MixTitleManagementTest\" + defaultTitleId.ToString("X") + "-DelBoard.xlast", true);

                base.statsClient.DeleteLeaderboards(defaultTitleId);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }

            public override void PostRun()
            {
                // Make sure we've got the default title propped (in case of multple test runs)
                DeployTitleDefault(defaultTitleId);
            }
        }

        [TestCase, Description("MixStatsDeleteLeaderboardNoForce"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsDeleteLeaderboardNoForce : CnGWCFTestBase
        {
            public override void PreRun()
            {
                // Make sure we've got the default title propped (in case of multple test runs)
                DeployTitleDefault(defaultTitleId);
            }

            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleId);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                DeployTitleDeleteLeaderboard(defaultTitleId);

                try
                {
                    base.statsClient.ConfigureLeaderboards(defaultTitleId);
                }
                catch(Exception e)
                {
                    if (e.Message.Contains("Stats ConfigureLeaderboards call failed with HR = 0x80176032") &&
                        e.InnerException.Message.Contains("This Leaderboard configuration requires the force parameter set to true to be successful"))
                    {
                        tr = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("MixStatsDeleteLeaderboardNoForce returned an unknown exception:\r\n" + e.Message);
                    }
                }

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("ConfigureLeaderboards failed");
                }
            }

            public override void PostRun()
            {
                // Make sure we've got the default title propped (in case of multple test runs)
                DeployTitleDefault(defaultTitleId);
            }
        }

        #region ConfigureLeaderboards

        [TestCase, Description("MixStatsConfigureLeaderboardTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixStatsConfigureLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleId);


                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(defaultTitleId, true);

                base.statsClient.DeleteLeaderboards(defaultTitleId);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("MixStatsConfigureLeaderboardNonProppedTitleIDTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixStatsConfigureLeaderboardNonProppedTitleIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                uint titleId = defaultTitleId - 5;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId);

                try
                {
                    // Deploy the title using MIX API
                    base.statsClient.ConfigureLeaderboards(titleId); // This will throw
                }
                catch
                {
                    // This is expected
                    base.statsClient.DeleteLeaderboards(titleId);
                    return;
                }

                try
                {
                    // Verify tables and sprocs exist
                    //if (statsClient.VerifyXbox360StatsData(titleId, false) == TEST_RESULTS.FAILED)
                    //{
                    //    base.statsClient.DeleteLeaderboards(titleId);
                    //    return;
                    //}

                    throw new UnexpectedTestResultException("VerifyXbox360StatsData unexpectedly succeeded");
                }
                finally
                {
                    // this is exactly where we should be
                    base.statsClient.DeleteLeaderboards(titleId);
                }
            }
        }

        [TestCase, Description("MixStatsConfigureLeaderboardInvalidTitleIDTest"), TestFrequency("Daily"), TestCasePriority(2)]
        class MixStatsConfigureLeaderboardInvalidTitleIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                uint titleId = 0;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId);

                try
                {
                    // Deploy the title using MIX API
                    base.statsClient.ConfigureLeaderboards(titleId); // This will throw
                }
                catch(Exception e)
                {
                    if (e.InnerException.Message.Contains("ConfigureLeaderboards Called With a null Title ID."))
                    {
                        base.statsClient.DeleteLeaderboards(titleId);
                        return;
                    }
                }

                try
                {
                    // Verify tables and sprocs exist
                    //if (statsClient.VerifyXbox360StatsData(titleId, true) == TEST_RESULTS.FAILED)
                    //{
                    //    base.statsClient.DeleteLeaderboards(titleId);
                    //    return;
                    //}

                    throw new UnexpectedTestResultException("VerifyXbox360StatsData unexpectedly succeeded");
                }
                finally
                {
                    // this is exactly where we should be
                    base.statsClient.DeleteLeaderboards(titleId);
                }
            }
        }

        private static string GetPlatformVisibleLeaderboardUrl(uint titleId)
        {
            string url = string.Format("http://{0}:11070/xstats/activity/titles/{1:X}/leaderboards?format=xml",
                Global.CurrentEnvironment.Environment,
                titleId);

            return url;
        }

        public static void VerifyPlatformVisibleLeaderboardIngestion(uint titleId, int[] rgLbids)
        {
            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            tr = statsClient.VerifyXbox360StatsData(titleId, true);

            if (tr != TEST_RESULTS.PASSED)
            {
                throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
            }

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(GetPlatformVisibleLeaderboardUrl(titleId));

            request.Method = "GET";
            request.ContentLength = 0;

            WebHeaderCollection col = new WebHeaderCollection();
            col.Add("x-locale", "de-DE");  // Request German

            request.Headers = col;
            request.ContentType = "text/xml";

            HttpWebResponse response = (HttpWebResponse)request.GetResponse();

            if (response.StatusCode != HttpStatusCode.OK)
            {
                throw new UnexpectedTestResultException("Platform Leaderboard metadata called failed!");
            }

            Stream responseStream = response.GetResponseStream();
            XmlTextReader reader = new XmlTextReader(responseStream);
            
            int numLeaderboards = 0;
            while (reader.Read())
            {
                if (reader.Name == "leaderboard" && reader.IsStartElement())
                {                    
                    reader.Read(); // advance to platform visible leaderboard id
                    string lbid = reader.ReadString(); // the platform visible leaderboard id
                    if (lbid != rgLbids[numLeaderboards++].ToString())
                    {
                        throw new UnexpectedTestResultException("VerifyPlatformVisibleLeaderboardIngestion found unexpected platform visible leaderboard id!");
                    }
                }
            }

            responseStream.Close();
            response.Close();

            if (rgLbids.Length != numLeaderboards)
            {
                throw new UnexpectedTestResultException("VerifyPlatformVisibleLeaderboardIngestion found wrong number of platform visible leaderboards!");
            }
        }

        [TestCase, Description("MixStatsConfigurePlatformLeaderboardTest"), Owner("joelwi"), EnvRequirement("Manual"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsConfigurePlatformLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                // The input title config file declares the following leaderboard ids as platform visible, and the 
                // primary platform visible leaderboard is '3', so it must be returned first in order.
                int[] rgLbids = { 3, 2, 4, 7 };

                VerifyPlatformVisibleLeaderboardIngestion(defaultTitleIdWithPlatformLeaderboards, rgLbids);
            }
        }

        [TestCase, Description("MixStatsConfigurePlatformLeaderboardWithNoChangesTest"), Owner("joelwi"), EnvRequirement("Manual"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsConfigurePlatformLeaderboardWithNoChangesTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                // The input title config file declares the following leaderboard ids as platform visible, and the 
                // primary platform visible leaderboard is '3', so it must be returned first in order.
                int[] rgLbids = { 3, 2, 4, 7 };

                VerifyPlatformVisibleLeaderboardIngestion(defaultTitleIdWithPlatformLeaderboards, rgLbids);

                // do it again... with no changes... still work ok?

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards, true);

                VerifyPlatformVisibleLeaderboardIngestion(defaultTitleIdWithPlatformLeaderboards, rgLbids);
            }
        }

        [TestCase, Description("MixStatsConfigurePlatformLeaderboardEditsTest"), Owner("joelwi"), EnvRequirement("Manual"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsConfigurePlatformLeaderboardEditsTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                // The input title config file declares the following leaderboard ids as platform visible, and the 
                // primary platform visible leaderboard is '3', so it must be returned first in order.
                int[] rgLbids = { 3, 2, 4, 7 };

                VerifyPlatformVisibleLeaderboardIngestion(defaultTitleIdWithPlatformLeaderboards, rgLbids);

                // do it again... with changes to platform visible leaderboard attributes... 

                // Deploy the test title again using MIX API but with different platform leaderboard configuration than before
                DeployTitleWithPlatformVisibleLeaderboardEdits(defaultTitleIdWithPlatformLeaderboards);

                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards, true);

                // The updated title config file declares the following leaderboard ids as platform visible, and the 
                // primary platform visible leaderboard is '5', so it must be returned first in order.
                int[] rgLbidsUpdated = { 5, 1 };

                VerifyPlatformVisibleLeaderboardIngestion(defaultTitleIdWithPlatformLeaderboards, rgLbidsUpdated);
            }
        }

        #endregion

        #region ResetLeaderboard

        [TestCase, Description("MixStatsResetLeaderboardTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                base.statsClient.ConfigureLeaderboards(defaultTitleId);

                base.statsClient.ResetLeaderboard(defaultTitleId, GetLBID(defaultTitleId));

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(defaultTitleId, true);

                base.statsClient.DeleteLeaderboards(defaultTitleId);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("MixStatsResetOneLeaderboardTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetOneLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // 1 LB
                uint titleId1 = 0xFFFE1000;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId1);

                base.titleClient.ConfigureTitle(base.titleClient.CompressXlast(GetXlast(titleId1)));

                base.statsClient.ConfigureLeaderboards(titleId1);

                base.statsClient.ResetLeaderboard(titleId1, GetLBID(titleId1));

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleId1, true);

                base.statsClient.DeleteLeaderboards(titleId1);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("MixStatsResetTenLeaderboardTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetTenLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // 10 LBs
                uint titleId10 = 0xFFFE1001;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId10);

                base.titleClient.ConfigureTitle(base.titleClient.CompressXlast(GetXlast(titleId10)));

                base.statsClient.ConfigureLeaderboards(titleId10);

                base.statsClient.ResetLeaderboard(titleId10, GetLBID(titleId10));

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleId10, true);

                base.statsClient.DeleteLeaderboards(titleId10);

                if (tr!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("MixStatsResetLeaderboardZeroLBIDTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetLeaderboardZeroLBIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                uint titleId0 = defaultTitleId;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId0);

                base.statsClient.ConfigureLeaderboards(titleId0);

                try
                {
                    base.statsClient.ResetLeaderboard(titleId0, 0);
                }
                catch
                {
                    base.statsClient.DeleteLeaderboards(titleId0);
                    return;
                }

                base.statsClient.DeleteLeaderboards(titleId0);
                throw new UnexpectedTestResultException("ResetLeaderboard unexpectedly succeeded");
            }
        }

        [TestCase, Description("MixStatsResetLeaderboardNonConfiguredIDTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetLeaderboardNonConfiguredIDTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleId);

                // Note the absense of a call to ConfigureLeaderboard

                try
                {
                    base.statsClient.ResetLeaderboard(defaultTitleId + 1, 1);
                }
                catch
                {
                    return;
                }

                throw new UnexpectedTestResultException("ResetLeaderboard unexpectedly succeeded");
            }
        }

        [TestCase, Description("MixStatsResetZeroLeaderboardTest"), TestFrequency("Daily"), TestCasePriority(1)]
        class MixStatsResetZeroLeaderboardTest : CnGWCFTestBase
        {
            public override void Run()
            {
                // zero LBs
                uint titleId0 = 0xFFFE1002;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleId0);

                base.titleClient.ConfigureTitle(base.titleClient.CompressXlast(GetXlast(titleId0)));

                base.statsClient.ConfigureLeaderboards(titleId0);

                // Get the first LBID
                try
                {
                    // If this throws, perfect
                    base.statsClient.ResetLeaderboard(titleId0, 1);
                }
                catch
                {
                    base.statsClient.DeleteLeaderboards(titleId0);
                    return;
                }

                base.statsClient.DeleteLeaderboards(titleId0);
                throw new UnexpectedTestResultException("ResetLeaderboard unexpectedly succeeded");
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StorageTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StorageTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StorageTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace StorageTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SettingsManagementTest\SetSetting.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;

using xonline.common.config;
using xonline.mix.settingsmanagement.contracts.V1;

namespace MixTest
{
    [TestGroup, Owner("johnmcp"), Description("Tests for the SetSetting mix API")]
    public class SetSetting : TestNode
    {
        #region Utils

        public static void CallAndVerify (uint expectedHResult, PlatformType platform, ushort? build, ushort? qfe, Guid group)
        {
            CallAndVerify(expectedHResult, platform, build, qfe, group, SettingsManagementCommon.TestSettingName, GetRandomValue());
        }

        public static void CallAndVerify (uint expectedHResult, PlatformType platform, ushort? build, ushort? qfe, Guid group, string setting, int value)
        {
            CallAndVerify(expectedHResult, platform, build, qfe, group, setting, value.ToString());
        }

        //calls the API and verifies the result against liveinfo
        public static void CallAndVerify (uint expectedHResult, PlatformType platform, ushort? build, ushort? qfe, Guid group, string setting, string value)
        {
            //make the request
            SettingsManagementWCFClient client = new SettingsManagementWCFClient();
            client.ExpectedHR=expectedHResult;
            client.SetSetting(platform, build, qfe, group, setting, value);

            if (expectedHResult == HResult.S_OK) //verify the response against what the liveinfo service thinks
            {
                // reload liveinfo
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);

                ConfigSource source = ConfigSource.Unknown;
                // this is a hack with the value because I didn't want to add yet another parameter
                if (build.HasValue && qfe.HasValue && value != null)
                {
                    source = (group == Guid.Empty ? ConfigSource.Build : ConfigSource.Beta);
                }
                else
                {
                    source = ConfigSource.Client;
                }

                // With these, we will verify that liveinfo and mix believe that the setting we just set is there
                GetSettings.CallAndVerify(HResult.S_OK, platform, build, qfe, group, source, value);
            }
        }

        public static int GetRandomValue ()
        {
            return RandomEx.GlobalRandGen.Next(1, int.MaxValue);
        }

        public class SetSettingGroupListTestChild : SettingsGroupListTestChild
        {
            public override void Run()
            {
                CallAndVerify(HResult.S_OK, PlatformType.Xenon, TheGroup.Build, TheGroup.Qfe, TheGroup.Group);
            }
        }

        #endregion

        #region Setup

        public override void OneTimeSetup ()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixsettingsmanagement, "Xonline.Mix.SettingsManagement.Service", "MixSettingsManagement.SetSetting");
        }

        public override void PreRun ()
        {
            // clean up the settings so we can be sure that we are setting things
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.ExecuteScalar("Delete from t_live_registry_settings where vc_setting = '" + SettingsManagementCommon.TestSettingName + "'");
            }
        }

        public override void PostRun ()
        {
            // clean up the settings mess that we have made
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                npdb.ExecuteScalar("Delete from t_live_registry_settings where vc_setting = '" + SettingsManagementCommon.TestSettingName + "'");
                // might be unsafe, targeting it specifically at the empty name test
                npdb.ExecuteScalar("Delete from t_live_registry_settings where vc_client_config = 'xenon' and si_build = 7371 and " +
                    "si_qfe = 0 and vc_setting = ''");
            }

            // reload liveinfo
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);
        }

        #endregion

        #region Mainline

        [TestCase, TestCasePriority(1), Description("Positive mainline case.")]
        public void SimpleMainline ()
        {
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, 7371, 0, Guid.Empty);
        }

        #endregion

        #region Platform

        [TestCase, TestCasePriority(1), Description("Platforms other than Xenon are not supported right now.")]
        public void NonXenonPlatform ()
        {
            CallAndVerify(HResult.XONLINE_E_MIX_INVALID_PLATFORM, PlatformType.PC, 7371, 0, Guid.Empty);
        }

        #endregion

        #region Build

        [TestCase, TestCasePriority(1), Description("Different builds.")]
        public class Build : SettingsGroupListTestNode<SetSettingGroupListTestChild>
        {
            public override SettingsGroup[] GetSettingsGroupList ()
            {
                return SettingsManagementCommon.Builds;
            }
        }

        /* Obselete now that datatypes are changed to be correct
        [TestCase, TestCasePriority(3), Description("Build and/or qfe are null.")]
        [CompoundCase("Build", 12039834, 0)]
        [CompoundCase("Qfe", 7371, 9664554)]
        [CompoundCase("BuildAndQfe", 3454354, 678732213)]
        public class LargeBuilds : TestNode
        {
            public override TEST_RESULTS Run ()
            {
                ushort build = (ushort)(int)MyValues[0];
                ushort qfe = (ushort)(int)MyValues[1];
                CallAndVerify(HResult.E_FAIL, PlatformType.Xenon, build, qfe, Guid.Empty);

                return TEST_RESULTS.PASSED;
            }
        }
        */

        [TestCase, TestCasePriority(3), Description("Build and/or qfe are null.")]
        [CompoundCase("Build", true, false)]
        [CompoundCase("Qfe", false, true)]
        [CompoundCase("BuildAndQfe", true, true)]
        public class NullBuilds : TestNode
        {
            public override void Run()
            {
                bool build = (bool)MyValues[0];
                bool qfe = (bool)MyValues[1];

                SettingsGroup sg = null;
                foreach (SettingsGroup s in SettingsManagementCommon.BetaGroups)
                {
                    if (s.Qfe != 0)
                    {
                        sg = s;
                        break;
                    }
                }

                CallAndVerify(HResult.XONLINE_E_MIX_INVALID_CONFIG, PlatformType.Xenon, (build ? null : (ushort?)sg.Build), (qfe ? null : (ushort?)sg.Qfe), sg.Group);
            }
        }

        #endregion

        #region Beta Group

        [TestCase, TestCasePriority(1), Description("Different beta groups.")]
        public class BetaGroup : SettingsGroupListTestNode<SetSettingGroupListTestChild>
        {
            public override SettingsGroup[] GetSettingsGroupList ()
            {
                return SettingsManagementCommon.BetaGroups;
            }
        }

        [TestCase, TestCasePriority(2), Description("Guid.NewGuid() [random] given for beta group.")]
        public void BetaNewGuid ()
        {
            SettingsGroup sg = SettingsManagementCommon.Builds[0];
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, sg.Build, sg.Qfe, Guid.NewGuid());
        }

        [TestCase, TestCasePriority(3), Description("Guid.MaxValue given for beta group.")]
        public void BetaMaxGuid ()
        {
            SettingsGroup sg = SettingsManagementCommon.Builds[1];
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, sg.Build, sg.Qfe, new Guid("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"));
        }

        #endregion

        #region Negative

        [TestCase, TestCasePriority(3), Description("Send a null value to the mix api.")]
        [CompoundCase("Config", true, false)]
        [CompoundCase("Setting", false, true)]
        [CompoundCase("ConfigAndSetting", true, true)]
        public class NullParams : TestNode
        {
            public override void Run()
            {
                bool conf = (bool)MyValues[0];
                bool sett = (bool)MyValues[1];

                SettingsManagementWCFClient client = new SettingsManagementWCFClient();
                client.ExpectedHR = HResult.XONLINE_E_MIX_ARGUMENT_NULL;

                LiveHiveConfig lhc = null;
                LiveHiveSetting lhs = null;

                if(conf)
                {
                    lhc = new LiveHiveConfig();
                    lhc.PlatformType = PlatformType.Xenon;
                }

                if(sett)
                {
                    lhs = new LiveHiveSetting();
                }

                client.SetSetting(lhc, lhs);
            }
        }

        #endregion

        #region Name

        [TestCase, TestCasePriority(1), Description("The setting name is null.")]
        public void SettingNameNull ()
        {
            CallAndVerify(HResult.XONLINE_E_MIX_ARGUMENT_NULL, PlatformType.Xenon, 7371, 0, Guid.Empty, null, 0);
        }

        [TestCase, TestCasePriority(1), Description("The setting name is an empty string.")]
        public void SettingNameEmpty ()
        {
            CallAndVerify(HResult.XONLINE_E_MIX_ARGUMENT_EMPTY, PlatformType.Xenon, 7371, 0, Guid.Empty, "", 0);
        }

        #endregion

        #region Value

        [TestCase, TestCasePriority(1), Description("The setting is set repeatedly.")]
        public void SetRepeat ()
        {
            SettingsGroup sg = SettingsManagementCommon.Builds[2];
            for (int i = 0; i < 3; ++i)
            {
                CallAndVerify(HResult.S_OK, PlatformType.Xenon, sg.Build, sg.Qfe, sg.Group);
            }
        }

        [TestCase, TestCasePriority(1), Description("The setting is set, then removed.")]
        public void RemoveSetting ()
        {
            // set it
            SettingsGroup sg = SettingsManagementCommon.Builds[6];
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, 3689, 0, Guid.Empty);

            // and forget it
            CallAndVerify(HResult.S_OK, PlatformType.Xenon, 3689, 0, Guid.Empty, SettingsManagementCommon.TestSettingName, null);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StatsTest\PlatformVisibleTests.cs ===
ï»¿using System;
using System.Collections;
using System.Data.SqlClient;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

using LiveStatsTest;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.titlemanagement.contract;
using xonline.common.xlastutil;

using MIXTesting;

namespace MixTest
{
    // PVL (Platform Visible Leaderboard) flags (currently only 1.. whether it is the 'primary' PVL or not)
    public enum PlatformVisibleLeaderboardFlags : byte
    {
        Primary = 0x1,
    }

    // PVL format bits indicating how the value should be formatted to the response string (long, floating point, or a formatted date)
    public enum PlatformVisibleLeaderboardDataType : byte
    {
        Long = 0,
        Decimal = 1,
        Timespan = 2,
        DateTime = 3,
    }

    // Formatting bits specific to the FormatDate PlatformVisibleLeaderboardFormatBits above.  Specifies how the long rating value 
    // should be converted to a diplayable time with various finite time units.  
    public enum PlatformVisibleLeaderboardTimeFormats : byte
    {
        ShortTime = 1,      // HH:mm
        LongTime = 2,       // HH:mm:ss
        ExtraLongTime = 3,  // HH:mm:ss.fff
        ShortDate = 4,      // MM/DD/YYYY
        ExpandedDate = 5,   // MM/DD/YYYY HH:mm
        FullDate = 6,       // MM/DD/YYYY HH:mm:ss
        ExtraFullDate = 7,  // MM/DD/YYYY HH:mm:ss.fff
    }    

    [TestGroup, Owner("srkalyan"), Description("PlatformVisible Tests")]
    public class StatsTestPlatformVisible : TestNode
    {
        public override void PreRun()
        {
            // Enable Stats APIs
            MIXTesting.Config.EnableAPIs(Interface.mixstats, "Xonline.Mix.Stats.Service", "MixStats.ConfigureLeaderboards", "MixStats.ResetLeaderboard");
            // Enable Title APIs
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
            Global.RO.Info("Deploying our default title so our tests can assume it is propped.");
        }

        static protected XLASTFactory _xlastFactory = new XLASTFactory();
        static protected TitleManagementWCFClient titleClient = new TitleManagementWCFClient();
        static protected StatsWCFClient statsClient = new StatsWCFClient();

        static uint defaultTitleIdWithPlatformLeaderboards = 0xFFFE1005;

        /// <summary>
        /// Deploys the title
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitle(uint titleId)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(titleId));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added game mode
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitle(uint titleId, string xlastFile)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(xlastFile));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }

        /// <summary>
        /// Deploys the title with an updated xlast which holds an added game mode
        /// </summary>
        /// <param name="titleId"></param>
        static public void DeployTitle_WithoutMobileConversion(uint titleId, string xlastFile)
        {
            byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast_WithoutMobileConversion(xlastFile));

            titleClient.AddBaseVersion(titleId, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
            titleClient.ConfigureTitle(compressedXlast);
        }


        /// <summary>
        /// Calls VerifyXbox360StatsData to verify StatsData
        /// </summary>
        /// <param name="titleID"></param>
        static public void VerifyStatsData(uint titleID, string xlast_path)
        {
            TEST_RESULTS tr = TEST_RESULTS.FAILED;

            tr = statsClient.VerifyXbox360StatsData(titleID, xlast_path, true);

            if (tr != TEST_RESULTS.PASSED)
            {
                throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// 
        /// "si_rating_attribute" will be 65534(int) or -2(short) by default i.e. the rating column is directly used for display.
        /// When another column is used for display in conjunction with the rating column, the si_rating_attribute will not be 65534.
        /// 
        /// "tfs" is either '1' (the primary) or '0' (not the primary).
        /// 
        /// "ti_type" can be one of the following:
        /// 
        ///   0                  || Long        || No special formatting required, and the service will always return all rating values for that leaderboard as "long" types. 
        ///   1                  || Decimal     || The rating value is a decimal, and the 2nd order byte indicates how many deicmal places should be returned for each response's rating value
        ///   2                  || Timespan    || The rating value is a unit of time expressed without a date
        ///   3                  || DateTime    || DateTime value
        /// 
        /// If "ti_type" is '2' (Timespan) or '3' (DateTime) the value for "ti_format" represents a a formatting string comprised of years|months|days|hours|minutes|seconds|milliseconds as follows: 
        /// 
        /// ShortTime =     1,     // HH:mm
        /// LongTime =      2,     // HH:mm:ss
        /// ExtraLongTime = 3,     // HH:mm:ss.fff
        /// ShortDate =     4,     // MM/DD/YYYY
        /// ExpandedDate =  5,     // MM/DD/YYYY HH:mm
        /// FullDate =      6,     // MM/DD/YYYY HH:mm:ss
        /// ExtraFullDate = 7,     // MM/DD/YYYY HH:mm:ss.fff
        /// 
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        [TestCase, Description("PlatformLeaderboardTest - Primary long"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetLong : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "en-US", 
                                                -2, 
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.Long, 
                                                0,      // no special format info
                                                "English Leaderboard_03", 
                                                "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, 0, English Leaderboard_03, English Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                PlatformVisibleLeaderboardFlags.Primary,
                                                PlatformVisibleLeaderboardDataType.Long));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                 3, 
                                                 "de-DE", 
                                                 -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.Long,
                                                0,      // no special format info
                                                "German Leaderboard_03", 
                                                "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, 0, German Leaderboard_03, German Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                PlatformVisibleLeaderboardFlags.Primary,
                                                PlatformVisibleLeaderboardDataType.Long));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary decimal"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetDecimal : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-decimal.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "en-US", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary, 
                                                (byte)PlatformVisibleLeaderboardDataType.Decimal, 
                                                4, 
                                                "English Leaderboard_03", 
                                                "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, 4, English Leaderboard_03, English Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.Decimal));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "de-DE", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                4, 
                                                "German Leaderboard_03", 
                                                "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, 4, German Leaderboard_03, German Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.Decimal));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary ExtraFullDate"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetDateTime_ExtraFullDate : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-extrafulldate.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "en-US", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate,
                                                "English Leaderboard_03", 
                                                "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "de-DE", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate,
                                                "German Leaderboard_03", 
                                                "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary FullDate"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetDateTime_FullDate : CnGWCFTestBase
        {
            public override void Run()
            {                
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-fulldate.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "en-US", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.FullDate,
                                                "English Leaderboard_03", 
                                                "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column",
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.FullDate));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                3, 
                                                "de-DE", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.FullDate, 
                                                "German Leaderboard_03", 
                                                "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                defaultTitleIdWithPlatformLeaderboards,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                (byte)PlatformVisibleLeaderboardTimeFormats.FullDate));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary ExpandedDate"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetDateTime_ExpandedDate : CnGWCFTestBase
        {
            public override void Run()
            {
                // Following are the values in FFFE1005-primary-expandeddate.xlast that is used for this test
                
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-expandeddate.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExpandedDate, 
                                                    "English Leaderboard_03", 
                                                    "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExpandedDate));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExpandedDate,
                                                    "German Leaderboard_03", 
                                                    "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExpandedDate));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary ShortDate"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetDateTime_ShortDate : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-shortdate.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortDate, 
                                                    "English Leaderboard_03", 
                                                    "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortDate));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortDate,
                                                    "German Leaderboard_03", 
                                                    "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortDate));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary ExtraLongTime"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetTime_ExtraLongTime : CnGWCFTestBase
        {
            public override void Run()
            {                
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-extralongtime.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                                    "English Leaderboard_03", 
                                                    "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                                    "German Leaderboard_03", 
                                                    "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2,  {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary LongTime"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetTime_LongTime : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-longtime.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    -2, 
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.LongTime,
                                                    "English Leaderboard_03", 
                                                    "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.LongTime));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.LongTime,
                                                    "German Leaderboard_03", 
                                                    "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.LongTime));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest - Primary ShortTime"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetTime_ShortTime : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-shorttime.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    -2, 
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortTime, 
                                                    "English Leaderboard_03", 
                                                    "English Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, en-US, -2, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortTime));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    -2,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortTime,
                                                    "German Leaderboard_03",
                                                    "German Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0} 3, de-DE, -2, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ShortTime));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest with Primary and AttributeID set"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetAttributeIDSet : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-attribute.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int NumDecimalPlaces = 2;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 2)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 2, Actual = {0}", count));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    1,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces,
                                                    "English Leaderboard_03", 
                                                    "English DecimalColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, en-US, 1, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    1,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces,
                                                    "German Leaderboard_03", 
                                                    "German DecimalColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, de-DE, 1, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest with Primary AttributeID set, 2 Enabled Set"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisiblePrimarySetAttributeIDSetEnabledSet : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\FFFE1005-primary-attribute-enabled.xlast";
                DeployTitle(defaultTitleIdWithPlatformLeaderboards, titlePath);

                // Following are the values in FFFE1005-primary-shorttime.xlast that is used for this test

                int NumDecimalPlaces = 2;

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(defaultTitleIdWithPlatformLeaderboards);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)defaultTitleIdWithPlatformLeaderboards);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(defaultTitleIdWithPlatformLeaderboards);

                VerifyStatsData(defaultTitleIdWithPlatformLeaderboards, titlePath);

                int count = t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards);

                if (count != 6)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 6, Actual = {0}", count));
                }

                //Verify platform visible primary leaderboard ID = 3
                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "en-US", 
                                                    1,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces, 
                                                    "English Leaderboard_03", 
                                                    "English DecimalColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, en-US, 1, {1}, {2}, {3}, English Leaderboard_03, English Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    3, 
                                                    "de-DE", 
                                                    1,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces, 
                                                    "German Leaderboard_03", 
                                                    "German DecimalColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, de-DE, 1, {1}, {2}, {3}, German Leaderboard_03, German Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                    (byte)PlatformVisibleLeaderboardDataType.Decimal,
                                                    (byte)NumDecimalPlaces));
                }

                //Verify platform vsible enabled leaderboard ID = 6
                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    6, 
                                                    "en-US", 
                                                    -2, 
                                                    0, 
                                                    0,
                                                    0,
                                                    "English Leaderboard_06", 
                                                    "English Enabled Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 6, en-US, -2, {1}, {2}, {3}, English Leaderboard_06, English Enabled Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    0,
                                                    0,
                                                    0));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    6, 
                                                    "de-DE", 
                                                    -2, 
                                                    0, 
                                                    0,
                                                    0,
                                                    "German Leaderboard_06", 
                                                    "German Enabled Rating Column"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 6, de-DE, -2, {1}, {2}, {3}, German Leaderboard_06, German Enabled Rating Column", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    0,
                                                    0,
                                                    0));
                }

                //Verify platform vsible enabled leaderboard ID = 4
                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    4, 
                                                    "en-US", 
                                                    3, 
                                                    0, // not the primary
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate, 
                                                    "English Leaderboard_04", 
                                                    "English TimeColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, en-US, 3, {1}, {2}, {3}, English Leaderboard_04, English TimeColumn", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    0, 
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate));
                }

                if (1 != t_pvt.RowCount((int)defaultTitleIdWithPlatformLeaderboards, 
                                                    4, 
                                                    "de-DE", 
                                                    3,
                                                    0,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate, 
                                                    "German Leaderboard_04", 
                                                    "German TimeColumn"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, 3, de-DE, 3, {1}, {2}, {3}, German Leaderboard_04, German TimeColumn", 
                                                    defaultTitleIdWithPlatformLeaderboards,
                                                    0,
                                                    (byte)PlatformVisibleLeaderboardDataType.DateTime,
                                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraFullDate));
                }
            }
        }

        [TestCase, Description("PlatformLeaderboardTest for Mobile Xlast BestScore Primary Descending, BestTime Enabled Ascending"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisibleMobile_BestScorePrimaryDescending_BestTimeEnabledAscending : CnGWCFTestBase
        {
            public override void Run()
            {

                string titlePath = "SuitesData\\MixTitleManagementTest\\mobilePV474607D6.xlast";
                const string LOC_FILE = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";
                const string TEMP_FILE = "SuitesData\\MixTitleManagementTest\\Mobile\\xlastAfterConversion.xml";

                uint mobileTitleID = 0x474607D6;
                DeployTitle_WithoutMobileConversion(mobileTitleID, titlePath);

                //Following are the values in mobilePV474607D6.xlast that is used for this test
                //si_attribute_id = -2 ( platformVisibleRatingAttributeId="1" ) 
                //We have 2 leaderboards id=1 and id=10
                //Note that for all mobile titles after conversion will have following 5 localized support
                //   <LocalizedStrings nextId="63" defaultLocale="en-US">
                //      <SupportedLocale locale="en-US" />
                //      <SupportedLocale locale="fr-FR" />
                //      <SupportedLocale locale="it-IT" />
                //      <SupportedLocale locale="de-DE" />
                //      <SupportedLocale locale="es-ES" />
                // For <FriendStatsView> leaderboard id=0 (primary) will be converted to 2 <StatsView> one "primary" and one "enabled"
                // <StatsView> leaderboard id=0 (primary) and leaderboard id=1 (enabled)
                // For leaderboard id=10 which is the "enabled" 
                
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(mobileTitleID);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)mobileTitleID);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(mobileTitleID);

                // The below code is to generate the expected converted XLAST file for verification whic we store in TEMP_FILE
                TestMobileTitle test1 = new TestMobileTitle(titlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                VerifyStatsData(mobileTitleID, TEMP_FILE);

                int count = t_pvt.RowCount((int)mobileTitleID);

                //We have 2 <FriendsStatsView> each localized for 5 languages. And we expect (2*2)=4 <StatsView> and in turn expect (4*5)=20 entries in platform visible table
                if (count != 20)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 20, Actual = {0}", count));
                }

                // Verify platform visible primary FriendsStatsView variant=0, BestScore, Lifetime
                // si_rating_attribute_id = 65534(int) / -2(short)
                
                int _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(0, MobileAndWebRatingColumn.BestScore, MobileAndWebLeaderboardType.Lifetime);

                if (1 != t_pvt.RowCount((int)mobileTitleID, 
                                                _lbID, 
                                                "en-US", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0,
                                                "Score", 
                                                "Score"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, -2, {2}, {3}, {4}, Score, Score", 
                                                mobileTitleID, 
                                                _lbID,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, 
                                                _lbID, 
                                                "de-DE", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0, 
                                                "Punkte", 
                                                "Punkte"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, -2, {2}, {3}, {4}, Punkte, Punkte", 
                                                mobileTitleID, 
                                                _lbID,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID,
                                                _lbID, 
                                                "es-ES", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0, 
                                                "Puntuacion", 
                                                "PuntuaciÃ³n"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, -2, {2}, {3}, {4}, Puntuacion, PuntuaciÃ³n", 
                                                mobileTitleID, 
                                                _lbID,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, 
                                                _lbID, 
                                                "fr-FR", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0, 
                                                "Points", 
                                                "Score"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, -2, {2}, {3}, {4}, Points, Score", 
                                                mobileTitleID, 
                                                _lbID,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, 
                                                _lbID, 
                                                "it-IT", 
                                                -2,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0, 
                                                "Punti", 
                                                "Punteggio"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, -2, {2}, {3}, {4}, Punti, Punteggio", 
                                                mobileTitleID, 
                                                _lbID,
                                                (byte)PlatformVisibleLeaderboardFlags.Primary,
                                                0,
                                                0));
                }

                // Verify platform visible primary FriendsStatsView variant=0, BestScore, Weekly
                // si_rating_attribute_id = 65534(int) / -2(short)

                _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(0, MobileAndWebRatingColumn.BestScore, MobileAndWebLeaderboardType.Weekly);

                if (1 != t_pvt.RowCount((int)mobileTitleID, 
                                                _lbID, 
                                                "en-US", 
                                                -2, 
                                                0, 
                                                0,
                                                0,
                                                "Score", 
                                                "Score"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, -2, 0, 0, 0, Score, Score", mobileTitleID, _lbID));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "de-DE", -2, 0, 0, 0, "Punkte", "Punkte"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, -2, 0, 0, 0, Punkte, Punkte", mobileTitleID, _lbID));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "es-ES", -2, 0, 0, 0, "Puntuacion", "PuntuaciÃ³n"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, -2, 0, 0, 0, Puntuacion, PuntuaciÃ³n", mobileTitleID, _lbID));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "fr-FR", -2, 0, 0, 0, "Points", "Score"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, -2, 0, 0, 0, Points, Score", mobileTitleID, _lbID));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "it-IT", -2, 0, 0, 0, "Punti", "Punteggio"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, -2, 0, 0, 0, Punti, Punteggio", mobileTitleID, _lbID));
                }


                // Verify platform visible primary FriendsStatsView variant=10, BestScore, Lifetime
                // si_rating_attribute_id = 2 whic his the display column and maps to propertyID 0x20000002

                _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(10, MobileAndWebRatingColumn.BestTime, MobileAndWebLeaderboardType.Lifetime);

                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "en-US", 2, 
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime, 
                                    "Time", 
                                    "Time"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, 2, 0, {2}, {3}, Time, Time", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "de-DE", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime, 
                                    "Zeit", 
                                    "Zeit"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, 2, 0, {2}, {3}, Zeist, Zeist",                                    
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "es-ES", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Tiempo", 
                                    "Tiempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Tiempo, Tiempo",                                     
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "fr-FR", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Temp", 
                                    "Heure"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, 2, 0, {2}, {3}, Temp, Heure", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "it-IT", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Tempo", 
                                    "Tempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Tempo, Tempo", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }

                // Verify platform visible primary FriendsStatsView variant=10, BestScore, Weekly
                // si_rating_attribute_id = 2 whic his the display column and maps to propertyID 0x20000002
                
                _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(10, MobileAndWebRatingColumn.BestTime, MobileAndWebLeaderboardType.Weekly);

                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "en-US", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Time", 
                                    "Time"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, 2, 0, {2}, {3}, Time, Time", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "de-DE", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Zeit", 
                                    "Zeit"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, 2, 0, {2}, {3}, Zeist, Zeist", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "es-ES", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Tiempo", 
                                    "Tiempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Tiempo, Tiempo", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "fr-FR", 2, 
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime, 
                                    "Temp", 
                                    "Heure"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, 2, 0, {2}, {3}, Temp, Heure", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "it-IT", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Tempo", 
                                    "Tempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Tempo, Tempo", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }

            }
        }

        [TestCase, Description("PlatformLeaderboardTest for Mobile Xlast BestTime Primary Ascending"), Owner("srkalyan"), TestFrequency("Daily"), TestCasePriority(1)]
        class PlatformVisibleMobile_BestTimePrimaryAscending : CnGWCFTestBase
        {
            public override void Run()
            {
                string titlePath = "SuitesData\\MixTitleManagementTest\\mobilePV474607D6_Ascending_BestTime.xlast";
                const string LOC_FILE = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";
                const string TEMP_FILE = "SuitesData\\MixTitleManagementTest\\Mobile\\xlastAfterConversion.xml";

                uint mobileTitleID = 0x474607D6;
                DeployTitle_WithoutMobileConversion(mobileTitleID, titlePath);

                // Following are the values in mobilePV474607D6_Ascending_BestTime.xlast that is used for this test
                //si_attribute_id = 2 ( platformVisibleRatingAttributeId="2" ) 
                
                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(mobileTitleID);

                t_PlatformVisibleLeaderboard t_pvt = new t_PlatformVisibleLeaderboard();
                t_pvt.delete((int)mobileTitleID);

                // Deploy the test title using MIX API
                base.statsClient.ConfigureLeaderboards(mobileTitleID);

                TestMobileTitle test1 = new TestMobileTitle(titlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                VerifyStatsData(mobileTitleID, TEMP_FILE);

                int count = t_pvt.RowCount((int)mobileTitleID);

                if (count != 10)
                {
                    throw new Exception(String.Format("The number of expected rows in [t_stats_platform_visible_leaderboards] do not match. Expected = 10, Actual = {0}", count));
                }

                // Verify platform visible primary FriendsStatsView variant=0, BestTime, Lifetime
                // si_rating_attribute_id = 65534(int) / -2(short)
                
                int _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(0, MobileAndWebRatingColumn.BestTime, MobileAndWebLeaderboardType.Lifetime);

                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "en-US", 2, 
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Score",
                                    "Time"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, 2, {2}, {3}, {4}, Score, Time", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "de-DE", 2,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Punkte", 
                                    "Zeit"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, 2, {2}, {3}, {4}, Punkte, Zeit", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "es-ES", 2,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Puntuacion", 
                                    "Tiempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, {2}, {3}, {4}, Puntuacion, Tiempo", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "fr-FR", 2,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Points", 
                                    "Heure"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, 2, {2}, {3}, {4}, Points, Heure", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "it-IT", 2,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Punti", 
                                    "Tempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, {2}, {3}, {4}, Punti, Punteggio",
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardFlags.Primary,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }

                // Verify platform visible primary FriendsStatsView variant=0, BestTime, weekly
                // si_rating_attribute_id = 65534(int) / -2(short)
                
                _lbID = MobileAndWebLeaderboardUtils.GetLeaderboardId(0, MobileAndWebRatingColumn.BestTime, MobileAndWebLeaderboardType.Weekly);

                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "en-US", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Score", 
                                    "Time"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, en-US, 2, 0, {2}, {3}, Score, Time", 
                                    mobileTitleID, 
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "de-DE", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Punkte", 
                                    "Zeit"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, de-DE, 2, 0, {2}, {3}, Punkte, Zeit",
                                    mobileTitleID,
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "es-ES", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Puntuacion", 
                                    "Tiempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Puntuacion, Tiempo",
                                    mobileTitleID,
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "fr-FR", 2,
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Points", 
                                    "Heure"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, fr-FR, 2, 0, {2}, {3}, Points, Heure",
                                    mobileTitleID,
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
                if (1 != t_pvt.RowCount((int)mobileTitleID, _lbID, "it-IT", 2, 
                                    0,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime,
                                    "Punti", 
                                    "Tempo"))
                {
                    throw new Exception(String.Format("Following expected row not found - {0}, {1}, es-ES, 2, 0, {2}, {3}, Punti, Punteggio",
                                    mobileTitleID,
                                    _lbID,
                                    (byte)PlatformVisibleLeaderboardDataType.Timespan,
                                    (byte)PlatformVisibleLeaderboardTimeFormats.ExtraLongTime));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\StorageTest\StorageTests.cs ===
ï»¿//Storage Tests for the MIX Storage API

using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Threading;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.Linq;

using xonline.common.config;
using xonline.mix.common;
using MIXTesting;
using xonline.mix.storage;
using xonline.mix.storage.contracts.V1;

namespace MixTest
{

    /// <summary>
    /// This test group covers the storage submission APIs.
    /// </summary>
    /// 
    [TestGroup, Owner("esebeni"), Description("Mix Storage Tests"), TestCasePriority(1)]
    public class StorageTests : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixstorage, "Xonline.Mix.Storage.Service", "MixStorage.SubmitFileToStorage", "MixStorage.SubmitAvatarImageToStorage");
        }

        private readonly int GLOBAL_STORAGE_DOMAIN = 6;
        int refreshTimer = 0;


        #region utils

        public override void PreRun()
        {
            base.PreRun();
            XConfig config = new XConfig();
            refreshTimer = config.GetStorageCacheRefreshTimer(GLOBAL_STORAGE_DOMAIN);
            config.SetStorageCacheRefreshTimer(GLOBAL_STORAGE_DOMAIN, 0);
            config.ForceConfigReload("stfd");
        }

        public override void PostRun()
        {
            XConfig config = new XConfig();
            config.SetStorageCacheRefreshTimer(GLOBAL_STORAGE_DOMAIN, refreshTimer);
            config.ForceConfigReload("stfd");
            base.PostRun();
        }


        #endregion
        [TestCase, Description("DefaultTest - Test Storing One Image")]
        class P_StoreImage_BaseCase : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.Achievement);
            }
        }

        [TestCase, Description("DefaultAvatarTest - Test Storing One Avatar Image")]
        class P_StoreAvatarImage_BaseCase : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeAvatarItem();
            }
        }

        [TestCase, Description("AchievementImageTest - Test Storing an Achievement Image")]
        class P_StoreAvatarImage : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.Achievement);
            }
        }

        [TestCase, Description("InGameMarketplaceBannerImageTest - Test Storing an InGameMarketplaceBanner Image")]
        class P_StoreInGameMarketplaceBannerImage : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.InGameMarketplaceBanner);
            }
        }

        [TestCase, Description("Avatar64ImageTest - Test Storing an Avatar64 Image")]
        class P_StoreAvatar64Image : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.Avatar64);
            }
        }

        [TestCase, Description("GameIconTest - Test Storing a GameIcon Image")]
        class P_StoreGameIcon : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.GameIcon);
            }
        }

        [TestCase, Description("GamertileTest - Test Storing a Gamertile Image")]
        class P_StoreGamertile : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.Gamertile);
            }
        }

        [TestCase, Description("MarketplaceImageTest - Test Storing a Marketplace Image")]
        class P_StoreMarketplaceImage : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.MarketplaceIcon);
            }
        }

        [TestCase, Description("AvatarImages - Store the Avatar image into storage for both an achievment image and an avatar image")]
        class P_AvatarImages : CnGWCFTestBase
        {
            public override void Run()
            {
                base.storageClient.SubmitFakeItem(MIXFileType.Avatar64);
                base.storageClient.SubmitFakeAvatarItem();
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails0"), TestCasePriority(2)]
        class P_AvatarDetails0 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails0))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails1"), TestCasePriority(2)]
        class P_AvatarDetails1 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails1))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails2"), TestCasePriority(2)]
        class P_AvatarDetails2 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails2))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails3"), TestCasePriority(2)]
        class P_AvatarDetails3 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails3))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails4"), TestCasePriority(2)]
        class P_AvatarDetails4 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails4))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails5"), TestCasePriority(2)]
        class P_AvatarDetails5 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails5))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails6"), TestCasePriority(2)]
        class P_AvatarDetails6 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails6))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails7"), TestCasePriority(2)]
        class P_AvatarDetails7 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails7))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails8"), TestCasePriority(2)]
        class P_AvatarDetails8 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails8))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("AvatarImages - Store AvatarDetails9"), TestCasePriority(2)]
        class P_AvatarDetails9 : CnGWCFTestBase
        {
            public override void Run()
            {
                if (!base.storageClient.SubmitFakeAvatarItem(MIXFileType.AvatarDetails9))
                    throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
            }
        }

        [TestCase, Description("NullImage - Try to submit a null image "), TestCasePriority(3)]
        class P_NullImage : CnGWCFTestBase
        {
            public override void Run()
            {
                try
                {
                    base.storageClient.SubmitFakeItem(
                                                    base.storageClient.FakeTitleID,
                                                    MIXFileType.Achievement,
                                                    storageClient.RandomImageID(),
                                                    null,
                                                    true);
                }
                catch (UnexpectedTestResultException) //Expected //!TODO: this isn't the best exception to have expectedly thrown...
                {
                    return;
                }

                throw new UnexpectedTestResultException("Test did not fail with a null image.");
            }
        }

        [TestCase, Description("HugeImage - Try to submit a huge image "), TestCasePriority(2)]
        class P_HugeImage : CnGWCFTestBase
        {
            public override void Run()
            {
                if (base.storageClient.SubmitFakeItem(
                                                    base.storageClient.FakeTitleID,
                                                    MIXFileType.Achievement,
                                                    storageClient.RandomImageID(),
                                                    new byte[220000],
                                                    true))
                {
                    if (!base.storageClient.SubmitFakeAvatarItem())
                        throw new UnexpectedTestResultException("SubmitFakeAvatarItem failed");
                }
                else
                    throw new UnexpectedTestResultException("SubmitFakeItem failed");
            }
        }

        [TestCase, Description("EmptyGuid - Try to submit an empty guid for an avatar item "), TestCasePriority(3)]
        class P_EmptyGuid : CnGWCFTestBase
        {
            public override void Run()
            {
                try
                {
                    base.storageClient.SubmitFakeAvatarItem(
                                                    base.storageClient.FakeTitleID,
                                                    MIXFileType.Avatar64,
                                                    Guid.Empty,
                                                    base.storageClient.RandomImage(),
                                                    true);
                }
                catch (UnexpectedTestResultException) //Expected //!TODO: this isn't the best exception to have expectedly thrown...
                {
                    return;
                }

                throw new UnexpectedTestResultException("Test did not fail with an empty Guid.");
            }
        }

        [TestCase, Description("InvalidType - Try to submit an invalid type an image"), TestCasePriority(3)]
        class P_InvalidType : CnGWCFTestBase
        {
            public override void Run()
            {
                try
                {
                    base.storageClient.SubmitAvatarImageToStorage(
                                                    base.storageClient.FakeTitleID,
                                                    MIXFileType.Achievement,
                                                    Guid.NewGuid(),
                                                    base.storageClient.RandomImage());
                }
                catch (UnexpectedTestResultException) //!TODO: this isn't the best exception to have expectedly thrown...
                {
                    return;
                }

                throw new UnexpectedTestResultException("Test did not fail with an invalid type.");
            }
        }

        [TestCase, Description("ImageCountQuota - Violate the image count quota"), TestCasePriority(3)]
        class P_ImageCountQuota : CnGWCFTestBase
        {
            public override void Run()
            {
                try
                {
                    ulong imageQuota = base.storageClient.retrieveFileCountQuota(base.storageClient.FakeTitleID);
                    if (imageQuota <= 0) // No quota
                    {
                        throw new DidNotExecuteException("This environment does not have an image count quota!");
                    }
                    for (ulong i = 0; i < imageQuota + 1; i++) // Make sure we go over the quota
                    {
                        base.storageClient.SubmitFakeAvatarItem(
                                                        base.storageClient.FakeTitleID,
                                                        MIXFileType.Avatar64,
                                                        Guid.NewGuid(),
                                                        base.storageClient.RandomImage(),
                                                        true);
                    }
                }
                catch (UnexpectedTestResultException) //!TODO: this isn't the best exception to have expectedly thrown...
                {
                    return;
                }

                throw new UnexpectedTestResultException("Storage API violated the storage quota without consequence!");
            }
        }

        [TestCase, Description("ImageSizeQuota - Violate the image size quota"), TestCasePriority(3)]
        class P_ImageSizeQuota : CnGWCFTestBase
        {
            public override void Run()
            {
                try
                {
                    ulong sizeQuota = base.storageClient.retrieveFileSizeQuota(base.storageClient.FakeTitleID);
                    if (sizeQuota <= 0) // No quota
                    {
                        throw new DidNotExecuteException("This environment does not have an image size quota!");
                    }
                    base.storageClient.SubmitFakeAvatarItem(
                                                        base.storageClient.FakeTitleID,
                                                        MIXFileType.Avatar64,
                                                        Guid.NewGuid(),
                                                        base.storageClient.RandomImage(sizeQuota),
                                                        true);
                }
                catch (UnexpectedTestResultException) //!TODO: this isn't the best exception to have expectedly thrown...
                {
                    return;
                }

                throw new UnexpectedTestResultException("Storage API violated the image size quota without consequence!");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\ServiceTypeEnumerateV1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;

using MIXTesting;

namespace MixTest
{
    public class ServiceTypes : NameValueList
    {
        public ServiceTypes()
        {
            Add("0", 0);
            Add("Xbox Live", 1);
            Add("Zune", 2);
        }
    }

    [TestGroup, Owner("LukeL"), TestCasePriority(1), TestFrequency("Regression")]
    public class ServiceTypeEnumerateV1: TestNode
    {
        static protected ServiceTypes serviceTypes;

        public override void OneTimeSetup()
        {
            serviceTypes = new ServiceTypes();
        }

        [TestCase, Description("Verify ServiceType returned")]
        class P_ServiceTypeEnumerate : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] sets = client.ServiceTypeEnumerate();              
                serviceTypes.Compare(sets);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\ServicePrivilegeSetEnumerateV1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;

using MIXTesting;

namespace MixTest
{

    public class NameValueList
    {

        //common stuff used by other groups too
        public List<NameValue> EntryList = new List<NameValue>();

        public void Add(string name, int value)
        {
            NameValue nv = new NameValue();
            nv.Name = name;
            nv.Value = value;
            EntryList.Add(nv);
        }

        //check if the list is a sub set of  list1 or not
        public bool IsSubSetof(NameValue[] list1)
        {
            NameValue[] list2 = EntryList.ToArray();
            if (list1 == list2) return true;

            if (list1 == null || list2 == null) return false;

            
            ValueCheck.Test("array size >0", true, list2.Length > 0);
            ValueCheck.Test("array size >0", true, list1.Length > 0);
            
            for (int i = 0; i < list2.Length; i++)
            {
                bool found = false;
                for (int j = 0; j < list1.Length; j++)
                {
                    if(list2[i].Name == list1[j].Name  &&
                        list2[i].Value == list1[j].Value)
                    {
                            found = true;
                            break;
                    }
                }
                if (!found) {
                    throw new UnexpectedTestResultException("can not find Name: " + list2[i].Name + " Value: " + list2[i].Value);
                }
            }
            return true;
        }

       
        public bool Compare(NameValue[] list1)
        {
            NameValue[] list2 = EntryList.ToArray();
            if (list1 == list2) return true;

            if (list1 == null || list2 == null) return false;

            ValueCheck.Test("array size", list1.Length, list2.Length);
            ValueCheck.Test("array size >0", true, list2.Length > 0);

            for (int i = 0; i < list1.Length; i++)
            {
                ValueCheck.Test("", list1[i].Name, list2[i].Name);
                ValueCheck.Test("", list1[i].Value, list2[i].Value);
            }
            return true;
        }
    }

    // --

    public class ServicePrivilegeSets : NameValueList
    {
        public static NameValue[] List;

        public ServicePrivilegeSets()
        {
            Add("Xbox Live - Silver", 101);
            Add("Xbox Live - Gold", 102);
            Add("Xbox Live - Family Gold", 103);
            Add("Zune Pass", 201);
        }
    }

    [TestGroup, Owner("LukeL"), TestCasePriority(1), TestFrequency("Regression")]
    public class ServicePrivilegeSetEnumerateV1: TestNode
    {

        static protected ServicePrivilegeSets servicePrivilegeSets;
        static protected int InvalidServicePrivilegeSet = 99999;

        public override void OneTimeSetup()
        {
            servicePrivilegeSets = new ServicePrivilegeSets();
        }

        [TestCase, Description("Verify the test service privileges added returned")]
        class P_ServicePrivilegeSetEnumerate : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] retSets = client.ServicePrivilegeSetEnumerate();

                foreach (NameValue nv in retSets)
                {
                    Global.RO.Info("Name: " + nv.Name + " Value:" + nv.Value);
                }
                servicePrivilegeSets.IsSubSetof(retSets);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\SubscriptionFamilyGetV1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;

using MIXTesting;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1), TestFrequency("Regression")]
    public class SubscriptionFamilyGetV1: TestNode
    {
        [TestCase, Description("Verify null return for none existed SubscriptionFamily")]
        class P_SubscriptionFamilyGet_Null : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo sf = client.SubscriptionFamilyGet(Guid.NewGuid());
                if (sf != null)
                    throw new UnexpectedTestResultException("Expected SubscriptionFamilyInfo to be null");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\SubscriptionFamilyConfigureV1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;

using MIXTesting;

namespace MixTest
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1), TestFrequency("Regression")]
    public class SubscriptionFamilyConfigureV1: TestNode
    {
        static protected int InvalidSubscriptionType = 99999;
        static protected int InvalidServiceType = 99999;
        static protected int InvalidServicePrivilegeSet = 99999;

        [TestCase, Description("Verfiy Create and Get methods for SubscriptionFamily")]
        class P_SubscriptionFamilyConfigure : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();

                Guid familyId = Guid.NewGuid();
                string familyName = "test SubscriptionFamily1";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                uint title = 0xfffe07d1;
                int[] titleIds = new int[] {(int) title };
                System.Nullable<int> servicePrivilegeSet = (System.Nullable<int>)101;

                //create subscriptionfamily through mix
                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);

                //read through value from mix service
                client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo sfRet = client.SubscriptionFamilyGet(familyId);

                Global.RO.Info("return titleId: " + sfRet.TitleIds[0].ToString("X") + "\n");
                SubscriptionFamilyHelper.Compare(sf1, sfRet);

            }
        }

        [TestCase, Description("Verfiy Create and Get methods for SubscriptionFamily")]
        class P_SubscriptionFamilyConfigure_Titles : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();

                Guid familyId = Guid.NewGuid();
                string familyName = "test SubscriptionFamily1";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                uint title = 0xfffe07d1;
                uint title2 = 0xfffe0777;
                int[] titleIds = new int[] { (int)title };
                System.Nullable<int> servicePrivilegeSet = (System.Nullable<int>)101;

                //create subscriptionfamily through mix
                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);

                //read through value from mix service
                client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo sfRet = client.SubscriptionFamilyGet(familyId);

              
                Global.RO.Info("return title lengths:" + sfRet.TitleIds.Length);
                Global.RO.Info("return titleId: " + sfRet.TitleIds[0].ToString("X") + "\n");
                SubscriptionFamilyHelper.Compare(sf1, sfRet);

               
                titleIds = new int[] { (int)title, (int)title2 };
                sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
                sfRet = client.SubscriptionFamilyGet(familyId);
                Global.RO.Info("return title lengths:" + sfRet.TitleIds.Length);
                Global.RO.Info("return titleId: " + sfRet.TitleIds[0].ToString("X") + "\n");
                SubscriptionFamilyHelper.Compare(sf1, sfRet);
                Global.RO.Info("return titleId: " + sfRet.TitleIds[1].ToString("X") + "\n");
                SubscriptionFamilyHelper.Compare(sf1, sfRet);

                titleIds = new int[] { (int)title};
                sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
                sfRet = client.SubscriptionFamilyGet(familyId);
                Global.RO.Info("return title lengths:" + sfRet.TitleIds.Length);
                Global.RO.Info("return titleId: " + sfRet.TitleIds[0].ToString("X") + "\n");
                SubscriptionFamilyHelper.Compare(sf1, sfRet);

            }
        }

        [TestCase, Description("Verfiy Create and Get methods for SubscriptionFamily when passing null for servicePrivilegeSet")]
        class P_SubscriptionFamilyConfigure_servicePrivilegeSet_Null : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();

                Guid familyId = Guid.NewGuid();
                string familyName = "test SubscriptionFamily1";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                System.Nullable<int> servicePrivilegeSet = null;

                //create subscriptionfamily through mix
                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);

                //read through value from mix service
                client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo sfRet = client.SubscriptionFamilyGet(familyId);

                SubscriptionFamilyHelper.Compare(sf1, sfRet);
            }
        }

        [TestCase, Description("Verfiy updating  SubscriptionFamily")]
        class P_SubscriptionFamilyUpdate : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();

                Guid familyId = Guid.NewGuid();
                string familyName = "test SubscriptionFamily1";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                int servicePrivilegeSet = 102;

                //create subscriptionfamily through mix
                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);

                //read through value from mix service
                client = new SubscriptionFamilyWCFClient();
                SubscriptionFamilyInfo sfRet = client.SubscriptionFamilyGet(familyId);

                SubscriptionFamilyHelper.Compare(sf1, sfRet);
                //change subscription family
                tierId = 3;
                serviceType = 2;
                servicePrivilegeSet = 101; 
                SubscriptionFamilyInfo sfModified = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
                client = new SubscriptionFamilyWCFClient();
                sfRet = client.SubscriptionFamilyGet(familyId);

                SubscriptionFamilyHelper.Compare(sfModified, sfRet);
            }
        }

        [TestCase, Description("Verfiy passing invalid service type")]
        class N_SubscriptionFamilyConfigure_InvalidServiceType : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.XONLINE_E_MIX_INVALID_SERVICE_TYPE;

                Guid familyId = Guid.NewGuid();
                string familyName = "test SubscriptionFamily1";
                int serviceType = InvalidServiceType;
                int subscriptionType = 1;
                int tierId = 6;
                int servicePrivilegeSet = 102;
            
                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }

        }

        [TestCase, Description("Verfiy passing null for familyName")]
        class P_SubscriptionFamilyConfigure_Name_Null : WCFTestBase
        {

            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.S_OK;

                Guid family