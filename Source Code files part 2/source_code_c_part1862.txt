SINT) & Size) &&
        ((lpMem == NULL) || GetCPElementData (cp, Index, lpMem, Size)) &&
        (*lpcbSize = Convert2Ascii (cp, Index, lpMem, *lpcbSize, Size, AllowBinary)))
    {
        return TRUE;
    } else
    {
        return FALSE;
    }
}
/***************************************************************************
*                           GetPS2CSA_DEFG_Intent
*  function:
*    This is the function which creates the CieBasedDEF(G)ColorSpace array
*    based on Intent.
*  prototype:
*       static BOOL GetPS2CSA_DEFG_Intent(
*                   CHANDLE     cp,
*                   MEMPTR      lpBuffer,
*                   LPDWORD     lpcbSize,
*                   CSIG        Intent,
*                   int         Type,
*                   BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_DEFG_Intent (
                       CHANDLE cp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       DWORD InpDrvClrSp,
                       CSIG Intent,
                       int Type,
                       BOOL AllowBinary)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG icSigAToBx;

 // Try to create CieBasedDEFG CSA first.
    if (((Type == TYPE_CIEBASEDDEFG) && (InpDrvClrSp != icSigCmykData) ||
         (Type == TYPE_CIEBASEDDEF) && (InpDrvClrSp != icSigDefData)) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
    switch (Intent)
    {
        case icPerceptual:
            icSigAToBx = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        case icSaturation:
            icSigAToBx = icSigAToB2Tag;
            break;
        case icAbsoluteColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        default:
            return Success;
    }

    if (DoesCPTagExist (cp, icSigAToBx) &&
        GetCPTagIndex (cp, icSigAToBx, (LPSINT) & Index))
    {
        Success = GetPS2CSA_DEFG (cp, lpBuffer, lpcbSize, Intent, Index, Type, AllowBinary);
    }

    return Success;
}
/***************************************************************************
*                               GetPS2ColorSpaceArray
*  function:
*    This is the main function which creates the ColorSpace array
*    from the data supplied in the Profile.
*  prototype:
*       BOOL GetPS2ColorSpaceArray(
*               CHANDLE     cp,
*               CSIG        InputIntent,
*               WORD        InpDrvClrSp,
*               MEMPTR      lpBuffer,
*               LPDWORD     lpcbSize,
*               BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*                       icSigCmykData: input data is cmyk, create CiebasedDEFG CSA.
*                       icSigRgbData : input data is rgb, create CieBasedABC CSA.
*                       icSigDefData : input data is rgb or lab, create CiebasedDEF CSA.
*                       isSigGrayData: input data is gray, create CieBasedA CSA.
*                       0            : Auto. Create CSA depends on profile color space.
*       InputIntent --  Intent.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
BOOL EXTERN
GetPS2ColorSpaceArray (
                       CHANDLE cp,
                       DWORD InputIntent,
                       DWORD InpDrvClrSp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       BOOL AllowBinary)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;
    DWORD dwSaveSize;
    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    dwSaveSize = *lpcbSize;
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

 // Get ColorSpace from Profile.
    if ((CSIG) InputIntent == Intent)
    {
        Success = GetCSAFromProfile (cp, lpBuffer, lpcbSize,
                                     InpDrvClrSp, ColorSpace, AllowBinary);
    }
    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    if (!GetPS2CSA_ABC (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, 
                                        AllowBinary, 1))   // create a backup CSA
                        GetDeviceRGB (lpNewBuffer, &cbNewSize, InpDrvClrSp, 1);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;

                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, 
                                         AllowBinary, 0);
                }
                if (!Success)
                {                           // Create DeviceRGB
                    Success = GetDeviceRGB (lpBuffer, lpcbSize, InpDrvClrSp, 0);
                    Success = FALSE;
                }
                break;
            case icSigCmykData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEFG, AllowBinary);
                if (Success)
                {                       // Create DeviceCMYK for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetDeviceCMYK (lpNewBuffer, &cbNewSize, InpDrvClrSp);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create DeviceCMYK
                    Success = GetDeviceCMYK (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigGrayData:
                Success = GetPS2CSA_MONO (cp, lpBuffer, lpcbSize, InpDrvClrSp, 
                                          (CSIG)InputIntent, AllowBinary);
                if (!Success)
                {                           // Create DeviceGray
                    Success = GetDeviceGray (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigLabData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetPS2CSA_ABC_LAB (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, AllowBinary);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC_LAB (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, AllowBinary);
                }
                break;

            default:
                break;
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;
typedef     SFLOAT __huge   *PFLOAT;
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;

// SRGB98
#define  REVCURVE_RATIO         1

/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

#define CS_ENABLE       1
#define CS_DISABLE      2
#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary, BOOL BackupCSA);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
SINT    BeginGlobalDict(MEMPTR lpMem);
SINT    EndGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;
extern  char _far    IntentType[]        ;
extern  char _far    IntentPer[]         ;
extern  char _far    IntentSat[]         ;
extern  char _far    IntentACol[]        ;
extern  char _far    IntentRCol[]        ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    MatrixPQR[]         ;
extern  char _far    RangePQR[]          ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;
 
extern  char _far    AdobeCSA[]          ; 
extern  char _far    AdobeCRD[]          ; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icSigK007Tag                        0x4B303037   /* 'K007' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
BOOL GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve);
SINT CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\profcrd.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICM3SEG)

#define MAXCOLOR8  255

#pragma optimize("", off)

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
       SINT numChan, SINT tableSize, SINT Offset, CSIG Tag, MEMPTR Buff);
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, BOOL, BOOL);
BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
       CSIG Intent, int Type);
static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp);
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
       float far *Input, float far *Output, 
       CSIG ColorSpace, BOOL bCheckOutputTable);
static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output);
static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
       LPSINT lpInTbSize, LPSINT lpOutTbSize, 
       LPCSIG lpIntentTag, LPSINT lpGrids);
static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint);

/***************************************************************************
*                           CreateHostInputOutputArray
*  function:
*    this is the function which creates the output array from the data
*    supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*    MEMPTR     lpMem        : The buffer to save output array.
*    LPHOSTCLUT lpHostClut   : 
*    SINT       nOutputCh    : Number of input channel.
*    SINT       nOutputTable : The size of each input table. 
*    SINT       Offset       : The position of source output data(in icc profile).
*    CSIG       Tag          : To determin the Output table is 8 or 16 bits.
*    MEMPTR     Buff         : The buffer that contains source data(copyed from icc profile)
*
*  returns:
*       SINT    Returns number of bytes of Output Array
*
***************************************************************************/

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
                            SINT numChan, SINT tableSize, 
                            SINT Offset, CSIG Tag, MEMPTR Buff)
{
    SINT    i, j;
    PUSHORT lpMemPtr16;
    MEMPTR  lpMemPtr8;
    MEMPTR  lpTable;

    if (Tag == icSigLut8Type)
        lpMemPtr8 = lpMem;
    else
        lpMemPtr16 = (PUSHORT)lpMem;

    for (i = 0; i < numChan; i++)
    {
        if (Tag == icSigLut8Type)
        {
            ppArray[i] = lpMemPtr8;
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                Offset +
                tableSize * i;
            MemCopy(lpMemPtr8, lpTable, tableSize);
                lpMemPtr8 += tableSize;
        }
        else
        {
            ppArray[i] = (MEMPTR)lpMemPtr16;
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * Offset +
                2 * tableSize * i;
            for (j = 0; j < tableSize; j++)
            {
                *lpMemPtr16++ = (USHORT) ui16toSINT (lpTable);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }
    if (Tag == icSigLut8Type)
        return ((SINT) ((MEMPTR)lpMemPtr8 - lpMem));
    else
        return ((SINT) ((MEMPTR)lpMemPtr16 - lpMem));

}

VOID
GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
            LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size)
{
    if (LutTag == icSigLut8Type)
    {
        *nInputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut8Type) lpLut)->lut.clutPoints);
        *nInputTable = 256L;
        *nOutputTable = 256L;
        *size = 1;  // one byte for each input\output table entry
    } else
    {
        *nInputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut16Type) lpLut)->lut.clutPoints);
        *nInputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.inputEnt);
        *nOutputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.outputEnt);
        *size = 2;  // two bytes for each input\output table entry
    }
}

/***************************************************************************
*                           GetHostCSA
*  function:
*    this is the function which creates a Host CSA
*  parameters:
*       CHANDLE cp       --  Color Profile handle 
*       MEMPTR lpMem     --  Pointer to the memory block. If this point is NULL,
*                            require buffer size.
*       LPDWORD lpcbSize --  Size of the memory block
*       CSIG InputIntent --
*       SINT Index       --  to the icc profile tag that contains the data of Intent
*       int  Type        --  DEF or DEFG
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostCSA (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
            CSIG InputIntent, SINT Index, int Type)
{
    CSIG    PCS, LutTag;
    CSIG    IntentSig;
    SINT    nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT    nInputTable, nOutputTable, nNumbers;
    SINT    i, j, k;
    MEMPTR  lpTable;
    MEMPTR  lpOldMem = lpMem;
    MEMPTR  lpLut = NULL;
    HGLOBAL hLut = 0;
    SINT    LutSize;
    LPHOSTCLUT lpHostClut;

    // Check if we can generate the CS.
    // If we cannot find the required tag - we will return false
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }

    // Estimate the memory size required to hold CS
    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    
    // First Pass. This is a size request
    if (lpMem == NULL)                  
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids;
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids;
        *lpcbSize = *lpcbSize             +   // size of RenderTable 8-bits only
            nInputCh * nInputTable * i    +   // size of input table 8/16-bits
            nOutputCh * nOutputTable * i  +   // size of output table 8/16-bits
            sizeof(HOSTCLUT) + 1024;          // data structure + extra safe space
        MemFree (hLut);
        return (TRUE);
    }

    // Second pass. constructure real HostCSA
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (LutTag == icSigLut8Type)? 8:16;

    // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;
    // Input Array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, LutTag, lpLut);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    // ourput array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, LutTag, lpLut);
 //********** /Table

    lpHostClut->clut = lpMem;
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        SecondGrids = nGrids;
    }
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        for (k = 0; k < SecondGrids; k++)
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (LutTag == icSigLut8Type)
            {
                // Copy 8-bit data.
                MemCopy(lpMem, lpTable, nNumbers);
                lpMem += nNumbers;
            }
            else
            {
                // convert 16 bit integer to right format. then copy only 8 bits.
                for (j = 0; j < nNumbers; j++)
                {
                    *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                }
            }
        }
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}

HGLOBAL GetTRCData(CHANDLE cp,
        LPMEMPTR lpRed,  LPMEMPTR lpGreen,  LPMEMPTR lpBlue,
        LPSINT   lpnRed, LPSINT   lpnGreen, LPSINT   lpnBlue)
{
    SINT     RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT     RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    SINT     MemSize;
    HGLOBAL  hMem;

 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
         return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) lpRed))
        return 0;

    *lpGreen = *lpRed + RedTRCSize;
    *lpBlue = *lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, *lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, *lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, *lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (NULL);
    }
    *lpnRed = ui32toSINT (((lpcpCurveType) *lpRed)->curve.count);
    *lpnGreen = ui32toSINT (((lpcpCurveType) *lpGreen)->curve.count);
    *lpnBlue = ui32toSINT (((lpcpCurveType) *lpBlue)->curve.count);

    return (hMem);
}


static SINT
CreateHostTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                        MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    SINT    i;
    PUSHORT lpPtr16;
    MEMPTR  lpTable;

    lpPtr16 = (PUSHORT)lpMem;
   
    lpHostClut->inputArray[0] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpRed)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[1] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpGreen)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[2] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpBlue)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }
    return ((MEMPTR)lpPtr16 - lpMem);
}

static SINT
CreateHostRevTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                           MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    HGLOBAL   hTemp;
    MEMPTR    lpTemp;

    if (!MemAlloc (lpHostClut->outputEnt * (REVCURVE_RATIO + 1) * 2 ,
                  (HGLOBAL FAR *) &hTemp, (LPMEMPTR) &lpTemp))
    {
        return (0);
    }

    lpHostClut->outputArray[0] = lpMem;
    GetRevCurve (lpRed, lpTemp, lpHostClut->outputArray[0]);
    lpHostClut->outputArray[1] = lpHostClut->outputArray[0] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpGreen, lpTemp, lpHostClut->outputArray[1]);
    lpHostClut->outputArray[2] = lpHostClut->outputArray[1] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpBlue, lpTemp, lpHostClut->outputArray[2]);

    MemFree (hTemp);
    return ( 2 * REVCURVE_RATIO * lpHostClut->outputEnt * 3);
}

static BOOL
GetHostMatrixCSAorCRD(CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, BOOL bCSA)
{
    SINT     nRedCount, nGreenCount, nBlueCount;
    MEMPTR   lpRed = NULL,lpGreen, lpBlue;
    HGLOBAL  hMem;
    LPHOSTCLUT lpHostClut;
    MEMPTR   lpOldMem = lpMem;
    double   pArray[9], pRevArray[9], pTemp[9];
    SINT     i;

    hMem = GetTRCData(cp,
        (LPMEMPTR)&lpRed, (LPMEMPTR)&lpGreen, (LPMEMPTR)&lpBlue,
        (LPSINT)&nRedCount,(LPSINT)&nGreenCount, (LPSINT)&nBlueCount);

    // Estimate the memory size required to hold CRD
    *lpcbSize = (nRedCount + nGreenCount + nBlueCount) * 2 +
           sizeof(HOSTCLUT) + 1024;      // data structure + extra safe space

    if (lpMem == NULL)                   // This is a size request
    {
        MemFree (hMem);
        return TRUE;
    }

    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->dataType = DATA_matrix;
    lpHostClut->clutPoints = 2;
    lpHostClut->pcs = icSigXYZData;
    GetCPWhitePoint(cp, (LPSFLOAT)lpHostClut->whitePoint);

    if (bCSA)
    {
        lpHostClut->inputEnt = (USHORT)nRedCount;
        lpHostClut->inputChan = 3;
        lpMem += CreateHostTRCInputTable(lpMem, lpHostClut,
                                         lpRed, lpGreen, lpBlue);
    }
    else
    {
        lpHostClut->outputEnt = (USHORT)nRedCount;
        lpHostClut->outputChan = 3;
        lpMem += CreateHostRevTRCInputTable(lpMem, lpHostClut,
                                            lpRed, lpGreen, lpBlue);
    }

    MemFree (hMem);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    if (!CreateColorantArray(cp, &pTemp[0], icSigRedColorantTag) ||
        !CreateColorantArray(cp, &pTemp[3], icSigGreenColorantTag) ||
        !CreateColorantArray(cp, &pTemp[6], icSigBlueColorantTag))
    {
       return (FALSE);
    }

    for (i = 0; i < 9; i++)
    {
        pArray[i] = pTemp[i/8*8 + i*3%8];
    }

    if (bCSA)
    {
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pArray[i];
    }
    else
    {
        InvertMatrix(pArray, pRevArray);
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pRevArray[i];
    }

    return TRUE;
}

/***************************************************************************
*                        GetHostCSA_Intent
*  function:
*       This is the function which creates the Host DEF or DEFGColorSpace array
*       based on Intent.
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
                   CSIG Intent, int Type)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG AToBxTag;

    switch (Intent)
    {
        case icPerceptual:
            AToBxTag = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // use RelativeColorimetric data to build it.
            AToBxTag = icSigAToB1Tag;
            break;
        case icSaturation:
            AToBxTag = icSigAToB2Tag;
            break;
        default:
            return FALSE;
            break;
    }
    if (DoesCPTagExist (cp, AToBxTag) &&
        GetCPTagIndex (cp, AToBxTag, (LPSINT) & Index))
    {
        Success = GetHostCSA(cp, lpBuffer, lpcbSize, Intent, Index, Type);
    }
    else if ((DoesTRCAndColorantTagExist(cp)) &&
            (Type == TYPE_CIEBASEDDEF))
    {
        Success = GetHostMatrixCSAorCRD(cp, lpBuffer, lpcbSize, TRUE);
    }

    return Success;
}
/***************************************************************************
*                            GetHostColorSpaceArray
*  function:
*    This is the main function which creates the Host CSA
*    from the data supplied in the Profile.
*  parameters:
*       cp          --  Color Profile handle
*       InputIntent --  Intent.
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostColorSpaceArray (CHANDLE cp, DWORD InputIntent,
                       MEMPTR  lpBuffer, LPDWORD lpcbSize)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;

    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEF);
                break;
            case icSigCmykData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEFG);
                break;
            default:
                break;
        }
    }
    return Success;
}

//===========================================================================

/***************************************************************************
*                             CreateHostLutCRD
*  function:
*    this is the function which creates the Host CRD
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       InputIntent --  Intent.
*
*  returns:
*       SINT        --  Size of Host CRD.
***************************************************************************/

static SINT 
CreateHostLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT     nInputCh, nOutputCh, nGrids;
    SINT     nInputTable, nOutputTable, nNumbers;
    CSIG     Tag, PCS;
    CSIG     IntentSig;

    SINT     Ret;
    SINT     i, j;
    MEMPTR   lpTable;

    MEMPTR   Buff = NULL;
    SINT     MemSize = 0;
    MEMPTR   lpOldMem = lpMem;
    HGLOBAL  hMem;
    LPHOSTCLUT  lpHostClut;

    // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }

    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (((nOutputCh != 3) && (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }

    // First Pass. This is a size request
    if (lpMem == NULL)       
    {
        Ret = nInputCh * nInputTable * i         +  // Input table 8/16-bits
            nOutputCh * nOutputTable * i         +  // Output table 8/16-bits
            nOutputCh * nGrids * nGrids * nGrids +  // CLUT 8-bits only
            sizeof(HOSTCLUT)                     +  // Data structure 
            1024;                                   // safe

        MemFree (hMem);
        return (Ret);
    }
     
    // Second Pass. Get a HostCRD
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (Tag == icSigLut8Type)? 8:16;

    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    // Support absolute whitePoint
    if (!GetCPMediaWhitePoint (cp, (LPSFLOAT)lpHostClut->mediaWP)) // .. Media WhitePoint
    {
        lpHostClut->mediaWP[0] = lpHostClut->whitePoint[0];
        lpHostClut->mediaWP[1] = lpHostClut->whitePoint[1];
        lpHostClut->mediaWP[2] = lpHostClut->whitePoint[2];
    }
    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;

//******** Input array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, Tag, Buff);
//******** the offset to the position of output array.
    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
//******** Output array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, Tag, Buff);
//******** Matrix.
    if (PCS == icSigXYZData)
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
        } else
        {
            lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
        }
        for (i = 0; i < 9; i++)
        {
            lpHostClut->e[i] = (float)((si16f16toSFLOAT (lpTable)) / CIEXYZRange);
            lpTable += sizeof (icS15Fixed16Number);
        }
    }
//********** RenderTable
    nNumbers = nGrids * nGrids * nOutputCh;
    lpHostClut->clut = lpMem;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (Tag == icSigLut8Type)
        {
            MemCopy(lpMem, lpTable, nNumbers);
            lpMem += nNumbers;
        }
        else
        {
            for (j = 0; j < nNumbers; j++)
            {
                *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}


/***************************************************************************
*                      GetHostColorRenderingDictionary
*  function:
*    this is the main function which creates the Host CRD
*  parameters:
*       cp          --  Color Profile handle
*       Intent      --  Intent.
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  size of memory block.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
static BOOL
GetHostColorRenderingDictionary (CHANDLE cp, DWORD Intent,
                                MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT Index;
    CSIG BToAxTag;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }

    switch (Intent)
    {
        case icPerceptual:
            BToAxTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // Use RelativeColorimetric to calculate this CRD.
            BToAxTag = icSigBToA1Tag;
            break;

        case icSaturation:
            BToAxTag = icSigBToA2Tag;
            break;

        default:
           *lpcbSize = (DWORD) 0;
            return FALSE;
    }

    if (DoesCPTagExist (cp, BToAxTag) &&
        GetCPTagIndex (cp, BToAxTag, (LPSINT) & Index))
    {
        *lpcbSize = CreateHostLutCRD (cp, Index, lpMem, Intent);
    }
    else if(DoesTRCAndColorantTagExist(cp))
    {
        GetHostMatrixCSAorCRD(cp, lpMem, lpcbSize, FALSE);
    }
    return (*lpcbSize > 0);
}

//========================================================================
/***************************************************************************
*                               g
*  function:
*    Calculate function y = g(x). used in Lab->XYZ conversion
*    y = g(x):      g(x) = x*x*x             if x >= 6/29
*                   g(x) = 108/841*(x-4/29)  otherwise
*  parameters:
*       f           --  x
*  returns:
*       SINT        --  y
***************************************************************************/

static float g(float f)
{
    float frc;
    if (f >= (6/29))
    {
        frc = f * f * f;
    }
    else
    {
        frc = f - (4.0f / 29.0f) * (108.0f / 841.0f);
    }
    return frc;
}

/***************************************************************************
*                          inverse_g
*  function:
*    Calculate inverse function y = g(x). used in XYZ->Lab conversion
*  parameters:
*       f           --  y
*  returns:
*       SINT        --  x
***************************************************************************/
static float inverse_g(float f)
{
    double frc;
    if (f >= (6.0*6.0*6.0)/(29.0*29.0*29.0))
    {
        frc = pow(f, 1.0 / 3.0);
    }
    else
    {
        frc = f * (841.0 / 108.0) + (4.0 / 29.0);
    }
    return (float)frc;
}

//========================================================================

static BOOL
TableInterp3(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpA, tmpBC;
    int    cellA, cellB, cellC;
    float  a, b, c;
    short  Grids;
    short  outputChan;
    MEMPTR v000, v001, v010, v011;
    MEMPTR v100, v101, v110, v111;
    float  vx0x, vx1x;
    float  v0xx, v1xx;
    int    idx;

    cellA = (int)(fTemp[0]);
    a = fTemp[0] - cellA;

    cellB = (int)(fTemp[1]);
    b = fTemp[1] - cellB;

    cellC = (int)(fTemp[2]);
    c = fTemp[2] - cellC;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpA  = outputChan * Grids * Grids; 
    tmpBC = outputChan * (Grids * cellB + cellC);

    // Calculate 8 surrounding cells.
    v000 = lpHostClut->clut + tmpA * cellA + tmpBC;
    v001 = (cellC < (Grids - 1))? v000 + outputChan : v000;
    v010 = (cellB < (Grids - 1))? v000 + outputChan * Grids : v000;
    v011 = (cellC < (Grids - 1))? v010 + outputChan : v010 ;

    v100 = (cellA < (Grids - 1))? v000 + tmpA : v000;
    v101 = (cellC < (Grids - 1))? v100 + outputChan : v100;
    v110 = (cellB < (Grids - 1))? v100 + outputChan * Grids : v100;
    v111 = (cellC < (Grids - 1))? v110 + outputChan : v110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 4 bottom cells.
        vx0x = *v000 + c * (int)((int)*v001 - (int)*v000);
        vx1x = *v010 + c * (int)((int)*v011 - (int)*v010);
        v0xx = vx0x + b * (vx1x - vx0x);

        // Calculate the average of 4 upper cells.
        vx0x = *v100 + c * (int)((int)*v101 - (int)*v100);
        vx1x = *v110 + c * (int)((int)*v111 - (int)*v110);
        v1xx = vx0x + b * (vx1x - vx0x);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xx + a * (v1xx - v0xx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v000++;
            v001++;
            v010++;
            v011++;
            v100++;
            v101++;
            v110++;
            v111++;
        }
    }

    return TRUE;
}

static BOOL
TableInterp4(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpH, tmpI, tmpJK;
    int    cellH, cellI, cellJ, cellK;
    float  h, i, j, k;
    short  Grids;
    short  outputChan;
    MEMPTR v0000, v0001, v0010, v0011;
    MEMPTR v0100, v0101, v0110, v0111;
    MEMPTR v1000, v1001, v1010, v1011;
    MEMPTR v1100, v1101, v1110, v1111;
    float  vxx0x, vxx1x;
    float  vx0xx, vx1xx;
    float  v0xxx, v1xxx;
    int    idx;

    cellH = (int)(fTemp[0]);
    h = fTemp[0] - cellH;

    cellI = (int)(fTemp[1]);
    i = fTemp[1] - cellI;

    cellJ = (int)(fTemp[2]);
    j = fTemp[2] - cellJ;

    cellK = (int)(fTemp[3]);
    k = fTemp[3] - cellK;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpI  = outputChan * Grids * Grids;
    tmpH  = tmpI * Grids; 
    tmpJK = outputChan * (Grids * cellJ + cellK);

    // Calculate 16 surrounding cells.
    v0000 = lpHostClut->clut + tmpH * cellH + tmpI * cellI + tmpJK;
    v0001 = (cellK < (Grids - 1))? v0000 + outputChan : v0000;
    v0010 = (cellJ < (Grids - 1))? v0000 + outputChan * Grids : v0000;
    v0011 = (cellK < (Grids - 1))? v0010 + outputChan : v0010;

    v0100 = (cellI < (Grids - 1))? v0000 + tmpI : v0000;
    v0101 = (cellK < (Grids - 1))? v0100 + outputChan : v0100;
    v0110 = (cellJ < (Grids - 1))? v0100 + outputChan * Grids : v0100;
    v0111 = (cellK < (Grids - 1))? v0110 + outputChan : v0110;

    v1000 = (cellH < (Grids - 1))? v0000 + tmpH : v0000;
    v1001 = (cellK < (Grids - 1))? v1000 + outputChan : v1000;
    v1010 = (cellJ < (Grids - 1))? v1000 + outputChan * Grids : v1000;
    v1011 = (cellK < (Grids - 1))? v1010 + outputChan : v1010;

    v1100 = (cellI < (Grids - 1))? v1000 + tmpI : v1000;
    v1101 = (cellK < (Grids - 1))? v1100 + outputChan : v1100;
    v1110 = (cellJ < (Grids - 1))? v1100 + outputChan * Grids : v1100;
    v1111 = (cellK < (Grids - 1))? v1110 + outputChan : v1110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 8 bottom cells.
        vxx0x = *v0000 + k * (int)((int)*v0001 - (int)*v0000);
        vxx1x = *v0010 + k * (int)((int)*v0011 - (int)*v0010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v0100 + k * (int)((int)*v0101 - (int)*v0100);
        vxx1x = *v0110 + k * (int)((int)*v0111 - (int)*v0110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v0xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the average of 8 upper cells.
        vxx0x = *v1000 + k * (int)((int)*v1001 - (int)*v1000);
        vxx1x = *v1010 + k * (int)((int)*v1011 - (int)*v1010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v1100 + k * (int)((int)*v1101 - (int)*v1100);
        vxx1x = *v1110 + k * (int)((int)*v1111 - (int)*v1110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v1xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xxx + h * (v1xxx - v0xxx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v0000++;
            v0001++;
            v0010++;
            v0011++;
            v0100++;
            v0101++;
            v0110++;
            v0111++;
            v1000++;
            v1001++;
            v1010++;
            v1011++;
            v1100++;
            v1101++;
            v1110++;
            v1111++;
        }
    }

    return TRUE;
}


/***************************************************************************
*                         CheckColorLookupTable
*  function:
*    This function check RenderTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input (in range [0 gred-1]) /
*                                 output(in range [0 1)
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp) 
{
    if (lpHostClut->inputChan == 3)
    {
        TableInterp3(lpHostClut, fTemp);
    }
    else if(lpHostClut->inputChan == 4)
    {
        TableInterp4(lpHostClut, fTemp);
    }
    return TRUE;
}

/***************************************************************************
*                         CheckInputOutputTable
*  function:
*    This function check inputTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input / output data
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, 
                      BOOL bCSA, BOOL bInputTable) 
{
    int     i;
    short   Grids;
    USHORT  floor1, ceiling1;
    float   fIndex;
    int     numChan;
    int     numEnt;
    PMEMPTR ppArray;

    if (bInputTable)
    {
        numChan = lpHostClut->inputChan;
        numEnt = lpHostClut->inputEnt - 1;
        ppArray = lpHostClut->inputArray;
    }
    else
    {
        numChan = lpHostClut->outputChan;
        numEnt = lpHostClut->outputEnt - 1;
        ppArray = lpHostClut->outputArray;
    }

    Grids = lpHostClut->clutPoints;
    for (i = 0; (i <= MAXCHANNELS) && (i < numChan); i++)
    {
        fTemp[i] = (fTemp[i] < 0)? 0: ((fTemp[i] > 1)? 1: fTemp[i]);
        fIndex = fTemp[i] * numEnt;
        if (lpHostClut->lutBits == 8)
        {
            floor1 = ppArray[i][(int)fIndex];
            ceiling1 = ppArray[i][((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 127.0);
            else
                fTemp[i] = (float)(fTemp[i] / 255.0);
        }
        else
        {
            floor1 = ((PUSHORT)(ppArray[i]))[(int)fIndex];
            ceiling1 = ((PUSHORT)(ppArray[i]))[((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 32767.0);
            else
                fTemp[i] = (float)(fTemp[i] / 65535.0);

        }
        if (bInputTable)
        {
            fTemp[i] *= (Grids - 1);
            if (fTemp[i] > (Grids - 1))
                fTemp[i] = (float)(Grids - 1);
        }
    }
    return TRUE;
}

static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = (Input[0] * 50 + 16) / 116;
    fa = (Input[1] * 128 - 128) / 500;
    fb = (Input[2] * 128 - 128) / 200;
    Output[0] = whitePoint[0] * g(fL + fa);
    Output[1] = whitePoint[1] * g(fL);
    Output[2] = whitePoint[2] * g(fL - fb);
}

static void
XYZToLab(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = inverse_g(Input[0] / whitePoint[0]);
    fa = inverse_g(Input[1] / whitePoint[1]);
    fb = inverse_g(Input[2] / whitePoint[2]);
    Output[0] = (fa * 116 - 16) / 100;
    Output[1] = (fL * 500 - fa * 500 + 128) / 255;
    Output[2] = (fa * 200 - fb * 200 + 128) / 255;
}

static void
ApplyMatrix(PFLOAT e, float far *Input, float far *Output)
{
    SINT  i, j;

    for (i = 0; i < 3; i++)
    {
        j = i*3;
        Output[i] = e[j ]    * Input[0] +
                    e[j + 1] * Input[1] +
                    e[j + 2] * Input[2];
    }
}

/***************************************************************************
*                         DoHostConversionCRD
*  function:
*    This function converts XYZ/Lab to RGB/CMYK by using HostCRD
*  parameters:
*       LPHOSTCLUT lpHostCRD  -- pointer to a HostCRD
*       LPHOSTCLUT lpHostCSA  -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
                     float far *Input, float far *Output,
                     CSIG ColorSpace, BOOL bCheckOutputTable)
{
    float   fTemp[MAXCHANNELS];
    float   fTemp1[MAXCHANNELS];
    int     i;

/**
** Input XYZ or Lab in range [0 2]
***/
    // When sampling the deviceCRD, skip the input table.
    // If lpHostCSA is not NULL, the current CRD is targetCRD, we
    // need to do input table conversion
    if (lpHostCSA)
    {
        // Convert Lab to XYZ  in range [ 0 whitePoint ]
        if ((lpHostCRD->pcs == icSigXYZData) && 
            (lpHostCSA->pcs == icSigLabData))
        {
            LabToXYZ(Input, fTemp1, lpHostCRD->whitePoint);
        }
        // Convert XYZ to Lab in range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigXYZData))
        {
            XYZToLab(Input, fTemp, lpHostCSA->whitePoint);
        }
        // Convert Lab to range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigLabData))
        {
            for (i = 0; i < 3; i++)
                fTemp[i] = Input[i] / 2;
        }
        // Convert XYZ to XYZ (based on white point) to range [0 1]
        else
        {   // TODO: different intents using different conversion.
            // icRelativeColorimetric: using Bradford transform.
            // icAbsoluteColorimetric: using scaling.
            for (i = 0; i < 3; i++)
                fTemp1[i] = Input[i] * lpHostCRD->whitePoint[i] / lpHostCSA->whitePoint[i];
        }
 
        // Matrix, used for XYZ data only or Matrix icc profile only
        if (lpHostCRD->pcs == icSigXYZData)
        {
            ApplyMatrix(lpHostCRD->e, fTemp1, fTemp);
        }
     
        if (lpHostCRD->dataType != DATA_matrix)
        {
            //Search input Table
            CheckInputOutputTable(lpHostCRD, fTemp, 0, 1);
        }
    }
    // If the current CRD is device CRD, we do not need to do input
    // table conversion.
    else
    {
        short   Grids;
        Grids = lpHostCRD->clutPoints;
        // Sample data may be XYZ or Lab. It depends on Target icc profile.
        // If the PCS of the target icc profile is XYZ, input data will be XYZ.
        // If the PCS of the target icc profile is Lab, input data will be Lab.

        if (lpHostCRD->dataType == DATA_matrix)
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i];
            }
        }
        else
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i]* (Grids - 1);
                if (fTemp[i] > (Grids - 1))
                    fTemp[i] = (float)(Grids - 1);
            }
        }
    }   // bCheckInputTable

    if (lpHostCRD->dataType != DATA_matrix)
    {
        // Rendering table
        CheckColorLookupTable(lpHostCRD, fTemp);

        /**
         ** Output RGB or CMYK in range [0 1]
        ***/
    }
    if (bCheckOutputTable)
    {
        //Output Table
        CheckInputOutputTable(lpHostCRD, fTemp, 0, 0);
    }
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostCRD->outputChan); i++)
    {
        Output[i] = fTemp[i];
    }

   return TRUE;
}

/***************************************************************************
*                         DoHostConversionCSA
*  function:
*    This function converts RGB/CMYK to XYZ/Lab by using HostCSA
*  parameters:
*       LPHOSTCLUT lpHostCLUT -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output)
{
    float   fTemp[MAXCHANNELS];
    int     i;

/**
** Input RGB or CMYK in range [0 1]
***/
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->inputChan); i++)
    {
        fTemp[i] = Input[i];
    }

    if (lpHostClut->dataType == DATA_matrix)
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);
        ApplyMatrix(lpHostClut->e, fTemp, Output);
    }
    else
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);

        // Rendering table
        CheckColorLookupTable(lpHostClut, fTemp);

        //Output Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 0 );

        /**
         ** Output XYZ or Lab in range [0 2]
         ***/
        for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->outputChan); i++)
        {
            Output[i] = fTemp[i];
        }
    }

    return TRUE;
}               

static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
    LPSINT lpInTbSize, LPSINT lpOutTbSize, 
    LPCSIG lpIntentTag, LPSINT lpGrids)
{
    CSIG    Tag;
    SINT    Index;
    SINT    Ret = 0;
    MEMPTR  Buff = NULL;
    SINT    MemSize = 0;
    HGLOBAL hMem;
    SINT    outputChan, outputEnt;
    SINT    inputChan, inputEnt;
    SINT    Grids;
    SINT    i;

    switch (Intent)
    {
        case icPerceptual:
            *lpIntentTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            *lpIntentTag = icSigBToA1Tag;
            break;

        case icSaturation:
            *lpIntentTag = icSigBToA2Tag;
            break;

        default:
            return FALSE;
    }
    if (!DoesCPTagExist (cp, *lpIntentTag) ||
        !GetCPTagIndex (cp, *lpIntentTag, (LPSINT) & Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        BOOL retVal = FALSE;

        if (NULL != Buff)
        {
            MemFree (hMem);
        }

        // Matrix icc profile.

        *lpGrids = 2;
        if (lpInTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpInTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpInTbSize = *lpInTbSize * 3;
        }
        if (lpOutTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpOutTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpOutTbSize = *lpOutTbSize * 3;
        }
        return retVal;
    }

    if (lpInTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if (inputChan != 3)
        {
            MemFree (hMem);
            return FALSE;
        }

        *lpInTbSize = inputChan * inputEnt * 6;  // Number of INT bytes
        *lpGrids = Grids;
    }

    if (lpOutTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if ((outputChan != 3) && (outputChan != 4))
        {
            MemFree (hMem);
            return FALSE;
        }
        *lpOutTbSize = outputChan * outputEnt * 6; // Number of INT bytes
        *lpGrids = Grids;
    }

    MemFree (hMem);
    return TRUE;
}

/***************************************************************************
*                         CreateOutputArray
*  function:
*       Create CSA/CRD output arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to a buffer which will contain the arrays. 
*       SINT    nOutputCh    -- Number of output channel. if lpHostClut, no meaning.
*       SINT    nOutputTable -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contain LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of output array created.
***************************************************************************/

SINT
CreateOutputArray (MEMPTR lpMem, SINT nOutputCh, 
    SINT nOutputTable, SINT Offset, MEMPTR Intent, 
    CSIG Tag, MEMPTR Buff, BOOL AllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nOutputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->outputChan);
        nOutputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->outputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
              icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);
        
        if (lpHostClut)
            lpTable = ((LPHOSTCLUT)lpHostClut)->outputArray[i];
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                    Offset +
                    nOutputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                    2 * Offset +
                    2 * nOutputTable * i;
        }

        if (!AllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nOutputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nOutputTable; j++)
                {
                    if (lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nOutputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nOutputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nOutputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

/***************************************************************************
*                         CreateInputArray
*  function:
*       Create CSA/CRD Input arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to the buffer which will contain the arrays.
*       SINT    nInputCh     -- Number of input channel. if lpHostClut, no meaning.
*       SINT    nInputTable  -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contains LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of inpput array created.
***************************************************************************/

SINT
CreateInputArray (MEMPTR lpMem, SINT nInputCh, 
    SINT nInputTable, MEMPTR Intent, CSIG Tag, 
    MEMPTR Buff, BOOL bAllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nInputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->inputChan);
        nInputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->inputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
               icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);

        if (lpHostClut)
        {
            lpTable = ((LPHOSTCLUT)lpHostClut)->inputArray[i];
        }
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) + nInputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) + 2 * nInputTable * i;
        }
        if (!bAllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable,lpLineStart, nInputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nInputTable; j++)
                {
                    if(lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nInputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nInputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nInputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

SINT
SendCRDLMN(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs)
{
    MEMPTR  lpOldMem;
    SINT    i, j;

    lpOldMem = lpMem;

//********** /MatrixLMN
    if (icAbsoluteColorimetric == Intent)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);

        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 3; j++)
                lpMem += WriteFloat (lpMem,
                    (double) (i == j) ? whitePoint[i] / mediaWP[i] : 0.0);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double) whitePoint[i]);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, RangeLMNLab);
    }

 //********** /EncodeLMN
    lpMem += WriteNewLineObject (lpMem, EncodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        if (pcs != icSigXYZData)
        {
            lpMem += WriteFloat (lpMem, (double)whitePoint[i]);
            lpMem += WriteObject (lpMem, DivOp);
            lpMem += WriteObject (lpMem, EncodeLMNLab);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    return (SINT)(lpMem - lpOldMem);
}


SINT
SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    if (icAbsoluteColorimetric != Intent)
    {
     //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, RangePQR);

     //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, MatrixPQR);
    }
    else
    {
    //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
        }
        lpMem += WriteObject (lpMem, EndArray);
    //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, Identity);
    }
//********** /TransformPQR
    lpMem += WriteNewLineObject (lpMem, TransformPQRTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem,
            (icAbsoluteColorimetric != Intent) ? TransformPQR[i] : NullOp);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
   
    return (SINT)(lpMem - lpOldMem);
} 

SINT
SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
           MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i, j;
    double TempMatrixABC[9];
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC);
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        if (e)
        {
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, e[i + j * 3]);
                }
            }
        }
        else
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
            } else
            {
                lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
            }
            for (i = 0; i < 9; i++)
            {
                TempMatrixABC[i] = ((double) si16f16toSFLOAT (lpTable)) / CIEXYZRange;
                lpTable += sizeof (icS15Fixed16Number);
            }
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, TempMatrixABC[i + j * 3]);
                }
            }
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nInputCh == 0)
        return (SINT)(lpMem - lpOldMem);

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        if (pcs == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
        lpMem += WriteObject (lpMem, StartClip);
        if (e)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)              // Output ASCII CRD
        {
            lpMem += WriteNewLineObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? 
                              Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT
SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

//********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

//********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
        SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    for (i = 0; i < nOutputCh; i++)
    {
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        if (bHost)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16);
            }
        }

        lpMem += WriteObject (lpMem, EndFunction);
    }
    return (SINT)(lpMem - lpOldMem);
}

//========================================================================
/***************************************************************************
*                  GetPS2PreviewColorRenderingDictionary
*  function:
*    This is the main function that creates proofing CRD.
*    It does the following:
*       1) Creates host TargetCRD, TargetCSA and DevCRD.
*       2) Create proofing CRD by sampling TargetCRD TargetCSA and DevCRD.
*       3) Uses TargetCRD's input table as proofingCRD's input table.
*       4) Uses DevCRD's output table as proofingCRD's output table.
*       5) Sample data is XYZ or Lab, depends on PCS of TargetCRD.
*
*  parameters:
*       CHANDLE  cpDev        -- handle to Target icc profile.
*       CHANDLE  cpTarget     -- handle to Dev icc profile.
*       DWORD    Intent       -- intent 
*       MEMPTR   lpMem        -- pointer to buffer for proofCRD,
*                                NULL means query buffer size.
*       LPDWORD  lpcbSize     -- as input: current buffer size
*                             -- as output: real proofCRD size.
*       BOOL     bAllowBinary -- create a ascii or binary proofCRD.
*
*  returns:
*       BOOL                  -- TRUE/FALSE
***************************************************************************/

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (CHANDLE cpDev,
                                CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL bAllowBinary)
{
    MEMPTR    lpTargetCRD, lpTargetCSA, lpDevCRD;
    DWORD     cbTargetCRD, cbTargetCSA, cbDevCRD;
    HGLOBAL   hTargetCRD, hTargetCSA, hDevCRD;
    BOOL      Success = FALSE;
    float     Input[MAXCHANNELS];
    float     Output[MAXCHANNELS];
    float     Temp[MAXCHANNELS];
    int       i, j, k, l;
    MEMPTR    lpLineStart;
    MEMPTR    lpOldMem;
    CSIG      ColorSpace;
    CSIG      DevColorSpace;
    static CSIG      IntentTag;
    static SINT      PreviewCRDGrid;
    SINT      OutArraySize, InArraySize;
    char      PublicArrayName[TempBfSize];
    SINT      TargetGrids, DevGrids;

    // First pass, return the size of Previewind CRD.
    if (lpMem == NULL)
    {
        SINT   dwOutArraySizr = 0;

        i = 3;      // Default output channal;
        if ((GetCPDevSpace (cpDev, (LPCSIG) & DevColorSpace)) &&
                          (DevColorSpace == icSigCmykData))
        {
            i = 4;
        }

        // Get the input array size IntentTag and Grid of the Target icc profile.
        if (!GetCRDInputOutputArraySize(cpTarget, Intent,
            &InArraySize, NULL, &IntentTag, &TargetGrids ))
            return FALSE;

        // Get the output array size IntentTag and Grid of the Dev icc profile.
        if (!GetCRDInputOutputArraySize(cpDev, Intent,
            NULL, &OutArraySize, &IntentTag, &DevGrids ))
            return FALSE;

        PreviewCRDGrid = (TargetGrids > DevGrids)? TargetGrids: DevGrids;

        // Min proofing CRD grid will be PREVIEWCRDGRID
        if (PreviewCRDGrid < PREVIEWCRDGRID)
            PreviewCRDGrid = PREVIEWCRDGRID;
        *lpcbSize = PreviewCRDGrid * PreviewCRDGrid * PreviewCRDGrid * 
                    i * 2 +           // CLUT size (Hex output)
                    OutArraySize +    // Output Array size
                    InArraySize  +    // Input Array size
                    4096;             // Extra PostScript staff.
         return (TRUE);
    }

    // Second pass, return the Previewind CRD.
    lpOldMem = lpMem;

    //Query the sizes of Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, NULL, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, NULL, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, NULL, &cbDevCRD)))
    {
        return (Success);
    }

    //Alloc the buffers for Host TargetCRD, TargetCSA and DevCRD.
    hTargetCRD = hTargetCSA = hDevCRD = 0;
    if (!MemAlloc (cbTargetCRD, (HGLOBAL FAR *)&hTargetCRD, (LPMEMPTR)&lpTargetCRD) ||
        !MemAlloc (cbTargetCSA, (HGLOBAL FAR *)&hTargetCSA, (LPMEMPTR)&lpTargetCSA) ||
        !MemAlloc (cbDevCRD, (HGLOBAL FAR *)&hDevCRD, (LPMEMPTR)&lpDevCRD))
    {
        goto Done;
    }

    //Build Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, lpTargetCRD, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, lpTargetCSA, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, lpDevCRD, &cbDevCRD)))
    {
        goto Done;
    }

//  Build Proofing CRD based on Host TargetCRD TargetCSA and DevCRD.
//  We use TargetCRD input tables and matrix as the
//  input tables and matrix of the ProofCRD.
//  We use DevCRD output tables as the output tables of the ProofCRD.

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cpDev, IntentTag, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, (SINT)0, (SINT)0, (MEMPTR)PublicArrayName, 
             (CSIG)0, NULL, bAllowBinary, lpTargetCRD);

    lpMem += CreateOutputArray (lpMem, (SINT)0, (SINT)0, (SINT)0, 
             (MEMPTR)PublicArrayName, (CSIG)0, NULL, bAllowBinary, lpDevCRD);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (Intent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;

        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;

        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }

//********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send PQR - For White Point correction
    lpMem += SendCRDPQR(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint,
        ((LPHOSTCLUT)lpTargetCRD)->mediaWP,
        ((LPHOSTCLUT)lpTargetCRD)->pcs);

//********** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpTargetCRD)->pcs,
        ((LPHOSTCLUT)lpTargetCRD)->inputChan,
        NULL,
        ((LPHOSTCLUT)lpTargetCRD)->e,
        (((LPHOSTCLUT)lpTargetCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        bAllowBinary);

//********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Na
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nb
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    ColorSpace = ((LPHOSTCLUT)lpDevCRD)->pcs;
    for (i = 0; i < PreviewCRDGrid; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (bAllowBinary)
        {
            lpMem += WriteStringToken (lpMem, 143, 
                PreviewCRDGrid * PreviewCRDGrid * ((LPHOSTCLUT)lpDevCRD)->outputChan);
        }
        else
        {
            lpMem += WriteObject (lpMem, BeginString);
        }
        Input[0] = ((float)i) / (PreviewCRDGrid - 1);
        for (j = 0; j < PreviewCRDGrid; j++)
        {
            Input[1] = ((float)j) / (PreviewCRDGrid - 1);
            for (k = 0; k < PreviewCRDGrid; k++)
            {
                Input[2] = ((float)k) / (PreviewCRDGrid - 1);

                DoHostConversionCRD ((LPHOSTCLUT)lpTargetCRD, NULL, Input, Output, ColorSpace, 1);
                DoHostConversionCSA ((LPHOSTCLUT)lpTargetCSA, Output, Temp);
                DoHostConversionCRD ((LPHOSTCLUT)lpDevCRD, (LPHOSTCLUT)lpTargetCSA, 
                                     Temp, Output, 0, 0);
                for (l = 0; l < ((LPHOSTCLUT)lpDevCRD)->outputChan; l++)
                {
                    if (bAllowBinary)
                    {
                        *lpMem++ = (BYTES)(Output[l]*255);
                    }
                    else
                    {
                        lpMem += WriteHex (lpMem, (USHORT)(Output[l]*255));
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
            }
        }
        if (!bAllowBinary)
            lpMem += WriteObject (lpMem, EndString);
    }
    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteInt (lpMem, ((LPHOSTCLUT)lpDevCRD)->outputChan);

//********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpDevCRD)->outputChan,
        (((LPHOSTCLUT)lpDevCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        TRUE,
        bAllowBinary);


    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndDict); // End dictionary definition
    lpMem += WriteNewLineObject (lpMem, CRDEnd);
    Success = TRUE;

Done:
    *lpcbSize = (DWORD)(lpMem - lpOldMem);

    if (hTargetCRD)
         MemFree(hTargetCRD);
    if (hTargetCSA)
         MemFree(hTargetCSA);
    if (hDevCRD)
         MemFree(hDevCRD);
    return (Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 16

typedef enum { DATA_lut=0, DATA_matrix } DATATYPE;

typedef struct tagHOSTCLUT {
    USHORT         size;
    DATATYPE       dataType;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                    CHANDLE cpDev,
                    CHANDLE cpTarget,
                    DWORD Intent,
                    MEMPTR lpMem,
                    LPDWORD lpcbSize,
                    BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;
typedef     SFLOAT __huge   *PFLOAT;
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;

// SRGB98
#define  REVCURVE_RATIO         1

/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

#define CS_ENABLE       1
#define CS_DISABLE      2
#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "profcrd.h"
#include "icmstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\dll32\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
#endif
//SRGB98
BOOL    EXTERN InvertMatrix (double FAR * lpInMatrix, double FAR * lpOutMatrix);
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);
BOOL   DoesTRCAndColorantTagExist(CHANDLE cp);
BOOL   GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize);
#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\control.c ===
#include "generic.h"

#pragma optimize("",off)

/***************************************************************************
*                               CreateINTENTControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void CreateINTENTControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateINTENTControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingIntent(cp, Intent, NULL, &cbSize);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingIntent(cp, Intent, lpBuffer, &cbSize);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No PS2 Intent created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateCRDControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingDictionary(cp, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingDictionary(cp, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateProfCRDControl(
    LPSTR       DevProfile,
    LPSTR       TargetProfile,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cpDev, cpTar;
    HGLOBAL     hDevCP = 0, hTarCP = 0;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    LoadCP32( (LPCSTR) DevProfile, &hDevCP, (LPCHANDLE) &cpDev);
    LoadCP32( (LPCSTR) TargetProfile, &hTarCP, (LPCHANDLE) &cpTar);

    if (!hDevCP || !hTarCP)
    {
        if (hDevCP)  FreeCP(hDevCP);
        if (hTarCP)  FreeCP(hTarCP);
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hDevCP);
    FreeCP(hTarCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               ColorSpaceControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
ColorSpaceControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       InpDrvClrSp,
    DWORD       Intent,
    WORD        CSAType,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        ColorSpace;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    switch (InpDrvClrSp)
    {
        case 0: break;
        case 1: InpDrvClrSp = icSigGrayData; break;
        case 3: InpDrvClrSp = icSigRgbData; break;
        case 4: InpDrvClrSp = icSigCmykData; break;
        default: InpDrvClrSp = 0; break;
    }

    // Create CieBasedDEF(G) first. if can not, create CieBasedABC.
    if (CSAType == 405)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
    // Create CieBasedABC
    else if (CSAType == 406)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
#if 0
    else if (CSAType == 406)
    {
        Ret = GetPS2CSA_ABC( cp, NULL, &cbSize, InpDrvClrSp, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2CSA_ABC( cp, lpBuffer, &cbSize, InpDrvClrSp, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
    else if ((CSAType == 407) &&
        (GetCPDevSpace(cp, (LPCSIG) &ColorSpace)))
    {
        if (ColorSpace == icSigRgbData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
        else if (ColorSpace == icSigCmykData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            if (ColorSpace == icSigRgbData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
            else if (ColorSpace == icSigCmykData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
#endif
    FreeCP(hCP);
    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    MatrixPQR[]         ;
extern  char _far    RangePQR[]          ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 17

typedef struct tagHOSTCLUT {
    USHORT         size;
    USHORT         wdummy;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                                CHANDLE cpDev,
								CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\dllmain.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dllmain.c
//
//  PURPOSE:  Contains the DLL's entry point function.
//
//  FUNCTIONS:
//    DLLMain   - The entry point function
//

#include <windows.h>


//
//  FUNCTION: DLLMain(HINSTANCE, DWORD, LPVOID)
//
//  PURPOSE:  Called when DLL is loaded by a process, and when new
//    threads are created by a process that has already loaded the
//    DLL.  Also called when threads of a process that has loaded the
//    DLL exit cleanly and when the process itself unloads the DLL.
//
//  PARAMETERS:
//    hDLLInst    - Instance handle of the DLL
//    fdwReason   - Process attach/detach or thread attach/detach
//    lpvReserved - Reserved and not used
//
//  RETURN VALUE:  (Used only when fdwReason == DLL_PROCESS_ATTACH)
//    TRUE  -  Used to signify that the DLL should remain loaded.
//    FALSE -  Used to signify that the DLL should be immediately unloaded.
//
//  COMMENTS:
//
//    If you want to use C runtime libraries, keep this function named
//    "DllMain" and you won't have to do anything special to initialize
//    the runtime libraries.
//
//    When fdwReason == DLL_PROCESS_ATTACH, the return value is used to
//    determine if the DLL should remain loaded, or should be immediately
//    unloaded depending upon whether the DLL could be initialized properly.
//    For all other values of fdwReason, the return value is ignored.
//

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.

            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icSigK007Tag                        0x4B303037   /* 'K007' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "icmstr.h"
#include "profcrd.h"

#define _ICMSEG  ""
#define _ICM2SEG ""
#define  ICMSEG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDD_DIALOG1                     101
#define IDI_ICON1                       102
#define IDC_EDIT1                       1000
#define IDC_BUTTON1                     1001
#define IDC_EDIT2                       1002
#define IDC_EDIT3                       1003
#define IDC_BUTTON2                     1004
#define IDC_BUTTON3                     1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         106
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\main.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


// menu commands

// Find menu
#define IDM_OPENFILE        100
#define IDM_SAVEFILE        101
#define IDM_SAVEFILEAS      102
#define IDM_PRINT           103
#define IDM_EXIT            104

// Options menu
#define IDM_ENTERNEW        200
#define IDM_CHOOSECOLOR     201
#define IDM_CHOOSEFONT      202
#define IDM_FINDTEXT        203
#define IDM_REPLACETEXT     204
#define IDM_STANDARD        205
#define IDM_HOOK            206
#define IDM_CUSTOM          207

// Settings
#define IDM_PERCEPUAL       400
#define IDM_COLOR           401
#define IDM_SATURATION      402
#define IDM_ASCII           403
#define IDM_BINARY          404
#define IDM_AUTO            405
#define IDM_ABC             406
#define IDM_DEFG            407
#define IDM_INP_AUTO        408
#define IDM_INP_GRAY        409
#define IDM_INP_RGB         410
#define IDM_INP_CMYK        411
#define IDM_CSA             412
#define IDM_CRD             413
#define IDM_INTENT          414
#define IDM_PROFCRD         415
// Help menu
#define IDM_ABOUT           300


// Dialog box constants
#define IDEDIT              500

// string constants

#define IDS_DIALOGFAILURE     1
#define IDS_STRUCTSIZE        2
#define IDS_INITIALIZATION    3
#define IDS_NOTEMPLATE        4
#define IDS_NOHINSTANCE       5
#define IDS_LOADSTRFAILURE    6
#define IDS_FINDRESFAILURE    7
#define IDS_LOADRESFAILURE    8
#define IDS_LOCKRESFAILURE    9
#define IDS_MEMALLOCFAILURE  10
#define IDS_MEMLOCKFAILURE   11
#define IDS_NOHOOK           12
#define IDS_SETUPFAILURE     13
#define IDS_PARSEFAILURE     14
#define IDS_RETDEFFAILURE    15
#define IDS_LOADDRVFAILURE   16
#define IDS_GETDEVMODEFAIL   17
#define IDS_INITFAILURE      18
#define IDS_NODEVICES        19
#define IDS_NODEFAULTPRN     20
#define IDS_DNDMMISMATCH     21
#define IDS_CREATEICFAILURE  22
#define IDS_PRINTERNOTFOUND  23
#define IDS_NOFONTS          24
#define IDS_SUBCLASSFAILURE  25
#define IDS_INVALIDFILENAME  26
#define IDS_BUFFERTOOSMALL   27
#define IDS_FILTERSTRING     28
#define IDS_UNKNOWNERROR     29

// constants

#define FILE_LEN            128

// Function prototypes

// procs
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK About(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EnterNew(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileOpenHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileSaveHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FindTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintDlgHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM);

//functions
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
BOOL OpenNewFile( HWND );
BOOL SaveToFile( HWND );
BOOL SaveAs( HWND );
void SearchFile( LPFINDREPLACE );
BOOL ChooseNewFont( HWND );
BOOL ChooseNewColor( HWND );
void PrintFile( HWND );
void CallFindText( HWND );
void CallReplaceText( HWND );
void ProcessCDError(DWORD, HWND);

void    ColorSpaceControl( LPSTR FileName, LPSTR SaveFileName, WORD InpDrvClrSp,
        DWORD Intent, WORD CSAType, BOOL AllowBinary);
void    CreateCRDControl( LPSTR FileName, LPSTR SaveFileName,
        DWORD Inter_Intent, BOOL AllowBinary);
void    CreateINTENTControl(LPSTR FileName, LPSTR SaveFileName, DWORD Inter_Intent);
void    CreateProfCRDControl(LPSTR DevProfile, LPSTR TargetProfile, 
        LPSTR SaveFileName, DWORD Inter_Intent, BOOL AllowBinary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\aug98\test\main.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************************************************************
*
*
*    PROGRAM: CmnDlg.c
*
*    PURPOSE: Sample demonstrating the use of the common dialogs in Windows
*
*    FUNCTIONS:
*
*        WinMain() - calls initialization function, processes message loop
*        InitApplication() - initializes window data and registers window
*        InitInstance() - saves instance handle and creates main window
*        MainWndProc() - processes messages
*        About() - processes messages for "About" dialog box
*        OpenNewFile() - opens a new file
*        SaveToFile() - saves the current text buffer to the current filename
*        SaveAs() - saves the current text buffer to a new file name
*        EnterNew() - to enter new text into the text buffer
*        FileOpenHookProc() - Hook procedure for GetOpenFileName() common dialog
*        FileSaveHookProc() - Hook procedure for GetSaveFileName() common dialog
*        ChooseFontHookProc() - Hook procedure for ChooseFont() common dialog
*        FindTextHookProc() - Hook procedure for FindText() common dialog
*        ReplaceTextHookProc() - Hook procedure for the ReplaceText() common dialog
*        PrintDlgHookProc() - Hook procedure for the PrintDlg() common dialog
*        PrintSetupHookProc() - Hook procedure for the PrintDlg() setup common dialog
*        SearchFile() - Searches for the specified text in the file buffer
*        ChooseNewFont() - chooses a new font for display
*        ChooseNewColor() - chooses a new color for display
*        PrintFile() - prints the current text in the file buffer
*        CallFindText() - calls the FindText() common dialog function
*        CallReplaceText() - calls the ReplaceText() common dialog function
*        ProcessCDError() - uses CommonDialogExtendedError() to output useful error messages
*
*    COMMENTS:
*
*
*        The common dialog APIs demonstrated in the sample include:
*
*            ChooseColor()
*            ChooseFont()
*            FindText()
*            GetOpenFileName()
*            GetSaveFileName()
*            PrintDlg()
*            ReplaceText()
*
*
*        Each dialog box is demonstrated being used in three different ways:
*        standard, using a modified template and using a hook function.
*
*
****************************************************************************/

#include <windows.h>    // includes basic windows functionality
#include <commdlg.h>    // includes common dialog functionality
#include <dlgs.h>       // includes common dialog template defines
#include <stdio.h>      // includes standard file i/o functionality
#include <string.h>     // includes string functions
#include <cderr.h>      // includes the common dialog error codes
#include "main.h"       // includes my common dialog functions
#include "resource.h"

HANDLE       hInst;
OPENFILENAME OpenFileName;
CHAR         szDirName[256]   = "";
CHAR         szFile[256]      = "\0";
CHAR         szFileTitle[256];

// Filter specification for the OPENFILENAME struct
// This is portable for i386 and MIPS
// Leaving out the \0 terminator will cause improper DWORD alignment
// and cause a failure under MIPS
CHAR szFilter[] = "Text Files (*.ICM)\0*.ICM\0All Files (*.*)\0*.*\0";
CHAR szSaveFilter[] = "Text Files (*.CSA)\0*.CSA\0All Files (*.*)\0*.*\0";

CHAR         FileBuf[FILE_LEN];
DWORD        dwFileSize;
UINT         FindReplaceMsg;
CHAR         szFindString[64]   = "";
CHAR         szReplaceString[64]   = "";
FINDREPLACE  frText;
LPFINDREPLACE lpFR;
CHAR *       lpBufPtr = FileBuf;
CHOOSEFONT   chf;
CHOOSECOLOR  chsclr;
COLORREF     crColor;
LOGFONT      lf;
WORD         wMode = IDM_CUSTOM;
WORD         wAsciiMode = IDM_ASCII;
WORD         wIntentMode = IDM_PERCEPUAL;
WORD         wCSAMode = IDM_AUTO;
WORD         wInpDrvClrSp = IDM_INP_AUTO;
WORD         wCSAorCRD = IDM_CSA;
HWND         hDlgFR = NULL;
PRINTDLG     pd;

BOOL         AllowBinary = FALSE;
DWORD        Intent = 0;
HWND         hWnd; 

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam);

/****************************************************************************
*
*    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
*
*    PURPOSE: calls initialization function, processes message loop
*
*    COMMENTS:
*
*
****************************************************************************/

int PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    MSG msg;                         /* message                      */

    if (!hPrevInstance)                  /* Other instances of app running? */
        if (!InitApplication(hInstance)) /* Initialize shared things */
            return (FALSE);              /* Exits if unable to initialize     */

    hInst = hInstance;

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    // register window message for FindText() and ReplaceText() hook procs
    FindReplaceMsg = RegisterWindowMessage( (LPSTR) FINDMSGSTRING );

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,        /* message structure                      */
            NULL,                  /* handle of window receiving the message */
            0,                     /* lowest message to examine              */
            0))                    /* highest message to examine             */
        if ( !hDlgFR || !IsWindow(hDlgFR) || !IsDialogMessage( hDlgFR, &msg ) )
            {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
            }
    return (msg.wParam);           /* Returns the value from PostQuitMessage */

    // avoid compiler warnings at W3
    lpCmdLine;
}


/****************************************************************************
*
*    FUNCTION: InitApplication(HANDLE)
*
*    PURPOSE: Initializes window data and registers window class
*
*    COMMENTS:
*
*        In this function, we initialize a window class by filling out a data
*        structure of type WNDCLASS and calling the Windows RegisterClass()
*        function.
*
****************************************************************************/

BOOL InitApplication(HANDLE hInstance)       /* current instance             */
{
    WNDCLASS  wc;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;                       /* Class style(s).                    */
    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = LoadIcon(NULL, IDI_ICON1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName =  "CmnDlgMenu";   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "CmnDlgWClass"; /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}


/****************************************************************************
*
*    FUNCTION:  InitInstance(HANDLE, int)
*
*    PURPOSE:  Saves instance handle and creates main window
*
*    COMMENTS:
*
*        In this function, we save the instance handle in a static variable and
*        create and display the main program window.
*
****************************************************************************/

BOOL InitInstance(
    HANDLE          hInstance,          /* Current instance identifier.       */
    int             nCmdShow)           /* Param for first ShowWindow() call. */
{
    HWND            hWND;               /* Main window handle.                */

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    hWND = CreateWindow(
        "CmnDlgWClass",                 /* See RegisterClass() call.          */
        "CIEBASED_CDEF Color Space",    /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWND)
        return (FALSE);
     
    hWnd = hWND;
    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */
    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************
*
*    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages
*
*    COMMENTS:
*
*        This function processes all messags sent to the window.  When the
*        user choses one of the options from one of the menus, the command
*        is processed here and passed onto the function for that command.
*        This function also processes the special "FindReplace" message that
*        this application registers for hook processing of the FindText()
*        and ReplaceText() common dialog functions.
*
****************************************************************************/

LRESULT CALLBACK MainWndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    FARPROC lpProcAbout;          /* pointer to the "About" function */
    FARPROC lpProcOpen;
    FARPROC lpProcEnterNew;       /* pointer to the "EnterNew" function */
    HDC hDC;
    PAINTSTRUCT ps;
    INT nDrawX;
    INT nDrawY;
    HFONT hFont;
    HANDLE Handle;
    static BOOL NewFont;

    switch (message) {


        case WM_CREATE:
            //initialize the output on the screen
            strcpy( FileBuf, " ");
            lpBufPtr = FileBuf;
            dwFileSize = strlen(FileBuf);
            crColor = 0;
            NewFont = FALSE;
            break;


        case WM_PAINT:
            /* Set up a display context to begin painting */
            hDC = BeginPaint (hWnd, &ps);

            /* Initialize drawing position to 1/4 inch from the top  */
            /* and from the left of the top, left corner of the      */
            /* client area of the main windows.                      */
            nDrawX = GetDeviceCaps(hDC, LOGPIXELSX) / 4;   /* 1/4 inch */
            nDrawY = GetDeviceCaps(hDC, LOGPIXELSY) / 4;   /* 1/4 inch */

            if ( NewFont == TRUE )
            {
                hFont = CreateFontIndirect( &lf );
                Handle = SelectObject( hDC, hFont );
            }

            SetTextColor( hDC, crColor );

            // end painting and release hDC
            EndPaint( hWnd, &ps );
            break;


        case WM_COMMAND:           /* message: command from application menu */

            switch( LOWORD( wParam ))
            {
                case IDM_OPENFILE:
                   lpProcOpen = MakeProcInstance((FARPROC)OpenFiles, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "OPENFILES",             /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcOpen);    /* About() instance address */

                    FreeProcInstance(lpProcOpen);
                    break;

                case IDM_EXIT:
                    PostQuitMessage(0);
                    break;

                case IDM_CHOOSECOLOR:
                    if (ChooseNewColor( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );
                    break;

                case IDM_CHOOSEFONT:
                    if (NewFont = ChooseNewFont( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );

                    break;

                case IDM_FINDTEXT:
                    CallFindText( hWnd );
                    break;

                case IDM_REPLACETEXT:
                    CallReplaceText( hWnd );
                    break;

                case IDM_STANDARD:
                  // enable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_ENABLED );
                    // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_HOOK:
                case IDM_CUSTOM:
                    // disable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_GRAYED );
                     // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ENTERNEW:
                    lpProcEnterNew = MakeProcInstance((FARPROC)EnterNew, hInst);

                    if (DialogBox(hInst,                 /* current instance         */
                        "EnterNewBox",           /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcEnterNew) == TRUE)

                        InvalidateRect( hWnd, NULL, TRUE );

                    FreeProcInstance(lpProcEnterNew);
                    break;

                case IDM_PERCEPUAL:
                    Intent = 0;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_COLOR:
                    Intent = 1;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_SATURATION:
                    Intent = 2;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ASCII:
                    AllowBinary = FALSE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_BINARY:
                    AllowBinary = TRUE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_AUTO:
                case IDM_ABC:
                case IDM_DEFG:
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_INP_AUTO:
                case IDM_INP_GRAY:
                case IDM_INP_RGB:
                case IDM_INP_CMYK:
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wInpDrvClrSp = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_CSA:
                case IDM_CRD:
				case IDM_PROFCRD:
                case IDM_INTENT:
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAorCRD = LOWORD(wParam);
                    if ((wCSAorCRD == IDM_CRD) || (wCSAorCRD == IDM_INTENT))
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_GRAYED );
                    }
                    else
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_ENABLED );
                    }

                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ABOUT:
                    lpProcAbout = MakeProcInstance((FARPROC)About, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "AboutBox",              /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcAbout);   /* About() instance address */

                    FreeProcInstance(lpProcAbout);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));

            }
            break;

        case WM_DESTROY:                  /* message: window being destroyed */
            PostQuitMessage(0);
            break;


        default:
            // Handle the special findreplace message (FindReplaceMsg) which
            // was registered at initialization time.
            if ( message == FindReplaceMsg )
            {
                if ( lpFR = (LPFINDREPLACE) lParam )
                    {
                    if (lpFR->Flags & FR_DIALOGTERM )  // terminating dialog
                        return (0);
                    SearchFile( lpFR );
                    InvalidateRect( hWnd, NULL, TRUE );
                    }
                return (0);
            }

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


/****************************************************************************
*
*    FUNCTION: EnterNew(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "EnterNew" dialog box
*
*    COMMENTS:
*
*        This function allows the user to enter new text in the current
*        window.  This text is stored in the global current buffer.
*
****************************************************************************/

BOOL CALLBACK EnterNew(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR Buf[FILE_LEN-1];

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, IDEDIT, Buf, FILE_LEN-1);
                strcpy( FileBuf, Buf);
                lpBufPtr = FileBuf;
                dwFileSize = strlen(FileBuf);
                EndDialog( hDlg, TRUE );
                return (TRUE);
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {   /* System menu close command? */
                EndDialog(hDlg, FALSE);       /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}


/****************************************************************************
*
*    FUNCTION: About(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "About" dialog box
*
*    COMMENTS:
*
*       No initialization is needed for this particular dialog box, but TRUE
*       must be returned to Windows.
*
*       Wait for user to click on "Ok" button, then close the dialog box.
*
****************************************************************************/

BOOL WINAPI About(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK          /* "OK" box selected?        */
                || LOWORD(wParam) == IDCANCEL) {        /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}

/****************************************************************************
*
*    FUNCTION: FileOpenHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for GetFileNameOpen() common dialog box
*
*    COMMENTS:
*
*        This function will prompt the user if they are sure they want
*        to open the file if the OFN_ENABLEHOOK flag is set.
*
*        If the current option mode is CUSTOM, the user is allowed to check
*        a box in the dialog prompting them whether or not they would like
*        the file created.  If they check this box, the file is created and
*        the string 'Empty' is written to it.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FileOpenHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    int hFile;
    CHAR szTempText[256];
    CHAR szString[256];
    OFSTRUCT OfStruct;

    switch (message)
    {

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                        sizeof( szTempText ) - 1);

                if ( OpenFileName.Flags & OFN_PATHMUSTEXIST )
                {
                    sprintf( szString, "Are you sure you want to open %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )

                        break;
                    return (TRUE);
                }

                // check to see if the Create File box has been checked
                if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                    BM_GETCHECK, 0, 0L )) == TRUE )
                {
                    // if so, create the file
                    if ((hFile = OpenFile(szTempText,
                        &OfStruct,
                        OF_CREATE)) == -1)
                    {
                        MessageBox( hDlg,
                            "Directory could not be created.",
                            NULL,
                            MB_OK );
                        return (FALSE);
                    }

                    strcpy(FileBuf, "Empty");
                    lpBufPtr = FileBuf;
                    dwFileSize = strlen(FileBuf);
                    if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
                        MessageBox( hDlg, "Error writing file.", NULL, MB_OK );

                    // close the file
                    _lclose( hFile );
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: OpenNewFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to open a file and opens it.
*
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure and calls
*        the GetOpenFileName() common dialog function.  This function will
*        work regardless of the mode: standard, using a hook or using a
*        customized template.
*
*    RETURN VALUES:
*        TRUE - The file was opened successfully and read into the buffer.
*        FALSE - No files were opened.
*
****************************************************************************/
BOOL OpenNewFile( HWND hWnd )
{
   strcpy( szFile, "");
   strcpy( szFileTitle, "");

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.lpstrFile         = szFile;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.lpstrFileTitle    = szFileTitle;
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Open a File";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.icm";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_ENABLEHOOK |
                OFN_HIDEREADONLY | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if (GetOpenFileName(&OpenFileName))
   {
   }
   else
   {
      ProcessCDError(CommDlgExtendedError(), hWnd );
      return FALSE;
   }
   return TRUE;
}

/****************************************************************************
*
*    FUNCTION: SaveToFile( HWND )
*
*    PURPOSE:  Saves the current buffer to the current file.
*
*    COMMENTS:
*
*        This function will save the current text buffer into the file
*        specified from the GetSaveFileName() common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveToFile( HWND hWnd )
{
   int hFile;
   OFSTRUCT OfStruct;
   WORD wStyle;
   CHAR buf[256];

   if (OpenFileName.Flags | OFN_FILEMUSTEXIST)
        wStyle = OF_READWRITE;
   else
        wStyle = OF_READWRITE | OF_CREATE;

   if ((hFile = OpenFile(OpenFileName.lpstrFile, &OfStruct,
         wStyle)) == -1)
   {
      sprintf( buf, "Could not create file %s", OpenFileName.lpstrFile );
      MessageBox( hWnd, buf, NULL, MB_OK );
      return FALSE;
   }
   // write it's contents into a file
   if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
   {
      MessageBox( hWnd, "Error writing file.", NULL, MB_OK );
      return FALSE;
   }

   // close the file
   _lclose( hFile );

   sprintf( buf, "%s", OpenFileName.lpstrFile );
   MessageBox( hWnd, buf, "File Saved", MB_OK );
   return TRUE;
}


/****************************************************************************
*
*    FUNCTION: FileSaveHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for FileSave common dialog box
*
*    COMMENTS:
*
*        This hook procedure prompts the user if they want to save the
*        current file.  If they choose YES, the file is saved and the dialog
*        is dismissed.  If they choose NO, they are returned to the
*        GetSaveFileName() common dialog.
*
*        If the current mode calls for a customized template, this function
*        will test the 'Create File?' checkbox.  If the user choses no, the
*        OFN_FILEMUSTEXIST flag is set.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
*
****************************************************************************/

BOOL CALLBACK FileSaveHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR szTempText[256];
    CHAR szString[256];

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                    sizeof( szTempText ) - 1);
                if ( OpenFileName.Flags & OFN_ENABLETEMPLATE )
                {
                    // check to see if the Create File box has been checked
                    if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                        BM_GETCHECK, 0, 0L )) == FALSE )
                        OpenFileName.Flags |= OFN_FILEMUSTEXIST;
                    break;

                }
                else
                {
                    sprintf( szString, "Are you sure you want to save %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )
                        break;
                    return(TRUE);
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: SaveAs(HWND)
*
*    PURPOSE:  Invokes the common dialog function to save the current
*              buffer to a file.
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure for any
*        mode selected by the user: standard, using a hook or using a
*        customized template.  It then calls the GetSaveFileName()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveAs( HWND hWnd )
{
   int      i;

//   strcpy( szFile, "");
//   strcpy( szFileTitle, "");

   for ( i = lstrlen(OpenFileName.lpstrFileTitle); i > 0; i--)
   {
       if (OpenFileName.lpstrFileTitle[i] == '.') break;
   }
   i ++;
   if (wCSAorCRD == IDM_CSA)
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'S';
        OpenFileName.lpstrFileTitle[i++] = 'A';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else if ((wCSAorCRD == IDM_CRD) ||
	        (wCSAorCRD == IDM_PROFCRD))
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'R';
        OpenFileName.lpstrFileTitle[i++] = 'D';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else
   {
        OpenFileName.lpstrFileTitle[i++] = 'I';
        OpenFileName.lpstrFileTitle[i++] = 'N';
        OpenFileName.lpstrFileTitle[i++] = 'T';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   strcpy(OpenFileName.lpstrFile, OpenFileName.lpstrFileTitle);

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szSaveFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Save File As";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.csa";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = 0L;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)(FARPROC)NULL;
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if ( GetSaveFileName( &OpenFileName ))
   {
        return (TRUE);
   }
   else
   {
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }

   return (FALSE);
}


/****************************************************************************
*
*    FUNCTION: ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseColor common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the color.  if they choose YES, the color of the
*        text will be changed and the dialog will be dismissed.  If they
*        choose NO, the color will not be changed and the user will be
*        returned to the dialog
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseColorHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the color?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewColor(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new color.
*
*    COMMENTS:
*        This function initializes the CHOOSECOLOR structure for any
*        mode the user chooses: standard, using a hook or using a
*        customized template.  It then calls the ChooseColor()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new color was chosen.
*        FALSE - No new color was chosen.
*
****************************************************************************/
BOOL ChooseNewColor( HWND hWnd )
{

    DWORD dwColor;
    DWORD dwCustClrs[16];
    BOOL fSetColor = FALSE;
    int i;


    for (i=0; i < 15; i++)
        dwCustClrs[i] = RGB( 255, 255, 255);

    dwColor = RGB( 0, 0, 0 );

    chsclr.lStructSize = sizeof(CHOOSECOLOR);
    chsclr.hwndOwner = hWnd;
    chsclr.hInstance = (HANDLE)hInst;
    chsclr.rgbResult = dwColor;
    chsclr.lpCustColors = (LPDWORD)dwCustClrs;
    chsclr.lCustData = 0L;

    switch( wMode )
    {
        case IDM_HOOK:
        case IDM_CUSTOM:
            chsclr.Flags = CC_PREVENTFULLOPEN | CC_ENABLEHOOK;
            chsclr.lpfnHook = (LPCCHOOKPROC)MakeProcInstance(ChooseColorHookProc, NULL);
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_STANDARD:
            chsclr.Flags = CC_PREVENTFULLOPEN;
            chsclr.lpfnHook = (LPCCHOOKPROC)(FARPROC)NULL;
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;


   }

   if ( fSetColor = ChooseColor( &chsclr ))
   {
       crColor = chsclr.rgbResult;
       return (TRUE);
   }
   else
   {
       ProcessCDError(CommDlgExtendedError(), hWnd );
       return FALSE;
   }
}


/****************************************************************************
*
*    FUNCTION: ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseFont common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the font.  if they choose YES, the color of the
*        font will be changed and the dialog will be dismissed.  If they
*        choose NO, the font will not be changed and the user will be
*        returned to the dialog
*
*        If the current mode is set to use a customized template, the
*        color drop down combo box is hidden.
*
*    RETURN VALUES:
*        TRUE - Change the font.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseFontHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (chf.Flags & CF_ENABLETEMPLATE)
            {
                ShowWindow(GetDlgItem(hDlg, stc4), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, cmb4), SW_HIDE);
            }
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the font?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewFont(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new font.
*
*    COMMENTS:
*
*        This function initializes the CHOOSEFONT structure for any mode
*        the user chooses: standard, using a hook or using a customized
*        template.  It then calls the ChooseFont() common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new font was chosen.
*        FALSE - No new font was chosen.
*
****************************************************************************/
BOOL ChooseNewFont( HWND hWnd )
{

   HDC hDC;

   hDC = GetDC( hWnd );
   chf.hDC = CreateCompatibleDC( hDC );
   ReleaseDC( hWnd, hDC );
   chf.lStructSize = sizeof(CHOOSEFONT);
   chf.hwndOwner = hWnd;
   chf.lpLogFont = &lf;
   chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
   chf.rgbColors = RGB(0, 255, 255);
   chf.lCustData = 0;
   chf.hInstance = (HANDLE)hInst;
   chf.lpszStyle = (LPSTR)NULL;
   chf.nFontType = SCREEN_FONTTYPE;
   chf.nSizeMin = 0;
   chf.nSizeMax = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
            chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)NULL;
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK |
              CF_ENABLETEMPLATE;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FORMATDLGORD31);
            break;
   }


   if( ChooseFont( &chf ) == FALSE )
   {
        DeleteDC( hDC );
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }


   DeleteDC( hDC );

   return (TRUE);
}

/****************************************************************************
*
*    FUNCTION: PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for PrintDlg setup common dialog box
*
*    COMMENTS:
*
*        This function processes the hook and customized template for the
*        print setup common dialog box.  If the customized template has
*        been provided, the 'Options' pushbutton is hidden.  If the hook only mode
*        is chosen, a message box is displayed informing the user that the
*        hook has been installed.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintSetupHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLESETUPTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, psh1), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}



/****************************************************************************
*
*    FUNCTION: PrintDlgHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for PrintDlg common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to print.  if they choose YES, the text buf will be printed
*        and the dialog will be dismissed.  If they choose NO, the text buf
*        will not be printeded and the user will be returned to the dialog.
*
*        If the current mode is 'custom', the 'Print to file' and 'Collate
*        Copies' options are hidden.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintDlgHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLEPRINTTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to print?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: PrintFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to print.
*
*    COMMENTS:
*
*        This function initializes the PRINTDLG structure for all modes
*        possible: standard, using a hook or using a customized template.
*        When hook mode is chosen, a hook is installed for both the
*        Print dialog and the Print Setup dialog.  When custom mode is
*        chosen, the templates are enabled for both the print dialog and
*        the Print Setup dialog boxes.
*
*        If the PrintDlg() common dialog returns TRUE, the current
*        text buffer is printed out.
*
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void PrintFile( HWND hWnd )
{


    // initialize PRINTDLG structure
    pd.lStructSize = sizeof(PRINTDLG);
    pd.hwndOwner = hWnd;
    pd.hDevMode = (HANDLE)NULL;
    pd.hDevNames = (HANDLE)NULL;
    pd.nFromPage = 0;
    pd.nToPage = 0;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 0;
    pd.hInstance = (HANDLE)hInst;


    switch( wMode )
    {
        case IDM_STANDARD:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)(FARPROC)NULL;
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)(FARPROC)NULL;
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLEPRINTTEMPLATE |
                PD_ENABLESETUPHOOK | PD_ENABLESETUPTEMPLATE | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)MAKEINTRESOURCE(PRNSETUPDLGORD);
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)MAKEINTRESOURCE(PRINTDLGORD);
            break;

    }

    //print a test page if successful
    if (PrintDlg(&pd) == TRUE)
    {
        Escape(pd.hDC, STARTDOC, 8, "Test-Doc", NULL);

        //Print text
        TextOut(pd.hDC, 5, 5, FileBuf, strlen(FileBuf));

        Escape(pd.hDC, NEWFRAME, 0, NULL, NULL);
        Escape(pd.hDC, ENDDOC, 0, NULL, NULL );
        DeleteDC(pd.hDC);
        if (pd.hDevMode)
            GlobalFree(pd.hDevMode);
        if (pd.hDevNames)
            GlobalFree(pd.hDevNames);
    }
   else
        ProcessCDError(CommDlgExtendedError(), hWnd );
}


/****************************************************************************
*
*    FUNCTION: ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ReplaceText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only active.  Otherwise, if template enabled, hides the
*        Replace All pushbutton, plus the 'Match case' and
*        'Match whole word' check box options.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ReplaceTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
                {
                    ShowWindow( GetDlgItem(hDlg, psh2), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}

/****************************************************************************
*
*    FUNCTION: FindTextHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for FindText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only enabled.  If custom template, hides the 'Match case'
*        and 'Match whole word' options, hides the group box 'Direction'
*        with the radio buttons 'Up' and 'Down'.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FindTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
            {
                ShowWindow(GetDlgItem(hDlg, chx1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, chx2), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad2), SW_HIDE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}


/****************************************************************************
*
*    FUNCTION: CallFindText( HWND )
*
*    PURPOSE:  Initializes and calls the FindText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the FindText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallFindText( HWND hWnd )
{

    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = (LPSTR)NULL;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = 0;
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags =  FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                 FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FINDDLGORD);
            break;
    }

    if ((hDlgFR = FindText(&frText)) == NULL)
        ProcessCDError(CommDlgExtendedError(), hWnd );

}


/****************************************************************************
*
*    FUNCTION: CallReplaceText( HWND )
*
*    PURPOSE:  Initializes and calls the ReplaceText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the ReplaceText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallReplaceText( HWND hWnd )
{
    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = szReplaceString;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = sizeof( szReplaceString );
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(REPLACEDLGORD);
            break;
    }

    if ( (hDlgFR = ReplaceText( &frText )) == NULL )
            ProcessCDError(CommDlgExtendedError(), hWnd );

}

/****************************************************************************
*
*    FUNCTION: SearchFile(LPFINDREPLACE)
*
*    PURPOSE:  Does the find/replace specified by the Find/ReplaceText
*        common dialog.
*
*    COMMENTS:
*
*        This function does the lease necessary to implement find and
*        replace by calling existing c-runtime functions.  It is in
*        no way intended to demonstrate either correct or efficient
*        methods for doing textual search or replacement.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void SearchFile( LPFINDREPLACE lpFR )
{

    CHAR Buf[FILE_LEN];
    CHAR *pStr;
    int count, newcount;
    static BOOL bFoundLast = FALSE;
    
if ( lpFR->Flags & ( FR_FINDNEXT | FR_REPLACE | FR_REPLACEALL ) )
    {
    memset(Buf, '\0', FILE_LEN -1);
    if ( bFoundLast )
        {
        if ( (lpBufPtr != FileBuf) && (lpFR->Flags & FR_FINDNEXT) )
            lpBufPtr++;
        bFoundLast = FALSE;
        }

    if (!*lpBufPtr || !(pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) )
        {
        sprintf( Buf, "'%s' not found!", lpFR->lpstrFindWhat );
        lpBufPtr = FileBuf;
        MessageBox( lpFR->hwndOwner, Buf, "No luck", MB_OK | MB_TASKMODAL);
        }
    else
        {
        if ( lpFR->Flags & FR_FINDNEXT )
            {
            sprintf( Buf, "Found Next '%s'!\nSubstring: '%.10s'", 
                     lpFR->lpstrFindWhat, pStr );
            lpBufPtr = pStr;
            bFoundLast = TRUE;
            MessageBox( lpFR->hwndOwner, Buf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACE )
            {
            // replace string specified in the replace with found string
            // copy up to found string into new buffer
            for( count=0; 
                 *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                 count++);
                strncpy( Buf, lpBufPtr, count );
            // concatenate new string
            strcat( Buf, lpFR->lpstrReplaceWith );
            // copy rest of string (less the found string)
            newcount = count + strlen(lpFR->lpstrFindWhat);
            strcat( Buf, lpBufPtr+newcount);
            strcpy( lpBufPtr, Buf );
            lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
            dwFileSize = strlen(FileBuf);
            MessageBox( lpFR->hwndOwner, FileBuf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACEALL)
            {
            do
                {
                // replace string specified in the replace with found string
                // copy up to found string into new buffer
                memset(Buf, '\0', FILE_LEN -1);
                for( count=0; 
                     *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                     count++);
                     strncpy( Buf, lpBufPtr, count );
                // concatenate new string
                strcat( Buf, lpFR->lpstrReplaceWith );
                // copy rest of string (less the found string)
                newcount = count + strlen(lpFR->lpstrFindWhat);
                strcat( Buf, lpBufPtr + newcount);
                strcpy( lpBufPtr, Buf );
                lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
                }
            while ( *lpBufPtr && 
                    (pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) );
            dwFileSize = strlen(FileBuf);
            lpBufPtr = FileBuf;
            MessageBox( lpFR->hwndOwner, FileBuf, 
                        "Success!", MB_OK | MB_TASKMODAL );
            }

        }
    }
}


/****************************************************************************
*
*    FUNCTION: ProcessCDError(DWORD)
*
*    PURPOSE:  Processes errors from the common dialog functions.
*
*    COMMENTS:
*
*        This function is called whenever a common dialog function
*        fails.  The CommonDialogExtendedError() value is passed to
*        the function which maps the error value to a string table.
*        The string is loaded and displayed for the user.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
   WORD  wStringID;
   CHAR  buf[256];

   switch(dwErrorCode)
      {
         case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break;
         case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break;
         case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break;
         case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break;
         case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break;
         case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break;
         case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break;
         case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break;
         case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break;
         case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break;
         case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break;
         case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break;
         case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break;
         case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break;
         case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break;
         case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break;
         case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break;
         case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break;
         case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break;
         case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break;
         case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break;
         case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break;
         case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break;
         case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break;
         case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break;
         case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break;
         case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break;

         case 0:   //User may have hit CANCEL or we got a *very* random error
            return;

         default:
            wStringID=IDS_UNKNOWNERROR;
      }

   LoadString(NULL, wStringID, buf, sizeof(buf));
   MessageBox(hWnd, buf, NULL, MB_OK);
   return;
}

/***********************************************************************/

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    int    Length;
    char   DevProfileName[FILE_LEN];
    char   TargetProfileName[FILE_LEN];
    char   OutputFileName[FILE_LEN];
    WORD   InpClrSp;

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: 
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile)); 
                    break;
                case IDC_BUTTON2:
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT2, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDC_BUTTON3:
                    if ( SaveAs( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT3, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDOK:
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXT, Length + 1, (long)(DevProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXT, Length + 1, (long)(TargetProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXT, Length + 1, (long)(OutputFileName));
                    switch (wInpDrvClrSp)
                    {
                        case IDM_INP_AUTO: InpClrSp = 0; break;
                        case IDM_INP_GRAY: InpClrSp = 1; break;
                        case IDM_INP_RGB:  InpClrSp = 3; break;
                        case IDM_INP_CMYK: InpClrSp = 4; break;
                        default: InpClrSp = 0; break;
                    }
                    if (wCSAorCRD == IDM_CSA)
                    {
                        ColorSpaceControl(DevProfileName, OutputFileName,
                            InpClrSp, Intent, wCSAMode, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_CRD)
                    {
                        CreateCRDControl(DevProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_PROFCRD)
                    {
                        CreateProfCRDControl(DevProfileName, 
                            TargetProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else 
                    {
                        CreateINTENTControl(DevProfileName, OutputFileName, Intent);
                    }

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                    return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
#endif
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);

#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\csprof.c ===
#include "generic.h"

//#pragma code_seg(_ICM2SEG)
#pragma optimize("",off)

#define TempBfSize 128
#define LINELENG   128

static  char    NewLine[]       = "\n" ;
static  char    ASCII85DecodeBegine[] = "<~";
static  char    ASCII85DecodeEnd[] = "~> cvx exec ";

//******************************************************************
//   Local functions to deal with output to the memory buffer

static  SINT    CPLastError;

BOOL    EXTERN     SetCPLastError(SINT LastError)
{
    CPLastError = LastError;
    return(TRUE);
}

SINT    EXTERN     GetCPLastError()
{
    return(CPLastError);
}

BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH)
{
    HGLOBAL hMem;
    LPVOID  lpMem;

    *hMemory = 0;
    if(lpMH == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hMem = GlobalAlloc(GHND, Size) ;
    if(hMem == 0 )
    {
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }

    lpMem = GlobalLock(hMem);
    if(lpMem == NULL )
    {
        GlobalFree(hMem);
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }
    *lpMH = (MEMPTR)lpMem ;
    *hMemory = hMem;
    return (TRUE);
}

BOOL    EXTERN MemFree(HGLOBAL hMem)
{
    if(hMem == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    GlobalUnlock(hMem);
    GlobalFree(hMem) ;
    return(TRUE);
}

//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    OFSTRUCT    OFStruct;

    *phMem = 0;
    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hFile = OpenFile(filename, &OFStruct, OF_READ );
    if( hFile == HFILE_ERROR )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }
 
    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    if( (Res == HFILE_ERROR) ||
        (Res != sizeof(CPHeader)) )
    {
        _close(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        _close(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
         _lseek(hFile, 0L, SEEK_SET);

        while(CPSize)
        {
            Res = _lread(hFile, (LPVOID) mpCP, 4096);
            if (Res == HFILE_ERROR) 
            {
                _close(hFile);
                SetCPLastError(CP_FILE_READ_ERR);
                return(FALSE);
            }
            mpCP    += Res;
            CPSize  -= Res;
        }
    }else
    {
        *phMem = 0;
        _close(hFile);
        return(FALSE);
    }
    _close(hFile);
    return (TRUE);
}

#ifdef ICMDLL
//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HANDLE      hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    BOOL        Success;

    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    hFile = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }

    Success = ReadFile(hFile, (LPVOID) &CPHeader, sizeof(CPHeader), &Res, NULL);
    if( ( !Success ) || (Res != sizeof(CPHeader)) )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
        SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        Success = ReadFile(hFile, (LPVOID) (LPVOID)mpCP, CPSize, &Res, NULL);
        if (!Success) 
        {
            CloseHandle(hFile);
            SetCPLastError(CP_FILE_READ_ERR);
            return(FALSE);
        }
    }else
    {
        CloseHandle(hFile);
        return(FALSE);
    }
    CloseHandle(hFile);
    return (TRUE);
}
#endif

BOOL    EXTERN FreeCP(HGLOBAL hMem)
{
    return( MemFree(hMem) );
}


BOOL    EXTERN GetCPElementCount(CHANDLE CP, LPSINT lpCount)
{
    lpcpTagList lpTL;
    if (lpCount == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    *lpCount = ui32toSINT(lpTL->count);
    return(TRUE);
}


BOOL    EXTERN GetCPElementInfo(CHANDLE CP, SINT Index,
                                LPMEMPTR lpTagData, LPMEMPTR lpElemData)
{
    SINT    Count;
    lpcpTagList lpTL;

    if ( (lpTagData == NULL) || (lpElemData == NULL) )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    if ( Count <= Index )
    {
        SetCPLastError(CP_OUT_OF_RANGE_ERR);
        return(FALSE);
    }
    *lpTagData      = ((MEMPTR) &(lpTL->tags[0])) + (Index * sizeof(icTag)) ;
    *lpElemData     = ((MEMPTR) CP) +
                                ui32toSINT( ((lpcpTag)*lpTagData)->offset);
    return(TRUE);
}


/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE CP)
{
    BOOL    Result;
    CSIG    ProfileClass;

    if(GetCPClass(CP, (LPCSIG) &ProfileClass) )
    {
        // All profiles must have a ProfileDescription and
        //  a Copyright  tags.

        if( !DoesCPTagExist(CP, icSigProfileDescriptionTag) || 
            !DoesCPTagExist(CP, icSigCopyrightTag ) )
        {
            SetCPLastError(CP_NOT_FOUND_ERR);
            return(FALSE);
        }

        // All profiles, except Device-link, must have a mediaWhitePoint Tag
        switch( ProfileClass )
        {
            case     icSigLinkClass :        /* 'link' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigProfileSequenceDescTag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                break;

            case     icSigInputClass:       /* 'scnr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) ||
                    DoesCPTagExist(CP, icSigAToB0Tag)      )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigDisplayClass:     /* 'mntr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigOutputClass:      /* 'prtr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                          DoesCPTagExist(CP, icSigAToB1Tag) &&
                          DoesCPTagExist(CP, icSigAToB2Tag) &&
                          DoesCPTagExist(CP, icSigBToA0Tag) &&
                          DoesCPTagExist(CP, icSigBToA1Tag) &&
                          DoesCPTagExist(CP, icSigBToA2Tag) &&
                          DoesCPTagExist(CP, icSigGamutTag) 
                        )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigAbstractClass:    /* 'abst' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigColorSpaceClass:  /* 'spac' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigBToA0Tag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            default:
                Result = FALSE;
                break;
        }
    }else
    {
        return(FALSE);
    }
    if( Result == FALSE )
    {
        SetCPLastError(CP_NOT_FOUND_ERR);
    }
    return(Result);
}

BOOL    EXTERN DoesCPTagExist(CHANDLE CP, CSIG CPTag)
{
    SINT    Count;
    MEMPTR   Data;
    lpcpTagList lpTL;

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ; 
    while ( Count-- )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }
    return(FALSE);
}


BOOL    EXTERN GetCPTagIndex(CHANDLE CP, CSIG CPTag, LPSINT lpIndex)
{
    SINT    Count;
    MEMPTR   Data;
    SINT    i;
    lpcpTagList lpTL;

    if (lpIndex == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ;

    for (i = 0; i < Count; i++ )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            *lpIndex = i;
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }

    SetCPLastError(CP_NOT_FOUND_ERR);
    return(FALSE);
}



BOOL    EXTERN GetCPTagSig(CHANDLE CP, SINT Index, LPCSIG lpCPTag)
{
    MEMPTR   TagData, ElemData;
    if (lpCPTag == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCPTag    = SigtoCSIG( ((lpcpTag)TagData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}

//***************************************************************
//      Function applicable to the elements
//
//***************************************************************

BOOL    EXTERN GetCPElementType(CHANDLE CP, SINT Index, LPCSIG lpCSig)
{
    MEMPTR   TagData, ElemData;
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCSig    = SigtoCSIG( ((lpcpTagBase)ElemData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}



BOOL    EXTERN GetCPElementSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR   TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size );
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL    EXTERN GetCPElementDataSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR  TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
//  Changed by jjia 8/24/95
//        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size ) -
//                                             sizeof(lpcpTagBase);
    *lpSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

//***************************************************************
//  The difference between GetCPElement and GetCPElementData
//  is that GetCPElement reads all fields of the element,
//  including the data tag, reserved fields and element data,
//  while GetCPElementData only reads the actual data.
//  Number of bytes that are required to hold the whole data element can be
//  obtained by calling the function GetCPElementSize().
//  The actulal number of data bytes is determined by
//  the call to GetCPElementDataSize().
//***************************************************************
BOOL    EXTERN GetCPElement(CHANDLE CP, SINT Index,
                               MEMPTR lpData, SINT Size)
{
    SINT        ElemSize;
    MEMPTR      TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size);
    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }
    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);

}


BOOL    EXTERN GetCPElementData(CHANDLE CP, SINT Index,
                                MEMPTR lpData, SINT Size)
{
    SINT     ElemSize;
    MEMPTR   TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
//  Changed by jjia 8/24/95
//    ElemData    +=  sizeof(lpcpTagBase);
//    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
//                     sizeof(lpcpTagBase);
    ElemData    +=  sizeof(icTagBase) + sizeof(icUInt32Number);
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);

    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }

    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);
}

// Check the data format is binary or ascii    8/22/95  jjia

BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType)
{
    MEMPTR   TagData, ElemData;

    if (lpDataType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemData    +=  sizeof(icTagBase);
    *lpDataType = ui32toSINT( ((icData __huge *)ElemData)->dataFlag);
    return (TRUE);
}

BOOL    EXTERN ValidateCPElement(CHANDLE CP, SINT Index)
{
    CSIG    TagSig, DataSig;
    BOOL    Result;
    if( GetCPTagSig(CP, Index, (LPCSIG) &TagSig) &&
        GetCPElementType(CP, Index, (LPCSIG) &DataSig) )
    {
        switch(TagSig)
        {
            case     icSigAToB0Tag:
            case     icSigAToB1Tag:
            case     icSigAToB2Tag:
            case     icSigBToA0Tag:
            case     icSigBToA1Tag:
            case     icSigBToA2Tag:
            case     icSigGamutTag:
            case     icSigPreview0Tag:
            case     icSigPreview1Tag:
            case     icSigPreview2Tag:
                Result = (DataSig == icSigLut16Type) ||
                         (DataSig == icSigLut8Type) ;
                break;

            case     icSigRedColorantTag: 
            case     icSigGreenColorantTag:
            case     icSigBlueColorantTag:
            case     icSigLuminanceTag:
            case     icSigMediaBlackPointTag:
            case     icSigMediaWhitePointTag:
                Result = (DataSig == icSigXYZType);
                break;

            case     icSigRedTRCTag:
            case     icSigGreenTRCTag:
            case     icSigBlueTRCTag:
            case     icSigGrayTRCTag:
                Result = (DataSig == icSigCurveType);
                break;

            case     icSigPs2CRD0Tag:
            case     icSigPs2CRD1Tag:
            case     icSigPs2CRD2Tag:
            case     icSigPs2CRD3Tag:
            case     icSigPs2CSATag:
            case     icSigPs2Intent0Tag:
            case     icSigPs2Intent1Tag:
            case     icSigPs2Intent2Tag:
            case     icSigPs2Intent3Tag:
                Result = (DataSig == icSigDataType);
                break;

            case     icSigCharTargetTag:
            case     icSigCopyrightTag:
                Result = (DataSig == icSigTextType);
                break;

            case     icSigCalibrationDateTimeTag:
                Result = (DataSig == icSigDateTimeType);
                break;

            case     icSigDeviceMfgDescTag:
            case     icSigDeviceModelDescTag:
            case     icSigProfileDescriptionTag:
            case     icSigScreeningDescTag:
            case     icSigViewingCondDescTag:
                Result = (DataSig == icSigTextDescriptionType);
                break;

            case     icSigMeasurementTag:
                Result = (DataSig == icSigMeasurementTag);
                break;

            case     icSigNamedColorTag:
                Result = (DataSig == icSigNamedColorTag);
                break;
        
            case      icSigProfileSequenceDescTag:
                Result = (DataSig == icSigProfileSequenceDescTag);
                break;

            case     icSigScreeningTag:
                Result = (DataSig == icSigScreeningTag);
                break;

            case     icSigTechnologyTag:
                Result = (DataSig == icSigSignatureType);
                break;

            case     icSigUcrBgTag:
                Result = (DataSig == icSigUcrBgTag);
                break;

            case     icSigViewingConditionsTag:
                Result = (DataSig == icSigViewingConditionsTag);
                break;

            default:
                Result = TRUE;
                break;
        }
    }else
    {
        Result = FALSE;
    }
    return(Result);
}

//******************************************************************
// Functions that get all information from the Color Profile Header
//******************************************************************
BOOL    EXTERN GetCPSize(CHANDLE CP, LPSINT lpSize)
{
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpSize    = ui32toSINT( ((lpcpHeader)CP)->size);
    return(TRUE);
}

BOOL    EXTERN GetCPCMMType(CHANDLE CP, LPCSIG lpType)
{
    if (lpType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpType    = SigtoCSIG( ((lpcpHeader)CP)->cmmId);
    return(TRUE);
}

BOOL    EXTERN GetCPVersion(CHANDLE CP, LPSINT lpVers)
{
    if (lpVers == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpVers    = ui32toSINT( ((lpcpHeader)CP)->version);
    return(TRUE);
}

BOOL    EXTERN GetCPClass(CHANDLE CP, LPCSIG lpClass)
{
    if (lpClass == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpClass    = SigtoCSIG( ((lpcpHeader)CP)->deviceClass);
    return(TRUE);
}

BOOL    EXTERN GetCPDevSpace(CHANDLE CP, LPCSIG lpInSpace)
{
    if (lpInSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpInSpace    = SigtoCSIG( ((lpcpHeader)CP)->colorSpace);
    return(TRUE);
}

BOOL    EXTERN GetCPConnSpace(CHANDLE CP, LPCSIG lpOutSpace)
{
    if (lpOutSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpOutSpace    = SigtoCSIG( ((lpcpHeader)CP)->pcs);
    return(TRUE);
}

BOOL    EXTERN GetCPTarget(CHANDLE CP, LPCSIG lpTarget)
{
    if (lpTarget == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpTarget    = SigtoCSIG( ((lpcpHeader)CP)->platform);
    return(TRUE);
}

BOOL    EXTERN GetCPManufacturer(CHANDLE CP, LPCSIG lpManuf)
{
    if (lpManuf == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpManuf    = SigtoCSIG( ((lpcpHeader)CP)->manufacturer);
    return(TRUE);
}

BOOL    EXTERN GetCPModel(CHANDLE CP, LPCSIG lpModel)
{
    if (lpModel == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpModel    = SigtoCSIG( ((lpcpHeader)CP)->model);
    return(TRUE);
}

BOOL    EXTERN GetCPFlags(CHANDLE CP, LPSINT lpFlags)
{
    if (lpFlags == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpFlags    = ui32toSINT( ((lpcpHeader)CP)->flags);
    return(TRUE);
}

BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent)
{
    if (lpIntent == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpIntent    = ui32toSINT( ((lpcpHeader)CP)->renderingIntent);
    return(TRUE);
}

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP)
{
    if (lpWP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpWP[0]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.X);
    lpWP[1]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Y);
    lpWP[2]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Z);
    return(TRUE);
}

BOOL    EXTERN GetCPAttributes(CHANDLE CP, LPATTRIB lpAttributes)
{
    return(TRUE);
}

BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE cp,  LPSFLOAT lpMediaWP)
{
    HGLOBAL   hTempMem;
    SINT      TempSize;
    MEMPTR    TempBuff;
    MEMPTR    lpTable;
    SINT      i, Index;

    if (DoesCPTagExist (cp, icSigMediaWhitePointTag) &&
        GetCPTagIndex (cp, icSigMediaWhitePointTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & TempSize) &&
        MemAlloc (TempSize, (HGLOBAL *) & hTempMem, (LPMEMPTR) & TempBuff) &&
        GetCPElement (cp, Index, TempBuff, TempSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) TempBuff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMediaWP[i] = (SFLOAT) si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hTempMem);
        return (TRUE);
    }
    return (FALSE);
}

/***************************************************************************
*                               GetPS2ColorRenderingIntent
*  function:
*    this is the function which creates the Intent string 
*    from the data supplied in the Profile that can be used
*    in --findcolorrendering-- operator.
*  prototype:
*       BOOL EXTERN GetPS2ColorRenderingIntent(
*                          char         *FileName,
*                          DWORD        Intent, 
*                          MEMPTR       lpMem,
*                          LPDWORD      lpcbSize )
*  parameters:
*       FileName    --  Color Profile Filename
*       Intent      --  Intent 
*       lpMem       --  Pointer to the memory block
*       lpcbSize        --  Size of the memory block
*                       Returns number of bytes required/transferred
*  returns:
*       BOOL        --  TRUE   if the function was successful,
*                       FALSE  otherwise.
***************************************************************************/
BOOL EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
                                       MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT       Index;
    SINT       Size;
        
    if (!cp)
        return FALSE;

    Size = (SINT) *lpcbSize;
    if( ( lpMem == NULL ) || ( Size == 0 ) )
    {
        lpMem = NULL;
        Size = 0;
        *lpcbSize = 0;
    }
        
    switch(Intent)
    {
        case icPerceptual:
        if( DoesCPTagExist(cp, icSigPs2Intent0Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent0Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        
        case icRelativeColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent1Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent1Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
    
        case icSaturation:
        if( DoesCPTagExist(cp, icSigPs2Intent2Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent2Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size ) )
          )
        {
        }
        break;
        case icAbsoluteColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent3Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent3Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        default:
            Size = 0 ;
        break;
    }
        
    if (Size != 0)
    {
        if (lpMem)
        {
            lpMem[Size] = '\0';
        }
        Size ++;
        *lpcbSize = (DWORD) Size;
        return (TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/***************************************************************************
*
*  Function to check if color matching mathod and icc profile type is 
*       supported by driver.
*  parameters:
*
*  returns:
*       BOOL:   TRUE or FALSE.
*
***************************************************************************/

#ifndef ICMDLL
BOOL EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI)
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res;
    CSIG        CPColorSpaceTag;

    if (NULL == lpICMI)
    {
        return(FALSE);
    }
    hFile = _lopen(lpICMI->lcsDestFilename, READ);
    if( hFile == HFILE_ERROR )
    {
        return(FALSE);
    }

    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    _lclose(hFile);
    if( (Res == HFILE_ERROR) || (Res != sizeof(CPHeader)) )
    {
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        return(FALSE);
    }
    // Make sure the profile is 'prtr'
    if( SigtoCSIG(CPHeader.deviceClass) != icSigOutputClass )
    {
        return(FALSE);
    }
    CPColorSpaceTag = SigtoCSIG(CPHeader.colorSpace);

    switch ( lppd->lpPSExtDevmode->dm.iColorMatchingMethod )
    {
        case COLOR_MATCHING_ON_HOST:
            if ((CPColorSpaceTag == icSigCmyData) ||
                (CPColorSpaceTag == icSigRgbData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
            case COLOR_MATCHING_ON_PRINTER:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
        case COLOR_MATCHING_PRINTER_CALIBRATION:
        default:
            break;
    }
    return (TRUE);
}
#endif

//***************************************************************************
//
//      Set of functions to output data into memory buffer
//
//***************************************************************************


/***************************************************************************
*
*   Function to put the chunk of memory as string of Hex
*
***************************************************************************/
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    MEMPTR  lpOldPtr = lpMem;

    for ( ; dwBytes ; dwBytes-- )
    {
        Res = wsprintf( (MEMPTR)TempArray, (LPSTR) "%2.2x", *lpBuff );
        *lpMem++ = TempArray[0];
        *lpMem++ = TempArray[1];
        lpBuff++;
        if (((SINT)(lpMem - lpLineStart)) > MAX_LINELENG)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject(lpMem,  NewLine);
        }
    }
    return( (SINT)(lpMem - lpOldPtr)); 
}

/***************************************************************************
*
*   Function to put the string into the buffer
*
***************************************************************************/
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res;

    Res = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res);
    return( Res );
}

SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n)
{
    MemCopy(lpMem, Obj, n);
    return( n );
}
/***************************************************************************
*
*   Function to write the integer into the buffer
*
***************************************************************************/
SINT WriteInt(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    
    Res = wsprintf( (MEMPTR)TempArray, "%lu ", Number );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the integer into the buffer as hex
*
***************************************************************************/
SINT WriteHex(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];

    Res = wsprintf( TempArray, "%2.2x", (int)(Number & 0x00FF) );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the float into the buffer
*
***************************************************************************/

SINT WriteFloat(MEMPTR lpMem, double dFloat)
{
    char    cSign;
    double  dInt ;
    double  dFract ;
    LONG    lFloat ;
    SINT    Res;
    char    TempArray[TempBfSize];

    lFloat = (LONG) floor( dFloat * 10000.0 + 0.5);

    dFloat = lFloat  / 10000.0 ;

    dInt = floor(fabs(dFloat));
    dFract =  fabs(dFloat) - dInt ;

    cSign   = ' ' ;
    if ( dFloat < 0 )
    {
        cSign   = '-' ;
    }

    Res = wsprintf( (LPSTR) TempArray, (LPSTR) "%c%d.%0.4lu ",
       cSign, (WORD) dInt , (DWORD) (dFract *10000.0)  );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return ( Res );
}

/***************************************************************************
*
*   Function to write the string token into the buffer
*
***************************************************************************/

SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (3);
}

/***************************************************************************
*
*   Function to write the Homogeneous Number Array token into the buffer
*
***************************************************************************/

SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = 32;       // 16-bit fixed integer, high-order byte first
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (4);
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. High byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = ui16toSINT( lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. Low-order byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = (SINT)*((PUSHORT)lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

    for (i = 0; i < sBytes; i ++)
        *lpMem++ = *lpBuff++;
    
    return(sBytes); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

       for( i = 0; i < sBytes ; i++)
    {
        *lpMem++ = (BYTE)(ui16toSINT( lpBuff)/256) ;
        lpBuff += sizeof(icUInt16Number);
    }
    return(sBytes); 
}

/***************************************************************************
*
*  Function to control ascii85 encoding.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       BufSize     --  Size of encording result buffer. 
*       lpSource    --  Pointer to the input buffer
*       DataSize    --  Size of the input buffer
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
****************************************************************************/

SINT    WriteASCII85Cont(MEMPTR lpDest, SINT BufSize, MEMPTR lpSource, SINT DataSize)
{
   SINT     incount;
   MEMPTR   lpPtr, lpSave;
   SINT     rem;
   SINT     bcount;
   SINT     dex;
   unsigned long word;
   
   /* encode the initial 4-tuples */
   lpSave = lpDest;
   lpPtr  = lpSource;
   word   = 0UL;
   bcount = 0;

   for (incount = 0; incount < DataSize; incount ++)
   {
      if ( incount  && ((incount % LINELENG) == 0) )
      lpDest += WriteObject(lpDest,  NewLine);
      word = (word<<8);
      word |= (BYTE)*lpPtr++;
      if (bcount == 3)
      {
         lpDest += WriteAscii85(lpDest, word, 5);
         word = 0UL;
         bcount = 0;
      }
      else
      {
         bcount ++;
      }
   }
   
   /* now do the last partial 4-tuple -- if there is one */
   /* see the Red Book spec for the rules on how this is done */
   if (bcount > 0)
   {
      rem = 4 - bcount;  /* count the remaining bytes */
      for (dex = 0; dex < rem; dex ++) /* shift left for each of them */
      {
         word = (word<<8);      /* (equivalent to adding in ZERO's)*/
         word |= (BYTE)32;
      }
//      lpDest += WriteAscii85(lpDest, word, (bcount + 1));  /* output only meaningful
      lpDest += WriteAscii85(lpDest, word, 5);               /* output only meaningful bytes + 1 */
   }
   return (lpDest - lpSave);
}

/************************************************************************
*
*  Function to convert 4 bytes binary data to 5 bytes ascii85 encorded data.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       inWord      --  Input word (4-bytes) 
*       nBytes      --  Number of bytes should be outputed.
*  returns:
*       SINT        --  Number of bytes actually outputed.
* 
*************************************************************************/

SINT    WriteAscii85(MEMPTR lpDest, unsigned long inWord, SINT nBytes)
{
    unsigned long divisor;
    int      bcount;
    BYTE     outchar;
    MEMPTR   lpSave = lpDest;

    if ((inWord == 0UL) && (nBytes == 5))
        *lpDest++ = 'z';
    else
    {
        divisor = 52200625UL;
        for (bcount = 0; bcount < nBytes; bcount ++)
        { 
            outchar = (BYTE)((int)(inWord/divisor) + (int)'!');
            *lpDest++ = outchar;
            if (bcount < 4)
            {
                inWord = (inWord % divisor);
                divisor =(divisor / 85);
            }
        }
    }
    return (SINT)(lpDest - lpSave);
}

/***************************************************************************
*
*  Function to convert binary data to ascii by performing ASCII85 encording
*  parameters:
*       lpMem       --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       DataSize    --  The size of input binary data. 
*       BufSize     --  The size of buffer pointed by lpMem.
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
***************************************************************************/

SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize)
{
    MEMPTR      intrbuf, Temp;
    HANDLE      intrhandle;
    SINT        AsciiDataSize = 0;

    if (BufSize >= (SINT)(DataSize/4*5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048))
    {
        if ((intrhandle = GlobalAlloc(GHND, BufSize)) != NULL)
        {
            if ((intrbuf = (MEMPTR) GlobalLock(intrhandle)) != NULL)
            {
                Temp = intrbuf;
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteObject(Temp,  ASCII85DecodeBegine);
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteASCII85Cont(Temp, BufSize, lpMem, DataSize);
                Temp += WriteObject(Temp,  ASCII85DecodeEnd);
                AsciiDataSize = (SINT)(Temp - intrbuf);
                lstrcpyn(lpMem, intrbuf, (WORD)AsciiDataSize); 
                GlobalUnlock(intrhandle);
            }
        }
        GlobalFree(intrhandle);
   }
   return (AsciiDataSize);
}

/***************************************************************************
*
*  Function to check if it is need to convert a CRD from binary to ascii
*  parameters:
*       CP          --  Handle of memory block which contains icm profile.
*       Index       --  Index of the element data of the profile.
*       lpData      --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       BufSize     --  The size of the buffer pointed by lpData.
*       DataSize    --  The size of input binary data.
*       AllowBinary --  Allow binary or not(1/0).
*  returns:
*       SINT        --  Number of bytes required/actually outputed.
*
***************************************************************************/

SINT    Convert2Ascii(CHANDLE CP, SINT Index,
                      MEMPTR lpData, SINT BufSize, 
                      SINT DataSize, BOOL AllowBinary)
{
    long    DataType;

    GetCPElementDataType(CP, Index, &DataType);
    if (BufSize == 0)
    {
        if (AllowBinary)
            return (DataSize);
        else if (DataType == 0)    // Ascii data in Profile 
            return (DataSize);
        else                       // Keep space for ascii85 encoding.
            return (DataSize / 4 * 5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048);
    }
    else
    {
        if (AllowBinary)
            return (DataSize);
        else if(DataType == 0) 
            return (DataSize);
        else 
            return (ConvertBinaryData2Ascii(lpData, DataSize, BufSize) );
    }
}

#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length)
{
    SINT    i;

    for (i = 0; i < Length; i++)
    {
        Dest[i] = Source[i];
    }
    return( Length );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\getcsa.c ===
#include "generic.h"
#include "icmstr.h"

//#pragma code_seg(_ICMSEG)

static char  *DecodeABCLab[] = {"50 mul 16 add 116 div ", 
                               "128 mul 128 sub 500 div", 
                               "128 mul 128 sub 200 div"};

#pragma optimize("",off)

/**************************************************************************/

SINT CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag);
static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);
static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);

/***************************************************************************
*                           GetDevideRGB
*  function:
*    this is the function which creates the DeviceRGB ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceRGB(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetDeviceRGB (
              MEMPTR lpMem,
              LPDWORD lpcbSize,
              DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
        return FALSE;

    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceRGBTag) + 8;
        return (TRUE);
    }
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DeviceRGBTag);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetDevideCMYK
*  function:
*    this is the function which creates the DeviceCMYK ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceCMYK(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetDeviceCMYK (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigCmykData) &&
        (InpDrvClrSp != 0))
        return FALSE;
    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceCMYKTag) + 8;
        return (TRUE);
    }
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DeviceCMYKTag);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);

}
/***************************************************************************
*                           GetDeviceGray
***************************************************************************/

static BOOL
GetDeviceGray (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceRGBTag) + 8;
            return (TRUE);
        }
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, DeviceRGBTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceGrayTag) + 8;
            return (TRUE);
        }
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, DeviceGrayTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    }
}
/***************************************************************************
*                           GetPublicArrayName
***************************************************************************/

SINT
GetPublicArrayName (CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName)
{
    MEMPTR OldPtr;
    OldPtr = PublicArrayName;
    PublicArrayName[0] = 0;
    MemCopy (PublicArrayName, (MEMPTR) & IntentSig, sizeof (CSIG));
    PublicArrayName += sizeof (CSIG);
    PublicArrayName[0] = 0;
    return (PublicArrayName - OldPtr);
}

static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
                    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    SINT   i;
    MEMPTR lpOldMem = lpMem;

 //********** /BlackPoint
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

 //********** /WhitePoint
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (Intent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
                       LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }
}

SINT  EnableGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, GlobalDictOp);
    lpMem += WriteObject (lpMem, BeginOp);

    lpMem += WriteObject (lpMem, CurrentGlobalOp);
    lpMem += WriteObject (lpMem, TrueOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    return (lpMem - lpOldMem);
}

/***************************************************************************
*                           GetPS2CSA_DEFG
*  function:
*    this is the function which creates the CIEBasedDEF(G) ColorSpace (CS)
*    from the data supplied in the RGB or CMYK Input Profile.
*  prototype:
*       GetPS2CSA_DEFG(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       int         Type
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Type        --  CieBasedDEF or CieBasedDEFG.
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_DEFG (
                CHANDLE cp,
                MEMPTR lpMem,
                LPDWORD lpcbSize,
                CSIG InputIntent,
                SINT Index,
                int Type,
                BOOL AllowBinary)
{
    CSIG PCS, LutTag;
    CSIG IntentSig;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    SINT nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    SINT i, j, k;
    MEMPTR lpTable;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpLut = NULL;
    MEMPTR lpLineStart;
    HGLOBAL hLut = 0;
    SINT LutSize;
    char PublicArrayName[TempBfSize];
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);

 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    if (lpMem == NULL)                  // This is a size request
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids * 2;  // LUT HEX bytes
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * 2;   // LUT HEX bytes

        *lpcbSize = *lpcbSize +
            nInputCh * nInputTable * 6 +
            nOutputCh * nOutputTable * 6 +  // Number of INT bytes
            nInputCh * (lstrlen (IndexArray) +
                        lstrlen (StartClip) +
                        lstrlen (EndClip)) +
            nOutputCh * (lstrlen (IndexArray) +
                         lstrlen (StartClip) +
                         lstrlen (EndClip)) +
            4096;                       // + other PS stuff


        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Testing CieBasedDEFG support
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, TestingDEFG);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SupportDEFG_S);

 //*********** Creating global data
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    lpMem += WriteObject (lpMem, NewLine);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CieBasedDEFGBegin);
    else
        lpMem += WriteObject (lpMem, CieBasedDEFBegin);

    lpMem += EnableGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    lpMem += WriteObject (lpMem, EndOp);

 //*********** Start creating the ColorSpace
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedDEF(G)
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CIEBasedDEFGTag);
    else
        lpMem += WriteObject (lpMem, CIEBasedDEFTag);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeDEF(G)
    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, DecodeDEFGTag);
    else
        lpMem += WriteObject (lpMem, DecodeDEFTag);

    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);

        lpMem += WriteObject (lpMem, BeginFunction);
#if 0
        if (PCS == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
#endif
        lpMem += WriteObject (lpMem, StartClip);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII
        {
            lpMem += WriteObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /Table
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, TableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Nh
    lpMem += WriteInt (lpMem, nGrids);  // Send down Ni
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nj
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        lpMem += WriteInt (lpMem, nGrids);  // Send down Nk
//     	nNumbers = nGrids * nGrids * nGrids * nOutputCh ;
        SecondGrids = nGrids;
    }
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteObject (lpMem, NewLine);
            lpMem += WriteObject (lpMem, BeginArray);
        }
        for (k = 0; k < SecondGrids; k++)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (!AllowBinary)           // Output ASCII
            {
                lpMem += WriteObject (lpMem, BeginString);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
                else
                {
                    for (j = 0; j < nNumbers; j++)
                    {
                        lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                        lpTable += sizeof (icUInt16Number);
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
                lpMem += WriteObject (lpMem, EndString);
            } else
            {                           // Output BINARY
                lpMem += WriteStringToken (lpMem, 143, nNumbers);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteByteString (lpMem, lpTable, nNumbers);
                else
                    lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
            }
            lpMem += WriteObject (lpMem, NewLine);
        }
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteObject (lpMem, EndArray);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndArray); // End array

 //********** /DecodeABC
    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);

        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);

            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        }

 // Now, We get CieBasedXYZ output. Output range 0 --> 1.99997
 // If the connection space is absolute XYZ, We need to convert 
 // from relative XYZ to absolute XYZ.
        if ((PCS == icSigXYZData) &&
            (InputIntent == icAbsoluteColorimetric))
        {
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
        }
 // If the connection space is Lab, We need to convert XYZ to Lab.
        else if (PCS == icSigLabData)
            lpMem += WriteObject (lpMem, DecodeABCLab[i]);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    if (PCS == icSigLabData)
    {
 //********** /MatrixABC
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, BeginFunction);
            lpMem += WriteObject (lpMem, DecodeLMNLab);
            if (InputIntent == icAbsoluteColorimetric)
                lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
            else 
                lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp);
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
 //********** /RangeLMN
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, RangeLMNTag);
        lpMem += WriteObject (lpMem, RangeLMN);
    }

 //********** End dictionary definition
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteObject (lpMem, NewLine);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CieBasedDEFGEnd);
    else
        lpMem += WriteObject (lpMem, CieBasedDEFEnd);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SupportDEFG_E);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}


/***************************************************************************
*                           GetPS2CSA_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the RGB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigRgbData) ||
        !DoesCPTagExist (cp, icSigRedColorantTag) ||
        !DoesCPTagExist (cp, icSigGreenColorantTag) ||
        !DoesCPTagExist (cp, icSigBlueColorantTag) ||
        !DoesCPTagExist (cp, icSigRedTRCTag) ||
        !DoesCPTagExist (cp, icSigGreenTRCTag) ||
        !DoesCPTagExist (cp, icSigBlueTRCTag))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Creating global data
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABCBegin);

    lpMem += EnableGlobalDict(lpMem);

    lpMem += CreateColSpArray (cp, lpMem, icSigRedTRCTag, AllowBinary);
    lpMem += CreateColSpArray (cp, lpMem, icSigGreenTRCTag, AllowBinary);
    lpMem += CreateColSpArray (cp, lpMem, icSigBlueTRCTag, AllowBinary);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    lpMem += WriteObject (lpMem, EndOp);


 //*********** Start creating the ColorSpace
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigRedTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigGreenTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigBlueTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, EndArray);

 //********** /MatrixABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += CreateFloatString (cp, lpMem, icSigRedColorantTag);
    lpMem += CreateFloatString (cp, lpMem, icSigGreenColorantTag);
    lpMem += CreateFloatString (cp, lpMem, icSigBlueColorantTag);

    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /DecodeLMN
    if (InputIntent == icAbsoluteColorimetric)
    {
        // Support absolute whitePoint
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i ++)
        {
            lpMem += WriteObject (lpMem, BeginFunction);
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }

 //********** End dictionary definition
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC_LAB
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the LAB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC_LAB (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigLabData))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigLabData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /RangeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC_Lab);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, DecodeABCLab1);

 //********** /MatrixABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, DecodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, DecodeLMNLab);
        if (InputIntent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
        lpMem += WriteObject (lpMem, MulOp); 
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, NewLine);
    }
    lpMem += WriteObject (lpMem, EndArray);


 //********** End dictionary definition
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_MONO_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                    CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, j, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABCBegin);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /MatrixABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        for (j = 0; j < 3; j++)
        {
            if (i != j)
                lpMem += WriteFloat (lpMem, (double)0);
            else
            {
                if (InputIntent == icAbsoluteColorimetric)
                    lpMem += WriteFloat (lpMem, (double)MediaWP[i]);
                else
                    lpMem += WriteFloat (lpMem, (double)IlluminantWP[i]);
            }
        }
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);


    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO_A
*  function:
*    this is the function which creates the CIEBasedA ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_A(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_A (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                  CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedABegin);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedA
    lpMem += WriteObject (lpMem, CIEBasedATag); // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeA
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeATag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> 0.99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> .99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, EndArray);
    }

 //********** /MatrixA
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixATag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (InputIntent == icAbsoluteColorimetric)
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        else
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /End dictionary
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CieBasedAEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO
*  function:
*    this is the function which creates the MONO ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Device color type (RGB or GRAY).
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_MONO (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
                DWORD InpDrvClrSp, CSIG InputIntent, BOOL AllowBinary)
{
    BOOL Success = FALSE;
#if 0
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_ABC (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
#else
    if ((InpDrvClrSp == icSigGrayData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
    else
    {
        Success = FALSE;
    }
#endif
    return Success;
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount != 0)
        {
            if (nCount == 1)            // Gamma supplied in ui16 format
            {
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpMem += WriteObject (lpMem, DecodeA3);
            } else
            {
                lpMem += WriteObject (lpMem, StartClip);
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteObject (lpMem, DecodeABCArray);
                lpMem += WriteInt (lpMem, (SINT) CPTag);

                if (!AllowBinary)       // Output ASCII CS
                {
                    lpMem += WriteObject (lpMem, IndexArray);
                } else
                {                       // Output BINARY CS
                    lpMem += WriteObject (lpMem, IndexArray16b);
                }
                lpMem += WriteObject (lpMem, Scale16);
                lpMem += WriteObject (lpMem, EndClip);
            }
        }
        MemFree (hBuff);
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, si16f16toSFLOAT (lpTable));
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a array later to be used in ColorSpace's DecodeABC.
*
***************************************************************************/

SINT 
CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    HGLOBAL hBuff;
    lpOldMem = lpMem;

    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, Slash);
    lpMem += WriteObject (lpMem, DecodeABCArray);
    lpMem += WriteInt (lpMem, (SINT) CPTag);
    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount > 1)
        {
            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            if (!AllowBinary)           // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (i = 0; i < nCount; i++)
                {
                    lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            } else
            {                           // Output BINARY CS
                lpMem += WriteHNAToken (lpMem, 149, nCount);
                lpMem += WriteIntStringU2S (lpMem, lpTable, nCount);
            }
        }
        MemFree (hBuff);
        lpMem += WriteObject (lpMem, DefOp);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*                               GetCSAFromProfile
*  function:
*    this is the function which gets the ColorSpace dictionary array
*    from the the Profile.
*  prototype:
*       static BOOL GetCSAFromProfile(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp,
*                       CSIG        DrvColorSpace,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*       DrvColorSpace --  Profile device color space.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetCSAFromProfile (
                   CHANDLE cp,
                   MEMPTR lpMem,
                   LPDWORD lpcbSize,
                   DWORD InpDrvClrSp,
                   CSIG DrvColorSpace,
                   BOOL AllowBinary)
{
    SINT Index;
    SINT Size;
    if ((DrvColorSpace == icSigGrayData) && (InpDrvClrSp != icSigGrayData))
        return FALSE;

    if (DoesCPTagExist (cp, icSigPs2CSATag) &&
        GetCPTagIndex (cp, icSigPs2CSATag, (LPSINT) & Index) &&
        GetCPElementDataSize (cp, Index, (LPSINT) & Size) &&
        ((lpMem == NULL) || GetCPElementData (cp, Index, lpMem, Size)) &&
        (*lpcbSize = Convert2Ascii (cp, Index, lpMem, *lpcbSize, Size, AllowBinary)))
    {
        return TRUE;
    } else
    {
        return FALSE;
    }
}
/***************************************************************************
*                           GetPS2CSA_DEFG_Intent
*  function:
*    This is the function which creates the CieBasedDEF(G)ColorSpace array
*    based on Intent.
*  prototype:
*       static BOOL GetPS2CSA_DEFG_Intent(
*                   CHANDLE     cp,
*                   MEMPTR      lpBuffer,
*                   LPDWORD     lpcbSize,
*                   CSIG        Intent,
*                   int         Type,
*                   BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_DEFG_Intent (
                       CHANDLE cp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       DWORD InpDrvClrSp,
                       CSIG Intent,
                       int Type,
                       BOOL AllowBinary)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG icSigAToBx;

 // Try to create CieBasedDEFG CSA first.
    if (((Type == TYPE_CIEBASEDDEFG) && (InpDrvClrSp != icSigCmykData) ||
         (Type == TYPE_CIEBASEDDEF) && (InpDrvClrSp != icSigDefData)) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
    switch (Intent)
    {
        case icPerceptual:
            icSigAToBx = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        case icSaturation:
            icSigAToBx = icSigAToB2Tag;
            break;
        case icAbsoluteColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        default:
            return Success;
    }

    if (DoesCPTagExist (cp, icSigAToBx) &&
        GetCPTagIndex (cp, icSigAToBx, (LPSINT) & Index))
    {
        Success = GetPS2CSA_DEFG (cp, lpBuffer, lpcbSize, Intent, Index, Type, AllowBinary);
    }

    return Success;
}
/***************************************************************************
*                               GetPS2ColorSpaceArray
*  function:
*    This is the main function which creates the ColorSpace array
*    from the data supplied in the Profile.
*  prototype:
*       BOOL GetPS2ColorSpaceArray(
*               CHANDLE     cp,
*               CSIG        InputIntent,
*               WORD        InpDrvClrSp,
*               MEMPTR      lpBuffer,
*               LPDWORD     lpcbSize,
*               BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*                       icSigCmykData: input data is cmyk, create CiebasedDEFG CSA.
*                       icSigRgbData : input data is rgb, create CieBasedABC CSA.
*                       icSigDefData : input data is rgb or lab, create CiebasedDEF CSA.
*                       isSigGrayData: input data is gray, create CieBasedA CSA.
*                       0            : Auto. Create CSA depends on profile color space.
*       InputIntent --  Intent.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
BOOL EXTERN
GetPS2ColorSpaceArray (
                       CHANDLE cp,
                       DWORD InputIntent,
                       DWORD InpDrvClrSp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       BOOL AllowBinary)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;
    DWORD dwSaveSize;
    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    dwSaveSize = *lpcbSize;
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

 // Get ColorSpace from Profile.
    if ((CSIG) InputIntent == Intent)
    {
        Success = GetCSAFromProfile (cp, lpBuffer, lpcbSize,
                                     InpDrvClrSp, ColorSpace, AllowBinary);
    }
    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    if (!GetPS2CSA_ABC (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, AllowBinary))
                        GetDeviceRGB (lpNewBuffer, &cbNewSize, InpDrvClrSp);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;

                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, AllowBinary);
                }
                if (!Success)
                {                           // Create DeviceRGB
                    Success = GetDeviceRGB (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigCmykData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEFG, AllowBinary);
                if (Success)
                {                       // Create DeviceCMYK for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetDeviceCMYK (lpNewBuffer, &cbNewSize, InpDrvClrSp);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create DeviceCMYK
                    Success = GetDeviceCMYK (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigGrayData:
                Success = GetPS2CSA_MONO (cp, lpBuffer, lpcbSize, InpDrvClrSp, 
                                          (CSIG)InputIntent, AllowBinary);
                if (!Success)
                {                           // Create DeviceGray
                    Success = GetDeviceGray (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigLabData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetPS2CSA_ABC_LAB (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, AllowBinary);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC_LAB (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, AllowBinary);
                }
                break;

            default:
                break;
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\getcrd.c ===
#include "generic.h"

//#pragma code_seg(_ICMSEG)

#define  REVCURVE_RATIO    2

char ICMSEG BeginString[]       = "<";
char ICMSEG EndString[]         = ">";
char ICMSEG BeginArray[]        = "[";
char ICMSEG EndArray[]          = "]";
char ICMSEG BeginFunction[]     = "{";
char ICMSEG EndFunction[]       = "}bind ";
char ICMSEG BeginDict[]         = "<<" ;
char ICMSEG EndDict[]           = ">>" ;
char ICMSEG BlackPoint[]        = "[0 0 0]" ;
char ICMSEG DictType[]          = "/ColorRenderingType 1 ";

char ICMSEG WhitePointTag[]     = "/WhitePoint " ;
char ICMSEG BlackPointTag[]     = "/BlackPoint " ;
char ICMSEG RangePQRTag[]       = "/RangePQR " ;
char ICMSEG TransformPQRTag[]   = "/TransformPQR " ;
char ICMSEG MatrixPQRTag[]      = "/MatrixPQR " ;

char ICMSEG RangeABCTag[]       = "/RangeABC " ;
char ICMSEG MatrixATag[]        = "/MatrixA ";
char ICMSEG MatrixABCTag[]      = "/MatrixABC ";
char ICMSEG EncodeABCTag[]      = "/EncodeABC " ;
char ICMSEG RangeLMNTag[]       = "/RangeLMN " ;
char ICMSEG MatrixLMNTag[]      = "/MatrixLMN " ;
char ICMSEG EncodeLMNTag[]      = "/EncodeLMN " ;
char ICMSEG RenderTableTag[]    = "/RenderTable " ;
char ICMSEG CIEBasedATag[]      = "/CIEBasedA " ;
char ICMSEG CIEBasedABCTag[]    = "/CIEBasedABC " ;
char ICMSEG CIEBasedDEFGTag[]   = "/CIEBasedDEFG " ;
char ICMSEG CIEBasedDEFTag[]    = "/CIEBasedDEF " ;
char ICMSEG DecodeATag[]        = "/DecodeA " ;
char ICMSEG DecodeABCTag[]      = "/DecodeABC " ;
char ICMSEG DecodeLMNTag[]      = "/DecodeLMN " ;
char ICMSEG DeviceRGBTag[]      = "/DeviceRGB " ;
char ICMSEG DeviceCMYKTag[]     = "/DeviceCMYK " ;
char ICMSEG DeviceGrayTag[]     = "/DeviceGray " ;
char ICMSEG TableTag[]          = "/Table " ;
char ICMSEG DecodeDEFGTag[]     = "/DecodeDEFG " ;
char ICMSEG DecodeDEFTag[]      = "/DecodeDEF " ;

char ICMSEG NullOp[]            = "";
char ICMSEG DupOp[]             = "dup ";
char ICMSEG UserDictOp[]        = "userdict ";
char ICMSEG GlobalDictOp[]      = "globaldict ";
char ICMSEG CurrentGlobalOp[]   = "currentglobal ";
char ICMSEG SetGlobalOp[]       = "setglobal ";
char ICMSEG DefOp[]             = "def ";
char ICMSEG BeginOp[]           = "begin ";
char ICMSEG EndOp[]             = "end ";
char ICMSEG TrueOp[]            = "true ";
char ICMSEG FalseOp[]           = "false ";
char ICMSEG MulOp[]             = "mul ";
char ICMSEG DivOp[]             = "div ";

char ICMSEG NewLine[]           = "\n" ;
char ICMSEG Slash[]             = "/" ;
char ICMSEG Space[]             = " " ;
char ICMSEG CRDBegin[]          = "%** CRD Begin ";
char ICMSEG CRDEnd[]            = "%** CRD End ";
char ICMSEG CieBasedDEFGBegin[] = "%** CieBasedDEFG CSA Begin ";
char ICMSEG CieBasedDEFBegin[]  = "%** CieBasedDEF CSA Begin ";
char ICMSEG CieBasedABCBegin[]  = "%** CieBasedABC CSA Begin ";
char ICMSEG CieBasedABegin[]    = "%** CieBasedA CSA Begin ";
char ICMSEG CieBasedDEFGEnd[]   = "%** CieBasedDEFG CSA End ";
char ICMSEG CieBasedDEFEnd[]    = "%** CieBasedDEF CSA End ";
char ICMSEG CieBasedABCEnd[]    = "%** CieBasedABC CSA End ";
char ICMSEG CieBasedAEnd[]      = "%** CieBasedA CSA End ";
char ICMSEG RangeABC[]          = "[ 0 1 0 1 0 1 ] ";
char ICMSEG RangeLMN[]          = "[ 0 2 0 2 0 2 ] ";
char ICMSEG Identity[]          = "[1 0 0 0 1 0 0 0 1]";
char ICMSEG RangeABC_Lab[]      = "[0 100 -128 127 -128 127]";

/********** This PostScript code clips incoming value between 0.0 and 1.0
   Use:   x <clip>   --   <clipped x>                                   */
char ICMSEG Clip01[]            = "dup 1.0 ge{pop 1.0}{dup 0.0 lt{pop 0.0}if}ifelse " ;
char ICMSEG DecodeA3[]          = "256 div exp ";
char ICMSEG DecodeA3Rev[]       = "256 div 1.0 exch div exp ";
char ICMSEG DecodeABCArray[]    = "DecodeABC_";
char ICMSEG InputArray[]        = "Inp_";
char ICMSEG OutputArray[]       = "Out_";
char ICMSEG PreViewInArray[]    = "IPV_";
char ICMSEG PreViewOutArray[]   = "OPV_";


// This PostScript segment takes value in range from 0.0 to 1.0 and
//  interpolates the result using array supplied.
//   x [array]  -- <interpolated value>

char ICMSEG IndexArray16b[]     = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 32768 add 4 -1 roll 3 -1 roll get 32768 add \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG IndexArray[]        = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 4 -1 roll 3 -1 roll get \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG TestingDEFG[]       = \
"/SupportDEFG? {/CIEBasedDEFG /ColorSpaceFamily resourcestatus { pop pop true}{false} ifelse} def";

char ICMSEG SupportDEFG_S[]     = "SupportDEFG? { ";
char ICMSEG NotSupportDEFG_S[]  = "SupportDEFG? not { ";
char ICMSEG SupportDEFG_E[]     = "}if ";

char ICMSEG StartClip[]         = "dup 1.0 le{dup 0.0 ge{" ;
char ICMSEG EndClip[]           = "}if}if " ;

char ICMSEG Scale8[]            = "255 div " ;
char ICMSEG Scale16[]           = "65535 div " ;
char ICMSEG Scale16XYZ[]        = "32768 div " ;
char ICMSEG TFunction8[]        = "exch 255 mul round cvi get 255 div " ;
char ICMSEG TFunction8XYZ[]     = "exch 255 mul round cvi get 128 div " ;
char ICMSEG MatrixABCLab[]      = "[1 1 1 1 0 0 0 0 -1]" ;
char ICMSEG DecodeABCLab1[]     = "[{16 add 116 div} bind {500 div} bind {200 div} bind]";
char ICMSEG DecodeALab[]        = " 50 mul 16 add 116 div ";
char ICMSEG DecodeLMNLab[]      = \
"dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse ";

char ICMSEG RangeLMNLab[]       = "[0 1 0 1 0 1]" ;
char ICMSEG EncodeLMNLab[]      = "\
dup 0.008856 le{7.787 mul 0.13793 add}{0.3333 exp}ifelse " ;

char ICMSEG MatrixABCLabCRD[]   = "[0 500 0 116 -500 200 0 0 -200]" ;
char ICMSEG MatrixABCXYZCRD[]   = "[0 1 0 1 0 0 0 0 1]" ;
char ICMSEG EncodeABCLab1[]     = "16 sub 100 div " ;
char ICMSEG EncodeABCLab2[]     = "128 add 255 div " ;
char *TransformPQR[3]      = {
"4 index 0 get div 2 index 0 get mul 4 {exch pop} repeat ",
"4 index 1 get div 2 index 1 get mul 4 {exch pop} repeat ",
"4 index 2 get div 2 index 2 get mul 4 {exch pop} repeat " };

#pragma optimize("",off)

/***************************************************************************
*                               CreateLutCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  prototype:
*       SINT EXTERN CreateLutCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CRD allowed,  0: only ascii CRD allowed.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

SINT EXTERN 
CreateLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT nInputCh, nOutputCh, nGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    CSIG Tag, PCS;
    CSIG IntentSig;

    SINT Ret;
    SINT i, j;
    MEMPTR lpTable;

    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    char PublicArrayName[TempBfSize];
    HGLOBAL hMem;
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);
 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (((nOutputCh != 3) &&
         (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }
    Ret = nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +  // Number of INT bytes
        nOutputCh * nGrids * nGrids * nGrids * 2 +  // LUT HEX bytes
        nInputCh * (lstrlen (IndexArray) +
                    lstrlen (StartClip) +
                    lstrlen (EndClip)) +
        nOutputCh * (lstrlen (IndexArray) +
                     lstrlen (StartClip) +
                     lstrlen (EndClip)) +
        2048;                           // + other PS stuff

    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
//  Get all necessary params from the header
//  GetCPRenderIntent (cp, (LPCSIG) & Intent);  // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    lpMem += WriteObject (lpMem, EndOp);


//************* Start writing  CRD  ****************************
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** Send PQR - used for Absolute Colorimetric *****
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 // ******** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        PCS, nInputCh, Buff, NULL, Tag, AllowBinary);

 //********** /RenderTable
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Na
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nb
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);
    nNumbers = nGrids * nGrids * nOutputCh;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, BeginString);
            if (Tag == icSigLut8Type)
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
            else
            {
                for (j = 0; j < nNumbers; j++)
                {
                    lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
            }
            lpMem += WriteObject (lpMem, EndString);
        } else
        {                               // Output BINARY CRD
            lpMem += WriteStringToken (lpMem, 143, nNumbers);
            if (Tag == icSigLut8Type)
                lpMem += WriteByteString (lpMem, lpTable, nNumbers);
            else
                lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
        }
    }

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteInt (lpMem, nOutputCh);   // Send down m

 //********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        nOutputCh, Tag, FALSE, AllowBinary);

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CRDEnd);

// Testing Convert binary to ascii
//    i = ConvertBinaryData2Ascii(lpOldMem, (SINT)(lpMem - lpOldMem), Ret);
//    lpMem = lpOldMem + i;
// Testing Convert binary to ascii

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
/***************************************************************************
*                               GetRevCurve
*  function:
*  prototype:
*       BOOL  GetRevCurve(
*                          MEMPTR       Buff,
*                          MEMPTR       lpRevCurve)
*  parameters:
*       Buff        --
*       lpRevCurve  --
*  returns:
*       BOOL        --  TRUE:  successful,
*                       FALSE: otherwise.
***************************************************************************/

static BOOL
GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve)
{
    SINT i, j, nCount;
    MEMPTR lpTable;
    PUSHORT lpInput, lpOutput;
    SFLOAT fTemp;
    SINT iBegin, iEnd, iTemp;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
    lpOutput = (PUSHORT) lpRevCurve;
    lpInput = (PUSHORT) lpCurve;

    for (i = 0; i < nCount; i++)
    {
        lpInput[i] = (USHORT) (ui16toSINT (lpTable));
        lpTable += sizeof (icUInt16Number);
    }

    j = nCount * REVCURVE_RATIO;
    for (i = 0; i < j; i++)
    {
        fTemp = (SFLOAT) i *65535 / (j - 1);
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    for (i = 0; i < j; i++)
    {
        iBegin = 0;
        iEnd = nCount - 1;
        for (;;)
        {
            if ((iEnd - iBegin) <= 1)
                break;
            iTemp = (iEnd + iBegin) / 2;
            if (lpOutput[i] < lpInput[iTemp])
                iEnd = iTemp;
            else
                iBegin = iTemp;
        }
        if (lpOutput[i] <= lpInput[iBegin])
            fTemp = (SFLOAT) iBegin;
        else if (lpOutput[i] >= lpInput[iEnd])
            fTemp = (SFLOAT) iEnd;
        else
        {
            fTemp = ((SFLOAT) (lpInput[iEnd] - lpOutput[i])) /
                (lpOutput[i] - lpInput[iBegin]);
            fTemp = (iBegin * fTemp + iEnd) / (fTemp + 1);
        }
        fTemp = (fTemp / (nCount - 1)) * 65535;
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    return TRUE;
}
/***************************************************************************
*                               CreateMonoCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the GrayTRC tag.
*  prototype:
*       BOOL EXTERN CreateMonoCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
//  According to the spec this tag-based function only converts from
//  Device to PCS, so we need to create an inverse function to perform
//  PCS->device conversion. By definition the CRD is only
//  for XYZ->DeviceRGB/CMYK conversion.
SINT EXTERN 
CreateMonoCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT nCount;
    CSIG Tag, PCS;

    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpCurve, lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SINT i;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);

 // Estimate the memory size required to hold CRD
    Ret = nCount * 6 * 2 +              // Number of INT elements
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
    if (!MemAlloc (nCount * 2 * (REVCURVE_RATIO + 1),
                   (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (FALSE);
    }
    lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
    GetRevCurve (Buff, lpCurve, lpRevCurve);

 //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//************* Start writing  CRD  ****************************
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** /TransformPQR
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** /MatrixLMN
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 //********** /MatrixABC
    if (PCS == icSigXYZData)
    {   // Switch ABC to BAC, since we want to output B which is converted from Y.
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCXYZCRD);
    }
    else if (PCS == icSigLabData)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, EncodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);
        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, EncodeABCLab1);
            }
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}


BOOL EXTERN
GetPS2ColorRenderingDictionary (
                                CHANDLE cp,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary)
{
    SINT Index;
    SINT Ret, Size;
    CSIG icSigPs2CRDx, icSigBToAx;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }
    Ret = 0;
    Size = (SINT) * lpcbSize;

    switch (Intent)
    {
        case icPerceptual:
            icSigPs2CRDx = icSigPs2CRD0Tag;
            icSigBToAx = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
            icSigPs2CRDx = icSigPs2CRD1Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        case icSaturation:
            icSigPs2CRDx = icSigPs2CRD2Tag;
            icSigBToAx = icSigBToA2Tag;
            break;

        case icAbsoluteColorimetric:
            icSigPs2CRDx = icSigPs2CRD3Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        default:
            *lpcbSize = (DWORD) Ret;
            return (Ret > 0);
    }

    if (
        (DoesCPTagExist (cp, icSigPs2CRDx) &&
         GetCPTagIndex (cp, icSigPs2CRDx, (LPSINT) & Index) &&
         GetCPElementDataSize (cp, Index, (LPSINT) & Ret) &&
         ((Size == 0) ||
          GetCPElementData (cp, Index, lpMem, Size)) &&
         (Ret = Convert2Ascii (cp, Index, lpMem, Size, Ret, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigBToAx) &&
         GetCPTagIndex (cp, icSigBToAx, (LPSINT) & Index) &&
         (Ret = CreateLutCRD (cp, Index, lpMem, Intent, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigGrayTRCTag) &&
         GetCPTagIndex (cp, icSigGrayTRCTag, (LPSINT) & Index) &&
         (Ret = CreateMonoCRD (cp, Index, lpMem, Intent))
        )
       )
    {
    }

    *lpcbSize = (DWORD) Ret;
    return (Ret > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;  
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "profcrd.h"
#include "icmstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 16

typedef struct tagHOSTCLUT {
    USHORT         size;
    USHORT         wdummy;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                    CHANDLE cpDev,
                    CHANDLE cpTarget,
                    DWORD Intent,
                    MEMPTR lpMem,
                    LPDWORD lpcbSize,
                    BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\profcrd.c ===
#include "generic.h"
#include "icmstr.h"

//#pragma code_seg(_ICM3SEG)

#define MAXCOLOR8  255

#pragma optimize("", off)

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
       SINT numChan, SINT tableSize, SINT Offset, CSIG Tag, MEMPTR Buff);
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, BOOL, BOOL);
static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp);
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
       float far *Input, float far *Output, 
       CSIG ColorSpace, BOOL bCheckOutputTable);
static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output);
static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
       LPSINT lpInTbSize, LPSINT lpOutTbSize, 
       LPCSIG lpIntentTag, LPSINT lpGrids);
static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint);

/***************************************************************************
*                           CreateHostInputOutputArray
*  function:
*    this is the function which creates the output array from the data
*    supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*    MEMPTR     lpMem        : The buffer to save output array.
*    LPHOSTCLUT lpHostClut   : 
*    SINT       nOutputCh    : Number of input channel.
*    SINT       nOutputTable : The size of each input table. 
*    SINT       Offset       : The position of source output data(in icc profile).
*    CSIG       Tag          : To determin the Output table is 8 or 16 bits.
*    MEMPTR     Buff         : The buffer that contains source data(copyed from icc profile)
*
*  returns:
*       SINT    Returns number of bytes of Output Array
*
***************************************************************************/

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
                            SINT numChan, SINT tableSize, 
                            SINT Offset, CSIG Tag, MEMPTR Buff)
{
    SINT    i, j;
    PUSHORT lpMemPtr16;
    MEMPTR  lpMemPtr8;
    MEMPTR  lpTable;

    if (Tag == icSigLut8Type)
        lpMemPtr8 = lpMem;
    else
        lpMemPtr16 = (PUSHORT)lpMem;

    for (i = 0; i < numChan; i++)
    {
        if (Tag == icSigLut8Type)
        {
            ppArray[i] = lpMemPtr8;
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                Offset +
                tableSize * i;
            MemCopy(lpMemPtr8, lpTable, tableSize);
                lpMemPtr8 += tableSize;
        }
        else
        {
            ppArray[i] = (MEMPTR)lpMemPtr16;
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * Offset +
                2 * tableSize * i;
            for (j = 0; j < tableSize; j++)
            {
                *lpMemPtr16++ = (USHORT) ui16toSINT (lpTable);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }
    if (Tag == icSigLut8Type)
        return ((SINT) ((MEMPTR)lpMemPtr8 - lpMem));
    else
        return ((SINT) ((MEMPTR)lpMemPtr16 - lpMem));

}

VOID
GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
            LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size)
{
    if (LutTag == icSigLut8Type)
    {
        *nInputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut8Type) lpLut)->lut.clutPoints);
        *nInputTable = 256L;
        *nOutputTable = 256L;
        *size = 1;  // one byte for each input\output table entry
    } else
    {
        *nInputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut16Type) lpLut)->lut.clutPoints);
        *nInputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.inputEnt);
        *nOutputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.outputEnt);
        *size = 2;  // two bytes for each input\output table entry
    }
}

/***************************************************************************
*                           GetHostCSA
*  function:
*    this is the function which creates a Host CSA
*  parameters:
*       CHANDLE cp       --  Color Profile handle 
*       MEMPTR lpMem     --  Pointer to the memory block. If this point is NULL,
*                            require buffer size.
*       LPDWORD lpcbSize --  Size of the memory block
*       CSIG InputIntent --
*       SINT Index       --  to the icc profile tag that contains the data of Intent
*       int  Type        --  DEF or DEFG
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostCSA (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
            CSIG InputIntent, SINT Index, int Type)
{
    CSIG    PCS, LutTag;
    CSIG    IntentSig;
    SINT    nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT    nInputTable, nOutputTable, nNumbers;
    SINT    i, j, k;
    MEMPTR  lpTable;
    MEMPTR  lpOldMem = lpMem;
    MEMPTR  lpLut = NULL;
    HGLOBAL hLut = 0;
    SINT    LutSize;
    LPHOSTCLUT lpHostClut;

    // Check if we can generate the CS.
    // If we cannot find the required tag - we will return false
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }

    // Estimate the memory size required to hold CS
    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
	
    // First Pass. This is a size request
    if (lpMem == NULL)                  
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids;
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids;
        *lpcbSize = *lpcbSize             +   // size of RenderTable 8-bits only
            nInputCh * nInputTable * i    +   // size of input table 8/16-bits
            nOutputCh * nOutputTable * i  +   // size of output table 8/16-bits
            sizeof(HOSTCLUT) + 1024;          // data structure + extra safe space
        MemFree (hLut);
        return (TRUE);
    }

    // Second pass. constructure real HostCSA
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (LutTag == icSigLut8Type)? 8:16;

    // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;
    // Input Array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, LutTag, lpLut);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    // ourput array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, LutTag, lpLut);
 //********** /Table

    lpHostClut->clut = lpMem;
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        SecondGrids = nGrids;
    }
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        for (k = 0; k < SecondGrids; k++)
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (LutTag == icSigLut8Type)
            {
                // Copy 8-bit data.
                MemCopy(lpMem, lpTable, nNumbers);
                lpMem += nNumbers;
            }
            else
            {
                // convert 16 bit integer to right format. then copy only 8 bits.
                for (j = 0; j < nNumbers; j++)
                {
                    *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                }
            }
        }
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}


/***************************************************************************
*                        GetHostCSA_Intent
*  function:
*       This is the function which creates the Host DEF or DEFGColorSpace array
*       based on Intent.
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
                   CSIG Intent, int Type)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG AToBxTag;

    switch (Intent)
    {
        case icPerceptual:
            AToBxTag = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // use RelativeColorimetric data to build it.
            AToBxTag = icSigAToB1Tag;
            break;
        case icSaturation:
            AToBxTag = icSigAToB2Tag;
            break;
        default:
            return FALSE;
            break;
    }
    if (DoesCPTagExist (cp, AToBxTag) &&
        GetCPTagIndex (cp, AToBxTag, (LPSINT) & Index))
    {
        Success = GetHostCSA(cp, lpBuffer, lpcbSize, Intent, Index, Type);
    }

    return Success;
}
/***************************************************************************
*                            GetHostColorSpaceArray
*  function:
*    This is the main function which creates the Host CSA
*    from the data supplied in the Profile.
*  parameters:
*       cp          --  Color Profile handle
*       InputIntent --  Intent.
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostColorSpaceArray (CHANDLE cp, DWORD InputIntent,
                       MEMPTR  lpBuffer, LPDWORD lpcbSize)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;

    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEF);
                break;
            case icSigCmykData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEFG);
                break;
            default:
                break;
        }
    }
    return Success;
}

//===========================================================================

/***************************************************************************
*                             CreateHostLutCRD
*  function:
*    this is the function which creates the Host CRD
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       InputIntent --  Intent.
*
*  returns:
*       SINT        --  Size of Host CRD.
***************************************************************************/

static SINT 
CreateHostLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT     nInputCh, nOutputCh, nGrids;
    SINT     nInputTable, nOutputTable, nNumbers;
    CSIG     Tag, PCS;
    CSIG     IntentSig;

    SINT     Ret;
    SINT     i, j;
    MEMPTR   lpTable;

    MEMPTR   Buff = NULL;
    SINT     MemSize = 0;
    MEMPTR   lpOldMem = lpMem;
    HGLOBAL  hMem;
    LPHOSTCLUT  lpHostClut;

    // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }

    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (((nOutputCh != 3) && (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }

    // First Pass. This is a size request
    if (lpMem == NULL)       
    {
        Ret = nInputCh * nInputTable * i         +  // Input table 8/16-bits
            nOutputCh * nOutputTable * i         +  // Output table 8/16-bits
            nOutputCh * nGrids * nGrids * nGrids +  // CLUT 8-bits only
            sizeof(HOSTCLUT)                     +  // Data structure 
            1024;                                   // safe

        MemFree (hMem);
        return (Ret);
    }
	 
    // Second Pass. Get a HostCRD
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (Tag == icSigLut8Type)? 8:16;

    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    // Support absolute whitePoint
    if (!GetCPMediaWhitePoint (cp, (LPSFLOAT)lpHostClut->mediaWP)) // .. Media WhitePoint
    {
        lpHostClut->mediaWP[0] = lpHostClut->whitePoint[0];
        lpHostClut->mediaWP[1] = lpHostClut->whitePoint[1];
        lpHostClut->mediaWP[2] = lpHostClut->whitePoint[2];
    }
    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;

//******** Input array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, Tag, Buff);
//******** the offset to the position of output array.
    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
//******** Output array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, Tag, Buff);
//******** Matrix.
    if (PCS == icSigXYZData)
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
        } else
        {
            lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
        }
        for (i = 0; i < 9; i++)
        {
            lpHostClut->e[i] = (float)((si16f16toSFLOAT (lpTable)) / CIEXYZRange);
            lpTable += sizeof (icS15Fixed16Number);
        }
    }
//********** RenderTable
    nNumbers = nGrids * nGrids * nOutputCh;
    lpHostClut->clut = lpMem;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (Tag == icSigLut8Type)
        {
            MemCopy(lpMem, lpTable, nNumbers);
            lpMem += nNumbers;
        }
        else
        {
            for (j = 0; j < nNumbers; j++)
            {
                *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}

/***************************************************************************
*                      GetHostColorRenderingDictionary
*  function:
*    this is the main function which creates the Host CRD
*  parameters:
*       cp          --  Color Profile handle
*       Intent      --  Intent.
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       lpcbSize    -- 	size of memory block.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
static BOOL
GetHostColorRenderingDictionary (CHANDLE cp, DWORD Intent,
                                MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT Index;
    SINT Ret;
    CSIG BToAxTag;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }
    Ret = 0;

    switch (Intent)
    {
        case icPerceptual:
            BToAxTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // Use RelativeColorimetric to calculate this CRD.
            BToAxTag = icSigBToA1Tag;
            break;

        case icSaturation:
            BToAxTag = icSigBToA2Tag;
            break;

        default:
           *lpcbSize = (DWORD) Ret;
            return FALSE;
    }

    if (DoesCPTagExist (cp, BToAxTag) &&
        GetCPTagIndex (cp, BToAxTag, (LPSINT) & Index))
    {
        Ret = CreateHostLutCRD (cp, Index, lpMem, Intent);
    }

    *lpcbSize = (DWORD) Ret;
    return (Ret > 0);
}

//========================================================================
/***************************************************************************
*                               g
*  function:
*    Calculate function y = g(x). used in Lab->XYZ conversion
*    y = g(x):      g(x) = x*x*x             if x >= 6/29
*                   g(x) = 108/841*(x-4/29)  otherwise
*  parameters:
*       f           --  x
*  returns:
*       SINT        --  y
***************************************************************************/

static float g(float f)
{
    float frc;
    if (f >= (6/29))
    {
        frc = f * f * f;
    }
    else
    {
        frc = f - (4.0f / 29.0f) * (108.0f / 841.0f);
    }
    return frc;
}

/***************************************************************************
*                          inverse_g
*  function:
*    Calculate inverse function y = g(x). used in XYZ->Lab conversion
*  parameters:
*       f           --  y
*  returns:
*       SINT        --  x
***************************************************************************/
static float inverse_g(float f)
{
    double frc;
    if (f >= (6.0*6.0*6.0)/(29.0*29.0*29.0))
    {
        frc = pow(f, 1.0 / 3.0);
    }
    else
    {
        frc = f * (841.0 / 108.0) + (4.0 / 29.0);
    }
    return (float)frc;
}

//========================================================================

static BOOL
TableInterp3(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpA, tmpBC;
    int    cellA, cellB, cellC;
    float  a, b, c;
    short  Grids;
    short  outputChan;
    MEMPTR v000, v001, v010, v011;
    MEMPTR v100, v101, v110, v111;
    float  vx0x, vx1x;
    float  v0xx, v1xx;
    int    idx;

    cellA = (int)(fTemp[0]);
    a = fTemp[0] - cellA;

    cellB = (int)(fTemp[1]);
    b = fTemp[1] - cellB;

    cellC = (int)(fTemp[2]);
    c = fTemp[2] - cellC;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpA  = outputChan * Grids * Grids; 
    tmpBC = outputChan * (Grids * cellB + cellC);

    // Calculate 8 surrounding cells.
    v000 = lpHostClut->clut + tmpA * cellA + tmpBC;
    v001 = (cellC < (Grids - 1))? v000 + outputChan : v000;
    v010 = (cellB < (Grids - 1))? v000 + outputChan * Grids : v000;
    v011 = (cellC < (Grids - 1))? v010 + outputChan : v010 ;

    v100 = (cellA < (Grids - 1))? v000 + tmpA : v000;
    v101 = (cellC < (Grids - 1))? v100 + outputChan : v100;
    v110 = (cellB < (Grids - 1))? v100 + outputChan * Grids : v100;
    v111 = (cellC < (Grids - 1))? v110 + outputChan : v110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 4 bottom cells.
        vx0x = *v000 + c * (int)((int)*v001 - (int)*v000);
        vx1x = *v010 + c * (int)((int)*v011 - (int)*v010);
        v0xx = vx0x + b * (vx1x - vx0x);

        // Calculate the average of 4 upper cells.
        vx0x = *v100 + c * (int)((int)*v101 - (int)*v100);
        vx1x = *v110 + c * (int)((int)*v111 - (int)*v110);
        v1xx = vx0x + b * (vx1x - vx0x);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xx + a * (v1xx - v0xx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v000++;
            v001++;
            v010++;
            v011++;
            v100++;
            v101++;
            v110++;
            v111++;
        }
    }

    return TRUE;
}

static BOOL
TableInterp4(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpH, tmpI, tmpJK;
    int    cellH, cellI, cellJ, cellK;
    float  h, i, j, k;
    short  Grids;
    short  outputChan;
    MEMPTR v0000, v0001, v0010, v0011;
    MEMPTR v0100, v0101, v0110, v0111;
    MEMPTR v1000, v1001, v1010, v1011;
    MEMPTR v1100, v1101, v1110, v1111;
    float  vxx0x, vxx1x;
    float  vx0xx, vx1xx;
    float  v0xxx, v1xxx;
    int    idx;

    cellH = (int)(fTemp[0]);
    h = fTemp[0] - cellH;

    cellI = (int)(fTemp[1]);
    i = fTemp[1] - cellI;

    cellJ = (int)(fTemp[2]);
    j = fTemp[2] - cellJ;

    cellK = (int)(fTemp[3]);
    k = fTemp[3] - cellK;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpI  = outputChan * Grids * Grids;
    tmpH  = tmpI * Grids; 
    tmpJK = outputChan * (Grids * cellJ + cellK);

    // Calculate 16 surrounding cells.
    v0000 = lpHostClut->clut + tmpH * cellH + tmpI * cellI + tmpJK;
    v0001 = (cellK < (Grids - 1))? v0000 + outputChan : v0000;
    v0010 = (cellJ < (Grids - 1))? v0000 + outputChan * Grids : v0000;
    v0011 = (cellK < (Grids - 1))? v0010 + outputChan : v0010;

    v0100 = (cellI < (Grids - 1))? v0000 + tmpI : v0000;
    v0101 = (cellK < (Grids - 1))? v0100 + outputChan : v0100;
    v0110 = (cellJ < (Grids - 1))? v0100 + outputChan * Grids : v0100;
    v0111 = (cellK < (Grids - 1))? v0110 + outputChan : v0110;

    v1000 = (cellH < (Grids - 1))? v0000 + tmpH : v0000;
    v1001 = (cellK < (Grids - 1))? v1000 + outputChan : v1000;
    v1010 = (cellJ < (Grids - 1))? v1000 + outputChan * Grids : v1000;
    v1011 = (cellK < (Grids - 1))? v1010 + outputChan : v1010;

    v1100 = (cellI < (Grids - 1))? v1000 + tmpI : v1000;
    v1101 = (cellK < (Grids - 1))? v1100 + outputChan : v1100;
    v1110 = (cellJ < (Grids - 1))? v1100 + outputChan * Grids : v1100;
    v1111 = (cellK < (Grids - 1))? v1110 + outputChan : v1110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 8 bottom cells.
        vxx0x = *v0000 + k * (int)((int)*v0001 - (int)*v0000);
        vxx1x = *v0010 + k * (int)((int)*v0011 - (int)*v0010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v0100 + k * (int)((int)*v0101 - (int)*v0100);
        vxx1x = *v0110 + k * (int)((int)*v0111 - (int)*v0110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v0xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the average of 8 upper cells.
        vxx0x = *v1000 + k * (int)((int)*v1001 - (int)*v1000);
        vxx1x = *v1010 + k * (int)((int)*v1011 - (int)*v1010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v1100 + k * (int)((int)*v1101 - (int)*v1100);
        vxx1x = *v1110 + k * (int)((int)*v1111 - (int)*v1110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v1xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xxx + h * (v1xxx - v0xxx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v0000++;
            v0001++;
            v0010++;
            v0011++;
            v0100++;
            v0101++;
            v0110++;
            v0111++;
            v1000++;
            v1001++;
            v1010++;
            v1011++;
            v1100++;
            v1101++;
            v1110++;
            v1111++;
        }
    }

    return TRUE;
}


/***************************************************************************
*                         CheckColorLookupTable
*  function:
*    This function check RenderTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input (in range [0 gred-1]) /
*                                 output(in range [0 1)
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp) 
{
    if (lpHostClut->inputChan == 3)
    {
        TableInterp3(lpHostClut, fTemp);
    }
    else if(lpHostClut->inputChan == 4)
    {
        TableInterp4(lpHostClut, fTemp);
    }
    return TRUE;
}

/***************************************************************************
*                         CheckInputOutputTable
*  function:
*    This function check inputTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input / output data
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, 
                      BOOL bCSA, BOOL bInputTable) 
{
    int     i;
    short   Grids;
    USHORT  floor1, ceiling1;
    float   fIndex;
    int     numChan;
    int     numEnt;
    PMEMPTR ppArray;

    if (bInputTable)
    {
        numChan = lpHostClut->inputChan;
        numEnt = lpHostClut->inputEnt - 1;
        ppArray = lpHostClut->inputArray;
    }
    else
    {
        numChan = lpHostClut->outputChan;
        numEnt = lpHostClut->outputEnt - 1;
        ppArray = lpHostClut->outputArray;
    }

    Grids = lpHostClut->clutPoints;
    for (i = 0; (i <= MAXCHANNELS) && (i < numChan); i++)
    {
        fTemp[i] = (fTemp[i] < 0)? 0: ((fTemp[i] > 1)? 1: fTemp[i]);
        fIndex = fTemp[i] * numEnt;
        if (lpHostClut->lutBits == 8)
        {
            floor1 = ppArray[i][(int)fIndex];
            ceiling1 = ppArray[i][((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 127.0);
            else
                fTemp[i] = (float)(fTemp[i] / 255.0);
        }
        else
        {
            floor1 = ((PUSHORT)(ppArray[i]))[(int)fIndex];
            ceiling1 = ((PUSHORT)(ppArray[i]))[((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 32767.0);
            else
                fTemp[i] = (float)(fTemp[i] / 65535.0);

        }
        if (bInputTable)
        {
            fTemp[i] *= (Grids - 1);
            if (fTemp[i] > (Grids - 1))
                fTemp[i] = (float)(Grids - 1);
        }
    }
    return TRUE;
}

static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = (Input[0] * 50 + 16) / 116;
    fa = (Input[1] * 128 - 128) / 500;
    fb = (Input[2] * 128 - 128) / 200;
    Output[0] = whitePoint[0] * g(fL + fa);
    Output[1] = whitePoint[1] * g(fL);
    Output[2] = whitePoint[2] * g(fL - fb);
}

static void
XYZToLab(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = inverse_g(Input[0] / whitePoint[0]);
    fa = inverse_g(Input[1] / whitePoint[1]);
    fb = inverse_g(Input[2] / whitePoint[2]);
    Output[0] = (fa * 116 - 16) / 100;
    Output[1] = (fL * 500 - fa * 500 + 128) / 255;
    Output[2] = (fa * 200 - fb * 200 + 128) / 255;
}

/***************************************************************************
*                         DoHostConversionCRD
*  function:
*    This function converts XYZ/Lab to RGB/CMYK by using HostCRD
*  parameters:
*       LPHOSTCLUT lpHostCRD  -- pointer to a HostCRD
*       LPHOSTCLUT lpHostCSA  -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
                     float far *Input, float far *Output,
                     CSIG ColorSpace, BOOL bCheckOutputTable)
{
    float   fTemp[MAXCHANNELS];
    float   fTemp1[MAXCHANNELS];
    int     i, j;

/**
** Input XYZ or Lab in range [0 2]
***/
    // When sampling the deviceCRD, skip the input table.
    // If lpHostCSA is not NULL, the current CRD is targetCRD, we
    // need to do input table conversion
    if (lpHostCSA)
    {
        // Convert Lab to XYZ  in range [ 0 whitePoint ]
        if ((lpHostCRD->pcs == icSigXYZData) && 
            (lpHostCSA->pcs == icSigLabData))
        {
            LabToXYZ(Input, fTemp1, lpHostCRD->whitePoint);
        }
        // Convert XYZ to Lab in range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigXYZData))
        {
            XYZToLab(Input, fTemp, lpHostCSA->whitePoint);
        }
        // Convert Lab to range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigLabData))
        {
            for (i = 0; i < 3; i++)
                fTemp[i] = Input[i] / 2;
        }
        // Convert XYZ to XYZ (based on white point) to range [0 1]
        else
        {
            for (i = 0; i < 3; i++)
                fTemp1[i] = Input[i] * lpHostCRD->whitePoint[i] / lpHostCSA->whitePoint[i];
        }
        // Matrix, used for XYZ data only.
        if (lpHostCRD->pcs == icSigXYZData)
        {
            for (i = 0; i < 3; i++)
            {
                j = i*3;
                fTemp[i] =  lpHostCRD->e[j ]    * fTemp1[0] +
                            lpHostCRD->e[j + 1] * fTemp1[1] +
                            lpHostCRD->e[j + 2] * fTemp1[2];
            }
        }

        //Search input Table
        CheckInputOutputTable(lpHostCRD, fTemp, 0, 1);
    }
    // If the current CRD is device CRD, we do not need to do input
    // table conversion.
    else
    {
        short   Grids;
    	Grids = lpHostCRD->clutPoints;
        // Sample data may be XYZ or Lab. It depends on Target icc profile.
        // If the PCS of the target icc profile is XYZ, input data will be XYZ.
        // If the PCS of the target icc profile is Lab, input data will be Lab.

        for (i = 0; i < 3; i++)
        {
            fTemp[i] = Input[i]* (Grids - 1);
            if (fTemp[i] > (Grids - 1))
                fTemp[i] = (float)(Grids - 1);
        }
    }   // bCheckInputTable

    // Rendering table
    CheckColorLookupTable(lpHostCRD, fTemp);

/**
** Output RGB or CMYK in range [0 1]
***/
    if (bCheckOutputTable)
    {
        //Output Table
        CheckInputOutputTable(lpHostCRD, fTemp, 0, 0);
    }
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostCRD->outputChan); i++)
    {
        Output[i] = fTemp[i];
    }

    return TRUE;
}

/***************************************************************************
*                         DoHostConversionCSA
*  function:
*    This function converts RGB/CMYK to XYZ/Lab by using HostCSA
*  parameters:
*       LPHOSTCLUT lpHostCLUT -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output)
{
    float   fTemp[MAXCHANNELS];
    int     i;

/**
** Input RGB or CMYK in range [0 1]
***/
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->inputChan); i++)
    {
        fTemp[i] = Input[i];
    }
    //Search input Table
    CheckInputOutputTable(lpHostClut, fTemp, 1, 1);

    // Rendering table
    CheckColorLookupTable(lpHostClut, fTemp);

    //Output Table
    CheckInputOutputTable(lpHostClut, fTemp, 1, 0 );

/**
** Output XYZ or Lab in range [0 2]
***/
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->outputChan); i++)
    {
        Output[i] = fTemp[i];
    }
    return TRUE;
}				

static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
    LPSINT lpInTbSize, LPSINT lpOutTbSize, 
    LPCSIG lpIntentTag, LPSINT lpGrids)
{
    CSIG    Tag;
    SINT    Index;
    SINT    Ret = 0;
    MEMPTR  Buff = NULL;
    SINT    MemSize = 0;
    HGLOBAL hMem;
    SINT    outputChan, outputEnt;
    SINT    inputChan, inputEnt;
    SINT    Grids;
    SINT    i;

    switch (Intent)
    {
        case icPerceptual:
            *lpIntentTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            *lpIntentTag = icSigBToA1Tag;
            break;

        case icSaturation:
            *lpIntentTag = icSigBToA2Tag;
            break;

        default:
            return FALSE;
    }
    if (!DoesCPTagExist (cp, *lpIntentTag) ||
        !GetCPTagIndex (cp, *lpIntentTag, (LPSINT) & Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return FALSE;
    }

    if (lpInTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if (inputChan != 3)
        {
            MemFree (hMem);
            return FALSE;
        }

        *lpInTbSize = inputChan * inputEnt * 6;  // Number of INT bytes
        *lpGrids = Grids;
    }

    if (lpOutTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if ((outputChan != 3) && (outputChan != 4))
        {
            MemFree (hMem);
            return FALSE;
        }
        *lpOutTbSize = outputChan * outputEnt * 6; // Number of INT bytes
        *lpGrids = Grids;
    }

    MemFree (hMem);
    return TRUE;
}

/***************************************************************************
*                         CreateOutputArray
*  function:
*       Create CSA/CRD output arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to a buffer which will contain the arrays. 
*       SINT    nOutputCh    -- Number of output channel. if lpHostClut, no meaning.
*       SINT    nOutputTable -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contain LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of output array created.
***************************************************************************/

SINT
CreateOutputArray (MEMPTR lpMem, SINT nOutputCh, 
    SINT nOutputTable, SINT Offset, MEMPTR Intent, 
    CSIG Tag, MEMPTR Buff, BOOL AllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nOutputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->outputChan);
        nOutputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->outputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
              icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);
        
        if (lpHostClut)
            lpTable = ((LPHOSTCLUT)lpHostClut)->outputArray[i];
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                    Offset +
                    nOutputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                    2 * Offset +
                    2 * nOutputTable * i;
        }

        if (!AllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nOutputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nOutputTable; j++)
                {
                    if (lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nOutputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nOutputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nOutputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

/***************************************************************************
*                         CreateInputArray
*  function:
*       Create CSA/CRD Input arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to the buffer which will contain the arrays.
*       SINT    nInputCh     -- Number of input channel. if lpHostClut, no meaning.
*       SINT    nInputTable  -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contains LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of inpput array created.
***************************************************************************/

SINT
CreateInputArray (MEMPTR lpMem, SINT nInputCh, 
    SINT nInputTable, MEMPTR Intent, CSIG Tag, 
    MEMPTR Buff, BOOL bAllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nInputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->inputChan);
        nInputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->inputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
               icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);

        if (lpHostClut)
        {
            lpTable = ((LPHOSTCLUT)lpHostClut)->inputArray[i];
        }
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) + nInputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) + 2 * nInputTable * i;
        }
        if (!bAllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable,lpLineStart, nInputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nInputTable; j++)
                {
                    if(lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nInputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nInputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nInputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

SINT
SendCRDLMN(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs)
{
    MEMPTR  lpOldMem;
    SINT    i, j;

    lpOldMem = lpMem;

//********** /MatrixLMN
    if (icAbsoluteColorimetric == Intent)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, MatrixLMNTag);

        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 3; j++)
                lpMem += WriteFloat (lpMem,
                    (double) (i == j) ? whitePoint[i] / mediaWP[i] : 0.0);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /RangeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeLMNTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double) whitePoint[i]);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, RangeLMNLab);
    }

 //********** /EncodeLMN
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EncodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        if (pcs != icSigXYZData)
        {
            lpMem += WriteFloat (lpMem, (double)whitePoint[i]);
            lpMem += WriteObject (lpMem, DivOp);
            lpMem += WriteObject (lpMem, EncodeLMNLab);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    return (SINT)(lpMem - lpOldMem);
}


SINT
SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

//********** /RangePQR
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangePQRTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteFloat (lpMem, (double) 0);
        lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
    }
    lpMem += WriteObject (lpMem, EndArray);

//********** /MatrixPQR
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixPQRTag);
    lpMem += WriteObject (lpMem, Identity);

//********** /TransformPQR
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, TransformPQRTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem,
            (icAbsoluteColorimetric != Intent) ? TransformPQR[i] : NullOp);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
   
    return (SINT)(lpMem - lpOldMem);
} 

SINT
SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
           MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i, j;
    double TempMatrixABC[9];
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

 //********** /RangeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC);
 //********** /MatrixABC
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, MatrixABCTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        if (e)
        {
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, e[i + j * 3]);
                }
            }
        }
        else
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
            } else
            {
                lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
            }
            for (i = 0; i < 9; i++)
            {
                TempMatrixABC[i] = ((double) si16f16toSFLOAT (lpTable)) / CIEXYZRange;
                lpTable += sizeof (icS15Fixed16Number);
            }
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, TempMatrixABC[i + j * 3]);
                }
            }
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EncodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, NewLine);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (pcs == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
        lpMem += WriteObject (lpMem, StartClip);
        if (e)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)              // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);
            lpMem += WriteObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? 
                              Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT
SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

//********** /BlackPoint
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

//********** /WhitePoint
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
        SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    for (i = 0; i < nOutputCh; i++)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        if (bHost)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16);
            }
        }

        lpMem += WriteObject (lpMem, EndFunction);
    }
    return (SINT)(lpMem - lpOldMem);
}

//========================================================================
/***************************************************************************
*                  GetPS2PreviewColorRenderingDictionary
*  function:
*    This is the main function that creates proofing CRD.
*    It does the following:
*       1) Creates host TargetCRD, TargetCSA and DevCRD.
*       2) Create proofing CRD by sampling TargetCRD TargetCSA and DevCRD.
*       3) Uses TargetCRD's input table as proofingCRD's input table.
*       4) Uses DevCRD's output table as proofingCRD's output table.
*       5) Sample data is XYZ or Lab, depends on PCS of TargetCRD.
*
*  parameters:
*       CHANDLE  cpDev        -- handle to Target icc profile.
*       CHANDLE  cpTarget     -- handle to Dev icc profile.
*       DWORD    Intent       -- intent 
*       MEMPTR   lpMem        -- pointer to buffer for proofCRD,
*                                NULL means query buffer size.
*       LPDWORD  lpcbSize     -- as input: current buffer size
*                             -- as output: real proofCRD size.
*       BOOL     bAllowBinary -- create a ascii or binary proofCRD.
*
*  returns:
*       BOOL                  -- TRUE/FALSE
***************************************************************************/

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (CHANDLE cpDev,
                                CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL bAllowBinary)
{
    MEMPTR    lpTargetCRD, lpTargetCSA, lpDevCRD;
    DWORD     cbTargetCRD, cbTargetCSA, cbDevCRD;
    HGLOBAL   hTargetCRD, hTargetCSA, hDevCRD;
    BOOL      Success = FALSE;
    float     Input[MAXCHANNELS];
    float     Output[MAXCHANNELS];
    float     Temp[MAXCHANNELS];
    int       i, j, k, l;
    MEMPTR    lpLineStart;
    MEMPTR    lpOldMem;
    CSIG      ColorSpace;
    CSIG      DevColorSpace;
    static CSIG      IntentTag;
    static SINT      PreviewCRDGrid;
    SINT      OutArraySize, InArraySize;
    char      PublicArrayName[TempBfSize];
    SINT      TargetGrids, DevGrids;

    // First pass, return the size of Previewind CRD.
    if (lpMem == NULL)
    {
        SINT   dwOutArraySizr = 0;

        i = 3;      // Default output channal;
        if ((GetCPDevSpace (cpDev, (LPCSIG) & DevColorSpace)) &&
                          (DevColorSpace == icSigCmykData))
        {
            i = 4;
        }

        // Get the input array size IntentTag and Grid of the Target icc profile.
        if (!GetCRDInputOutputArraySize(cpTarget, Intent,
            &InArraySize, NULL, &IntentTag, &TargetGrids ))
            return FALSE;

        // Get the output array size IntentTag and Grid of the Dev icc profile.
        if (!GetCRDInputOutputArraySize(cpDev, Intent,
            NULL, &OutArraySize, &IntentTag, &DevGrids ))
            return FALSE;

        PreviewCRDGrid = (TargetGrids > DevGrids)? TargetGrids: DevGrids;

        // Min proofing CRD grid will be PREVIEWCRDGRID
        if (PreviewCRDGrid < PREVIEWCRDGRID)
            PreviewCRDGrid = PREVIEWCRDGRID;
        *lpcbSize = PreviewCRDGrid * PreviewCRDGrid * PreviewCRDGrid * 
                    i * 2 +           // CLUT size (Hex output)
                    OutArraySize +    // Output Array size
                    InArraySize  +    // Input Array size
                    4096;             // Extra PostScript staff.
         return (TRUE);
    }

    // Second pass, return the Previewind CRD.
    lpOldMem = lpMem;

    //Query the sizes of Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, NULL, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, NULL, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, NULL, &cbDevCRD)))
    {
        return (Success);
    }

    //Alloc the buffers for Host TargetCRD, TargetCSA and DevCRD.
    hTargetCRD = hTargetCSA = hDevCRD = 0;
    if (!MemAlloc (cbTargetCRD, (HGLOBAL FAR *)&hTargetCRD, (LPMEMPTR)&lpTargetCRD) ||
        !MemAlloc (cbTargetCSA, (HGLOBAL FAR *)&hTargetCSA, (LPMEMPTR)&lpTargetCSA) ||
        !MemAlloc (cbDevCRD, (HGLOBAL FAR *)&hDevCRD, (LPMEMPTR)&lpDevCRD))
    {
        goto Done;
    }

    //Build Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, lpTargetCRD, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, lpTargetCSA, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, lpDevCRD, &cbDevCRD)))
    {
        goto Done;
    }

//  Build Proofing CRD based on Host TargetCRD TargetCSA and DevCRD.
//  We use TargetCRD input tables and matrix as the
//  input tables and matrix of the ProofCRD.
//  We use DevCRD output tables as the output tables of the ProofCRD.

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cpDev, IntentTag, PublicArrayName);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, (SINT)0, (SINT)0, (MEMPTR)PublicArrayName, 
             (CSIG)0, NULL, bAllowBinary, lpTargetCRD);

    lpMem += CreateOutputArray (lpMem, (SINT)0, (SINT)0, (SINT)0, 
             (MEMPTR)PublicArrayName, (CSIG)0, NULL, bAllowBinary, lpDevCRD);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    lpMem += WriteObject (lpMem, EndOp);

//************* Start writing  CRD  ****************************
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

//********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send PQR - For White Point correction
    lpMem += SendCRDPQR(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint,
        ((LPHOSTCLUT)lpTargetCRD)->mediaWP,
        ((LPHOSTCLUT)lpTargetCRD)->pcs);

//********** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpTargetCRD)->pcs,
        ((LPHOSTCLUT)lpTargetCRD)->inputChan,
        NULL,
        ((LPHOSTCLUT)lpTargetCRD)->e,
        (((LPHOSTCLUT)lpTargetCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        bAllowBinary);

//********** /RenderTable
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Na
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nb
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, BeginArray);
    ColorSpace = ((LPHOSTCLUT)lpDevCRD)->pcs;
    for (i = 0; i < PreviewCRDGrid; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (bAllowBinary)
        {
            lpMem += WriteStringToken (lpMem, 143, 
                PreviewCRDGrid * PreviewCRDGrid * ((LPHOSTCLUT)lpDevCRD)->outputChan);
        }
        else
        {
            lpMem += WriteObject (lpMem, BeginString);
        }
        Input[0] = ((float)i) / (PreviewCRDGrid - 1);
        for (j = 0; j < PreviewCRDGrid; j++)
        {
            Input[1] = ((float)j) / (PreviewCRDGrid - 1);
            for (k = 0; k < PreviewCRDGrid; k++)
            {
                Input[2] = ((float)k) / (PreviewCRDGrid - 1);

                DoHostConversionCRD ((LPHOSTCLUT)lpTargetCRD, NULL, Input, Output, ColorSpace, 1);
                DoHostConversionCSA ((LPHOSTCLUT)lpTargetCSA, Output, Temp);
                DoHostConversionCRD ((LPHOSTCLUT)lpDevCRD, (LPHOSTCLUT)lpTargetCSA, 
                                     Temp, Output, 0, 0);
                for (l = 0; l < ((LPHOSTCLUT)lpDevCRD)->outputChan; l++)
                {
                    if (bAllowBinary)
                    {
                        *lpMem++ = (BYTES)(Output[l]*255);
                    }
                    else
                    {
                        lpMem += WriteHex (lpMem, (USHORT)(Output[l]*255));
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
            }
        }
        if (!bAllowBinary)
            lpMem += WriteObject (lpMem, EndString);
    }
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteInt (lpMem, ((LPHOSTCLUT)lpDevCRD)->outputChan);

//********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpDevCRD)->outputChan,
        (((LPHOSTCLUT)lpDevCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        TRUE,
        bAllowBinary);


    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndDict); // End dictionary definition
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += WriteObject (lpMem, CRDEnd);
    Success = TRUE;

Done:
    *lpcbSize = (DWORD)(lpMem - lpOldMem);

    if (hTargetCRD)
         MemFree(hTargetCRD);
    if (hTargetCSA)
         MemFree(hTargetCSA);
    if (hDevCRD)
         MemFree(hDevCRD);
    return (Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\control.c ===
#include "generic.h"

#pragma optimize("",off)

/***************************************************************************
*                               CreateINTENTControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void CreateINTENTControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateINTENTControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingIntent(cp, Intent, NULL, &cbSize);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingIntent(cp, Intent, lpBuffer, &cbSize);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No PS2 Intent created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateCRDControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingDictionary(cp, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingDictionary(cp, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateProfCRDControl(
    LPSTR       DevProfile,
    LPSTR       TargetProfile,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cpDev, cpTar;
    HGLOBAL     hDevCP = 0, hTarCP = 0;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    LoadCP32( (LPCSTR) DevProfile, &hDevCP, (LPCHANDLE) &cpDev);
    LoadCP32( (LPCSTR) TargetProfile, &hTarCP, (LPCHANDLE) &cpTar);

    if (!hDevCP || !hTarCP)
    {
        if (hDevCP)  FreeCP(hDevCP);
        if (hTarCP)  FreeCP(hTarCP);
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hDevCP);
    FreeCP(hTarCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               ColorSpaceControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
ColorSpaceControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       InpDrvClrSp,
    DWORD       Intent,
    WORD        CSAType,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    switch (InpDrvClrSp)
    {
        case 0: break;
        case 1: InpDrvClrSp = icSigGrayData; break;
        case 3: InpDrvClrSp = icSigRgbData; break;
        case 4: InpDrvClrSp = icSigCmykData; break;
        default: InpDrvClrSp = 0; break;
    }

    // Create CieBasedDEF(G) first. if can not, create CieBasedABC.
    if (CSAType == 405)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
    // Create CieBasedABC
    else if (CSAType == 406)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
#if 0
    else if (CSAType == 406)
    {
        Ret = GetPS2CSA_ABC( cp, NULL, &cbSize, InpDrvClrSp, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2CSA_ABC( cp, lpBuffer, &cbSize, InpDrvClrSp, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
    else if ((CSAType == 407) &&
        (GetCPDevSpace(cp, (LPCSIG) &ColorSpace)))
    {
        if (ColorSpace == icSigRgbData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
        else if (ColorSpace == icSigCmykData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            if (ColorSpace == icSigRgbData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
            else if (ColorSpace == icSigCmykData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
#endif
    FreeCP(hCP);
    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\dll32\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


// typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;


/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

//#define CS_ENABLE       1
//#define CS_DISABLE      2
//#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
#endif
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);

#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\main.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


// menu commands

// Find menu
#define IDM_OPENFILE        100
#define IDM_SAVEFILE        101
#define IDM_SAVEFILEAS      102
#define IDM_PRINT           103
#define IDM_EXIT            104

// Options menu
#define IDM_ENTERNEW        200
#define IDM_CHOOSECOLOR     201
#define IDM_CHOOSEFONT      202
#define IDM_FINDTEXT        203
#define IDM_REPLACETEXT     204
#define IDM_STANDARD        205
#define IDM_HOOK            206
#define IDM_CUSTOM          207

// Settings
#define IDM_PERCEPUAL       400
#define IDM_COLOR           401
#define IDM_SATURATION      402
#define IDM_ASCII           403
#define IDM_BINARY          404
#define IDM_AUTO            405
#define IDM_ABC             406
#define IDM_DEFG            407
#define IDM_INP_AUTO        408
#define IDM_INP_GRAY        409
#define IDM_INP_RGB         410
#define IDM_INP_CMYK        411
#define IDM_CSA             412
#define IDM_CRD             413
#define IDM_INTENT          414
#define IDM_PROFCRD         415
// Help menu
#define IDM_ABOUT           300


// Dialog box constants
#define IDEDIT              500

// string constants

#define IDS_DIALOGFAILURE     1
#define IDS_STRUCTSIZE        2
#define IDS_INITIALIZATION    3
#define IDS_NOTEMPLATE        4
#define IDS_NOHINSTANCE       5
#define IDS_LOADSTRFAILURE    6
#define IDS_FINDRESFAILURE    7
#define IDS_LOADRESFAILURE    8
#define IDS_LOCKRESFAILURE    9
#define IDS_MEMALLOCFAILURE  10
#define IDS_MEMLOCKFAILURE   11
#define IDS_NOHOOK           12
#define IDS_SETUPFAILURE     13
#define IDS_PARSEFAILURE     14
#define IDS_RETDEFFAILURE    15
#define IDS_LOADDRVFAILURE   16
#define IDS_GETDEVMODEFAIL   17
#define IDS_INITFAILURE      18
#define IDS_NODEVICES        19
#define IDS_NODEFAULTPRN     20
#define IDS_DNDMMISMATCH     21
#define IDS_CREATEICFAILURE  22
#define IDS_PRINTERNOTFOUND  23
#define IDS_NOFONTS          24
#define IDS_SUBCLASSFAILURE  25
#define IDS_INVALIDFILENAME  26
#define IDS_BUFFERTOOSMALL   27
#define IDS_FILTERSTRING     28
#define IDS_UNKNOWNERROR     29

// constants

#define FILE_LEN            128

// Function prototypes

// procs
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK About(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EnterNew(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileOpenHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileSaveHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FindTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintDlgHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM);

//functions
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
BOOL OpenNewFile( HWND );
BOOL SaveToFile( HWND );
BOOL SaveAs( HWND );
void SearchFile( LPFINDREPLACE );
BOOL ChooseNewFont( HWND );
BOOL ChooseNewColor( HWND );
void PrintFile( HWND );
void CallFindText( HWND );
void CallReplaceText( HWND );
void ProcessCDError(DWORD, HWND);

void    ColorSpaceControl( LPSTR FileName, LPSTR SaveFileName, WORD InpDrvClrSp,
        DWORD Intent, WORD CSAType, BOOL AllowBinary);
void    CreateCRDControl( LPSTR FileName, LPSTR SaveFileName,
        DWORD Inter_Intent, BOOL AllowBinary);
void    CreateINTENTControl(LPSTR FileName, LPSTR SaveFileName, DWORD Inter_Intent);
void    CreateProfCRDControl(LPSTR DevProfile, LPSTR TargetProfile, 
        LPSTR SaveFileName, DWORD Inter_Intent, BOOL AllowBinary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDD_DIALOG1                     101
#define IDI_ICON1                       102
#define IDC_EDIT1                       1000
#define IDC_BUTTON1                     1001
#define IDC_EDIT2                       1002
#define IDC_EDIT3                       1003
#define IDC_BUTTON2                     1004
#define IDC_BUTTON3                     1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         106
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 17

typedef struct tagHOSTCLUT {
    USHORT         size;
    USHORT         wdummy;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                                CHANDLE cpDev,
								CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;  
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
DWORD   FAR  PASCAL crc32(MEMPTR buff, DWORD  length);
#endif
//SRGB98
BOOL    EXTERN InvertMatrix (double FAR * lpInMatrix, double FAR * lpOutMatrix);
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);
BOOL   DoesTRCAndColorantTagExist(CHANDLE cp);
BOOL   GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize);
#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "icmstr.h"
#include "profcrd.h"

#define _ICMSEG  ""
#define _ICM2SEG ""
#define  ICMSEG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\dllmain.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dllmain.c
//
//  PURPOSE:  Contains the DLL's entry point function.
//
//  FUNCTIONS:
//    DLLMain   - The entry point function
//

#include <windows.h>


//
//  FUNCTION: DLLMain(HINSTANCE, DWORD, LPVOID)
//
//  PURPOSE:  Called when DLL is loaded by a process, and when new
//    threads are created by a process that has already loaded the
//    DLL.  Also called when threads of a process that has loaded the
//    DLL exit cleanly and when the process itself unloads the DLL.
//
//  PARAMETERS:
//    hDLLInst    - Instance handle of the DLL
//    fdwReason   - Process attach/detach or thread attach/detach
//    lpvReserved - Reserved and not used
//
//  RETURN VALUE:  (Used only when fdwReason == DLL_PROCESS_ATTACH)
//    TRUE  -  Used to signify that the DLL should remain loaded.
//    FALSE -  Used to signify that the DLL should be immediately unloaded.
//
//  COMMENTS:
//
//    If you want to use C runtime libraries, keep this function named
//    "DllMain" and you won't have to do anything special to initialize
//    the runtime libraries.
//
//    When fdwReason == DLL_PROCESS_ATTACH, the return value is used to
//    determine if the DLL should remain loaded, or should be immediately
//    unloaded depending upon whether the DLL could be initialized properly.
//    For all other values of fdwReason, the return value is ignored.
//

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.

            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
BOOL GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve);
SINT CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary, BOOL BackupCSA);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
SINT    BeginGlobalDict(MEMPTR lpMem);
SINT    EndGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;
typedef     SFLOAT __huge   *PFLOAT;
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\main.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************************************************************
*
*
*    PROGRAM: CmnDlg.c
*
*    PURPOSE: Sample demonstrating the use of the common dialogs in Windows
*
*    FUNCTIONS:
*
*        WinMain() - calls initialization function, processes message loop
*        InitApplication() - initializes window data and registers window
*        InitInstance() - saves instance handle and creates main window
*        MainWndProc() - processes messages
*        About() - processes messages for "About" dialog box
*        OpenNewFile() - opens a new file
*        SaveToFile() - saves the current text buffer to the current filename
*        SaveAs() - saves the current text buffer to a new file name
*        EnterNew() - to enter new text into the text buffer
*        FileOpenHookProc() - Hook procedure for GetOpenFileName() common dialog
*        FileSaveHookProc() - Hook procedure for GetSaveFileName() common dialog
*        ChooseFontHookProc() - Hook procedure for ChooseFont() common dialog
*        FindTextHookProc() - Hook procedure for FindText() common dialog
*        ReplaceTextHookProc() - Hook procedure for the ReplaceText() common dialog
*        PrintDlgHookProc() - Hook procedure for the PrintDlg() common dialog
*        PrintSetupHookProc() - Hook procedure for the PrintDlg() setup common dialog
*        SearchFile() - Searches for the specified text in the file buffer
*        ChooseNewFont() - chooses a new font for display
*        ChooseNewColor() - chooses a new color for display
*        PrintFile() - prints the current text in the file buffer
*        CallFindText() - calls the FindText() common dialog function
*        CallReplaceText() - calls the ReplaceText() common dialog function
*        ProcessCDError() - uses CommonDialogExtendedError() to output useful error messages
*
*    COMMENTS:
*
*
*        The common dialog APIs demonstrated in the sample include:
*
*            ChooseColor()
*            ChooseFont()
*            FindText()
*            GetOpenFileName()
*            GetSaveFileName()
*            PrintDlg()
*            ReplaceText()
*
*
*        Each dialog box is demonstrated being used in three different ways:
*        standard, using a modified template and using a hook function.
*
*
****************************************************************************/

#include <windows.h>    // includes basic windows functionality
#include <commdlg.h>    // includes common dialog functionality
#include <dlgs.h>       // includes common dialog template defines
#include <stdio.h>      // includes standard file i/o functionality
#include <string.h>     // includes string functions
#include <cderr.h>      // includes the common dialog error codes
#include "main.h"       // includes my common dialog functions
#include "resource.h"

HANDLE       hInst;
OPENFILENAME OpenFileName;
CHAR         szDirName[256]   = "";
CHAR         szFile[256]      = "\0";
CHAR         szFileTitle[256];

// Filter specification for the OPENFILENAME struct
// This is portable for i386 and MIPS
// Leaving out the \0 terminator will cause improper DWORD alignment
// and cause a failure under MIPS
CHAR szFilter[] = "Text Files (*.ICM)\0*.ICM\0All Files (*.*)\0*.*\0";
CHAR szSaveFilter[] = "Text Files (*.CSA)\0*.CSA\0All Files (*.*)\0*.*\0";

CHAR         FileBuf[FILE_LEN];
DWORD        dwFileSize;
UINT         FindReplaceMsg;
CHAR         szFindString[64]   = "";
CHAR         szReplaceString[64]   = "";
FINDREPLACE  frText;
LPFINDREPLACE lpFR;
CHAR *       lpBufPtr = FileBuf;
CHOOSEFONT   chf;
CHOOSECOLOR  chsclr;
COLORREF     crColor;
LOGFONT      lf;
WORD         wMode = IDM_CUSTOM;
WORD         wAsciiMode = IDM_ASCII;
WORD         wIntentMode = IDM_PERCEPUAL;
WORD         wCSAMode = IDM_AUTO;
WORD         wInpDrvClrSp = IDM_INP_AUTO;
WORD         wCSAorCRD = IDM_CSA;
HWND         hDlgFR = NULL;
PRINTDLG     pd;

BOOL         AllowBinary = FALSE;
DWORD        Intent = 0;
HWND         hWnd; 

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam);

/****************************************************************************
*
*    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
*
*    PURPOSE: calls initialization function, processes message loop
*
*    COMMENTS:
*
*
****************************************************************************/

int PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    MSG msg;                         /* message                      */

    if (!hPrevInstance)                  /* Other instances of app running? */
        if (!InitApplication(hInstance)) /* Initialize shared things */
            return (FALSE);              /* Exits if unable to initialize     */

    hInst = hInstance;

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    // register window message for FindText() and ReplaceText() hook procs
    FindReplaceMsg = RegisterWindowMessage( (LPSTR) FINDMSGSTRING );

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,        /* message structure                      */
            NULL,                  /* handle of window receiving the message */
            0,                     /* lowest message to examine              */
            0))                    /* highest message to examine             */
        if ( !hDlgFR || !IsWindow(hDlgFR) || !IsDialogMessage( hDlgFR, &msg ) )
            {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
            }
    return (msg.wParam);           /* Returns the value from PostQuitMessage */

    // avoid compiler warnings at W3
    lpCmdLine;
}


/****************************************************************************
*
*    FUNCTION: InitApplication(HANDLE)
*
*    PURPOSE: Initializes window data and registers window class
*
*    COMMENTS:
*
*        In this function, we initialize a window class by filling out a data
*        structure of type WNDCLASS and calling the Windows RegisterClass()
*        function.
*
****************************************************************************/

BOOL InitApplication(HANDLE hInstance)       /* current instance             */
{
    WNDCLASS  wc;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;                       /* Class style(s).                    */
    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = LoadIcon(NULL, IDI_ICON1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName =  "CmnDlgMenu";   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "CmnDlgWClass"; /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}


/****************************************************************************
*
*    FUNCTION:  InitInstance(HANDLE, int)
*
*    PURPOSE:  Saves instance handle and creates main window
*
*    COMMENTS:
*
*        In this function, we save the instance handle in a static variable and
*        create and display the main program window.
*
****************************************************************************/

BOOL InitInstance(
    HANDLE          hInstance,          /* Current instance identifier.       */
    int             nCmdShow)           /* Param for first ShowWindow() call. */
{
    HWND            hWND;               /* Main window handle.                */

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    hWND = CreateWindow(
        "CmnDlgWClass",                 /* See RegisterClass() call.          */
        "CIEBASED_CDEF Color Space",    /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWND)
        return (FALSE);
     
    hWnd = hWND;
    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */
    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************
*
*    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages
*
*    COMMENTS:
*
*        This function processes all messags sent to the window.  When the
*        user choses one of the options from one of the menus, the command
*        is processed here and passed onto the function for that command.
*        This function also processes the special "FindReplace" message that
*        this application registers for hook processing of the FindText()
*        and ReplaceText() common dialog functions.
*
****************************************************************************/

LRESULT CALLBACK MainWndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    FARPROC lpProcAbout;          /* pointer to the "About" function */
    FARPROC lpProcOpen;
    FARPROC lpProcEnterNew;       /* pointer to the "EnterNew" function */
    HDC hDC;
    PAINTSTRUCT ps;
    INT nDrawX;
    INT nDrawY;
    HFONT hFont;
    HANDLE Handle;
    static BOOL NewFont;

    switch (message) {


        case WM_CREATE:
            //initialize the output on the screen
            strcpy( FileBuf, " ");
            lpBufPtr = FileBuf;
            dwFileSize = strlen(FileBuf);
            crColor = 0;
            NewFont = FALSE;
            break;


        case WM_PAINT:
            /* Set up a display context to begin painting */
            hDC = BeginPaint (hWnd, &ps);

            /* Initialize drawing position to 1/4 inch from the top  */
            /* and from the left of the top, left corner of the      */
            /* client area of the main windows.                      */
            nDrawX = GetDeviceCaps(hDC, LOGPIXELSX) / 4;   /* 1/4 inch */
            nDrawY = GetDeviceCaps(hDC, LOGPIXELSY) / 4;   /* 1/4 inch */

            if ( NewFont == TRUE )
            {
                hFont = CreateFontIndirect( &lf );
                Handle = SelectObject( hDC, hFont );
            }

            SetTextColor( hDC, crColor );

            // end painting and release hDC
            EndPaint( hWnd, &ps );
            break;


        case WM_COMMAND:           /* message: command from application menu */

            switch( LOWORD( wParam ))
            {
                case IDM_OPENFILE:
                   lpProcOpen = MakeProcInstance((FARPROC)OpenFiles, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "OPENFILES",             /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcOpen);    /* About() instance address */

                    FreeProcInstance(lpProcOpen);
                    break;

                case IDM_EXIT:
                    PostQuitMessage(0);
                    break;

                case IDM_CHOOSECOLOR:
                    if (ChooseNewColor( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );
                    break;

                case IDM_CHOOSEFONT:
                    if (NewFont = ChooseNewFont( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );

                    break;

                case IDM_FINDTEXT:
                    CallFindText( hWnd );
                    break;

                case IDM_REPLACETEXT:
                    CallReplaceText( hWnd );
                    break;

                case IDM_STANDARD:
                  // enable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_ENABLED );
                    // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_HOOK:
                case IDM_CUSTOM:
                    // disable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_GRAYED );
                     // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ENTERNEW:
                    lpProcEnterNew = MakeProcInstance((FARPROC)EnterNew, hInst);

                    if (DialogBox(hInst,                 /* current instance         */
                        "EnterNewBox",           /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcEnterNew) == TRUE)

                        InvalidateRect( hWnd, NULL, TRUE );

                    FreeProcInstance(lpProcEnterNew);
                    break;

                case IDM_PERCEPUAL:
                    Intent = 0;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_COLOR:
                    Intent = 1;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_SATURATION:
                    Intent = 2;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ASCII:
                    AllowBinary = FALSE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_BINARY:
                    AllowBinary = TRUE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_AUTO:
                case IDM_ABC:
                case IDM_DEFG:
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_INP_AUTO:
                case IDM_INP_GRAY:
                case IDM_INP_RGB:
                case IDM_INP_CMYK:
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wInpDrvClrSp = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_CSA:
                case IDM_CRD:
				case IDM_PROFCRD:
                case IDM_INTENT:
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAorCRD = LOWORD(wParam);
                    if ((wCSAorCRD == IDM_CRD) || (wCSAorCRD == IDM_INTENT))
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_GRAYED );
                    }
                    else
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_ENABLED );
                    }

                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ABOUT:
                    lpProcAbout = MakeProcInstance((FARPROC)About, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "AboutBox",              /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcAbout);   /* About() instance address */

                    FreeProcInstance(lpProcAbout);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));

            }
            break;

        case WM_DESTROY:                  /* message: window being destroyed */
            PostQuitMessage(0);
            break;


        default:
            // Handle the special findreplace message (FindReplaceMsg) which
            // was registered at initialization time.
            if ( message == FindReplaceMsg )
            {
                if ( lpFR = (LPFINDREPLACE) lParam )
                    {
                    if (lpFR->Flags & FR_DIALOGTERM )  // terminating dialog
                        return (0);
                    SearchFile( lpFR );
                    InvalidateRect( hWnd, NULL, TRUE );
                    }
                return (0);
            }

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


/****************************************************************************
*
*    FUNCTION: EnterNew(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "EnterNew" dialog box
*
*    COMMENTS:
*
*        This function allows the user to enter new text in the current
*        window.  This text is stored in the global current buffer.
*
****************************************************************************/

BOOL CALLBACK EnterNew(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR Buf[FILE_LEN-1];

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, IDEDIT, Buf, FILE_LEN-1);
                strcpy( FileBuf, Buf);
                lpBufPtr = FileBuf;
                dwFileSize = strlen(FileBuf);
                EndDialog( hDlg, TRUE );
                return (TRUE);
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {   /* System menu close command? */
                EndDialog(hDlg, FALSE);       /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}


/****************************************************************************
*
*    FUNCTION: About(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "About" dialog box
*
*    COMMENTS:
*
*       No initialization is needed for this particular dialog box, but TRUE
*       must be returned to Windows.
*
*       Wait for user to click on "Ok" button, then close the dialog box.
*
****************************************************************************/

BOOL WINAPI About(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK          /* "OK" box selected?        */
                || LOWORD(wParam) == IDCANCEL) {        /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}

/****************************************************************************
*
*    FUNCTION: FileOpenHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for GetFileNameOpen() common dialog box
*
*    COMMENTS:
*
*        This function will prompt the user if they are sure they want
*        to open the file if the OFN_ENABLEHOOK flag is set.
*
*        If the current option mode is CUSTOM, the user is allowed to check
*        a box in the dialog prompting them whether or not they would like
*        the file created.  If they check this box, the file is created and
*        the string 'Empty' is written to it.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FileOpenHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    int hFile;
    CHAR szTempText[256];
    CHAR szString[256];
    OFSTRUCT OfStruct;

    switch (message)
    {

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                        sizeof( szTempText ) - 1);

                if ( OpenFileName.Flags & OFN_PATHMUSTEXIST )
                {
                    sprintf( szString, "Are you sure you want to open %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )

                        break;
                    return (TRUE);
                }

                // check to see if the Create File box has been checked
                if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                    BM_GETCHECK, 0, 0L )) == TRUE )
                {
                    // if so, create the file
                    if ((hFile = OpenFile(szTempText,
                        &OfStruct,
                        OF_CREATE)) == -1)
                    {
                        MessageBox( hDlg,
                            "Directory could not be created.",
                            NULL,
                            MB_OK );
                        return (FALSE);
                    }

                    strcpy(FileBuf, "Empty");
                    lpBufPtr = FileBuf;
                    dwFileSize = strlen(FileBuf);
                    if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
                        MessageBox( hDlg, "Error writing file.", NULL, MB_OK );

                    // close the file
                    _lclose( hFile );
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: OpenNewFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to open a file and opens it.
*
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure and calls
*        the GetOpenFileName() common dialog function.  This function will
*        work regardless of the mode: standard, using a hook or using a
*        customized template.
*
*    RETURN VALUES:
*        TRUE - The file was opened successfully and read into the buffer.
*        FALSE - No files were opened.
*
****************************************************************************/
BOOL OpenNewFile( HWND hWnd )
{
   strcpy( szFile, "");
   strcpy( szFileTitle, "");

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.lpstrFile         = szFile;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.lpstrFileTitle    = szFileTitle;
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Open a File";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.icm";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_ENABLEHOOK |
                OFN_HIDEREADONLY | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if (GetOpenFileName(&OpenFileName))
   {
   }
   else
   {
      ProcessCDError(CommDlgExtendedError(), hWnd );
      return FALSE;
   }
   return TRUE;
}

/****************************************************************************
*
*    FUNCTION: SaveToFile( HWND )
*
*    PURPOSE:  Saves the current buffer to the current file.
*
*    COMMENTS:
*
*        This function will save the current text buffer into the file
*        specified from the GetSaveFileName() common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveToFile( HWND hWnd )
{
   int hFile;
   OFSTRUCT OfStruct;
   WORD wStyle;
   CHAR buf[256];

   if (OpenFileName.Flags | OFN_FILEMUSTEXIST)
        wStyle = OF_READWRITE;
   else
        wStyle = OF_READWRITE | OF_CREATE;

   if ((hFile = OpenFile(OpenFileName.lpstrFile, &OfStruct,
         wStyle)) == -1)
   {
      sprintf( buf, "Could not create file %s", OpenFileName.lpstrFile );
      MessageBox( hWnd, buf, NULL, MB_OK );
      return FALSE;
   }
   // write it's contents into a file
   if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
   {
      MessageBox( hWnd, "Error writing file.", NULL, MB_OK );
      return FALSE;
   }

   // close the file
   _lclose( hFile );

   sprintf( buf, "%s", OpenFileName.lpstrFile );
   MessageBox( hWnd, buf, "File Saved", MB_OK );
   return TRUE;
}


/****************************************************************************
*
*    FUNCTION: FileSaveHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for FileSave common dialog box
*
*    COMMENTS:
*
*        This hook procedure prompts the user if they want to save the
*        current file.  If they choose YES, the file is saved and the dialog
*        is dismissed.  If they choose NO, they are returned to the
*        GetSaveFileName() common dialog.
*
*        If the current mode calls for a customized template, this function
*        will test the 'Create File?' checkbox.  If the user choses no, the
*        OFN_FILEMUSTEXIST flag is set.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
*
****************************************************************************/

BOOL CALLBACK FileSaveHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR szTempText[256];
    CHAR szString[256];

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                    sizeof( szTempText ) - 1);
                if ( OpenFileName.Flags & OFN_ENABLETEMPLATE )
                {
                    // check to see if the Create File box has been checked
                    if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                        BM_GETCHECK, 0, 0L )) == FALSE )
                        OpenFileName.Flags |= OFN_FILEMUSTEXIST;
                    break;

                }
                else
                {
                    sprintf( szString, "Are you sure you want to save %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )
                        break;
                    return(TRUE);
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: SaveAs(HWND)
*
*    PURPOSE:  Invokes the common dialog function to save the current
*              buffer to a file.
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure for any
*        mode selected by the user: standard, using a hook or using a
*        customized template.  It then calls the GetSaveFileName()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveAs( HWND hWnd )
{
   int      i;

//   strcpy( szFile, "");
//   strcpy( szFileTitle, "");

   for ( i = lstrlen(OpenFileName.lpstrFileTitle); i > 0; i--)
   {
       if (OpenFileName.lpstrFileTitle[i] == '.') break;
   }
   i ++;
   if (wCSAorCRD == IDM_CSA)
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'S';
        OpenFileName.lpstrFileTitle[i++] = 'A';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else if ((wCSAorCRD == IDM_CRD) ||
	        (wCSAorCRD == IDM_PROFCRD))
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'R';
        OpenFileName.lpstrFileTitle[i++] = 'D';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else
   {
        OpenFileName.lpstrFileTitle[i++] = 'I';
        OpenFileName.lpstrFileTitle[i++] = 'N';
        OpenFileName.lpstrFileTitle[i++] = 'T';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   strcpy(OpenFileName.lpstrFile, OpenFileName.lpstrFileTitle);

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szSaveFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Save File As";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.csa";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = 0L;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)(FARPROC)NULL;
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if ( GetSaveFileName( &OpenFileName ))
   {
        return (TRUE);
   }
   else
   {
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }

   return (FALSE);
}


/****************************************************************************
*
*    FUNCTION: ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseColor common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the color.  if they choose YES, the color of the
*        text will be changed and the dialog will be dismissed.  If they
*        choose NO, the color will not be changed and the user will be
*        returned to the dialog
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseColorHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the color?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewColor(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new color.
*
*    COMMENTS:
*        This function initializes the CHOOSECOLOR structure for any
*        mode the user chooses: standard, using a hook or using a
*        customized template.  It then calls the ChooseColor()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new color was chosen.
*        FALSE - No new color was chosen.
*
****************************************************************************/
BOOL ChooseNewColor( HWND hWnd )
{

    DWORD dwColor;
    DWORD dwCustClrs[16];
    BOOL fSetColor = FALSE;
    int i;


    for (i=0; i < 15; i++)
        dwCustClrs[i] = RGB( 255, 255, 255);

    dwColor = RGB( 0, 0, 0 );

    chsclr.lStructSize = sizeof(CHOOSECOLOR);
    chsclr.hwndOwner = hWnd;
    chsclr.hInstance = (HANDLE)hInst;
    chsclr.rgbResult = dwColor;
    chsclr.lpCustColors = (LPDWORD)dwCustClrs;
    chsclr.lCustData = 0L;

    switch( wMode )
    {
        case IDM_HOOK:
        case IDM_CUSTOM:
            chsclr.Flags = CC_PREVENTFULLOPEN | CC_ENABLEHOOK;
            chsclr.lpfnHook = (LPCCHOOKPROC)MakeProcInstance(ChooseColorHookProc, NULL);
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_STANDARD:
            chsclr.Flags = CC_PREVENTFULLOPEN;
            chsclr.lpfnHook = (LPCCHOOKPROC)(FARPROC)NULL;
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;


   }

   if ( fSetColor = ChooseColor( &chsclr ))
   {
       crColor = chsclr.rgbResult;
       return (TRUE);
   }
   else
   {
       ProcessCDError(CommDlgExtendedError(), hWnd );
       return FALSE;
   }
}


/****************************************************************************
*
*    FUNCTION: ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseFont common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the font.  if they choose YES, the color of the
*        font will be changed and the dialog will be dismissed.  If they
*        choose NO, the font will not be changed and the user will be
*        returned to the dialog
*
*        If the current mode is set to use a customized template, the
*        color drop down combo box is hidden.
*
*    RETURN VALUES:
*        TRUE - Change the font.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseFontHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (chf.Flags & CF_ENABLETEMPLATE)
            {
                ShowWindow(GetDlgItem(hDlg, stc4), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, cmb4), SW_HIDE);
            }
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the font?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewFont(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new font.
*
*    COMMENTS:
*
*        This function initializes the CHOOSEFONT structure for any mode
*        the user chooses: standard, using a hook or using a customized
*        template.  It then calls the ChooseFont() common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new font was chosen.
*        FALSE - No new font was chosen.
*
****************************************************************************/
BOOL ChooseNewFont( HWND hWnd )
{

   HDC hDC;

   hDC = GetDC( hWnd );
   chf.hDC = CreateCompatibleDC( hDC );
   ReleaseDC( hWnd, hDC );
   chf.lStructSize = sizeof(CHOOSEFONT);
   chf.hwndOwner = hWnd;
   chf.lpLogFont = &lf;
   chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
   chf.rgbColors = RGB(0, 255, 255);
   chf.lCustData = 0;
   chf.hInstance = (HANDLE)hInst;
   chf.lpszStyle = (LPSTR)NULL;
   chf.nFontType = SCREEN_FONTTYPE;
   chf.nSizeMin = 0;
   chf.nSizeMax = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
            chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)NULL;
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK |
              CF_ENABLETEMPLATE;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FORMATDLGORD31);
            break;
   }


   if( ChooseFont( &chf ) == FALSE )
   {
        DeleteDC( hDC );
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }


   DeleteDC( hDC );

   return (TRUE);
}

/****************************************************************************
*
*    FUNCTION: PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for PrintDlg setup common dialog box
*
*    COMMENTS:
*
*        This function processes the hook and customized template for the
*        print setup common dialog box.  If the customized template has
*        been provided, the 'Options' pushbutton is hidden.  If the hook only mode
*        is chosen, a message box is displayed informing the user that the
*        hook has been installed.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintSetupHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLESETUPTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, psh1), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}



/****************************************************************************
*
*    FUNCTION: PrintDlgHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for PrintDlg common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to print.  if they choose YES, the text buf will be printed
*        and the dialog will be dismissed.  If they choose NO, the text buf
*        will not be printeded and the user will be returned to the dialog.
*
*        If the current mode is 'custom', the 'Print to file' and 'Collate
*        Copies' options are hidden.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintDlgHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLEPRINTTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to print?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: PrintFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to print.
*
*    COMMENTS:
*
*        This function initializes the PRINTDLG structure for all modes
*        possible: standard, using a hook or using a customized template.
*        When hook mode is chosen, a hook is installed for both the
*        Print dialog and the Print Setup dialog.  When custom mode is
*        chosen, the templates are enabled for both the print dialog and
*        the Print Setup dialog boxes.
*
*        If the PrintDlg() common dialog returns TRUE, the current
*        text buffer is printed out.
*
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void PrintFile( HWND hWnd )
{


    // initialize PRINTDLG structure
    pd.lStructSize = sizeof(PRINTDLG);
    pd.hwndOwner = hWnd;
    pd.hDevMode = (HANDLE)NULL;
    pd.hDevNames = (HANDLE)NULL;
    pd.nFromPage = 0;
    pd.nToPage = 0;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 0;
    pd.hInstance = (HANDLE)hInst;


    switch( wMode )
    {
        case IDM_STANDARD:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)(FARPROC)NULL;
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)(FARPROC)NULL;
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLEPRINTTEMPLATE |
                PD_ENABLESETUPHOOK | PD_ENABLESETUPTEMPLATE | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)MAKEINTRESOURCE(PRNSETUPDLGORD);
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)MAKEINTRESOURCE(PRINTDLGORD);
            break;

    }

    //print a test page if successful
    if (PrintDlg(&pd) == TRUE)
    {
        Escape(pd.hDC, STARTDOC, 8, "Test-Doc", NULL);

        //Print text
        TextOut(pd.hDC, 5, 5, FileBuf, strlen(FileBuf));

        Escape(pd.hDC, NEWFRAME, 0, NULL, NULL);
        Escape(pd.hDC, ENDDOC, 0, NULL, NULL );
        DeleteDC(pd.hDC);
        if (pd.hDevMode)
            GlobalFree(pd.hDevMode);
        if (pd.hDevNames)
            GlobalFree(pd.hDevNames);
    }
   else
        ProcessCDError(CommDlgExtendedError(), hWnd );
}


/****************************************************************************
*
*    FUNCTION: ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ReplaceText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only active.  Otherwise, if template enabled, hides the
*        Replace All pushbutton, plus the 'Match case' and
*        'Match whole word' check box options.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ReplaceTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
                {
                    ShowWindow( GetDlgItem(hDlg, psh2), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}

/****************************************************************************
*
*    FUNCTION: FindTextHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for FindText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only enabled.  If custom template, hides the 'Match case'
*        and 'Match whole word' options, hides the group box 'Direction'
*        with the radio buttons 'Up' and 'Down'.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FindTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
            {
                ShowWindow(GetDlgItem(hDlg, chx1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, chx2), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad2), SW_HIDE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}


/****************************************************************************
*
*    FUNCTION: CallFindText( HWND )
*
*    PURPOSE:  Initializes and calls the FindText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the FindText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallFindText( HWND hWnd )
{

    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = (LPSTR)NULL;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = 0;
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags =  FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                 FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FINDDLGORD);
            break;
    }

    if ((hDlgFR = FindText(&frText)) == NULL)
        ProcessCDError(CommDlgExtendedError(), hWnd );

}


/****************************************************************************
*
*    FUNCTION: CallReplaceText( HWND )
*
*    PURPOSE:  Initializes and calls the ReplaceText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the ReplaceText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallReplaceText( HWND hWnd )
{
    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = szReplaceString;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = sizeof( szReplaceString );
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(REPLACEDLGORD);
            break;
    }

    if ( (hDlgFR = ReplaceText( &frText )) == NULL )
            ProcessCDError(CommDlgExtendedError(), hWnd );

}

/****************************************************************************
*
*    FUNCTION: SearchFile(LPFINDREPLACE)
*
*    PURPOSE:  Does the find/replace specified by the Find/ReplaceText
*        common dialog.
*
*    COMMENTS:
*
*        This function does the lease necessary to implement find and
*        replace by calling existing c-runtime functions.  It is in
*        no way intended to demonstrate either correct or efficient
*        methods for doing textual search or replacement.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void SearchFile( LPFINDREPLACE lpFR )
{

    CHAR Buf[FILE_LEN];
    CHAR *pStr;
    int count, newcount;
    static BOOL bFoundLast = FALSE;
    
if ( lpFR->Flags & ( FR_FINDNEXT | FR_REPLACE | FR_REPLACEALL ) )
    {
    memset(Buf, '\0', FILE_LEN -1);
    if ( bFoundLast )
        {
        if ( (lpBufPtr != FileBuf) && (lpFR->Flags & FR_FINDNEXT) )
            lpBufPtr++;
        bFoundLast = FALSE;
        }

    if (!*lpBufPtr || !(pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) )
        {
        sprintf( Buf, "'%s' not found!", lpFR->lpstrFindWhat );
        lpBufPtr = FileBuf;
        MessageBox( lpFR->hwndOwner, Buf, "No luck", MB_OK | MB_TASKMODAL);
        }
    else
        {
        if ( lpFR->Flags & FR_FINDNEXT )
            {
            sprintf( Buf, "Found Next '%s'!\nSubstring: '%.10s'", 
                     lpFR->lpstrFindWhat, pStr );
            lpBufPtr = pStr;
            bFoundLast = TRUE;
            MessageBox( lpFR->hwndOwner, Buf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACE )
            {
            // replace string specified in the replace with found string
            // copy up to found string into new buffer
            for( count=0; 
                 *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                 count++);
                strncpy( Buf, lpBufPtr, count );
            // concatenate new string
            strcat( Buf, lpFR->lpstrReplaceWith );
            // copy rest of string (less the found string)
            newcount = count + strlen(lpFR->lpstrFindWhat);
            strcat( Buf, lpBufPtr+newcount);
            strcpy( lpBufPtr, Buf );
            lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
            dwFileSize = strlen(FileBuf);
            MessageBox( lpFR->hwndOwner, FileBuf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACEALL)
            {
            do
                {
                // replace string specified in the replace with found string
                // copy up to found string into new buffer
                memset(Buf, '\0', FILE_LEN -1);
                for( count=0; 
                     *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                     count++);
                     strncpy( Buf, lpBufPtr, count );
                // concatenate new string
                strcat( Buf, lpFR->lpstrReplaceWith );
                // copy rest of string (less the found string)
                newcount = count + strlen(lpFR->lpstrFindWhat);
                strcat( Buf, lpBufPtr + newcount);
                strcpy( lpBufPtr, Buf );
                lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
                }
            while ( *lpBufPtr && 
                    (pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) );
            dwFileSize = strlen(FileBuf);
            lpBufPtr = FileBuf;
            MessageBox( lpFR->hwndOwner, FileBuf, 
                        "Success!", MB_OK | MB_TASKMODAL );
            }

        }
    }
}


/****************************************************************************
*
*    FUNCTION: ProcessCDError(DWORD)
*
*    PURPOSE:  Processes errors from the common dialog functions.
*
*    COMMENTS:
*
*        This function is called whenever a common dialog function
*        fails.  The CommonDialogExtendedError() value is passed to
*        the function which maps the error value to a string table.
*        The string is loaded and displayed for the user.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
   WORD  wStringID;
   CHAR  buf[256];

   switch(dwErrorCode)
      {
         case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break;
         case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break;
         case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break;
         case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break;
         case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break;
         case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break;
         case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break;
         case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break;
         case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break;
         case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break;
         case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break;
         case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break;
         case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break;
         case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break;
         case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break;
         case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break;
         case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break;
         case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break;
         case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break;
         case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break;
         case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break;
         case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break;
         case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break;
         case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break;
         case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break;
         case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break;
         case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break;

         case 0:   //User may have hit CANCEL or we got a *very* random error
            return;

         default:
            wStringID=IDS_UNKNOWNERROR;
      }

   LoadString(NULL, wStringID, buf, sizeof(buf));
   MessageBox(hWnd, buf, NULL, MB_OK);
   return;
}

/***********************************************************************/

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    int    Length;
    char   DevProfileName[FILE_LEN];
    char   TargetProfileName[FILE_LEN];
    char   OutputFileName[FILE_LEN];
    WORD   InpClrSp;

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: 
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile)); 
                    break;
                case IDC_BUTTON2:
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT2, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDC_BUTTON3:
                    if ( SaveAs( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT3, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDOK:
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXT, Length + 1, (long)(DevProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXT, Length + 1, (long)(TargetProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXT, Length + 1, (long)(OutputFileName));
                    switch (wInpDrvClrSp)
                    {
                        case IDM_INP_AUTO: InpClrSp = 0; break;
                        case IDM_INP_GRAY: InpClrSp = 1; break;
                        case IDM_INP_RGB:  InpClrSp = 3; break;
                        case IDM_INP_CMYK: InpClrSp = 4; break;
                        default: InpClrSp = 0; break;
                    }
                    if (wCSAorCRD == IDM_CSA)
                    {
                        ColorSpaceControl(DevProfileName, OutputFileName,
                            InpClrSp, Intent, wCSAMode, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_CRD)
                    {
                        CreateCRDControl(DevProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_PROFCRD)
                    {
                        CreateProfCRDControl(DevProfileName, 
                            TargetProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else 
                    {
                        CreateINTENTControl(DevProfileName, OutputFileName, Intent);
                    }

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                    return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


//typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;


/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

//#define CS_ENABLE       1
//#define CS_DISABLE      2
//#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#ifndef ICMDLL
BOOL ProfileSelection(LPPDEVICE lppd, LPSTR lpProfileName);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\dec97\test\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    TransformPQR[]      ;
extern  char _far    CSAName[]           ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;
extern  char _far    IntentType[]        ;
extern  char _far    IntentPer[]         ;
extern  char _far    IntentSat[]         ;
extern  char _far    IntentACol[]        ;
extern  char _far    IntentRCol[]        ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    MatrixPQR[]         ;
extern  char _far    RangePQR[]          ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;
 
extern  char _far    AdobeCSA[]          ; 
extern  char _far    AdobeCRD[]          ; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\csprof.c ===
#include "generic.h"

#pragma code_seg(_ICM2SEG)
#pragma optimize("",off)

#define TempBfSize 128
#define LINELENG   128
#ifdef ICMDLL
#define ICM2SEG
#endif

static  char    ICM2SEG NewLine[]       = "\n" ;
static  char    ICM2SEG ASCII85DecodeBegine[] = "<~";
static  char    ICM2SEG ASCII85DecodeEnd[] = "~> cvx exec ";

//******************************************************************
//   Local functions to deal with output to the memory buffer

static  SINT    CPLastError;

BOOL    EXTERN     SetCPLastError(SINT LastError)
{
    CPLastError = LastError;
    return(TRUE);
}

SINT    EXTERN     GetCPLastError()
{
    return(CPLastError);
}

BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH)
{
    HGLOBAL hMem;
    LPVOID  lpMem;

    *hMemory = 0;
    if(lpMH == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hMem = GlobalAlloc(GHND, Size) ;
    if(hMem == 0 )
    {
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }

    lpMem = GlobalLock(hMem);
    if(lpMem == NULL )
    {
        GlobalFree(hMem);
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }
    *lpMH = (MEMPTR)lpMem ;
    *hMemory = hMem;
    return (TRUE);
}

BOOL    EXTERN MemFree(HGLOBAL hMem)
{
    if(hMem == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    GlobalUnlock(hMem);
    GlobalFree(hMem) ;
    return(TRUE);
}

//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
#ifndef ICMDLL
BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    DWORD       dwFileSize;

    *phMem = 0;
    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hFile = _lopen(filename, READ );
    if( hFile == HFILE_ERROR )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }

    dwFileSize = _lseek(hFile, 0, SEEK_END);
    _lseek(hFile, 0, SEEK_SET);

    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    if( (Res == HFILE_ERROR) ||
        (Res != sizeof(CPHeader)) )
    {
        _lclose(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }
    
    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        _lclose(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    if (dwFileSize == 0xFFFFFFFF)
        CPSize = ui32toSINT(CPHeader.size);
    else
        CPSize = (SINT)dwFileSize;
    
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
         _lseek(hFile, 0L, SEEK_SET);

        while(CPSize)
        {
            Res = _lread(hFile, (LPVOID) mpCP, 4096);
            if (Res == HFILE_ERROR) 
            {
                _lclose(hFile);
                SetCPLastError(CP_FILE_READ_ERR);
                return(FALSE);
            }
            mpCP    += Res;
            CPSize  -= Res;
        }
    }else
    {
        *phMem = 0;
        _lclose(hFile);
        return(FALSE);
    }
    _lclose(hFile);
    return (TRUE);
}

#else
//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HANDLE      hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    BOOL        Success;
    DWORD       dwFileSize;

    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    hFile = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }
    
    dwFileSize = GetFileSize(hFile, NULL);

    Success = ReadFile(hFile, (LPVOID) &CPHeader, sizeof(CPHeader), &Res, NULL);
    if( ( !Success ) || (Res != sizeof(CPHeader)) )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    if (dwFileSize == 0xFFFFFFFF)
        CPSize = ui32toSINT(CPHeader.size);
    else
        CPSize = (SINT)dwFileSize;

    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
        SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        Success = ReadFile(hFile, (LPVOID) (LPVOID)mpCP, CPSize, &Res, NULL);
        if (!Success) 
        {
            CloseHandle(hFile);
            SetCPLastError(CP_FILE_READ_ERR);
            return(FALSE);
        }
    }else
    {
        CloseHandle(hFile);
        return(FALSE);
    }
    CloseHandle(hFile);
    return (TRUE);
}
#endif

BOOL    EXTERN FreeCP(HGLOBAL hMem)
{
    return( MemFree(hMem) );
}


BOOL    EXTERN GetCPElementCount(CHANDLE CP, LPSINT lpCount)
{
    lpcpTagList lpTL;
    if (lpCount == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    *lpCount = ui32toSINT(lpTL->count);
    return(TRUE);
}


BOOL    EXTERN GetCPElementInfo(CHANDLE CP, SINT Index,
                                LPMEMPTR lpTagData, LPMEMPTR lpElemData)
{
    SINT    Count;
    lpcpTagList lpTL;

    if ( (lpTagData == NULL) || (lpElemData == NULL) )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    if ( Count <= Index )
    {
        SetCPLastError(CP_OUT_OF_RANGE_ERR);
        return(FALSE);
    }
    *lpTagData      = ((MEMPTR) &(lpTL->tags[0])) + (Index * sizeof(icTag)) ;
    *lpElemData     = ((MEMPTR) CP) +
                                ui32toSINT( ((lpcpTag)*lpTagData)->offset);
    return(TRUE);
}


/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE CP)
{
    BOOL    Result;
    CSIG    ProfileClass;

    if(GetCPClass(CP, (LPCSIG) &ProfileClass) )
    {
        // All profiles must have a ProfileDescription and
        //  a Copyright  tags.

        if( !DoesCPTagExist(CP, icSigProfileDescriptionTag) || 
            !DoesCPTagExist(CP, icSigCopyrightTag ) )
        {
            SetCPLastError(CP_NOT_FOUND_ERR);
            return(FALSE);
        }

        // All profiles, except Device-link, must have a mediaWhitePoint Tag
        switch( ProfileClass )
        {
            case     icSigLinkClass :        /* 'link' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigProfileSequenceDescTag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                break;

            case     icSigInputClass:       /* 'scnr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) ||
                    DoesCPTagExist(CP, icSigAToB0Tag)      )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigDisplayClass:     /* 'mntr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigOutputClass:      /* 'prtr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                          DoesCPTagExist(CP, icSigAToB1Tag) &&
                          DoesCPTagExist(CP, icSigAToB2Tag) &&
                          DoesCPTagExist(CP, icSigBToA0Tag) &&
                          DoesCPTagExist(CP, icSigBToA1Tag) &&
                          DoesCPTagExist(CP, icSigBToA2Tag) &&
                          DoesCPTagExist(CP, icSigGamutTag) 
                        )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigAbstractClass:    /* 'abst' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigColorSpaceClass:  /* 'spac' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigBToA0Tag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            default:
                Result = FALSE;
                break;
        }
    }else
    {
        return(FALSE);
    }
    if( Result == FALSE )
    {
        SetCPLastError(CP_NOT_FOUND_ERR);
    }
    return(Result);
}

BOOL    EXTERN DoesCPTagExist(CHANDLE CP, CSIG CPTag)
{
    SINT    Count;
    MEMPTR   Data;
    lpcpTagList lpTL;

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ; 
    while ( Count-- )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }
    return(FALSE);
}


BOOL    EXTERN GetCPTagIndex(CHANDLE CP, CSIG CPTag, LPSINT lpIndex)
{
    SINT    Count;
    MEMPTR   Data;
    SINT    i;
    lpcpTagList lpTL;

    if (lpIndex == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ;

    for (i = 0; i < Count; i++ )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            *lpIndex = i;
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }

    SetCPLastError(CP_NOT_FOUND_ERR);
    return(FALSE);
}



BOOL    EXTERN GetCPTagSig(CHANDLE CP, SINT Index, LPCSIG lpCPTag)
{
    MEMPTR   TagData, ElemData;
    if (lpCPTag == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCPTag    = SigtoCSIG( ((lpcpTag)TagData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}

//***************************************************************
//      Function applicable to the elements
//
//***************************************************************

BOOL    EXTERN GetCPElementType(CHANDLE CP, SINT Index, LPCSIG lpCSig)
{
    MEMPTR   TagData, ElemData;
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCSig    = SigtoCSIG( ((lpcpTagBase)ElemData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}



BOOL    EXTERN GetCPElementSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR   TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size );
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL    EXTERN GetCPElementDataSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR  TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
//  Changed by jjia 8/24/95
//        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size ) -
//                                             sizeof(lpcpTagBase);
    *lpSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

//***************************************************************
//  The difference between GetCPElement and GetCPElementData
//  is that GetCPElement reads all fields of the element,
//  including the data tag, reserved fields and element data,
//  while GetCPElementData only reads the actual data.
//  Number of bytes that are required to hold the whole data element can be
//  obtained by calling the function GetCPElementSize().
//  The actulal number of data bytes is determined by
//  the call to GetCPElementDataSize().
//***************************************************************
BOOL    EXTERN GetCPElement(CHANDLE CP, SINT Index,
                               MEMPTR lpData, SINT Size)
{
    SINT        ElemSize;
    MEMPTR      TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size);
    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }
    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);

}


BOOL    EXTERN GetCPElementData(CHANDLE CP, SINT Index,
                                MEMPTR lpData, SINT Size)
{
    SINT     ElemSize;
    MEMPTR   TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
//  Changed by jjia 8/24/95
//    ElemData    +=  sizeof(lpcpTagBase);
//    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
//                     sizeof(lpcpTagBase);
    ElemData    +=  sizeof(icTagBase) + sizeof(icUInt32Number);
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);

    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }

    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);
}

// Check the data format is binary or ascii    8/22/95  jjia

BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType)
{
    MEMPTR   TagData, ElemData;

    if (lpDataType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemData    +=  sizeof(icTagBase);
    *lpDataType = ui32toSINT( ((icData __huge *)ElemData)->dataFlag);
    return (TRUE);
}

BOOL    EXTERN ValidateCPElement(CHANDLE CP, SINT Index)
{
    CSIG    TagSig, DataSig;
    BOOL    Result;
    if( GetCPTagSig(CP, Index, (LPCSIG) &TagSig) &&
        GetCPElementType(CP, Index, (LPCSIG) &DataSig) )
    {
        switch(TagSig)
        {
            case     icSigAToB0Tag:
            case     icSigAToB1Tag:
            case     icSigAToB2Tag:
            case     icSigBToA0Tag:
            case     icSigBToA1Tag:
            case     icSigBToA2Tag:
            case     icSigGamutTag:
            case     icSigPreview0Tag:
            case     icSigPreview1Tag:
            case     icSigPreview2Tag:
                Result = (DataSig == icSigLut16Type) ||
                         (DataSig == icSigLut8Type) ;
                break;

            case     icSigRedColorantTag: 
            case     icSigGreenColorantTag:
            case     icSigBlueColorantTag:
            case     icSigLuminanceTag:
            case     icSigMediaBlackPointTag:
            case     icSigMediaWhitePointTag:
                Result = (DataSig == icSigXYZType);
                break;

            case     icSigRedTRCTag:
            case     icSigGreenTRCTag:
            case     icSigBlueTRCTag:
            case     icSigGrayTRCTag:
                Result = (DataSig == icSigCurveType);
                break;

            case     icSigPs2CRD0Tag:
            case     icSigPs2CRD1Tag:
            case     icSigPs2CRD2Tag:
            case     icSigPs2CRD3Tag:
            case     icSigPs2CSATag:
            case     icSigPs2Intent0Tag:
            case     icSigPs2Intent1Tag:
            case     icSigPs2Intent2Tag:
            case     icSigPs2Intent3Tag:
                Result = (DataSig == icSigDataType);
                break;

            case     icSigCharTargetTag:
            case     icSigCopyrightTag:
                Result = (DataSig == icSigTextType);
                break;

            case     icSigCalibrationDateTimeTag:
                Result = (DataSig == icSigDateTimeType);
                break;

            case     icSigDeviceMfgDescTag:
            case     icSigDeviceModelDescTag:
            case     icSigProfileDescriptionTag:
            case     icSigScreeningDescTag:
            case     icSigViewingCondDescTag:
                Result = (DataSig == icSigTextDescriptionType);
                break;

            case     icSigMeasurementTag:
                Result = (DataSig == icSigMeasurementTag);
                break;

            case     icSigNamedColorTag:
                Result = (DataSig == icSigNamedColorTag);
                break;
        
            case      icSigProfileSequenceDescTag:
                Result = (DataSig == icSigProfileSequenceDescTag);
                break;

            case     icSigScreeningTag:
                Result = (DataSig == icSigScreeningTag);
                break;

            case     icSigTechnologyTag:
                Result = (DataSig == icSigSignatureType);
                break;

            case     icSigUcrBgTag:
                Result = (DataSig == icSigUcrBgTag);
                break;

            case     icSigViewingConditionsTag:
                Result = (DataSig == icSigViewingConditionsTag);
                break;

            default:
                Result = TRUE;
                break;
        }
    }else
    {
        Result = FALSE;
    }
    return(Result);
}

//******************************************************************
// Functions that get all information from the Color Profile Header
//******************************************************************
BOOL    EXTERN GetCPSize(CHANDLE CP, LPSINT lpSize)
{
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpSize    = ui32toSINT( ((lpcpHeader)CP)->size);
    return(TRUE);
}

BOOL    EXTERN GetCPCMMType(CHANDLE CP, LPCSIG lpType)
{
    if (lpType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpType    = SigtoCSIG( ((lpcpHeader)CP)->cmmId);
    return(TRUE);
}

BOOL    EXTERN GetCPVersion(CHANDLE CP, LPSINT lpVers)
{
    if (lpVers == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpVers    = ui32toSINT( ((lpcpHeader)CP)->version);
    return(TRUE);
}

BOOL    EXTERN GetCPClass(CHANDLE CP, LPCSIG lpClass)
{
    if (lpClass == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpClass    = SigtoCSIG( ((lpcpHeader)CP)->deviceClass);
    return(TRUE);
}

BOOL    EXTERN GetCPDevSpace(CHANDLE CP, LPCSIG lpInSpace)
{
    if (lpInSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpInSpace    = SigtoCSIG( ((lpcpHeader)CP)->colorSpace);
    return(TRUE);
}

BOOL    EXTERN GetCPConnSpace(CHANDLE CP, LPCSIG lpOutSpace)
{
    if (lpOutSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpOutSpace    = SigtoCSIG( ((lpcpHeader)CP)->pcs);
    return(TRUE);
}

BOOL    EXTERN GetCPTarget(CHANDLE CP, LPCSIG lpTarget)
{
    if (lpTarget == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpTarget    = SigtoCSIG( ((lpcpHeader)CP)->platform);
    return(TRUE);
}

BOOL    EXTERN GetCPManufacturer(CHANDLE CP, LPCSIG lpManuf)
{
    if (lpManuf == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpManuf    = SigtoCSIG( ((lpcpHeader)CP)->manufacturer);
    return(TRUE);
}

BOOL    EXTERN GetCPModel(CHANDLE CP, LPCSIG lpModel)
{
    if (lpModel == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpModel    = SigtoCSIG( ((lpcpHeader)CP)->model);
    return(TRUE);
}

BOOL    EXTERN GetCPFlags(CHANDLE CP, LPSINT lpFlags)
{
    if (lpFlags == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpFlags    = ui32toSINT( ((lpcpHeader)CP)->flags);
    return(TRUE);
}

BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent)
{
    if (lpIntent == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpIntent    = ui32toSINT( ((lpcpHeader)CP)->renderingIntent);
    return(TRUE);
}

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP)
{
    if (lpWP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpWP[0]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.X);
    lpWP[1]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Y);
    lpWP[2]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Z);
    return(TRUE);
}

BOOL    EXTERN GetCPAttributes(CHANDLE CP, LPATTRIB lpAttributes)
{
    return(TRUE);
}

BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE cp,  LPSFLOAT lpMediaWP)
{
    HGLOBAL   hTempMem;
    SINT      TempSize;
    MEMPTR    TempBuff;
    MEMPTR    lpTable;
    SINT      i, Index;

    if (DoesCPTagExist (cp, icSigMediaWhitePointTag) &&
        GetCPTagIndex (cp, icSigMediaWhitePointTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & TempSize) &&
        MemAlloc (TempSize, (HGLOBAL *) & hTempMem, (LPMEMPTR) & TempBuff) &&
        GetCPElement (cp, Index, TempBuff, TempSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) TempBuff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMediaWP[i] = (SFLOAT) si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hTempMem);
        return (TRUE);
    }
    return (FALSE);
}

/***************************************************************************
*                               GetPS2ColorRenderingIntent
*  function:
*    this is the function which creates the Intent string 
*    from the data supplied in the Profile that can be used
*    in --findcolorrendering-- operator.
*  prototype:
*       BOOL EXTERN GetPS2ColorRenderingIntent(
*                          char         *FileName,
*                          DWORD        Intent, 
*                          MEMPTR       lpMem,
*                          LPDWORD      lpcbSize )
*  parameters:
*       FileName    --  Color Profile Filename
*       Intent      --  Intent 
*       lpMem       --  Pointer to the memory block
*       lpcbSize        --  Size of the memory block
*                       Returns number of bytes required/transferred
*  returns:
*       BOOL        --  TRUE   if the function was successful,
*                       FALSE  otherwise.
***************************************************************************/
BOOL EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
                                       MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT       Index;
    SINT       Size;
        
    if (!cp)
        return FALSE;

    Size = (SINT) *lpcbSize;
    if( ( lpMem == NULL ) || ( Size == 0 ) )
    {
        lpMem = NULL;
        Size = 0;
        *lpcbSize = 0;
    }
        
    switch(Intent)
    {
        case icPerceptual:
        if( DoesCPTagExist(cp, icSigPs2Intent0Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent0Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        
        case icRelativeColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent1Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent1Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
    
        case icSaturation:
        if( DoesCPTagExist(cp, icSigPs2Intent2Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent2Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size ) )
          )
        {
        }
        break;
        case icAbsoluteColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent3Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent3Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        default:
            Size = 0 ;
        break;
    }
        
    if (Size != 0)
    {
        if (lpMem)
        {
            lpMem[Size] = '\0';
        }
        Size ++;
        *lpcbSize = (DWORD) Size;
        return (TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/***************************************************************************
*
*  Function to check if color matching mathod and icc profile type is 
*       supported by driver.
*  parameters:
*
*  returns:
*       BOOL:   TRUE or FALSE.
*
***************************************************************************/

#ifndef ICMDLL
BOOL EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS )
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res;
    CSIG        CPColorSpaceTag;

    if (NULL == lpICMI)
    {
        return(FALSE);
    }
    hFile = _lopen(lpICMI->lcsDestFilename, READ);
    if( hFile == HFILE_ERROR )
    {
        return(FALSE);
    }

    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    _lclose(hFile);
    if( (Res == HFILE_ERROR) || (Res != sizeof(CPHeader)) )
    {
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        return(FALSE);
    }
    // Make sure the profile is 'prtr'
    // SRGB98
    // if( SigtoCSIG(CPHeader.deviceClass) != icSigOutputClass )
    // {
    //     return(FALSE);
    // }
    CPColorSpaceTag = SigtoCSIG(CPHeader.colorSpace);
    *lpDevCS = CPColorSpaceTag;             // 247974

    switch ( lppd->lpPSExtDevmode->dm.iColorMatchingMethod )
    {
        case COLOR_MATCHING_ON_HOST:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigRgbData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
            case COLOR_MATCHING_ON_PRINTER:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
        case COLOR_MATCHING_PRINTER_CALIBRATION:
        default:
            break;
    }
    return (TRUE);
}
#endif

//***************************************************************************
//
//      Set of functions to output data into memory buffer
//
//***************************************************************************


/***************************************************************************
*
*   Function to put the chunk of memory as string of Hex
*
***************************************************************************/
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    MEMPTR  lpOldPtr = lpMem;

    for ( ; dwBytes ; dwBytes-- )
    {
        Res = wsprintf( (MEMPTR)TempArray, (LPSTR) "%2.2x", *lpBuff );
        *lpMem++ = TempArray[0];
        *lpMem++ = TempArray[1];
        lpBuff++;
        if (((SINT)(lpMem - lpLineStart)) > MAX_LINELENG)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject(lpMem,  NewLine);
        }
    }
    return( (SINT)(lpMem - lpOldPtr)); 
}

/***************************************************************************
*
*   Function to put the string into the buffer
*
***************************************************************************/
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res1, Res2;

    Res1 = lstrlen(NewLine);
    MemCopy(lpMem, NewLine, Res1);

    lpMem += Res1;
    Res2 = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res2);
    return( Res1 + Res2 );
}

SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res;

    Res = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res);
    return( Res );
}

SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n)
{
    MemCopy(lpMem, Obj, n);
    return( n );
}
/***************************************************************************
*
*   Function to write the integer into the buffer
*
***************************************************************************/
SINT WriteInt(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    
    Res = wsprintf( (MEMPTR)TempArray, "%lu ", Number );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the integer into the buffer as hex
*
***************************************************************************/
SINT WriteHex(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];

    Res = wsprintf( TempArray, "%2.2x", (int)(Number & 0x00FF) );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the float into the buffer
*
***************************************************************************/

SINT WriteFloat(MEMPTR lpMem, double dFloat)
{
    char    cSign;
    double  dInt ;
    double  dFract ;
    LONG    lFloat ;
    SINT    Res;
    char    TempArray[TempBfSize];

    lFloat = (LONG) floor( dFloat * 10000.0 + 0.5);

    dFloat = lFloat  / 10000.0 ;

    dInt = floor(fabs(dFloat));
    dFract =  fabs(dFloat) - dInt ;

    cSign   = ' ' ;
    if ( dFloat < 0 )
    {
        cSign   = '-' ;
    }

    Res = wsprintf( (LPSTR) TempArray, (LPSTR) "%c%d.%0.4lu ",
       cSign, (WORD) dInt , (DWORD) (dFract *10000.0)  );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return ( Res );
}

/***************************************************************************
*
*   Function to write the string token into the buffer
*
***************************************************************************/

SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (3);
}

/***************************************************************************
*
*   Function to write the Homogeneous Number Array token into the buffer
*
***************************************************************************/

SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = 32;       // 16-bit fixed integer, high-order byte first
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (4);
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. High byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = ui16toSINT( lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. Low-order byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = (SINT)*((PUSHORT)lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

    for (i = 0; i < sBytes; i ++)
        *lpMem++ = *lpBuff++;
    
    return(sBytes); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

       for( i = 0; i < sBytes ; i++)
    {
        *lpMem++ = (BYTE)(ui16toSINT( lpBuff)/256) ;
        lpBuff += sizeof(icUInt16Number);
    }
    return(sBytes); 
}

/***************************************************************************
*
*  Function to control ascii85 encoding.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       BufSize     --  Size of encording result buffer. 
*       lpSource    --  Pointer to the input buffer
*       DataSize    --  Size of the input buffer
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
****************************************************************************/

SINT    WriteASCII85Cont(MEMPTR lpDest, SINT BufSize, MEMPTR lpSource, SINT DataSize)
{
   SINT     incount;
   MEMPTR   lpPtr, lpSave;
   SINT     rem;
   SINT     bcount;
   SINT     dex;
   unsigned long word;
   
   /* encode the initial 4-tuples */
   lpSave = lpDest;
   lpPtr  = lpSource;
   word   = 0UL;
   bcount = 0;

   for (incount = 0; incount < DataSize; incount ++)
   {
      if ( incount  && ((incount % LINELENG) == 0) )
      lpDest += WriteObject(lpDest,  NewLine);
      word = (word<<8);
      word |= (BYTE)*lpPtr++;
      if (bcount == 3)
      {
         lpDest += WriteAscii85(lpDest, word, 5);
         word = 0UL;
         bcount = 0;
      }
      else
      {
         bcount ++;
      }
   }
   
   /* now do the last partial 4-tuple -- if there is one */
   /* see the Red Book spec for the rules on how this is done */
   if (bcount > 0)
   {
      rem = 4 - bcount;  /* count the remaining bytes */
      for (dex = 0; dex < rem; dex ++) /* shift left for each of them */
      {
         word = (word<<8);      /* (equivalent to adding in ZERO's)*/
         word |= (BYTE)32;
      }
//      lpDest += WriteAscii85(lpDest, word, (bcount + 1));  /* output only meaningful
      lpDest += WriteAscii85(lpDest, word, 5);               /* output only meaningful bytes + 1 */
   }
   return (lpDest - lpSave);
}

/************************************************************************
*
*  Function to convert 4 bytes binary data to 5 bytes ascii85 encorded data.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       inWord      --  Input word (4-bytes) 
*       nBytes      --  Number of bytes should be outputed.
*  returns:
*       SINT        --  Number of bytes actually outputed.
* 
*************************************************************************/

SINT    WriteAscii85(MEMPTR lpDest, unsigned long inWord, SINT nBytes)
{
    unsigned long divisor;
    int      bcount;
    BYTE     outchar;
    MEMPTR   lpSave = lpDest;

    if ((inWord == 0UL) && (nBytes == 5))
        *lpDest++ = 'z';
    else
    {
        divisor = 52200625UL;
        for (bcount = 0; bcount < nBytes; bcount ++)
        { 
            outchar = (BYTE)((int)(inWord/divisor) + (int)'!');
            *lpDest++ = outchar;
            if (bcount < 4)
            {
                inWord = (inWord % divisor);
                divisor =(divisor / 85);
            }
        }
    }
    return (SINT)(lpDest - lpSave);
}

/***************************************************************************
*
*  Function to convert binary data to ascii by performing ASCII85 encording
*  parameters:
*       lpMem       --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       DataSize    --  The size of input binary data. 
*       BufSize     --  The size of buffer pointed by lpMem.
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
***************************************************************************/

SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize)
{
    MEMPTR      intrbuf, Temp;
    HANDLE      intrhandle;
    SINT        AsciiDataSize = 0;

    if (BufSize >= (SINT)(DataSize/4*5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048))
    {
        if ((intrhandle = GlobalAlloc(GHND, BufSize)) != NULL)
        {
            if ((intrbuf = (MEMPTR) GlobalLock(intrhandle)) != NULL)
            {
                Temp = intrbuf;
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteObject(Temp,  ASCII85DecodeBegine);
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteASCII85Cont(Temp, BufSize, lpMem, DataSize);
                Temp += WriteObject(Temp,  ASCII85DecodeEnd);
                AsciiDataSize = (SINT)(Temp - intrbuf);
                lstrcpyn(lpMem, intrbuf, (WORD)AsciiDataSize); 
                GlobalUnlock(intrhandle);
            }
        }
        GlobalFree(intrhandle);
   }
   return (AsciiDataSize);
}

/***************************************************************************
*
*  Function to check if it is need to convert a CRD from binary to ascii
*  parameters:
*       CP          --  Handle of memory block which contains icm profile.
*       Index       --  Index of the element data of the profile.
*       lpData      --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       BufSize     --  The size of the buffer pointed by lpData.
*       DataSize    --  The size of input binary data.
*       AllowBinary --  Allow binary or not(1/0).
*  returns:
*       SINT        --  Number of bytes required/actually outputed.
*
***************************************************************************/

SINT    Convert2Ascii(CHANDLE CP, SINT Index,
                      MEMPTR lpData, SINT BufSize, 
                      SINT DataSize, BOOL AllowBinary)
{
    long    DataType;

    GetCPElementDataType(CP, Index, &DataType);
    if (BufSize == 0)
    {
        if (AllowBinary)
            return (DataSize);
        else if (DataType == 0)    // Ascii data in Profile 
            return (DataSize);
        else                       // Keep space for ascii85 encoding.
            return (DataSize / 4 * 5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048);
    }
    else
    {
        if (AllowBinary)
            return (DataSize);
        else if(DataType == 0) 
            return (DataSize);
        else 
            return (ConvertBinaryData2Ascii(lpData, DataSize, BufSize) );
    }
}

#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length)
{
    SINT    i;

    for (i = 0; i < Length; i++)
    {
        Dest[i] = Source[i];
    }
    return( Length );
}

// SRGB98
BOOL EXTERN InvertMatrix (double FAR * lpInMatrix,
                   double FAR * lpOutMatrix)
{
    double det;

    double FAR *a;
    double FAR *b;
    double FAR *c;
    if ((NULL == lpInMatrix) ||
        (NULL == lpOutMatrix))
    {
        return (FALSE);
    }
    a = (double FAR *) &(lpInMatrix[0]);
    b = (double FAR *) &(lpInMatrix[3]);
    c = (double FAR *) &(lpInMatrix[6]);

    det = a[0] * b[1] * c[2] + a[1] * b[2] * c[0] + a[2] * b[0] * c[1] -
        (a[2] * b[1] * c[0] + a[1] * b[0] * c[2] + a[0] * b[2] * c[1]);

    if (det == 0.0)                     // What to do?
    {
        lpOutMatrix[0] = 1.0;
        lpOutMatrix[1] = 0.0;
        lpOutMatrix[2] = 0.0;

        lpOutMatrix[3] = 0.0;
        lpOutMatrix[4] = 1.0;
        lpOutMatrix[5] = 0.0;

        lpOutMatrix[6] = 0.0;
        lpOutMatrix[7] = 0.0;
        lpOutMatrix[8] = 1.0;
        return (FALSE);
    } else
    {
        lpOutMatrix[0] = (b[1] * c[2] - b[2] * c[1]) / det;
        lpOutMatrix[3] = -(b[0] * c[2] - b[2] * c[0]) / det;
        lpOutMatrix[6] = (b[0] * c[1] - b[1] * c[0]) / det;

        lpOutMatrix[1] = -(a[1] * c[2] - a[2] * c[1]) / det;
        lpOutMatrix[4] = (a[0] * c[2] - a[2] * c[0]) / det;
        lpOutMatrix[7] = -(a[0] * c[1] - a[1] * c[0]) / det;

        lpOutMatrix[2] = (a[1] * b[2] - a[2] * b[1]) / det;
        lpOutMatrix[5] = -(a[0] * b[2] - a[2] * b[0]) / det;
        lpOutMatrix[8] = (a[0] * b[1] - a[1] * b[0]) / det;
        return (TRUE);
    }
}

/*
 *  Crc - 32 BIT ANSI X3.66 CRC checksum files
 *
 *
 * Copyright (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */

static DWORD  crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD  FAR  PASCAL  crc32(MEMPTR buff, DWORD  length)
{
  DWORD  crc, charcnt;
  BYTE    c;


  crc = 0xFFFFFFFF;
  charcnt = 0;

  for (charcnt = 0 ; charcnt < length ; charcnt++)
  {
    c = buff[charcnt] ;
    crc = crc_32_tab[(crc ^ c) & 0xff] ^ (crc >> 8);
  }

  return crc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 16

typedef enum { DATA_lut=0, DATA_matrix } DATATYPE;

typedef struct tagHOSTCLUT {
    USHORT         size;
    DATATYPE       dataType;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                    CHANDLE cpDev,
                    CHANDLE cpTarget,
                    DWORD Intent,
                    MEMPTR lpMem,
                    LPDWORD lpcbSize,
                    BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\getcrd.c ===
#include "generic.h"
#include "stdio.h"
#pragma code_seg(_ICMSEG)

char ICMSEG BeginString[]       = "<";
char ICMSEG EndString[]         = ">";
char ICMSEG BeginArray[]        = "[";
char ICMSEG EndArray[]          = "]";
char ICMSEG BeginFunction[]     = "{";
char ICMSEG EndFunction[]       = "}bind ";
char ICMSEG BeginDict[]         = "<<" ;
char ICMSEG EndDict[]           = ">>" ;
char ICMSEG BlackPoint[]        = "[0 0 0]" ;
char ICMSEG DictType[]          = "/ColorRenderingType 1 ";
char ICMSEG IntentType[]        = "/RenderingIntent ";
char ICMSEG IntentPer[]         = "/Perceptual";
char ICMSEG IntentSat[]         = "/Saturation";
char ICMSEG IntentACol[]        = "/AbsoluteColorimetric";
char ICMSEG IntentRCol[]        = "/RelativeColorimetric";

char ICMSEG WhitePointTag[]     = "/WhitePoint " ;
char ICMSEG BlackPointTag[]     = "/BlackPoint " ;
char ICMSEG RangePQRTag[]       = "/RangePQR " ;
char ICMSEG TransformPQRTag[]   = "/TransformPQR " ;
char ICMSEG MatrixPQRTag[]      = "/MatrixPQR " ;

char ICMSEG RangeABCTag[]       = "/RangeABC " ;
char ICMSEG MatrixATag[]        = "/MatrixA ";
char ICMSEG MatrixABCTag[]      = "/MatrixABC ";
char ICMSEG EncodeABCTag[]      = "/EncodeABC " ;
char ICMSEG RangeLMNTag[]       = "/RangeLMN " ;
char ICMSEG MatrixLMNTag[]      = "/MatrixLMN " ;
char ICMSEG EncodeLMNTag[]      = "/EncodeLMN " ;
char ICMSEG RenderTableTag[]    = "/RenderTable " ;
char ICMSEG CIEBasedATag[]      = "/CIEBasedA " ;
char ICMSEG CIEBasedABCTag[]    = "/CIEBasedABC " ;
char ICMSEG CIEBasedDEFGTag[]   = "/CIEBasedDEFG " ;
char ICMSEG CIEBasedDEFTag[]    = "/CIEBasedDEF " ;
char ICMSEG DecodeATag[]        = "/DecodeA " ;
char ICMSEG DecodeABCTag[]      = "/DecodeABC " ;
char ICMSEG DecodeLMNTag[]      = "/DecodeLMN " ;
char ICMSEG DeviceRGBTag[]      = "/DeviceRGB " ;
char ICMSEG DeviceCMYKTag[]     = "/DeviceCMYK " ;
char ICMSEG DeviceGrayTag[]     = "/DeviceGray " ;
char ICMSEG TableTag[]          = "/Table " ;
char ICMSEG DecodeDEFGTag[]     = "/DecodeDEFG " ;
char ICMSEG DecodeDEFTag[]      = "/DecodeDEF " ;

char ICMSEG NullOp[]            = "";
char ICMSEG DupOp[]             = "dup ";
char ICMSEG UserDictOp[]        = "userdict ";
char ICMSEG GlobalDictOp[]      = "globaldict ";
char ICMSEG CurrentGlobalOp[]   = "currentglobal ";
char ICMSEG SetGlobalOp[]       = "setglobal ";
char ICMSEG DefOp[]             = "def ";
char ICMSEG BeginOp[]           = "begin ";
char ICMSEG EndOp[]             = "end ";
char ICMSEG TrueOp[]            = "true ";
char ICMSEG FalseOp[]           = "false ";
char ICMSEG MulOp[]             = "mul ";
char ICMSEG DivOp[]             = "div ";

char ICMSEG NewLine[]           = "\n" ;
char ICMSEG Slash[]             = "/" ;
char ICMSEG Space[]             = " " ;
char ICMSEG CRDBegin[]          = "%** CRD Begin ";
char ICMSEG CRDEnd[]            = "%** CRD End ";
char ICMSEG CieBasedDEFGBegin[] = "%** CieBasedDEFG CSA Begin ";
char ICMSEG CieBasedDEFBegin[]  = "%** CieBasedDEF CSA Begin ";
char ICMSEG CieBasedABCBegin[]  = "%** CieBasedABC CSA Begin ";
char ICMSEG CieBasedABegin[]    = "%** CieBasedA CSA Begin ";
char ICMSEG CieBasedDEFGEnd[]   = "%** CieBasedDEFG CSA End ";
char ICMSEG CieBasedDEFEnd[]    = "%** CieBasedDEF CSA End ";
char ICMSEG CieBasedABCEnd[]    = "%** CieBasedABC CSA End ";
char ICMSEG CieBasedAEnd[]      = "%** CieBasedA CSA End ";
char ICMSEG RangeABC[]          = "[ 0 1 0 1 0 1 ] ";
char ICMSEG RangeLMN[]          = "[ 0 2 0 2 0 2 ] ";
char ICMSEG Identity[]          = "[1 0 0 0 1 0 0 0 1]";
char ICMSEG RangeABC_Lab[]      = "[0 100 -128 127 -128 127]";

/********** This PostScript code clips incoming value between 0.0 and 1.0
   Use:   x <clip>   --   <clipped x>                                   */
char ICMSEG Clip01[]            = "dup 1.0 ge{pop 1.0}{dup 0.0 lt{pop 0.0}if}ifelse " ;
char ICMSEG DecodeA3[]          = "256 div exp ";
char ICMSEG DecodeA3Rev[]       = "256 div 1.0 exch div exp ";
char ICMSEG DecodeABCArray[]    = "DecodeABC_";
char ICMSEG InputArray[]        = "Inp_";
char ICMSEG OutputArray[]       = "Out_";
char ICMSEG PreViewInArray[]    = "IPV_";
char ICMSEG PreViewOutArray[]   = "OPV_";

char ICMSEG AdobeCSA[] = "[ /CIEBasedABC << /DecodeLMN [\n\
{dup 0.03928 le {12.92321 div}{0.055 add 1.055 div 2.4 exp}ifelse} bind dup dup ]\n\
/MatrixLMN [0.412457 0.212673 0.019334 0.357576 0.715152 0.119192 0.180437 0.072175 0.950301]\n\
/WhitePoint [ 0.9505 1 1.0890 ] >> ]";

char ICMSEG AdobeCRD[] = " /RangePQR [ -0.5 2 -0.5 2 -0.5 2 ]\n\
/MatrixPQR [0.8951 -0.7502  0.0389 0.2664  1.7135 -0.0685 -0.1614  0.0367  1.0296]\n\
/TransformPQR [{exch pop exch 3 get mul exch pop exch 3 get div} bind\n\
{exch pop exch 4 get mul exch pop exch 4 get div} bind\n\
{exch pop exch 5 get mul exch pop exch 5 get div} bind]\n\
/MatrixLMN [3.240449 -0.969265  0.055643 -1.537136  1.876011 -0.204026 -0.498531  0.041556  1.057229]\n\
/EncodeABC [{dup 0.00304 le {12.92321 mul}{1 2.4 div exp 1.055 mul 0.055 sub}ifelse} bind dup dup]\n\
/WhitePoint[0.9505 1 1.0890] >>";

// This PostScript segment takes value in range from 0.0 to 1.0 and
//  interpolates the result using array supplied.
//   x [array]  -- <interpolated value>

char ICMSEG IndexArray16b[]     = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 32768 add 4 -1 roll 3 -1 roll get 32768 add \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG IndexArray[]        = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 4 -1 roll 3 -1 roll get \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG TestingDEFG[]       = \
"/SupportDEFG? {/CIEBasedDEFG /ColorSpaceFamily resourcestatus { pop pop languagelevel 3 ge}{false} ifelse} def";

char ICMSEG SupportDEFG_S[]     = "SupportDEFG? { ";
char ICMSEG NotSupportDEFG_S[]  = "SupportDEFG? not { ";
char ICMSEG SupportDEFG_E[]     = "}if ";

char ICMSEG StartClip[]         = "dup 1.0 le{dup 0.0 ge{" ;
char ICMSEG EndClip[]           = "}if}if " ;

char ICMSEG Scale8[]            = "255 div " ;
char ICMSEG Scale16[]           = "65535 div " ;
char ICMSEG Scale16XYZ[]        = "32768 div " ;
char ICMSEG TFunction8[]        = "exch 255 mul round cvi get 255 div " ;
char ICMSEG TFunction8XYZ[]     = "exch 255 mul round cvi get 128 div " ;
char ICMSEG MatrixABCLab[]      = "[1 1 1 1 0 0 0 0 -1]" ;
char ICMSEG DecodeABCLab1[]     = "[{16 add 116 div} bind {500 div} bind {200 div} bind]";
char ICMSEG DecodeALab[]        = " 50 mul 16 add 116 div ";
char ICMSEG DecodeLMNLab[]      = \
"dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse ";

char ICMSEG RangeLMNLab[]       = "[0 1 0 1 0 1]" ;
char ICMSEG EncodeLMNLab[]      = "\
dup 0.008856 le{7.787 mul 0.13793 add}{0.3333 exp}ifelse " ;

char ICMSEG MatrixABCLabCRD[]   = "[0 500 0 116 -500 200 0 0 -200]" ;
char ICMSEG MatrixABCXYZCRD[]   = "[0 1 0 1 0 0 0 0 1]" ;
char ICMSEG EncodeABCLab1[]     = "16 sub 100 div " ;
char ICMSEG EncodeABCLab2[]     = "128 add 255 div " ;

char ICMSEG   RangePQR[]          = "[ -0.07 2.2 -0.02 1.4 -0.2 4.8 ]";
char ICMSEG   MatrixPQR[]         = "[0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296]";

char *TransformPQR[3]             = {
"exch pop exch 3 get mul exch pop exch 3 get div ",
"exch pop exch 4 get mul exch pop exch 4 get div ",
"exch pop exch 5 get mul exch pop exch 5 get div " };

#define SRGBCRC 0x678175D2L

#pragma optimize("",off)

/***************************************************************************
*                               CreateLutCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  prototype:
*       SINT EXTERN CreateLutCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CRD allowed,  0: only ascii CRD allowed.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

SINT EXTERN 
CreateLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT nInputCh, nOutputCh, nGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    CSIG Tag, PCS;
    CSIG IntentSig;

    SINT Ret;
    SINT i, j;
    MEMPTR lpTable;

    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    char PublicArrayName[TempBfSize];
    HGLOBAL hMem;
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);
 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (((nOutputCh != 3) &&
         (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }
    Ret = nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +  // Number of INT bytes
        nOutputCh * nGrids * nGrids * nGrids * 2 +  // LUT HEX bytes
        nInputCh * (lstrlen (IndexArray) +
                    lstrlen (StartClip) +
                    lstrlen (EndClip)) +
        nOutputCh * (lstrlen (IndexArray) +
                     lstrlen (StartClip) +
                     lstrlen (EndClip)) +
        2048;                           // + other PS stuff

    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
//  Get all necessary params from the header
//  GetCPRenderIntent (cp, (LPCSIG) & Intent);  // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type
    
    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (InputIntent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;

        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;

        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }
    
 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** Send PQR - used for Absolute Colorimetric *****
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 // ******** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        PCS, nInputCh, Buff, NULL, Tag, AllowBinary);

 //********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Na
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nb
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    nNumbers = nGrids * nGrids * nOutputCh;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, BeginString);
            if (Tag == icSigLut8Type)
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
            else
            {
                for (j = 0; j < nNumbers; j++)
                {
                    lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
            }
            lpMem += WriteObject (lpMem, EndString);
        } else
        {                               // Output BINARY CRD
            lpMem += WriteStringToken (lpMem, 143, nNumbers);
            if (Tag == icSigLut8Type)
                lpMem += WriteByteString (lpMem, lpTable, nNumbers);
            else
                lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
        }
    }

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteInt (lpMem, nOutputCh);   // Send down m

 //********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        nOutputCh, Tag, FALSE, AllowBinary);

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    lpMem += WriteNewLineObject (lpMem, CRDEnd);

// Testing Convert binary to ascii
//    i = ConvertBinaryData2Ascii(lpOldMem, (SINT)(lpMem - lpOldMem), Ret);
//    lpMem = lpOldMem + i;
// Testing Convert binary to ascii

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
/***************************************************************************
*                               GetRevCurve
*  function:
*  prototype:
*       BOOL  GetRevCurve(
*                          MEMPTR       Buff,
*                          MEMPTR       lpRevCurve)
*  parameters:
*       Buff        --
*       lpRevCurve  --
*  returns:
*       BOOL        --  TRUE:  successful,
*                       FALSE: otherwise.
***************************************************************************/

BOOL
GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve)
{
    SINT i, j, nCount;
    MEMPTR lpTable;
    PUSHORT lpInput, lpOutput;
    SFLOAT fTemp;
    SINT iBegin, iEnd, iTemp;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
    lpOutput = (PUSHORT) lpRevCurve;
    lpInput = (PUSHORT) lpCurve;

    for (i = 0; i < nCount; i++)
    {
        lpInput[i] = (USHORT) (ui16toSINT (lpTable));
        lpTable += sizeof (icUInt16Number);
    }

    j = nCount * REVCURVE_RATIO;
    for (i = 0; i < j; i++)
    {
        fTemp = (SFLOAT) i *65535 / (j - 1);
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    for (i = 0; i < j; i++)
    {
        iBegin = 0;
        iEnd = nCount - 1;
        for (;;)
        {
            if ((iEnd - iBegin) <= 1)
                break;
            iTemp = (iEnd + iBegin) / 2;
            if (lpOutput[i] < lpInput[iTemp])
                iEnd = iTemp;
            else
                iBegin = iTemp;
        }
        if (lpOutput[i] <= lpInput[iBegin])
            fTemp = (SFLOAT) iBegin;
        else if (lpOutput[i] >= lpInput[iEnd])
            fTemp = (SFLOAT) iEnd;
        else
        {
            fTemp = ((SFLOAT) (lpInput[iEnd] - lpOutput[i])) /
                (lpOutput[i] - lpInput[iBegin]);
            fTemp = (iBegin * fTemp + iEnd) / (fTemp + 1);
        }
        fTemp = (fTemp / (nCount - 1)) * 65535;
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    return TRUE;
}
/***************************************************************************
*                               CreateMonoCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the GrayTRC tag.
*  prototype:
*       BOOL EXTERN CreateMonoCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
//  According to the spec this tag-based function only converts from
//  Device to PCS, so we need to create an inverse function to perform
//  PCS->device conversion. By definition the CRD is only
//  for XYZ->DeviceRGB/CMYK conversion.
SINT EXTERN 
CreateMonoCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT nCount;
    CSIG Tag, PCS;

    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpCurve, lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SINT i;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);

 // Estimate the memory size required to hold CRD
 // SRGB98
    Ret = nCount * 6 * REVCURVE_RATIO + // Number of INT elements
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
    if (!MemAlloc (nCount * 2 * (REVCURVE_RATIO + 1),
                   (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (FALSE);
    }
    lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
    GetRevCurve (Buff, lpCurve, lpRevCurve);

 //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (InputIntent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;
        
        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;
        
        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }
    
 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** /TransformPQR
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** /MatrixLMN
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 //********** /MatrixABC
    if (PCS == icSigXYZData)
    {   // Switch ABC to BAC, since we want to output B which is converted from Y.
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCXYZCRD);
    }
    else if (PCS == icSigLabData)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, EncodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);
        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, EncodeABCLab1);
            }
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}

// SRGB98 start
BOOL
GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize)
{
    CSIG Tag;

    if (!GetCPTagIndex (cp, icSigXTRCTag, (LPSINT) pIndex) ||
        !GetCPElementType (cp, *pIndex, (LPCSIG) & Tag) ||
        !(Tag == icSigCurveType) ||
        !GetCPElementSize (cp, *pIndex, (LPSINT) pTRCSize))
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
DoesTRCAndColorantTagExist (CHANDLE cp)
{
    if (DoesCPTagExist (cp, icSigRedColorantTag) &&
        DoesCPTagExist (cp, icSigRedTRCTag ) &&
        DoesCPTagExist (cp, icSigGreenColorantTag) &&
        DoesCPTagExist (cp, icSigGreenTRCTag ) &&
        DoesCPTagExist (cp, icSigBlueColorantTag) &&
        DoesCPTagExist (cp, icSigBlueTRCTag ))
    {
        return TRUE;
    }

    return FALSE;
}

static SINT 
CreateRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
                MEMPTR lpRevCurve, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    MEMPTR lpCurve;

    lpOldMem = lpMem;

    lpLineStart = lpMem;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount > 1)
    {
        lpMem += WriteNewLineObject (lpMem, Slash);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteInt (lpMem, (SINT) CPTag);

        lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
        GetRevCurve (lpBuff, lpCurve, lpRevCurve);

        if (!AllowBinary)           // Output ASCII DATA
        {
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
        } else
        {                           // Output BINARY DATA
            lpMem += WriteHNAToken (lpMem, 149, nCount);
            lpMem += WriteIntStringU2S_L (lpMem, lpRevCurve, nCount);
        }
    }
    lpMem += WriteObject (lpMem, DefOp);
    return ((SINT) (lpMem - lpOldMem));
}

static SINT 
SendRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
              CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount;
    MEMPTR lpOldMem;
    MEMPTR lpTable;

    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount != 0)
    {
        if (nCount == 1)            // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, InputArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            if (!AllowBinary)       // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {                       // Output BINARY CS
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}

SINT 
CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    HGLOBAL hBuff;

    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            *lpArray++ = (SFLOAT)si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ( TRUE );
}  


/***************************************************************************
*                           IsSRGB
*  function: check if the profile is sRGB
*
*  parameters:
*       cp          --  Color Profile handle
*
*  returns:
*       BOOL        --  TRUE if the profile is sRGB
*                       FALSE otherwise.
***************************************************************************/
BOOL FAR IsSRGB (CHANDLE cp)
{   
    BOOL    match = FALSE;
    SINT    RedTRCIndex, GreenTRCIndex, BlueTRCIndex, RedCIndex, GreenCIndex, BlueCIndex;
    SINT    MemSize;
    SINT    RedTRCSize=0, GreenTRCSize=0, BlueTRCSize=0, RedCSize=0, GreenCSize=0, BlueCSize=0;
    HGLOBAL hMem;
    MEMPTR  lpRed = NULL,lpGreen, lpBlue, lpRedC, lpGreenC, lpBlueC;
    DWORD   crc;

    if (GetCPTagIndex (cp, icSigRedTRCTag, &RedTRCIndex) &&
        GetCPElementSize (cp, RedTRCIndex, &RedTRCSize)  &&
            
        GetCPTagIndex (cp, icSigGreenTRCTag, &GreenTRCIndex) &&
        GetCPElementSize (cp, GreenTRCIndex, &GreenTRCSize)  &&
            
        GetCPTagIndex (cp, icSigBlueTRCTag, &BlueTRCIndex) &&
        GetCPElementSize (cp, BlueTRCIndex, &BlueTRCSize) && 
            
        GetCPTagIndex (cp, icSigRedColorantTag, &RedCIndex) &&
        GetCPElementSize (cp, RedCIndex, &RedCSize)  &&
            
        GetCPTagIndex (cp, icSigGreenColorantTag, &GreenCIndex) &&
        GetCPElementSize (cp, GreenCIndex, &GreenCSize)  &&
            
        GetCPTagIndex (cp, icSigBlueColorantTag, &BlueCIndex) &&
        GetCPElementSize (cp, BlueCIndex, &BlueCSize) )
    {
        MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize + RedCSize + GreenCSize + BlueCSize;

        if ( (MemSize == 6240) && // #bytes in sRGBColorTags
             MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR)&lpRed) )
        {
            lpGreen = lpRed + RedTRCSize;
            lpBlue = lpGreen + GreenTRCSize;
            lpRedC = lpBlue + BlueTRCSize;
            lpGreenC = lpRedC + RedCSize;
            lpBlueC = lpGreenC + GreenCSize;
            
            if (GetCPElement (cp, RedTRCIndex, lpRed, RedTRCSize) &&
                GetCPElement (cp, GreenTRCIndex, lpGreen, GreenTRCSize ) &&
                GetCPElement (cp, BlueTRCIndex, lpBlue, BlueTRCSize ) &&
                GetCPElement (cp, RedCIndex, lpRedC, RedCSize) &&
                GetCPElement (cp, GreenCIndex, lpGreenC, GreenCSize ) &&
                GetCPElement (cp, BlueCIndex, lpBlueC, BlueCSize ))
            {   
                crc = crc32( lpRed, 6240 );    
                match = (crc == SRGBCRC);
            }
            MemFree(hMem);
        }    
    }            
    return (match);
}

/***************************************************************************
*                           CreateMatrixCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the redTRC, greenTRC, blueTRA, redColorant,
*    greenColorant and BlueColorant tags
*  prototype:
*       BOOL EXTERN CreateMatrixCRD(
*                          CHANDLE      cp,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block
*       AllowBinary --
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
// With matrix/TRC model, only the CIEXYZ encoding of the PCS can be used.
// So, we don't need to worry about CIELAB.
SINT EXTERN 
CreateMatrixCRD (CHANDLE cp, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT i, MemSize;
    SINT nRedCount, nGreenCount, nBlueCount;
    MEMPTR lpRed = NULL,lpGreen, lpBlue;
    SINT RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SFLOAT IlluminantWP[3];
    double Colorant[9];
    double RevColorant[9];
 
 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
        return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & lpRed))
        return 0;

    lpGreen = lpRed + RedTRCSize;
    lpBlue = lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (0);
    }
    nRedCount = ui32toSINT (((lpcpCurveType) lpRed)->curve.count);
    nGreenCount = ui32toSINT (((lpcpCurveType) lpGreen)->curve.count);
    nBlueCount = ui32toSINT (((lpcpCurveType) lpBlue)->curve.count);

 // Estimate the memory size required to hold CRD
    Ret = (nRedCount + nGreenCount + nBlueCount) * 6 * REVCURVE_RATIO + 
        2048;                // Number of INT elements + other PS stuff
    if (lpMem == NULL)       // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }

    if (!MemAlloc (nRedCount * 2 * (REVCURVE_RATIO + 1),
                  (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (0);
    }

    if (IsSRGB(cp))
    {
       lpMem += WriteNewLineObject (lpMem, CRDBegin);
       lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
       lpMem += WriteObject (lpMem, DictType); // Dictionary type
       lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
       switch (InputIntent)
       {
           case icPerceptual:
               lpMem += WriteObject (lpMem, IntentPer);
               break;

           case icSaturation:
               lpMem += WriteObject (lpMem, IntentSat);
               break;
        
           case icRelativeColorimetric:
               lpMem += WriteObject (lpMem, IntentRCol);
               break;
        
           case icAbsoluteColorimetric:
               lpMem += WriteObject (lpMem, IntentACol);
               break;
       }
       lpMem += WriteNewLineObject (lpMem, AdobeCRD);
       lpMem += WriteNewLineObject (lpMem, CRDEnd);
    }
    else
    {
       lpMem += EnableGlobalDict(lpMem);
       lpMem += BeginGlobalDict(lpMem);
       
       lpMem += CreateRevArray (cp, lpMem, lpRed, lpRevCurve, icSigRedTRCTag, AllowBinary);
       lpMem += CreateRevArray (cp, lpMem, lpGreen, lpRevCurve, icSigGreenTRCTag, AllowBinary);
       lpMem += CreateRevArray (cp, lpMem, lpBlue, lpRevCurve, icSigBlueTRCTag, AllowBinary);
   
       lpMem += EndGlobalDict(lpMem);
   
    //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
       GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant
   
    //************* Start writing  CRD  ****************************
       lpMem += WriteNewLineObject (lpMem, CRDBegin);
   
       lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
       lpMem += WriteObject (lpMem, DictType); // Dictionary type
                            
       lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
       switch (InputIntent)
       {
           case icPerceptual:
               lpMem += WriteObject (lpMem, IntentPer);
               break;

           case icSaturation:
               lpMem += WriteObject (lpMem, IntentSat);
               break;
        
           case icRelativeColorimetric:
               lpMem += WriteObject (lpMem, IntentRCol);
               break;
        
           case icAbsoluteColorimetric:
               lpMem += WriteObject (lpMem, IntentACol);
               break;
       }
                     
    //********** Send Black/White Point.
       lpMem += SendCRDBWPoint(lpMem, IlluminantWP);
   
    //********** /TransformPQR
       lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);
   
    //********** /MatrixLMN
       CreateColorantArray(cp, &Colorant[0], icSigRedColorantTag);
       CreateColorantArray(cp, &Colorant[3], icSigGreenColorantTag);
       CreateColorantArray(cp, &Colorant[6], icSigBlueColorantTag);
       InvertMatrix (Colorant, RevColorant);
   
       lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);
   
       lpMem += WriteObject (lpMem, BeginArray);
       for (i = 0; i < 9; i++)
       {
           lpMem += WriteFloat (lpMem, (SFLOAT)RevColorant[i]);
       }
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /EncodeABC
       lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpRed, icSigRedTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpGreen, icSigGreenTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += SendRevArray (cp, lpMem, lpBlue, icSigBlueTRCTag, AllowBinary);
       lpMem += WriteNewLineObject (lpMem, EndArray);
   
       lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
   
       lpMem += WriteNewLineObject (lpMem, CRDEnd);
    }
    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
// SRGB98 End

BOOL EXTERN
GetPS2ColorRenderingDictionary (
                                CHANDLE cp,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary)
{
    SINT Index;
    SINT Ret, Size;
    CSIG icSigPs2CRDx, icSigBToAx;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }
    Ret = 0;
    Size = (SINT) * lpcbSize;

    switch (Intent)
    {
        case icPerceptual:
            icSigPs2CRDx = icSigPs2CRD0Tag;
            icSigBToAx = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
            icSigPs2CRDx = icSigPs2CRD1Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        case icSaturation:
            icSigPs2CRDx = icSigPs2CRD2Tag;
            icSigBToAx = icSigBToA2Tag;
            break;

        case icAbsoluteColorimetric:
            icSigPs2CRDx = icSigPs2CRD3Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        default:
            *lpcbSize = (DWORD) Ret;
            return (Ret > 0);
    }

    if (
        (DoesCPTagExist (cp, icSigPs2CRDx) &&
         GetCPTagIndex (cp, icSigPs2CRDx, (LPSINT) & Index) &&
         GetCPElementDataSize (cp, Index, (LPSINT) & Ret) &&
         ((Size == 0) ||
          GetCPElementData (cp, Index, lpMem, Size)) &&
         (Ret = Convert2Ascii (cp, Index, lpMem, Size, Ret, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigBToAx) &&
         GetCPTagIndex (cp, icSigBToAx, (LPSINT) & Index) &&
         (Ret = CreateLutCRD (cp, Index, lpMem, Intent, AllowBinary))
        ) || 
        // SRGB98 Support Windows 98 sRGB icc profile.
        // Create CRD from TRC and Colorant Tags.
        (DoesTRCAndColorantTagExist (cp) &&
         (Ret = CreateMatrixCRD (cp, lpMem, Intent, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigGrayTRCTag) &&
         GetCPTagIndex (cp, icSigGrayTRCTag, (LPSINT) & Index) &&
         (Ret = CreateMonoCRD (cp, Index, lpMem, Intent))
        )
       )
    {
    }

    *lpcbSize = (DWORD) Ret;
    return (Ret > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\dllmain.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   dllmain.c
//
//  PURPOSE:  Contains the DLL's entry point function.
//
//  FUNCTIONS:
//    DLLMain   - The entry point function
//

#include <windows.h>


//
//  FUNCTION: DLLMain(HINSTANCE, DWORD, LPVOID)
//
//  PURPOSE:  Called when DLL is loaded by a process, and when new
//    threads are created by a process that has already loaded the
//    DLL.  Also called when threads of a process that has loaded the
//    DLL exit cleanly and when the process itself unloads the DLL.
//
//  PARAMETERS:
//    hDLLInst    - Instance handle of the DLL
//    fdwReason   - Process attach/detach or thread attach/detach
//    lpvReserved - Reserved and not used
//
//  RETURN VALUE:  (Used only when fdwReason == DLL_PROCESS_ATTACH)
//    TRUE  -  Used to signify that the DLL should remain loaded.
//    FALSE -  Used to signify that the DLL should be immediately unloaded.
//
//  COMMENTS:
//
//    If you want to use C runtime libraries, keep this function named
//    "DllMain" and you won't have to do anything special to initialize
//    the runtime libraries.
//
//    When fdwReason == DLL_PROCESS_ATTACH, the return value is used to
//    determine if the DLL should remain loaded, or should be immediately
//    unloaded depending upon whether the DLL could be initialized properly.
//    For all other values of fdwReason, the return value is ignored.
//

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.

            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\getcsa.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICMSEG)

static char  *DecodeABCLab[] = {"50 mul 16 add 116 div ", 
                               "128 mul 128 sub 500 div", 
                               "128 mul 128 sub 200 div"};

#pragma optimize("",off)

BOOL IsSRGB( CHANDLE cp );

/**************************************************************************/

SINT CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag);
static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);
static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);

/***************************************************************************
*                           GetDevideRGB
*  function:
*    this is the function which creates the DeviceRGB ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceRGB(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetDeviceRGB (
              MEMPTR lpMem,
              LPDWORD lpcbSize,
              DWORD InpDrvClrSp,
              BOOL  BackupCSA)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
        return FALSE;

    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceRGBTag) + 8;
        return (TRUE);
    }

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
    }

    lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetDevideCMYK
*  function:
*    this is the function which creates the DeviceCMYK ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceCMYK(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetDeviceCMYK (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigCmykData) &&
        (InpDrvClrSp != 0))
        return FALSE;
    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceCMYKTag) + 8;
        return (TRUE);
    }
    lpMem += WriteNewLineObject (lpMem, DeviceCMYKTag);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);

}
/***************************************************************************
*                           GetDeviceGray
***************************************************************************/

static BOOL
GetDeviceGray (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceRGBTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceGrayTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceGrayTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    }
}
/***************************************************************************
*                           GetPublicArrayName
***************************************************************************/

SINT
GetPublicArrayName (CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName)
{
    MEMPTR OldPtr;
    OldPtr = PublicArrayName;
    PublicArrayName[0] = 0;
    MemCopy (PublicArrayName, (MEMPTR) & IntentSig, sizeof (CSIG));
    PublicArrayName += sizeof (CSIG);
    PublicArrayName[0] = 0;
    return (PublicArrayName - OldPtr);
}

static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
                    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    SINT   i;
    MEMPTR lpOldMem = lpMem;

 //********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

 //********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (Intent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
                       LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }
}

SINT  BeginGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, GlobalDictOp);
    lpMem += WriteObject (lpMem, BeginOp);

    return (lpMem - lpOldMem);
}

SINT  EndGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);

    return (lpMem - lpOldMem);
}

SINT  EnableGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, CurrentGlobalOp);
    lpMem += WriteObject (lpMem, TrueOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    return (lpMem - lpOldMem);
}

/***************************************************************************
*                           GetPS2CSA_DEFG
*  function:
*    this is the function which creates the CIEBasedDEF(G) ColorSpace (CS)
*    from the data supplied in the RGB or CMYK Input Profile.
*  prototype:
*       GetPS2CSA_DEFG(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       int         Type
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Type        --  CieBasedDEF or CieBasedDEFG.
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_DEFG (
                CHANDLE cp,
                MEMPTR lpMem,
                LPDWORD lpcbSize,
                CSIG InputIntent,
                SINT Index,
                int Type,
                BOOL AllowBinary)
{
    CSIG PCS, LutTag;
    CSIG IntentSig;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    SINT nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    SINT i, j, k;
    MEMPTR lpTable;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpLut = NULL;
    MEMPTR lpLineStart;
    HGLOBAL hLut = 0;
    SINT LutSize;
    char PublicArrayName[TempBfSize];
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);

 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    if (lpMem == NULL)                  // This is a size request
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids * 2;  // LUT HEX bytes
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * 2;   // LUT HEX bytes

        *lpcbSize = *lpcbSize +
            nInputCh * nInputTable * 6 +
            nOutputCh * nOutputTable * 6 +  // Number of INT bytes
            nInputCh * (lstrlen (IndexArray) +
                        lstrlen (StartClip) +
                        lstrlen (EndClip)) +
            nOutputCh * (lstrlen (IndexArray) +
                         lstrlen (StartClip) +
                         lstrlen (EndClip)) +
            4096;                       // + other PS stuff


        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Testing CieBasedDEFG support
    lpMem += WriteNewLineObject (lpMem, TestingDEFG);

 //*********** Creating global data
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGBegin);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    lpMem += WriteNewLineObject (lpMem, SetGlobalOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedDEF(G)
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CIEBasedDEFGTag);
    else
        lpMem += WriteObject (lpMem, CIEBasedDEFTag);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeDEF(G)
    lpLineStart = lpMem;
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, DecodeDEFGTag);
    else
        lpMem += WriteNewLineObject (lpMem, DecodeDEFTag);

    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;

        lpMem += WriteNewLineObject (lpMem, BeginFunction);
#if 0
        if (PCS == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
#endif
        lpMem += WriteObject (lpMem, StartClip);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII
        {
            lpMem += WriteObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /Table
    lpMem += WriteNewLineObject (lpMem, TableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Nh
    lpMem += WriteInt (lpMem, nGrids);  // Send down Ni
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nj
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        lpMem += WriteInt (lpMem, nGrids);  // Send down Nk
//       nNumbers = nGrids * nGrids * nGrids * nOutputCh ;
        SecondGrids = nGrids;
    }
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteNewLineObject (lpMem, BeginArray);
        }
        for (k = 0; k < SecondGrids; k++)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (!AllowBinary)           // Output ASCII
            {
                lpMem += WriteObject (lpMem, BeginString);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
                else
                {
                    for (j = 0; j < nNumbers; j++)
                    {
                        lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                        lpTable += sizeof (icUInt16Number);
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
                lpMem += WriteObject (lpMem, EndString);
            } else
            {                           // Output BINARY
                lpMem += WriteStringToken (lpMem, 143, nNumbers);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteByteString (lpMem, lpTable, nNumbers);
                else
                    lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
            }
            lpMem += WriteObject (lpMem, NewLine);
        }
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteObject (lpMem, EndArray);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndArray); // End array

 //********** /DecodeABC
    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);

            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        }

 // Now, We get CieBasedXYZ output. Output range 0 --> 1.99997
 // If the connection space is absolute XYZ, We need to convert 
 // from relative XYZ to absolute XYZ.
        if ((PCS == icSigXYZData) &&
            (InputIntent == icAbsoluteColorimetric))
        {
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
        }
 // If the connection space is Lab, We need to convert XYZ to Lab.
        else if (PCS == icSigLabData)
            lpMem += WriteObject (lpMem, DecodeABCLab[i]);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    if (PCS == icSigLabData)
    {
 //********** /MatrixABC
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, BeginFunction);
            lpMem += WriteObject (lpMem, DecodeLMNLab);
            if (InputIntent == icAbsoluteColorimetric)
                lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
            else 
                lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp);
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
 //********** /RangeLMN
        lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
        lpMem += WriteObject (lpMem, RangeLMN);
    }

 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGEnd);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFEnd);

    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the RGB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*       BackupCSA   --  1: A CIEBasedDEF has been created, this CSA is a backup 
*                          in case some old printer can not support CIEBasedDEF.
*                       0: No CIEBasedDEF. This is the only CSA.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, 
               BOOL AllowBinary, BOOL BackupCSA)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0; 
    
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigRgbData) ||
        !DoesTRCAndColorantTagExist(cp))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }

 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                            
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Creating global data

    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    if (IsSRGB(cp))
    {
       lpMem += WriteNewLineObject (lpMem, AdobeCSA);
    }
    else
    {
       lpMem += EnableGlobalDict(lpMem);
       
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
       }
   
       lpMem += BeginGlobalDict(lpMem);
   
       lpMem += CreateColSpArray (cp, lpMem, icSigRedTRCTag, AllowBinary);
       lpMem += CreateColSpArray (cp, lpMem, icSigGreenTRCTag, AllowBinary);
       lpMem += CreateColSpArray (cp, lpMem, icSigBlueTRCTag, AllowBinary);
   
       lpMem += WriteNewLineObject (lpMem, EndOp);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
       }
       lpMem += WriteNewLineObject (lpMem, SetGlobalOp);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
       }
   
    //*********** Start creating the ColorSpace
       lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
    //********** /CIEBasedABC
       lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
       lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary
   
    //********** Black/White Point
       lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);
   
    //********** /DecodeABC
       lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigRedTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigGreenTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, NewLine);
       lpMem += CreateColSpProc (cp, lpMem, icSigBlueTRCTag, AllowBinary);
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /MatrixABC
       lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
       lpMem += WriteObject (lpMem, BeginArray);
   
       lpMem += CreateFloatString (cp, lpMem, icSigRedColorantTag);
       lpMem += CreateFloatString (cp, lpMem, icSigGreenColorantTag);
       lpMem += CreateFloatString (cp, lpMem, icSigBlueColorantTag);
   
       lpMem += WriteObject (lpMem, EndArray);
   
    //********** /RangeLMN
       lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
       lpMem += WriteObject (lpMem, RangeLMN);
   
    //********** /DecodeLMN
       if (InputIntent == icAbsoluteColorimetric)
       {
           // Support absolute whitePoint
           lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
           lpMem += WriteObject (lpMem, BeginArray);
           for (i = 0; i < 3; i ++)
           {
               lpMem += WriteObject (lpMem, BeginFunction);
               lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
               lpMem += WriteObject (lpMem, MulOp); 
               lpMem += WriteObject (lpMem, EndFunction);
           }
           lpMem += WriteObject (lpMem, EndArray);
       }
   
    //********** End dictionary definition
       lpMem += WriteNewLineObject (lpMem, EndDict);
       lpMem += WriteObject (lpMem, EndArray);
   
       if (BackupCSA)
       {
           lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
       }
   
    }
    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC_LAB
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the LAB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC_LAB (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigLabData))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigLabData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC_Lab);

 //********** /DecodeABC
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, DecodeABCLab1);

 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
    lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, DecodeLMNLab);
        if (InputIntent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
        lpMem += WriteObject (lpMem, MulOp); 
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, NewLine);
    }
    lpMem += WriteObject (lpMem, EndArray);


 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_MONO_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                    CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, j, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        for (j = 0; j < 3; j++)
        {
            if (i != j)
                lpMem += WriteFloat (lpMem, (double)0);
            else
            {
                if (InputIntent == icAbsoluteColorimetric)
                    lpMem += WriteFloat (lpMem, (double)MediaWP[i]);
                else
                    lpMem += WriteFloat (lpMem, (double)IlluminantWP[i]);
            }
        }
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);


    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO_A
*  function:
*    this is the function which creates the CIEBasedA ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_A(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_A (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                  CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedA
    lpMem += WriteObject (lpMem, CIEBasedATag); // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeA
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeATag);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> 0.99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> .99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }

 //********** /MatrixA
    lpMem += WriteNewLineObject (lpMem, MatrixATag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (InputIntent == icAbsoluteColorimetric)
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        else
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /End dictionary
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedAEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO
*  function:
*    this is the function which creates the MONO ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Device color type (RGB or GRAY).
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_MONO (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
                DWORD InpDrvClrSp, CSIG InputIntent, BOOL AllowBinary)
{
    BOOL Success = FALSE;
#if 0
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_ABC (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
#else
    if ((InpDrvClrSp == icSigGrayData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
    else
    {
        Success = FALSE;
    }
#endif
    return Success;
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount != 0)
        {
            if (nCount == 1)            // Gamma supplied in ui16 format
            {
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpMem += WriteObject (lpMem, DecodeA3);
            } else
            {
                lpMem += WriteObject (lpMem, StartClip);
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteObject (lpMem, DecodeABCArray);
                lpMem += WriteInt (lpMem, (SINT) CPTag);

                if (!AllowBinary)       // Output ASCII CS
                {
                    lpMem += WriteObject (lpMem, IndexArray);
                } else
                {                       // Output BINARY CS
                    lpMem += WriteObject (lpMem, IndexArray16b);
                }
                lpMem += WriteObject (lpMem, Scale16);
                lpMem += WriteObject (lpMem, EndClip);
            }
        }
        MemFree (hBuff);
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, si16f16toSFLOAT (lpTable));
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a array later to be used in ColorSpace's DecodeABC.
*
***************************************************************************/

SINT 
CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    HGLOBAL hBuff;
    lpOldMem = lpMem;

    lpLineStart = lpMem;

    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount > 1)
        {
            lpMem += WriteNewLineObject (lpMem, Slash);
            lpMem += WriteObject (lpMem, DecodeABCArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            if (!AllowBinary)           // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (i = 0; i < nCount; i++)
                {
                    lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            } else
            {                           // Output BINARY CS
                lpMem += WriteHNAToken (lpMem, 149, nCount);
                lpMem += WriteIntStringU2S (lpMem, lpTable, nCount);
            }
            lpMem += WriteObject (lpMem, DefOp);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*                               GetCSAFromProfile
*  function:
*    this is the function which gets the ColorSpace dictionary array
*    from the the Profile.
*  prototype:
*       static BOOL GetCSAFromProfile(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp,
*                       CSIG        DrvColorSpace,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*       DrvColorSpace --  Profile device color space.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetCSAFromProfile (
                   CHANDLE cp,
                   MEMPTR lpMem,
                   LPDWORD lpcbSize,
                   DWORD InpDrvClrSp,
                   CSIG DrvColorSpace,
                   BOOL AllowBinary)
{
    SINT Index;
    SINT Size;
    if ((DrvColorSpace == icSigGrayData) && (InpDrvClrSp != icSigGrayData))
        return FALSE;

    if (DoesCPTagExist (cp, icSigPs2CSATag) &&
        GetCPTagIndex (cp, icSigPs2CSATag, (LPSINT) & Index) &&
        GetCPElementDataSize (cp, Index, (LPSINT) & Size) &&
        ((lpMem == NULL) || GetCPElementData (cp, Index, lpMem, Size)) &&
        (*lpcbSize = Convert2Ascii (cp, Index, lpMem, *lpcbSize, Size, AllowBinary)))
    {
        return TRUE;
    } else
    {
        return FALSE;
    }
}
/***************************************************************************
*                           GetPS2CSA_DEFG_Intent
*  function:
*    This is the function which creates the CieBasedDEF(G)ColorSpace array
*    based on Intent.
*  prototype:
*       static BOOL GetPS2CSA_DEFG_Intent(
*                   CHANDLE     cp,
*                   MEMPTR      lpBuffer,
*                   LPDWORD     lpcbSize,
*                   CSIG        Intent,
*                   int         Type,
*                   BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_DEFG_Intent (
                       CHANDLE cp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       DWORD InpDrvClrSp,
                       CSIG Intent,
                       int Type,
                       BOOL AllowBinary)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG icSigAToBx;

 // Try to create CieBasedDEFG CSA first.
    if (((Type == TYPE_CIEBASEDDEFG) && (InpDrvClrSp != icSigCmykData) ||
         (Type == TYPE_CIEBASEDDEF) && (InpDrvClrSp != icSigDefData)) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
    switch (Intent)
    {
        case icPerceptual:
            icSigAToBx = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        case icSaturation:
            icSigAToBx = icSigAToB2Tag;
            break;
        case icAbsoluteColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        default:
            return Success;
    }

    if (DoesCPTagExist (cp, icSigAToBx) &&
        GetCPTagIndex (cp, icSigAToBx, (LPSINT) & Index))
    {
        Success = GetPS2CSA_DEFG (cp, lpBuffer, lpcbSize, Intent, Index, Type, AllowBinary);
    }

    return Success;
}
/***************************************************************************
*                               GetPS2ColorSpaceArray
*  function:
*    This is the main function which creates the ColorSpace array
*    from the data supplied in the Profile.
*  prototype:
*       BOOL GetPS2ColorSpaceArray(
*               CHANDLE     cp,
*               CSIG        InputIntent,
*               WORD        InpDrvClrSp,
*               MEMPTR      lpBuffer,
*               LPDWORD     lpcbSize,
*               BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*                       icSigCmykData: input data is cmyk, create CiebasedDEFG CSA.
*                       icSigRgbData : input data is rgb, create CieBasedABC CSA.
*                       icSigDefData : input data is rgb or lab, create CiebasedDEF CSA.
*                       isSigGrayData: input data is gray, create CieBasedA CSA.
*                       0            : Auto. Create CSA depends on profile color space.
*       InputIntent --  Intent.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
BOOL EXTERN
GetPS2ColorSpaceArray (
                       CHANDLE cp,
                       DWORD InputIntent,
                       DWORD InpDrvClrSp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       BOOL AllowBinary)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;
    DWORD dwSaveSize;
    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    dwSaveSize = *lpcbSize;
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

 // Get ColorSpace from Profile.
    if ((CSIG) InputIntent == Intent)
    {
        Success = GetCSAFromProfile (cp, lpBuffer, lpcbSize,
                                     InpDrvClrSp, ColorSpace, AllowBinary);
    }
    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    if (!GetPS2CSA_ABC (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, 
                                        AllowBinary, 1))   // create a backup CSA
                        GetDeviceRGB (lpNewBuffer, &cbNewSize, InpDrvClrSp, 1);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;

                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, 
                                         AllowBinary, 0);
                }
                if (!Success)
                {                           // Create DeviceRGB
                    Success = GetDeviceRGB (lpBuffer, lpcbSize, InpDrvClrSp, 0);
                    Success = FALSE;
                }
                break;
            case icSigCmykData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEFG, AllowBinary);
                if (Success)
                {                       // Create DeviceCMYK for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetDeviceCMYK (lpNewBuffer, &cbNewSize, InpDrvClrSp);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create DeviceCMYK
                    Success = GetDeviceCMYK (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigGrayData:
                Success = GetPS2CSA_MONO (cp, lpBuffer, lpcbSize, InpDrvClrSp, 
                                          (CSIG)InputIntent, AllowBinary);
                if (!Success)
                {                           // Create DeviceGray
                    Success = GetDeviceGray (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigLabData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetPS2CSA_ABC_LAB (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, AllowBinary);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC_LAB (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, AllowBinary);
                }
                break;

            default:
                break;
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "icmstr.h"
#include "profcrd.h"

#define _ICMSEG  ""
#define _ICM2SEG ""
#define  ICMSEG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
BOOL GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve);
SINT CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icSigK007Tag                        0x4B303037   /* 'K007' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */ 
#define    icSigMediaType                      0x4D533031   /* 'MS01' */
#define    icSigDitherType                     0x4D533032   /* 'MS02' */
#define    icSigResolution                     0x4D533033   /* 'MS03' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary, BOOL BackupCSA);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
SINT    BeginGlobalDict(MEMPTR lpMem);
SINT    EndGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;
typedef     SFLOAT __huge   *PFLOAT;
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;

// SRGB98
#define  REVCURVE_RATIO         1

/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

#define CS_ENABLE       1
#define CS_DISABLE      2
#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\profcrd.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICM3SEG)

#define MAXCOLOR8  255

#pragma optimize("", off)

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
       SINT numChan, SINT tableSize, SINT Offset, CSIG Tag, MEMPTR Buff);
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, BOOL, BOOL);
BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
       CSIG Intent, int Type);
static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp);
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
       float far *Input, float far *Output, 
       CSIG ColorSpace, BOOL bCheckOutputTable);
static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output);
static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
       LPSINT lpInTbSize, LPSINT lpOutTbSize, 
       LPCSIG lpIntentTag, LPSINT lpGrids);
static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint);

/***************************************************************************
*                           CreateHostInputOutputArray
*  function:
*    this is the function which creates the output array from the data
*    supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*    MEMPTR     lpMem        : The buffer to save output array.
*    LPHOSTCLUT lpHostClut   : 
*    SINT       nOutputCh    : Number of input channel.
*    SINT       nOutputTable : The size of each input table. 
*    SINT       Offset       : The position of source output data(in icc profile).
*    CSIG       Tag          : To determin the Output table is 8 or 16 bits.
*    MEMPTR     Buff         : The buffer that contains source data(copyed from icc profile)
*
*  returns:
*       SINT    Returns number of bytes of Output Array
*
***************************************************************************/

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
                            SINT numChan, SINT tableSize, 
                            SINT Offset, CSIG Tag, MEMPTR Buff)
{
    SINT    i, j;
    PUSHORT lpMemPtr16;
    MEMPTR  lpMemPtr8;
    MEMPTR  lpTable;

    if (Tag == icSigLut8Type)
        lpMemPtr8 = lpMem;
    else
        lpMemPtr16 = (PUSHORT)lpMem;

    for (i = 0; i < numChan; i++)
    {
        if (Tag == icSigLut8Type)
        {
            ppArray[i] = lpMemPtr8;
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                Offset +
                tableSize * i;
            MemCopy(lpMemPtr8, lpTable, tableSize);
                lpMemPtr8 += tableSize;
        }
        else
        {
            ppArray[i] = (MEMPTR)lpMemPtr16;
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * Offset +
                2 * tableSize * i;
            for (j = 0; j < tableSize; j++)
            {
                *lpMemPtr16++ = (USHORT) ui16toSINT (lpTable);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }
    if (Tag == icSigLut8Type)
        return ((SINT) ((MEMPTR)lpMemPtr8 - lpMem));
    else
        return ((SINT) ((MEMPTR)lpMemPtr16 - lpMem));

}

VOID
GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
            LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size)
{
    if (LutTag == icSigLut8Type)
    {
        *nInputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut8Type) lpLut)->lut.clutPoints);
        *nInputTable = 256L;
        *nOutputTable = 256L;
        *size = 1;  // one byte for each input\output table entry
    } else
    {
        *nInputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut16Type) lpLut)->lut.clutPoints);
        *nInputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.inputEnt);
        *nOutputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.outputEnt);
        *size = 2;  // two bytes for each input\output table entry
    }
}

/***************************************************************************
*                           GetHostCSA
*  function:
*    this is the function which creates a Host CSA
*  parameters:
*       CHANDLE cp       --  Color Profile handle 
*       MEMPTR lpMem     --  Pointer to the memory block. If this point is NULL,
*                            require buffer size.
*       LPDWORD lpcbSize --  Size of the memory block
*       CSIG InputIntent --
*       SINT Index       --  to the icc profile tag that contains the data of Intent
*       int  Type        --  DEF or DEFG
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostCSA (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
            CSIG InputIntent, SINT Index, int Type)
{
    CSIG    PCS, LutTag;
    CSIG    IntentSig;
    SINT    nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT    nInputTable, nOutputTable, nNumbers;
    SINT    i, j, k;
    MEMPTR  lpTable;
    MEMPTR  lpOldMem = lpMem;
    MEMPTR  lpLut = NULL;
    HGLOBAL hLut = 0;
    SINT    LutSize;
    LPHOSTCLUT lpHostClut;

    // Check if we can generate the CS.
    // If we cannot find the required tag - we will return false
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }

    // Estimate the memory size required to hold CS
    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    
    // First Pass. This is a size request
    if (lpMem == NULL)                  
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids;
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids;
        *lpcbSize = *lpcbSize             +   // size of RenderTable 8-bits only
            nInputCh * nInputTable * i    +   // size of input table 8/16-bits
            nOutputCh * nOutputTable * i  +   // size of output table 8/16-bits
            sizeof(HOSTCLUT) + 1024;          // data structure + extra safe space
        MemFree (hLut);
        return (TRUE);
    }

    // Second pass. constructure real HostCSA
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (LutTag == icSigLut8Type)? 8:16;

    // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;
    // Input Array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, LutTag, lpLut);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    // ourput array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, LutTag, lpLut);
 //********** /Table

    lpHostClut->clut = lpMem;
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        SecondGrids = nGrids;
    }
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        for (k = 0; k < SecondGrids; k++)
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (LutTag == icSigLut8Type)
            {
                // Copy 8-bit data.
                MemCopy(lpMem, lpTable, nNumbers);
                lpMem += nNumbers;
            }
            else
            {
                // convert 16 bit integer to right format. then copy only 8 bits.
                for (j = 0; j < nNumbers; j++)
                {
                    *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                }
            }
        }
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}

HGLOBAL GetTRCData(CHANDLE cp,
        LPMEMPTR lpRed,  LPMEMPTR lpGreen,  LPMEMPTR lpBlue,
        LPSINT   lpnRed, LPSINT   lpnGreen, LPSINT   lpnBlue)
{
    SINT     RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT     RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    SINT     MemSize;
    HGLOBAL  hMem;

 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
         return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) lpRed))
        return 0;

    *lpGreen = *lpRed + RedTRCSize;
    *lpBlue = *lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, *lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, *lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, *lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (NULL);
    }
    *lpnRed = ui32toSINT (((lpcpCurveType) *lpRed)->curve.count);
    *lpnGreen = ui32toSINT (((lpcpCurveType) *lpGreen)->curve.count);
    *lpnBlue = ui32toSINT (((lpcpCurveType) *lpBlue)->curve.count);

    return (hMem);
}


static SINT
CreateHostTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                        MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    SINT    i;
    PUSHORT lpPtr16;
    MEMPTR  lpTable;

    lpPtr16 = (PUSHORT)lpMem;
   
    lpHostClut->inputArray[0] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpRed)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[1] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpGreen)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[2] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpBlue)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }
    return ((MEMPTR)lpPtr16 - lpMem);
}

static SINT
CreateHostRevTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                           MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    HGLOBAL   hTemp;
    MEMPTR    lpTemp;

    if (!MemAlloc (lpHostClut->outputEnt * (REVCURVE_RATIO + 1) * 2 ,
                  (HGLOBAL FAR *) &hTemp, (LPMEMPTR) &lpTemp))
    {
        return (0);
    }

    lpHostClut->outputArray[0] = lpMem;
    GetRevCurve (lpRed, lpTemp, lpHostClut->outputArray[0]);
    lpHostClut->outputArray[1] = lpHostClut->outputArray[0] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpGreen, lpTemp, lpHostClut->outputArray[1]);
    lpHostClut->outputArray[2] = lpHostClut->outputArray[1] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpBlue, lpTemp, lpHostClut->outputArray[2]);

    MemFree (hTemp);
    return ( 2 * REVCURVE_RATIO * lpHostClut->outputEnt * 3);
}

static BOOL
GetHostMatrixCSAorCRD(CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, BOOL bCSA)
{
    SINT     nRedCount, nGreenCount, nBlueCount;
    MEMPTR   lpRed = NULL,lpGreen, lpBlue;
    HGLOBAL  hMem;
    LPHOSTCLUT lpHostClut;
    MEMPTR   lpOldMem = lpMem;
    double   pArray[9], pRevArray[9], pTemp[9];
    SINT     i;

    hMem = GetTRCData(cp,
        (LPMEMPTR)&lpRed, (LPMEMPTR)&lpGreen, (LPMEMPTR)&lpBlue,
        (LPSINT)&nRedCount,(LPSINT)&nGreenCount, (LPSINT)&nBlueCount);

    // Estimate the memory size required to hold CRD
    *lpcbSize = (nRedCount + nGreenCount + nBlueCount) * 2 +
           sizeof(HOSTCLUT) + 1024;      // data structure + extra safe space

    if (lpMem == NULL)                   // This is a size request
    {
        MemFree (hMem);
        return TRUE;
    }

    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->dataType = DATA_matrix;
    lpHostClut->clutPoints = 2;
    lpHostClut->pcs = icSigXYZData;
    GetCPWhitePoint(cp, (LPSFLOAT)lpHostClut->whitePoint);

    if (bCSA)
    {
        lpHostClut->inputEnt = (USHORT)nRedCount;
        lpHostClut->inputChan = 3;
        lpMem += CreateHostTRCInputTable(lpMem, lpHostClut,
                                         lpRed, lpGreen, lpBlue);
    }
    else
    {
        lpHostClut->outputEnt = (USHORT)nRedCount;
        lpHostClut->outputChan = 3;
        lpMem += CreateHostRevTRCInputTable(lpMem, lpHostClut,
                                            lpRed, lpGreen, lpBlue);
    }

    MemFree (hMem);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    if (!CreateColorantArray(cp, &pTemp[0], icSigRedColorantTag) ||
        !CreateColorantArray(cp, &pTemp[3], icSigGreenColorantTag) ||
        !CreateColorantArray(cp, &pTemp[6], icSigBlueColorantTag))
    {
       return (FALSE);
    }

    for (i = 0; i < 9; i++)
    {
        pArray[i] = pTemp[i/8*8 + i*3%8];
    }

    if (bCSA)
    {
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pArray[i];
    }
    else
    {
        InvertMatrix(pArray, pRevArray);
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pRevArray[i];
    }

    return TRUE;
}

/***************************************************************************
*                        GetHostCSA_Intent
*  function:
*       This is the function which creates the Host DEF or DEFGColorSpace array
*       based on Intent.
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
                   CSIG Intent, int Type)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG AToBxTag;

    switch (Intent)
    {
        case icPerceptual:
            AToBxTag = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // use RelativeColorimetric data to build it.
            AToBxTag = icSigAToB1Tag;
            break;
        case icSaturation:
            AToBxTag = icSigAToB2Tag;
            break;
        default:
            return FALSE;
            break;
    }
    if (DoesCPTagExist (cp, AToBxTag) &&
        GetCPTagIndex (cp, AToBxTag, (LPSINT) & Index))
    {
        Success = GetHostCSA(cp, lpBuffer, lpcbSize, Intent, Index, Type);
    }
    else if ((DoesTRCAndColorantTagExist(cp)) &&
            (Type == TYPE_CIEBASEDDEF))
    {
        Success = GetHostMatrixCSAorCRD(cp, lpBuffer, lpcbSize, TRUE);
    }

    return Success;
}
/***************************************************************************
*                            GetHostColorSpaceArray
*  function:
*    This is the main function which creates the Host CSA
*    from the data supplied in the Profile.
*  parameters:
*       cp          --  Color Profile handle
*       InputIntent --  Intent.
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostColorSpaceArray (CHANDLE cp, DWORD InputIntent,
                       MEMPTR  lpBuffer, LPDWORD lpcbSize)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;

    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEF);
                break;
            case icSigCmykData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEFG);
                break;
            default:
                break;
        }
    }
    return Success;
}

//===========================================================================

/***************************************************************************
*                             CreateHostLutCRD
*  function:
*    this is the function which creates the Host CRD
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       InputIntent --  Intent.
*
*  returns:
*       SINT        --  Size of Host CRD.
***************************************************************************/

static SINT 
CreateHostLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT     nInputCh, nOutputCh, nGrids;
    SINT     nInputTable, nOutputTable, nNumbers;
    CSIG     Tag, PCS;
    CSIG     IntentSig;

    SINT     Ret;
    SINT     i, j;
    MEMPTR   lpTable;

    MEMPTR   Buff = NULL;
    SINT     MemSize = 0;
    MEMPTR   lpOldMem = lpMem;
    HGLOBAL  hMem;
    LPHOSTCLUT  lpHostClut;

    // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }

    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (((nOutputCh != 3) && (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }

    // First Pass. This is a size request
    if (lpMem == NULL)       
    {
        Ret = nInputCh * nInputTable * i         +  // Input table 8/16-bits
            nOutputCh * nOutputTable * i         +  // Output table 8/16-bits
            nOutputCh * nGrids * nGrids * nGrids +  // CLUT 8-bits only
            sizeof(HOSTCLUT)                     +  // Data structure 
            1024;                                   // safe

        MemFree (hMem);
        return (Ret);
    }
     
    // Second Pass. Get a HostCRD
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (Tag == icSigLut8Type)? 8:16;

    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    // Support absolute whitePoint
    if (!GetCPMediaWhitePoint (cp, (LPSFLOAT)lpHostClut->mediaWP)) // .. Media WhitePoint
    {
        lpHostClut->mediaWP[0] = lpHostClut->whitePoint[0];
        lpHostClut->mediaWP[1] = lpHostClut->whitePoint[1];
        lpHostClut->mediaWP[2] = lpHostClut->whitePoint[2];
    }
    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;

//******** Input array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, Tag, Buff);
//******** the offset to the position of output array.
    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
//******** Output array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, Tag, Buff);
//******** Matrix.
    if (PCS == icSigXYZData)
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
        } else
        {
            lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
        }
        for (i = 0; i < 9; i++)
        {
            lpHostClut->e[i] = (float)((si16f16toSFLOAT (lpTable)) / CIEXYZRange);
            lpTable += sizeof (icS15Fixed16Number);
        }
    }
//********** RenderTable
    nNumbers = nGrids * nGrids * nOutputCh;
    lpHostClut->clut = lpMem;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (Tag == icSigLut8Type)
        {
            MemCopy(lpMem, lpTable, nNumbers);
            lpMem += nNumbers;
        }
        else
        {
            for (j = 0; j < nNumbers; j++)
            {
                *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}


/***************************************************************************
*                      GetHostColorRenderingDictionary
*  function:
*    this is the main function which creates the Host CRD
*  parameters:
*       cp          --  Color Profile handle
*       Intent      --  Intent.
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  size of memory block.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
static BOOL
GetHostColorRenderingDictionary (CHANDLE cp, DWORD Intent,
                                MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT Index;
    CSIG BToAxTag;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }

    switch (Intent)
    {
        case icPerceptual:
            BToAxTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // Use RelativeColorimetric to calculate this CRD.
            BToAxTag = icSigBToA1Tag;
            break;

        case icSaturation:
            BToAxTag = icSigBToA2Tag;
            break;

        default:
           *lpcbSize = (DWORD) 0;
            return FALSE;
    }

    if (DoesCPTagExist (cp, BToAxTag) &&
        GetCPTagIndex (cp, BToAxTag, (LPSINT) & Index))
    {
        *lpcbSize = CreateHostLutCRD (cp, Index, lpMem, Intent);
    }
    else if(DoesTRCAndColorantTagExist(cp))
    {
        GetHostMatrixCSAorCRD(cp, lpMem, lpcbSize, FALSE);
    }
    return (*lpcbSize > 0);
}

//========================================================================
/***************************************************************************
*                               g
*  function:
*    Calculate function y = g(x). used in Lab->XYZ conversion
*    y = g(x):      g(x) = x*x*x             if x >= 6/29
*                   g(x) = 108/841*(x-4/29)  otherwise
*  parameters:
*       f           --  x
*  returns:
*       SINT        --  y
***************************************************************************/

static float g(float f)
{
    float frc;
    if (f >= (6/29))
    {
        frc = f * f * f;
    }
    else
    {
        frc = f - (4.0f / 29.0f) * (108.0f / 841.0f);
    }
    return frc;
}

/***************************************************************************
*                          inverse_g
*  function:
*    Calculate inverse function y = g(x). used in XYZ->Lab conversion
*  parameters:
*       f           --  y
*  returns:
*       SINT        --  x
***************************************************************************/
static float inverse_g(float f)
{
    double frc;
    if (f >= (6.0*6.0*6.0)/(29.0*29.0*29.0))
    {
        frc = pow(f, 1.0 / 3.0);
    }
    else
    {
        frc = f * (841.0 / 108.0) + (4.0 / 29.0);
    }
    return (float)frc;
}

//========================================================================

static BOOL
TableInterp3(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpA, tmpBC;
    int    cellA, cellB, cellC;
    float  a, b, c;
    short  Grids;
    short  outputChan;
    MEMPTR v000, v001, v010, v011;
    MEMPTR v100, v101, v110, v111;
    float  vx0x, vx1x;
    float  v0xx, v1xx;
    int    idx;

    cellA = (int)(fTemp[0]);
    a = fTemp[0] - cellA;

    cellB = (int)(fTemp[1]);
    b = fTemp[1] - cellB;

    cellC = (int)(fTemp[2]);
    c = fTemp[2] - cellC;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpA  = outputChan * Grids * Grids; 
    tmpBC = outputChan * (Grids * cellB + cellC);

    // Calculate 8 surrounding cells.
    v000 = lpHostClut->clut + tmpA * cellA + tmpBC;
    v001 = (cellC < (Grids - 1))? v000 + outputChan : v000;
    v010 = (cellB < (Grids - 1))? v000 + outputChan * Grids : v000;
    v011 = (cellC < (Grids - 1))? v010 + outputChan : v010 ;

    v100 = (cellA < (Grids - 1))? v000 + tmpA : v000;
    v101 = (cellC < (Grids - 1))? v100 + outputChan : v100;
    v110 = (cellB < (Grids - 1))? v100 + outputChan * Grids : v100;
    v111 = (cellC < (Grids - 1))? v110 + outputChan : v110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 4 bottom cells.
        vx0x = *v000 + c * (int)((int)*v001 - (int)*v000);
        vx1x = *v010 + c * (int)((int)*v011 - (int)*v010);
        v0xx = vx0x + b * (vx1x - vx0x);

        // Calculate the average of 4 upper cells.
        vx0x = *v100 + c * (int)((int)*v101 - (int)*v100);
        vx1x = *v110 + c * (int)((int)*v111 - (int)*v110);
        v1xx = vx0x + b * (vx1x - vx0x);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xx + a * (v1xx - v0xx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v000++;
            v001++;
            v010++;
            v011++;
            v100++;
            v101++;
            v110++;
            v111++;
        }
    }

    return TRUE;
}

static BOOL
TableInterp4(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpH, tmpI, tmpJK;
    int    cellH, cellI, cellJ, cellK;
    float  h, i, j, k;
    short  Grids;
    short  outputChan;
    MEMPTR v0000, v0001, v0010, v0011;
    MEMPTR v0100, v0101, v0110, v0111;
    MEMPTR v1000, v1001, v1010, v1011;
    MEMPTR v1100, v1101, v1110, v1111;
    float  vxx0x, vxx1x;
    float  vx0xx, vx1xx;
    float  v0xxx, v1xxx;
    int    idx;

    cellH = (int)(fTemp[0]);
    h = fTemp[0] - cellH;

    cellI = (int)(fTemp[1]);
    i = fTemp[1] - cellI;

    cellJ = (int)(fTemp[2]);
    j = fTemp[2] - cellJ;

    cellK = (int)(fTemp[3]);
    k = fTemp[3] - cellK;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpI  = outputChan * Grids * Grids;
    tmpH  = tmpI * Grids; 
    tmpJK = outputChan * (Grids * cellJ + cellK);

    // Calculate 16 surrounding cells.
    v0000 = lpHostClut->clut + tmpH * cellH + tmpI * cellI + tmpJK;
    v0001 = (cellK < (Grids - 1))? v0000 + outputChan : v0000;
    v0010 = (cellJ < (Grids - 1))? v0000 + outputChan * Grids : v0000;
    v0011 = (cellK < (Grids - 1))? v0010 + outputChan : v0010;

    v0100 = (cellI < (Grids - 1))? v0000 + tmpI : v0000;
    v0101 = (cellK < (Grids - 1))? v0100 + outputChan : v0100;
    v0110 = (cellJ < (Grids - 1))? v0100 + outputChan * Grids : v0100;
    v0111 = (cellK < (Grids - 1))? v0110 + outputChan : v0110;

    v1000 = (cellH < (Grids - 1))? v0000 + tmpH : v0000;
    v1001 = (cellK < (Grids - 1))? v1000 + outputChan : v1000;
    v1010 = (cellJ < (Grids - 1))? v1000 + outputChan * Grids : v1000;
    v1011 = (cellK < (Grids - 1))? v1010 + outputChan : v1010;

    v1100 = (cellI < (Grids - 1))? v1000 + tmpI : v1000;
    v1101 = (cellK < (Grids - 1))? v1100 + outputChan : v1100;
    v1110 = (cellJ < (Grids - 1))? v1100 + outputChan * Grids : v1100;
    v1111 = (cellK < (Grids - 1))? v1110 + outputChan : v1110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 8 bottom cells.
        vxx0x = *v0000 + k * (int)((int)*v0001 - (int)*v0000);
        vxx1x = *v0010 + k * (int)((int)*v0011 - (int)*v0010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v0100 + k * (int)((int)*v0101 - (int)*v0100);
        vxx1x = *v0110 + k * (int)((int)*v0111 - (int)*v0110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v0xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the average of 8 upper cells.
        vxx0x = *v1000 + k * (int)((int)*v1001 - (int)*v1000);
        vxx1x = *v1010 + k * (int)((int)*v1011 - (int)*v1010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v1100 + k * (int)((int)*v1101 - (int)*v1100);
        vxx1x = *v1110 + k * (int)((int)*v1111 - (int)*v1110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v1xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xxx + h * (v1xxx - v0xxx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v0000++;
            v0001++;
            v0010++;
            v0011++;
            v0100++;
            v0101++;
            v0110++;
            v0111++;
            v1000++;
            v1001++;
            v1010++;
            v1011++;
            v1100++;
            v1101++;
            v1110++;
            v1111++;
        }
    }

    return TRUE;
}


/***************************************************************************
*                         CheckColorLookupTable
*  function:
*    This function check RenderTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input (in range [0 gred-1]) /
*                                 output(in range [0 1)
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp) 
{
    if (lpHostClut->inputChan == 3)
    {
        TableInterp3(lpHostClut, fTemp);
    }
    else if(lpHostClut->inputChan == 4)
    {
        TableInterp4(lpHostClut, fTemp);
    }
    return TRUE;
}

/***************************************************************************
*                         CheckInputOutputTable
*  function:
*    This function check inputTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input / output data
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, 
                      BOOL bCSA, BOOL bInputTable) 
{
    int     i;
    short   Grids;
    USHORT  floor1, ceiling1;
    float   fIndex;
    int     numChan;
    int     numEnt;
    PMEMPTR ppArray;

    if (bInputTable)
    {
        numChan = lpHostClut->inputChan;
        numEnt = lpHostClut->inputEnt - 1;
        ppArray = lpHostClut->inputArray;
    }
    else
    {
        numChan = lpHostClut->outputChan;
        numEnt = lpHostClut->outputEnt - 1;
        ppArray = lpHostClut->outputArray;
    }

    Grids = lpHostClut->clutPoints;
    for (i = 0; (i <= MAXCHANNELS) && (i < numChan); i++)
    {
        fTemp[i] = (fTemp[i] < 0)? 0: ((fTemp[i] > 1)? 1: fTemp[i]);
        fIndex = fTemp[i] * numEnt;
        if (lpHostClut->lutBits == 8)
        {
            floor1 = ppArray[i][(int)fIndex];
            ceiling1 = ppArray[i][((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 127.0);
            else
                fTemp[i] = (float)(fTemp[i] / 255.0);
        }
        else
        {
            floor1 = ((PUSHORT)(ppArray[i]))[(int)fIndex];
            ceiling1 = ((PUSHORT)(ppArray[i]))[((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 32767.0);
            else
                fTemp[i] = (float)(fTemp[i] / 65535.0);

        }
        if (bInputTable)
        {
            fTemp[i] *= (Grids - 1);
            if (fTemp[i] > (Grids - 1))
                fTemp[i] = (float)(Grids - 1);
        }
    }
    return TRUE;
}

static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = (Input[0] * 50 + 16) / 116;
    fa = (Input[1] * 128 - 128) / 500;
    fb = (Input[2] * 128 - 128) / 200;
    Output[0] = whitePoint[0] * g(fL + fa);
    Output[1] = whitePoint[1] * g(fL);
    Output[2] = whitePoint[2] * g(fL - fb);
}

static void
XYZToLab(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = inverse_g(Input[0] / whitePoint[0]);
    fa = inverse_g(Input[1] / whitePoint[1]);
    fb = inverse_g(Input[2] / whitePoint[2]);
    Output[0] = (fa * 116 - 16) / 100;
    Output[1] = (fL * 500 - fa * 500 + 128) / 255;
    Output[2] = (fa * 200 - fb * 200 + 128) / 255;
}

static void
ApplyMatrix(PFLOAT e, float far *Input, float far *Output)
{
    SINT  i, j;

    for (i = 0; i < 3; i++)
    {
        j = i*3;
        Output[i] = e[j ]    * Input[0] +
                    e[j + 1] * Input[1] +
                    e[j + 2] * Input[2];
    }
}

/***************************************************************************
*                         DoHostConversionCRD
*  function:
*    This function converts XYZ/Lab to RGB/CMYK by using HostCRD
*  parameters:
*       LPHOSTCLUT lpHostCRD  -- pointer to a HostCRD
*       LPHOSTCLUT lpHostCSA  -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
                     float far *Input, float far *Output,
                     CSIG ColorSpace, BOOL bCheckOutputTable)
{
    float   fTemp[MAXCHANNELS];
    float   fTemp1[MAXCHANNELS];
    int     i;

/**
** Input XYZ or Lab in range [0 2]
***/
    // When sampling the deviceCRD, skip the input table.
    // If lpHostCSA is not NULL, the current CRD is targetCRD, we
    // need to do input table conversion
    if (lpHostCSA)
    {
        // Convert Lab to XYZ  in range [ 0 whitePoint ]
        if ((lpHostCRD->pcs == icSigXYZData) && 
            (lpHostCSA->pcs == icSigLabData))
        {
            LabToXYZ(Input, fTemp1, lpHostCRD->whitePoint);
        }
        // Convert XYZ to Lab in range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigXYZData))
        {
            XYZToLab(Input, fTemp, lpHostCSA->whitePoint);
        }
        // Convert Lab to range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigLabData))
        {
            for (i = 0; i < 3; i++)
                fTemp[i] = Input[i] / 2;
        }
        // Convert XYZ to XYZ (based on white point) to range [0 1]
        else
        {   // TODO: different intents using different conversion.
            // icRelativeColorimetric: using Bradford transform.
            // icAbsoluteColorimetric: using scaling.
            for (i = 0; i < 3; i++)
                fTemp1[i] = Input[i] * lpHostCRD->whitePoint[i] / lpHostCSA->whitePoint[i];
        }
 
        // Matrix, used for XYZ data only or Matrix icc profile only
        if (lpHostCRD->pcs == icSigXYZData)
        {
            ApplyMatrix(lpHostCRD->e, fTemp1, fTemp);
        }
     
        if (lpHostCRD->dataType != DATA_matrix)
        {
            //Search input Table
            CheckInputOutputTable(lpHostCRD, fTemp, 0, 1);
        }
    }
    // If the current CRD is device CRD, we do not need to do input
    // table conversion.
    else
    {
        short   Grids;
        Grids = lpHostCRD->clutPoints;
        // Sample data may be XYZ or Lab. It depends on Target icc profile.
        // If the PCS of the target icc profile is XYZ, input data will be XYZ.
        // If the PCS of the target icc profile is Lab, input data will be Lab.

        if (lpHostCRD->dataType == DATA_matrix)
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i];
            }
        }
        else
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i]* (Grids - 1);
                if (fTemp[i] > (Grids - 1))
                    fTemp[i] = (float)(Grids - 1);
            }
        }
    }   // bCheckInputTable

    if (lpHostCRD->dataType != DATA_matrix)
    {
        // Rendering table
        CheckColorLookupTable(lpHostCRD, fTemp);

        /**
         ** Output RGB or CMYK in range [0 1]
        ***/
    }
    if (bCheckOutputTable)
    {
        //Output Table
        CheckInputOutputTable(lpHostCRD, fTemp, 0, 0);
    }
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostCRD->outputChan); i++)
    {
        Output[i] = fTemp[i];
    }

   return TRUE;
}

/***************************************************************************
*                         DoHostConversionCSA
*  function:
*    This function converts RGB/CMYK to XYZ/Lab by using HostCSA
*  parameters:
*       LPHOSTCLUT lpHostCLUT -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output)
{
    float   fTemp[MAXCHANNELS];
    int     i;

/**
** Input RGB or CMYK in range [0 1]
***/
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->inputChan); i++)
    {
        fTemp[i] = Input[i];
    }

    if (lpHostClut->dataType == DATA_matrix)
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);
        ApplyMatrix(lpHostClut->e, fTemp, Output);
    }
    else
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);

        // Rendering table
        CheckColorLookupTable(lpHostClut, fTemp);

        //Output Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 0 );

        /**
         ** Output XYZ or Lab in range [0 2]
         ***/
        for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->outputChan); i++)
        {
            Output[i] = fTemp[i];
        }
    }

    return TRUE;
}               

static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
    LPSINT lpInTbSize, LPSINT lpOutTbSize, 
    LPCSIG lpIntentTag, LPSINT lpGrids)
{
    CSIG    Tag;
    SINT    Index;
    SINT    Ret = 0;
    MEMPTR  Buff = NULL;
    SINT    MemSize = 0;
    HGLOBAL hMem;
    SINT    outputChan, outputEnt;
    SINT    inputChan, inputEnt;
    SINT    Grids;
    SINT    i;

    switch (Intent)
    {
        case icPerceptual:
            *lpIntentTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            *lpIntentTag = icSigBToA1Tag;
            break;

        case icSaturation:
            *lpIntentTag = icSigBToA2Tag;
            break;

        default:
            return FALSE;
    }
    if (!DoesCPTagExist (cp, *lpIntentTag) ||
        !GetCPTagIndex (cp, *lpIntentTag, (LPSINT) & Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        BOOL retVal = FALSE;

        if (NULL != Buff)
        {
            MemFree (hMem);
        }

        // Matrix icc profile.

        *lpGrids = 2;
        if (lpInTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpInTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpInTbSize = *lpInTbSize * 3;
        }
        if (lpOutTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpOutTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpOutTbSize = *lpOutTbSize * 3;
        }
        return retVal;
    }

    if (lpInTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if (inputChan != 3)
        {
            MemFree (hMem);
            return FALSE;
        }

        *lpInTbSize = inputChan * inputEnt * 6;  // Number of INT bytes
        *lpGrids = Grids;
    }

    if (lpOutTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if ((outputChan != 3) && (outputChan != 4))
        {
            MemFree (hMem);
            return FALSE;
        }
        *lpOutTbSize = outputChan * outputEnt * 6; // Number of INT bytes
        *lpGrids = Grids;
    }

    MemFree (hMem);
    return TRUE;
}

/***************************************************************************
*                         CreateOutputArray
*  function:
*       Create CSA/CRD output arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to a buffer which will contain the arrays. 
*       SINT    nOutputCh    -- Number of output channel. if lpHostClut, no meaning.
*       SINT    nOutputTable -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contain LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of output array created.
***************************************************************************/

SINT
CreateOutputArray (MEMPTR lpMem, SINT nOutputCh, 
    SINT nOutputTable, SINT Offset, MEMPTR Intent, 
    CSIG Tag, MEMPTR Buff, BOOL AllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nOutputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->outputChan);
        nOutputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->outputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
              icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);
        
        if (lpHostClut)
            lpTable = ((LPHOSTCLUT)lpHostClut)->outputArray[i];
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                    Offset +
                    nOutputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                    2 * Offset +
                    2 * nOutputTable * i;
        }

        if (!AllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nOutputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nOutputTable; j++)
                {
                    if (lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nOutputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nOutputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nOutputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

/***************************************************************************
*                         CreateInputArray
*  function:
*       Create CSA/CRD Input arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to the buffer which will contain the arrays.
*       SINT    nInputCh     -- Number of input channel. if lpHostClut, no meaning.
*       SINT    nInputTable  -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contains LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of inpput array created.
***************************************************************************/

SINT
CreateInputArray (MEMPTR lpMem, SINT nInputCh, 
    SINT nInputTable, MEMPTR Intent, CSIG Tag, 
    MEMPTR Buff, BOOL bAllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nInputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->inputChan);
        nInputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->inputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
               icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);

        if (lpHostClut)
        {
            lpTable = ((LPHOSTCLUT)lpHostClut)->inputArray[i];
        }
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) + nInputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) + 2 * nInputTable * i;
        }
        if (!bAllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable,lpLineStart, nInputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nInputTable; j++)
                {
                    if(lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nInputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nInputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nInputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

SINT
SendCRDLMN(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs)
{
    MEMPTR  lpOldMem;
    SINT    i, j;

    lpOldMem = lpMem;

//********** /MatrixLMN
    if (icAbsoluteColorimetric == Intent)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);

        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 3; j++)
                lpMem += WriteFloat (lpMem,
                    (double) (i == j) ? whitePoint[i] / mediaWP[i] : 0.0);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double) whitePoint[i]);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, RangeLMNLab);
    }

 //********** /EncodeLMN
    lpMem += WriteNewLineObject (lpMem, EncodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        if (pcs != icSigXYZData)
        {
            lpMem += WriteFloat (lpMem, (double)whitePoint[i]);
            lpMem += WriteObject (lpMem, DivOp);
            lpMem += WriteObject (lpMem, EncodeLMNLab);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    return (SINT)(lpMem - lpOldMem);
}


SINT
SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    if (icAbsoluteColorimetric != Intent)
    {
     //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, RangePQR);

     //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, MatrixPQR);
    }
    else
    {
    //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
        }
        lpMem += WriteObject (lpMem, EndArray);
    //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, Identity);
    }
//********** /TransformPQR
    lpMem += WriteNewLineObject (lpMem, TransformPQRTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem,
            (icAbsoluteColorimetric != Intent) ? TransformPQR[i] : NullOp);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
   
    return (SINT)(lpMem - lpOldMem);
} 

SINT
SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
           MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i, j;
    double TempMatrixABC[9];
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC);
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        if (e)
        {
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, e[i + j * 3]);
                }
            }
        }
        else
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
            } else
            {
                lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
            }
            for (i = 0; i < 9; i++)
            {
                TempMatrixABC[i] = ((double) si16f16toSFLOAT (lpTable)) / CIEXYZRange;
                lpTable += sizeof (icS15Fixed16Number);
            }
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, TempMatrixABC[i + j * 3]);
                }
            }
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nInputCh == 0)
        return (SINT)(lpMem - lpOldMem);

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        if (pcs == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
        lpMem += WriteObject (lpMem, StartClip);
        if (e)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)              // Output ASCII CRD
        {
            lpMem += WriteNewLineObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? 
                              Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT
SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

//********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

//********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
        SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    for (i = 0; i < nOutputCh; i++)
    {
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        if (bHost)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16);
            }
        }

        lpMem += WriteObject (lpMem, EndFunction);
    }
    return (SINT)(lpMem - lpOldMem);
}

//========================================================================
/***************************************************************************
*                  GetPS2PreviewColorRenderingDictionary
*  function:
*    This is the main function that creates proofing CRD.
*    It does the following:
*       1) Creates host TargetCRD, TargetCSA and DevCRD.
*       2) Create proofing CRD by sampling TargetCRD TargetCSA and DevCRD.
*       3) Uses TargetCRD's input table as proofingCRD's input table.
*       4) Uses DevCRD's output table as proofingCRD's output table.
*       5) Sample data is XYZ or Lab, depends on PCS of TargetCRD.
*
*  parameters:
*       CHANDLE  cpDev        -- handle to Target icc profile.
*       CHANDLE  cpTarget     -- handle to Dev icc profile.
*       DWORD    Intent       -- intent 
*       MEMPTR   lpMem        -- pointer to buffer for proofCRD,
*                                NULL means query buffer size.
*       LPDWORD  lpcbSize     -- as input: current buffer size
*                             -- as output: real proofCRD size.
*       BOOL     bAllowBinary -- create a ascii or binary proofCRD.
*
*  returns:
*       BOOL                  -- TRUE/FALSE
***************************************************************************/

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (CHANDLE cpDev,
                                CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL bAllowBinary)
{
    MEMPTR    lpTargetCRD, lpTargetCSA, lpDevCRD;
    DWORD     cbTargetCRD, cbTargetCSA, cbDevCRD;
    HGLOBAL   hTargetCRD, hTargetCSA, hDevCRD;
    BOOL      Success = FALSE;
    float     Input[MAXCHANNELS];
    float     Output[MAXCHANNELS];
    float     Temp[MAXCHANNELS];
    int       i, j, k, l;
    MEMPTR    lpLineStart;
    MEMPTR    lpOldMem;
    CSIG      ColorSpace;
    CSIG      DevColorSpace;
    static CSIG      IntentTag;
    static SINT      PreviewCRDGrid;
    SINT      OutArraySize, InArraySize;
    char      PublicArrayName[TempBfSize];
    SINT      TargetGrids, DevGrids;

    // First pass, return the size of Previewind CRD.
    if (lpMem == NULL)
    {
        SINT   dwOutArraySizr = 0;

        i = 3;      // Default output channal;
        if ((GetCPDevSpace (cpDev, (LPCSIG) & DevColorSpace)) &&
                          (DevColorSpace == icSigCmykData))
        {
            i = 4;
        }

        // Get the input array size IntentTag and Grid of the Target icc profile.
        if (!GetCRDInputOutputArraySize(cpTarget, Intent,
            &InArraySize, NULL, &IntentTag, &TargetGrids ))
            return FALSE;

        // Get the output array size IntentTag and Grid of the Dev icc profile.
        if (!GetCRDInputOutputArraySize(cpDev, Intent,
            NULL, &OutArraySize, &IntentTag, &DevGrids ))
            return FALSE;

        PreviewCRDGrid = (TargetGrids > DevGrids)? TargetGrids: DevGrids;

        // Min proofing CRD grid will be PREVIEWCRDGRID
        if (PreviewCRDGrid < PREVIEWCRDGRID)
            PreviewCRDGrid = PREVIEWCRDGRID;
        *lpcbSize = PreviewCRDGrid * PreviewCRDGrid * PreviewCRDGrid * 
                    i * 2 +           // CLUT size (Hex output)
                    OutArraySize +    // Output Array size
                    InArraySize  +    // Input Array size
                    4096;             // Extra PostScript staff.
         return (TRUE);
    }

    // Second pass, return the Previewind CRD.
    lpOldMem = lpMem;

    //Query the sizes of Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, NULL, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, NULL, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, NULL, &cbDevCRD)))
    {
        return (Success);
    }

    //Alloc the buffers for Host TargetCRD, TargetCSA and DevCRD.
    hTargetCRD = hTargetCSA = hDevCRD = 0;
    if (!MemAlloc (cbTargetCRD, (HGLOBAL FAR *)&hTargetCRD, (LPMEMPTR)&lpTargetCRD) ||
        !MemAlloc (cbTargetCSA, (HGLOBAL FAR *)&hTargetCSA, (LPMEMPTR)&lpTargetCSA) ||
        !MemAlloc (cbDevCRD, (HGLOBAL FAR *)&hDevCRD, (LPMEMPTR)&lpDevCRD))
    {
        goto Done;
    }

    //Build Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, lpTargetCRD, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, lpTargetCSA, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, lpDevCRD, &cbDevCRD)))
    {
        goto Done;
    }

//  Build Proofing CRD based on Host TargetCRD TargetCSA and DevCRD.
//  We use TargetCRD input tables and matrix as the
//  input tables and matrix of the ProofCRD.
//  We use DevCRD output tables as the output tables of the ProofCRD.

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cpDev, IntentTag, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, (SINT)0, (SINT)0, (MEMPTR)PublicArrayName, 
             (CSIG)0, NULL, bAllowBinary, lpTargetCRD);

    lpMem += CreateOutputArray (lpMem, (SINT)0, (SINT)0, (SINT)0, 
             (MEMPTR)PublicArrayName, (CSIG)0, NULL, bAllowBinary, lpDevCRD);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

    lpMem += WriteNewLineObject (lpMem, IntentType); // RenderingIntent
    switch (Intent)
    {
        case icPerceptual:
            lpMem += WriteObject (lpMem, IntentPer);
            break;

        case icSaturation:
            lpMem += WriteObject (lpMem, IntentSat);
            break;

        case icRelativeColorimetric:
            lpMem += WriteObject (lpMem, IntentRCol);
            break;

        case icAbsoluteColorimetric:
            lpMem += WriteObject (lpMem, IntentACol);
            break;
    }

//********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send PQR - For White Point correction
    lpMem += SendCRDPQR(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint,
        ((LPHOSTCLUT)lpTargetCRD)->mediaWP,
        ((LPHOSTCLUT)lpTargetCRD)->pcs);

//********** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpTargetCRD)->pcs,
        ((LPHOSTCLUT)lpTargetCRD)->inputChan,
        NULL,
        ((LPHOSTCLUT)lpTargetCRD)->e,
        (((LPHOSTCLUT)lpTargetCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        bAllowBinary);

//********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Na
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nb
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    ColorSpace = ((LPHOSTCLUT)lpDevCRD)->pcs;
    for (i = 0; i < PreviewCRDGrid; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (bAllowBinary)
        {
            lpMem += WriteStringToken (lpMem, 143, 
                PreviewCRDGrid * PreviewCRDGrid * ((LPHOSTCLUT)lpDevCRD)->outputChan);
        }
        else
        {
            lpMem += WriteObject (lpMem, BeginString);
        }
        Input[0] = ((float)i) / (PreviewCRDGrid - 1);
        for (j = 0; j < PreviewCRDGrid; j++)
        {
            Input[1] = ((float)j) / (PreviewCRDGrid - 1);
            for (k = 0; k < PreviewCRDGrid; k++)
            {
                Input[2] = ((float)k) / (PreviewCRDGrid - 1);

                DoHostConversionCRD ((LPHOSTCLUT)lpTargetCRD, NULL, Input, Output, ColorSpace, 1);
                DoHostConversionCSA ((LPHOSTCLUT)lpTargetCSA, Output, Temp);
                DoHostConversionCRD ((LPHOSTCLUT)lpDevCRD, (LPHOSTCLUT)lpTargetCSA, 
                                     Temp, Output, 0, 0);
                for (l = 0; l < ((LPHOSTCLUT)lpDevCRD)->outputChan; l++)
                {
                    if (bAllowBinary)
                    {
                        *lpMem++ = (BYTES)(Output[l]*255);
                    }
                    else
                    {
                        lpMem += WriteHex (lpMem, (USHORT)(Output[l]*255));
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
            }
        }
        if (!bAllowBinary)
            lpMem += WriteObject (lpMem, EndString);
    }
    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteInt (lpMem, ((LPHOSTCLUT)lpDevCRD)->outputChan);

//********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpDevCRD)->outputChan,
        (((LPHOSTCLUT)lpDevCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        TRUE,
        bAllowBinary);


    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndDict); // End dictionary definition
    lpMem += WriteNewLineObject (lpMem, CRDEnd);
    Success = TRUE;

Done:
    *lpcbSize = (DWORD)(lpMem - lpOldMem);

    if (hTargetCRD)
         MemFree(hTargetCRD);
    if (hTargetCSA)
         MemFree(hTargetCSA);
    if (hDevCRD)
         MemFree(hDevCRD);
    return (Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jan99\dll32\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB      0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004   
#define LCS_GM_ABSOLUTE     0x0000FFFF
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN      0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK       CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;

// SRGB98
#define  REVCURVE_RATIO         1

/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
   LOGCOLORSPACE   lcsSource;  // source image colorspace
   HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
         CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

#define CS_ENABLE       1
#define CS_DISABLE      2
#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
                  LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
                  LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
                   LPVOID    lpSrc, DWORD dwSrcFlags,
                     DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
                   LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
                   LPVOID   lpSrc,
                   LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
                  LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
                  LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
                   LPVOID    lpSrc, DWORD dwSrcFlags, 
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
                   LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
                   LPVOID   lpSrc,
                   LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
#endif
//SRGB98
BOOL    EXTERN InvertMatrix (double FAR * lpInMatrix, double FAR * lpOutMatrix);
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);
BOOL   DoesTRCAndColorantTagExist(CHANDLE cp);
BOOL   GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize);
#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    MatrixPQR[]         ;
extern  char _far    RangePQR[]          ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 16

typedef enum { DATA_lut=0, DATA_matrix } DATATYPE;

typedef struct tagHOSTCLUT {
    USHORT         size;
    DATATYPE       dataType;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                    CHANDLE cpDev,
                    CHANDLE cpTarget,
                    DWORD Intent,
                    MEMPTR lpMem,
                    LPDWORD lpcbSize,
                    BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\getcrd.c ===
#include "generic.h"

#pragma code_seg(_ICMSEG)

char ICMSEG BeginString[]       = "<";
char ICMSEG EndString[]         = ">";
char ICMSEG BeginArray[]        = "[";
char ICMSEG EndArray[]          = "]";
char ICMSEG BeginFunction[]     = "{";
char ICMSEG EndFunction[]       = "}bind ";
char ICMSEG BeginDict[]         = "<<" ;
char ICMSEG EndDict[]           = ">>" ;
char ICMSEG BlackPoint[]        = "[0 0 0]" ;
char ICMSEG DictType[]          = "/ColorRenderingType 1 ";

char ICMSEG WhitePointTag[]     = "/WhitePoint " ;
char ICMSEG BlackPointTag[]     = "/BlackPoint " ;
char ICMSEG RangePQRTag[]       = "/RangePQR " ;
char ICMSEG TransformPQRTag[]   = "/TransformPQR " ;
char ICMSEG MatrixPQRTag[]      = "/MatrixPQR " ;

char ICMSEG RangeABCTag[]       = "/RangeABC " ;
char ICMSEG MatrixATag[]        = "/MatrixA ";
char ICMSEG MatrixABCTag[]      = "/MatrixABC ";
char ICMSEG EncodeABCTag[]      = "/EncodeABC " ;
char ICMSEG RangeLMNTag[]       = "/RangeLMN " ;
char ICMSEG MatrixLMNTag[]      = "/MatrixLMN " ;
char ICMSEG EncodeLMNTag[]      = "/EncodeLMN " ;
char ICMSEG RenderTableTag[]    = "/RenderTable " ;
char ICMSEG CIEBasedATag[]      = "/CIEBasedA " ;
char ICMSEG CIEBasedABCTag[]    = "/CIEBasedABC " ;
char ICMSEG CIEBasedDEFGTag[]   = "/CIEBasedDEFG " ;
char ICMSEG CIEBasedDEFTag[]    = "/CIEBasedDEF " ;
char ICMSEG DecodeATag[]        = "/DecodeA " ;
char ICMSEG DecodeABCTag[]      = "/DecodeABC " ;
char ICMSEG DecodeLMNTag[]      = "/DecodeLMN " ;
char ICMSEG DeviceRGBTag[]      = "/DeviceRGB " ;
char ICMSEG DeviceCMYKTag[]     = "/DeviceCMYK " ;
char ICMSEG DeviceGrayTag[]     = "/DeviceGray " ;
char ICMSEG TableTag[]          = "/Table " ;
char ICMSEG DecodeDEFGTag[]     = "/DecodeDEFG " ;
char ICMSEG DecodeDEFTag[]      = "/DecodeDEF " ;

char ICMSEG NullOp[]            = "";
char ICMSEG DupOp[]             = "dup ";
char ICMSEG UserDictOp[]        = "userdict ";
char ICMSEG GlobalDictOp[]      = "globaldict ";
char ICMSEG CurrentGlobalOp[]   = "currentglobal ";
char ICMSEG SetGlobalOp[]       = "setglobal ";
char ICMSEG DefOp[]             = "def ";
char ICMSEG BeginOp[]           = "begin ";
char ICMSEG EndOp[]             = "end ";
char ICMSEG TrueOp[]            = "true ";
char ICMSEG FalseOp[]           = "false ";
char ICMSEG MulOp[]             = "mul ";
char ICMSEG DivOp[]             = "div ";

char ICMSEG NewLine[]           = "\n" ;
char ICMSEG Slash[]             = "/" ;
char ICMSEG Space[]             = " " ;
char ICMSEG CRDBegin[]          = "%** CRD Begin ";
char ICMSEG CRDEnd[]            = "%** CRD End ";
char ICMSEG CieBasedDEFGBegin[] = "%** CieBasedDEFG CSA Begin ";
char ICMSEG CieBasedDEFBegin[]  = "%** CieBasedDEF CSA Begin ";
char ICMSEG CieBasedABCBegin[]  = "%** CieBasedABC CSA Begin ";
char ICMSEG CieBasedABegin[]    = "%** CieBasedA CSA Begin ";
char ICMSEG CieBasedDEFGEnd[]   = "%** CieBasedDEFG CSA End ";
char ICMSEG CieBasedDEFEnd[]    = "%** CieBasedDEF CSA End ";
char ICMSEG CieBasedABCEnd[]    = "%** CieBasedABC CSA End ";
char ICMSEG CieBasedAEnd[]      = "%** CieBasedA CSA End ";
char ICMSEG RangeABC[]          = "[ 0 1 0 1 0 1 ] ";
char ICMSEG RangeLMN[]          = "[ 0 2 0 2 0 2 ] ";
char ICMSEG Identity[]          = "[1 0 0 0 1 0 0 0 1]";
char ICMSEG RangeABC_Lab[]      = "[0 100 -128 127 -128 127]";

/********** This PostScript code clips incoming value between 0.0 and 1.0
   Use:   x <clip>   --   <clipped x>                                   */
char ICMSEG Clip01[]            = "dup 1.0 ge{pop 1.0}{dup 0.0 lt{pop 0.0}if}ifelse " ;
char ICMSEG DecodeA3[]          = "256 div exp ";
char ICMSEG DecodeA3Rev[]       = "256 div 1.0 exch div exp ";
char ICMSEG DecodeABCArray[]    = "DecodeABC_";
char ICMSEG InputArray[]        = "Inp_";
char ICMSEG OutputArray[]       = "Out_";
char ICMSEG PreViewInArray[]    = "IPV_";
char ICMSEG PreViewOutArray[]   = "OPV_";


// This PostScript segment takes value in range from 0.0 to 1.0 and
//  interpolates the result using array supplied.
//   x [array]  -- <interpolated value>

char ICMSEG IndexArray16b[]     = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 32768 add 4 -1 roll 3 -1 roll get 32768 add \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG IndexArray[]        = \
" dup length 1 sub 3 -1 roll mul dup dup floor cvi \
exch ceiling cvi 3 index exch get 4 -1 roll 3 -1 roll get \
dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

char ICMSEG TestingDEFG[]       = \
"/SupportDEFG? {/CIEBasedDEFG /ColorSpaceFamily resourcestatus { pop pop true}{false} ifelse} def";

char ICMSEG SupportDEFG_S[]     = "SupportDEFG? { ";
char ICMSEG NotSupportDEFG_S[]  = "SupportDEFG? not { ";
char ICMSEG SupportDEFG_E[]     = "}if ";

char ICMSEG StartClip[]         = "dup 1.0 le{dup 0.0 ge{" ;
char ICMSEG EndClip[]           = "}if}if " ;

char ICMSEG Scale8[]            = "255 div " ;
char ICMSEG Scale16[]           = "65535 div " ;
char ICMSEG Scale16XYZ[]        = "32768 div " ;
char ICMSEG TFunction8[]        = "exch 255 mul round cvi get 255 div " ;
char ICMSEG TFunction8XYZ[]     = "exch 255 mul round cvi get 128 div " ;
char ICMSEG MatrixABCLab[]      = "[1 1 1 1 0 0 0 0 -1]" ;
char ICMSEG DecodeABCLab1[]     = "[{16 add 116 div} bind {500 div} bind {200 div} bind]";
char ICMSEG DecodeALab[]        = " 50 mul 16 add 116 div ";
char ICMSEG DecodeLMNLab[]      = \
"dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse ";

char ICMSEG RangeLMNLab[]       = "[0 1 0 1 0 1]" ;
char ICMSEG EncodeLMNLab[]      = "\
dup 0.008856 le{7.787 mul 0.13793 add}{0.3333 exp}ifelse " ;

char ICMSEG MatrixABCLabCRD[]   = "[0 500 0 116 -500 200 0 0 -200]" ;
char ICMSEG MatrixABCXYZCRD[]   = "[0 1 0 1 0 0 0 0 1]" ;
char ICMSEG EncodeABCLab1[]     = "16 sub 100 div " ;
char ICMSEG EncodeABCLab2[]     = "128 add 255 div " ;

char ICMSEG   RangePQR[]          = "[ -0.07 2.2 -0.02 1.4 -0.2 4.8 ]";
char ICMSEG   MatrixPQR[]         = "[0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296]";

char *TransformPQR[3]             = {
"exch pop exch 3 get mul exch pop exch 3 get div ",
"exch pop exch 4 get mul exch pop exch 4 get div ",
"exch pop exch 5 get mul exch pop exch 5 get div " };

#pragma optimize("",off)

/***************************************************************************
*                               CreateLutCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  prototype:
*       SINT EXTERN CreateLutCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CRD allowed,  0: only ascii CRD allowed.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

SINT EXTERN 
CreateLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT nInputCh, nOutputCh, nGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    CSIG Tag, PCS;
    CSIG IntentSig;

    SINT Ret;
    SINT i, j;
    MEMPTR lpTable;

    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    char PublicArrayName[TempBfSize];
    HGLOBAL hMem;
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);
 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (((nOutputCh != 3) &&
         (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }
    Ret = nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +  // Number of INT bytes
        nOutputCh * nGrids * nGrids * nGrids * 2 +  // LUT HEX bytes
        nInputCh * (lstrlen (IndexArray) +
                    lstrlen (StartClip) +
                    lstrlen (EndClip)) +
        nOutputCh * (lstrlen (IndexArray) +
                     lstrlen (StartClip) +
                     lstrlen (EndClip)) +
        2048;                           // + other PS stuff

    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
//  Get all necessary params from the header
//  GetCPRenderIntent (cp, (LPCSIG) & Intent);  // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, Tag, Buff, AllowBinary, NULL);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** Send PQR - used for Absolute Colorimetric *****
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 // ******** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        PCS, nInputCh, Buff, NULL, Tag, AllowBinary);

 //********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Na
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nb
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    nNumbers = nGrids * nGrids * nOutputCh;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, BeginString);
            if (Tag == icSigLut8Type)
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
            else
            {
                for (j = 0; j < nNumbers; j++)
                {
                    lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
            }
            lpMem += WriteObject (lpMem, EndString);
        } else
        {                               // Output BINARY CRD
            lpMem += WriteStringToken (lpMem, 143, nNumbers);
            if (Tag == icSigLut8Type)
                lpMem += WriteByteString (lpMem, lpTable, nNumbers);
            else
                lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
        }
    }

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteInt (lpMem, nOutputCh);   // Send down m

 //********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        nOutputCh, Tag, FALSE, AllowBinary);

    lpMem += WriteObject (lpMem, EndArray); // End array
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    lpMem += WriteNewLineObject (lpMem, CRDEnd);

// Testing Convert binary to ascii
//    i = ConvertBinaryData2Ascii(lpOldMem, (SINT)(lpMem - lpOldMem), Ret);
//    lpMem = lpOldMem + i;
// Testing Convert binary to ascii

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
/***************************************************************************
*                               GetRevCurve
*  function:
*  prototype:
*       BOOL  GetRevCurve(
*                          MEMPTR       Buff,
*                          MEMPTR       lpRevCurve)
*  parameters:
*       Buff        --
*       lpRevCurve  --
*  returns:
*       BOOL        --  TRUE:  successful,
*                       FALSE: otherwise.
***************************************************************************/

BOOL
GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve)
{
    SINT i, j, nCount;
    MEMPTR lpTable;
    PUSHORT lpInput, lpOutput;
    SFLOAT fTemp;
    SINT iBegin, iEnd, iTemp;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
    lpOutput = (PUSHORT) lpRevCurve;
    lpInput = (PUSHORT) lpCurve;

    for (i = 0; i < nCount; i++)
    {
        lpInput[i] = (USHORT) (ui16toSINT (lpTable));
        lpTable += sizeof (icUInt16Number);
    }

    j = nCount * REVCURVE_RATIO;
    for (i = 0; i < j; i++)
    {
        fTemp = (SFLOAT) i *65535 / (j - 1);
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    for (i = 0; i < j; i++)
    {
        iBegin = 0;
        iEnd = nCount - 1;
        for (;;)
        {
            if ((iEnd - iBegin) <= 1)
                break;
            iTemp = (iEnd + iBegin) / 2;
            if (lpOutput[i] < lpInput[iTemp])
                iEnd = iTemp;
            else
                iBegin = iTemp;
        }
        if (lpOutput[i] <= lpInput[iBegin])
            fTemp = (SFLOAT) iBegin;
        else if (lpOutput[i] >= lpInput[iEnd])
            fTemp = (SFLOAT) iEnd;
        else
        {
            fTemp = ((SFLOAT) (lpInput[iEnd] - lpOutput[i])) /
                (lpOutput[i] - lpInput[iBegin]);
            fTemp = (iBegin * fTemp + iEnd) / (fTemp + 1);
        }
        fTemp = (fTemp / (nCount - 1)) * 65535;
        lpOutput[i] = (fTemp < 65535) ? (USHORT) fTemp : (USHORT) 65535;
    }

    return TRUE;
}
/***************************************************************************
*                               CreateMonoCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the GrayTRC tag.
*  prototype:
*       BOOL EXTERN CreateMonoCRD(
*                          CHANDLE      cp,
*                          SINT         Index,
*                          MEMPTR       lpMem)
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
//  According to the spec this tag-based function only converts from
//  Device to PCS, so we need to create an inverse function to perform
//  PCS->device conversion. By definition the CRD is only
//  for XYZ->DeviceRGB/CMYK conversion.
SINT EXTERN 
CreateMonoCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT nCount;
    CSIG Tag, PCS;

    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpCurve, lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SINT i;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpLineStart;
 // Check if we can generate the CRD
    if (!GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }
    nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);

 // Estimate the memory size required to hold CRD
 // SRGB98
    Ret = nCount * 6 * REVCURVE_RATIO + // Number of INT elements
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }
    if (!MemAlloc (nCount * 2 * (REVCURVE_RATIO + 1),
                   (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (FALSE);
    }
    lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
    GetRevCurve (Buff, lpCurve, lpRevCurve);

 //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** /TransformPQR
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** /MatrixLMN
    lpMem += SendCRDLMN(lpMem, InputIntent, IlluminantWP, MediaWP, PCS);

 //********** /MatrixABC
    if (PCS == icSigXYZData)
    {   // Switch ABC to BAC, since we want to output B which is converted from Y.
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCXYZCRD);
    }
    else if (PCS == icSigLabData)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        lpMem += WriteObject (lpMem, EncodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);
        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, EncodeABCLab1);
            }
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}

// SRGB98 start
BOOL
GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize)
{
    CSIG Tag;

    if (!GetCPTagIndex (cp, icSigXTRCTag, (LPSINT) pIndex) ||
        !GetCPElementType (cp, *pIndex, (LPCSIG) & Tag) ||
        !(Tag == icSigCurveType) ||
        !GetCPElementSize (cp, *pIndex, (LPSINT) pTRCSize))
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
DoesTRCAndColorantTagExist (CHANDLE cp)
{
    if (DoesCPTagExist (cp, icSigRedColorantTag) &&
        DoesCPTagExist (cp, icSigRedTRCTag ) &&
        DoesCPTagExist (cp, icSigGreenColorantTag) &&
        DoesCPTagExist (cp, icSigGreenTRCTag ) &&
        DoesCPTagExist (cp, icSigBlueColorantTag) &&
        DoesCPTagExist (cp, icSigBlueTRCTag ))
    {
        return TRUE;
    }

    return FALSE;
}

static SINT 
CreateRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
                MEMPTR lpRevCurve, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    MEMPTR lpCurve;

    lpOldMem = lpMem;

    lpLineStart = lpMem;
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount > 1)
    {
        lpMem += WriteNewLineObject (lpMem, Slash);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteInt (lpMem, (SINT) CPTag);

        lpCurve = lpRevCurve + 2 * REVCURVE_RATIO * nCount;
        GetRevCurve (lpBuff, lpCurve, lpRevCurve);

        if (!AllowBinary)           // Output ASCII DATA
        {
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                lpMem += WriteInt (lpMem, (SINT) (*((PUSHORT) lpRevCurve)));
                lpRevCurve += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
        } else
        {                           // Output BINARY DATA
            lpMem += WriteHNAToken (lpMem, 149, nCount);
            lpMem += WriteIntStringU2S_L (lpMem, lpRevCurve, nCount);
        }
    }
    lpMem += WriteObject (lpMem, DefOp);
    return ((SINT) (lpMem - lpOldMem));
}

static SINT 
SendRevArray (CHANDLE cp, MEMPTR lpMem, MEMPTR lpBuff, 
              CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount;
    MEMPTR lpOldMem;
    MEMPTR lpTable;

    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);
    if (nCount != 0)
    {
        if (nCount == 1)            // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3Rev);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpMem += WriteObject (lpMem, InputArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            if (!AllowBinary)       // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {                       // Output BINARY CS
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}

SINT 
CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    HGLOBAL hBuff;

    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            *lpArray++ = (SFLOAT)si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ( TRUE );
}
/***************************************************************************
*                           CreateMatrixCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the redTRC, greenTRC, blueTRA, redColorant,
*    greenColorant and BlueColorant tags
*  prototype:
*       BOOL EXTERN CreateMatrixCRD(
*                          CHANDLE      cp,
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block
*       AllowBinary --
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
// With matrix/TRC model, only the CIEXYZ encoding of the PCS can be used.
// So, we don't need to worry about CIELAB.
SINT EXTERN 
CreateMatrixCRD (CHANDLE cp, MEMPTR lpMem, DWORD InputIntent, BOOL AllowBinary)
{
    SINT RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT i, MemSize;
    SINT nRedCount, nGreenCount, nBlueCount;
    MEMPTR lpRed = NULL,lpGreen, lpBlue;
    SINT RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpRevCurve;
    HGLOBAL hRevCurve;
    SINT Ret = 0;
    HGLOBAL hMem;
    SFLOAT IlluminantWP[3];
    double Colorant[9];
    double RevColorant[9];
 
 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
        return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & lpRed))
        return 0;

    lpGreen = lpRed + RedTRCSize;
    lpBlue = lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (0);
    }
    nRedCount = ui32toSINT (((lpcpCurveType) lpRed)->curve.count);
    nGreenCount = ui32toSINT (((lpcpCurveType) lpGreen)->curve.count);
    nBlueCount = ui32toSINT (((lpcpCurveType) lpBlue)->curve.count);

 // Estimate the memory size required to hold CRD
    Ret = (nRedCount + nGreenCount + nBlueCount) * 6 * REVCURVE_RATIO + 
        2048;                // Number of INT elements + other PS stuff
    if (lpMem == NULL)       // This is a size request
    {
        MemFree (hMem);
        return (Ret);
    }

    if (!MemAlloc (nRedCount * 2 * (REVCURVE_RATIO + 1),
                  (HGLOBAL FAR *) &hRevCurve, (LPMEMPTR) & lpRevCurve))
    {
        MemFree (hMem);
        return (0);
    }

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);
    
    lpMem += CreateRevArray (cp, lpMem, lpRed, lpRevCurve, icSigRedTRCTag, AllowBinary);
    lpMem += CreateRevArray (cp, lpMem, lpGreen, lpRevCurve, icSigGreenTRCTag, AllowBinary);
    lpMem += CreateRevArray (cp, lpMem, lpBlue, lpRevCurve, icSigBlueTRCTag, AllowBinary);

    lpMem += EndGlobalDict(lpMem);

 //   GetCPCMMType (cp, (LPCSIG) & Intent);   // Get Intent
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 //************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

 //********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, IlluminantWP);

 //********** /TransformPQR
    lpMem += SendCRDPQR(lpMem, InputIntent, IlluminantWP);

 //********** /MatrixLMN
    CreateColorantArray(cp, &Colorant[0], icSigRedColorantTag);
    CreateColorantArray(cp, &Colorant[3], icSigGreenColorantTag);
    CreateColorantArray(cp, &Colorant[6], icSigBlueColorantTag);
    InvertMatrix (Colorant, RevColorant);

    lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);

    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 9; i++)
    {
        lpMem += WriteFloat (lpMem, (SFLOAT)RevColorant[i]);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /EncodeABC
    lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += SendRevArray (cp, lpMem, lpRed, icSigRedTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += SendRevArray (cp, lpMem, lpGreen, icSigGreenTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += SendRevArray (cp, lpMem, lpBlue, icSigBlueTRCTag, AllowBinary);
    lpMem += WriteNewLineObject (lpMem, EndArray);

    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition

    lpMem += WriteNewLineObject (lpMem, CRDEnd);

    MemFree (hRevCurve);
    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}
// SRGB98 End

BOOL EXTERN
GetPS2ColorRenderingDictionary (
                                CHANDLE cp,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary)
{
    SINT Index;
    SINT Ret, Size;
    CSIG icSigPs2CRDx, icSigBToAx;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }
    Ret = 0;
    Size = (SINT) * lpcbSize;

    switch (Intent)
    {
        case icPerceptual:
            icSigPs2CRDx = icSigPs2CRD0Tag;
            icSigBToAx = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
            icSigPs2CRDx = icSigPs2CRD1Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        case icSaturation:
            icSigPs2CRDx = icSigPs2CRD2Tag;
            icSigBToAx = icSigBToA2Tag;
            break;

        case icAbsoluteColorimetric:
            icSigPs2CRDx = icSigPs2CRD3Tag;
            icSigBToAx = icSigBToA1Tag;
            break;

        default:
            *lpcbSize = (DWORD) Ret;
            return (Ret > 0);
    }

    if (
        (DoesCPTagExist (cp, icSigPs2CRDx) &&
         GetCPTagIndex (cp, icSigPs2CRDx, (LPSINT) & Index) &&
         GetCPElementDataSize (cp, Index, (LPSINT) & Ret) &&
         ((Size == 0) ||
          GetCPElementData (cp, Index, lpMem, Size)) &&
         (Ret = Convert2Ascii (cp, Index, lpMem, Size, Ret, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigBToAx) &&
         GetCPTagIndex (cp, icSigBToAx, (LPSINT) & Index) &&
         (Ret = CreateLutCRD (cp, Index, lpMem, Intent, AllowBinary))
        ) ||
        // SRGB98 Support Windows 98 sRGB icc profile.
        // Create CRD from TRC and Colorant Tags.
        (DoesTRCAndColorantTagExist (cp) &&
         (Ret = CreateMatrixCRD (cp, lpMem, Intent, AllowBinary))
        ) ||
        (DoesCPTagExist (cp, icSigGrayTRCTag) &&
         GetCPTagIndex (cp, icSigGrayTRCTag, (LPSINT) & Index) &&
         (Ret = CreateMonoCRD (cp, Index, lpMem, Intent))
        )
       )
    {
    }

    *lpcbSize = (DWORD) Ret;
    return (Ret > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\csprof.c ===
#include "generic.h"

#pragma code_seg(_ICM2SEG)
#pragma optimize("",off)

#define TempBfSize 128
#define LINELENG   128
#ifdef ICMDLL
#define ICM2SEG
#endif

static  char    ICM2SEG NewLine[]       = "\n" ;
static  char    ICM2SEG ASCII85DecodeBegine[] = "<~";
static  char    ICM2SEG ASCII85DecodeEnd[] = "~> cvx exec ";

//******************************************************************
//   Local functions to deal with output to the memory buffer

static  SINT    CPLastError;

BOOL    EXTERN     SetCPLastError(SINT LastError)
{
    CPLastError = LastError;
    return(TRUE);
}

SINT    EXTERN     GetCPLastError()
{
    return(CPLastError);
}

BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH)
{
    HGLOBAL hMem;
    LPVOID  lpMem;

    *hMemory = 0;
    if(lpMH == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hMem = GlobalAlloc(GHND, Size) ;
    if(hMem == 0 )
    {
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }

    lpMem = GlobalLock(hMem);
    if(lpMem == NULL )
    {
        GlobalFree(hMem);
        SetCPLastError(CP_MEMORY_ALLOC_ERR);
        return(FALSE);
    }
    *lpMH = (MEMPTR)lpMem ;
    *hMemory = hMem;
    return (TRUE);
}

BOOL    EXTERN MemFree(HGLOBAL hMem)
{
    if(hMem == NULL )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    GlobalUnlock(hMem);
    GlobalFree(hMem) ;
    return(TRUE);
}

//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
#ifndef ICMDLL
BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;

    *phMem = 0;
    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    hFile = _lopen(filename, READ );
    if( hFile == HFILE_ERROR )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }
 
    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    if( (Res == HFILE_ERROR) ||
        (Res != sizeof(CPHeader)) )
    {
        _lclose(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        _lclose(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
         _lseek(hFile, 0L, SEEK_SET);

        while(CPSize)
        {
            Res = _lread(hFile, (LPVOID) mpCP, 4096);
            if (Res == HFILE_ERROR) 
            {
                _lclose(hFile);
                SetCPLastError(CP_FILE_READ_ERR);
                return(FALSE);
            }
            mpCP    += Res;
            CPSize  -= Res;
        }
    }else
    {
        *phMem = 0;
        _lclose(hFile);
        return(FALSE);
    }
    _lclose(hFile);
    return (TRUE);
}

#else
//******************************************************************
//      Low-level Profile functions - used for individual tag access
//******************************************************************
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP)
{
    icHeader    CPHeader;
    HANDLE      hFile;
    SINT        Res, CPSize;
    MEMPTR      mpCP;
    BOOL        Success;

    if (lpCP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    hFile = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        SetCPLastError(CP_FILE_OPEN_ERR);
        return(FALSE);
    }

    Success = ReadFile(hFile, (LPVOID) &CPHeader, sizeof(CPHeader), &Res, NULL);
    if( ( !Success ) || (Res != sizeof(CPHeader)) )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FILE_READ_ERR);
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        CloseHandle(hFile);
        SetCPLastError(CP_FORMAT_ERR);
        return(FALSE);
    }

    CPSize = ui32toSINT(CPHeader.size);
    if( MemAlloc(CPSize, phMem, (LPMEMPTR) &mpCP) )
    {

        *lpCP = (CHANDLE) mpCP;  // Put the memory pointer as  handle
        // Read profile into  memory
        SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        Success = ReadFile(hFile, (LPVOID) (LPVOID)mpCP, CPSize, &Res, NULL);
        if (!Success) 
        {
            CloseHandle(hFile);
            SetCPLastError(CP_FILE_READ_ERR);
            return(FALSE);
        }
    }else
    {
        CloseHandle(hFile);
        return(FALSE);
    }
    CloseHandle(hFile);
    return (TRUE);
}
#endif

BOOL    EXTERN FreeCP(HGLOBAL hMem)
{
    return( MemFree(hMem) );
}


BOOL    EXTERN GetCPElementCount(CHANDLE CP, LPSINT lpCount)
{
    lpcpTagList lpTL;
    if (lpCount == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    *lpCount = ui32toSINT(lpTL->count);
    return(TRUE);
}


BOOL    EXTERN GetCPElementInfo(CHANDLE CP, SINT Index,
                                LPMEMPTR lpTagData, LPMEMPTR lpElemData)
{
    SINT    Count;
    lpcpTagList lpTL;

    if ( (lpTagData == NULL) || (lpElemData == NULL) )
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    if ( Count <= Index )
    {
        SetCPLastError(CP_OUT_OF_RANGE_ERR);
        return(FALSE);
    }
    *lpTagData      = ((MEMPTR) &(lpTL->tags[0])) + (Index * sizeof(icTag)) ;
    *lpElemData     = ((MEMPTR) CP) +
                                ui32toSINT( ((lpcpTag)*lpTagData)->offset);
    return(TRUE);
}


/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE CP)
{
    BOOL    Result;
    CSIG    ProfileClass;

    if(GetCPClass(CP, (LPCSIG) &ProfileClass) )
    {
        // All profiles must have a ProfileDescription and
        //  a Copyright  tags.

        if( !DoesCPTagExist(CP, icSigProfileDescriptionTag) || 
            !DoesCPTagExist(CP, icSigCopyrightTag ) )
        {
            SetCPLastError(CP_NOT_FOUND_ERR);
            return(FALSE);
        }

        // All profiles, except Device-link, must have a mediaWhitePoint Tag
        switch( ProfileClass )
        {
            case     icSigLinkClass :        /* 'link' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigProfileSequenceDescTag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                break;

            case     icSigInputClass:       /* 'scnr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) ||
                    DoesCPTagExist(CP, icSigAToB0Tag)      )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigDisplayClass:     /* 'mntr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigGreenColorantTag) )
                {
                    if( DoesCPTagExist(CP, icSigRedColorantTag) &&
                        DoesCPTagExist(CP, icSigBlueColorantTag) &&
                        DoesCPTagExist(CP, icSigRedTRCTag) &&
                        DoesCPTagExist(CP, icSigGreenTRCTag) &&
                        DoesCPTagExist(CP, icSigBlueTRCTag)
                      )
                    {
                        Result = TRUE;
                    }else
                    {
                        Result = FALSE;
                    }
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigOutputClass:      /* 'prtr' */
                if( DoesCPTagExist(CP, icSigGrayTRCTag) )
                {
                    Result = TRUE;
                }else if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                          DoesCPTagExist(CP, icSigAToB1Tag) &&
                          DoesCPTagExist(CP, icSigAToB2Tag) &&
                          DoesCPTagExist(CP, icSigBToA0Tag) &&
                          DoesCPTagExist(CP, icSigBToA1Tag) &&
                          DoesCPTagExist(CP, icSigBToA2Tag) &&
                          DoesCPTagExist(CP, icSigGamutTag) 
                        )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigAbstractClass:    /* 'abst' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            case     icSigColorSpaceClass:  /* 'spac' */
                if( DoesCPTagExist(CP, icSigAToB0Tag) &&
                    DoesCPTagExist(CP, icSigBToA0Tag)
                  )
                {
                    Result = TRUE;
                }else
                {
                    Result = FALSE;
                }
                Result  &= DoesCPTagExist(CP, icSigMediaWhitePointTag);
                break;

            default:
                Result = FALSE;
                break;
        }
    }else
    {
        return(FALSE);
    }
    if( Result == FALSE )
    {
        SetCPLastError(CP_NOT_FOUND_ERR);
    }
    return(Result);
}

BOOL    EXTERN DoesCPTagExist(CHANDLE CP, CSIG CPTag)
{
    SINT    Count;
    MEMPTR   Data;
    lpcpTagList lpTL;

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ; 
    while ( Count-- )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }
    return(FALSE);
}


BOOL    EXTERN GetCPTagIndex(CHANDLE CP, CSIG CPTag, LPSINT lpIndex)
{
    SINT    Count;
    MEMPTR   Data;
    SINT    i;
    lpcpTagList lpTL;

    if (lpIndex == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    lpTL = (lpcpTagList) &(((lpcpProfile)CP)->count);
    Count   = ui32toSINT(lpTL->count);
    Data    = (MEMPTR)  &(lpTL->tags[0]) ;

    for (i = 0; i < Count; i++ )
    {
        if(  SigtoCSIG( ((lpcpTag)Data)->sig) == CPTag )
        {
            *lpIndex = i;
            return(TRUE);
        }else
        {
            Data    += sizeof(icTag);   // Bump pointer to the next tag
        }
    }

    SetCPLastError(CP_NOT_FOUND_ERR);
    return(FALSE);
}



BOOL    EXTERN GetCPTagSig(CHANDLE CP, SINT Index, LPCSIG lpCPTag)
{
    MEMPTR   TagData, ElemData;
    if (lpCPTag == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCPTag    = SigtoCSIG( ((lpcpTag)TagData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}

//***************************************************************
//      Function applicable to the elements
//
//***************************************************************

BOOL    EXTERN GetCPElementType(CHANDLE CP, SINT Index, LPCSIG lpCSig)
{
    MEMPTR   TagData, ElemData;
    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpCSig    = SigtoCSIG( ((lpcpTagBase)ElemData)->sig ) ;
    }else
    {
        return(FALSE);
    }
    return(TRUE);
}



BOOL    EXTERN GetCPElementSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR   TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size );
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL    EXTERN GetCPElementDataSize(CHANDLE CP, SINT Index, LPSINT lpSize)
{
    MEMPTR  TagData, ElemData;
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
//  Changed by jjia 8/24/95
//        *lpSize     = ui32toSINT( ((lpcpTag)TagData)->size ) -
//                                             sizeof(lpcpTagBase);
    *lpSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);
    }else
    {
        return(FALSE);
    }

    return(TRUE);
}

//***************************************************************
//  The difference between GetCPElement and GetCPElementData
//  is that GetCPElement reads all fields of the element,
//  including the data tag, reserved fields and element data,
//  while GetCPElementData only reads the actual data.
//  Number of bytes that are required to hold the whole data element can be
//  obtained by calling the function GetCPElementSize().
//  The actulal number of data bytes is determined by
//  the call to GetCPElementDataSize().
//***************************************************************
BOOL    EXTERN GetCPElement(CHANDLE CP, SINT Index,
                               MEMPTR lpData, SINT Size)
{
    SINT        ElemSize;
    MEMPTR      TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size);
    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }
    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);

}


BOOL    EXTERN GetCPElementData(CHANDLE CP, SINT Index,
                                MEMPTR lpData, SINT Size)
{
    SINT     ElemSize;
    MEMPTR   TagData, ElemData;
    if (lpData == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
//  Changed by jjia 8/24/95
//    ElemData    +=  sizeof(lpcpTagBase);
//    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
//                     sizeof(lpcpTagBase);
    ElemData    +=  sizeof(icTagBase) + sizeof(icUInt32Number);
    ElemSize    = ui32toSINT( ((lpcpTag)TagData)->size) - 
                    sizeof(icTagBase) - sizeof(icUInt32Number);

    if(ElemSize > Size )
    {
        SetCPLastError(CP_NO_MEMORY_ERR);
        return(FALSE);
    }

    MemCopy(lpData, ElemData, ElemSize);
    return(TRUE);
}

// Check the data format is binary or ascii    8/22/95  jjia

BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType)
{
    MEMPTR   TagData, ElemData;

    if (lpDataType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }

    if ( !GetCPElementInfo(CP, Index, (LPMEMPTR) &TagData,
            (LPMEMPTR) &ElemData) )
    {
        return(FALSE);
    }
    ElemData    +=  sizeof(icTagBase);
    *lpDataType = ui32toSINT( ((icData __huge *)ElemData)->dataFlag);
    return (TRUE);
}

BOOL    EXTERN ValidateCPElement(CHANDLE CP, SINT Index)
{
    CSIG    TagSig, DataSig;
    BOOL    Result;
    if( GetCPTagSig(CP, Index, (LPCSIG) &TagSig) &&
        GetCPElementType(CP, Index, (LPCSIG) &DataSig) )
    {
        switch(TagSig)
        {
            case     icSigAToB0Tag:
            case     icSigAToB1Tag:
            case     icSigAToB2Tag:
            case     icSigBToA0Tag:
            case     icSigBToA1Tag:
            case     icSigBToA2Tag:
            case     icSigGamutTag:
            case     icSigPreview0Tag:
            case     icSigPreview1Tag:
            case     icSigPreview2Tag:
                Result = (DataSig == icSigLut16Type) ||
                         (DataSig == icSigLut8Type) ;
                break;

            case     icSigRedColorantTag: 
            case     icSigGreenColorantTag:
            case     icSigBlueColorantTag:
            case     icSigLuminanceTag:
            case     icSigMediaBlackPointTag:
            case     icSigMediaWhitePointTag:
                Result = (DataSig == icSigXYZType);
                break;

            case     icSigRedTRCTag:
            case     icSigGreenTRCTag:
            case     icSigBlueTRCTag:
            case     icSigGrayTRCTag:
                Result = (DataSig == icSigCurveType);
                break;

            case     icSigPs2CRD0Tag:
            case     icSigPs2CRD1Tag:
            case     icSigPs2CRD2Tag:
            case     icSigPs2CRD3Tag:
            case     icSigPs2CSATag:
            case     icSigPs2Intent0Tag:
            case     icSigPs2Intent1Tag:
            case     icSigPs2Intent2Tag:
            case     icSigPs2Intent3Tag:
                Result = (DataSig == icSigDataType);
                break;

            case     icSigCharTargetTag:
            case     icSigCopyrightTag:
                Result = (DataSig == icSigTextType);
                break;

            case     icSigCalibrationDateTimeTag:
                Result = (DataSig == icSigDateTimeType);
                break;

            case     icSigDeviceMfgDescTag:
            case     icSigDeviceModelDescTag:
            case     icSigProfileDescriptionTag:
            case     icSigScreeningDescTag:
            case     icSigViewingCondDescTag:
                Result = (DataSig == icSigTextDescriptionType);
                break;

            case     icSigMeasurementTag:
                Result = (DataSig == icSigMeasurementTag);
                break;

            case     icSigNamedColorTag:
                Result = (DataSig == icSigNamedColorTag);
                break;
        
            case      icSigProfileSequenceDescTag:
                Result = (DataSig == icSigProfileSequenceDescTag);
                break;

            case     icSigScreeningTag:
                Result = (DataSig == icSigScreeningTag);
                break;

            case     icSigTechnologyTag:
                Result = (DataSig == icSigSignatureType);
                break;

            case     icSigUcrBgTag:
                Result = (DataSig == icSigUcrBgTag);
                break;

            case     icSigViewingConditionsTag:
                Result = (DataSig == icSigViewingConditionsTag);
                break;

            default:
                Result = TRUE;
                break;
        }
    }else
    {
        Result = FALSE;
    }
    return(Result);
}

//******************************************************************
// Functions that get all information from the Color Profile Header
//******************************************************************
BOOL    EXTERN GetCPSize(CHANDLE CP, LPSINT lpSize)
{
    if (lpSize == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpSize    = ui32toSINT( ((lpcpHeader)CP)->size);
    return(TRUE);
}

BOOL    EXTERN GetCPCMMType(CHANDLE CP, LPCSIG lpType)
{
    if (lpType == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpType    = SigtoCSIG( ((lpcpHeader)CP)->cmmId);
    return(TRUE);
}

BOOL    EXTERN GetCPVersion(CHANDLE CP, LPSINT lpVers)
{
    if (lpVers == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpVers    = ui32toSINT( ((lpcpHeader)CP)->version);
    return(TRUE);
}

BOOL    EXTERN GetCPClass(CHANDLE CP, LPCSIG lpClass)
{
    if (lpClass == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpClass    = SigtoCSIG( ((lpcpHeader)CP)->deviceClass);
    return(TRUE);
}

BOOL    EXTERN GetCPDevSpace(CHANDLE CP, LPCSIG lpInSpace)
{
    if (lpInSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpInSpace    = SigtoCSIG( ((lpcpHeader)CP)->colorSpace);
    return(TRUE);
}

BOOL    EXTERN GetCPConnSpace(CHANDLE CP, LPCSIG lpOutSpace)
{
    if (lpOutSpace == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpOutSpace    = SigtoCSIG( ((lpcpHeader)CP)->pcs);
    return(TRUE);
}

BOOL    EXTERN GetCPTarget(CHANDLE CP, LPCSIG lpTarget)
{
    if (lpTarget == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpTarget    = SigtoCSIG( ((lpcpHeader)CP)->platform);
    return(TRUE);
}

BOOL    EXTERN GetCPManufacturer(CHANDLE CP, LPCSIG lpManuf)
{
    if (lpManuf == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpManuf    = SigtoCSIG( ((lpcpHeader)CP)->manufacturer);
    return(TRUE);
}

BOOL    EXTERN GetCPModel(CHANDLE CP, LPCSIG lpModel)
{
    if (lpModel == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpModel    = SigtoCSIG( ((lpcpHeader)CP)->model);
    return(TRUE);
}

BOOL    EXTERN GetCPFlags(CHANDLE CP, LPSINT lpFlags)
{
    if (lpFlags == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpFlags    = ui32toSINT( ((lpcpHeader)CP)->flags);
    return(TRUE);
}

BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent)
{
    if (lpIntent == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    *lpIntent    = ui32toSINT( ((lpcpHeader)CP)->renderingIntent);
    return(TRUE);
}

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP)
{
    if (lpWP == NULL)
    {
        SetCPLastError(CP_NULL_POINTER_ERR);
        return(FALSE);
    }
    lpWP[0]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.X);
    lpWP[1]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Y);
    lpWP[2]    = (SFLOAT) si16f16toSFLOAT( ((lpcpHeader)CP)->illuminant.Z);
    return(TRUE);
}

BOOL    EXTERN GetCPAttributes(CHANDLE CP, LPATTRIB lpAttributes)
{
    return(TRUE);
}

BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE cp,  LPSFLOAT lpMediaWP)
{
    HGLOBAL   hTempMem;
    SINT      TempSize;
    MEMPTR    TempBuff;
    MEMPTR    lpTable;
    SINT      i, Index;

    if (DoesCPTagExist (cp, icSigMediaWhitePointTag) &&
        GetCPTagIndex (cp, icSigMediaWhitePointTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & TempSize) &&
        MemAlloc (TempSize, (HGLOBAL *) & hTempMem, (LPMEMPTR) & TempBuff) &&
        GetCPElement (cp, Index, TempBuff, TempSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) TempBuff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMediaWP[i] = (SFLOAT) si16f16toSFLOAT (lpTable);
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hTempMem);
        return (TRUE);
    }
    return (FALSE);
}

/***************************************************************************
*                               GetPS2ColorRenderingIntent
*  function:
*    this is the function which creates the Intent string 
*    from the data supplied in the Profile that can be used
*    in --findcolorrendering-- operator.
*  prototype:
*       BOOL EXTERN GetPS2ColorRenderingIntent(
*                          char         *FileName,
*                          DWORD        Intent, 
*                          MEMPTR       lpMem,
*                          LPDWORD      lpcbSize )
*  parameters:
*       FileName    --  Color Profile Filename
*       Intent      --  Intent 
*       lpMem       --  Pointer to the memory block
*       lpcbSize        --  Size of the memory block
*                       Returns number of bytes required/transferred
*  returns:
*       BOOL        --  TRUE   if the function was successful,
*                       FALSE  otherwise.
***************************************************************************/
BOOL EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
                                       MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT       Index;
    SINT       Size;
        
    if (!cp)
        return FALSE;

    Size = (SINT) *lpcbSize;
    if( ( lpMem == NULL ) || ( Size == 0 ) )
    {
        lpMem = NULL;
        Size = 0;
        *lpcbSize = 0;
    }
        
    switch(Intent)
    {
        case icPerceptual:
        if( DoesCPTagExist(cp, icSigPs2Intent0Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent0Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        
        case icRelativeColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent1Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent1Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
    
        case icSaturation:
        if( DoesCPTagExist(cp, icSigPs2Intent2Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent2Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size ) )
          )
        {
        }
        break;
        case icAbsoluteColorimetric:
        if( DoesCPTagExist(cp, icSigPs2Intent3Tag) &&
            GetCPTagIndex(cp, icSigPs2Intent3Tag, (LPSINT) &Index) &&
            GetCPElementDataSize(cp, Index, (LPSINT) &Size) &&
            ( ( lpMem == NULL ) ||
                GetCPElementData(cp, Index, lpMem, Size) ) )
        {
        }
        break;
        default:
            Size = 0 ;
        break;
    }
        
    if (Size != 0)
    {
        if (lpMem)
        {
            lpMem[Size] = '\0';
        }
        Size ++;
        *lpcbSize = (DWORD) Size;
        return (TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/***************************************************************************
*
*  Function to check if color matching mathod and icc profile type is 
*       supported by driver.
*  parameters:
*
*  returns:
*       BOOL:   TRUE or FALSE.
*
***************************************************************************/

#ifndef ICMDLL
BOOL EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS )
{
    icHeader    CPHeader;
    HFILE       hFile;
    SINT        Res;
    CSIG        CPColorSpaceTag;

    if (NULL == lpICMI)
    {
        return(FALSE);
    }
    hFile = _lopen(lpICMI->lcsDestFilename, READ);
    if( hFile == HFILE_ERROR )
    {
        return(FALSE);
    }

    Res = _lread(hFile, (LPVOID) &CPHeader, sizeof(CPHeader));
    _lclose(hFile);
    if( (Res == HFILE_ERROR) || (Res != sizeof(CPHeader)) )
    {
        return(FALSE);
    }

    // Make the initial check for validity of the profile
    if( SigtoCSIG(CPHeader.magic) != icMagicNumber )
    {
        return(FALSE);
    }
    // Make sure the profile is 'prtr'
    // SRGB98
    // if( SigtoCSIG(CPHeader.deviceClass) != icSigOutputClass )
    // {
    //     return(FALSE);
    // }
    CPColorSpaceTag = SigtoCSIG(CPHeader.colorSpace);
    *lpDevCS = CPColorSpaceTag;             // 247974

    switch ( lppd->lpPSExtDevmode->dm.iColorMatchingMethod )
    {
        case COLOR_MATCHING_ON_HOST:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigRgbData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
            case COLOR_MATCHING_ON_PRINTER:
            if ((CPColorSpaceTag == icSigCmyData))
//                (CPColorSpaceTag == icSigGrayData))
            {
                return(FALSE);
            }
            break;
        case COLOR_MATCHING_PRINTER_CALIBRATION:
        default:
            break;
    }
    return (TRUE);
}
#endif

//***************************************************************************
//
//      Set of functions to output data into memory buffer
//
//***************************************************************************


/***************************************************************************
*
*   Function to put the chunk of memory as string of Hex
*
***************************************************************************/
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    MEMPTR  lpOldPtr = lpMem;

    for ( ; dwBytes ; dwBytes-- )
    {
        Res = wsprintf( (MEMPTR)TempArray, (LPSTR) "%2.2x", *lpBuff );
        *lpMem++ = TempArray[0];
        *lpMem++ = TempArray[1];
        lpBuff++;
        if (((SINT)(lpMem - lpLineStart)) > MAX_LINELENG)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject(lpMem,  NewLine);
        }
    }
    return( (SINT)(lpMem - lpOldPtr)); 
}

/***************************************************************************
*
*   Function to put the string into the buffer
*
***************************************************************************/
SINT    WriteNewLineObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res1, Res2;

    Res1 = lstrlen(NewLine);
    MemCopy(lpMem, NewLine, Res1);

    lpMem += Res1;
    Res2 = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res2);
    return( Res1 + Res2 );
}

SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj)
{
    SINT    Res;

    Res = lstrlen(Obj);
    MemCopy(lpMem, Obj, Res);
    return( Res );
}

SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n)
{
    MemCopy(lpMem, Obj, n);
    return( n );
}
/***************************************************************************
*
*   Function to write the integer into the buffer
*
***************************************************************************/
SINT WriteInt(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];
    
    Res = wsprintf( (MEMPTR)TempArray, "%lu ", Number );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the integer into the buffer as hex
*
***************************************************************************/
SINT WriteHex(MEMPTR lpMem, SINT Number)
{
    SINT    Res;
    char    TempArray[TempBfSize];

    Res = wsprintf( TempArray, "%2.2x", (int)(Number & 0x00FF) );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return( Res );
}

/***************************************************************************
*
*   Function to write the float into the buffer
*
***************************************************************************/

SINT WriteFloat(MEMPTR lpMem, double dFloat)
{
    char    cSign;
    double  dInt ;
    double  dFract ;
    LONG    lFloat ;
    SINT    Res;
    char    TempArray[TempBfSize];

    lFloat = (LONG) floor( dFloat * 10000.0 + 0.5);

    dFloat = lFloat  / 10000.0 ;

    dInt = floor(fabs(dFloat));
    dFract =  fabs(dFloat) - dInt ;

    cSign   = ' ' ;
    if ( dFloat < 0 )
    {
        cSign   = '-' ;
    }

    Res = wsprintf( (LPSTR) TempArray, (LPSTR) "%c%d.%0.4lu ",
       cSign, (WORD) dInt , (DWORD) (dFract *10000.0)  );
    MemCopy(lpMem, TempArray, lstrlen(TempArray));
    return ( Res );
}

/***************************************************************************
*
*   Function to write the string token into the buffer
*
***************************************************************************/

SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (3);
}

/***************************************************************************
*
*   Function to write the Homogeneous Number Array token into the buffer
*
***************************************************************************/

SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum)
{
    *lpMem++ = Token;
    *lpMem++ = 32;       // 16-bit fixed integer, high-order byte first
    *lpMem++ = (BYTE)((sNum & 0xFF00) >> 8);
    *lpMem++ = (BYTE)(sNum & 0x00FF);
    return (4);
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. High byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = ui16toSINT( lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed 
*   integer(-32768) and write them to the buffer. Low-order byte first.
*
***************************************************************************/

SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum)
{
    SINT    i;
    SINT    Temp;

    for (i = 0; i < sNum; i ++)
    {
        Temp = (SINT)*((PUSHORT)lpBuff) - 32768;
        *lpMem++ = (BYTE)((Temp & 0xFF00) >> 8);
        *lpMem++ = (BYTE)(Temp & 0x00FF);
        lpBuff += sizeof(icUInt16Number);
    }
    return(sNum * 2); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

    for (i = 0; i < sBytes; i ++)
        *lpMem++ = *lpBuff++;
    
    return(sBytes); 
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes)
{
    SINT    i;

       for( i = 0; i < sBytes ; i++)
    {
        *lpMem++ = (BYTE)(ui16toSINT( lpBuff)/256) ;
        lpBuff += sizeof(icUInt16Number);
    }
    return(sBytes); 
}

/***************************************************************************
*
*  Function to control ascii85 encoding.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       BufSize     --  Size of encording result buffer. 
*       lpSource    --  Pointer to the input buffer
*       DataSize    --  Size of the input buffer
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
****************************************************************************/

SINT    WriteASCII85Cont(MEMPTR lpDest, SINT BufSize, MEMPTR lpSource, SINT DataSize)
{
   SINT     incount;
   MEMPTR   lpPtr, lpSave;
   SINT     rem;
   SINT     bcount;
   SINT     dex;
   unsigned long word;
   
   /* encode the initial 4-tuples */
   lpSave = lpDest;
   lpPtr  = lpSource;
   word   = 0UL;
   bcount = 0;

   for (incount = 0; incount < DataSize; incount ++)
   {
      if ( incount  && ((incount % LINELENG) == 0) )
      lpDest += WriteObject(lpDest,  NewLine);
      word = (word<<8);
      word |= (BYTE)*lpPtr++;
      if (bcount == 3)
      {
         lpDest += WriteAscii85(lpDest, word, 5);
         word = 0UL;
         bcount = 0;
      }
      else
      {
         bcount ++;
      }
   }
   
   /* now do the last partial 4-tuple -- if there is one */
   /* see the Red Book spec for the rules on how this is done */
   if (bcount > 0)
   {
      rem = 4 - bcount;  /* count the remaining bytes */
      for (dex = 0; dex < rem; dex ++) /* shift left for each of them */
      {
         word = (word<<8);      /* (equivalent to adding in ZERO's)*/
         word |= (BYTE)32;
      }
//      lpDest += WriteAscii85(lpDest, word, (bcount + 1));  /* output only meaningful
      lpDest += WriteAscii85(lpDest, word, 5);               /* output only meaningful bytes + 1 */
   }
   return (lpDest - lpSave);
}

/************************************************************************
*
*  Function to convert 4 bytes binary data to 5 bytes ascii85 encorded data.
*  parameters:
*       lpDest      --  Pointer to the encording result buffer.
*       inWord      --  Input word (4-bytes) 
*       nBytes      --  Number of bytes should be outputed.
*  returns:
*       SINT        --  Number of bytes actually outputed.
* 
*************************************************************************/

SINT    WriteAscii85(MEMPTR lpDest, unsigned long inWord, SINT nBytes)
{
    unsigned long divisor;
    int      bcount;
    BYTE     outchar;
    MEMPTR   lpSave = lpDest;

    if ((inWord == 0UL) && (nBytes == 5))
        *lpDest++ = 'z';
    else
    {
        divisor = 52200625UL;
        for (bcount = 0; bcount < nBytes; bcount ++)
        { 
            outchar = (BYTE)((int)(inWord/divisor) + (int)'!');
            *lpDest++ = outchar;
            if (bcount < 4)
            {
                inWord = (inWord % divisor);
                divisor =(divisor / 85);
            }
        }
    }
    return (SINT)(lpDest - lpSave);
}

/***************************************************************************
*
*  Function to convert binary data to ascii by performing ASCII85 encording
*  parameters:
*       lpMem       --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       DataSize    --  The size of input binary data. 
*       BufSize     --  The size of buffer pointed by lpMem.
*  returns:
*       SINT        --  Number of bytes actually outputed.
*
***************************************************************************/

SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize)
{
    MEMPTR      intrbuf, Temp;
    HANDLE      intrhandle;
    SINT        AsciiDataSize = 0;

    if (BufSize >= (SINT)(DataSize/4*5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048))
    {
        if ((intrhandle = GlobalAlloc(GHND, BufSize)) != NULL)
        {
            if ((intrbuf = (MEMPTR) GlobalLock(intrhandle)) != NULL)
            {
                Temp = intrbuf;
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteObject(Temp,  ASCII85DecodeBegine);
                Temp += WriteObject(Temp,  NewLine);
                Temp += WriteASCII85Cont(Temp, BufSize, lpMem, DataSize);
                Temp += WriteObject(Temp,  ASCII85DecodeEnd);
                AsciiDataSize = (SINT)(Temp - intrbuf);
                lstrcpyn(lpMem, intrbuf, (WORD)AsciiDataSize); 
                GlobalUnlock(intrhandle);
            }
        }
        GlobalFree(intrhandle);
   }
   return (AsciiDataSize);
}

/***************************************************************************
*
*  Function to check if it is need to convert a CRD from binary to ascii
*  parameters:
*       CP          --  Handle of memory block which contains icm profile.
*       Index       --  Index of the element data of the profile.
*       lpData      --  A pointer to the buffer. 
*                       as input: contains binary data; 
*                       as output: contains ascii data. 
*       BufSize     --  The size of the buffer pointed by lpData.
*       DataSize    --  The size of input binary data.
*       AllowBinary --  Allow binary or not(1/0).
*  returns:
*       SINT        --  Number of bytes required/actually outputed.
*
***************************************************************************/

SINT    Convert2Ascii(CHANDLE CP, SINT Index,
                      MEMPTR lpData, SINT BufSize, 
                      SINT DataSize, BOOL AllowBinary)
{
    long    DataType;

    GetCPElementDataType(CP, Index, &DataType);
    if (BufSize == 0)
    {
        if (AllowBinary)
            return (DataSize);
        else if (DataType == 0)    // Ascii data in Profile 
            return (DataSize);
        else                       // Keep space for ascii85 encoding.
            return (DataSize / 4 * 5 + sizeof(ASCII85DecodeBegine)+sizeof(ASCII85DecodeEnd) + 2048);
    }
    else
    {
        if (AllowBinary)
            return (DataSize);
        else if(DataType == 0) 
            return (DataSize);
        else 
            return (ConvertBinaryData2Ascii(lpData, DataSize, BufSize) );
    }
}

#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length)
{
    SINT    i;

    for (i = 0; i < Length; i++)
    {
        Dest[i] = Source[i];
    }
    return( Length );
}

// SRGB98
BOOL EXTERN InvertMatrix (double FAR * lpInMatrix,
                   double FAR * lpOutMatrix)
{
    double det;

    double FAR *a;
    double FAR *b;
    double FAR *c;
    if ((NULL == lpInMatrix) ||
        (NULL == lpOutMatrix))
    {
        return (FALSE);
    }
    a = (double FAR *) &(lpInMatrix[0]);
    b = (double FAR *) &(lpInMatrix[3]);
    c = (double FAR *) &(lpInMatrix[6]);

    det = a[0] * b[1] * c[2] + a[1] * b[2] * c[0] + a[2] * b[0] * c[1] -
        (a[2] * b[1] * c[0] + a[1] * b[0] * c[2] + a[0] * b[2] * c[1]);

    if (det == 0.0)                     // What to do?
    {
        lpOutMatrix[0] = 1.0;
        lpOutMatrix[1] = 0.0;
        lpOutMatrix[2] = 0.0;

        lpOutMatrix[3] = 0.0;
        lpOutMatrix[4] = 1.0;
        lpOutMatrix[5] = 0.0;

        lpOutMatrix[6] = 0.0;
        lpOutMatrix[7] = 0.0;
        lpOutMatrix[8] = 1.0;
        return (FALSE);
    } else
    {
        lpOutMatrix[0] = (b[1] * c[2] - b[2] * c[1]) / det;
        lpOutMatrix[3] = -(b[0] * c[2] - b[2] * c[0]) / det;
        lpOutMatrix[6] = (b[0] * c[1] - b[1] * c[0]) / det;

        lpOutMatrix[1] = -(a[1] * c[2] - a[2] * c[1]) / det;
        lpOutMatrix[4] = (a[0] * c[2] - a[2] * c[0]) / det;
        lpOutMatrix[7] = -(a[0] * c[1] - a[1] * c[0]) / det;

        lpOutMatrix[2] = (a[1] * b[2] - a[2] * b[1]) / det;
        lpOutMatrix[5] = -(a[0] * b[2] - a[2] * b[0]) / det;
        lpOutMatrix[8] = (a[0] * b[1] - a[1] * b[0]) / det;
        return (TRUE);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\getcsa.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICMSEG)

static char  *DecodeABCLab[] = {"50 mul 16 add 116 div ", 
                               "128 mul 128 sub 500 div", 
                               "128 mul 128 sub 200 div"};

#pragma optimize("",off)

/**************************************************************************/

SINT CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary);
SINT CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag);
static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);
static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP);

/***************************************************************************
*                           GetDevideRGB
*  function:
*    this is the function which creates the DeviceRGB ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceRGB(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetDeviceRGB (
              MEMPTR lpMem,
              LPDWORD lpcbSize,
              DWORD InpDrvClrSp,
              BOOL  BackupCSA)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
        return FALSE;

    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceRGBTag) + 8;
        return (TRUE);
    }

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
    }

    lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetDevideCMYK
*  function:
*    this is the function which creates the DeviceCMYK ColorSpace (CS)
*  prototype:
*       BOOL EXTERN GetDeviceCMYK(
*                          MEMPTR       lpMem,
*                          BOOL         AllowBinary)
*  parameters:
*       lpMem       --  Pointer to the memory block
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetDeviceCMYK (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp != icSigCmykData) &&
        (InpDrvClrSp != 0))
        return FALSE;
    if (lpMem == NULL)
    {
        *lpcbSize = lstrlen (DeviceCMYKTag) + 8;
        return (TRUE);
    }
    lpMem += WriteNewLineObject (lpMem, DeviceCMYKTag);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);

}
/***************************************************************************
*                           GetDeviceGray
***************************************************************************/

static BOOL
GetDeviceGray (
               MEMPTR lpMem,
               LPDWORD lpcbSize,
               DWORD InpDrvClrSp)
{
    MEMPTR lpOldMem = lpMem;
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceRGBTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceRGBTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        if (lpMem == NULL)
        {
            *lpcbSize = lstrlen (DeviceGrayTag) + 8;
            return (TRUE);
        }
        lpMem += WriteNewLineObject (lpMem, DeviceGrayTag);

        *lpcbSize = (DWORD) (lpMem - lpOldMem);
        return (TRUE);
    }
}
/***************************************************************************
*                           GetPublicArrayName
***************************************************************************/

SINT
GetPublicArrayName (CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName)
{
    MEMPTR OldPtr;
    OldPtr = PublicArrayName;
    PublicArrayName[0] = 0;
    MemCopy (PublicArrayName, (MEMPTR) & IntentSig, sizeof (CSIG));
    PublicArrayName += sizeof (CSIG);
    PublicArrayName[0] = 0;
    return (PublicArrayName - OldPtr);
}

static SINT SendCSABWPoint(MEMPTR lpMem, CSIG Intent, 
                    LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    SINT   i;
    MEMPTR lpOldMem = lpMem;

 //********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

 //********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (Intent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

static void GetMediaWP(CHANDLE cp, CSIG InputIntent, 
                       LPSFLOAT IlluminantWP, LPSFLOAT MediaWP)
{
    if (InputIntent == icAbsoluteColorimetric)
    {
        if (!GetCPMediaWhitePoint (cp, (LPSFLOAT) & MediaWP)) // .. Media WhitePoint
        {
            MediaWP[0] = IlluminantWP[0];
            MediaWP[1] = IlluminantWP[1];
            MediaWP[2] = IlluminantWP[2];
        }
    }
}

SINT  BeginGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, GlobalDictOp);
    lpMem += WriteObject (lpMem, BeginOp);

    return (lpMem - lpOldMem);
}

SINT  EndGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);

    return (lpMem - lpOldMem);
}

SINT  EnableGlobalDict(MEMPTR lpMem)
{
    MEMPTR lpOldMem = lpMem;

    lpMem += WriteNewLineObject (lpMem, CurrentGlobalOp);
    lpMem += WriteObject (lpMem, TrueOp);
    lpMem += WriteObject (lpMem, SetGlobalOp);
    return (lpMem - lpOldMem);
}

/***************************************************************************
*                           GetPS2CSA_DEFG
*  function:
*    this is the function which creates the CIEBasedDEF(G) ColorSpace (CS)
*    from the data supplied in the RGB or CMYK Input Profile.
*  prototype:
*       GetPS2CSA_DEFG(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       int         Type
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Type        --  CieBasedDEF or CieBasedDEFG.
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_DEFG (
                CHANDLE cp,
                MEMPTR lpMem,
                LPDWORD lpcbSize,
                CSIG InputIntent,
                SINT Index,
                int Type,
                BOOL AllowBinary)
{
    CSIG PCS, LutTag;
    CSIG IntentSig;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    SINT nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT nInputTable, nOutputTable, nNumbers;
    SINT i, j, k;
    MEMPTR lpTable;
    MEMPTR lpOldMem = lpMem;
    MEMPTR lpLut = NULL;
    MEMPTR lpLineStart;
    HGLOBAL hLut = 0;
    SINT LutSize;
    char PublicArrayName[TempBfSize];
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
        &nGrids, &nInputTable, &nOutputTable, &i);

 // Level 2 printers support only tri-component CIEBasedABC input,
 // but can have either 3 or 4 output channels.
    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
    if (lpMem == NULL)                  // This is a size request
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids * 2;  // LUT HEX bytes
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * 2;   // LUT HEX bytes

        *lpcbSize = *lpcbSize +
            nInputCh * nInputTable * 6 +
            nOutputCh * nOutputTable * 6 +  // Number of INT bytes
            nInputCh * (lstrlen (IndexArray) +
                        lstrlen (StartClip) +
                        lstrlen (EndClip)) +
            nOutputCh * (lstrlen (IndexArray) +
                         lstrlen (StartClip) +
                         lstrlen (EndClip)) +
            4096;                       // + other PS stuff


        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Testing CieBasedDEFG support
    lpMem += WriteNewLineObject (lpMem, TestingDEFG);

 //*********** Creating global data
    GetPublicArrayName (cp, IntentSig, PublicArrayName);
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGBegin);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, nInputCh, nInputTable,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    lpMem += CreateOutputArray (lpMem, nOutputCh, nOutputTable, i,
             (MEMPTR) PublicArrayName, LutTag, lpLut, AllowBinary, NULL);

    lpMem += WriteNewLineObject (lpMem, EndOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    lpMem += WriteNewLineObject (lpMem, SetGlobalOp);
    lpMem += WriteNewLineObject (lpMem, SupportDEFG_S);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedDEF(G)
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteObject (lpMem, CIEBasedDEFGTag);
    else
        lpMem += WriteObject (lpMem, CIEBasedDEFTag);
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeDEF(G)
    lpLineStart = lpMem;
    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, DecodeDEFGTag);
    else
        lpMem += WriteNewLineObject (lpMem, DecodeDEFTag);

    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;

        lpMem += WriteNewLineObject (lpMem, BeginFunction);
#if 0
        if (PCS == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
#endif
        lpMem += WriteObject (lpMem, StartClip);
        lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII
        {
            lpMem += WriteObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /Table
    lpMem += WriteNewLineObject (lpMem, TableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, nGrids);  // Send down Nh
    lpMem += WriteInt (lpMem, nGrids);  // Send down Ni
    lpMem += WriteInt (lpMem, nGrids);  // Send down Nj
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        lpMem += WriteInt (lpMem, nGrids);  // Send down Nk
//     	nNumbers = nGrids * nGrids * nGrids * nOutputCh ;
        SecondGrids = nGrids;
    }
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteNewLineObject (lpMem, BeginArray);
        }
        for (k = 0; k < SecondGrids; k++)
        {
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (!AllowBinary)           // Output ASCII
            {
                lpMem += WriteObject (lpMem, BeginString);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nNumbers);
                else
                {
                    for (j = 0; j < nNumbers; j++)
                    {
                        lpMem += WriteHex (lpMem, ui16toSINT (lpTable) / 256);
                        lpTable += sizeof (icUInt16Number);
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
                lpMem += WriteObject (lpMem, EndString);
            } else
            {                           // Output BINARY
                lpMem += WriteStringToken (lpMem, 143, nNumbers);
                if (LutTag == icSigLut8Type)
                    lpMem += WriteByteString (lpMem, lpTable, nNumbers);
                else
                    lpMem += WriteInt2ByteString (lpMem, lpTable, nNumbers);
            }
            lpMem += WriteObject (lpMem, NewLine);
        }
        if (Type == TYPE_CIEBASEDDEFG)
        {
            lpMem += WriteObject (lpMem, EndArray);
        }
    }
    lpMem += WriteObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndArray); // End array

 //********** /DecodeABC
    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!AllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);

            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8XYZ);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16XYZ);
            }
        }

 // Now, We get CieBasedXYZ output. Output range 0 --> 1.99997
 // If the connection space is absolute XYZ, We need to convert 
 // from relative XYZ to absolute XYZ.
        if ((PCS == icSigXYZData) &&
            (InputIntent == icAbsoluteColorimetric))
        {
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
        }
 // If the connection space is Lab, We need to convert XYZ to Lab.
        else if (PCS == icSigLabData)
            lpMem += WriteObject (lpMem, DecodeABCLab[i]);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    if (PCS == icSigLabData)
    {
 //********** /MatrixABC
        lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
        lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpLineStart = lpMem;
            lpMem += WriteNewLineObject (lpMem, BeginFunction);
            lpMem += WriteObject (lpMem, DecodeLMNLab);
            if (InputIntent == icAbsoluteColorimetric)
                lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
            else 
                lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp);
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
 //********** /RangeLMN
        lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
        lpMem += WriteObject (lpMem, RangeLMN);
    }

 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    if (Type == TYPE_CIEBASEDDEFG)
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFGEnd);
    else
        lpMem += WriteNewLineObject (lpMem, CieBasedDEFEnd);

    lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}


/***************************************************************************
*                           GetPS2CSA_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the RGB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*       BackupCSA   --  1: A CIEBasedDEF has been created, this CSA is a backup 
*                          in case some old printer can not support CIEBasedDEF.
*                       0: No CIEBasedDEF. This is the only CSA.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, 
               BOOL AllowBinary, BOOL BackupCSA)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigRgbData) ||
        !DoesTRCAndColorantTagExist(cp))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigRgbData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Creating global data
    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    lpMem += EnableGlobalDict(lpMem);
    
    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
    }

    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateColSpArray (cp, lpMem, icSigRedTRCTag, AllowBinary);
    lpMem += CreateColSpArray (cp, lpMem, icSigGreenTRCTag, AllowBinary);
    lpMem += CreateColSpArray (cp, lpMem, icSigBlueTRCTag, AllowBinary);

    lpMem += WriteNewLineObject (lpMem, EndOp);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    }
    lpMem += WriteNewLineObject (lpMem, SetGlobalOp);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, NotSupportDEFG_S);
    }

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigRedTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigGreenTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, NewLine);
    lpMem += CreateColSpProc (cp, lpMem, icSigBlueTRCTag, AllowBinary);
    lpMem += WriteObject (lpMem, EndArray);

 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += CreateFloatString (cp, lpMem, icSigRedColorantTag);
    lpMem += CreateFloatString (cp, lpMem, icSigGreenColorantTag);
    lpMem += CreateFloatString (cp, lpMem, icSigBlueColorantTag);

    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /DecodeLMN
    if (InputIntent == icAbsoluteColorimetric)
    {
        // Support absolute whitePoint
        lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i ++)
        {
            lpMem += WriteObject (lpMem, BeginFunction);
            lpMem += WriteFloat (lpMem, (double)MediaWP[i]/IlluminantWP[i]);
            lpMem += WriteObject (lpMem, MulOp); 
            lpMem += WriteObject (lpMem, EndFunction);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }

 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    if (BackupCSA)
    {
        lpMem += WriteNewLineObject (lpMem, SupportDEFG_E);
    }

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_ABC_LAB
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the LAB Input Profile.
*  prototype:
*       GetPS2CSA_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InputIntent --
*       InpDrvClrSp --
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_ABC_LAB (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
               CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary)
{
    CSIG PCS, Dev;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];

    SINT i;
    MEMPTR lpOldMem = lpMem;
    SINT Ret = 0;
 // Check if we can generate the CS.
 // Required  tags are: red, green and blue Colorants.
 // As for TRC tags - we are quite flexible here - if we cannot find the
 // required tag - we assume the linear responce
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPDevSpace (cp, (LPCSIG) & Dev) ||
        (Dev != icSigLabData))
    {
        return (FALSE);
    }
    if ((InpDrvClrSp != icSigLabData) &&
        (InpDrvClrSp != icSigDefData) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
 // Estimate the memory size required to hold CS

    if (lpMem == NULL)                  // This is a size request
    {
        *lpcbSize = 65530;
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);     // .. Illuminant
                                                         
 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array

 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC_Lab);

 //********** /DecodeABC
    lpMem += WriteNewLineObject (lpMem, DecodeABCTag);
    lpMem += WriteObject (lpMem, DecodeABCLab1);

 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, MatrixABCLab);

 //********** /DecodeLMN
    lpMem += WriteNewLineObject (lpMem, DecodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, DecodeLMNLab);
        if (InputIntent == icAbsoluteColorimetric)
        {
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        }
        else
        {
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
        }
        lpMem += WriteObject (lpMem, MulOp); 
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, NewLine);
    }
    lpMem += WriteObject (lpMem, EndArray);


 //********** End dictionary definition
    lpMem += WriteNewLineObject (lpMem, EndDict);
    lpMem += WriteObject (lpMem, EndArray);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) ((lpMem - lpOldMem));
    return (TRUE);
}

/***************************************************************************
*                           GetPS2CSA_MONO_ABC
*  function:
*    this is the function which creates the CIEBasedABC ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_ABC(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_ABC (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                    CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, j, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABCBegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedABC
    lpMem += WriteObject (lpMem, CIEBasedABCTag);   // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeABC
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeABCTag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, DupOp);
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i ++)
    {
        for (j = 0; j < 3; j++)
        {
            if (i != j)
                lpMem += WriteFloat (lpMem, (double)0);
            else
            {
                if (InputIntent == icAbsoluteColorimetric)
                    lpMem += WriteFloat (lpMem, (double)MediaWP[i]);
                else
                    lpMem += WriteFloat (lpMem, (double)IlluminantWP[i]);
            }
        }
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);


    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedABCEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO_A
*  function:
*    this is the function which creates the CIEBasedA ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO_A(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetPS2CSA_MONO_A (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
                  CSIG InputIntent, BOOL AllowBinary)
{
    SINT nCount;
    CSIG Tag, PCS;
    SINT i, Index;
    MEMPTR lpTable;
    SFLOAT IlluminantWP[3];
    SFLOAT MediaWP[3];
    MEMPTR lpBuff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem = lpMem;
    HGLOBAL hBuff;
    MEMPTR lpLineStart;
 // Check if we can generate the CS
    if (!DoesCPTagExist (cp, icSigGrayTRCTag) ||
        !GetCPTagIndex (cp, icSigGrayTRCTag, &Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        (Tag != icSigCurveType) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & lpBuff) ||
        !GetCPElement (cp, Index, lpBuff, MemSize))
    {
        if (NULL != lpBuff)
        {
            MemFree (hBuff);
        }
        return (FALSE);
    }
    nCount = ui32toSINT (((lpcpCurveType) lpBuff)->curve.count);

 // Estimate the memory size required to hold CS
    *lpcbSize = nCount * 6 +            // Number of INT elements
        3 * (lstrlen (IndexArray) +
             lstrlen (StartClip) +
             lstrlen (EndClip)) +
        2048;                           // + other PS stuff
    if (lpMem == NULL)                  // This is a size request
    {
        MemFree (hBuff);
        return (TRUE);
    }
 // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT) & IlluminantWP);          // .. Illuminant

 // Support absolute whitePoint
    GetMediaWP(cp, InputIntent, IlluminantWP, MediaWP);

 //*********** Start creating the ColorSpace
    lpMem += WriteNewLineObject (lpMem, CieBasedABegin);

    lpMem += WriteNewLineObject (lpMem, BeginArray);   // Begin array
 //********** /CIEBasedA
    lpMem += WriteObject (lpMem, CIEBasedATag); // Create entry
    lpMem += WriteObject (lpMem, BeginDict);    // Begin dictionary

 //********** Black/White Point
    lpMem += SendCSABWPoint(lpMem, InputIntent, IlluminantWP, MediaWP);

 //********** /DecodeA
    lpMem += WriteObject (lpMem, NewLine);
    lpLineStart = lpMem;

    if (nCount != 0)
    {
        lpMem += WriteObject (lpMem, DecodeATag);
        lpMem += WriteObject (lpMem, BeginArray);

        lpMem += WriteObject (lpMem, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
            lpMem += WriteObject (lpMem, DecodeA3);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> 0.99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
        } else
        {
            lpMem += WriteObject (lpMem, StartClip);
            lpTable = (MEMPTR) (((lpcpCurveType) lpBuff)->curve.data);
            lpMem += WriteObject (lpMem, BeginArray);
            for (i = 0; i < nCount; i++)
            {
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpTable += sizeof (icUInt16Number);
                if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                {
                    lpLineStart = lpMem;
                    lpMem += WriteObject (lpMem, NewLine);
                }
            }
            lpMem += WriteObject (lpMem, EndArray);
            lpLineStart = lpMem;
            lpMem += WriteObject (lpMem, NewLine);

            lpMem += WriteObject (lpMem, IndexArray);
            lpMem += WriteObject (lpMem, Scale16);
    // If the PCS is Lab, we need to convert Lab to XYZ
    // Now, the range is from 0 --> .99997.
    // Actually, the conversion from Lab to XYZ is not needed.
            if (PCS == icSigLabData)
            {
                lpMem += WriteObject (lpMem, DecodeALab);
                lpMem += WriteObject (lpMem, DecodeLMNLab);
            }
            lpMem += WriteObject (lpMem, EndClip);
        }
        lpMem += WriteObject (lpMem, EndFunction);
        lpMem += WriteObject (lpMem, EndArray);
    }

 //********** /MatrixA
    lpMem += WriteNewLineObject (lpMem, MatrixATag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        if (InputIntent == icAbsoluteColorimetric)
            lpMem += WriteFloat (lpMem, (double) MediaWP[i]);
        else
            lpMem += WriteFloat (lpMem, (double) IlluminantWP[i]);
    }
    lpMem += WriteObject (lpMem, EndArray);

 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    lpMem += WriteObject (lpMem, RangeLMN);

 //********** /End dictionary
    lpMem += WriteObject (lpMem, EndDict);  // End dictionary definition
    lpMem += WriteObject (lpMem, EndArray);

    MemFree (hBuff);

    lpMem += WriteNewLineObject (lpMem, CieBasedAEnd);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);
    return (TRUE);
}
/***************************************************************************
*                           GetPS2CSA_MONO
*  function:
*    this is the function which creates the MONO ColorSpace (CS)
*    from the data supplied in the GRAY Input Profile.
*  prototype:
*       GetPS2CSA_MONO(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpMem       --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Device color type (RGB or GRAY).
*       AllowBinary --  1: binary CSA allowed,  0: only ascii CSA allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetPS2CSA_MONO (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
                DWORD InpDrvClrSp, CSIG InputIntent, BOOL AllowBinary)
{
    BOOL Success = FALSE;
#if 0
    if ((InpDrvClrSp == icSigRgbData) ||
        (InpDrvClrSp == icSigDefData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_ABC (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    } else if (InpDrvClrSp == icSigGrayData)
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
#else
    if ((InpDrvClrSp == icSigGrayData) ||
        (InpDrvClrSp == 0))
    {
        Success = GetPS2CSA_MONO_A (cp, lpMem, lpcbSize, InputIntent, AllowBinary);
    }
    else
    {
        Success = FALSE;
    }
#endif
    return Success;
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateColSpProc (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    lpMem += WriteObject (lpMem, BeginFunction);
    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount != 0)
        {
            if (nCount == 1)            // Gamma supplied in ui16 format
            {
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                lpMem += WriteObject (lpMem, DecodeA3);
            } else
            {
                lpMem += WriteObject (lpMem, StartClip);
                lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
                lpMem += WriteObject (lpMem, DecodeABCArray);
                lpMem += WriteInt (lpMem, (SINT) CPTag);

                if (!AllowBinary)       // Output ASCII CS
                {
                    lpMem += WriteObject (lpMem, IndexArray);
                } else
                {                       // Output BINARY CS
                    lpMem += WriteObject (lpMem, IndexArray16b);
                }
                lpMem += WriteObject (lpMem, Scale16);
                lpMem += WriteObject (lpMem, EndClip);
            }
        }
        MemFree (hBuff);
    }
    lpMem += WriteObject (lpMem, EndFunction);
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a procedure for Color space.
*
***************************************************************************/

SINT 
CreateFloatString (CHANDLE cp, MEMPTR lpMem, CSIG CPTag)
{
    SINT i, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem;
    HGLOBAL hBuff;
    lpOldMem = lpMem;
    if (GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        lpTable = (MEMPTR) & (((lpcpXYZType) Buff)->data);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, si16f16toSFLOAT (lpTable));
            lpTable += sizeof (icS15Fixed16Number);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*
*   Function to create a array later to be used in ColorSpace's DecodeABC.
*
***************************************************************************/

SINT 
CreateColSpArray (CHANDLE cp, MEMPTR lpMem, CSIG CPTag, BOOL AllowBinary)
{
    SINT i, nCount, Index;
    MEMPTR lpTable;
    MEMPTR Buff = NULL;
    SINT MemSize = 0;
    MEMPTR lpOldMem, lpLineStart;
    HGLOBAL hBuff;
    lpOldMem = lpMem;

    lpLineStart = lpMem;

    if (DoesCPTagExist (cp, CPTag) &&
        GetCPTagIndex (cp, CPTag, (LPSINT) & Index) &&
        GetCPElementSize (cp, Index, (LPSINT) & MemSize) &&
        MemAlloc (MemSize, (HGLOBAL FAR *)&hBuff, (LPMEMPTR) & Buff) &&
        GetCPElement (cp, Index, Buff, MemSize))
    {
        nCount = ui32toSINT (((lpcpCurveType) Buff)->curve.count);
        if (nCount > 1)
        {
            lpMem += WriteNewLineObject (lpMem, Slash);
            lpMem += WriteObject (lpMem, DecodeABCArray);
            lpMem += WriteInt (lpMem, (SINT) CPTag);

            lpTable = (MEMPTR) (((lpcpCurveType) Buff)->curve.data);
            if (!AllowBinary)           // Output ASCII CS
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (i = 0; i < nCount; i++)
                {
                    lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            } else
            {                           // Output BINARY CS
                lpMem += WriteHNAToken (lpMem, 149, nCount);
                lpMem += WriteIntStringU2S (lpMem, lpTable, nCount);
            }
            lpMem += WriteObject (lpMem, DefOp);
        }
        MemFree (hBuff);
    }
    return ((SINT) (lpMem - lpOldMem));
}
/***************************************************************************
*                               GetCSAFromProfile
*  function:
*    this is the function which gets the ColorSpace dictionary array
*    from the the Profile.
*  prototype:
*       static BOOL GetCSAFromProfile(
*                       CHANDLE     cp,
*                       MEMPTR      lpMem,
*                       LPDWORD     lpcbSize,
*                       WORD        InpDrvClrSp,
*                       CSIG        DrvColorSpace,
*                       BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*       DrvColorSpace --  Profile device color space.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

static BOOL
GetCSAFromProfile (
                   CHANDLE cp,
                   MEMPTR lpMem,
                   LPDWORD lpcbSize,
                   DWORD InpDrvClrSp,
                   CSIG DrvColorSpace,
                   BOOL AllowBinary)
{
    SINT Index;
    SINT Size;
    if ((DrvColorSpace == icSigGrayData) && (InpDrvClrSp != icSigGrayData))
        return FALSE;

    if (DoesCPTagExist (cp, icSigPs2CSATag) &&
        GetCPTagIndex (cp, icSigPs2CSATag, (LPSINT) & Index) &&
        GetCPElementDataSize (cp, Index, (LPSINT) & Size) &&
        ((lpMem == NULL) || GetCPElementData (cp, Index, lpMem, Size)) &&
        (*lpcbSize = Convert2Ascii (cp, Index, lpMem, *lpcbSize, Size, AllowBinary)))
    {
        return TRUE;
    } else
    {
        return FALSE;
    }
}
/***************************************************************************
*                           GetPS2CSA_DEFG_Intent
*  function:
*    This is the function which creates the CieBasedDEF(G)ColorSpace array
*    based on Intent.
*  prototype:
*       static BOOL GetPS2CSA_DEFG_Intent(
*                   CHANDLE     cp,
*                   MEMPTR      lpBuffer,
*                   LPDWORD     lpcbSize,
*                   CSIG        Intent,
*                   int         Type,
*                   BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetPS2CSA_DEFG_Intent (
                       CHANDLE cp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       DWORD InpDrvClrSp,
                       CSIG Intent,
                       int Type,
                       BOOL AllowBinary)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG icSigAToBx;

 // Try to create CieBasedDEFG CSA first.
    if (((Type == TYPE_CIEBASEDDEFG) && (InpDrvClrSp != icSigCmykData) ||
         (Type == TYPE_CIEBASEDDEF) && (InpDrvClrSp != icSigDefData)) &&
        (InpDrvClrSp != 0))
    {
        return (FALSE);
    }
    switch (Intent)
    {
        case icPerceptual:
            icSigAToBx = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        case icSaturation:
            icSigAToBx = icSigAToB2Tag;
            break;
        case icAbsoluteColorimetric:
            icSigAToBx = icSigAToB1Tag;
            break;
        default:
            return Success;
    }

    if (DoesCPTagExist (cp, icSigAToBx) &&
        GetCPTagIndex (cp, icSigAToBx, (LPSINT) & Index))
    {
        Success = GetPS2CSA_DEFG (cp, lpBuffer, lpcbSize, Intent, Index, Type, AllowBinary);
    }

    return Success;
}
/***************************************************************************
*                               GetPS2ColorSpaceArray
*  function:
*    This is the main function which creates the ColorSpace array
*    from the data supplied in the Profile.
*  prototype:
*       BOOL GetPS2ColorSpaceArray(
*               CHANDLE     cp,
*               CSIG        InputIntent,
*               WORD        InpDrvClrSp,
*               MEMPTR      lpBuffer,
*               LPDWORD     lpcbSize,
*               BOOL        AllowBinary)
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       InpDrvClrSp --  Input device color space.
*                       icSigCmykData: input data is cmyk, create CiebasedDEFG CSA.
*                       icSigRgbData : input data is rgb, create CieBasedABC CSA.
*                       icSigDefData : input data is rgb or lab, create CiebasedDEF CSA.
*                       isSigGrayData: input data is gray, create CieBasedA CSA.
*                       0            : Auto. Create CSA depends on profile color space.
*       InputIntent --  Intent.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
BOOL EXTERN
GetPS2ColorSpaceArray (
                       CHANDLE cp,
                       DWORD InputIntent,
                       DWORD InpDrvClrSp,
                       MEMPTR lpBuffer,
                       LPDWORD lpcbSize,
                       BOOL AllowBinary)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;
    DWORD dwSaveSize;
    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    dwSaveSize = *lpcbSize;
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

 // Get ColorSpace from Profile.
    if ((CSIG) InputIntent == Intent)
    {
        Success = GetCSAFromProfile (cp, lpBuffer, lpcbSize,
                                     InpDrvClrSp, ColorSpace, AllowBinary);
    }
    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    if (!GetPS2CSA_ABC (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, 
                                        AllowBinary, 1))   // create a backup CSA
                        GetDeviceRGB (lpNewBuffer, &cbNewSize, InpDrvClrSp, 1);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;

                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, 
                                         AllowBinary, 0);
                }
                if (!Success)
                {                           // Create DeviceRGB
                    Success = GetDeviceRGB (lpBuffer, lpcbSize, InpDrvClrSp, 0);
                    Success = FALSE;
                }
                break;
            case icSigCmykData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEFG, AllowBinary);
                if (Success)
                {                       // Create DeviceCMYK for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetDeviceCMYK (lpNewBuffer, &cbNewSize, InpDrvClrSp);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create DeviceCMYK
                    Success = GetDeviceCMYK (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigGrayData:
                Success = GetPS2CSA_MONO (cp, lpBuffer, lpcbSize, InpDrvClrSp, 
                                          (CSIG)InputIntent, AllowBinary);
                if (!Success)
                {                           // Create DeviceGray
                    Success = GetDeviceGray (lpBuffer, lpcbSize, InpDrvClrSp);
                    Success = FALSE;
                }
                break;
            case icSigLabData:
                Success = GetPS2CSA_DEFG_Intent (cp, lpBuffer, lpcbSize,
                                                 InpDrvClrSp, (CSIG) InputIntent, 
                                                 TYPE_CIEBASEDDEF, AllowBinary);
                if (Success)
                {                       // Create CieBasedABC or DeviceRGB
                                        // for the printer
                                        // which does not support CieBasedDEF(G).
                    DWORD cbNewSize = 0;
                    MEMPTR lpNewBuffer;
                    MEMPTR lpOldBuffer;
                    if (lpBuffer)
                    {
                        lpNewBuffer = lpBuffer + *lpcbSize;
                        lpOldBuffer = lpNewBuffer;
                        lpNewBuffer += WriteObject (lpNewBuffer, NewLine);
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, NotSupportDEFG_S);
                        cbNewSize = dwSaveSize - (DWORD) (lpNewBuffer - lpBuffer);
                    } else
                        lpNewBuffer = NULL;

                    GetPS2CSA_ABC_LAB (cp, lpNewBuffer, &cbNewSize,
                                        (CSIG)InputIntent, InpDrvClrSp, AllowBinary);

                    if (lpBuffer)
                    {
                        lpNewBuffer += cbNewSize;
                        lpNewBuffer += WriteNewLineObject (lpNewBuffer, SupportDEFG_E);
                        *lpcbSize += (DWORD) (lpNewBuffer - lpOldBuffer);
                    } else
                        *lpcbSize += cbNewSize;
                }
                if (!Success)
                {                           // Create CieBasedABC
                    Success = GetPS2CSA_ABC_LAB (cp, lpBuffer, lpcbSize,
                                         (CSIG)InputIntent, InpDrvClrSp, AllowBinary);
                }
                break;

            default:
                break;
        }
    }
    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\csprof.h ===
#ifndef SUPPORT_H
#define SUPPORT_H 
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#ifdef  __cplusplus
extern "C"
{
#endif

#define  TYPE_CIEBASEDDEF   1
#define  TYPE_CIEBASEDDEFG  2
#define  TempBfSize         128 
#define  CIEXYZRange        1.99997
#define  MAX_LINELENG       240

/*------------------------------------------------------------------------*/
//               Foreword to the functions format.
//  All functions return TRUE if successful
//  and FALSE if not. Exact reason for the FALSE return can be determined
//  by calling GetLastCPError() function.
//  This allows us to use the "C" standard left-to-right evaluation order
//  for the logical expression and the requirement that logical AND
//  operation is performed until FALSE condition is met. That way we can use
//  expression like:
//        if( LoadCP() && ValidateCP() &&
//            DoesCPTagExist() && GetCPTagSig() &&
//            ValidateCPElement())
//        {   // Profile element is OK
//            Process CP Element........
//        }else
//        {     //Something is wrong
//            Err=GetLastCPError();
//        }

// Implementation-specific representation of the handle to the ColorProfile

typedef     MEMPTR      CHANDLE,        // For the convinience and speed
            __far       *LPCHANDLE;     // let's use the pointer to the
                                        // memory block of the profile
                                        // as the profile handle

BOOL    EXTERN LoadCP(LPCSTR filename, HGLOBAL FAR *phMem, LPCHANDLE lphCP);
BOOL    EXTERN LoadCP32(LPCSTR filename, HGLOBAL *phMem, LPCHANDLE lpCP);

BOOL    EXTERN FreeCP(HGLOBAL hMem);

/* Checks if the profile has all required fields  for
    this specific type of the color profile             */
BOOL    EXTERN ValidateCP(CHANDLE hCP);

BOOL    EXTERN DoesCPTagExist(CHANDLE hCP, CSIG CPTag);
BOOL    EXTERN GetCPTagIndex(CHANDLE hCP, CSIG CPTag, LPSINT lpIndex);

BOOL    EXTERN GetCPElementCount(CHANDLE hCP, LPSINT lpIndex);
BOOL    EXTERN ValidateCPElement(CHANDLE hCP, SINT Index);
BOOL    EXTERN GetCPTagSig(CHANDLE hCP, SINT Index, LPCSIG lpCPTag);
BOOL    EXTERN GetCPElementType(CHANDLE hCP, SINT Index, LPCSIG lpCSig);

BOOL    EXTERN GetCPElementSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElementDataSize(CHANDLE hCP, SINT Index, LPSINT lpSize);
BOOL    EXTERN GetCPElement(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementData(CHANDLE hCP, SINT Index, MEMPTR lpData, SINT Size);
BOOL    EXTERN GetCPElementDataType(CHANDLE CP, SINT Index, long far *lpDataType);

// Functions that get all information from the Color Profile Header
BOOL    EXTERN GetCPSize(CHANDLE hCP, LPSINT lpSize);
BOOL    EXTERN GetCPCMMType(CHANDLE hCP, LPCSIG lpType);
BOOL    EXTERN GetCPVersion(CHANDLE hCP, LPSINT lpVers);
BOOL    EXTERN GetCPClass(CHANDLE hCP, LPCSIG lpClass);
BOOL    EXTERN GetCPDevSpace(CHANDLE hCP, LPCSIG lpDevSpace);
BOOL    EXTERN GetCPConnSpace(CHANDLE hCP, LPCSIG lpConnSpace);
BOOL    EXTERN GetCPTarget(CHANDLE hCP, LPCSIG lpTarget);
BOOL    EXTERN GetCPManufacturer(CHANDLE hCP, LPCSIG lpManuf);
BOOL    EXTERN GetCPModel(CHANDLE hCP, LPCSIG lpModel);
BOOL    EXTERN GetCPFlags(CHANDLE hCP, LPSINT lpFlags);
BOOL    EXTERN GetCPAttributes(CHANDLE hCP, LPATTRIB lpAttributes);
BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
BOOL    EXTERN GetCPMediaWhitePoint(CHANDLE CP,  LPSFLOAT lpMediaWP);
BOOL    EXTERN GetCPRenderIntent(CHANDLE CP, LPSINT lpIntent);
BOOL    EXTERN GetPS2ColorRenderingIntent(CHANDLE cp, DWORD Intent,
               MEMPTR lpMem, LPDWORD Size);

SINT    EXTERN GetCPLastCPError();
BOOL    EXTERN SetCPLastCPError(SINT cpError);
BOOL    EXTERN SetCPLastError(SINT LastError);
#ifndef ICMDLL
BOOL    EXTERN ValidColorSpace(LPPDEVICE lppd, LPICMINFO lpICMI, LPCSIG lpDevCS);
#endif

BOOL    EXTERN GetCPWhitePoint(CHANDLE CP,  LPSFLOAT lpWP);
SINT    WriteInt(MEMPTR lpMem, SINT Number);
SINT    WriteHex(MEMPTR lpMem, SINT Number);
SINT    WriteObject(MEMPTR lpMem, MEMPTR Obj);
SINT    WriteObjectN(MEMPTR lpMem, MEMPTR Obj, SINT n);
SINT    WriteHexBuffer(MEMPTR lpMem, MEMPTR lpBuff, MEMPTR lpLineStart, DWORD dwBytes);
SINT    WriteFloat(MEMPTR lpMem, double dFloat);
SINT    WriteStringToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteInt2ByteString(MEMPTR lpMem, MEMPTR lpBuff, SINT sBytes);
SINT    WriteIntStringU2S(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteIntStringU2S_L(MEMPTR lpMem, MEMPTR lpBuff, SINT sNum);
SINT    WriteHNAToken(MEMPTR lpMem, BYTE Token, SINT sNum);
SINT    WriteAscii85(MEMPTR lpDest, unsigned long inword, SINT nBytes);
SINT    ConvertBinaryData2Ascii(MEMPTR lpMem, SINT DataSize, SINT BufSize);
SINT    Convert2Ascii(CHANDLE CP, SINT Index,
		MEMPTR lpData, SINT BufSize, SINT DataSize, BOOL AllowBinary);
#ifdef ICMDLL
SINT    MemCopy(MEMPTR Dest, MEMPTR Source, SINT Length);
#endif
//SRGB98
BOOL    EXTERN InvertMatrix (double FAR * lpInMatrix, double FAR * lpOutMatrix);
BOOL    EXTERN MemAlloc(SINT Size, HGLOBAL FAR *hMemory, LPMEMPTR lpMH);
BOOL    EXTERN MemFree(HGLOBAL hMem);
DWORD FIXED_2DOT30(float);
DWORD FIXED_16DOT16(float);
BOOL   DoesTRCAndColorantTagExist(CHANDLE cp);
BOOL   GetTRCElementSize(CHANDLE cp, CSIG icSigXTRCTag, LPSINT pIndex, LPSINT pTRCSize);
#ifdef  __cplusplus
}
#endif

#endif  //  __SUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\getcrd.h ===
#ifndef GETCRD_H
#define GETCRD_H
BOOL EXTERN  GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
SINT SendCRDLMN(MEMPTR lpMem, CSIG Intent, 
    LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs);
SINT SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint);
SINT SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
    MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary);
SINT SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint);
SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
    SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary);
BOOL GetRevCurve (MEMPTR lpBuff, MEMPTR lpCurve, MEMPTR lpRevCurve);
SINT CreateColorantArray(CHANDLE cp, double FAR *lpArray, CSIG CPTag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\generic.h ===
/**************************************************************************/
/*                                                                        */
/* GENERIC.H -- global include file for pscript driver                    */
/*                                                                        */
/**************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
#include <limits.h>
#include <math.h>
#include <memory.h>
#include <commctrl.h>
#include <winerror.h>

#include "icmdll.h"
#include "icc.h"
#include "icm.h"
#include "icc_i386.h"
#include "csprof.h"
#include "getcrd.h"
#include "getcsa.h"
#include "profcrd.h"
#include "icmstr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\getcsa.h ===
#ifndef GETCSA_H
#define GETCSA_H
BOOL    EXTERN  GetPS2ColorSpaceArray(CHANDLE cp, DWORD InputIntent,
        DWORD InpDrvClrSp, MEMPTR lpBuffer, LPDWORD lpcbSize, BOOL AllowBinary);
BOOL    GetPS2CSA_DEFG_Intent(CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
        DWORD InpDrvClrSp, CSIG Intent, int Type, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
BOOL    GetPS2CSA_ABC_LAB( CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, 
        CSIG InputIntent, DWORD InpDrvClrSp, BOOL AllowBinary);
SINT    GetPublicArrayName(CHANDLE cp, CSIG IntentSig, MEMPTR PublicArrayName);
SINT    CreateInputArray(MEMPTR lpMem, SINT nInputCh, SINT nInputTable ,
        MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
SINT    CreateOutputArray(MEMPTR lpMem, SINT nOutputCh, SINT nOutputTable,
        SINT Offset, MEMPTR Intent, CSIG Tag, MEMPTR  Buff, BOOL AllowBinary, MEMPTR);
VOID    GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
        LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size);
SINT    EnableGlobalDict(MEMPTR lpMem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\icmdll.h ===
#ifndef ICMDLL_H
#define ICMDLL_H

#define __huge
#define __far
#define  _far
#define __pascal
#define __loadds
#undef  FAR
#define FAR
#define SINT    int

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\icc_i386.h ===
#ifndef ICC_I386_H
#define ICC_I386_H
#include "windows.h"

#ifdef  __cplusplus
extern "C"
{
#endif

// ColorProfile errors - can be later added to global Errors
//
typedef enum
{
    CP_NULL_POINTER_ERR = 10000,
    CP_MEMORY_ALLOC_ERR,
    CP_FILE_OPEN_ERR,
    CP_FILE_READ_ERR,
    CP_FORMAT_ERR,
    CP_OUT_OF_RANGE_ERR,
    CP_NO_MEMORY_ERR,
    CP_NOT_FOUND_ERR,
    CP_POSTSCRIPT_ERR
} cpError;


/*------------------------------------------------------------------------*/
//          Application specific data
//
//  We use here the same concept that is used in WINSOCK 1.1 specifications.
//  All the data that come from the ColorProfile are in "network" format,
//   and we deal with that data using "host" format. The "host" byte order can
//   be either big- or little-endian, the size of the integers and floats
//   may vary too, we only require that all "host" type data must have
//   the precision  equal or higher of the "network" data.
//  The platfornm-specific implementation must provide macros or functions
//   to convert from  "network" to "host" representation.
//  Currently we do not write data into profile, so no conversion
//   from "host" to "network" is  required.
//
//  The basic types that should be defined to work with ColorProfiles are:
//
//      BOOL    -   any size variable that can hold either TRUE or FALSE
//      BYTES   -   exactly 8-bit 
//      SINT    -   signed int capable of holding at least 32 bits
//      SFLOAT  -   signed float capable of holding at least 32 bits
//      CSIG    -   entity that can hold at least 32 bits of signature
//                      in host format
//      ATTRIB  -   entity that can hold at least 64 bits of attributes
//                      in host format
//      MEMPTR  -   Pointer to the memory block which can refernce more
//                      than 64K of BYTES
//      
//
/*------------------------------------------------------------------------*/

#ifndef     BOOL
typedef     int             BOOL;       // Any variable that can hold
#endif                                  //  a boolean TRUE/FALSE

typedef     unsigned char   BYTES;      // Exactly 8 bits

typedef     short           SHORT;      // Exactly 16 bits signed int

typedef     unsigned short  USHORT;     // Exactly 16 bits unsigned signed int
                                       
typedef     signed long     SINT;       // The signed integer type that can
                                        //  hold more than 32768( > 16bits)

typedef     float           SFLOAT;     // The type that can hold a floating
                                        //  or fixed point variable
                                        //  at least with 5 digits after point, 
                                        //  both positive and negtive

typedef     unsigned long   CSIG;       // Type that can hold a Signature -
                                        //  32-bits or more

typedef     unsigned long   ATTRIB[2];  // Type that can hold attributes,
                                        // it's more than or equal to 64 bits

typedef     BYTES __huge    *MEMPTR;    // Pointer to the memory that can
                                        // access more than 64K BYTES
typedef     MEMPTR __huge   *PMEMPTR;   

typedef     SHORT __huge    *PSHORT;
typedef     USHORT __huge   *PUSHORT;
typedef     SFLOAT __huge   *PFLOAT;
#define     EXTERN          __loadds __far __pascal  


/*------------------------------------------------------------------------*/
//  Pointers to the platform-specific data types.
//
/*------------------------------------------------------------------------*/

// Those pointers are platform and OS specific. For all 16-bit apps
//   we have to explicitly declare those pointers as __far for them
//   to be able to point to the data in case DS !=SS.
// Pointers that will be used to sequentially access the
//   data (like anypointer[i]  and so on) must be declared  __huge
//   in order to provide correct passing of 64K selector boundary.
// For NT apps and other 32-bit apps all pointers are 32-bits, so no
//   __far and __huge declaration is necessary.

typedef     BYTES   __far   *LPBYTES;
typedef     SINT    __far   *LPSINT;
typedef     SFLOAT  __far   *LPSFLOAT;
typedef     CSIG    __far   *LPCSIG;
typedef     ATTRIB  __far   *LPATTRIB;
typedef     MEMPTR  __far   *LPMEMPTR;

typedef     icProfile       __huge *lpcpProfile;
typedef     icHeader        __huge *lpcpHeader;
typedef     icTagList       __huge *lpcpTagList;
typedef     icTag           __huge *lpcpTag;
typedef     icTagBase       __huge *lpcpTagBase;

typedef     icCurveType     __huge *lpcpCurveType;
typedef     icLut16Type     __huge *lpcpLut16Type;
typedef     icLut8Type      __huge *lpcpLut8Type;
typedef     icXYZType       __huge *lpcpXYZType;


//===========================================================================
//    Macros to convert from Color Profile to Platform-specific
//          data representation.
//  We assume here that all data in ColorProfile are accessed through
//      pointer to BYTES. The only valid way to use those macros
//      is to call them this way:
//          MEMPTR lpMem;
//          ...
//          lpMem = ..........;
//          z = XtoY(lpMem);

#define     ui8toSINT(a)    ((SINT) (a))
#define     ui16toSINT(a)   ((SINT) ( ( ((a)[0]<<8) & 0x00FF00) | \
                                      (  (a)[1] & 0x00FF)))
#define     ui32toSINT(a)   ((SINT) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )))

#define     si8toSINT(a)    ((SINT) (a))
#define     si16toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<8 | \
                                      (        (a)[1] & 0x00FF)))
#define     si32toSINT(a)   ((SINT) (   ((SINT)(a)[0])<<24                | \
                                    (  (((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                    (  (       (a)[2] <<8)  & 0x00FF00  ) | \
                                    (          (a)[3] & 0x00FF          )))

#define     ui8f8toSFLOAT(a)   ((SFLOAT)(  (a)[0] + (a)[1]/256.0) )
#define     ui16f16toSFLOAT(a) ((SFLOAT)(  (a)[0]*256.0         + \
                                           (a)[1]               + \
                                         ( (a)[2]               + \
                                           (a)[3]/256.0 ) /256.0 ))


#define     si16f16toSFLOAT(a) ( ((SFLOAT)( ((SINT)(a)[0])<<24                | \
                                          ((((SINT)(a)[1])<<16) & 0x00FF0000) | \
                                          (       ((a)[2] <<8)  & 0x00FF00  ) | \
                                          (        (a)[3]        & 0x00FF   )   \
                                 )) /65536.0)


#define     SigtoCSIG(a)    ((CSIG) ( ( (((SINT)(a)[0])<<24) & 0x00FF000000) | \
                                      ( (((SINT)(a)[1])<<16) & 0x00FF0000  ) | \
                                      ( (       (a)[2] <<8)  & 0x00FF00    ) | \
                                      (         (a)[3]       & 0x00FF      )  ) )


#ifdef  __cplusplus
}
#endif

#endif  //  ICC_I386_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\icm.h ===
#ifndef ICM_H
#define ICM_H
#include "windows.h"
#include "icc.h"
#include "icc_i386.h"

#define CMS_GET_VERSION     0x00000000
#define CMS_GET_IDENT       0x00000001
#define CMS_GET_DRIVER_LEVEL 0x00000002
#define CMS_GET_RESERVED    0xFFFFFFFC

#define CMS_LEVEL_1         0x00000001
#define CMS_LEVEL_2         0x00000002
#define CMS_LEVEL_3         0x00000004
#define CMS_LEVEL_RESERVED  0xFFFFFFFC



#define CMS_FORWARD         0x00000000
#define CMS_BACKWARD        0x00000001

#define CMS_X555WORD        0x00000000
#define CMS_565WORD         0x00000001
#define CMS_RGBTRIPLETS     0x00000002
#define CMS_BGRTRIPLETS     0x00000004
#define CMS_XRGBQUADS       0x00000008
#define CMS_XBGRQUADS       0x00000010
#define CMS_QUADS           0x00000020

#ifndef ICMDLL
#define LCS_CALIBRATED_RGB  0x00000000
#define LCS_DEVICE_RGB	    0x00000001
#define LCS_DEVICE_CMYK     0x00000002

#define LCS_GM_DEFAULT      0x00000000
#define LCS_GM_BUSINESS     0x00000001
#define LCS_GM_GRAPHICS     0x00000002
#define LCS_GM_IMAGES       0x00000004
#endif

// Use printer colors       == 0
// Change all RGBs          == CM_USE_ICM;
// Select downloaded CRD    == CM_USE_CS | CM_USE_CRD
// Download/select CRD      == CM_USE_CS | CM_USE_CRD | CM_SEND_CRD
// Use Sony                 == CM_USE_CS
#define CM_USE_CS           0x00000001
#define CM_USE_CRD          0x00000002
#define CM_SEND_CRD         0x00000004
#define CM_USE_ICM          0x00000008
#define CM_CMYK_IN          0x00000010
#define CM_CMYK_DIB_IN	    0x00000020
#define CM_CMYK_OUT         0x00000040
#define CM_CMYK 	    CM_CMYK_IN | CM_CMYK_DIB_IN | CM_CMYK_OUT


typedef HANDLE      HCOLORSPACE;
typedef DWORD       HCTMTRANSFORM;

// SRGB98
#define  REVCURVE_RATIO         1

/*  Logical Color Space Structure */

#ifndef ICMDLL
typedef struct tagLOGCOLORSPACE {
DWORD lcsSignature;
DWORD lcsVersion;
DWORD lcsSize;
DWORD lcsCSType;
DWORD lcsGamutMatch;
CIEXYZTRIPLE lcsEndpoints;
DWORD lcsGammaRed;
DWORD lcsGammaGreen;
DWORD lcsGammaBlue;
char    lcsFilename[MAX_PATH];
} LOGCOLORSPACE;
typedef LOGCOLORSPACE FAR *LPLOGCOLORSPACE;
#endif

typedef struct tagICMINFO {
	LOGCOLORSPACE   lcsSource;  // source image colorspace
	HCTMTRANSFORM   hICMT;      // Handle to the associated transform
        char            lcsDestFilename[256];
        char            lcsTargetFilename[256];
        LPSTR           lppd;       // Used to find the buffered bitmap.
                                    // Fix bug 195632. jjia  2/20/97.
} ICMINFO , FAR *LPICMINFO;


typedef enum {CS_DEVICE_RGB = 0, CS_DEVICE_CMYK,
			CS_CALIBRATED_RGB, CS_SONY_TRINITRON } CSPACESET;


#ifndef ICMDLL
BOOL FAR PASCAL EnableICM(HDC, BOOL);
HANDLE FAR PASCAL LoadImageColorMatcher(LPSTR);
BOOL FAR PASCAL FreeImageColorMatcher(HANDLE);
int FAR PASCAL EnumColorProfiles(HDC,FARPROC,LPARAM);
BOOL FAR PASCAL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE FAR PASCAL GetColorSpace(HDC);
BOOL FAR PASCAL GetLogColorSpace(HCOLORSPACE,LPVOID,DWORD);
HCOLORSPACE FAR PASCAL CreateColorSpace(LPLOGCOLORSPACE);
BOOL FAR PASCAL SetColorSpace(HDC,HCOLORSPACE);
BOOL FAR PASCAL DeleteColorSpace(HCOLORSPACE);
BOOL FAR PASCAL GetColorProfile(HDC,LPSTR,WORD);
BOOL FAR PASCAL SetColorProfile(HDC,LPSTR);
BOOL FAR PASCAL GetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL SetDeviceGammaRamp(HDC,LPVOID);
BOOL FAR PASCAL ColorMatchToTarget(HDC,HDC,WORD);
#endif

#define CS_ENABLE       1
#define CS_DISABLE      2
#define CS_DELETE_TRANSFORM 3

DWORD _loadds FAR PASCAL CMGetInfo(DWORD dwInfo);

HCTMTRANSFORM _loadds      FAR PASCAL CMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  CMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  CMTranslateRGB(HCTMTRANSFORM hTransform,RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  CMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,
							DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   CMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
BOOL _loadds    FAR PASCAL   CMGetPS2ColorSpaceArray(
                                                 LPSTR       lpProfileName,
                                                 DWORD       InputIntent,
                                                 WORD        InpDrvClrSp,
                                                 MEMPTR      lpBuffer, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL   CMGetPS2ColorRenderingDictionary(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent, 
                                                 MEMPTR      lpMem, 
                                                 LPDWORD     lpcbSize,
                                                 BOOL        AllowBinary);

BOOL _loadds    FAR PASCAL  CMGetPS2ColorRenderingIntent(
                                                 LPSTR       lpProfileName,
                                                 DWORD       Intent,
                                                 MEMPTR      lpMem,
                                                 LPDWORD     lpcbSize);


HCTMTRANSFORM _loadds      FAR PASCAL ICMCreateTransform(LPLOGCOLORSPACE lpCS, 
						LPSTR lpDevCh, LPSTR lpTargetDevCh);

BOOL _loadds    FAR PASCAL  ICMDeleteTransform(HCTMTRANSFORM hTransform);

BOOL _loadds    FAR PASCAL  ICMTranslateRGB(HCTMTRANSFORM hTransform, RGBQUAD RGBQuad,
						LPVOID lpResult, DWORD dwFlags);

BOOL _loadds    FAR PASCAL  ICMTranslateRGBs(HCTMTRANSFORM hTransform, 
						 LPVOID    lpSrc, DWORD dwSrcFlags,	
                   DWORD nSrcWidth, DWORD nSrcHeight, DWORD nSrcStride,
						 LPVOID lpDest, DWORD dwDestFlags, DWORD dwFlags);

BOOL _loadds    FAR PASCAL   ICMCheckColorsInGamut(HCTMTRANSFORM hTransform, 
						 LPVOID   lpSrc,
						 LPVOID lpDest, DWORD dwCount);
// ALWAYS_ICM
HCTMTRANSFORM _loadds FAR PASCAL CreateDefTransform (LPVOID lppd);
BOOL _loadds FAR PASCAL DeleteDefTransform (HCTMTRANSFORM hTransform);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\icmstr.h ===
#ifndef ICMSTR_H
#define ICMSTR_H

extern  char _far    BeginString[]       ;
extern  char _far    EndString[]         ;
extern  char _far    BeginArray[]        ;
extern  char _far    EndArray[]          ;
extern  char _far    BeginFunction[]     ;
extern  char _far    EndFunction[]       ;
extern  char _far    BeginDict[]         ;
extern  char _far    EndDict[]           ;
extern  char _far    BlackPoint[]        ;
extern  char _far    DictType[]          ;

extern  char _far    WhitePointTag[]     ;
extern  char _far    BlackPointTag[]     ;
extern  char _far    RangePQRTag[]       ;
extern  char _far    TransformPQRTag[]   ;
extern  char _far    MatrixPQRTag[]      ;

extern  char _far    RangeABCTag[]       ;
extern  char _far    MatrixATag[]        ;
extern  char _far    MatrixABCTag[]      ;
extern  char _far    EncodeABCTag[]      ;
extern  char _far    RangeLMNTag[]       ;
extern  char _far    MatrixLMNTag[]      ;
extern  char _far    EncodeLMNTag[]      ;
extern  char _far    RenderTableTag[]    ;
extern  char _far    CIEBasedATag[]      ;
extern  char _far    CIEBasedABCTag[]    ;
extern  char _far    CIEBasedDEFGTag[]   ;
extern  char _far    CIEBasedDEFTag[]    ;
extern  char _far    DecodeATag[]        ;
extern  char _far    DecodeABCTag[]      ;
extern  char _far    DecodeLMNTag[]      ;
extern  char _far    DeviceRGBTag[]      ;
extern  char _far    DeviceCMYKTag[]     ;
extern  char _far    DeviceGrayTag[]     ;
extern  char _far    TableTag[]          ;
extern  char _far    DecodeDEFGTag[]     ;
extern  char _far    DecodeDEFTag[]      ;

extern  char _far    NullOp[]            ;
extern  char _far    DupOp[]             ;
extern  char _far    UserDictOp[]        ;
extern  char _far    GlobalDictOp[]      ;
extern  char _far    CurrentGlobalOp[]   ;
extern  char _far    SetGlobalOp[]       ;
extern  char _far    DefOp[]             ;
extern  char _far    BeginOp[]           ;
extern  char _far    EndOp[]             ;
extern  char _far    TrueOp[]            ;
extern  char _far    FalseOp[]           ;
extern  char _far    MulOp[]             ;
extern  char _far    DivOp[]             ;

extern  char _far    NewLine[]           ;
extern  char _far    Slash[]             ;
extern  char _far    Space[]             ;
extern  char _far    CRDBegin[]          ;
extern  char _far    CRDEnd[]            ;
extern  char _far    CieBasedDEFGBegin[] ;
extern  char _far    CieBasedDEFBegin[]  ;
extern  char _far    CieBasedABCBegin[]  ;
extern  char _far    CieBasedABegin[]    ;
extern  char _far    CieBasedDEFGEnd[]   ;
extern  char _far    CieBasedDEFEnd[]    ;
extern  char _far    CieBasedABCEnd[]    ;
extern  char _far    CieBasedAEnd[]      ;
extern  char _far    RangeABC[]          ;
extern  char _far    RangeLMN[]          ;
extern  char _far    Identity[]          ;
extern  char _far    RangeABC_Lab[]      ;

extern  char _far    Clip01[]            ;
extern  char _far    DecodeA3[]          ;
extern  char _far    DecodeA3Rev[]       ;
extern  char _far    DecodeABCArray[]    ;
extern  char _far    InputArray[]        ;
extern  char _far    OutputArray[]       ;

extern  char _far    IndexArray16b[]     ;
extern  char _far    IndexArray[]        ;
extern  char _far    TestingDEFG[]       ;

extern  char _far    SupportDEFG_S[]     ;
extern  char _far    NotSupportDEFG_S[]  ;
extern  char _far    SupportDEFG_E[]     ;

extern  char _far    StartClip[]         ;
extern  char _far    EndClip[]           ;

extern  char _far    Scale8[]            ;
extern  char _far    Scale16[]           ;
extern  char _far    Scale16XYZ[]        ;
extern  char _far    TFunction8[]        ;
extern  char _far    TFunction8XYZ[]     ;
extern  char _far    MatrixABCLab[]      ;

extern  char _far    DecodeABCLab1[]     ;
extern  char _far    DecodeALab[]        ;
extern  char _far    DecodeLMNLab[]      ;
extern  char _far    RangeLMNLab[]       ;
extern  char _far    EncodeLMNLab[]      ;
extern  char _far    MatrixABCLabCRD[]   ;
extern  char _far    MatrixABCXYZCRD[]   ;
extern  char _far    EncodeABCLab1[]     ;
extern  char _far    EncodeABCLab2[]     ;
extern  char _far    MatrixPQR[]         ;
extern  char _far    RangePQR[]          ;
extern  char _far    *TransformPQR[3]    ;
extern  char _far    CSAName[]           ;
extern  char _far    PreViewInArray[]    ;
extern  char _far    PreViewOutArray[]   ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\main.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


// menu commands

// Find menu
#define IDM_OPENFILE        100
#define IDM_SAVEFILE        101
#define IDM_SAVEFILEAS      102
#define IDM_PRINT           103
#define IDM_EXIT            104

// Options menu
#define IDM_ENTERNEW        200
#define IDM_CHOOSECOLOR     201
#define IDM_CHOOSEFONT      202
#define IDM_FINDTEXT        203
#define IDM_REPLACETEXT     204
#define IDM_STANDARD        205
#define IDM_HOOK            206
#define IDM_CUSTOM          207

// Settings
#define IDM_PERCEPUAL       400
#define IDM_COLOR           401
#define IDM_SATURATION      402
#define IDM_ASCII           403
#define IDM_BINARY          404
#define IDM_AUTO            405
#define IDM_ABC             406
#define IDM_DEFG            407
#define IDM_INP_AUTO        408
#define IDM_INP_GRAY        409
#define IDM_INP_RGB         410
#define IDM_INP_CMYK        411
#define IDM_CSA             412
#define IDM_CRD             413
#define IDM_INTENT          414
#define IDM_PROFCRD         415
// Help menu
#define IDM_ABOUT           300


// Dialog box constants
#define IDEDIT              500

// string constants

#define IDS_DIALOGFAILURE     1
#define IDS_STRUCTSIZE        2
#define IDS_INITIALIZATION    3
#define IDS_NOTEMPLATE        4
#define IDS_NOHINSTANCE       5
#define IDS_LOADSTRFAILURE    6
#define IDS_FINDRESFAILURE    7
#define IDS_LOADRESFAILURE    8
#define IDS_LOCKRESFAILURE    9
#define IDS_MEMALLOCFAILURE  10
#define IDS_MEMLOCKFAILURE   11
#define IDS_NOHOOK           12
#define IDS_SETUPFAILURE     13
#define IDS_PARSEFAILURE     14
#define IDS_RETDEFFAILURE    15
#define IDS_LOADDRVFAILURE   16
#define IDS_GETDEVMODEFAIL   17
#define IDS_INITFAILURE      18
#define IDS_NODEVICES        19
#define IDS_NODEFAULTPRN     20
#define IDS_DNDMMISMATCH     21
#define IDS_CREATEICFAILURE  22
#define IDS_PRINTERNOTFOUND  23
#define IDS_NOFONTS          24
#define IDS_SUBCLASSFAILURE  25
#define IDS_INVALIDFILENAME  26
#define IDS_BUFFERTOOSMALL   27
#define IDS_FILTERSTRING     28
#define IDS_UNKNOWNERROR     29

// constants

#define FILE_LEN            128

// Function prototypes

// procs
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK About(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EnterNew(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileOpenHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FileSaveHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK FindTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintDlgHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM);

//functions
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
BOOL OpenNewFile( HWND );
BOOL SaveToFile( HWND );
BOOL SaveAs( HWND );
void SearchFile( LPFINDREPLACE );
BOOL ChooseNewFont( HWND );
BOOL ChooseNewColor( HWND );
void PrintFile( HWND );
void CallFindText( HWND );
void CallReplaceText( HWND );
void ProcessCDError(DWORD, HWND);

void    ColorSpaceControl( LPSTR FileName, LPSTR SaveFileName, WORD InpDrvClrSp,
        DWORD Intent, WORD CSAType, BOOL AllowBinary);
void    CreateCRDControl( LPSTR FileName, LPSTR SaveFileName,
        DWORD Inter_Intent, BOOL AllowBinary);
void    CreateINTENTControl(LPSTR FileName, LPSTR SaveFileName, DWORD Inter_Intent);
void    CreateProfCRDControl(LPSTR DevProfile, LPSTR TargetProfile, 
        LPSTR SaveFileName, DWORD Inter_Intent, BOOL AllowBinary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\ps2color.h ===
#ifndef PS2COLOR_H
#define PS2COLOR_H
BOOL GetPS2ColorRenderingDictionary(
    CHANDLE     cp,
    DWORD       Intent, 
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize,
    BOOL        AllowBinary);
BOOL    GetPS2ColorSpaceArray(
    CHANDLE     cp, 
    DWORD       InputIntent, 
    DWORD       InpDrvClrSp,  
    MEMPTR      lpBuffer, 
    LPDWORD     lpcbSize, 
    BOOL        AllowBinary);
BOOL    EXTERN GetPS2ColorRenderingIntent(
    CHANDLE     cp, 
    DWORD       Intent,
    MEMPTR      lpMem, 
    LPDWORD     lpcbSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icSigK007Tag                        0x4B303037   /* 'K007' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\profcrd.h ===
#ifndef PROFCRD_H
#define PROFCRD_H

#define MAXCHANNELS    4
#define PREVIEWCRDGRID 17

typedef struct tagHOSTCLUT {
    USHORT         size;
    USHORT         wdummy;
    DWORD          colorSpace;
    DWORD          pcs;
    DWORD          intent;
    float          whitePoint[3];
    float          mediaWP[3];
    unsigned char  inputChan;
    unsigned char  outputChan;
    unsigned char  clutPoints;
    unsigned char  lutBits;
    float          e[9];
    USHORT         inputEnt;
    USHORT         outputEnt;
    MEMPTR         inputArray[MAXCHANNELS];
    MEMPTR         outputArray[MAXCHANNELS];
    MEMPTR         clut;
} HOSTCLUT;
typedef HOSTCLUT __huge *LPHOSTCLUT;

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (
                                CHANDLE cpDev,
								CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL AllowBinary);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDD_DIALOG1                     101
#define IDI_ICON1                       102
#define IDC_EDIT1                       1000
#define IDC_BUTTON1                     1001
#define IDC_EDIT2                       1002
#define IDC_EDIT3                       1003
#define IDC_BUTTON2                     1004
#define IDC_BUTTON3                     1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         106
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\dll32\profcrd.c ===
#include "generic.h"
#include "icmstr.h"

#pragma code_seg(_ICM3SEG)

#define MAXCOLOR8  255

#pragma optimize("", off)

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
       SINT numChan, SINT tableSize, SINT Offset, CSIG Tag, MEMPTR Buff);
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, BOOL, BOOL);
BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
       CSIG Intent, int Type);
static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp);
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
       float far *Input, float far *Output, 
       CSIG ColorSpace, BOOL bCheckOutputTable);
static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output);
static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
       LPSINT lpInTbSize, LPSINT lpOutTbSize, 
       LPCSIG lpIntentTag, LPSINT lpGrids);
static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint);

/***************************************************************************
*                           CreateHostInputOutputArray
*  function:
*    this is the function which creates the output array from the data
*    supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*    MEMPTR     lpMem        : The buffer to save output array.
*    LPHOSTCLUT lpHostClut   : 
*    SINT       nOutputCh    : Number of input channel.
*    SINT       nOutputTable : The size of each input table. 
*    SINT       Offset       : The position of source output data(in icc profile).
*    CSIG       Tag          : To determin the Output table is 8 or 16 bits.
*    MEMPTR     Buff         : The buffer that contains source data(copyed from icc profile)
*
*  returns:
*       SINT    Returns number of bytes of Output Array
*
***************************************************************************/

static SINT
CreateHostInputOutputArray (MEMPTR lpMem, PMEMPTR ppArray,
                            SINT numChan, SINT tableSize, 
                            SINT Offset, CSIG Tag, MEMPTR Buff)
{
    SINT    i, j;
    PUSHORT lpMemPtr16;
    MEMPTR  lpMemPtr8;
    MEMPTR  lpTable;

    if (Tag == icSigLut8Type)
        lpMemPtr8 = lpMem;
    else
        lpMemPtr16 = (PUSHORT)lpMem;

    for (i = 0; i < numChan; i++)
    {
        if (Tag == icSigLut8Type)
        {
            ppArray[i] = lpMemPtr8;
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                Offset +
                tableSize * i;
            MemCopy(lpMemPtr8, lpTable, tableSize);
                lpMemPtr8 += tableSize;
        }
        else
        {
            ppArray[i] = (MEMPTR)lpMemPtr16;
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * Offset +
                2 * tableSize * i;
            for (j = 0; j < tableSize; j++)
            {
                *lpMemPtr16++ = (USHORT) ui16toSINT (lpTable);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }
    if (Tag == icSigLut8Type)
        return ((SINT) ((MEMPTR)lpMemPtr8 - lpMem));
    else
        return ((SINT) ((MEMPTR)lpMemPtr16 - lpMem));

}

VOID
GetCLUTinfo(CSIG LutTag, MEMPTR lpLut, LPSINT nInputCh, LPSINT nOutputCh, 
            LPSINT nGrids, LPSINT nInputTable, LPSINT nOutputTable, LPSINT size)
{
    if (LutTag == icSigLut8Type)
    {
        *nInputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut8Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut8Type) lpLut)->lut.clutPoints);
        *nInputTable = 256L;
        *nOutputTable = 256L;
        *size = 1;  // one byte for each input\output table entry
    } else
    {
        *nInputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.inputChan);
        *nOutputCh = ui8toSINT (((lpcpLut16Type) lpLut)->lut.outputChan);
        *nGrids = ui8toSINT (((lpcpLut16Type) lpLut)->lut.clutPoints);
        *nInputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.inputEnt);
        *nOutputTable = ui16toSINT (((lpcpLut16Type) lpLut)->lut.outputEnt);
        *size = 2;  // two bytes for each input\output table entry
    }
}

/***************************************************************************
*                           GetHostCSA
*  function:
*    this is the function which creates a Host CSA
*  parameters:
*       CHANDLE cp       --  Color Profile handle 
*       MEMPTR lpMem     --  Pointer to the memory block. If this point is NULL,
*                            require buffer size.
*       LPDWORD lpcbSize --  Size of the memory block
*       CSIG InputIntent --
*       SINT Index       --  to the icc profile tag that contains the data of Intent
*       int  Type        --  DEF or DEFG
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostCSA (CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize,
            CSIG InputIntent, SINT Index, int Type)
{
    CSIG    PCS, LutTag;
    CSIG    IntentSig;
    SINT    nInputCh, nOutputCh, nGrids, SecondGrids;
    SINT    nInputTable, nOutputTable, nNumbers;
    SINT    i, j, k;
    MEMPTR  lpTable;
    MEMPTR  lpOldMem = lpMem;
    MEMPTR  lpLut = NULL;
    HGLOBAL hLut = 0;
    SINT    LutSize;
    LPHOSTCLUT lpHostClut;

    // Check if we can generate the CS.
    // If we cannot find the required tag - we will return false
    if (!GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        (PCS != icSigLabData) && (PCS != icSigXYZData) ||
        !GetCPTagSig (cp, Index, (LPCSIG) & IntentSig))
    {
        return (FALSE);
    }
    if (!GetCPElementType (cp, Index, (LPCSIG) & LutTag) ||
        ((LutTag != icSigLut8Type) && (LutTag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & LutSize) ||
        !MemAlloc (LutSize, (HGLOBAL FAR *) &hLut, (LPMEMPTR) & lpLut) ||
        !GetCPElement (cp, Index, lpLut, LutSize))
    {
        if (0 != hLut)
        {
            MemFree (hLut);
        }
        return (FALSE);
    }

    // Estimate the memory size required to hold CS
    GetCLUTinfo(LutTag, lpLut, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (Type == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (Type == TYPE_CIEBASEDDEFG)))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hLut);
        return (FALSE);
    }
	
    // First Pass. This is a size request
    if (lpMem == NULL)                  
    {
        if (Type == TYPE_CIEBASEDDEFG)
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids * nGrids;
        else
            *lpcbSize = nOutputCh * nGrids * nGrids * nGrids;
        *lpcbSize = *lpcbSize             +   // size of RenderTable 8-bits only
            nInputCh * nInputTable * i    +   // size of input table 8/16-bits
            nOutputCh * nOutputTable * i  +   // size of output table 8/16-bits
            sizeof(HOSTCLUT) + 1024;          // data structure + extra safe space
        MemFree (hLut);
        return (TRUE);
    }

    // Second pass. constructure real HostCSA
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (LutTag == icSigLut8Type)? 8:16;

    // Get info about Illuminant White Point from the header
    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;
    // Input Array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, LutTag, lpLut);

    if (Type == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    } else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    // ourput array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, LutTag, lpLut);
 //********** /Table

    lpHostClut->clut = lpMem;
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (Type == TYPE_CIEBASEDDEFG)
    {
        SecondGrids = nGrids;
    }
    for (i = 0; i < nGrids; i++)        // Nh strings should be sent
    {
        for (k = 0; k < SecondGrids; k++)
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) (((lpcpLut8Type) lpLut)->lut.data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            } else
            {
                lpTable = (MEMPTR) (((lpcpLut16Type) lpLut)->lut.data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (LutTag == icSigLut8Type)
            {
                // Copy 8-bit data.
                MemCopy(lpMem, lpTable, nNumbers);
                lpMem += nNumbers;
            }
            else
            {
                // convert 16 bit integer to right format. then copy only 8 bits.
                for (j = 0; j < nNumbers; j++)
                {
                    *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                    lpTable += sizeof (icUInt16Number);
                }
            }
        }
    }

    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    MemFree (hLut);
    return (TRUE);
}

HGLOBAL GetTRCData(CHANDLE cp,
        LPMEMPTR lpRed,  LPMEMPTR lpGreen,  LPMEMPTR lpBlue,
        LPSINT   lpnRed, LPSINT   lpnGreen, LPSINT   lpnBlue)
{
    SINT     RedTRCIndex, GreenTRCIndex, BlueTRCIndex;
    SINT     RedTRCSize = 0, GreenTRCSize = 0, BlueTRCSize = 0;
    SINT     MemSize;
    HGLOBAL  hMem;

 // Check if we can generate the CRD
    if (!GetTRCElementSize(cp, icSigRedTRCTag, &RedTRCIndex, &RedTRCSize) ||
        !GetTRCElementSize(cp, icSigGreenTRCTag, &GreenTRCIndex, &GreenTRCSize) ||
        !GetTRCElementSize(cp, icSigBlueTRCTag, &BlueTRCIndex, &BlueTRCSize))
    {
         return 0;
    }
    MemSize = RedTRCSize + GreenTRCSize + BlueTRCSize;
    if (!MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) lpRed))
        return 0;

    *lpGreen = *lpRed + RedTRCSize;
    *lpBlue = *lpGreen + GreenTRCSize;
    if (!GetCPElement (cp, RedTRCIndex, *lpRed, RedTRCSize) ||
        !GetCPElement (cp, GreenTRCIndex, *lpGreen, GreenTRCSize ) ||
        !GetCPElement (cp, BlueTRCIndex, *lpBlue, BlueTRCSize ))
    {
        MemFree (hMem);
        return (NULL);
    }
    *lpnRed = ui32toSINT (((lpcpCurveType) *lpRed)->curve.count);
    *lpnGreen = ui32toSINT (((lpcpCurveType) *lpGreen)->curve.count);
    *lpnBlue = ui32toSINT (((lpcpCurveType) *lpBlue)->curve.count);

    return (hMem);
}


static SINT
CreateHostTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                        MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    SINT    i;
    PUSHORT lpPtr16;
    MEMPTR  lpTable;

    lpPtr16 = (PUSHORT)lpMem;
   
    lpHostClut->inputArray[0] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpRed)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[1] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpGreen)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }

    lpHostClut->inputArray[2] = (MEMPTR)lpPtr16;
    lpTable = (MEMPTR)(((lpcpCurveType) lpBlue)->curve.data);
    for (i = 0; i < (SINT)(lpHostClut->inputEnt); i++)
    {
        *lpPtr16++ = (USHORT) ui16toSINT(lpTable);
        lpTable += sizeof(icUInt16Number);
    }
    return ((MEMPTR)lpPtr16 - lpMem);
}

static SINT
CreateHostRevTRCInputTable(MEMPTR lpMem, LPHOSTCLUT lpHostClut,
                           MEMPTR lpRed, MEMPTR lpGreen, MEMPTR lpBlue)
{
    HGLOBAL   hTemp;
    MEMPTR    lpTemp;

    if (!MemAlloc (lpHostClut->outputEnt * (REVCURVE_RATIO + 1) * 2 ,
                  (HGLOBAL FAR *) &hTemp, (LPMEMPTR) &lpTemp))
    {
        return (0);
    }

    lpHostClut->outputArray[0] = lpMem;
    GetRevCurve (lpRed, lpTemp, lpHostClut->outputArray[0]);
    lpHostClut->outputArray[1] = lpHostClut->outputArray[0] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpGreen, lpTemp, lpHostClut->outputArray[1]);
    lpHostClut->outputArray[2] = lpHostClut->outputArray[1] +
                                2 * REVCURVE_RATIO * lpHostClut->outputEnt;
    GetRevCurve (lpBlue, lpTemp, lpHostClut->outputArray[2]);

    MemFree (hTemp);
    return ( 2 * REVCURVE_RATIO * lpHostClut->outputEnt * 3);
}

static BOOL
GetHostMatrixCSAorCRD(CHANDLE cp, MEMPTR lpMem, LPDWORD lpcbSize, BOOL bCSA)
{
    SINT     nRedCount, nGreenCount, nBlueCount;
    MEMPTR   lpRed = NULL,lpGreen, lpBlue;
    HGLOBAL  hMem;
    LPHOSTCLUT lpHostClut;
    MEMPTR   lpOldMem = lpMem;
    double   pArray[9], pRevArray[9], pTemp[9];
    SINT     i;

    hMem = GetTRCData(cp,
        (LPMEMPTR)&lpRed, (LPMEMPTR)&lpGreen, (LPMEMPTR)&lpBlue,
        (LPSINT)&nRedCount,(LPSINT)&nGreenCount, (LPSINT)&nBlueCount);

    // Estimate the memory size required to hold CRD
    *lpcbSize = (nRedCount + nGreenCount + nBlueCount) * 2 +
           sizeof(HOSTCLUT) + 1024;      // data structure + extra safe space

    if (lpMem == NULL)                   // This is a size request
    {
        MemFree (hMem);
        return TRUE;
    }

    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->dataType = DATA_matrix;
    lpHostClut->clutPoints = 2;
    lpHostClut->pcs = icSigXYZData;
    GetCPWhitePoint(cp, (LPSFLOAT)lpHostClut->whitePoint);

    if (bCSA)
    {
        lpHostClut->inputEnt = (USHORT)nRedCount;
        lpHostClut->inputChan = 3;
        lpMem += CreateHostTRCInputTable(lpMem, lpHostClut,
                                         lpRed, lpGreen, lpBlue);
    }
    else
    {
        lpHostClut->outputEnt = (USHORT)nRedCount;
        lpHostClut->outputChan = 3;
        lpMem += CreateHostRevTRCInputTable(lpMem, lpHostClut,
                                            lpRed, lpGreen, lpBlue);
    }

    MemFree (hMem);
    *lpcbSize = (DWORD) (lpMem - lpOldMem);

    if (!CreateColorantArray(cp, &pTemp[0], icSigRedColorantTag) ||
        !CreateColorantArray(cp, &pTemp[3], icSigGreenColorantTag) ||
        !CreateColorantArray(cp, &pTemp[6], icSigBlueColorantTag))
    {
       return (FALSE);
    }

    for (i = 0; i < 9; i++)
    {
        pArray[i] = pTemp[i/8*8 + i*3%8];
    }

    if (bCSA)
    {
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pArray[i];
    }
    else
    {
        InvertMatrix(pArray, pRevArray);
        for (i = 0; i < 9; i++)
            lpHostClut->e[i] = (float)pRevArray[i];
    }

    return TRUE;
}

/***************************************************************************
*                        GetHostCSA_Intent
*  function:
*       This is the function which creates the Host DEF or DEFGColorSpace array
*       based on Intent.
*  parameters:
*       cp          --  Color Profile handle
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*       Intent      --  Intent.
*       Type        --  CieBasedDEF or CieBasedDEF.
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostCSA_Intent (CHANDLE cp, MEMPTR lpBuffer, LPDWORD lpcbSize,
                   CSIG Intent, int Type)
{
    SINT Index;
    BOOL Success = FALSE;
    CSIG AToBxTag;

    switch (Intent)
    {
        case icPerceptual:
            AToBxTag = icSigAToB0Tag;
            break;
        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // use RelativeColorimetric data to build it.
            AToBxTag = icSigAToB1Tag;
            break;
        case icSaturation:
            AToBxTag = icSigAToB2Tag;
            break;
        default:
            return FALSE;
            break;
    }
    if (DoesCPTagExist (cp, AToBxTag) &&
        GetCPTagIndex (cp, AToBxTag, (LPSINT) & Index))
    {
        Success = GetHostCSA(cp, lpBuffer, lpcbSize, Intent, Index, Type);
    }
    else if ((DoesTRCAndColorantTagExist(cp)) &&
            (Type == TYPE_CIEBASEDDEF))
    {
        Success = GetHostMatrixCSAorCRD(cp, lpBuffer, lpcbSize, TRUE);
    }

    return Success;
}
/***************************************************************************
*                            GetHostColorSpaceArray
*  function:
*    This is the main function which creates the Host CSA
*    from the data supplied in the Profile.
*  parameters:
*       cp          --  Color Profile handle
*       InputIntent --  Intent.
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/
static BOOL
GetHostColorSpaceArray (CHANDLE cp, DWORD InputIntent,
                       MEMPTR  lpBuffer, LPDWORD lpcbSize)
{
    CSIG ColorSpace, Intent;
    BOOL Success = FALSE;

    if (!cp)
        return Success;

    if (!GetCPDevSpace (cp, (LPCSIG) & ColorSpace) ||
        !GetCPRenderIntent (cp, (LPCSIG) & Intent))
    {
        return Success;
    }
    if (InputIntent == icUseRenderingIntent)
        InputIntent = (DWORD)Intent;

    if (!Success)
    {
        switch (ColorSpace)
        {
            case icSigRgbData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEF);
                break;
            case icSigCmykData:
                Success = GetHostCSA_Intent (cp, lpBuffer, lpcbSize,
                          (CSIG) InputIntent, TYPE_CIEBASEDDEFG);
                break;
            default:
                break;
        }
    }
    return Success;
}

//===========================================================================

/***************************************************************************
*                             CreateHostLutCRD
*  function:
*    this is the function which creates the Host CRD
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*       cp          --  Color Profile handle
*       Index       --  Index of the tag
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       InputIntent --  Intent.
*
*  returns:
*       SINT        --  Size of Host CRD.
***************************************************************************/

static SINT 
CreateHostLutCRD (CHANDLE cp, SINT Index, MEMPTR lpMem, DWORD InputIntent)
{
    SINT     nInputCh, nOutputCh, nGrids;
    SINT     nInputTable, nOutputTable, nNumbers;
    CSIG     Tag, PCS;
    CSIG     IntentSig;

    SINT     Ret;
    SINT     i, j;
    MEMPTR   lpTable;

    MEMPTR   Buff = NULL;
    SINT     MemSize = 0;
    MEMPTR   lpOldMem = lpMem;
    HGLOBAL  hMem;
    LPHOSTCLUT  lpHostClut;

    // Check if we can generate the CRD
    if (!GetCPTagSig (cp, Index, (LPCSIG) & IntentSig) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPConnSpace (cp, (LPCSIG) & PCS) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        if (NULL != Buff)
        {
            MemFree (hMem);
        }
        return (0);
    }

    GetCLUTinfo(Tag, Buff, &nInputCh, &nOutputCh, 
                &nGrids, &nInputTable, &nOutputTable, &i);

    if (((nOutputCh != 3) && (nOutputCh != 4)) ||
        (nInputCh != 3))
    {
        SetCPLastError (CP_POSTSCRIPT_ERR);
        MemFree (hMem);
        return (0);
    }

    // First Pass. This is a size request
    if (lpMem == NULL)       
    {
        Ret = nInputCh * nInputTable * i         +  // Input table 8/16-bits
            nOutputCh * nOutputTable * i         +  // Output table 8/16-bits
            nOutputCh * nGrids * nGrids * nGrids +  // CLUT 8-bits only
            sizeof(HOSTCLUT)                     +  // Data structure 
            1024;                                   // safe

        MemFree (hMem);
        return (Ret);
    }
	 
    // Second Pass. Get a HostCRD
    lpHostClut = (LPHOSTCLUT)lpMem;
    lpMem += sizeof(HOSTCLUT);
    lpHostClut->size = sizeof(HOSTCLUT);
    lpHostClut->pcs = PCS;
    lpHostClut->intent = InputIntent;
    lpHostClut->lutBits = (Tag == icSigLut8Type)? 8:16;

    GetCPWhitePoint (cp, (LPSFLOAT)lpHostClut->whitePoint);          // .. Illuminant

    // Support absolute whitePoint
    if (!GetCPMediaWhitePoint (cp, (LPSFLOAT)lpHostClut->mediaWP)) // .. Media WhitePoint
    {
        lpHostClut->mediaWP[0] = lpHostClut->whitePoint[0];
        lpHostClut->mediaWP[1] = lpHostClut->whitePoint[1];
        lpHostClut->mediaWP[2] = lpHostClut->whitePoint[2];
    }
    lpHostClut->inputChan = (unsigned char)nInputCh;
    lpHostClut->outputChan = (unsigned char)nOutputCh;
    lpHostClut->clutPoints = (unsigned char)nGrids;
    lpHostClut->inputEnt = (USHORT)nInputTable;
    lpHostClut->outputEnt = (USHORT)nOutputTable;

//******** Input array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->inputArray, 
             nInputCh, nInputTable, 0, Tag, Buff);
//******** the offset to the position of output array.
    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
//******** Output array
    lpMem += CreateHostInputOutputArray (lpMem, lpHostClut->outputArray, 
             nOutputCh, nOutputTable, i, Tag, Buff);
//******** Matrix.
    if (PCS == icSigXYZData)
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
        } else
        {
            lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
        }
        for (i = 0; i < 9; i++)
        {
            lpHostClut->e[i] = (float)((si16f16toSFLOAT (lpTable)) / CIEXYZRange);
            lpTable += sizeof (icS15Fixed16Number);
        }
    }
//********** RenderTable
    nNumbers = nGrids * nGrids * nOutputCh;
    lpHostClut->clut = lpMem;
    for (i = 0; i < nGrids; i++)        // Na strings should be sent
    {
        if (Tag == icSigLut8Type)
        {
            lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                nInputTable * nInputCh +
                nNumbers * i;
        } else
        {
            lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                2 * nInputTable * nInputCh +
                2 * nNumbers * i;
        }
        if (Tag == icSigLut8Type)
        {
            MemCopy(lpMem, lpTable, nNumbers);
            lpMem += nNumbers;
        }
        else
        {
            for (j = 0; j < nNumbers; j++)
            {
                *lpMem++ = (BYTE)(ui16toSINT (lpTable) / 256);
                lpTable += sizeof (icUInt16Number);
            }
        }
    }

    MemFree (hMem);
    return ((SINT) ((unsigned long) (lpMem - lpOldMem)));
}


/***************************************************************************
*                      GetHostColorRenderingDictionary
*  function:
*    this is the main function which creates the Host CRD
*  parameters:
*       cp          --  Color Profile handle
*       Intent      --  Intent.
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       lpcbSize    -- 	size of memory block.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/
static BOOL
GetHostColorRenderingDictionary (CHANDLE cp, DWORD Intent,
                                MEMPTR lpMem, LPDWORD lpcbSize)
{
    SINT Index;
    CSIG BToAxTag;

    if (!cp)
        return FALSE;

    if ((lpMem == NULL) || (*lpcbSize == 0))
    {
        lpMem = NULL;
        *lpcbSize = 0;
    }

    switch (Intent)
    {
        case icPerceptual:
            BToAxTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            // Use RelativeColorimetric to calculate this CRD.
            BToAxTag = icSigBToA1Tag;
            break;

        case icSaturation:
            BToAxTag = icSigBToA2Tag;
            break;

        default:
           *lpcbSize = (DWORD) 0;
            return FALSE;
    }

    if (DoesCPTagExist (cp, BToAxTag) &&
        GetCPTagIndex (cp, BToAxTag, (LPSINT) & Index))
    {
        *lpcbSize = CreateHostLutCRD (cp, Index, lpMem, Intent);
    }
    else if(DoesTRCAndColorantTagExist(cp))
    {
        GetHostMatrixCSAorCRD(cp, lpMem, lpcbSize, FALSE);
    }
    return (*lpcbSize > 0);
}

//========================================================================
/***************************************************************************
*                               g
*  function:
*    Calculate function y = g(x). used in Lab->XYZ conversion
*    y = g(x):      g(x) = x*x*x             if x >= 6/29
*                   g(x) = 108/841*(x-4/29)  otherwise
*  parameters:
*       f           --  x
*  returns:
*       SINT        --  y
***************************************************************************/

static float g(float f)
{
    float frc;
    if (f >= (6/29))
    {
        frc = f * f * f;
    }
    else
    {
        frc = f - (4.0f / 29.0f) * (108.0f / 841.0f);
    }
    return frc;
}

/***************************************************************************
*                          inverse_g
*  function:
*    Calculate inverse function y = g(x). used in XYZ->Lab conversion
*  parameters:
*       f           --  y
*  returns:
*       SINT        --  x
***************************************************************************/
static float inverse_g(float f)
{
    double frc;
    if (f >= (6.0*6.0*6.0)/(29.0*29.0*29.0))
    {
        frc = pow(f, 1.0 / 3.0);
    }
    else
    {
        frc = f * (841.0 / 108.0) + (4.0 / 29.0);
    }
    return (float)frc;
}

//========================================================================

static BOOL
TableInterp3(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpA, tmpBC;
    int    cellA, cellB, cellC;
    float  a, b, c;
    short  Grids;
    short  outputChan;
    MEMPTR v000, v001, v010, v011;
    MEMPTR v100, v101, v110, v111;
    float  vx0x, vx1x;
    float  v0xx, v1xx;
    int    idx;

    cellA = (int)(fTemp[0]);
    a = fTemp[0] - cellA;

    cellB = (int)(fTemp[1]);
    b = fTemp[1] - cellB;

    cellC = (int)(fTemp[2]);
    c = fTemp[2] - cellC;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpA  = outputChan * Grids * Grids; 
    tmpBC = outputChan * (Grids * cellB + cellC);

    // Calculate 8 surrounding cells.
    v000 = lpHostClut->clut + tmpA * cellA + tmpBC;
    v001 = (cellC < (Grids - 1))? v000 + outputChan : v000;
    v010 = (cellB < (Grids - 1))? v000 + outputChan * Grids : v000;
    v011 = (cellC < (Grids - 1))? v010 + outputChan : v010 ;

    v100 = (cellA < (Grids - 1))? v000 + tmpA : v000;
    v101 = (cellC < (Grids - 1))? v100 + outputChan : v100;
    v110 = (cellB < (Grids - 1))? v100 + outputChan * Grids : v100;
    v111 = (cellC < (Grids - 1))? v110 + outputChan : v110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 4 bottom cells.
        vx0x = *v000 + c * (int)((int)*v001 - (int)*v000);
        vx1x = *v010 + c * (int)((int)*v011 - (int)*v010);
        v0xx = vx0x + b * (vx1x - vx0x);

        // Calculate the average of 4 upper cells.
        vx0x = *v100 + c * (int)((int)*v101 - (int)*v100);
        vx1x = *v110 + c * (int)((int)*v111 - (int)*v110);
        v1xx = vx0x + b * (vx1x - vx0x);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xx + a * (v1xx - v0xx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v000++;
            v001++;
            v010++;
            v011++;
            v100++;
            v101++;
            v110++;
            v111++;
        }
    }

    return TRUE;
}

static BOOL
TableInterp4(LPHOSTCLUT lpHostClut, float far *fTemp)
{
    int    tmpH, tmpI, tmpJK;
    int    cellH, cellI, cellJ, cellK;
    float  h, i, j, k;
    short  Grids;
    short  outputChan;
    MEMPTR v0000, v0001, v0010, v0011;
    MEMPTR v0100, v0101, v0110, v0111;
    MEMPTR v1000, v1001, v1010, v1011;
    MEMPTR v1100, v1101, v1110, v1111;
    float  vxx0x, vxx1x;
    float  vx0xx, vx1xx;
    float  v0xxx, v1xxx;
    int    idx;

    cellH = (int)(fTemp[0]);
    h = fTemp[0] - cellH;

    cellI = (int)(fTemp[1]);
    i = fTemp[1] - cellI;

    cellJ = (int)(fTemp[2]);
    j = fTemp[2] - cellJ;

    cellK = (int)(fTemp[3]);
    k = fTemp[3] - cellK;

    Grids = lpHostClut->clutPoints;
    outputChan = lpHostClut->outputChan;
    tmpI  = outputChan * Grids * Grids;
    tmpH  = tmpI * Grids; 
    tmpJK = outputChan * (Grids * cellJ + cellK);

    // Calculate 16 surrounding cells.
    v0000 = lpHostClut->clut + tmpH * cellH + tmpI * cellI + tmpJK;
    v0001 = (cellK < (Grids - 1))? v0000 + outputChan : v0000;
    v0010 = (cellJ < (Grids - 1))? v0000 + outputChan * Grids : v0000;
    v0011 = (cellK < (Grids - 1))? v0010 + outputChan : v0010;

    v0100 = (cellI < (Grids - 1))? v0000 + tmpI : v0000;
    v0101 = (cellK < (Grids - 1))? v0100 + outputChan : v0100;
    v0110 = (cellJ < (Grids - 1))? v0100 + outputChan * Grids : v0100;
    v0111 = (cellK < (Grids - 1))? v0110 + outputChan : v0110;

    v1000 = (cellH < (Grids - 1))? v0000 + tmpH : v0000;
    v1001 = (cellK < (Grids - 1))? v1000 + outputChan : v1000;
    v1010 = (cellJ < (Grids - 1))? v1000 + outputChan * Grids : v1000;
    v1011 = (cellK < (Grids - 1))? v1010 + outputChan : v1010;

    v1100 = (cellI < (Grids - 1))? v1000 + tmpI : v1000;
    v1101 = (cellK < (Grids - 1))? v1100 + outputChan : v1100;
    v1110 = (cellJ < (Grids - 1))? v1100 + outputChan * Grids : v1100;
    v1111 = (cellK < (Grids - 1))? v1110 + outputChan : v1110;

    for (idx = 0; idx < outputChan; idx++)
    {
        // Calculate the average of 8 bottom cells.
        vxx0x = *v0000 + k * (int)((int)*v0001 - (int)*v0000);
        vxx1x = *v0010 + k * (int)((int)*v0011 - (int)*v0010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v0100 + k * (int)((int)*v0101 - (int)*v0100);
        vxx1x = *v0110 + k * (int)((int)*v0111 - (int)*v0110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v0xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the average of 8 upper cells.
        vxx0x = *v1000 + k * (int)((int)*v1001 - (int)*v1000);
        vxx1x = *v1010 + k * (int)((int)*v1011 - (int)*v1010);
        vx0xx = vxx0x + j * (vxx1x - vxx0x);
        vxx0x = *v1100 + k * (int)((int)*v1101 - (int)*v1100);
        vxx1x = *v1110 + k * (int)((int)*v1111 - (int)*v1110);
        vx1xx = vxx0x + j * (vxx1x - vxx0x);
        v1xxx = vx0xx + i * (vx1xx - vx0xx);

        // Calculate the bottom and upper average.
        fTemp[idx] = (v0xxx + h * (v1xxx - v0xxx)) / MAXCOLOR8;

        if ( idx < (outputChan - 1))
        {
            v0000++;
            v0001++;
            v0010++;
            v0011++;
            v0100++;
            v0101++;
            v0110++;
            v0111++;
            v1000++;
            v1001++;
            v1010++;
            v1011++;
            v1100++;
            v1101++;
            v1110++;
            v1111++;
        }
    }

    return TRUE;
}


/***************************************************************************
*                         CheckColorLookupTable
*  function:
*    This function check RenderTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input (in range [0 gred-1]) /
*                                 output(in range [0 1)
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
CheckColorLookupTable(LPHOSTCLUT lpHostClut, float far *fTemp) 
{
    if (lpHostClut->inputChan == 3)
    {
        TableInterp3(lpHostClut, fTemp);
    }
    else if(lpHostClut->inputChan == 4)
    {
        TableInterp4(lpHostClut, fTemp);
    }
    return TRUE;
}

/***************************************************************************
*                         CheckInputOutputTable
*  function:
*    This function check inputTable.
*  parameters:
*       LPHOSTCLUT lpHostClut -- 
*       float far  *fTemp     --  Input / output data
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
CheckInputOutputTable(LPHOSTCLUT lpHostClut, float far *fTemp, 
                      BOOL bCSA, BOOL bInputTable) 
{
    int     i;
    short   Grids;
    USHORT  floor1, ceiling1;
    float   fIndex;
    int     numChan;
    int     numEnt;
    PMEMPTR ppArray;

    if (bInputTable)
    {
        numChan = lpHostClut->inputChan;
        numEnt = lpHostClut->inputEnt - 1;
        ppArray = lpHostClut->inputArray;
    }
    else
    {
        numChan = lpHostClut->outputChan;
        numEnt = lpHostClut->outputEnt - 1;
        ppArray = lpHostClut->outputArray;
    }

    Grids = lpHostClut->clutPoints;
    for (i = 0; (i <= MAXCHANNELS) && (i < numChan); i++)
    {
        fTemp[i] = (fTemp[i] < 0)? 0: ((fTemp[i] > 1)? 1: fTemp[i]);
        fIndex = fTemp[i] * numEnt;
        if (lpHostClut->lutBits == 8)
        {
            floor1 = ppArray[i][(int)fIndex];
            ceiling1 = ppArray[i][((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 127.0);
            else
                fTemp[i] = (float)(fTemp[i] / 255.0);
        }
        else
        {
            floor1 = ((PUSHORT)(ppArray[i]))[(int)fIndex];
            ceiling1 = ((PUSHORT)(ppArray[i]))[((int)fIndex) + 1];
            fTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));
            if (bCSA && !bInputTable)
                fTemp[i] = (float)(fTemp[i] / 32767.0);
            else
                fTemp[i] = (float)(fTemp[i] / 65535.0);

        }
        if (bInputTable)
        {
            fTemp[i] *= (Grids - 1);
            if (fTemp[i] > (Grids - 1))
                fTemp[i] = (float)(Grids - 1);
        }
    }
    return TRUE;
}

static void
LabToXYZ(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = (Input[0] * 50 + 16) / 116;
    fa = (Input[1] * 128 - 128) / 500;
    fb = (Input[2] * 128 - 128) / 200;
    Output[0] = whitePoint[0] * g(fL + fa);
    Output[1] = whitePoint[1] * g(fL);
    Output[2] = whitePoint[2] * g(fL - fb);
}

static void
XYZToLab(float far *Input, float far *Output, float far *whitePoint)
{
    float   fL, fa, fb;

    fL = inverse_g(Input[0] / whitePoint[0]);
    fa = inverse_g(Input[1] / whitePoint[1]);
    fb = inverse_g(Input[2] / whitePoint[2]);
    Output[0] = (fa * 116 - 16) / 100;
    Output[1] = (fL * 500 - fa * 500 + 128) / 255;
    Output[2] = (fa * 200 - fb * 200 + 128) / 255;
}

static void
ApplyMatrix(PFLOAT e, float far *Input, float far *Output)
{
    SINT  i, j;

    for (i = 0; i < 3; i++)
    {
        j = i*3;
        Output[i] = e[j ]    * Input[0] +
                    e[j + 1] * Input[1] +
                    e[j + 2] * Input[2];
    }
}

/***************************************************************************
*                         DoHostConversionCRD
*  function:
*    This function converts XYZ/Lab to RGB/CMYK by using HostCRD
*  parameters:
*       LPHOSTCLUT lpHostCRD  -- pointer to a HostCRD
*       LPHOSTCLUT lpHostCSA  -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/
static BOOL
DoHostConversionCRD (LPHOSTCLUT lpHostCRD, LPHOSTCLUT lpHostCSA,
                     float far *Input, float far *Output,
                     CSIG ColorSpace, BOOL bCheckOutputTable)
{
    float   fTemp[MAXCHANNELS];
    float   fTemp1[MAXCHANNELS];
    int     i;

/**
** Input XYZ or Lab in range [0 2]
***/
    // When sampling the deviceCRD, skip the input table.
    // If lpHostCSA is not NULL, the current CRD is targetCRD, we
    // need to do input table conversion
    if (lpHostCSA)
    {
        // Convert Lab to XYZ  in range [ 0 whitePoint ]
        if ((lpHostCRD->pcs == icSigXYZData) && 
            (lpHostCSA->pcs == icSigLabData))
        {
            LabToXYZ(Input, fTemp1, lpHostCRD->whitePoint);
        }
        // Convert XYZ to Lab in range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigXYZData))
        {
            XYZToLab(Input, fTemp, lpHostCSA->whitePoint);
        }
        // Convert Lab to range [ 0 1]
        else if ((lpHostCRD->pcs == icSigLabData) && 
                 (lpHostCSA->pcs == icSigLabData))
        {
            for (i = 0; i < 3; i++)
                fTemp[i] = Input[i] / 2;
        }
        // Convert XYZ to XYZ (based on white point) to range [0 1]
        else
        {   // TODO: different intents using different conversion.
            // icRelativeColorimetric: using Bradford transform.
            // icAbsoluteColorimetric: using scaling.
            for (i = 0; i < 3; i++)
                fTemp1[i] = Input[i] * lpHostCRD->whitePoint[i] / lpHostCSA->whitePoint[i];
        }
 
        // Matrix, used for XYZ data only or Matrix icc profile only
        if (lpHostCRD->pcs == icSigXYZData)
        {
            ApplyMatrix(lpHostCRD->e, fTemp1, fTemp);
        }
     
        if (lpHostCRD->dataType != DATA_matrix)
        {
            //Search input Table
            CheckInputOutputTable(lpHostCRD, fTemp, 0, 1);
        }
    }
    // If the current CRD is device CRD, we do not need to do input
    // table conversion.
    else
    {
        short   Grids;
    	Grids = lpHostCRD->clutPoints;
        // Sample data may be XYZ or Lab. It depends on Target icc profile.
        // If the PCS of the target icc profile is XYZ, input data will be XYZ.
        // If the PCS of the target icc profile is Lab, input data will be Lab.

        if (lpHostCRD->dataType == DATA_matrix)
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i];
            }
        }
        else
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = Input[i]* (Grids - 1);
                if (fTemp[i] > (Grids - 1))
                    fTemp[i] = (float)(Grids - 1);
            }
        }
    }   // bCheckInputTable

    if (lpHostCRD->dataType != DATA_matrix)
    {
        // Rendering table
        CheckColorLookupTable(lpHostCRD, fTemp);

        /**
         ** Output RGB or CMYK in range [0 1]
        ***/
    }
    if (bCheckOutputTable)
    {
        //Output Table
        CheckInputOutputTable(lpHostCRD, fTemp, 0, 0);
    }
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostCRD->outputChan); i++)
    {
        Output[i] = fTemp[i];
    }

   return TRUE;
}

/***************************************************************************
*                         DoHostConversionCSA
*  function:
*    This function converts RGB/CMYK to XYZ/Lab by using HostCSA
*  parameters:
*       LPHOSTCLUT lpHostCLUT -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

static BOOL
DoHostConversionCSA (LPHOSTCLUT lpHostClut, float far *Input, float far *Output)
{
    float   fTemp[MAXCHANNELS];
    int     i;

/**
** Input RGB or CMYK in range [0 1]
***/
    for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->inputChan); i++)
    {
        fTemp[i] = Input[i];
    }

    if (lpHostClut->dataType == DATA_matrix)
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);
        ApplyMatrix(lpHostClut->e, fTemp, Output);
    }
    else
    {
        //Search input Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 1);

        // Rendering table
        CheckColorLookupTable(lpHostClut, fTemp);

        //Output Table
        CheckInputOutputTable(lpHostClut, fTemp, 1, 0 );

        /**
         ** Output XYZ or Lab in range [0 2]
         ***/
        for (i = 0; (i <= MAXCHANNELS) && (i < lpHostClut->outputChan); i++)
        {
            Output[i] = fTemp[i];
        }
    }

    return TRUE;
}				

static BOOL
GetCRDInputOutputArraySize(CHANDLE cp, DWORD Intent, 
    LPSINT lpInTbSize, LPSINT lpOutTbSize, 
    LPCSIG lpIntentTag, LPSINT lpGrids)
{
    CSIG    Tag;
    SINT    Index;
    SINT    Ret = 0;
    MEMPTR  Buff = NULL;
    SINT    MemSize = 0;
    HGLOBAL hMem;
    SINT    outputChan, outputEnt;
    SINT    inputChan, inputEnt;
    SINT    Grids;
    SINT    i;

    switch (Intent)
    {
        case icPerceptual:
            *lpIntentTag = icSigBToA0Tag;
            break;

        case icRelativeColorimetric:
        case icAbsoluteColorimetric:
            *lpIntentTag = icSigBToA1Tag;
            break;

        case icSaturation:
            *lpIntentTag = icSigBToA2Tag;
            break;

        default:
            return FALSE;
    }
    if (!DoesCPTagExist (cp, *lpIntentTag) ||
        !GetCPTagIndex (cp, *lpIntentTag, (LPSINT) & Index) ||
        !GetCPElementType (cp, Index, (LPCSIG) & Tag) ||
        ((Tag != icSigLut8Type) && (Tag != icSigLut16Type)) ||
        !GetCPElementSize (cp, Index, (LPSINT) & MemSize) ||
        !MemAlloc (MemSize, (HGLOBAL FAR *)&hMem, (LPMEMPTR) & Buff) ||
        !GetCPElement (cp, Index, Buff, MemSize))
    {
        BOOL retVal = FALSE;

        if (NULL != Buff)
        {
            MemFree (hMem);
        }

        // Matrix icc profile.

        *lpGrids = 2;
        if (lpInTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpInTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpInTbSize = *lpInTbSize * 3;
        }
        if (lpOutTbSize)
        {
            retVal = GetHostCSA_Intent (cp, NULL, lpOutTbSize,
                          (CSIG) Intent, TYPE_CIEBASEDDEF);
            *lpOutTbSize = *lpOutTbSize * 3;
        }
        return retVal;
    }

    if (lpInTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if (inputChan != 3)
        {
            MemFree (hMem);
            return FALSE;
        }

        *lpInTbSize = inputChan * inputEnt * 6;  // Number of INT bytes
        *lpGrids = Grids;
    }

    if (lpOutTbSize)
    {
        GetCLUTinfo(Tag, Buff, &inputChan, &outputChan, 
                &Grids, &inputEnt, &outputEnt, &i);

        if ((outputChan != 3) && (outputChan != 4))
        {
            MemFree (hMem);
            return FALSE;
        }
        *lpOutTbSize = outputChan * outputEnt * 6; // Number of INT bytes
        *lpGrids = Grids;
    }

    MemFree (hMem);
    return TRUE;
}

/***************************************************************************
*                         CreateOutputArray
*  function:
*       Create CSA/CRD output arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to a buffer which will contain the arrays. 
*       SINT    nOutputCh    -- Number of output channel. if lpHostClut, no meaning.
*       SINT    nOutputTable -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contain LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of output array created.
***************************************************************************/

SINT
CreateOutputArray (MEMPTR lpMem, SINT nOutputCh, 
    SINT nOutputTable, SINT Offset, MEMPTR Intent, 
    CSIG Tag, MEMPTR Buff, BOOL AllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nOutputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->outputChan);
        nOutputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->outputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
              icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nOutputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);
        
        if (lpHostClut)
            lpTable = ((LPHOSTCLUT)lpHostClut)->outputArray[i];
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) +
                    Offset +
                    nOutputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) +
                    2 * Offset +
                    2 * nOutputTable * i;
        }

        if (!AllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable, lpLineStart, nOutputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nOutputTable; j++)
                {
                    if (lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nOutputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nOutputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nOutputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

/***************************************************************************
*                         CreateInputArray
*  function:
*       Create CSA/CRD Input arrays from the data supplied in icc profile's
*       LUT8 or LUT16 tags.
*  parameters:
*       MEMPTR  lpMem        -- a pointer to the buffer which will contain the arrays.
*       SINT    nInputCh     -- Number of input channel. if lpHostClut, no meaning.
*       SINT    nInputTable  -- saze of each array.  if lpHostClut, no meaning.
*       SINT    Offset       -- offset of Buff, point to the 1st byte of output array in CLUT.
*                               if lpHostClut, no meaning.
*       MEMPTR  Intent       -- 
*       CSIG    Tag          -- LUT8 or LUT16
*       MEMPTR  Buff         -- point to a buffer which contains LUT8 or LUT16.
*                               if NULL, use lpHostClut.
*       BOOL    AllowBinary  --
*       MEMPTR  lpHostClut   -- point to host CSA/CRD. if NULL, use Buff.
*  returns:
*       SINT                 -- The size of inpput array created.
***************************************************************************/

SINT
CreateInputArray (MEMPTR lpMem, SINT nInputCh, 
    SINT nInputTable, MEMPTR Intent, CSIG Tag, 
    MEMPTR Buff, BOOL bAllowBinary, MEMPTR lpHostClut)
{
    SINT i, j;
    MEMPTR lpOldMem;
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

    if (lpHostClut)
    {
        nInputCh = (SINT)(((LPHOSTCLUT)lpHostClut)->inputChan);
        nInputTable = (SINT)(((LPHOSTCLUT)lpHostClut)->inputEnt);
        Tag = (((LPHOSTCLUT)lpHostClut)->lutBits == 8)? 
               icSigLut8Type : icSigLut16Type;
    }

    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, Slash);
        if (lpHostClut)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, Intent, lstrlen (Intent));
        lpMem += WriteInt (lpMem, i);

        if (lpHostClut)
        {
            lpTable = ((LPHOSTCLUT)lpHostClut)->inputArray[i];
        }
        else
        {
            if (Tag == icSigLut8Type)
                lpTable = (MEMPTR) (((lpcpLut8Type) Buff)->lut.data) + nInputTable * i;
            else
                lpTable = (MEMPTR) (((lpcpLut16Type) Buff)->lut.data) + 2 * nInputTable * i;
        }
        if (!bAllowBinary)               // Output ASCII CRD
        {
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, BeginString);
                lpMem += WriteHexBuffer (lpMem, lpTable,lpLineStart, nInputTable);
                lpMem += WriteObject (lpMem, EndString);
            } else
            {
                lpMem += WriteObject (lpMem, BeginArray);
                for (j = 0; j < nInputTable; j++)
                {
                    if(lpHostClut)
                        lpMem += WriteInt (lpMem, *((PUSHORT)lpTable));
                    else
                        lpMem += WriteInt (lpMem, ui16toSINT (lpTable));
                    lpTable += sizeof (icUInt16Number);
                    if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                    {
                        lpLineStart = lpMem;
                        lpMem += WriteObject (lpMem, NewLine);
                    }
                }
                lpMem += WriteObject (lpMem, EndArray);
            }
        } else
        {                               // Output BINARY CRD
            if (Tag == icSigLut8Type)
            {
                lpMem += WriteStringToken (lpMem, 143, 256);
                lpMem += WriteByteString (lpMem, lpTable, 256L);
            } else
            {
                lpMem += WriteHNAToken (lpMem, 149, nInputTable);
                if (lpHostClut)
                    lpMem += WriteIntStringU2S_L (lpMem, lpTable, nInputTable);
                else
                    lpMem += WriteIntStringU2S (lpMem, lpTable, nInputTable);
            }
        }
        lpMem += WriteObject (lpMem, DefOp);
    }

    return ((SINT) (lpMem - lpOldMem));
}

SINT
SendCRDLMN(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint, LPSFLOAT mediaWP, CSIG pcs)
{
    MEMPTR  lpOldMem;
    SINT    i, j;

    lpOldMem = lpMem;

//********** /MatrixLMN
    if (icAbsoluteColorimetric == Intent)
    {
        lpMem += WriteNewLineObject (lpMem, MatrixLMNTag);

        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 3; j++)
                lpMem += WriteFloat (lpMem,
                    (double) (i == j) ? whitePoint[i] / mediaWP[i] : 0.0);
        }
        lpMem += WriteObject (lpMem, EndArray);
    }
 //********** /RangeLMN
    lpMem += WriteNewLineObject (lpMem, RangeLMNTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double) whitePoint[i]);
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, RangeLMNLab);
    }

 //********** /EncodeLMN
    lpMem += WriteNewLineObject (lpMem, EncodeLMNTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        if (pcs != icSigXYZData)
        {
            lpMem += WriteFloat (lpMem, (double)whitePoint[i]);
            lpMem += WriteObject (lpMem, DivOp);
            lpMem += WriteObject (lpMem, EncodeLMNLab);
        }
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);

    return (SINT)(lpMem - lpOldMem);
}


SINT
SendCRDPQR(MEMPTR lpMem, CSIG Intent, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    if (icAbsoluteColorimetric != Intent)
    {
     //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, RangePQR);

     //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, MatrixPQR);
    }
    else
    {
    //********** /RangePQR
        lpMem += WriteNewLineObject (lpMem, RangePQRTag);
        lpMem += WriteObject (lpMem, BeginArray);
        for (i = 0; i < 3; i++)
        {
            lpMem += WriteFloat (lpMem, (double) 0);
            lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
        }
        lpMem += WriteObject (lpMem, EndArray);
    //********** /MatrixPQR
        lpMem += WriteNewLineObject (lpMem, MatrixPQRTag);
        lpMem += WriteObject (lpMem, Identity);
    }
//********** /TransformPQR
    lpMem += WriteNewLineObject (lpMem, TransformPQRTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem,
            (icAbsoluteColorimetric != Intent) ? TransformPQR[i] : NullOp);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
   
    return (SINT)(lpMem - lpOldMem);
} 

SINT
SendCRDABC(MEMPTR lpMem, MEMPTR PublicArrayName, CSIG pcs, SINT nInputCh,
           MEMPTR Buff, LPSFLOAT e, CSIG LutTag, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i, j;
    double TempMatrixABC[9];
    MEMPTR lpTable;
    MEMPTR lpLineStart;
    lpOldMem = lpMem;

 //********** /RangeABC
    lpMem += WriteNewLineObject (lpMem, RangeABCTag);
    lpMem += WriteObject (lpMem, RangeABC);
 //********** /MatrixABC
    lpMem += WriteNewLineObject (lpMem, MatrixABCTag);
    if (pcs == icSigXYZData)
    {
        lpMem += WriteObject (lpMem, BeginArray);
        if (e)
        {
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, e[i + j * 3]);
                }
            }
        }
        else
        {
            if (LutTag == icSigLut8Type)
            {
                lpTable = (MEMPTR) & ((lpcpLut8Type) Buff)->lut.e00;
            } else
            {
                lpTable = (MEMPTR) & ((lpcpLut16Type) Buff)->lut.e00;
            }
            for (i = 0; i < 9; i++)
            {
                TempMatrixABC[i] = ((double) si16f16toSFLOAT (lpTable)) / CIEXYZRange;
                lpTable += sizeof (icS15Fixed16Number);
            }
            for (i = 0; i < 3; i++)
            {
                for (j = 0; j < 3; j++)
                {
                    lpMem += WriteFloat (lpMem, TempMatrixABC[i + j * 3]);
                }
            }
        }
        lpMem += WriteObject (lpMem, EndArray);
    } else
    {
        lpMem += WriteObject (lpMem, MatrixABCLabCRD);
    }
 //********** /EncodeABC
    if (nInputCh == 0)
        return (SINT)(lpMem - lpOldMem);

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, EncodeABCTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < nInputCh; i++)
    {
        lpLineStart = lpMem;
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        if (pcs == icSigLabData)
        {
            lpMem += WriteObject (lpMem,
                                  (0 == i) ? EncodeABCLab1 : EncodeABCLab2);
        }
        lpMem += WriteObject (lpMem, StartClip);
        if (e)
            lpMem += WriteObject (lpMem, PreViewInArray);
        else
            lpMem += WriteObject (lpMem, InputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)              // Output ASCII CRD
        {
            lpMem += WriteNewLineObject (lpMem, IndexArray);
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, IndexArray);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
            }
        }
        lpMem += WriteObject (lpMem, (LutTag == icSigLut8Type) ? 
                              Scale8 : Scale16);
        lpMem += WriteObject (lpMem, EndClip);
        lpMem += WriteObject (lpMem, EndFunction);
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT
SendCRDBWPoint(MEMPTR lpMem, LPSFLOAT whitePoint)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

//********** /BlackPoint
    lpMem += WriteNewLineObject (lpMem, BlackPointTag);
    lpMem += WriteObject (lpMem, BlackPoint);

//********** /WhitePoint
    lpMem += WriteNewLineObject (lpMem, WhitePointTag);
    lpMem += WriteObject (lpMem, BeginArray);
    for (i = 0; i < 3; i++)
    {
        lpMem += WriteFloat (lpMem, (double)(whitePoint[i]));
    }
    lpMem += WriteObject (lpMem, EndArray);
    return (SINT)(lpMem - lpOldMem);
}

SINT SendCRDOutputTable(MEMPTR lpMem, MEMPTR PublicArrayName, 
        SINT nOutputCh, CSIG LutTag, BOOL bHost, BOOL bAllowBinary)
{
    MEMPTR  lpOldMem;
    SINT    i;

    lpOldMem = lpMem;

    for (i = 0; i < nOutputCh; i++)
    {
        lpMem += WriteNewLineObject (lpMem, BeginFunction);
        lpMem += WriteObject (lpMem, Clip01);
        if (bHost)
            lpMem += WriteObject (lpMem, PreViewOutArray);
        else
            lpMem += WriteObject (lpMem, OutputArray);
        lpMem += WriteObjectN (lpMem, (MEMPTR) PublicArrayName, lstrlen (PublicArrayName));
        lpMem += WriteInt (lpMem, i);

        if (!bAllowBinary)               // Output ASCII CRD
        {
            lpMem += WriteObject (lpMem, NewLine);
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray);
                lpMem += WriteObject (lpMem, Scale16);
            }
        } else
        {                               // Output BINARY CRD
            if (LutTag == icSigLut8Type)
            {
                lpMem += WriteObject (lpMem, TFunction8);
            } else
            {
                lpMem += WriteObject (lpMem, IndexArray16b);
                lpMem += WriteObject (lpMem, Scale16);
            }
        }

        lpMem += WriteObject (lpMem, EndFunction);
    }
    return (SINT)(lpMem - lpOldMem);
}

//========================================================================
/***************************************************************************
*                  GetPS2PreviewColorRenderingDictionary
*  function:
*    This is the main function that creates proofing CRD.
*    It does the following:
*       1) Creates host TargetCRD, TargetCSA and DevCRD.
*       2) Create proofing CRD by sampling TargetCRD TargetCSA and DevCRD.
*       3) Uses TargetCRD's input table as proofingCRD's input table.
*       4) Uses DevCRD's output table as proofingCRD's output table.
*       5) Sample data is XYZ or Lab, depends on PCS of TargetCRD.
*
*  parameters:
*       CHANDLE  cpDev        -- handle to Target icc profile.
*       CHANDLE  cpTarget     -- handle to Dev icc profile.
*       DWORD    Intent       -- intent 
*       MEMPTR   lpMem        -- pointer to buffer for proofCRD,
*                                NULL means query buffer size.
*       LPDWORD  lpcbSize     -- as input: current buffer size
*                             -- as output: real proofCRD size.
*       BOOL     bAllowBinary -- create a ascii or binary proofCRD.
*
*  returns:
*       BOOL                  -- TRUE/FALSE
***************************************************************************/

BOOL EXTERN
GetPS2PreviewColorRenderingDictionary (CHANDLE cpDev,
                                CHANDLE cpTarget,
                                DWORD Intent,
                                MEMPTR lpMem,
                                LPDWORD lpcbSize,
                                BOOL bAllowBinary)
{
    MEMPTR    lpTargetCRD, lpTargetCSA, lpDevCRD;
    DWORD     cbTargetCRD, cbTargetCSA, cbDevCRD;
    HGLOBAL   hTargetCRD, hTargetCSA, hDevCRD;
    BOOL      Success = FALSE;
    float     Input[MAXCHANNELS];
    float     Output[MAXCHANNELS];
    float     Temp[MAXCHANNELS];
    int       i, j, k, l;
    MEMPTR    lpLineStart;
    MEMPTR    lpOldMem;
    CSIG      ColorSpace;
    CSIG      DevColorSpace;
    static CSIG      IntentTag;
    static SINT      PreviewCRDGrid;
    SINT      OutArraySize, InArraySize;
    char      PublicArrayName[TempBfSize];
    SINT      TargetGrids, DevGrids;

    // First pass, return the size of Previewind CRD.
    if (lpMem == NULL)
    {
        SINT   dwOutArraySizr = 0;

        i = 3;      // Default output channal;
        if ((GetCPDevSpace (cpDev, (LPCSIG) & DevColorSpace)) &&
                          (DevColorSpace == icSigCmykData))
        {
            i = 4;
        }

        // Get the input array size IntentTag and Grid of the Target icc profile.
        if (!GetCRDInputOutputArraySize(cpTarget, Intent,
            &InArraySize, NULL, &IntentTag, &TargetGrids ))
            return FALSE;

        // Get the output array size IntentTag and Grid of the Dev icc profile.
        if (!GetCRDInputOutputArraySize(cpDev, Intent,
            NULL, &OutArraySize, &IntentTag, &DevGrids ))
            return FALSE;

        PreviewCRDGrid = (TargetGrids > DevGrids)? TargetGrids: DevGrids;

        // Min proofing CRD grid will be PREVIEWCRDGRID
        if (PreviewCRDGrid < PREVIEWCRDGRID)
            PreviewCRDGrid = PREVIEWCRDGRID;
        *lpcbSize = PreviewCRDGrid * PreviewCRDGrid * PreviewCRDGrid * 
                    i * 2 +           // CLUT size (Hex output)
                    OutArraySize +    // Output Array size
                    InArraySize  +    // Input Array size
                    4096;             // Extra PostScript staff.
         return (TRUE);
    }

    // Second pass, return the Previewind CRD.
    lpOldMem = lpMem;

    //Query the sizes of Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, NULL, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, NULL, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, NULL, &cbDevCRD)))
    {
        return (Success);
    }

    //Alloc the buffers for Host TargetCRD, TargetCSA and DevCRD.
    hTargetCRD = hTargetCSA = hDevCRD = 0;
    if (!MemAlloc (cbTargetCRD, (HGLOBAL FAR *)&hTargetCRD, (LPMEMPTR)&lpTargetCRD) ||
        !MemAlloc (cbTargetCSA, (HGLOBAL FAR *)&hTargetCSA, (LPMEMPTR)&lpTargetCSA) ||
        !MemAlloc (cbDevCRD, (HGLOBAL FAR *)&hDevCRD, (LPMEMPTR)&lpDevCRD))
    {
        goto Done;
    }

    //Build Host TargetCRD, TargetCSA and DevCRD.
    if (!(GetHostColorRenderingDictionary (cpTarget, Intent, lpTargetCRD, &cbTargetCRD)) ||
        !(GetHostColorSpaceArray (cpTarget, Intent, lpTargetCSA, &cbTargetCSA)) ||
        !(GetHostColorRenderingDictionary (cpDev, Intent, lpDevCRD, &cbDevCRD)))
    {
        goto Done;
    }

//  Build Proofing CRD based on Host TargetCRD TargetCSA and DevCRD.
//  We use TargetCRD input tables and matrix as the
//  input tables and matrix of the ProofCRD.
//  We use DevCRD output tables as the output tables of the ProofCRD.

//******** Define golbal array used in EncodeABC and RenderTaber
    GetPublicArrayName (cpDev, IntentTag, PublicArrayName);
    lpMem += WriteNewLineObject (lpMem, CRDBegin);

    lpMem += EnableGlobalDict(lpMem);
    lpMem += BeginGlobalDict(lpMem);

    lpMem += CreateInputArray (lpMem, (SINT)0, (SINT)0, (MEMPTR)PublicArrayName, 
             (CSIG)0, NULL, bAllowBinary, lpTargetCRD);

    lpMem += CreateOutputArray (lpMem, (SINT)0, (SINT)0, (SINT)0, 
             (MEMPTR)PublicArrayName, (CSIG)0, NULL, bAllowBinary, lpDevCRD);

    lpMem += EndGlobalDict(lpMem);

//************* Start writing  CRD  ****************************
    lpMem += WriteNewLineObject (lpMem, BeginDict);    // Begin dictionary
    lpMem += WriteObject (lpMem, DictType); // Dictionary type

//********** Send Black/White Point.
    lpMem += SendCRDBWPoint(lpMem, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send PQR - For White Point correction
    lpMem += SendCRDPQR(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint);

//********** Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    lpMem += SendCRDLMN(lpMem, Intent, 
        ((LPHOSTCLUT)lpTargetCRD)->whitePoint,
        ((LPHOSTCLUT)lpTargetCRD)->mediaWP,
        ((LPHOSTCLUT)lpTargetCRD)->pcs);

//********** Create MatrixABC and  EncodeABC  stuff
    lpMem += SendCRDABC(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpTargetCRD)->pcs,
        ((LPHOSTCLUT)lpTargetCRD)->inputChan,
        NULL,
        ((LPHOSTCLUT)lpTargetCRD)->e,
        (((LPHOSTCLUT)lpTargetCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        bAllowBinary);

//********** /RenderTable
    lpMem += WriteNewLineObject (lpMem, RenderTableTag);
    lpMem += WriteObject (lpMem, BeginArray);

    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Na
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nb
    lpMem += WriteInt (lpMem, PreviewCRDGrid);  // Send down Nc

    lpLineStart = lpMem;
    lpMem += WriteNewLineObject (lpMem, BeginArray);
    ColorSpace = ((LPHOSTCLUT)lpDevCRD)->pcs;
    for (i = 0; i < PreviewCRDGrid; i++)        // Na strings should be sent
    {
        lpMem += WriteObject (lpMem, NewLine);
        lpLineStart = lpMem;
        if (bAllowBinary)
        {
            lpMem += WriteStringToken (lpMem, 143, 
                PreviewCRDGrid * PreviewCRDGrid * ((LPHOSTCLUT)lpDevCRD)->outputChan);
        }
        else
        {
            lpMem += WriteObject (lpMem, BeginString);
        }
        Input[0] = ((float)i) / (PreviewCRDGrid - 1);
        for (j = 0; j < PreviewCRDGrid; j++)
        {
            Input[1] = ((float)j) / (PreviewCRDGrid - 1);
            for (k = 0; k < PreviewCRDGrid; k++)
            {
                Input[2] = ((float)k) / (PreviewCRDGrid - 1);

                DoHostConversionCRD ((LPHOSTCLUT)lpTargetCRD, NULL, Input, Output, ColorSpace, 1);
                DoHostConversionCSA ((LPHOSTCLUT)lpTargetCSA, Output, Temp);
                DoHostConversionCRD ((LPHOSTCLUT)lpDevCRD, (LPHOSTCLUT)lpTargetCSA, 
                                     Temp, Output, 0, 0);
                for (l = 0; l < ((LPHOSTCLUT)lpDevCRD)->outputChan; l++)
                {
                    if (bAllowBinary)
                    {
                        *lpMem++ = (BYTES)(Output[l]*255);
                    }
                    else
                    {
                        lpMem += WriteHex (lpMem, (USHORT)(Output[l]*255));
                        if (((SINT) (lpMem - lpLineStart)) > MAX_LINELENG)
                        {
                            lpLineStart = lpMem;
                            lpMem += WriteObject (lpMem, NewLine);
                        }
                    }
                }
            }
        }
        if (!bAllowBinary)
            lpMem += WriteObject (lpMem, EndString);
    }
    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteInt (lpMem, ((LPHOSTCLUT)lpDevCRD)->outputChan);

//********** Send Output Table.
    lpMem += SendCRDOutputTable(lpMem, PublicArrayName, 
        ((LPHOSTCLUT)lpDevCRD)->outputChan,
        (((LPHOSTCLUT)lpDevCRD)->lutBits == 8)? icSigLut8Type:icSigLut16Type,
        TRUE,
        bAllowBinary);


    lpMem += WriteNewLineObject (lpMem, EndArray);
    lpMem += WriteObject (lpMem, EndDict); // End dictionary definition
    lpMem += WriteNewLineObject (lpMem, CRDEnd);
    Success = TRUE;

Done:
    *lpcbSize = (DWORD)(lpMem - lpOldMem);

    if (hTargetCRD)
         MemFree(hTargetCRD);
    if (hTargetCSA)
         MemFree(hTargetCSA);
    if (hDevCRD)
         MemFree(hDevCRD);
    return (Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\control.c ===
#include "generic.h"

#pragma optimize("",off)

/***************************************************************************
*                               CreateINTENTControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void CreateINTENTControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateINTENTControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingIntent(cp, Intent, NULL, &cbSize);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingIntent(cp, Intent, lpBuffer, &cbSize);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No PS2 Intent created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateCRDControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2ColorRenderingDictionary(cp, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2ColorRenderingDictionary(cp, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               CreateCRDControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
CreateProfCRDControl(
    LPSTR       DevProfile,
    LPSTR       TargetProfile,
    LPSTR       SaveFileName,
    DWORD       Inter_Intent,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cpDev, cpTar;
    HGLOBAL     hDevCP = 0, hTarCP = 0;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        Intent;

    LoadCP32( (LPCSTR) DevProfile, &hDevCP, (LPCHANDLE) &cpDev);
    LoadCP32( (LPCSTR) TargetProfile, &hTarCP, (LPCHANDLE) &cpTar);

    if (!hDevCP || !hTarCP)
    {
        if (hDevCP)  FreeCP(hDevCP);
        if (hTarCP)  FreeCP(hTarCP);
        return;
    }
    
    switch (Inter_Intent)
    {
        case 0: Intent = icPerceptual; break;
        case 1: Intent = icRelativeColorimetric; break;
        case 2: Intent = icSaturation; break;
        case 3: Intent = icAbsoluteColorimetric; break;
        default: return;
    }

    Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, NULL, &cbSize, AllowBinary);
    if (Ret)
    {
        if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
            return;
        Ret = GetPS2PreviewColorRenderingDictionary(cpDev, cpTar, Intent, lpBuffer, &cbSize, AllowBinary);
        hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
        cbSize = _lwrite(hOutput, lpBuffer, cbSize);
        _lclose(hOutput);
        MemFree(hBuffer);
    }
    FreeCP(hDevCP);
    FreeCP(hTarCP);

    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
}

/***************************************************************************
*                               ColorSpaceControl
*  function:
*    This is a main testing program
*    
*  prototype:
*       void ColorSpaceControl(
*               LPSTR       FileName,
*               LPSTR       SaveFileName,
*               WORD        CSAType,  
*               BOOL        AllowBinary)
*  parameters:
*       FileName    --  Color Profile Filename
*       SaveFileName--  Color Space save to Filename
*       CSAType     --  Create CSA based on auto or manual selection.
*       AllowBinary --  1: binary CS allowed,  0: only ascii CS allowed.
*  returns:
*       None.
****************************************************************************/
void 
ColorSpaceControl(
    LPSTR       FileName,
    LPSTR       SaveFileName,
    DWORD       InpDrvClrSp,
    DWORD       Intent,
    WORD        CSAType,
    BOOL        AllowBinary)
{
    BOOL        Ret;
    CHANDLE     cp;
    HGLOBAL     hCP;
    HGLOBAL     hBuffer;
    MEMPTR      lpBuffer;
    OFSTRUCT    OfStruct;
    HFILE       hOutput;
    DWORD       cbSize;
    CSIG        ColorSpace;

    if( !LoadCP32( (LPCSTR) FileName, &hCP, (LPCHANDLE) &cp) )
    {
        return;
    }
    switch (InpDrvClrSp)
    {
        case 0: break;
        case 1: InpDrvClrSp = icSigGrayData; break;
        case 3: InpDrvClrSp = icSigRgbData; break;
        case 4: InpDrvClrSp = icSigCmykData; break;
        default: InpDrvClrSp = 0; break;
    }

    // Create CieBasedDEF(G) first. if can not, create CieBasedABC.
    if (CSAType == 405)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, InpDrvClrSp, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
    // Create CieBasedABC
    else if (CSAType == 406)
    {
        Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, NULL, &cbSize, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2ColorSpaceArray(cp, Intent, icSigRgbData, lpBuffer, &cbSize, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }
    }
#if 0
    else if (CSAType == 406)
    {
        Ret = GetPS2CSA_ABC( cp, NULL, &cbSize, InpDrvClrSp, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            Ret = GetPS2CSA_ABC( cp, lpBuffer, &cbSize, InpDrvClrSp, AllowBinary);

            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
    else if ((CSAType == 407) &&
        (GetCPDevSpace(cp, (LPCSIG) &ColorSpace)))
    {
        if (ColorSpace == icSigRgbData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
        else if (ColorSpace == icSigCmykData)
            Ret = GetPS2CSA_DEFG_Intent(cp, NULL, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
        if (Ret)
        {
            if (!MemAlloc(cbSize, &hBuffer, &lpBuffer))
                return;
            if (ColorSpace == icSigRgbData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEF, AllowBinary);
            else if (ColorSpace == icSigCmykData)
                Ret = GetPS2CSA_DEFG_Intent(cp, lpBuffer, &cbSize, 
                    InpDrvClrSp, Intent, TYPE_CIEBASEDDEFG, AllowBinary);
            hOutput = OpenFile(SaveFileName, &OfStruct, OF_CREATE);
            cbSize = _lwrite(hOutput, lpBuffer, cbSize);
            _lclose(hOutput);

            MemFree(hBuffer);
        }

    }
#endif
    FreeCP(hCP);
    if (!Ret)
         MessageBox( GetFocus(), "No CRD created.", NULL, MB_OK );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\icc.h ===
/* Header file guard bands */
#ifndef ICC_H
#define ICC_H

/*****************************************************************
 Copyright (c) 1994 SunSoft, Inc.

                    All Rights Reserved

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restrict-
ion, including without limitation the rights to use, copy, modify,
merge, publish distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT.  IN NO EVENT SHALL SUNSOFT, INC. OR ITS PARENT
COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of SunSoft, Inc.
shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without written
authorization from SunSoft Inc.
******************************************************************/

/*
 * This version of the header file corresponds to the profile
 * specification version 3.0.
 *
 * All header file entries are pre-fixed with "ic" to help
 * avoid name space collisions. Signatures are pre-fixed with
 * icSig.
 *
 * The structures defined in this header file were created to
 * represent a description of an ICC profile on disk. Rather
 * than use pointers a technique is used where a single byte array
 * was placed at the end of each structure. This allows us in "C"
 * to extend the structure by allocating more data than is needed
 * to account for variable length structures.
 *
 * This also ensures that data following is allocated
 * contiguously and makes it easier to write and read data from
 * the file.
 *
 * For example to allocate space for a 256 count length UCR
 * and BG array, and fill the allocated data.
 *
        icUcrBgCurve    *ucrCurve, *bgCurve;
        int             ucr_nbytes, bg_nbytes;
        icUcrBg         *ucrBgWrite;

        ucr_nbytes = sizeof(icUInt32Number) +
                 (UCR_CURVE_SIZE * sizeof(icUInt16Number));
        bg_nbytes = sizeof(icUInt32Number) +
                 (BG_CURVE_SIZE * sizeof(icUInt16Number));

        ucrBgWrite = (icUcrBg *)malloc((ucr_nbytes + bg_nbytes));

        ucrCurve = (icUcrBgCurve *)ucrBgWrite->data;
        ucrCurve->count = UCR_CURVE_SIZE;
        for (i=0; i<ucrCurve->count; i++)
                ucrCurve->curve[i] = (icUInt16Number)i;

        bgCurve = (icUcrBgCurve *)((char *)ucrCurve + ucr_nbytes);
        bgCurve->count = BG_CURVE_SIZE;
        for (i=0; i<bgCurve->count; i++)
                bgCurve->curve[i] = 255 - (icUInt16Number)i;
 *
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/*------------------------------------------------------------------------*/
/*
 * Defines used in the specification
 */
#define icMagicNumber                   0x61637370      /* 'acsp' */
#define icVersionNumber                 0x02000000      /* 2.0, BCD */

/* Screening Encodings */
#define icPrtrDefaultScreensFalse       0x00000000      /* Bit position 0 */
#define icPrtrDefaultScreensTrue        0x00000001      /* Bit position 0 */
#define icLinesPerInch                  0x00000002      /* Bit position 1 */
#define icLinesPerCm                    0x00000000      /* Bit position 1 */

/*
 * Device attributes, currently defined values correspond
 * to the low 4 bytes of the 8 byte attribute quantity, see
 * the header for their location.
 */
#define icReflective                    0x00000000      /* Bit position 0 */
#define icTransparency                  0x00000001      /* Bit position 0 */
#define icGlossy                        0x00000000      /* Bit position 1 */
#define icMatte                         0x00000002      /* Bit position 1 */

/*
 * Profile header flags, the low 16 bits are reserved for consortium
 * use.
 */
#define icEmbeddedProfileFalse          0x00000000      /* Bit position 0 */
#define icEmbeddedProfileTrue           0x00000001      /* Bit position 0 */
#define icUseAnywhere                   0x00000000      /* Bit position 1 */
#define icUseWithEmdeddedDataOnly       0x00000002      /* Bit position 1 */

/* Ascii or Binary data */
#define icAsciiData                     0x00000000      /* Used in dataType */
#define icBinaryData                    0x00000001

/*
 * Define used to indicate that this is a variable length array
 */
#define icAny                           1

/*------------------------------------------------------------------------*/
/*
 * Signatures, these are basically 4 byte identifiers
 * used to differentiate between tags and other items
 * in the profile format.
 */
typedef unsigned char    icSignature[4];

typedef unsigned char   icTagSignature[4];
/* public tags and sizes */
#define    icSigAToB0Tag                       0x41324230   /* 'A2B0' */
#define    icSigAToB1Tag                       0x41324231   /* 'A2B1' */
#define    icSigAToB2Tag                       0x41324232   /* 'A2B2' */
#define    icSigAToB3Tag                       0x41324233   /* 'A2B2' */
#define    icSigBlueColorantTag                0x6258595A   /* 'bXYZ' */
#define    icSigBlueTRCTag                     0x62545243   /* 'bTRC' */
#define    icSigBToA0Tag                       0x42324130   /* 'B2A0' */
#define    icSigBToA1Tag                       0x42324131   /* 'B2A1' */
#define    icSigBToA2Tag                       0x42324132   /* 'B2A2' */
#define    icSigBToA3Tag                       0x42324133   /* 'B2A3' */
#define    icSigCalibrationDateTimeTag         0x63616C74   /* 'calt' */
#define    icSigCharTargetTag                  0x74617267   /* 'targ' */
#define    icSigCopyrightTag                   0x63707274   /* 'cprt' */
#define    icSigDeviceMfgDescTag               0x646D6E64   /* 'dmnd' */
#define    icSigDeviceModelDescTag             0x646D6464   /* 'dmdd' */
#define    icSigGamutTag                       0x676d7420   /* 'gmt ' */
#define    icSigGrayTRCTag                     0x6b545243   /* 'kTRC' */
#define    icSigGreenColorantTag               0x6758595A   /* 'gXYZ' */
#define    icSigGreenTRCTag                    0x67545243   /* 'gTRC' */
#define    icSigLuminanceTag                   0x6C756d69   /* 'lumi' */
#define    icSigMeasurementTag                 0x6D656173   /* 'meas' */
#define    icSigMediaBlackPointTag             0x626B7074   /* 'bkpt' */
#define    icSigMediaWhitePointTag             0x77747074   /* 'wtpt' */
#define    icSigNamedColorTag                  0x6E636f6C   /* 'ncol' */
#define    icSigPreview0Tag                    0x70726530   /* 'pre0' */
#define    icSigPreview1Tag                    0x70726531   /* 'pre1' */
#define    icSigPreview2Tag                    0x70726532   /* 'pre2' */
#define    icSigProfileDescriptionTag          0x64657363   /* 'desc' */
#define    icSigProfileSequenceDescTag         0x70736571   /* 'pseq' */
#define    icSigPs2CRD0Tag                     0x70736430   /* 'psd0' */
#define    icSigPs2CRD1Tag                     0x70736431   /* 'psd1' */
#define    icSigPs2CRD2Tag                     0x70736432   /* 'psd2' */
#define    icSigPs2CRD3Tag                     0x70736433   /* 'psd3' */
#define    icSigPs2CSATag                      0x70733273   /* 'ps2s' */
#define    icSigPs2Intent0Tag                  0x70736930   /* 'psi0' */
#define    icSigPs2Intent1Tag                  0x70736931   /* 'psi1' */
#define    icSigPs2Intent2Tag                  0x70736932   /* 'psi2' */
#define    icSigPs2Intent3Tag                  0x70736933   /* 'psi3' */
#define    icSigRedColorantTag                 0x7258595A   /* 'rXYZ' */
#define    icSigRedTRCTag                      0x72545243   /* 'rTRC' */
#define    icSigScreeningDescTag               0x73637264   /* 'scrd' */
#define    icSigScreeningTag                   0x7363726E   /* 'scrn' */
#define    icSigTechnologyTag                  0x74656368   /* 'tech' */
#define    icSigUcrBgTag                       0x62666420   /* 'bfd ' */
#define    icSigViewingCondDescTag             0x76756564   /* 'vued' */
#define    icSigViewingConditionsTag           0x76696577   /* 'view' */
#define    icSigK007Tag                        0x4B303037   /* 'K007' */
#define    icMaxEnumTag                        0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTechnologySignature[4];
/* technology signature descriptions */
#define    icSigFilmScanner                    0x6673636E   /* 'fscn' */
#define    icSigReflectiveScanner              0x7273636E   /* 'rscn' */
#define    icSigInkJetPrinter                  0x696A6574   /* 'ijet' */
#define    icSigThermalWaxPrinter              0x74776178   /* 'twax' */
#define    icSigElectrophotographicPrinter     0x6570686F   /* 'epho' */
#define    icSigElectrostaticPrinter           0x65737461   /* 'esta' */
#define    icSigDyeSublimationPrinter          0x64737562   /* 'dsub' */
#define    icSigPhotographicPaperPrinter       0x7270686F   /* 'rpho' */
#define    icSigFilmWriter                     0x6670726E   /* 'fprn' */
#define    icSigVideoMonitor                   0x7669646D   /* 'vidm' */
#define    icSigVideoCamera                    0x76696463   /* 'vidc' */
#define    icSigProjectionTelevision           0x706A7476   /* 'pjtv' */
#define    icSigCRTDisplay                     0x43525420   /* 'CRT ' */
#define    icSigPMDisplay                      0x504D4420   /* 'PMD ' */
#define    icSigAMDisplay                      0x414D4420   /* 'AMD ' */
#define    icSigPhotoCD                        0x4B504344   /* 'KPCD' */
#define    icSigPhotoImageSetter               0x696D6773   /* 'imgs' */
#define    icSigGravure                        0x67726176   /* 'grav' */
#define    icSigOffsetLithography              0x6F666673   /* 'offs' */
#define    icSigSilkscreen                     0x73696C6B   /* 'silk' */
#define    icSigFlexography                    0x666C6578   /* 'flex' */
#define    icMaxEnumTechnology                 0xFFFFFFFF   /* enum = 4
bytes max */

typedef unsigned char   icTagTypeSignature[4];
/* type signatures */
#define    icSigCurveType                      0x63757276   /* 'curv' */
#define    icSigDataType                       0x64617461   /* 'data' */
#define    icSigDateTimeType                   0x6474696D   /* 'dtim' */
#define    icSigLut16Type                      0x6d667432   /* 'mft2' */
#define    icSigLut8Type                       0x6d667431   /* 'mft1' */
#define    icSigMeasurementType                0x6D656173   /* 'meas' */
#define    icSigNamedColorType                 0x6E636f6C   /* 'ncol' */
#define    icSigProfileSequenceDescType        0x70736571   /* 'pseq' */
#define    icSigS15Fixed16ArrayType            0x73663332   /* 'sf32' */
#define    icSigScreeningType                  0x7363726E   /* 'scrn' */
#define    icSigSignatureType                  0x73696720   /* 'sig ' */
#define    icSigTextType                       0x74657874   /* 'text' */
#define    icSigTextDescriptionType            0x64657363   /* 'desc' */
#define    icSigU16Fixed16ArrayType            0x75663332   /* 'uf32' */
#define    icSigUcrBgType                      0x62666420   /* 'bfd ' */
#define    icSigUInt16ArrayType                0x75693136   /* 'ui16' */
#define    icSigUInt32ArrayType                0x75693332   /* 'ui32' */
#define    icSigUInt64ArrayType                0x75693634   /* 'ui64' */
#define    icSigUInt8ArrayType                 0x75693038   /* 'ui08' */
#define    icSigViewingConditionsType          0x76696577   /* 'view' */
#define    icSigXYZType                        0x58595A20   /* 'XYZ ' */
#define    icMaxEnumType                       0xFFFFFFFF   /* enum = 4
bytes max */

/*
 * Color Space Signatures
 * Note that only icSigXYZData and icSigLabData are valid
 * Profile Connection Spaces (PCSs)
 */
typedef unsigned char   icColorSpaceSignature[4];
#define    icSigXYZData                        0x58595A20   /* 'XYZ ' */
#define    icSigLabData                        0x4C616220   /* 'Lab ' */
#define    icSigLuvData                        0x4C757620   /* 'Luv ' */
#define    icSigYCbCrData                      0x59436272   /* 'YCbr' */
#define    icSigYxyData                        0x59787920   /* 'Yxy ' */
#define    icSigRgbData                        0x52474220   /* 'RGB ' */
#define    icSigGrayData                       0x47524159   /* 'GRAY' */
#define    icSigHsvData                        0x48535620   /* 'HSV ' */
#define    icSigHlsData                        0x484C5320   /* 'HLS ' */
#define    icSigCmykData                       0x434D594B   /* 'CMYK' */
#define    icSigCmyData                        0x434D5920   /* 'CMY ' */
#define    icSigDefData                        0x44454620   /* 'DEF ' New Definition */
#define    icMaxEnumData                       0xFFFFFFFF   /* enum = 4
bytes max */

/* profileClass enumerations */
typedef unsigned char   icProfileClassSignature[4];
#define    icSigInputClass                     0x73636E72   /* 'scnr' */
#define    icSigDisplayClass                   0x6D6E7472   /* 'mntr' */
#define    icSigOutputClass                    0x70727472   /* 'prtr' */
#define    icSigLinkClass                      0x6C696E6B   /* 'link' */
#define    icSigAbstractClass                  0x61627374   /* 'abst' */
#define    icSigColorSpaceClass                0x73706163   /* 'spac' */
#define    icMaxEnumClass                      0xFFFFFFFF   /* enum = 4
bytes max */

/* Platform Signatures */
typedef unsigned char   icPlatformSignature[4];
#define    icSigMacintosh                      0x4150504C   /* 'APPL' */
#define    icSigMicrosoft                      0x4D534654   /* 'MSFT' */
#define    icSigSolaris                        0x53554E57   /* 'SUNW' */
#define    icSigSGI                            0x53474920   /* 'SGI ' */
#define    icSigTaligent                       0x54474E54   /* 'TGNT' */
#define    icMaxEnumPlatform                   0xFFFFFFFF   /* enum = 4
bytes max */

/*------------------------------------------------------------------------*/
/*
 * Other enums
 */

/* Measurement Flare, used in the measurmentType tag */
typedef unsigned char   icMeasurementFlare[4];
#define     icFlare0                    0x00000000      /* 0% flare */
#define     icFlare100                  0x00000001      /* 100% flare */
#define     icMaxFlare                  0xFFFFFFFF      /* enum = 4 bytes max */

/* Measurement Geometry, used in the measurmentType tag */
typedef unsigned char   icMeasurementGeometry[4];
#define     icGeometryUnknown           0x00000000      /* Unknown geometry */
#define     icGeometry045or450          0x00000001      /* 0/45 or 45/0 */
#define     icGeometry0dord0            0x00000002      /* 0/d or d/0 */
#define     icMaxGeometry               0xFFFFFFFF      /* enum = 4 bytes max */

/* Rendering Intents, used in the profile header */
typedef unsigned char   icRenderingIntent[4];
#define     icPerceptual                0
#define     icRelativeColorimetric      1
#define     icSaturation                2
#define     icAbsoluteColorimetric      3
#define     icUseRenderingIntent        0xFFFFFFFF      /* New Definition  */
#define     icMaxEnumIntent             0xFFFFFFFF      /* enum = 4 bytes max */

/* Different Spot Shapes currently defined, used for screeningType */
typedef unsigned char   icSpotShape[4];
#define     icSpotShapeUnknown          0
#define     icSpotShapePrinterDefault   1
#define     icSpotShapeRound            2
#define     icSpotShapeDiamond          3
#define     icSpotShapeEllipse          4
#define     icSpotShapeLine             5
#define     icSpotShapeSquare           6
#define     icSpotShapeCross            7
#define     icMaxEnumSpot               0xFFFFFFFF      /* enum = 4 bytes max */

/* Standard Observer, used in the measurmentType tag */
typedef unsigned char   icStandardObserver[4];
#define     icStdObsUnknown             0x00000000      /* Unknown observer */
#define     icStdObs1931TwoDegrees      0x00000001      /* 1931 two degrees */
#define     icStdObs1964TenDegrees      0x00000002      /* 1961 ten degrees */
#define     icMaxStdObs                 0xFFFFFFFF      /* enum = 4 bytes max */

/* Pre-defined illuminants, used in measurement and viewing conditions type */
typedef unsigned char   icIlluminant[4];
#define     icIlluminantUnknown                 = 0x00000000
#define     icIlluminantD50                     = 0x00000001
#define     icIlluminantD65                     = 0x00000002
#define     icIlluminantD93                     = 0x00000003
#define     icIlluminantF2                      = 0x00000004
#define     icIlluminantD55                     = 0x00000005
#define     icIlluminantA                       = 0x00000006
#define     icIlluminantEquiPowerE              = 0x00000007    /* Equi-Power (E) */
#define     icIlluminantF8                      = 0x00000008
#define     icMaxEnumIluminant                  = 0xFFFFFFFF    /* enum = 4

/*------------------------------------------------------------------------*/
/*
 * Number definitions
 */

/* Unsigned integer numbers */
typedef unsigned char   icUInt8Number;
typedef unsigned char   icUInt16Number[2];
typedef unsigned char   icUInt32Number[4];
typedef unsigned char   icUInt64Number[8];

/* Signed numbers */
typedef signed char     icInt8Number;
typedef signed char     icInt16Number[2];
typedef signed char     icInt32Number[4];
typedef signed char     icInt64Number[8];

/* Fixed numbers */
typedef signed char     icS15Fixed16Number[4];
typedef unsigned char   icU16Fixed16Number[4];

/*------------------------------------------------------------------------*/
/*
 * Arrays of numbers
 */

/* Int8 Array */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of values */
} icInt8Array;

/* UInt8 Array */
typedef struct {
    icUInt8Number       data[icAny];    /* Variable array of values */
} icUInt8Array;

/* uInt16 Array */
typedef struct {
    icUInt16Number      data[icAny];    /* Variable array of values */
} icUInt16Array;

/* Int16 Array */
typedef struct {
    icInt16Number       data[icAny];    /* Variable array of values */
} icInt16Array;

/* uInt32 Array */
typedef struct {
    icUInt32Number      data[icAny];    /* Variable array of values */
} icUInt32Array;

/* Int32 Array */
typedef struct {
    icInt32Number       data[icAny];    /* Variable array of values */
} icInt32Array;

/* UInt64 Array */
typedef struct {
    icUInt64Number      data[icAny];    /* Variable array of values */
} icUInt64Array;

/* Int64 Array */
typedef struct {
    icInt64Number       data[icAny];    /* Variable array of values */
} icInt64Array;

/* u16Fixed16 Array */
typedef struct {
    icU16Fixed16Number  data[icAny];    /* Variable array of values */
} icU16Fixed16Array;

/* s15Fixed16 Array */
typedef struct {
    icS15Fixed16Number  data[icAny];    /* Variable array of values */
} icS15Fixed16Array;

/* The base date time number */
typedef struct {
    icUInt16Number      year;
    icUInt16Number      month;
    icUInt16Number      day;
    icUInt16Number      hours;
    icUInt16Number      minutes;
    icUInt16Number      seconds;
} icDateTimeNumber;

/* XYZ Number  */
typedef struct {
    icS15Fixed16Number  X;
    icS15Fixed16Number  Y;
    icS15Fixed16Number  Z;
} icXYZNumber;

/* XYZ Array */
typedef struct {
    icXYZNumber         data[icAny];    /* Variable array of XYZ numbers */
} icXYZArray;

/* Curve */
typedef struct {
    icUInt32Number      count;          /* Number of entries */
    icUInt16Number      data[icAny];    /* The actual table data, real
                                         * number is determined by count
                                         */
} icCurve;

/* Data */
typedef struct {
    icUInt32Number      dataFlag;       /* 0 = ascii, 1 = binary */
    icInt8Number        data[icAny];    /* Data, size determined from tag */
} icData;

/* lut16 */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;            /* Padding for byte alignment */
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt16Number      inputEnt;       /* Number of input table entries */
    icUInt16Number      outputEnt;      /* Number of output table entries */
    icUInt16Number      data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt16Number      inputTable[inputChan][icAny];   * The input table
 *  icUInt16Number      clutTable[icAny];               * The clut table
 *  icUInt16Number      outputTable[outputChan][icAny]; * The output table
 */
} icLut16;

/* lut8, input & output tables are always 256 bytes in length */
typedef struct {
    icUInt8Number       inputChan;      /* Number of input channels */
    icUInt8Number       outputChan;     /* Number of output channels */
    icUInt8Number       clutPoints;     /* Number of clutTable grid points */
    icInt8Number        pad;
    icS15Fixed16Number  e00;            /* e00 in the 3 * 3 */
    icS15Fixed16Number  e01;            /* e01 in the 3 * 3 */
    icS15Fixed16Number  e02;            /* e02 in the 3 * 3 */
    icS15Fixed16Number  e10;            /* e10 in the 3 * 3 */
    icS15Fixed16Number  e11;            /* e11 in the 3 * 3 */
    icS15Fixed16Number  e12;            /* e12 in the 3 * 3 */
    icS15Fixed16Number  e20;            /* e20 in the 3 * 3 */
    icS15Fixed16Number  e21;            /* e21 in the 3 * 3 */
    icS15Fixed16Number  e22;            /* e22 in the 3 * 3 */
    icUInt8Number       data[icAny];    /* Data follows see spec for size */
/*
 *  Data that follows is of this form
 *
 *  icUInt8Number       inputTable[inputChan][256];     * The input table
 *  icUInt8Number       clutTable[icAny];               * The clut table
 *  icUInt8Number       outputTable[outputChan][256];   * The output table
 */
} icLut8;

/* Measurement Data */
typedef struct {
    icStandardObserver          stdObserver;    /* Standard observer */
    icXYZNumber                 backing;        /* XYZ for backing material */
    icMeasurementGeometry       geometry;       /* Measurement geometry */
    icMeasurementFlare          flare;          /* Measurement flare */
    icIlluminant                illuminant;     /* Illuminant */
} icMeasurement;

/* Named color */
typedef struct {
    icUInt32Number      vendorFlag;     /* Bottom 16 bits for IC use */
    icUInt32Number      count;          /* Count of named colors */
    icInt8Number        data[icAny];    /* Named color data follows */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         prefix[icAny];  * Prefix for the color name, max = 32
 * icInt8Number         suffix[icAny];  * Suffix for the color name, max = 32
 * icInt8Number         root1[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords1[icAny]; * Color co-ordinates of first color
 * icInt8Number         root2[icAny];   * Root name for first color, max = 32
 * icInt8Number         coords2[icAny]; * Color co-ordinates of first color
 *                      :
 *                      :
 * Repeat for root name and color co-ordinates up to (count-1)
 */
} icNamedColor;

/* Profile sequence structure */
typedef struct {
    icSignature                 deviceMfg;      /* Device Manufacturer */
    icSignature                 deviceModel;    /* Decvice Model */
    icUInt64Number              attributes;     /* Device attributes */
    icTechnologySignature       technology;     /* Technology signature */
    icInt8Number                data[icAny];    /* Descriptions text
follows */
/*
 *  Data that follows is of this form
 *
 * icTextDescription            deviceMfgDesc[icAny];   * Manufacturer text
 * icTextDescription            modelDesc[icAny];       * Model text
 */
} icDescStruct;

/* Profile sequence description */
typedef struct {
    icUInt32Number      count;          /* Number of descriptions */
    icDescStruct        data[icAny];    /* Array of description struct */
} icProfileSequenceDesc;

/* textDescription */
typedef struct {
    icUInt32Number      count;          /* Description length */
    icInt8Number        data[icAny];    /* Descriptions follow */
/*
 *  Data that follows is of this form
 *
 * icInt8Number         desc[icAny]     * NULL terminated ascii string
 * icUInt32Number       ucLangCode;     * UniCode language code
 * icUInt32Number       ucCount;        * UniCode description length
 * icInt8Number         ucDesc[icAny;   * The UniCode description
 * icUInt16Number       scCode;         * ScriptCode code
 * icUInt8Number        scCount;        * ScriptCode count
 * icInt8Number         scDesc[64];     * ScriptCode Description
 */
} icTextDescription;

/* Screening Data */
typedef struct {
    icS15Fixed16Number  frequency;      /* Frequency */
    icS15Fixed16Number  angle;          /* Screen angle */
    icSpotShape         spotShape;      /* Spot Shape encodings below */
} icScreeningData;

typedef struct {
    icUInt32Number      screeningFlag;  /* Screening flag */
    icUInt32Number      channels;       /* Number of channels */
    icScreeningData     data[icAny];    /* Array of screening data */
} icScreening;

/* Text Data */
typedef struct {
    icInt8Number        data[icAny];    /* Variable array of characters */
} icText;

/* Structure describing either a UCR or BG curve */
typedef struct {
    icUInt32Number      count;          /* Curve length */
    icUInt16Number      curve[icAny];   /* The array of curve values */
} icUcrBgCurve;

/* Under color removal, black generation */
typedef struct {
    icUInt8Number       data[icAny];            /* The Ucr BG data */
/*
 *  Data that follows is of this form
 *
 * icUcrBgCurve         ucr;            * Ucr curve
 * icUcrBgCurve         bg;             * Bg curve
 */
} icUcrBg;

/* viewingConditionsType */
typedef struct {
    icXYZNumber         illuminant;     /* In candelas per metre sq'd */
    icXYZNumber         surround;       /* In candelas per metre sq'd */
    icIlluminant        stdIluminant;   /* See icIlluminant defines */
} icViewingCondition;


/*------------------------------------------------------------------------*/
/*
 * Tag Type definitions
 */

/*
 * Many of the structures contain variable length arrays. This
 * is represented by the use of the convention.
 *
 *      type    data[icAny];
 */

/* The base part of each tag */
typedef struct {
    icTagTypeSignature  sig;            /* Signature */
    icInt8Number        reserved[4];    /* Reserved, set to 0 */
} icTagBase;

/* curveType */
typedef struct {
    icTagBase           base;           /* Signature, "curv" */
    icCurve             curve;          /* The curve data */
} icCurveType;

/* dataType */
typedef struct {
    icTagBase           base;           /* Signature, "data" */
    icData              data;           /* The data structure */
} icDataType;

/* dateTimeType */
typedef struct {
    icTagBase           base;           /* Signature, "dtim" */
    icDateTimeNumber    date;           /* The date */
} icDateTimeType;

/* lut16Type */
typedef struct {
    icTagBase           base;           /* Signature, "mft2" */
    icLut16             lut;            /* Lut16 data */
} icLut16Type;

/* lut8Type, input & output tables are always 256 bytes in length */
typedef struct {
    icTagBase           base;           /* Signature, "mft1" */
    icLut8              lut;            /* Lut8 data */
} icLut8Type;

/* Measurement Type */
typedef struct {
    icTagBase           base;           /* Signature, "meas" */
    icMeasurement       measurement;    /* Measurement data */
} icMeasurementType;

/* Named color type */
typedef struct {
    icTagBase           base;           /* Signature, "ncol" */
    icNamedColor        ncolor;         /* Named color data */
} icNamedColorType;

/* Profile sequence description type */
typedef struct {
    icTagBase                   base;   /* Signature, "pseq" */
    icProfileSequenceDesc       desc;   /* The seq description */
} icProfileSequenceDescType;

/* textDescriptionType */
typedef struct {
    icTagBase                   base;   /* Signature, "desc" */
    icTextDescription           desc;           /* The description */
} icTextDescriptionType;

/* s15Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "sf32" */
    icS15Fixed16Array   data;           /* Array of values */
} icS15Fixed16ArrayType;

typedef struct {
    icTagBase           base;           /* Signature, "scrn" */
    icScreening         screen;         /* Screening structure */
} icScreeningType;

/* sigType */
typedef struct {
    icTagBase           base;           /* Signature, "sig" */
    icSignature         signature;      /* The signature data */
} icSignatureType;

/* textType */
typedef struct {
    icTagBase           base;           /* Signature, "text" */
    icText              data;           /* Variable array of characters */
} icTextType;

/* u16Fixed16Type */
typedef struct {
    icTagBase           base;           /* Signature, "uf32" */
    icU16Fixed16Array   data;           /* Variable array of values */
} icU16Fixed16ArrayType;

/* Under color removal, black generation type */
typedef struct {
    icTagBase           base;           /* Signature, "bfd " */
    icUcrBg             data;           /* ucrBg structure */
} icUcrBgType;

/* uInt16Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui16" */
    icUInt16Array       data;           /* Variable array of values */
} icUInt16ArrayType;

/* uInt32Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui32" */
    icUInt32Array       data;           /* Variable array of values */
} icUInt32ArrayType;

/* uInt64Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui64" */
    icUInt64Array       data;           /* Variable array of values */
} icUInt64ArrayType;

/* uInt8Type */
typedef struct {
    icTagBase           base;           /* Signature, "ui08" */
    icUInt8Array        data;           /* Variable array of values */
} icUInt8ArrayType;

/* viewingConditionsType */
typedef struct {
    icTagBase           base;           /* Signature, "view" */
    icViewingCondition  view;           /* Viewing conditions */
} icViewingConditionType;

/* XYZ Type */
typedef struct {
    icTagBase           base;           /* Signature, "XYZ" */
    icXYZArray          data;           /* Variable array of XYZ numbers */
} icXYZType;

/*------------------------------------------------------------------------*/

/*
 * Lists of tags, tags, profile header and profile strcuture
 */

/* A tag */
typedef struct {
    icTagSignature      sig;            /* The tag signature */
    icUInt32Number      offset;         /* Start of tag relative to
                                         * start of header, Spec Section 8 */
    icUInt32Number      size;           /* Size in bytes */
} icTag;

/* A Structure that may be used independently for a list of tags */
typedef struct {
    icUInt32Number      count;          /* Number of tags in the profile */
    icTag               tags[icAny];    /* Variable array of tags */
} icTagList;

/* The Profile header */
typedef struct {
    icUInt32Number              size;           /* Profile size in bytes */
    icSignature                 cmmId;          /* CMM for this profile */
    icUInt32Number              version;        /* Format version number */
    icProfileClassSignature     deviceClass;    /* Type of profile */
    icColorSpaceSignature       colorSpace;     /* Color space of data */
    icColorSpaceSignature       pcs;            /* PCS, XYZ or Lab only */
    icDateTimeNumber            date;           /* Date profile was created */
    icSignature                 magic;          /* icMagicNumber */
    icPlatformSignature         platform;       /* Primary Platform */
    icUInt32Number              flags;          /* Various bit settings */
    icSignature                 manufacturer;   /* Device manufacturer */
    icUInt32Number              model;          /* Device model number */
    icUInt64Number              attributes;     /* Device attributes */
    icUInt32Number              renderingIntent;/* Rendering intent */
    icXYZNumber                 illuminant;     /* Profile illuminant */
    icInt8Number                reserved[48];   /* Reserved for future use */
} icHeader;

/*
 * A profile,
 * we can't use icTagList here because its not at the end of the structure
 */
typedef struct {
    icHeader            header;         /* The header */
    icUInt32Number      count;          /* Number of tags in the profile */
    icInt8Number        data[icAny];    /* The tagTable and tagData */
/*
 * Data that follows is of the form
 *
 * icTag        tagTable[icAny];        * The tag table
 * icInt8Number tagData[icAny];         * The tag data
 */
} icProfile;    

/*------------------------------------------------------------------------*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\devprop.h ===
/******************************************************************************

  Header File:  Device Property Page.H

  Defines the class that handles the various device profile management pages.
  These derive from CShellExtensionPage.

  Since much of the profile management process is common to all devices, a base
  class (CDeviceProfileManagement) provides these core services- filling the
  device list box, properly enabling and disabling the "Remove" button, and
  adding, associating, and dissociating profiles as needed.  Virtual functions
  provide the means by which the individual device pages customize or modify
  this behavior.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises, Inc. Production

  Change History:

  11-27-96  a-RobKj@microsoft.com coded it

******************************************************************************/

#if !defined(DEVICE_PROFILE_UI)

#define DEVICE_PROFILE_UI

#include    "PropPage.H"
#include    "Profile.H"

/******************************************************************************

  CDeviceProfileManagement class

  This class provides the core services for these pages.

  NOTES:

  The profiles must be in a list box (not a combo box) with the ID ProfileList.
  If this isn't done, you must both override OnInit, and not call this class's
  OnInit function.

  Most implementations of derived classes will call this class's version of
  functions they override.  Whether they do that before or after they do their
  customizatins will probably require understanding what this class does.

******************************************************************************/

/*
 * m_bReadOnly == FALSE (default)
 * In this case the property page behaves normally - user input
 * is accepted.
 * m_bReadOnly == TRUE
 * In this case all the buttons for this page are greyed out and
 * the user can only inspect the data.
 *
 * The flag is used for locking out users without permission to
 * modify the settings - but still allows them to view the settings.
 *
 * m_bCMYK is true if the device is a printer and it supports
 * CMYK profiles
 */

#define DEVLIST_ONINIT   0x0001
#define DEVLIST_CHANGED  0x0002
#define DEVLIST_NOSELECT 0x0004

class CDeviceProfileManagement : public CShellExtensionPage {

    DWORD           m_dwType;       //  Type class of target device

protected:

    CUintArray      m_cuaRemovals;  //  indices of dissociations to be done
    CProfileArray   m_cpaAdds;      //  Profiles to be added
    CProfileArray   m_cpaProfile;   //  Associated Profile Names
    CString         m_csDevice;     //  Target Device Name
    HWND            m_hwndList;     //  Profile list box in dialog
    BOOL            m_bCMYK;        //  Printer support for CMYK
    BOOL            m_bReadOnly;    //  Flag indicating that settings can be
                                    //  modified by the user
    virtual void    InitList();
    virtual void    FillList(DWORD dwFlags = 0);

    void            GetDeviceTypeString(DWORD dwType,CString& csDeviceName);

public:

    CDeviceProfileManagement(LPCTSTR lpstrName, HINSTANCE hiWhere, int idPage,
                             DWORD  dwType);
    ~CDeviceProfileManagement() {}


    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);
    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh);
};

//  This class encapsulates the required "Add Profile" old-style file open
//  dialog.  Kind of a shame, Explorer's a much nicer interface...

class CAddProfileDialog {

    CStringArray csa_Files;

    static UINT_PTR APIENTRY OpenFileHookProc(HWND hDlg, UINT uMessage, WPARAM wp,
                                          LPARAM lp);

public:

    CAddProfileDialog(HWND hwndOwner, HINSTANCE hi);
    ~CAddProfileDialog() { csa_Files.Empty(); }

    unsigned  ProfileCount()              { return csa_Files.Count(); }
    LPCTSTR   ProfileName(unsigned u)     { return csa_Files[u]; }
    CString   ProfileNameAndExtension(unsigned u) 
                                          { return csa_Files[u].NameAndExtension(); }
    void      AddProfile(LPCTSTR str)     { csa_Files.Add(str); }
};

//  The Printer Profile Management class uses the core class pretty much as is.
//  We override the OnInit member to disable all controls if the user lacks
//  administrative authority for the target printer.

class CPrinterProfileManagement : public CDeviceProfileManagement {

protected:

    unsigned    m_uDefault;    //  Default profile index
    BOOL        m_bManualMode; //  Manual profile selection mode
    BOOL        m_bAdminAccess;
    BOOL        m_bLocalPrinter;

    virtual void    InitList();
    virtual void    FillList(DWORD dwFlags = 0);

public:

    CPrinterProfileManagement(LPCTSTR lpstrName, HINSTANCE hiWhere);
    ~CPrinterProfileManagement() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);
    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh);

    virtual BOOL    OnHelp(LPHELPINFO pHelp);
    virtual BOOL    OnContextMenu(HWND hwnd);
};

//  The Scanner Profile Management class uses the core class pretty much as is.
//  We override the OnInit member to disable all controls if the user lacks
//  administrative authority for the target printer.

class CScannerProfileManagement : public CDeviceProfileManagement {

public:

    CScannerProfileManagement(LPCTSTR lpstrName, HINSTANCE hiWhere);
    ~CScannerProfileManagement() {}

    virtual BOOL    OnInit();

    virtual BOOL    OnHelp(LPHELPINFO pHelp);
    virtual BOOL    OnContextMenu(HWND hwnd);
};

//  The monitor profile class is a bit more complex, as it allows the
//  manipulation and setting of device default profiles as well as association
//  and dissociation of profiles.  It also has some extra controls to
//  initialize.

class CMonitorProfileManagement : public CDeviceProfileManagement {

protected:

    unsigned    m_uDefault;              //  Default profile index
    CString     m_csDeviceFriendlyName;  //  Target Device Friendly Name

    virtual void    InitList();
    virtual void    FillList(DWORD dwFlags = 0);

public:

    CMonitorProfileManagement(LPCTSTR lpstrName, LPCTSTR lpstrFriendlyName, HINSTANCE hiWhere);
    ~CMonitorProfileManagement() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);
    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh);

    virtual BOOL    OnHelp(LPHELPINFO pHelp);
    virtual BOOL    OnContextMenu(HWND hwnd);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\dialog.cpp ===
/******************************************************************************

  Source File:	Dialog.CPP

  Implements the CDialog class.  See Dialog.H for class definitions and details

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96	a-robkj@microsoft.com Created it
  12-11-96  a-robkj@microsoft.com Implemented hook

******************************************************************************/

#include	"ICMUI.H"

//	CDialog member functions

//	Class constructor- just save things, for now

CDialog::CDialog(HINSTANCE hiWhere, int id, HWND hwndParent) {
	m_idMain = id;
	m_hwndParent = hwndParent;
	m_hiWhere = hiWhere;
	m_bIsModal = FALSE;
	m_hwnd = NULL;
    m_dpHook = NULL;
    m_lpHook = 0;
}

CDialog::CDialog(CDialog &cdOwner, int id) {
	m_idMain = id;
	m_hwndParent = cdOwner.m_hwnd;
	m_hiWhere = cdOwner.m_hiWhere;
	m_bIsModal = FALSE;
	m_hwnd = NULL;
    m_dpHook = NULL;
    m_lpHook = 0;
}

//	Class destructor- clean up the window, if it is modeless.

CDialog::~CDialog() {
	Destroy();
}

//	Modal Dialog Box

LONG	CDialog::DoModal() {
	m_bIsModal = TRUE;
	return	(LONG)DialogBoxParam(m_hiWhere, MAKEINTRESOURCE(m_idMain), m_hwndParent,
		CDialog::DialogProc, (LPARAM) this);
}

//	Modeless dialog box creation

void	CDialog::Create() {
	if	(!m_bIsModal && m_hwnd)
		return;	//	We'va already got one!

	m_bIsModal = FALSE;
	CreateDialogParam(m_hiWhere, MAKEINTRESOURCE(m_idMain),
		m_hwndParent, CDialog::DialogProc, (LPARAM) this);
}

//	Modeless dialog box  destruction

void	CDialog::Destroy() {
	if	(!m_bIsModal && m_hwnd) {
		DestroyWindow(m_hwnd);
		m_hwnd = NULL;
	}
}

//	Dialog Procedure- this is a static private method.  This means
//	that all instances of this class (including derived classes) share
//	this code (no pointers needed) and that only instances of this
//	class (not even derived classes) can find it.

INT_PTR CALLBACK	CDialog::DialogProc(HWND hwndMe, UINT uMsg, WPARAM wp,
										  LPARAM lp) {

	CDialog	*pcdMe = (CDialog *) GetWindowLongPtr(hwndMe, DWLP_USER);

    //  If there is a hook procedure, it can either ignore or filter a
    //  message by returning FALSE, or it can handle itself by returning
    //  TRUE.  WM_INITDALOG hook processing occurs AFTER all of our other
    //  calls are made, and we allow the base class to define the LPARAM
    //  that is passed in to the hook.
    //  Because we do not have a pointer to the base class, we will miss
    //  messages sent before WM_INITDIALOG (specifically WM_SETFONT)

    if  (uMsg != WM_INITDIALOG && pcdMe && pcdMe -> m_dpHook &&
            (*pcdMe -> m_dpHook)(hwndMe, uMsg, wp, lp))
        return  TRUE;

	switch	(uMsg) {

		case	WM_INITDIALOG:

			//	The lp is the this pointer for the caller

			pcdMe = (CDialog *) lp;

            if(!pcdMe)
            {
                return FALSE;
            }
            
			SetWindowLongPtr(hwndMe, DWLP_USER, (LONG_PTR)pcdMe);
			pcdMe -> m_hwnd = hwndMe;

			//	Derived classes override OnInit to initialize the dialog

			if  (!pcdMe -> m_dpHook)
                return	pcdMe -> OnInit();
            else {
                //  If there is a hook procedure, we will call that after the
                //  override- if the override returned FALSE, so must we
                BOOL    bReturn = pcdMe -> OnInit();
                return  (*pcdMe -> m_dpHook)(hwndMe, uMsg, wp,
                    pcdMe -> m_lpHook) && bReturn;
            }

		case	WM_COMMAND:
            if(pcdMe)
            {
                return pcdMe -> OnCommand(HIWORD(wp), LOWORD(wp), (HWND) lp);
            }
            break;

		case	WM_NOTIFY:
            if(pcdMe)
            {
                return pcdMe -> OnNotify((int) wp, (LPNMHDR) lp);
            }
            break;

        case    WM_HELP:
            if(pcdMe)
            {
                return  pcdMe -> OnHelp((LPHELPINFO) lp);
            }
            break;

        case    WM_CONTEXTMENU:
            if(pcdMe)
            {
                return  pcdMe -> OnContextMenu((HWND) wp);
            }
            break;

	}

	return	FALSE;
}

//	Moves the window into position (needed to get dialogs positioned proeprly
//	in tab control display area).

void	CDialog::Adjust(RECT& rc) {
	SetWindowPos(m_hwnd, HWND_TOP, rc.left, rc.top, 0, 0,
		SWP_NOACTIVATE | SWP_NOSIZE | SWP_SHOWWINDOW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\dialog.h ===
/******************************************************************************

  Header File:  Dialog.H

  This defines the C++ class used to encapsulate dialogs.  It supports both
  modal and modeless styles.  This class uses a static method for the dialog
  procedure, which automatically caches the "this" pointer for the class in the
  DWL_USER field of the window's internal structure for the dialog.  This
  hand-off is accomplished by setting the lParam parameter on a DialogBoxParam
  or CreateDialogParam call to the "this" pointer.  It also saves the dialog
  handle in a protected member for easy access from derived classes.

  To create a C++ class for any specific dialog, derive the class from this
  class, providing the dialog ID and instance handle needed to get the dialog
  resource in the derived class constructor.  Also provide the parent window
  handle, if there is one.

  The dialog procedure then provides virtual functions for Windows messages
  of interest.  I've added these as needed.  If I were going to a truly
  universal class of this sort, I'd just as well go to MFC, and save the
  debugging time, so this approach seems reasonable to me.

  12-11-96- to support the hook procedure used in the application UI, I've
  added two protected members to allow this support to be in the base class.
  If there is a hook procedure, it gets first chance at all messages except
  WM_INITDIALOG.  If it returns TRUE, we do no further processing, otherwise
  we will call the various overrides, if applicable.

  For WM_INITDIALOG, we call any overrides first.  The derived class' OnInit
  procedure can then supply an LPARAM for the hook procedure (e.g., a pointer
  to some relevant class member), if desired.  We handle the returns from the
  calls so that if either an override or the hook procedure states it has
  altered the focus, we return the appropriate value.  This is pretty standard
  handling for dialog hooks, so it should serve well, and it's almost 0 code.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version
  12-11-96  a-robkj@microsoft.com   Added hook procedure support

******************************************************************************/

#if !defined(DIALOG_STUFF)

#define DIALOG_STUFF

class CDialog {

    static INT_PTR CALLBACK    DialogProc(HWND hwndPage, UINT uMsg, WPARAM wp,
                                       LPARAM lp);
    int         m_idMain;
    BOOL        m_bIsModal;

protected:

    //  These should be protected (accessible only from derived classes)
    //  The instance is available for string table or other resource access

    HWND        m_hwndParent;
    HWND        m_hwnd;
    HINSTANCE   m_hiWhere;
    DLGPROC     m_dpHook;       //  Dialog Hook Procedure
    LPARAM      m_lpHook;       //  LPARAM for Hook WM_INITDIALOG call

public:

    //  Our constructor requires the resource ID and instance.  Not
    //  unreasonable for this project.

    CDialog(HINSTANCE hiWhere, int id, HWND hwndParent = NULL);
    CDialog(CDialog& cdOwner, int id);
    ~CDialog();

    //  Modal dialog box operation

    LONG    DoModal();

    //  Modeless dialog boxes- create and destroy.  We only allow one
    //  modeless DB per instance of this class.

    void    Create();   //  For modeless boxes
    void    Destroy();

    //  This allows us to adjust the position of a dialog in its parent window.
    //  We use only the left and top members of the given rectangle.

    void    Adjust(RECT& rc);

    //  Windows message overrides

    //  WM_COMMAND- control notifications.  We assure you can always get out
    //  of a modal dialog by pressing any button to make prototyping easy.

    virtual BOOL OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl) {
        //  Call EndDialog for all BN_CLICKED messages on Modal boxes
        if  (m_bIsModal && wNotifyCode == BN_CLICKED)
            EndDialog(m_hwnd, wid);
        return  FALSE;
    }

    //  WM_NOTIFY- common control notifications

    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh) {
        return  FALSE;
    }

    //  WM_INITDIALOG- before being called, this and m_hwnd will be valid.

    virtual BOOL    OnInit() { return TRUE; }

    //  WM_HELP and WM_CONTEXTMENU- for context-sensitive help.

    virtual BOOL    OnHelp(LPHELPINFO pHelp) { return TRUE; }
    virtual BOOL    OnContextMenu(HWND hwnd) { return TRUE; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\appui.cpp ===
/******************************************************************************

  Source File:  AppUI.CPP

  This file implements the Application UI.  This consists of two (ANSI/UNICODE)
  functions that allow an application to specify profiles to be used, and so
  forth.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  12-11-96  a-robkj@microsoft.com   Created it

******************************************************************************/

#include    "ICMUI.H"

CONST DWORD ApplicationUIHelpIds[] = {
    ApplyButton,          IDH_ICMUI_APPLY,
    EnableICM,            IDH_APPUI_ICM,
    EnableBasic,          IDH_APPUI_BASIC,
    EnableProofing,       IDH_APPUI_PROOF,
    MonitorProfile,       IDH_APPUI_MONITOR,
    MonitorProfileLabel,  IDH_APPUI_MONITOR,
    PrinterProfile,       IDH_APPUI_PRINTER,
    PrinterProfileLabel,  IDH_APPUI_PRINTER,
    RenderingIntent,      IDH_APPUI_INTENT,
    RenderingIntentLabel, IDH_APPUI_INTENT,
    TargetProfile,        IDH_APPUI_EMULATE,
    TargetProfileLabel,   IDH_APPUI_EMULATE,
    TargetIntent,         IDH_APPUI_INTENT,
    TargetIntentLabel,    IDH_APPUI_INTENT,
#if !defined(_WIN95_) // context-sentitive help
//  SourceProfile,        IDH_APPUI_SOURCE,
    SourceProfileLabel,   IDH_APPUI_SOURCE,
#endif
    0, 0
};

class   CColorMatchDialog : public CDialog {

    BOOL            m_bSuccess, m_bEnableICM, m_bEnableProofing, m_bColorPrinter;

    CString         m_csSource, m_csMonitor, m_csPrinter,
                    m_csMonitorProfile, m_csPrinterProfile, m_csTargetProfile;

    CString         m_csMonitorDisplayName; // since displayName != deviceName for monitor.

    CStringArray    m_csaMonitor, m_csaPrinter, m_csaTarget;
    CStringArray    m_csaMonitorDesc, m_csaPrinterDesc, m_csaTargetDesc;

    //  For handy reference (from Setup structure)

    DWORD   m_dwRenderIntent, m_dwProofIntent;

    //  To reduce stack usage and code size

    HWND    m_hwndRenderIntent, m_hwndTargetIntent, m_hwndMonitorList,
            m_hwndPrinterList, m_hwndTargetList, m_hwndIntentText1,
            m_hwndIntentLabel, m_hwndTargetProfileLabel, m_hwndTargetIntentLabel,
            m_hwndMonitorProfileLabel, m_hwndPrinterProfileLabel;

    //  For Apply callback

    PCMSCALLBACK m_dpApplyCallback;
    LPARAM       m_lpApplyCallback;

    //  To identify callee

    BOOL    m_bAnsiCall;

    //  Display profile description or filename

    BOOL    m_bUseProfileDescription;

    //  Intent control

    BOOL    m_bDisableIntent, m_bDisableRenderIntent;

    // Pointer to COLORMATCHSETUP[A|W]

    PVOID   m_pvCMS;

    void    Fail(DWORD dwError);
    BOOL    GoodParms(PCOLORMATCHSETUP pcms);
    void    CompleteInitialization();
    void    UpdateControls(BOOL bChanged = FALSE);

    void    FillStructure(COLORMATCHSETUPA *pcms);
    void    FillStructure(COLORMATCHSETUPW *pcms);

    void    EnableApplyButton(BOOL bEnable = TRUE);

public:

    CColorMatchDialog(COLORMATCHSETUPA *pcms);
    CColorMatchDialog(COLORMATCHSETUPW *pcms);

    ~CColorMatchDialog() {
        m_csaMonitor.Empty();
        m_csaPrinter.Empty();
        m_csaTarget.Empty();
        m_csaMonitorDesc.Empty();
        m_csaPrinterDesc.Empty();
        m_csaTargetDesc.Empty();
        m_csSource.Empty();
        m_csMonitor.Empty();
        m_csPrinter.Empty();
        m_csMonitorProfile.Empty();
        m_csPrinterProfile.Empty();
        m_csTargetProfile.Empty();
        m_csMonitorDisplayName.Empty();
    }

    BOOL    Results() const { return m_bSuccess; }

    virtual BOOL    OnInit();

    virtual BOOL OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);

    virtual BOOL OnHelp(LPHELPINFO pHelp);
    virtual BOOL OnContextMenu(HWND hwnd);
};

//  Record a failure

void    CColorMatchDialog::Fail(DWORD dwError) {
    SetLastError(dwError);
    m_bSuccess = FALSE;
}

//  Report input parameter validity

BOOL    CColorMatchDialog::GoodParms(PCOLORMATCHSETUP pcms) {

    m_bSuccess = TRUE;

    if  (!pcms || pcms -> dwVersion != COLOR_MATCH_VERSION ||
         pcms -> dwSize != sizeof *pcms || !pcms -> pMonitorProfile ||
         !pcms -> pPrinterProfile || !pcms -> pTargetProfile ||
         !pcms -> ccMonitorProfile || !pcms -> ccPrinterProfile ||
         !pcms -> ccTargetProfile) {
        Fail(ERROR_INVALID_PARAMETER);
        return  FALSE;
    }

    if  (pcms -> dwFlags & CMS_USEHOOK && !pcms -> lpfnHook)
        Fail(ERROR_INVALID_PARAMETER);

    if  (pcms -> dwFlags & CMS_USEAPPLYCALLBACK && !pcms -> lpfnApplyCallback)
        Fail(ERROR_INVALID_PARAMETER);

    if  (pcms -> dwFlags & CMS_SETRENDERINTENT &&
         pcms -> dwRenderIntent > INTENT_ABSOLUTE_COLORIMETRIC)
         Fail(ERROR_INVALID_PARAMETER);

    if  (pcms -> dwFlags & CMS_SETPROOFINTENT &&
         pcms -> dwFlags & CMS_ENABLEPROOFING &&
         pcms -> dwProofingIntent > INTENT_ABSOLUTE_COLORIMETRIC)
         Fail(ERROR_INVALID_PARAMETER);

    //  Setup the hooking, if needed

    if  (pcms -> dwFlags & CMS_USEHOOK) {
        m_dpHook = pcms -> lpfnHook;
        m_lpHook = pcms -> lParam;
    }

    //  Setup the callback for apply, if needed

    if  (pcms -> dwFlags & CMS_USEAPPLYCALLBACK) {
        m_dpApplyCallback = pcms -> lpfnApplyCallback;
        m_lpApplyCallback = pcms -> lParamApplyCallback;
    } else {
        m_dpApplyCallback = NULL;
        m_lpApplyCallback = 0L;
    }

    //  Cache the flags...

    DWORD   dwFlags = pcms -> dwFlags;

    //  Init the intents

    m_dwRenderIntent = (dwFlags & CMS_SETRENDERINTENT) ?
        pcms -> dwRenderIntent : INTENT_PERCEPTUAL;

    m_dwProofIntent = (dwFlags & CMS_SETPROOFINTENT) && (dwFlags & CMS_ENABLEPROOFING) ?
        pcms -> dwProofingIntent : m_dwRenderIntent;

    //  Init the flags

    m_bEnableICM = !(dwFlags & CMS_DISABLEICM);
    m_bEnableProofing = !!(dwFlags & CMS_ENABLEPROOFING);

    m_bUseProfileDescription = !!(dwFlags & CMS_USEDESCRIPTION);

    m_bDisableIntent = !!(dwFlags & CMS_DISABLEINTENT);
    m_bDisableRenderIntent = !!(dwFlags & CMS_DISABLERENDERINTENT);

    //  Init the pointer to buffer

    m_pvCMS = (PVOID) pcms;

    return  m_bSuccess;
}

//  Encoding-independent construction actions

void    CColorMatchDialog::CompleteInitialization() {

    //  Determine the appropriate source, monitor and printer names

    if  (m_csSource.IsEmpty())
        m_csSource.Load(DefaultSourceString);

    //  Check the validation for monitor name.

    CMonitorList    cml;
    cml.Enumerate();

    if  (!cml.IsValidDeviceName(m_csMonitor)) {

        // Get primary device.

        m_csMonitor = cml.PrimaryDeviceName();
    }

    //  Map display name from device name

    m_csMonitorDisplayName = cml.DeviceNameToDisplayName(m_csMonitor);

    //  Check the validation for printer name.

    HANDLE hPrinter;

    if  (!m_csPrinter.IsEmpty() && OpenPrinter(m_csPrinter,&hPrinter,NULL)) {

        // The specified printer has been found.

        ClosePrinter(hPrinter);

    } else {

        //  The specified printer has not been found,
        //  Get the default printer name- do it the old, slimy way...

        TCHAR   acBuffer[MAX_PATH];

        GetProfileString(_TEXT("Windows"), _TEXT("Device"), _TEXT(""),
            acBuffer, MAX_PATH);

        //  The buffer will contains "PrinterName,DriverName,Port".
        //  What we need is only printer name.

        TCHAR *pTmp = acBuffer;

        while (*pTmp) {
            if (*pTmp == __TEXT(',')) {
                *pTmp = NULL;
                break;
            }
            pTmp++;
        }

        m_csPrinter = acBuffer;
    }

    if  (CGlobals::ThisIsAColorPrinter(m_csPrinter))
        m_bColorPrinter = TRUE;
     else
        m_bColorPrinter = FALSE;

    //  Now, we collect the names

    ENUMTYPE et = { sizeof et, ENUM_TYPE_VERSION, (ET_DEVICENAME|ET_DEVICECLASS) };

    //  Enumrate monitor.

    et.pDeviceName   = m_csMonitor;
    et.dwDeviceClass = CLASS_MONITOR;
    CProfile::Enumerate(et, m_csaMonitor, m_csaMonitorDesc);

    //  Enumrate only for Color Printer.

    if (m_bColorPrinter) {
        et.pDeviceName   = m_csPrinter;
        et.dwDeviceClass = CLASS_PRINTER;
        CProfile::Enumerate(et, m_csaPrinter, m_csaPrinterDesc);
    } else {
        m_csaPrinter.Empty();
        m_csaPrinterDesc.Empty();
    }

    et.dwFields = 0;

    CProfile::Enumerate(et, m_csaTarget, m_csaTargetDesc);

    //  Fix up the default names for the profiles

    if  (m_csaPrinter.Map(m_csPrinterProfile) == m_csaPrinter.Count())
    {
        _RPTF2(_CRT_WARN, "Printer Profile %s isn't associated with "
            "the monitor (%s)", (LPCTSTR) m_csPrinterProfile,
            (LPCTSTR) m_csPrinter);
        if (m_csaPrinter.Count())
        {
            m_csPrinterProfile = m_csaPrinter[0];
        }
        else
        {
            m_csPrinterProfile = (LPCTSTR) NULL;
        }
    }

    if  (m_csaMonitor.Map(m_csMonitorProfile) == m_csaMonitor.Count())
    {
        _RPTF2(_CRT_WARN, "Monitor Profile %s isn't associated with "
            "the monitor (%s)", (LPCTSTR) m_csMonitorProfile,
            (LPCTSTR) m_csMonitor);
        if (m_csaMonitor.Count())
        {
            m_csMonitorProfile = m_csaMonitor[0];
        }
        else
        {
            m_csMonitorProfile = (LPCTSTR) NULL;
        }
    }

    //  If the target profile name is invalid, use the printer profile

    if  (m_csaTarget.Map(m_csTargetProfile) == m_csaTarget.Count())
    {
        _RPTF1(_CRT_WARN, "Target Profile %s isn't installed",
            (LPCTSTR) m_csTargetProfile);
        if (m_csaPrinter.Count())
        {
            m_csTargetProfile = m_csaPrinter[0];
        }
        else
        {
            // And then, there is no printer profile, it will
            // be Windows color space profile.

            TCHAR TargetProfileName[MAX_PATH];
            DWORD dwSize = MAX_PATH;

            if (GetStandardColorSpaceProfile(NULL,LCS_WINDOWS_COLOR_SPACE,TargetProfileName,&dwSize)) {
                m_csTargetProfile = (LPCTSTR) TargetProfileName;
                m_csTargetProfile = (LPCTSTR) m_csTargetProfile.NameAndExtension();
            } else {
                m_csTargetProfile = (LPCTSTR) NULL;
            }
        }
    }
}

//  Update the controls

void    CColorMatchDialog::UpdateControls(BOOL bChanged) {

    //  Switch Proofing Controls based on setting

    ShowWindow(m_hwndIntentText1, m_bEnableProofing && m_bEnableICM ? SW_SHOWNORMAL : SW_HIDE);

    EnableWindow(m_hwndTargetProfileLabel, m_bEnableProofing && m_bEnableICM);
    EnableWindow(m_hwndTargetList, m_bEnableProofing && m_bEnableICM);

    EnableWindow(m_hwndTargetIntentLabel, m_bEnableProofing && m_bEnableICM && !m_bDisableIntent);
    EnableWindow(m_hwndTargetIntent, m_bEnableProofing && m_bEnableICM && !m_bDisableIntent);

    //  Switch the other Controls, as well...

    EnableWindow(m_hwndMonitorProfileLabel, m_bEnableICM);
    EnableWindow(m_hwndMonitorList, m_bEnableICM);

    EnableWindow(m_hwndPrinterProfileLabel, m_bEnableICM && !m_csPrinter.IsEmpty());
    EnableWindow(m_hwndPrinterList, m_bEnableICM && m_bColorPrinter && !m_csPrinter.IsEmpty());

    if (m_bEnableProofing) {
        EnableWindow(m_hwndIntentLabel, m_bEnableICM && !m_bDisableIntent && !m_bDisableRenderIntent);
        EnableWindow(m_hwndRenderIntent, m_bEnableICM && !m_bDisableIntent && !m_bDisableRenderIntent);
    } else {
        EnableWindow(m_hwndIntentLabel, m_bEnableICM && !m_bDisableIntent);
        EnableWindow(m_hwndRenderIntent, m_bEnableICM && !m_bDisableIntent);
    }

    EnableWindow(GetDlgItem(m_hwnd, EnableBasic), m_bEnableICM);
    EnableWindow(GetDlgItem(m_hwnd, EnableProofing), m_bEnableICM);

    EnableApplyButton(bChanged);
}

//  Update the Apply buttom

void    CColorMatchDialog::EnableApplyButton(BOOL bEnable) {

    EnableWindow(GetDlgItem(m_hwnd, ApplyButton), bEnable);

}

//  Flags for buffer overflow (combined)

#define BAD_BUFFER_FLAGS    (CMS_MONITOROVERFLOW | CMS_PRINTEROVERFLOW | \
                             CMS_TARGETOVERFLOW)

//  By moving the ANSI / Unicode issues into the CString class
//  it becomes feasible to code these two versions so they look
//  encoding-independent.  In other words, the code for both
//  of these versions is written identically, and the compiler
//  does all the work, just like it ought to...

void CColorMatchDialog::FillStructure(COLORMATCHSETUPA *pcms) {

    if  (m_bEnableICM) {

        pcms -> dwFlags = CMS_SETRENDERINTENT | CMS_SETPRINTERPROFILE |
                          CMS_SETMONITORPROFILE;

        pcms -> dwRenderIntent = m_dwRenderIntent;

        //  03-20-1997  Bob_Kjelgaard@Prodigy.Net   RAID 21091 (Memphis)
        //  Don't fail if there is no monitor or printer profile.  Set
        //  them to an empty string and succeed, instead.
        //  We can always do this, because 0 counts and empty pointers
        //  have already been screened out.

        if  (m_csMonitorProfile.IsEmpty())
            pcms -> pMonitorProfile[0] = '\0';
        else {
            lstrcpynA(pcms -> pMonitorProfile, m_csMonitorProfile,
                pcms -> ccMonitorProfile);
            if  (lstrcmpA(pcms -> pMonitorProfile, m_csMonitorProfile))
                pcms -> dwFlags |= CMS_MONITOROVERFLOW;
        }

        if  (m_csPrinterProfile.IsEmpty() || !m_bColorPrinter)
            pcms -> pPrinterProfile[0] = '\0';
        else {
            lstrcpynA(pcms -> pPrinterProfile, m_csPrinterProfile,
                pcms -> ccPrinterProfile);

            if  (lstrcmpA(pcms -> pPrinterProfile, m_csPrinterProfile))
                pcms -> dwFlags |= CMS_PRINTEROVERFLOW;
        }

        if  (m_bEnableProofing) {
            pcms -> dwFlags |=
                CMS_ENABLEPROOFING | CMS_SETTARGETPROFILE;
            pcms -> dwProofingIntent = m_dwProofIntent;
            lstrcpynA(pcms -> pTargetProfile, m_csTargetProfile,
                pcms -> ccTargetProfile);
            if  (lstrcmpA(pcms -> pTargetProfile, m_csTargetProfile))
                pcms -> dwFlags |= CMS_TARGETOVERFLOW;
        } else {
            pcms -> pTargetProfile[0] = '\0';
        }

        if  (pcms -> dwFlags & BAD_BUFFER_FLAGS)
            Fail(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        pcms -> dwFlags = CMS_DISABLEICM;   //  No other flags are valid!
        pcms -> pMonitorProfile[0] = '\0';  //  No color profiles are choosed
        pcms -> pPrinterProfile[0] = '\0';
        pcms -> pTargetProfile[0]  = '\0';
    }
}

void CColorMatchDialog::FillStructure(COLORMATCHSETUPW *pcms) {

    if  (m_bEnableICM) {

        pcms -> dwFlags = CMS_SETRENDERINTENT | CMS_SETPRINTERPROFILE |
                          CMS_SETMONITORPROFILE;

        pcms -> dwRenderIntent = m_dwRenderIntent;

        //  03-20-1997  Bob_Kjelgaard@Prodigy.Net   RAID 21091 (Memphis)
        //  Don't fail if there is no monitor or printer profile.  Set
        //  them to an empty string and succeed, instead.
        //  We can always do this, because 0 counts and empty pointers
        //  have already been screened out.

        if  (m_csMonitorProfile.IsEmpty())
            pcms -> pMonitorProfile[0] = '\0';
        else {
            lstrcpynW(pcms -> pMonitorProfile, m_csMonitorProfile,
                pcms -> ccMonitorProfile);
            if  (lstrcmpW(pcms -> pMonitorProfile, m_csMonitorProfile))
                pcms -> dwFlags |= CMS_MONITOROVERFLOW;
        }

        if  (m_csPrinterProfile.IsEmpty() || !m_bColorPrinter)
            pcms -> pPrinterProfile[0] = '\0';
        else {
            lstrcpynW(pcms -> pPrinterProfile, m_csPrinterProfile,
                pcms -> ccPrinterProfile);

            if  (lstrcmpW(pcms -> pPrinterProfile, m_csPrinterProfile))
                pcms -> dwFlags |= CMS_PRINTEROVERFLOW;
        }

        if  (m_bEnableProofing) {
            pcms -> dwFlags |=
                CMS_ENABLEPROOFING | CMS_SETTARGETPROFILE | CMS_SETPROOFINTENT;
            pcms -> dwProofingIntent = m_dwProofIntent;
            lstrcpynW(pcms -> pTargetProfile, m_csTargetProfile,
                pcms -> ccTargetProfile);
            if  (lstrcmpW(pcms -> pTargetProfile, m_csTargetProfile))
                pcms -> dwFlags |= CMS_TARGETOVERFLOW;
        } else {
            pcms -> pTargetProfile[0] = '\0';
        }

        if  (pcms -> dwFlags & BAD_BUFFER_FLAGS)
            Fail(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        pcms -> dwFlags = CMS_DISABLEICM;   //  No other flags are valid!
        pcms -> pMonitorProfile[0] = '\0';  //  No color profiles are choosed
        pcms -> pPrinterProfile[0] = '\0';
        pcms -> pTargetProfile[0]  = '\0';
    }
}

CColorMatchDialog::CColorMatchDialog(COLORMATCHSETUPA *pcms) :
    CDialog(CGlobals::Instance(), ApplicationUI, pcms -> hwndOwner) {

    if  (!GoodParms((PCOLORMATCHSETUP) pcms))
        return;

    //  Make sure we've initialized these, if we have to.

    if  (pcms -> dwFlags & CMS_SETMONITORPROFILE)
        m_csMonitorProfile = pcms -> pMonitorProfile;

    if  (pcms -> dwFlags & CMS_SETPRINTERPROFILE)
        m_csPrinterProfile = pcms -> pPrinterProfile;

    if  (pcms -> dwFlags & CMS_SETTARGETPROFILE)
        m_csTargetProfile = pcms -> pTargetProfile;

    m_csSource  = pcms -> pSourceName;
    m_csMonitor = pcms -> pDisplayName;
    m_csPrinter = pcms -> pPrinterName;

    //  Ansi version call

    m_bAnsiCall = TRUE;

    CompleteInitialization();

    //  Display the UI, and watch what happens...

    switch  (DoModal()) {

        case    IDOK:
            if  (!m_bSuccess)
                return;

            // Fill up return buffer.

            FillStructure(pcms);
            return;

        case    IDCANCEL:
            Fail(ERROR_SUCCESS);
            return;

        default:
            Fail(GetLastError());
    }
}

CColorMatchDialog::CColorMatchDialog(COLORMATCHSETUPW *pcms) :
    CDialog(CGlobals::Instance(), ApplicationUI, pcms -> hwndOwner) {

    if  (!GoodParms((PCOLORMATCHSETUP) pcms))
        return;

    //  Make sure we've initialized these, if we have to.

    if  (pcms -> dwFlags & CMS_SETMONITORPROFILE) {
        m_csMonitorProfile = pcms -> pMonitorProfile;
        m_csMonitorProfile = m_csMonitorProfile.NameAndExtension();
    }

    if  (pcms -> dwFlags & CMS_SETPRINTERPROFILE) {
        m_csPrinterProfile = pcms -> pPrinterProfile;
        m_csPrinterProfile = m_csPrinterProfile.NameAndExtension();
    }

    if  (pcms -> dwFlags & CMS_SETTARGETPROFILE) {
        m_csTargetProfile = pcms -> pTargetProfile;
        m_csTargetProfile = m_csTargetProfile.NameAndExtension();
    }

    m_csSource  = pcms -> pSourceName;
    m_csMonitor = pcms -> pDisplayName;
    m_csPrinter = pcms -> pPrinterName;

    //  Unicode version call

    m_bAnsiCall = FALSE;

    CompleteInitialization();

    //  Display the UI, and watch what happens...

    switch  (DoModal()) {

        case    IDOK:
            if  (!m_bSuccess)
                return;

            // Fill up return buffer.

            FillStructure(pcms);
            return;

        case    IDCANCEL:
            Fail(ERROR_SUCCESS);
            return;

        default:
            Fail(GetLastError());
    }
}

//  Dialog initialization function

BOOL    CColorMatchDialog::OnInit() {

    //  Collect the common handles

    m_hwndRenderIntent = GetDlgItem(m_hwnd, RenderingIntent);
    m_hwndTargetIntent = GetDlgItem(m_hwnd, TargetIntent);
    m_hwndPrinterList = GetDlgItem(m_hwnd, PrinterProfile);
    m_hwndMonitorList = GetDlgItem(m_hwnd, MonitorProfile);
    m_hwndTargetList = GetDlgItem(m_hwnd, TargetProfile);

    m_hwndMonitorProfileLabel = GetDlgItem(m_hwnd, MonitorProfileLabel);
    m_hwndPrinterProfileLabel = GetDlgItem(m_hwnd, PrinterProfileLabel);
    m_hwndIntentLabel = GetDlgItem(m_hwnd, RenderingIntentLabel);
    m_hwndTargetProfileLabel = GetDlgItem(m_hwnd, TargetProfileLabel);
    m_hwndTargetIntentLabel = GetDlgItem(m_hwnd, TargetIntentLabel);

    m_hwndIntentText1 = GetDlgItem(m_hwnd, RenderingIntentText1);

    //  Fill in the source name
    SetDlgItemText(m_hwnd, SourceProfile, m_csSource);

    //  Set the Check Boxes

    CheckDlgButton(m_hwnd, EnableICM,
        m_bEnableICM ? BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(m_hwnd, EnableBasic,
        m_bEnableProofing ? BST_UNCHECKED : BST_CHECKED);
    CheckDlgButton(m_hwnd, EnableProofing,
        m_bEnableProofing ? BST_CHECKED : BST_UNCHECKED);

    //  Fill in the list(s) of Rendering Intents

    CString csWork; //  There's plenty of it to do...

    for (int i = INTENT_PERCEPTUAL; i <= INTENT_ABSOLUTE_COLORIMETRIC; i++) {
        csWork.Load(i + PerceptualString);
        SendMessage(m_hwndRenderIntent, CB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) csWork);
        SendMessage(m_hwndTargetIntent, CB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) csWork);
    }

    //  Init the rendering intents

    SendMessage(m_hwndRenderIntent, CB_SETCURSEL, m_dwRenderIntent, 0);
    SendMessage(m_hwndTargetIntent, CB_SETCURSEL, m_dwProofIntent, 0);

    //  Init the profile lists

    //  03-20-1997    Bob_Kjelgaard@Prodigy.Net   RAID Memphis:22213
    //  The algorithm used to determine which profile to select was incorrect.
    //  There's a much simpler and direct way, anyway.

    LRESULT id;

    //  Target Profiles

    for (unsigned u = 0; u < m_csaTarget.Count(); u++) {
        if (m_bUseProfileDescription) {
            id = SendMessage(m_hwndTargetList, CB_ADDSTRING,
                             0, (LPARAM)((LPTSTR) m_csaTargetDesc[u]));
        } else {
            id = SendMessage(m_hwndTargetList, CB_ADDSTRING,
                             0, m_csaTarget[u].NameOnly());
        }
        SendMessage(m_hwndTargetList, CB_SETITEMDATA, id, u);

        if (m_csaTarget[u].IsEqualString(m_csTargetProfile)) {
            SendMessage(m_hwndTargetList, CB_SETCURSEL, id, 0);
        }
    }

    //  Set Target profile if specified, otherwise the default

    if  (!m_csaTarget.Count()) {
        CString csWork;
        csWork.Load(NoProfileString);

        SendMessage(m_hwndTargetList, CB_ADDSTRING, 0, csWork);
        SendMessage(m_hwndTargetList, CB_SETITEMDATA, 0, -1);
        SendMessage(m_hwndTargetList, CB_SETCURSEL, 0, 0);
    }

    //  Monitor Profiles

    //  03-20-1997  Bob_Kjelgaard@Prodigy.Net   Memphis RAID #22289

    csWork.Load(GetDlgItem(m_hwnd, MonitorProfileLabel));
    csWork = csWork + m_csMonitorDisplayName + _TEXT(")");
    SetDlgItemText(m_hwnd, MonitorProfileLabel, csWork);

    for (u = 0; u < m_csaMonitor.Count(); u++) {
        if (m_bUseProfileDescription) {
            id = SendMessage(m_hwndMonitorList, CB_ADDSTRING,
                             0, (LPARAM)((LPTSTR) m_csaMonitorDesc[u]));
        } else {
            id = SendMessage(m_hwndMonitorList, CB_ADDSTRING,
                             0, m_csaMonitor[u].NameOnly());
        }
        SendMessage(m_hwndMonitorList, CB_SETITEMDATA, id, u);

        if (m_csaMonitor[u].IsEqualString(m_csMonitorProfile)) {
            SendMessage(m_hwndMonitorList, CB_SETCURSEL, id, 0);
        }
    }

    //  Set Monitor profile if specified

    if  (!m_csaMonitor.Count()) {
        CString csWork;
        csWork.Load(NoProfileString);

        SendMessage(m_hwndMonitorList, CB_ADDSTRING, 0, csWork);
        SendMessage(m_hwndMonitorList, CB_SETITEMDATA, 0, -1);
        SendMessage(m_hwndMonitorList, CB_SETCURSEL, 0, 0);
    }

    //  Printer Profiles

    //  03-20-1997  Bob_Kjelgaard@Prodigy.Net   RAID Memphis:22290
    //  If there's no printer, then we should disable all of the related
    //  controls.

    if  (m_csPrinter.IsEmpty()) {
        csWork.Load(NoPrintersInstalled);
    } else {
        csWork.Load(GetDlgItem(m_hwnd, PrinterProfileLabel));
        csWork = csWork + m_csPrinter + _TEXT(")");
    }

    SetDlgItemText(m_hwnd, PrinterProfileLabel, csWork);

    for (u = 0; u < m_csaPrinter.Count(); u++) {
        if (m_bUseProfileDescription) {
            id = SendMessage(m_hwndPrinterList, CB_ADDSTRING,
                             0, (LPARAM)((LPTSTR) m_csaPrinterDesc[u]));
        } else {
            id = SendMessage(m_hwndPrinterList, CB_ADDSTRING,
                             0, m_csaPrinter[u].NameOnly());
        }
        SendMessage(m_hwndPrinterList, CB_SETITEMDATA, id, u);

        if (m_csaPrinter[u].IsEqualString(m_csPrinterProfile)) {
            SendMessage(m_hwndPrinterList, CB_SETCURSEL, id, 0);
        }
    }

    //  Set Printer profile if specified

    if  (!m_csaPrinter.Count()) {
        CString csWork;

        if (!m_csPrinter.IsEmpty() && !m_bColorPrinter) {
            // Printer are specified, but it is not color printer.
            csWork.Load(NotColorPrinter);
        } else {
            csWork.Load(NoProfileString);
        }

        SendMessage(m_hwndPrinterList, CB_ADDSTRING, 0, csWork);
        SendMessage(m_hwndPrinterList, CB_SETITEMDATA, 0, -1);
        SendMessage(m_hwndPrinterList, CB_SETCURSEL, 0, 0);
    }

    //  End RAID Memphis:22213, 22289, 22290 03-20-1997

    //  If Apply callback does not provided, disable apply button.

    if  (m_dpApplyCallback == NULL) {
        RECT  rcApply, rcCancel;
        POINT ptApply, ptCancel;

        // Get current "Apply" and "Cancel" buttom position

        GetWindowRect(GetDlgItem(m_hwnd, ApplyButton), &rcApply);
        GetWindowRect(GetDlgItem(m_hwnd, IDCANCEL), &rcCancel);

        // Convert the buttom coordinate to parent dialog coord from screen coord.

        ptApply.x = rcApply.left;   ptApply.y = rcApply.top;
        ptCancel.x = rcCancel.left; ptCancel.y = rcCancel.top;

        ScreenToClient(m_hwnd,&ptApply);
        ScreenToClient(m_hwnd,&ptCancel);

        // Move "Apply" button away... and shift "Cancel" and "OK"

        MoveWindow(GetDlgItem(m_hwnd, ApplyButton),0,0,0,0,TRUE);
        MoveWindow(GetDlgItem(m_hwnd, IDCANCEL),
                   ptApply.x,ptApply.y,
                   rcApply.right - rcApply.left,
                   rcApply.bottom - rcApply.top,TRUE);
        MoveWindow(GetDlgItem(m_hwnd, IDOK),
                   ptCancel.x,ptCancel.y,
                   rcCancel.right - rcCancel.left,
                   rcCancel.bottom - rcCancel.top,TRUE);
    }

    //  Enable/Disable controls based upon settings

    UpdateControls(FALSE);

    return  FALSE;  //  Because we've probably moved it...
}

//  Command Processing override

BOOL CColorMatchDialog::OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl) {

    switch  (wNotifyCode) {

        case    BN_CLICKED:

            switch  (wid) {

                case    EnableICM:
                    m_bEnableICM = !m_bEnableICM;
                    UpdateControls(TRUE);
                    return  TRUE;

                case    EnableBasic:

                    if (m_bEnableProofing)
                    {
                        m_bEnableProofing = FALSE;

                        // Copy proof intent to rendering intent
                        //
                        m_dwRenderIntent = m_dwProofIntent;

                        // Update UI
                        //
                        SendMessage(m_hwndTargetIntent, CB_SETCURSEL,
                            m_dwProofIntent, 0);
                        SendMessage(m_hwndRenderIntent, CB_SETCURSEL,
                            m_dwRenderIntent, 0);
                        UpdateControls(TRUE);
                    }
                    return TRUE;

                case    EnableProofing:

                    if (m_bEnableProofing == FALSE)
                    {
                        m_bEnableProofing = TRUE;

                        //  Copy the original rendering intent to the proofing
                        //  intent, and set original to Absolute Colorimetric

                        m_dwProofIntent = m_dwRenderIntent;
                        m_dwRenderIntent = INTENT_ABSOLUTE_COLORIMETRIC;

                        // Update UI
                        //
                        SendMessage(m_hwndTargetIntent, CB_SETCURSEL,
                            m_dwProofIntent, 0);
                        SendMessage(m_hwndRenderIntent, CB_SETCURSEL,
                            m_dwRenderIntent, 0);
                        UpdateControls(TRUE);
                    }
                    return  TRUE;

                case ApplyButton: {

                    // Disable apply button

                    EnableApplyButton(FALSE);

                    // Callback supplied function

                    if (m_dpApplyCallback) {

                        if (m_bAnsiCall) {
                            PCOLORMATCHSETUPA pcms = (PCOLORMATCHSETUPA) m_pvCMS;

                            FillStructure(pcms);
                            (*(PCMSCALLBACKA)m_dpApplyCallback)(pcms,m_lpApplyCallback);
                        } else {
                            PCOLORMATCHSETUPW pcms = (PCOLORMATCHSETUPW) m_pvCMS;

                            FillStructure(pcms);
                            (*(PCMSCALLBACKW)m_dpApplyCallback)(pcms,m_lpApplyCallback);
                        }
                    }

                    return TRUE;
                }
            }

            break;

        case    CBN_SELCHANGE: {

            DWORD idItem = (DWORD)SendMessage(hwndCtl, CB_GETCURSEL, 0, 0);
            unsigned uItem = (unsigned)SendMessage(hwndCtl, CB_GETITEMDATA, idItem, 0);

            switch  (wid) {

                case    RenderingIntent:

                    if (m_dwRenderIntent != idItem)
                    {
                        m_dwRenderIntent = idItem;

                        // If proofing is disabled, proof intent follows
                        // render intent

                        if (! m_bEnableProofing)
                        {
                            m_dwProofIntent = idItem;
                            SendMessage(m_hwndTargetIntent, CB_SETCURSEL,
                                        m_dwProofIntent, 0);
                        }

                        EnableApplyButton();
                    }

                    return  TRUE;

                case    TargetIntent:

                    if (m_dwProofIntent != idItem)
                    {
                        m_dwProofIntent = idItem;

                        EnableApplyButton();
                    }

                    return  TRUE;

                case    TargetProfile:

                    //  If there are no installed profiles, don't bother

                    if  (!m_csaTarget.Count())
                        return  TRUE;

                    if (m_csTargetProfile.IsEqualString(m_csaTarget[uItem]) == FALSE)
                    {
                        m_csTargetProfile = m_csaTarget[uItem];

                        EnableApplyButton();
                    }

                    return  TRUE;

                case    MonitorProfile:

                    //  If there are no installed profiles, don't bother

                    if  (!m_csaMonitor.Count())
                        return  TRUE;

                    if (m_csMonitorProfile.IsEqualString(m_csaMonitor[uItem]) == FALSE)
                    {
                        m_csMonitorProfile = m_csaMonitor[uItem];

                        EnableApplyButton();
                    }

                    return  TRUE;

                case    PrinterProfile:

                    //  If there are no installed profiles, don't bother

                    if  (!m_csaPrinter.Count())
                        return  TRUE;

                    if (m_csPrinterProfile.IsEqualString(m_csaPrinter[uItem]) == FALSE)
                    {
                        m_csPrinterProfile = m_csaPrinter[uItem];

                        EnableApplyButton();
                    }

                    return  TRUE;
            }

        }

    }

    //  Pass anything we didn't handle above to the base class

    return  CDialog::OnCommand(wNotifyCode, wid, hwndCtl);

}

//  Context-sensitive help handler

BOOL CColorMatchDialog::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
                HELP_WM_HELP, (ULONG_PTR) (LPSTR) ApplicationUIHelpIds);
    }

    return (TRUE);
}

BOOL CColorMatchDialog::OnContextMenu(HWND hwnd) {

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) ApplicationUIHelpIds);

    return (TRUE);
}

//  This are the real honest-to-goodness API!

extern "C" BOOL WINAPI  SetupColorMatchingA(PCOLORMATCHSETUPA pcms) {

    CColorMatchDialog   ccmd(pcms);

    return  ccmd.Results();
}

extern "C" BOOL WINAPI  SetupColorMatchingW(PCOLORMATCHSETUPW pcms) {

    CColorMatchDialog   ccmd(pcms);

    return  ccmd.Results();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\adobe\jul98\test\main.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/****************************************************************************
*
*
*    PROGRAM: CmnDlg.c
*
*    PURPOSE: Sample demonstrating the use of the common dialogs in Windows
*
*    FUNCTIONS:
*
*        WinMain() - calls initialization function, processes message loop
*        InitApplication() - initializes window data and registers window
*        InitInstance() - saves instance handle and creates main window
*        MainWndProc() - processes messages
*        About() - processes messages for "About" dialog box
*        OpenNewFile() - opens a new file
*        SaveToFile() - saves the current text buffer to the current filename
*        SaveAs() - saves the current text buffer to a new file name
*        EnterNew() - to enter new text into the text buffer
*        FileOpenHookProc() - Hook procedure for GetOpenFileName() common dialog
*        FileSaveHookProc() - Hook procedure for GetSaveFileName() common dialog
*        ChooseFontHookProc() - Hook procedure for ChooseFont() common dialog
*        FindTextHookProc() - Hook procedure for FindText() common dialog
*        ReplaceTextHookProc() - Hook procedure for the ReplaceText() common dialog
*        PrintDlgHookProc() - Hook procedure for the PrintDlg() common dialog
*        PrintSetupHookProc() - Hook procedure for the PrintDlg() setup common dialog
*        SearchFile() - Searches for the specified text in the file buffer
*        ChooseNewFont() - chooses a new font for display
*        ChooseNewColor() - chooses a new color for display
*        PrintFile() - prints the current text in the file buffer
*        CallFindText() - calls the FindText() common dialog function
*        CallReplaceText() - calls the ReplaceText() common dialog function
*        ProcessCDError() - uses CommonDialogExtendedError() to output useful error messages
*
*    COMMENTS:
*
*
*        The common dialog APIs demonstrated in the sample include:
*
*            ChooseColor()
*            ChooseFont()
*            FindText()
*            GetOpenFileName()
*            GetSaveFileName()
*            PrintDlg()
*            ReplaceText()
*
*
*        Each dialog box is demonstrated being used in three different ways:
*        standard, using a modified template and using a hook function.
*
*
****************************************************************************/

#include <windows.h>    // includes basic windows functionality
#include <commdlg.h>    // includes common dialog functionality
#include <dlgs.h>       // includes common dialog template defines
#include <stdio.h>      // includes standard file i/o functionality
#include <string.h>     // includes string functions
#include <cderr.h>      // includes the common dialog error codes
#include "main.h"       // includes my common dialog functions
#include "resource.h"

HANDLE       hInst;
OPENFILENAME OpenFileName;
CHAR         szDirName[256]   = "";
CHAR         szFile[256]      = "\0";
CHAR         szFileTitle[256];

// Filter specification for the OPENFILENAME struct
// This is portable for i386 and MIPS
// Leaving out the \0 terminator will cause improper DWORD alignment
// and cause a failure under MIPS
CHAR szFilter[] = "Text Files (*.ICM)\0*.ICM\0All Files (*.*)\0*.*\0";
CHAR szSaveFilter[] = "Text Files (*.CSA)\0*.CSA\0All Files (*.*)\0*.*\0";

CHAR         FileBuf[FILE_LEN];
DWORD        dwFileSize;
UINT         FindReplaceMsg;
CHAR         szFindString[64]   = "";
CHAR         szReplaceString[64]   = "";
FINDREPLACE  frText;
LPFINDREPLACE lpFR;
CHAR *       lpBufPtr = FileBuf;
CHOOSEFONT   chf;
CHOOSECOLOR  chsclr;
COLORREF     crColor;
LOGFONT      lf;
WORD         wMode = IDM_CUSTOM;
WORD         wAsciiMode = IDM_ASCII;
WORD         wIntentMode = IDM_PERCEPUAL;
WORD         wCSAMode = IDM_AUTO;
WORD         wInpDrvClrSp = IDM_INP_AUTO;
WORD         wCSAorCRD = IDM_CSA;
HWND         hDlgFR = NULL;
PRINTDLG     pd;

BOOL         AllowBinary = FALSE;
DWORD        Intent = 0;
HWND         hWnd; 

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam);

/****************************************************************************
*
*    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
*
*    PURPOSE: calls initialization function, processes message loop
*
*    COMMENTS:
*
*
****************************************************************************/

int PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    MSG msg;                         /* message                      */

    if (!hPrevInstance)                  /* Other instances of app running? */
        if (!InitApplication(hInstance)) /* Initialize shared things */
            return (FALSE);              /* Exits if unable to initialize     */

    hInst = hInstance;

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    // register window message for FindText() and ReplaceText() hook procs
    FindReplaceMsg = RegisterWindowMessage( (LPSTR) FINDMSGSTRING );

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,        /* message structure                      */
            NULL,                  /* handle of window receiving the message */
            0,                     /* lowest message to examine              */
            0))                    /* highest message to examine             */
        if ( !hDlgFR || !IsWindow(hDlgFR) || !IsDialogMessage( hDlgFR, &msg ) )
            {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
            }
    return (msg.wParam);           /* Returns the value from PostQuitMessage */

    // avoid compiler warnings at W3
    lpCmdLine;
}


/****************************************************************************
*
*    FUNCTION: InitApplication(HANDLE)
*
*    PURPOSE: Initializes window data and registers window class
*
*    COMMENTS:
*
*        In this function, we initialize a window class by filling out a data
*        structure of type WNDCLASS and calling the Windows RegisterClass()
*        function.
*
****************************************************************************/

BOOL InitApplication(HANDLE hInstance)       /* current instance             */
{
    WNDCLASS  wc;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;                       /* Class style(s).                    */
    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = LoadIcon(NULL, IDI_ICON1);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName =  "CmnDlgMenu";   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "CmnDlgWClass"; /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}


/****************************************************************************
*
*    FUNCTION:  InitInstance(HANDLE, int)
*
*    PURPOSE:  Saves instance handle and creates main window
*
*    COMMENTS:
*
*        In this function, we save the instance handle in a static variable and
*        create and display the main program window.
*
****************************************************************************/

BOOL InitInstance(
    HANDLE          hInstance,          /* Current instance identifier.       */
    int             nCmdShow)           /* Param for first ShowWindow() call. */
{
    HWND            hWND;               /* Main window handle.                */

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    hWND = CreateWindow(
        "CmnDlgWClass",                 /* See RegisterClass() call.          */
        "CIEBASED_CDEF Color Space",    /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWND)
        return (FALSE);
     
    hWnd = hWND;
    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */
    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************
*
*    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages
*
*    COMMENTS:
*
*        This function processes all messags sent to the window.  When the
*        user choses one of the options from one of the menus, the command
*        is processed here and passed onto the function for that command.
*        This function also processes the special "FindReplace" message that
*        this application registers for hook processing of the FindText()
*        and ReplaceText() common dialog functions.
*
****************************************************************************/

LRESULT CALLBACK MainWndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    FARPROC lpProcAbout;          /* pointer to the "About" function */
    FARPROC lpProcOpen;
    FARPROC lpProcEnterNew;       /* pointer to the "EnterNew" function */
    HDC hDC;
    PAINTSTRUCT ps;
    INT nDrawX;
    INT nDrawY;
    HFONT hFont;
    HANDLE Handle;
    static BOOL NewFont;

    switch (message) {


        case WM_CREATE:
            //initialize the output on the screen
            strcpy( FileBuf, " ");
            lpBufPtr = FileBuf;
            dwFileSize = strlen(FileBuf);
            crColor = 0;
            NewFont = FALSE;
            break;


        case WM_PAINT:
            /* Set up a display context to begin painting */
            hDC = BeginPaint (hWnd, &ps);

            /* Initialize drawing position to 1/4 inch from the top  */
            /* and from the left of the top, left corner of the      */
            /* client area of the main windows.                      */
            nDrawX = GetDeviceCaps(hDC, LOGPIXELSX) / 4;   /* 1/4 inch */
            nDrawY = GetDeviceCaps(hDC, LOGPIXELSY) / 4;   /* 1/4 inch */

            if ( NewFont == TRUE )
            {
                hFont = CreateFontIndirect( &lf );
                Handle = SelectObject( hDC, hFont );
            }

            SetTextColor( hDC, crColor );

            // end painting and release hDC
            EndPaint( hWnd, &ps );
            break;


        case WM_COMMAND:           /* message: command from application menu */

            switch( LOWORD( wParam ))
            {
                case IDM_OPENFILE:
                   lpProcOpen = MakeProcInstance((FARPROC)OpenFiles, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "OPENFILES",             /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcOpen);    /* About() instance address */

                    FreeProcInstance(lpProcOpen);
                    break;

                case IDM_EXIT:
                    PostQuitMessage(0);
                    break;

                case IDM_CHOOSECOLOR:
                    if (ChooseNewColor( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );
                    break;

                case IDM_CHOOSEFONT:
                    if (NewFont = ChooseNewFont( hWnd ))
                        InvalidateRect( hWnd, NULL, TRUE );

                    break;

                case IDM_FINDTEXT:
                    CallFindText( hWnd );
                    break;

                case IDM_REPLACETEXT:
                    CallReplaceText( hWnd );
                    break;

                case IDM_STANDARD:
                  // enable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_ENABLED );
                    // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_HOOK:
                case IDM_CUSTOM:
                    // disable the ChooseColor() option
                    EnableMenuItem(GetMenu(hWnd), IDM_CHOOSECOLOR,
                            MF_BYCOMMAND | MF_GRAYED );
                     // uncheck previous selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ENTERNEW:
                    lpProcEnterNew = MakeProcInstance((FARPROC)EnterNew, hInst);

                    if (DialogBox(hInst,                 /* current instance         */
                        "EnterNewBox",           /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcEnterNew) == TRUE)

                        InvalidateRect( hWnd, NULL, TRUE );

                    FreeProcInstance(lpProcEnterNew);
                    break;

                case IDM_PERCEPUAL:
                    Intent = 0;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_COLOR:
                    Intent = 1;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_SATURATION:
                    Intent = 2;
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wIntentMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wIntentMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ASCII:
                    AllowBinary = FALSE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_BINARY:
                    AllowBinary = TRUE;
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wAsciiMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wAsciiMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;
                case IDM_AUTO:
                case IDM_ABC:
                case IDM_DEFG:
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAMode = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAMode, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_INP_AUTO:
                case IDM_INP_GRAY:
                case IDM_INP_RGB:
                case IDM_INP_CMYK:
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wInpDrvClrSp = LOWORD(wParam);
                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wInpDrvClrSp, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_CSA:
                case IDM_CRD:
				case IDM_PROFCRD:
                case IDM_INTENT:
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_UNCHECKED | MF_BYCOMMAND);
                    //reset mode
                    wCSAorCRD = LOWORD(wParam);
                    if ((wCSAorCRD == IDM_CRD) || (wCSAorCRD == IDM_INTENT))
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_GRAYED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_GRAYED );
                    }
                    else
                    {
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_GRAY, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_RGB,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_INP_CMYK, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_AUTO, MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_ABC,  MF_BYCOMMAND | MF_ENABLED );
                        EnableMenuItem(GetMenu(hWnd), IDM_DEFG, MF_BYCOMMAND | MF_ENABLED );
                    }

                    //check new selection
                    CheckMenuItem( GetMenu( hWnd ), wCSAorCRD, MF_CHECKED | MF_BYCOMMAND);
                    DrawMenuBar( hWnd);
                    break;

                case IDM_ABOUT:
                    lpProcAbout = MakeProcInstance((FARPROC)About, hInst);

                    DialogBox(hInst,             /* current instance         */
                        "AboutBox",              /* resource to use          */
                        hWnd,                    /* parent handle            */
                        (DLGPROC)lpProcAbout);   /* About() instance address */

                    FreeProcInstance(lpProcAbout);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));

            }
            break;

        case WM_DESTROY:                  /* message: window being destroyed */
            PostQuitMessage(0);
            break;


        default:
            // Handle the special findreplace message (FindReplaceMsg) which
            // was registered at initialization time.
            if ( message == FindReplaceMsg )
            {
                if ( lpFR = (LPFINDREPLACE) lParam )
                    {
                    if (lpFR->Flags & FR_DIALOGTERM )  // terminating dialog
                        return (0);
                    SearchFile( lpFR );
                    InvalidateRect( hWnd, NULL, TRUE );
                    }
                return (0);
            }

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


/****************************************************************************
*
*    FUNCTION: EnterNew(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "EnterNew" dialog box
*
*    COMMENTS:
*
*        This function allows the user to enter new text in the current
*        window.  This text is stored in the global current buffer.
*
****************************************************************************/

BOOL CALLBACK EnterNew(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR Buf[FILE_LEN-1];

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, IDEDIT, Buf, FILE_LEN-1);
                strcpy( FileBuf, Buf);
                lpBufPtr = FileBuf;
                dwFileSize = strlen(FileBuf);
                EndDialog( hDlg, TRUE );
                return (TRUE);
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {   /* System menu close command? */
                EndDialog(hDlg, FALSE);       /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}


/****************************************************************************
*
*    FUNCTION: About(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for "About" dialog box
*
*    COMMENTS:
*
*       No initialization is needed for this particular dialog box, but TRUE
*       must be returned to Windows.
*
*       Wait for user to click on "Ok" button, then close the dialog box.
*
****************************************************************************/

BOOL WINAPI About(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            if (LOWORD(wParam) == IDOK          /* "OK" box selected?        */
                || LOWORD(wParam) == IDCANCEL) {        /* System menu close command? */
                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}

/****************************************************************************
*
*    FUNCTION: FileOpenHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for GetFileNameOpen() common dialog box
*
*    COMMENTS:
*
*        This function will prompt the user if they are sure they want
*        to open the file if the OFN_ENABLEHOOK flag is set.
*
*        If the current option mode is CUSTOM, the user is allowed to check
*        a box in the dialog prompting them whether or not they would like
*        the file created.  If they check this box, the file is created and
*        the string 'Empty' is written to it.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FileOpenHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    int hFile;
    CHAR szTempText[256];
    CHAR szString[256];
    OFSTRUCT OfStruct;

    switch (message)
    {

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                        sizeof( szTempText ) - 1);

                if ( OpenFileName.Flags & OFN_PATHMUSTEXIST )
                {
                    sprintf( szString, "Are you sure you want to open %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )

                        break;
                    return (TRUE);
                }

                // check to see if the Create File box has been checked
                if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                    BM_GETCHECK, 0, 0L )) == TRUE )
                {
                    // if so, create the file
                    if ((hFile = OpenFile(szTempText,
                        &OfStruct,
                        OF_CREATE)) == -1)
                    {
                        MessageBox( hDlg,
                            "Directory could not be created.",
                            NULL,
                            MB_OK );
                        return (FALSE);
                    }

                    strcpy(FileBuf, "Empty");
                    lpBufPtr = FileBuf;
                    dwFileSize = strlen(FileBuf);
                    if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
                        MessageBox( hDlg, "Error writing file.", NULL, MB_OK );

                    // close the file
                    _lclose( hFile );
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: OpenNewFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to open a file and opens it.
*
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure and calls
*        the GetOpenFileName() common dialog function.  This function will
*        work regardless of the mode: standard, using a hook or using a
*        customized template.
*
*    RETURN VALUES:
*        TRUE - The file was opened successfully and read into the buffer.
*        FALSE - No files were opened.
*
****************************************************************************/
BOOL OpenNewFile( HWND hWnd )
{
   strcpy( szFile, "");
   strcpy( szFileTitle, "");

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.lpstrFile         = szFile;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.lpstrFileTitle    = szFileTitle;
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Open a File";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.icm";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_SHOWHELP | OFN_ENABLEHOOK |
                OFN_HIDEREADONLY | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileOpenHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if (GetOpenFileName(&OpenFileName))
   {
   }
   else
   {
      ProcessCDError(CommDlgExtendedError(), hWnd );
      return FALSE;
   }
   return TRUE;
}

/****************************************************************************
*
*    FUNCTION: SaveToFile( HWND )
*
*    PURPOSE:  Saves the current buffer to the current file.
*
*    COMMENTS:
*
*        This function will save the current text buffer into the file
*        specified from the GetSaveFileName() common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveToFile( HWND hWnd )
{
   int hFile;
   OFSTRUCT OfStruct;
   WORD wStyle;
   CHAR buf[256];

   if (OpenFileName.Flags | OFN_FILEMUSTEXIST)
        wStyle = OF_READWRITE;
   else
        wStyle = OF_READWRITE | OF_CREATE;

   if ((hFile = OpenFile(OpenFileName.lpstrFile, &OfStruct,
         wStyle)) == -1)
   {
      sprintf( buf, "Could not create file %s", OpenFileName.lpstrFile );
      MessageBox( hWnd, buf, NULL, MB_OK );
      return FALSE;
   }
   // write it's contents into a file
   if (_lwrite( hFile, (LPSTR)&FileBuf[0], dwFileSize)==-1)
   {
      MessageBox( hWnd, "Error writing file.", NULL, MB_OK );
      return FALSE;
   }

   // close the file
   _lclose( hFile );

   sprintf( buf, "%s", OpenFileName.lpstrFile );
   MessageBox( hWnd, buf, "File Saved", MB_OK );
   return TRUE;
}


/****************************************************************************
*
*    FUNCTION: FileSaveHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for FileSave common dialog box
*
*    COMMENTS:
*
*        This hook procedure prompts the user if they want to save the
*        current file.  If they choose YES, the file is saved and the dialog
*        is dismissed.  If they choose NO, they are returned to the
*        GetSaveFileName() common dialog.
*
*        If the current mode calls for a customized template, this function
*        will test the 'Create File?' checkbox.  If the user choses no, the
*        OFN_FILEMUSTEXIST flag is set.
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
*
****************************************************************************/

BOOL CALLBACK FileSaveHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    CHAR szTempText[256];
    CHAR szString[256];

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                GetDlgItemText( hDlg, edt1, szTempText,
                    sizeof( szTempText ) - 1);
                if ( OpenFileName.Flags & OFN_ENABLETEMPLATE )
                {
                    // check to see if the Create File box has been checked
                    if ( (BOOL)(SendMessage( GetDlgItem(hDlg, chx2),
                        BM_GETCHECK, 0, 0L )) == FALSE )
                        OpenFileName.Flags |= OFN_FILEMUSTEXIST;
                    break;

                }
                else
                {
                    sprintf( szString, "Are you sure you want to save %s?",
                        szTempText);
                    if ( MessageBox( hDlg, szString, "Information",
                        MB_YESNO ) == IDYES )
                        break;
                    return(TRUE);
                }

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}

/****************************************************************************
*
*    FUNCTION: SaveAs(HWND)
*
*    PURPOSE:  Invokes the common dialog function to save the current
*              buffer to a file.
*    COMMENTS:
*
*        This function initializes the OPENFILENAME structure for any
*        mode selected by the user: standard, using a hook or using a
*        customized template.  It then calls the GetSaveFileName()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - The file was saved successfully.
*        FALSE - The buffer was not saved to a file.
*
****************************************************************************/
BOOL SaveAs( HWND hWnd )
{
   int      i;

//   strcpy( szFile, "");
//   strcpy( szFileTitle, "");

   for ( i = lstrlen(OpenFileName.lpstrFileTitle); i > 0; i--)
   {
       if (OpenFileName.lpstrFileTitle[i] == '.') break;
   }
   i ++;
   if (wCSAorCRD == IDM_CSA)
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'S';
        OpenFileName.lpstrFileTitle[i++] = 'A';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else if ((wCSAorCRD == IDM_CRD) ||
	        (wCSAorCRD == IDM_PROFCRD))
   {
        OpenFileName.lpstrFileTitle[i++] = 'C';
        OpenFileName.lpstrFileTitle[i++] = 'R';
        OpenFileName.lpstrFileTitle[i++] = 'D';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   else
   {
        OpenFileName.lpstrFileTitle[i++] = 'I';
        OpenFileName.lpstrFileTitle[i++] = 'N';
        OpenFileName.lpstrFileTitle[i++] = 'T';
        OpenFileName.lpstrFileTitle[i] = 0;
   }
   strcpy(OpenFileName.lpstrFile, OpenFileName.lpstrFileTitle);

   OpenFileName.lStructSize       = sizeof(OPENFILENAME);
   OpenFileName.hwndOwner         = hWnd;
   OpenFileName.hInstance         = (HANDLE) hInst;
   OpenFileName.lpstrFilter       = szSaveFilter;
   OpenFileName.lpstrCustomFilter = (LPSTR) NULL;
   OpenFileName.nMaxCustFilter    = 0L;
   OpenFileName.nFilterIndex      = 1L;
   OpenFileName.nMaxFile          = sizeof(szFile);
   OpenFileName.nMaxFileTitle     = sizeof(szFileTitle);
   OpenFileName.lpstrInitialDir   = NULL;
   OpenFileName.lpstrTitle        = "Save File As";
   OpenFileName.nFileOffset       = 0;
   OpenFileName.nFileExtension    = 0;
   OpenFileName.lpstrDefExt       = "*.csa";
   OpenFileName.lCustData         = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            OpenFileName.Flags = 0L;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)(FARPROC)NULL;
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            OpenFileName.Flags = OFN_ENABLEHOOK;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            OpenFileName.Flags = OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
            OpenFileName.lpfnHook = (LPOFNHOOKPROC)MakeProcInstance(FileSaveHookProc, NULL);
            OpenFileName.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FILEOPENORD);
            break;
   }

   if ( GetSaveFileName( &OpenFileName ))
   {
        return (TRUE);
   }
   else
   {
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }

   return (FALSE);
}


/****************************************************************************
*
*    FUNCTION: ChooseColorHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseColor common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the color.  if they choose YES, the color of the
*        text will be changed and the dialog will be dismissed.  If they
*        choose NO, the color will not be changed and the user will be
*        returned to the dialog
*
*    RETURN VALUES:
*        TRUE - User chose 'Yes' from the "Are you sure message box".
*        FALSE - User chose 'No'; return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseColorHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the color?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewColor(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new color.
*
*    COMMENTS:
*        This function initializes the CHOOSECOLOR structure for any
*        mode the user chooses: standard, using a hook or using a
*        customized template.  It then calls the ChooseColor()
*        common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new color was chosen.
*        FALSE - No new color was chosen.
*
****************************************************************************/
BOOL ChooseNewColor( HWND hWnd )
{

    DWORD dwColor;
    DWORD dwCustClrs[16];
    BOOL fSetColor = FALSE;
    int i;


    for (i=0; i < 15; i++)
        dwCustClrs[i] = RGB( 255, 255, 255);

    dwColor = RGB( 0, 0, 0 );

    chsclr.lStructSize = sizeof(CHOOSECOLOR);
    chsclr.hwndOwner = hWnd;
    chsclr.hInstance = (HANDLE)hInst;
    chsclr.rgbResult = dwColor;
    chsclr.lpCustColors = (LPDWORD)dwCustClrs;
    chsclr.lCustData = 0L;

    switch( wMode )
    {
        case IDM_HOOK:
        case IDM_CUSTOM:
            chsclr.Flags = CC_PREVENTFULLOPEN | CC_ENABLEHOOK;
            chsclr.lpfnHook = (LPCCHOOKPROC)MakeProcInstance(ChooseColorHookProc, NULL);
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_STANDARD:
            chsclr.Flags = CC_PREVENTFULLOPEN;
            chsclr.lpfnHook = (LPCCHOOKPROC)(FARPROC)NULL;
            chsclr.lpTemplateName = (LPSTR)NULL;
            break;


   }

   if ( fSetColor = ChooseColor( &chsclr ))
   {
       crColor = chsclr.rgbResult;
       return (TRUE);
   }
   else
   {
       ProcessCDError(CommDlgExtendedError(), hWnd );
       return FALSE;
   }
}


/****************************************************************************
*
*    FUNCTION: ChooseFontHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ChooseFont common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to change the font.  if they choose YES, the color of the
*        font will be changed and the dialog will be dismissed.  If they
*        choose NO, the font will not be changed and the user will be
*        returned to the dialog
*
*        If the current mode is set to use a customized template, the
*        color drop down combo box is hidden.
*
*    RETURN VALUES:
*        TRUE - Change the font.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ChooseFontHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (chf.Flags & CF_ENABLETEMPLATE)
            {
                ShowWindow(GetDlgItem(hDlg, stc4), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, cmb4), SW_HIDE);
            }
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to change the font?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: ChooseNewFont(HWND)
*
*    PURPOSE:  Invokes common dialog function to chose a new font.
*
*    COMMENTS:
*
*        This function initializes the CHOOSEFONT structure for any mode
*        the user chooses: standard, using a hook or using a customized
*        template.  It then calls the ChooseFont() common dialog function.
*
*    RETURN VALUES:
*        TRUE - A new font was chosen.
*        FALSE - No new font was chosen.
*
****************************************************************************/
BOOL ChooseNewFont( HWND hWnd )
{

   HDC hDC;

   hDC = GetDC( hWnd );
   chf.hDC = CreateCompatibleDC( hDC );
   ReleaseDC( hWnd, hDC );
   chf.lStructSize = sizeof(CHOOSEFONT);
   chf.hwndOwner = hWnd;
   chf.lpLogFont = &lf;
   chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
   chf.rgbColors = RGB(0, 255, 255);
   chf.lCustData = 0;
   chf.hInstance = (HANDLE)hInst;
   chf.lpszStyle = (LPSTR)NULL;
   chf.nFontType = SCREEN_FONTTYPE;
   chf.nSizeMin = 0;
   chf.nSizeMax = 0;

   switch( wMode )
   {
        case IDM_STANDARD:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS;
            chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)NULL;
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_ENABLEHOOK |
              CF_ENABLETEMPLATE;
            chf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL);
            chf.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FORMATDLGORD31);
            break;
   }


   if( ChooseFont( &chf ) == FALSE )
   {
        DeleteDC( hDC );
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return FALSE;
   }


   DeleteDC( hDC );

   return (TRUE);
}

/****************************************************************************
*
*    FUNCTION: PrintSetupHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for PrintDlg setup common dialog box
*
*    COMMENTS:
*
*        This function processes the hook and customized template for the
*        print setup common dialog box.  If the customized template has
*        been provided, the 'Options' pushbutton is hidden.  If the hook only mode
*        is chosen, a message box is displayed informing the user that the
*        hook has been installed.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintSetupHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLESETUPTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, psh1), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}



/****************************************************************************
*
*    FUNCTION: PrintDlgHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for PrintDlg common dialog box
*
*    COMMENTS:
*
*        This hook procedure simply prompts the user whether or not they
*        want to print.  if they choose YES, the text buf will be printed
*        and the dialog will be dismissed.  If they choose NO, the text buf
*        will not be printeded and the user will be returned to the dialog.
*
*        If the current mode is 'custom', the 'Print to file' and 'Collate
*        Copies' options are hidden.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK PrintDlgHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (pd.Flags & PD_ENABLEPRINTTEMPLATE )
            {
                ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                return(TRUE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (MessageBox( hDlg, "Are you sure you want to print?",
                    "Information", MB_YESNO ) == IDYES )
                    break;
                return (TRUE);

            }
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;

}


/****************************************************************************
*
*    FUNCTION: PrintFile(HWND)
*
*    PURPOSE:  Invokes common dialog function to print.
*
*    COMMENTS:
*
*        This function initializes the PRINTDLG structure for all modes
*        possible: standard, using a hook or using a customized template.
*        When hook mode is chosen, a hook is installed for both the
*        Print dialog and the Print Setup dialog.  When custom mode is
*        chosen, the templates are enabled for both the print dialog and
*        the Print Setup dialog boxes.
*
*        If the PrintDlg() common dialog returns TRUE, the current
*        text buffer is printed out.
*
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void PrintFile( HWND hWnd )
{


    // initialize PRINTDLG structure
    pd.lStructSize = sizeof(PRINTDLG);
    pd.hwndOwner = hWnd;
    pd.hDevMode = (HANDLE)NULL;
    pd.hDevNames = (HANDLE)NULL;
    pd.nFromPage = 0;
    pd.nToPage = 0;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 0;
    pd.hInstance = (HANDLE)hInst;


    switch( wMode )
    {
        case IDM_STANDARD:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)(FARPROC)NULL;
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)(FARPROC)NULL;
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)NULL;
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            pd.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION |
                PD_ENABLEPRINTHOOK | PD_ENABLEPRINTTEMPLATE |
                PD_ENABLESETUPHOOK | PD_ENABLESETUPTEMPLATE | PD_PRINTSETUP;
            pd.lpfnSetupHook = (LPSETUPHOOKPROC)MakeProcInstance(PrintSetupHookProc, NULL);
            pd.lpSetupTemplateName = (LPSTR)MAKEINTRESOURCE(PRNSETUPDLGORD);
            pd.lpfnPrintHook = (LPPRINTHOOKPROC)MakeProcInstance(PrintDlgHookProc, NULL);
            pd.lpPrintTemplateName = (LPSTR)MAKEINTRESOURCE(PRINTDLGORD);
            break;

    }

    //print a test page if successful
    if (PrintDlg(&pd) == TRUE)
    {
        Escape(pd.hDC, STARTDOC, 8, "Test-Doc", NULL);

        //Print text
        TextOut(pd.hDC, 5, 5, FileBuf, strlen(FileBuf));

        Escape(pd.hDC, NEWFRAME, 0, NULL, NULL);
        Escape(pd.hDC, ENDDOC, 0, NULL, NULL );
        DeleteDC(pd.hDC);
        if (pd.hDevMode)
            GlobalFree(pd.hDevMode);
        if (pd.hDevNames)
            GlobalFree(pd.hDevNames);
    }
   else
        ProcessCDError(CommDlgExtendedError(), hWnd );
}


/****************************************************************************
*
*    FUNCTION: ReplaceTextHookProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Processes messages for ReplaceText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only active.  Otherwise, if template enabled, hides the
*        Replace All pushbutton, plus the 'Match case' and
*        'Match whole word' check box options.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK ReplaceTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
                {
                    ShowWindow( GetDlgItem(hDlg, psh2), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx1), SW_HIDE );
                    ShowWindow( GetDlgItem(hDlg, chx2), SW_HIDE );
                }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}

/****************************************************************************
*
*    FUNCTION: FindTextHookProc(HWND, UINT, UINT, LONG)
*
*    PURPOSE:  Processes messages for FindText common dialog box
*
*    COMMENTS:
*
*        Puts up a message stating that the hook is active if hook
*        only enabled.  If custom template, hides the 'Match case'
*        and 'Match whole word' options, hides the group box 'Direction'
*        with the radio buttons 'Up' and 'Down'.
*
*    RETURN VALUES:
*        TRUE - Continue.
*        FALSE - Return to the dialog box.
*
****************************************************************************/

BOOL CALLBACK FindTextHookProc(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            if (frText.Flags & FR_ENABLETEMPLATE )
            {
                ShowWindow(GetDlgItem(hDlg, chx1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, chx2), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, rad2), SW_HIDE);
            }
            MessageBox( hDlg,
                    "Hook installed.",
                    "Information", MB_OK );
            return (TRUE);


        default:
            break;
    }
    return (FALSE);

    // avoid compiler warnings at W3
    lParam;
    wParam;
}


/****************************************************************************
*
*    FUNCTION: CallFindText( HWND )
*
*    PURPOSE:  Initializes and calls the FindText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the FindText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallFindText( HWND hWnd )
{

    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = (LPSTR)NULL;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = 0;
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags =  FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                 FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(FindTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(FINDDLGORD);
            break;
    }

    if ((hDlgFR = FindText(&frText)) == NULL)
        ProcessCDError(CommDlgExtendedError(), hWnd );

}


/****************************************************************************
*
*    FUNCTION: CallReplaceText( HWND )
*
*    PURPOSE:  Initializes and calls the ReplaceText()
*        common dialog.
*
*    COMMENTS:
*
*        This function initialzes the FINDREPLACE structure for any mode:
*        standard, using a hook or using a customized template.  It then
*        calls the ReplaceText() common dialog function.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void CallReplaceText( HWND hWnd )
{
    frText.lStructSize = sizeof( frText );
    frText.hwndOwner = hWnd;
    frText.hInstance = (HANDLE)hInst;
    frText.lpstrFindWhat = szFindString;
    frText.lpstrReplaceWith = szReplaceString;
    frText.wFindWhatLen = sizeof(szFindString);
    frText.wReplaceWithLen = sizeof( szReplaceString );
    frText.lCustData = 0;
    lpBufPtr = FileBuf;

    switch( wMode )
    {
        case IDM_STANDARD:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD;
            frText.lpfnHook = (LPFRHOOKPROC)(FARPROC)NULL;
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_HOOK:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)NULL;
            break;

        case IDM_CUSTOM:
            frText.Flags = FR_NOMATCHCASE | FR_NOUPDOWN | FR_NOWHOLEWORD |
                FR_ENABLEHOOK | FR_ENABLETEMPLATE;
            frText.lpfnHook = (LPFRHOOKPROC)MakeProcInstance(ReplaceTextHookProc, NULL);
            frText.lpTemplateName = (LPSTR)MAKEINTRESOURCE(REPLACEDLGORD);
            break;
    }

    if ( (hDlgFR = ReplaceText( &frText )) == NULL )
            ProcessCDError(CommDlgExtendedError(), hWnd );

}

/****************************************************************************
*
*    FUNCTION: SearchFile(LPFINDREPLACE)
*
*    PURPOSE:  Does the find/replace specified by the Find/ReplaceText
*        common dialog.
*
*    COMMENTS:
*
*        This function does the lease necessary to implement find and
*        replace by calling existing c-runtime functions.  It is in
*        no way intended to demonstrate either correct or efficient
*        methods for doing textual search or replacement.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void SearchFile( LPFINDREPLACE lpFR )
{

    CHAR Buf[FILE_LEN];
    CHAR *pStr;
    int count, newcount;
    static BOOL bFoundLast = FALSE;
    
if ( lpFR->Flags & ( FR_FINDNEXT | FR_REPLACE | FR_REPLACEALL ) )
    {
    memset(Buf, '\0', FILE_LEN -1);
    if ( bFoundLast )
        {
        if ( (lpBufPtr != FileBuf) && (lpFR->Flags & FR_FINDNEXT) )
            lpBufPtr++;
        bFoundLast = FALSE;
        }

    if (!*lpBufPtr || !(pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) )
        {
        sprintf( Buf, "'%s' not found!", lpFR->lpstrFindWhat );
        lpBufPtr = FileBuf;
        MessageBox( lpFR->hwndOwner, Buf, "No luck", MB_OK | MB_TASKMODAL);
        }
    else
        {
        if ( lpFR->Flags & FR_FINDNEXT )
            {
            sprintf( Buf, "Found Next '%s'!\nSubstring: '%.10s'", 
                     lpFR->lpstrFindWhat, pStr );
            lpBufPtr = pStr;
            bFoundLast = TRUE;
            MessageBox( lpFR->hwndOwner, Buf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACE )
            {
            // replace string specified in the replace with found string
            // copy up to found string into new buffer
            for( count=0; 
                 *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                 count++);
                strncpy( Buf, lpBufPtr, count );
            // concatenate new string
            strcat( Buf, lpFR->lpstrReplaceWith );
            // copy rest of string (less the found string)
            newcount = count + strlen(lpFR->lpstrFindWhat);
            strcat( Buf, lpBufPtr+newcount);
            strcpy( lpBufPtr, Buf );
            lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
            dwFileSize = strlen(FileBuf);
            MessageBox( lpFR->hwndOwner, FileBuf, "Success!", MB_OK | MB_TASKMODAL );
            }
        else if ( lpFR->Flags & FR_REPLACEALL)
            {
            do
                {
                // replace string specified in the replace with found string
                // copy up to found string into new buffer
                memset(Buf, '\0', FILE_LEN -1);
                for( count=0; 
                     *pStr && lpBufPtr[count] && *pStr != lpBufPtr[count]; 
                     count++);
                     strncpy( Buf, lpBufPtr, count );
                // concatenate new string
                strcat( Buf, lpFR->lpstrReplaceWith );
                // copy rest of string (less the found string)
                newcount = count + strlen(lpFR->lpstrFindWhat);
                strcat( Buf, lpBufPtr + newcount);
                strcpy( lpBufPtr, Buf );
                lpBufPtr += count + strlen(lpFR->lpstrReplaceWith);
                }
            while ( *lpBufPtr && 
                    (pStr = strstr( lpBufPtr, lpFR->lpstrFindWhat ) ) );
            dwFileSize = strlen(FileBuf);
            lpBufPtr = FileBuf;
            MessageBox( lpFR->hwndOwner, FileBuf, 
                        "Success!", MB_OK | MB_TASKMODAL );
            }

        }
    }
}


/****************************************************************************
*
*    FUNCTION: ProcessCDError(DWORD)
*
*    PURPOSE:  Processes errors from the common dialog functions.
*
*    COMMENTS:
*
*        This function is called whenever a common dialog function
*        fails.  The CommonDialogExtendedError() value is passed to
*        the function which maps the error value to a string table.
*        The string is loaded and displayed for the user.
*
*    RETURN VALUES:
*        void.
*
****************************************************************************/
void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
   WORD  wStringID;
   CHAR  buf[256];

   switch(dwErrorCode)
      {
         case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break;
         case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break;
         case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break;
         case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break;
         case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break;
         case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break;
         case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break;
         case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break;
         case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break;
         case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break;
         case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break;
         case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break;
         case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break;
         case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break;
         case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break;
         case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break;
         case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break;
         case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break;
         case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break;
         case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break;
         case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break;
         case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break;
         case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break;
         case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break;
         case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break;
         case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break;
         case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break;

         case 0:   //User may have hit CANCEL or we got a *very* random error
            return;

         default:
            wStringID=IDS_UNKNOWNERROR;
      }

   LoadString(NULL, wStringID, buf, sizeof(buf));
   MessageBox(hWnd, buf, NULL, MB_OK);
   return;
}

/***********************************************************************/

BOOL WINAPI OpenFiles(
        HWND hDlg,                /* window handle of the dialog box */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* message-specific information    */
        LPARAM lParam)
{
    int    Length;
    char   DevProfileName[FILE_LEN];
    char   TargetProfileName[FILE_LEN];
    char   OutputFileName[FILE_LEN];
    WORD   InpClrSp;

    switch (message)
    {
        case WM_INITDIALOG:                /* message: initialize dialog box */
            return (TRUE);

        case WM_COMMAND:                      /* message: received a command */
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: 
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile)); 
                    break;
                case IDC_BUTTON2:
                    if ( OpenNewFile( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT2, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDC_BUTTON3:
                    if ( SaveAs( hWnd ) == TRUE )
                        SendDlgItemMessage(hDlg, IDC_EDIT3, WM_SETTEXT, 0, (long)(OpenFileName.lpstrFile));
                    break;
                case IDOK:
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXT, Length + 1, (long)(DevProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT2, WM_GETTEXT, Length + 1, (long)(TargetProfileName));
                    Length = SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXTLENGTH, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXT, Length + 1, (long)(OutputFileName));
                    switch (wInpDrvClrSp)
                    {
                        case IDM_INP_AUTO: InpClrSp = 0; break;
                        case IDM_INP_GRAY: InpClrSp = 1; break;
                        case IDM_INP_RGB:  InpClrSp = 3; break;
                        case IDM_INP_CMYK: InpClrSp = 4; break;
                        default: InpClrSp = 0; break;
                    }
                    if (wCSAorCRD == IDM_CSA)
                    {
                        ColorSpaceControl(DevProfileName, OutputFileName,
                            InpClrSp, Intent, wCSAMode, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_CRD)
                    {
                        CreateCRDControl(DevProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else if (wCSAorCRD == IDM_PROFCRD)
                    {
                        CreateProfCRDControl(DevProfileName, 
                            TargetProfileName, OutputFileName,
                            Intent, AllowBinary);
                    }
                    else 
                    {
                        CreateINTENTControl(DevProfileName, OutputFileName, Intent);
                    }

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);        /* Exits the dialog box        */
                    return (TRUE);
            }
            break;
    }
    return (FALSE);                           /* Didn't process a message    */

    // avoid compiler warnings at W3
    lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\devprop.cpp ===
/******************************************************************************

  Source File:  Device Profile Management .CPP

  Change History:


  Implements the class which provides the various device profile management UI

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises, Inc. Production
  11-27-96  a-RobKj@microsoft.com coded it

******************************************************************************/

#include    "ICMUI.H"

//
// This function is obtained from the April 1998 Knowledge Base
// Its purpose is to determine if the current user is an
// Administrator and therefore priveledged to change profile
// settings.
//
// BOOL IsAdmin(void)
//
//      returns TRUE if user is an admin
//              FALSE if user is not an admin
//

#if defined(_WIN95_)

//
// Always administrator on Windows 9x platform.
//

BOOL IsAdmin(void) {

    return (TRUE);
}

#else

BOOL IsAdmin(void)
{
    BOOL   fReturn = FALSE;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if(!CheckTokenMembership( NULL, psidAdmin, &fReturn )) {

          //
          // explicitly disallow Admin Access if CheckTokenMembership fails.
          // 

          fReturn = FALSE;
        }
        FreeSid ( psidAdmin);
    }
    
    return ( fReturn );
}

#endif // _WIN95_

/******************************************************************************

  List Managment functions

  The method used here is simlar to that used in the profile Managment sheets
  for managing device associations.

  We (not royal, I mean the OS and I) manage two "to-do" lists and use these
  to show the user the anticipated result of these lists being applied.  The
  first list is a list of existing associations that are to be broken.  The
  second is one of new associations to be made.  This is coupled with a list
  of the current associations.

  The "Removals" list is the indices of existing associations which will be
  borken.  The "Adds" list is a list of new profiles to be associated.  The
  "Profiles" list is the list of existing associations.

  Adding and removing profiles could mean removing an item from one of the work
  lists (undoing a previous selection), or adding one.  Each time such a change
  is made, the profile list box is emptied and refilled.  This lets us avoid
  mapping removals and additions more directly.

  When changes are commited, either with Apply or OK, we make or break
  associations as specified, then empty all of the lists, and rebuild the list
  of current associations.

  We use the ITEMDATA of the UI list box to handle the associations.  This lets
  the list remain sorted.

  All of the list management functions can be overriden, if needed.

******************************************************************************/

void    CDeviceProfileManagement::InitList() {

    //  Make sure the lists are empty.

    m_cuaRemovals.Empty();
    m_cpaAdds.Empty();

    //  Determine the associations for the target device.

    ENUMTYPE    et = {sizeof et, ENUM_TYPE_VERSION, ET_DEVICENAME, m_csDevice};

    CProfile::Enumerate(et, m_cpaProfile);
}

//  Fill the UI list of profiles

void    CDeviceProfileManagement::FillList(DWORD dwFlags) {

    //  Before reset list box, get current selection to restore later.

    CString csSelect;

    csSelect.Empty();

    LRESULT idSelect = LB_ERR;

    if ( !(dwFlags & DEVLIST_NOSELECT)) {

        //  Get current selected position.

        idSelect = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

        //  Get text length where currently selected, than allocate buffer for that.

        DWORD   dwLen = (DWORD) SendMessage(m_hwndList, LB_GETTEXTLEN, idSelect, 0);
        TCHAR  *pszSelect = new TCHAR[dwLen + 1];

        //  Get text itself.
    
        if (pszSelect != NULL) {

            if (SendMessage(m_hwndList, LB_GETTEXT, idSelect, (LPARAM) pszSelect) != LB_ERR) {
                csSelect = pszSelect;
            }

            delete pszSelect;
        }
    }

    //  reset list box

    SendMessage(m_hwndList, LB_RESETCONTENT, 0, 0);

    //  Fill the profile list box from the list of profiles

    for (unsigned u = 0; u < m_cpaProfile.Count(); u++) {

        //  Don't list profiles tentatively disassociated...

        for (unsigned uOut = 0; uOut < m_cuaRemovals.Count(); uOut++)
            if  (m_cuaRemovals[uOut] == u)
                break;

        if  (uOut < m_cuaRemovals.Count())
            continue;   //  Don't add this to list, it's been zapped!

        LRESULT id = SendMessage(m_hwndList, LB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) m_cpaProfile[u] -> GetName());

        SendMessage(m_hwndList, LB_SETITEMDATA, id, u);
    }

    //  Add the profiles that have been tentatively added...

    for (u = 0; u < m_cpaAdds.Count(); u ++) {
        LRESULT id = SendMessage(m_hwndList, LB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) m_cpaAdds[u] -> GetName());
        SendMessage(m_hwndList, LB_SETITEMDATA, id, u + m_cpaProfile.Count());
    }

    //  If we have any profiles, select the first one
    //  Otherwise, disable the "Remove" button, as there's nothing to remove

    unsigned itemCount = (m_cpaProfile.Count() + m_cpaAdds.Count() - m_cuaRemovals.Count());

    if  (itemCount) {

        // The Remove button must remain disabled
        // unless the user is Administrator.
        // This code is specific to the Monitor Profile
        // Property sheet.

        if (!m_bReadOnly) {
            EnableWindow(GetDlgItem(m_hwnd, RemoveButton), TRUE);
        }

        if ( !(dwFlags & DEVLIST_NOSELECT)) {

            // Find out the string selected previously.

            idSelect = LB_ERR;

            if (!csSelect.IsEmpty()) {
                idSelect = SendMessage(m_hwndList, LB_FINDSTRINGEXACT,
                                       (WPARAM) -1, (LPARAM) (LPCTSTR) csSelect);
            }

            // if could not find, just select first item.

            if (idSelect == LB_ERR) {
                idSelect = 0;
            }

            // Select it.

            SendMessage(m_hwndList, LB_SETCURSEL, idSelect, 0);
        }

    } else {

        HWND hwndRemove = GetDlgItem(m_hwnd, RemoveButton);

        // If focus is on Remove, move it to Add button.

        if (GetFocus() == hwndRemove) {

            HWND hwndAdd = GetDlgItem(m_hwnd, AddButton);

            SetFocus(hwndAdd);
            SendMessage(hwndRemove, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
            SendMessage(hwndAdd, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
        }

        EnableWindow(hwndRemove, FALSE);
    }

    // Apply button needs to remain disabled unless the
    // user has permision to make changes - ie. user
    // is Administrator.

    if  ((dwFlags & DEVLIST_CHANGED) && !(m_bReadOnly)) {
        EnableApplyButton();
        SettingChanged(TRUE);
    }
}

void CDeviceProfileManagement::GetDeviceTypeString(DWORD dwType,CString& csDeviceName) {

    DWORD id;

    switch (dwType) {

    case CLASS_MONITOR :
        id = ClassMonitorString;
        break;
    case CLASS_PRINTER :
        id = ClassPrinterString;
        break;
    case CLASS_SCANNER :
        id = ClassScannerString;
        break;
    case CLASS_LINK :
        id = ClassLinkString;
        break;
    case CLASS_ABSTRACT :
        id = ClassAbstractString;
        break;
    case CLASS_NAMED :
        id = ClassNamedString;
        break;
    case CLASS_COLORSPACE :
    default :
        id = ClassColorSpaceString;
        break;
    }

    // Load string.

    csDeviceName.Load(id);
}

//  Constructor

CDeviceProfileManagement::CDeviceProfileManagement(LPCTSTR lpstrDevice,
                                                   HINSTANCE hiWhere,
                                                   int idPage, DWORD dwType) {
    m_csDevice = lpstrDevice;
    m_dwType = dwType;
    m_psp.hInstance = hiWhere;
    m_psp.pszTemplate = MAKEINTRESOURCE(idPage);

    //  Setting m_bReadOnly to false enables functionality

    m_bReadOnly = FALSE;        // default setting is false

#if defined(_WIN95_)

    //
    // There is no way to detect printer supports CMYK or not on Win 9x.

    m_bCMYK = TRUE;

#else

    //  we need to check the device capabilities
    //  and determine if we're trying to associate
    //  a cmyk printer profile to a printer that
    //  doesn't support it.

    m_bCMYK = FALSE;            // default setting - don't support cmyk

    //  if the device is a printer

    if (m_dwType == CLASS_PRINTER) {

        HDC hdcThis = CGlobals::GetPrinterHDC(m_csDevice);

        //  if the printer supports CMYK

        if (hdcThis) {
            if (GetDeviceCaps(hdcThis, COLORMGMTCAPS) & CM_CMYK_COLOR) {
                m_bCMYK = TRUE;
            }
            DeleteDC(hdcThis);
        }
    }

#endif // defined(_WIN95_)
}

//  UI initialization

BOOL    CDeviceProfileManagement::OnInit() {

    InitList();

    m_hwndList = GetDlgItem(m_hwnd, ProfileListControl);

    //  Fill the profile list box

    FillList(DEVLIST_ONINIT);

    //  Disable apply button as default.

    DisableApplyButton();

    //  Nothing changed, yet.

    SettingChanged(FALSE);

    return  TRUE;
}

//  Command processing

BOOL    CDeviceProfileManagement::OnCommand(WORD wNotifyCode, WORD wid,
                                             HWND hwndCtl) {

    switch  (wNotifyCode) {

        case    BN_CLICKED:

            switch  (wid) {

                case    AddButton: {

                    unsigned i = 0, u = 0;

                    //  Time to do the old OpenFile dialog stuff...

                    CAddProfileDialog capd(m_hwnd, m_psp.hInstance);

                    //  See if a profile was selected

                    while(i < capd.ProfileCount()) {

                        //  Check profile validity and device type

                        CProfile cpTemp(capd.ProfileName(i));

                        //  CLASS_COLORSPACE and CLASS_MONITOR can be associated to
                        //  any device. Other (CLASS_SCANNER, CLASS_PRINTER) only
                        //  can be associated to much device.

                        if (    !cpTemp.IsValid() // Wrong profile type or invalid?
                             || (   cpTemp.GetType() != m_dwType
                                 && cpTemp.GetType() != CLASS_COLORSPACE
                        #if 1 // ALLOW_MONITOR_PROFILE_TO_ANY_DEVICE
                                 && cpTemp.GetType() != CLASS_MONITOR
                        #endif
                                )
                           ) {

                            //  Throw up a message box to inform the user of this

                            if (cpTemp.IsValid())
                            {
                                CString csDeviceType;  GetDeviceTypeString(m_dwType,csDeviceType);
                                CString csProfileType; GetDeviceTypeString(cpTemp.GetType(),csProfileType);

                                CGlobals::ReportEx(MismatchDeviceType, m_hwnd, FALSE,
                                               MB_OK|MB_ICONEXCLAMATION, 3,
                                               (LPTSTR)capd.ProfileNameAndExtension(i),
                                               (LPTSTR)csProfileType,
                                               (LPTSTR)csDeviceType);
                            }
                            else
                            {
                                CGlobals::ReportEx(InstFailedWithName, m_hwnd, FALSE,
                                               MB_OK|MB_ICONEXCLAMATION, 1,
                                               (LPTSTR)capd.ProfileNameAndExtension(i));
                            }

                            goto SkipToNext;
                        }

                        //  See if the profile has already been listed for addition

                        for (u = 0; u < m_cpaAdds.Count(); u++) {
                            if  (!lstrcmpi(m_cpaAdds[u] -> GetName(), cpTemp.GetName())) {
                                goto SkipToNext; //  This profile is already added
                            }
                        }

                        //  If this profile is on the existing list, either ignore
                        //  or zap it from the removal list, as the case may be

                        for (u = 0; u < m_cpaProfile.Count(); u++) {
                            if  (!lstrcmpi(m_cpaProfile[u] -> GetName(),
                                    cpTemp.GetName())) {
                                //  Is this one on the removal list?
                                for (unsigned uOut = 0;
                                     uOut < m_cuaRemovals.Count();
                                     uOut++) {
                                    if  (m_cuaRemovals[uOut] == u) {
                                        //  Was to be removed- undo that...
                                        m_cuaRemovals.Remove(uOut);
                                        FillList(DEVLIST_CHANGED);
                                        break;
                                    }
                                }
                                goto SkipToNext;
                            }   //  End of name in existing list
                        }

                        //  We need to check the device capabilities
                        //  and determine if we're trying to associate
                        //  a cmyk printer profile to a printer that
                        //  doesn't support it.

                        if  ((!m_bCMYK) && (cpTemp.GetColorSpace() == SPACE_CMYK)) {
                            CGlobals::ReportEx(UnsupportedProfile, m_hwnd, FALSE,
                                                MB_OK|MB_ICONEXCLAMATION, 2,
                                                (LPTSTR)m_csDevice,
                                                (LPTSTR)capd.ProfileNameAndExtension(i));
                            goto SkipToNext;
                        }

                        //  Add this profile to the list, item (max orig + index)

                        m_cpaAdds.Add(capd.ProfileName(i));

                        //  Change has been made, update the list

                        FillList(DEVLIST_CHANGED);
SkipToNext:
                        i++;
                    }

                    return  TRUE;
                }

                case    RemoveButton: {

                    //  Remove the selected profile

                    LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);
                    unsigned u = (unsigned) SendMessage(m_hwndList,
                        LB_GETITEMDATA, id, 0);

                    //  If this is a tentative add, just drop it, otherwise
                    //  note that it's been removed...

                    if  (u >= m_cpaProfile.Count())
                        m_cpaAdds.Remove(u - m_cpaProfile.Count());
                    else
                        m_cuaRemovals.Add(u);

                    //  That's it- just update the display, now...

                    FillList(DEVLIST_CHANGED);

                    // explicitly set the position of the current selection
                    // after the list has been recomputed.

                    int listsize = m_cpaProfile.Count()+m_cpaAdds.Count()-m_cuaRemovals.Count();
                    if (id >= listsize) id = listsize-1;
                    if (id < 0)         id = 0;
                    SendMessage(m_hwndList, LB_SETCURSEL, id, 0);

                    return  TRUE;
                }
            }
            break;

        case    LBN_SELCHANGE: {

            LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);
            
            if (id == -1) {
                EnableWindow(GetDlgItem(m_hwnd, RemoveButton), FALSE);
            } else {

                // The Remove button must remain disabled on a monitor
                // profile property page if the user isn't the
                // Administrator, otherwise enable remove button.

                EnableWindow(GetDlgItem(m_hwnd, RemoveButton), !m_bReadOnly);
            }

            return  TRUE;
        }
    }

    return  FALSE;
}

//  Property Sheet notification processing

BOOL    CDeviceProfileManagement::OnNotify(int idCtrl, LPNMHDR pnmh) {

    switch  (pnmh -> code) {

        case    PSN_APPLY:

            DisableApplyButton();

            if (SettingChanged()) {

                //  Apply the changes the user has made...

                SettingChanged(FALSE);

                while   (m_cpaAdds.Count()) {
                    if  (!m_cpaAdds[0] -> IsInstalled()) {
                        m_cpaAdds[0] -> Install();
                    }
                    m_cpaAdds[0] -> Associate(m_csDevice);
                    m_cpaAdds.Remove(0);
                }

                //  Now do the removals (actually just dissociations)

                while   (m_cuaRemovals.Count()) {
                    m_cpaProfile[m_cuaRemovals[0]] -> Dissociate(m_csDevice);
                    m_cuaRemovals.Remove(0);
                }

                InitList();
                FillList();

                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            }

            return  TRUE;
    }

    return  FALSE;
}

//  This hook procedure both forces the use of the old-style common dialog
//  and changes the OK button to an Add button.  The actual button text is
//  a string resource, and hence localizable.

UINT_PTR APIENTRY CAddProfileDialog::OpenFileHookProc(HWND hDlg, UINT uMessage,
                                                  WPARAM wp, LPARAM lp) {
    switch  (uMessage) {

        case    WM_INITDIALOG: {

            CString csAddButton;

            OPENFILENAME    *pofn = (OPENFILENAME *) lp;

            csAddButton.Load(AddButtonText);

            SetDlgItemText(GetParent(hDlg), IDOK, csAddButton);
            return  TRUE;
        }
    }

    return  FALSE;
}

//  Once again, a constructor that actually does most of the work!

TCHAR gacColorDir[MAX_PATH] = _TEXT("\0");
TCHAR gacFilter[MAX_PATH]   = _TEXT("\0");

CAddProfileDialog::CAddProfileDialog(HWND hwndOwner, HINSTANCE hi) {

    TCHAR tempBuffer[MAX_PATH*10];

    // Empty the profile list.

    csa_Files.Empty();

    // Prepare file filter (if not yet).

    if (gacFilter[0] == NULL) {

        ULONG offset; /* 32bits is enough even for sundown */
        CString csIccFilter; CString csAllFilter;

        // If the filter is not built yet, build it here.

        csIccFilter.Load(IccProfileFilterString);
        csAllFilter.Load(AllProfileFilterString);
        offset = 0;
        lstrcpy(gacFilter+offset, csIccFilter);
        offset += lstrlen(csIccFilter)+1;
        lstrcpy(gacFilter+offset, TEXT("*.icm;*.icc"));
        offset += lstrlen(TEXT("*.icm;*.icc"))+1;
        lstrcpy(gacFilter+offset, csAllFilter);
        offset += lstrlen(csAllFilter)+1;
        lstrcpy(gacFilter+offset, TEXT("*.*"));
        offset += lstrlen(TEXT("*.*"))+1;
        *(gacFilter+offset) = TEXT('\0');
    }

    if (gacColorDir[0] == _TEXT('\0'))  {
        DWORD dwcbDir = MAX_PATH;
        GetColorDirectory(NULL, gacColorDir, &dwcbDir);
    }

    //  Time to do the old OpenFile dialog stuff...
    CString csTitle; csTitle.Load(AddProfileAssociation);

    //  Set initial filename as null.
    memset(tempBuffer, 0, sizeof tempBuffer);

    OPENFILENAME ofn = {
        sizeof ofn, hwndOwner, hi,
        gacFilter,
        NULL, 0, 1,
        tempBuffer, sizeof tempBuffer / sizeof tempBuffer[0],
        NULL, 0,
        gacColorDir,
        csTitle,
        OFN_ALLOWMULTISELECT | OFN_EXPLORER | OFN_HIDEREADONLY |
        OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_ENABLEHOOK,
        0, 0,
        _TEXT("icm"),
        (LPARAM) this, OpenFileHookProc, NULL};

    if  (!GetOpenFileName(&ofn)) {
        if (CommDlgExtendedError() == FNERR_BUFFERTOOSMALL) {
            CGlobals::Report(TooManyFileSelected);
        }
    } else {
        if (tempBuffer[0] != TEXT('\0')) {

            TCHAR *pPath = tempBuffer;
            TCHAR *pFile = tempBuffer + lstrlen(tempBuffer) + 1;

            // remember the last access-ed directory.

            memset(gacColorDir, 0, sizeof pPath);
            memcpy(gacColorDir, pPath, ofn.nFileOffset*sizeof(TCHAR));

            if (*pFile) {
                TCHAR workBuffer[MAX_PATH];

                // This is multiple-selection
                // Work through the buufer to build profile file list.

                while (*pFile) {

                    lstrcpy(workBuffer,pPath);
                    lstrcat(workBuffer,TEXT("\\"));
                    lstrcat(workBuffer,pFile);

                    // Insert built profile pathname
                    AddProfile(workBuffer);

                    // Move on to next.
                    pFile = pFile + lstrlen(pFile) + 1;
                }
            }
            else {
                // Single selection case.
                AddProfile(pPath);

                #if HIDEYUKN_DBG
                MessageBox(NULL,pPath,TEXT(""),MB_OK);
                #endif
            }
        }
    }

    return;
}

//  Printer Profile Management

CONST DWORD PrinterUIHelpIds[] = {
    AddButton,              IDH_PRINTERUI_ADD,
    RemoveButton,           IDH_PRINTERUI_REMOVE,
    ProfileListControl,     IDH_PRINTERUI_LIST,

#if !defined(_WIN95_)
    ProfileListControlText, IDH_PRINTERUI_LIST,
    PrinterUIIcon,          IDH_DISABLED,
    DescriptionText,        IDH_DISABLED,
    DefaultButton,          IDH_PRINTERUI_DEFAULTBTN,
    AutoSelButton,          IDH_PRINTERUI_AUTOMATIC,
    AutoSelText,            IDH_PRINTERUI_AUTOMATIC,
    ManualSelButton,        IDH_PRINTERUI_MANUAL,
    ManualSelText,          IDH_PRINTERUI_MANUAL,
    DefaultProfileText,     IDH_PRINTERUI_DEFAULTTEXT,
    DefaultProfile,         IDH_PRINTERUI_DEFAULTTEXT,
#endif
    0, 0
};

//  Initialize lists override- call the base class, then set the default

void    CPrinterProfileManagement::InitList() {

    CDeviceProfileManagement::InitList();

    m_uDefault = m_cpaProfile.Count() ? 0 : (unsigned) -1;
}

//  Fill list override- write the correct default and call the base function

void    CPrinterProfileManagement::FillList(DWORD dwFlags) {

    //  If we are initializing list box, we want to put focus on
    //  "default" profile. here we won't below FillList set focus
    //  to first one.

    if (dwFlags & DEVLIST_ONINIT) {
        dwFlags |= DEVLIST_NOSELECT;
    }

    CDeviceProfileManagement::FillList(dwFlags);

    //  There is either no default profile, an existing profile is the
    //  default, or a newly selected one is.  Some people just like the
    //  selection operator.

    //  if there is only 1 profile in list box, we treat it as default profile.
    
    if (SendMessage(m_hwndList,LB_GETCOUNT,0,0) == 1) {
        m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 0, 0);
    }

    if (m_uDefault == -1) {

        // There is no profile associated for this device.

        CString csNoProfile;
        csNoProfile.Load(NoProfileString);
        SetDlgItemText(m_hwnd, DefaultProfile, csNoProfile);        

    } else {

        // If the default has been deleted, set default as last in list.

        if (m_uDefault >= (m_cpaProfile.Count() + m_cpaAdds.Count())) {

            m_uDefault = (m_cpaProfile.Count() + m_cpaAdds.Count()) - 1;
        }

        // Put default profile name in UI.

        CProfile *pcpDefault = (m_uDefault < m_cpaProfile.Count()) ? \
                                           m_cpaProfile[m_uDefault] : \
                                           m_cpaAdds[m_uDefault - m_cpaProfile.Count()];

        SetDlgItemText(m_hwnd, DefaultProfile, pcpDefault -> GetName());

        LRESULT idSelect = SendMessage(m_hwndList, LB_FINDSTRINGEXACT,
                                   (WPARAM) -1, (LPARAM) (LPCTSTR) pcpDefault -> GetName());

        // if could not find, just select first item.

        if (idSelect == LB_ERR) {
            idSelect = 0;
        }

        // Select it.

        SendMessage(m_hwndList, LB_SETCURSEL, idSelect, 0);
    }

    //  03-08-1997  Bob_Kjelgaard@Prodigy.Net   Memphis RAID 18420
    //  Disable the Default button if there aren't any profiles

    if (m_bManualMode && m_bAdminAccess) {
        EnableWindow(GetDlgItem(m_hwnd, DefaultButton),
                     m_cpaAdds.Count() + m_cpaProfile.Count() - m_cuaRemovals.Count());
    }
}

//  Printer Profile Management class constructor- doesn't need any individual
//  code at the moment.

CPrinterProfileManagement::CPrinterProfileManagement(LPCTSTR lpstrName,
                                                     HINSTANCE hiWhere) :
    CDeviceProfileManagement(lpstrName, hiWhere, PrinterUI, CLASS_PRINTER) {
}

//  This class overrides OnInit so it can disable the UI if the user lacks
//  authority to make changes.

BOOL    CPrinterProfileManagement::OnInit() {

    //  Call the base class routine first, as it does most of the work...

    CDeviceProfileManagement::OnInit();

    DWORD dwSize = sizeof(DWORD);

    //  Query current mode.

    if (!InternalGetDeviceConfig((LPCTSTR)m_csDevice, CLASS_PRINTER,
                                 MSCMS_PROFILE_ENUM_MODE, &m_bManualMode, &dwSize)) {

        //  Auto selection mode as default.

        m_bManualMode = FALSE;
    }

    //  Now, see if we have sufficient authority to administer the printer

    HANDLE  hPrinter;
    PRINTER_DEFAULTS    pd = {NULL, NULL, PRINTER_ACCESS_ADMINISTER};

    m_bAdminAccess  = TRUE;
    m_bLocalPrinter = TRUE;

    if  (OpenPrinter(const_cast<LPTSTR> ((LPCTSTR) m_csDevice), &hPrinter, &pd)) {

        //  We can administer the printer- proceed in the normal way.

#if !defined(_WIN95_)

        //  If the printer is "Network Printer", we don't allow user to install
        //  or uninstall color profile.

        BYTE  StackPrinterData[sizeof(PRINTER_INFO_4)+MAX_PATH*2];
        PBYTE pPrinterData = StackPrinterData;
        BOOL  bSuccess = TRUE;
        DWORD dwReturned;

        if (!GetPrinter(hPrinter, 4, pPrinterData, sizeof(StackPrinterData), &dwReturned)) {

            if ((GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
                (pPrinterData = (PBYTE) LocalAlloc(LPTR, dwReturned))) {

                if (GetPrinter(hPrinter, 4, pPrinterData, dwReturned, &dwReturned)) {

                    bSuccess = TRUE;

                }
            }

        } else {

            bSuccess = TRUE;
        }
       
        if (bSuccess)
        {
            m_bLocalPrinter = ((PRINTER_INFO_4 *)pPrinterData)->pServerName ? FALSE : TRUE;
        }
        else
        {
            m_bAdminAccess = FALSE;
        }

        if (pPrinterData && (pPrinterData != StackPrinterData))
        {
            LocalFree(pPrinterData);
        }

#endif // !defined(_WIN95_)

        ClosePrinter(hPrinter);

    } else {

        m_bAdminAccess = FALSE;
    }

    // How many profile in listbox ?

    LRESULT itemCount = SendMessage(m_hwndList, LB_GETCOUNT, 0, 0);
    if (itemCount == LB_ERR) itemCount = 0;

    //  make sure the ancestor list code behaves correctly.
    //  You need Admin Access and a Local Printer to be able to add/remove profiles

    m_bReadOnly = !(m_bAdminAccess && m_bLocalPrinter);

    //  Enable/Disable the controls (if needed)

    CheckDlgButton(m_hwnd, AutoSelButton, m_bManualMode ? BST_UNCHECKED : BST_CHECKED);
    CheckDlgButton(m_hwnd, ManualSelButton, m_bManualMode ? BST_CHECKED : BST_UNCHECKED);

    //  Only administrator can change 'auto','manual' configuration.

    EnableWindow(GetDlgItem(m_hwnd, AutoSelButton), m_bAdminAccess && m_bLocalPrinter);
    EnableWindow(GetDlgItem(m_hwnd, ManualSelButton), m_bAdminAccess && m_bLocalPrinter);

    //  Only administrator and printer is at local, can install/uninstall color profile.

    EnableWindow(GetDlgItem(m_hwnd, AddButton), m_bAdminAccess && m_bLocalPrinter);
    EnableWindow(GetDlgItem(m_hwnd, RemoveButton), m_bAdminAccess && m_bLocalPrinter && itemCount);

    EnableWindow(m_hwndList, m_bAdminAccess);
    EnableWindow(GetDlgItem(m_hwnd, DefaultProfileText), m_bAdminAccess);
    EnableWindow(GetDlgItem(m_hwnd, DefaultProfile), m_bAdminAccess);

    //  Only with manual mode, these controls are enabled.

    EnableWindow(GetDlgItem(m_hwnd, DefaultButton), m_bAdminAccess && m_bManualMode
                                                         && m_bLocalPrinter && itemCount);

    if (!m_bAdminAccess) {

        //  Set the focus to the OK button

        SetFocus(GetDlgItem(m_hwndSheet, IDOK));
        return  FALSE;  //  Because we moved the focus!
    }

    return TRUE;
}

//  Command processing- we never let them click into the edit control, to
//  prevent them from editing it.

BOOL    CPrinterProfileManagement::OnCommand(WORD wNotifyCode, WORD wid,
                                             HWND hwndCtl) {

    switch  (wNotifyCode) {

        case    LBN_DBLCLK: {

            //  Retrieve the ID of the new default profile          
            //  only accept dblclk changes if the dialog
            //  is not read only - i.e. user is admin

            if  (m_bManualMode) {

                int id = (int)SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);
                m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, id, 0);

                //  Change has been made, update the list

                FillList(DEVLIST_CHANGED);
            }

            return  TRUE;
        }

        case    BN_CLICKED:

            switch  (wid) {

                case    AutoSelButton:
                case    ManualSelButton: {

                    // How many profile in listbox ?

                    LRESULT itemCount = SendMessage(m_hwndList, LB_GETCOUNT, 0, 0);
                    if (itemCount == LB_ERR) itemCount = 0;

                    m_bManualMode = (wid == ManualSelButton) ? TRUE : FALSE;

                    //  Only with manual mode, these controls are enabled.

                    EnableWindow(GetDlgItem(m_hwnd, DefaultButton), m_bManualMode && itemCount);

                    //  Configuarion has been changed, enable apply button.

                    EnableApplyButton();
                    SettingChanged(TRUE);

                    return TRUE;
                }

                case    RemoveButton: {

                    //  Make sure we've tracked the default profile correctly
                    //  when a profile is removed.
                    //  All cases break, because we then want the base class to
                    //  process this message.

                    LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                    unsigned uTarget = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA,
                        id, 0);

                    if  (uTarget > m_uDefault || m_uDefault == (unsigned) -1)
                        break;  //  Nothing here to worry about

                    if  (m_uDefault == uTarget) {

                        if (CGlobals::ReportEx(AskRemoveDefault, m_hwnd, FALSE,
                                               MB_YESNO|MB_ICONEXCLAMATION,0) == IDYES) {

                            //  The default has been deleted- the profile
                            //  at the top of monitor profile list will be
                            //  made the default profile, if we have

                            LRESULT itemCount = SendMessage(m_hwndList, LB_GETCOUNT, 0, 0);

                            if ((itemCount != LB_ERR) && (itemCount > 1)) {
                                m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 0, 0);
                                if (m_uDefault == uTarget) {
                                    m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 1, 0);
                                }
                            } else {
                                m_uDefault = -1;
                            }

                            break;
                        } else {
                            return TRUE; // opration cancelled.
                        }
                    }

                    if  (uTarget < m_cpaProfile.Count())
                        break;  // We're fine

                    //  Must be an added profile below us in the list was
                    //  zapped- we need to decrement ourselves.

                    m_uDefault--;
                    break;
                }

                case    DefaultButton: {

                    LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                    m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, id, 0);

                    //  Change has been made, update the list

                    FillList(DEVLIST_CHANGED);

                    return  TRUE;
                }
            }

        //  Deliberate fall-through (use a break if you add a case here)
    }

    //  Use common command handling if not handled above

    return  CDeviceProfileManagement::OnCommand(wNotifyCode, wid, hwndCtl);
}

//  Property Sheet notification processing

BOOL    CPrinterProfileManagement::OnNotify(int idCtrl, LPNMHDR pnmh) {

    switch  (pnmh -> code) {

        case    PSN_APPLY: {

            DisableApplyButton();

            //  If nothing changed, nothing need to do.

            if (!SettingChanged())
                return TRUE;

            if (m_bManualMode) {

                //  If the user hasn't selected a default, and we have
                //  associated profiles, then we can't allow this.

                //  03-08-1997  A-RobKj Fix for Memphis RAID 18416- if there's
                //  only one profile left, then it must be the default.

                if  (m_uDefault == (unsigned) -1 && (m_cpaAdds.Count() +
                     m_cpaProfile.Count() - m_cuaRemovals.Count()) > 1) {

                    CGlobals::Report(NoDefaultProfile, m_hwndSheet);
                    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                //  ATTENTION: This behavior is hardly depend on EnumColorProfiles() API

                //  OK, if the default profile has changed, we have to delete default
                //  profile associations, and do the association for default profile
                //  in "last".

                //  Let the base class handle the cases where the default hasn't
                //  changed, or we started with no profiles and still have none.
                //
                //  03-08-1997  Sleazy code note.  The case where no default is
                //  selected but only one is assigned will now fall here.  Since the
                //  default happens to be the "last", and there only is one, letting
                //  the base class handle it is not a problem.  The list filling
                //  code will take care of the rest for us.

                if  (m_uDefault == (unsigned) -1) break;

                //  Remove default first (if default is associated), then associate later.

                if  (m_uDefault < m_cpaProfile.Count())
                    m_cpaProfile[m_uDefault] -> Dissociate(m_csDevice);

                //  Now do the other removals (actually just dissociations)

                for (unsigned u = 0; u < m_cuaRemovals.Count(); u++) {
                    m_cpaProfile[m_cuaRemovals[u]] -> Dissociate(m_csDevice);
                }

                //  Add in the new ones

                for (u = 0; u < m_cpaAdds.Count(); u++) {
                    if  (m_uDefault >= m_cpaProfile.Count())
                        if  (u == (m_uDefault - m_cpaProfile.Count()))
                            continue;   // this is default, will be done later

                    //  OK, add it back in...
                    m_cpaAdds[u] -> Associate(m_csDevice);
                }

                //  Finally, associate back default profile.

                if  (m_uDefault < m_cpaProfile.Count())
                    m_cpaProfile[m_uDefault] -> Associate(m_csDevice);
                else
                    m_cpaAdds[m_uDefault - m_cpaProfile.Count()] -> Associate(m_csDevice);

                //  Update the various working structures...

                InitList();
                FillList();

                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);

                //  Now, we have updated settings.

                SettingChanged(FALSE);
            }

            // Update "auto/manual" status.

            InternalSetDeviceConfig((LPCTSTR)m_csDevice, CLASS_PRINTER,
                                    MSCMS_PROFILE_ENUM_MODE, &m_bManualMode, sizeof(DWORD));
        }
    }

    //  Let the base class handle everything else

    return  CDeviceProfileManagement::OnNotify(idCtrl, pnmh);
}

//  Context-sensitive help handler

BOOL    CPrinterProfileManagement::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
                HELP_WM_HELP, (ULONG_PTR) (LPSTR) PrinterUIHelpIds);
    }

    return (TRUE);
}

BOOL    CPrinterProfileManagement::OnContextMenu(HWND hwnd) {

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) PrinterUIHelpIds);

    return (TRUE);
}

//  Scanner Profile Management
//  Scanner Profile Management class constructor- doesn't need any individual
//  code at the moment.

//  Scanner Profile Management

CONST DWORD ScannerUIHelpIds[] = {
#if !defined(_WIN95_)
    AddButton,          IDH_SCANNERUI_ADD,
    RemoveButton,       IDH_SCANNERUI_REMOVE,
    ProfileListControl, IDH_SCANNERUI_LIST,
    ProfileListControlText, IDH_SCANNERUI_LIST,
#endif
    0, 0
};

CScannerProfileManagement::CScannerProfileManagement(LPCTSTR lpstrName,
                                                     HINSTANCE hiWhere) :

    CDeviceProfileManagement(lpstrName, hiWhere, ScannerUI, CLASS_SCANNER) {
    m_bReadOnly = !IsAdmin();
}

//  This class overrides OnInit so it can disable the UI if the user lacks
//  authority to make changes.

BOOL    CScannerProfileManagement::OnInit() {

    //  Call the base class routine first, as it does most of the work...

    CDeviceProfileManagement::OnInit();

    //  Now, see if we have sufficient authority to administer the scanner
    //
    if (m_bReadOnly) {    
        // User is not Admin, Disable all of the controls

        EnableWindow(GetDlgItem(m_hwnd, AddButton), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, RemoveButton), FALSE);

        //  Set the focus to the OK button
        SetFocus(GetDlgItem(m_hwndSheet, IDOK));
        return  FALSE;  //  Because we moved the focus!
    }

    return TRUE;
}

//  Context-sensitive help handler

BOOL    CScannerProfileManagement::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
                HELP_WM_HELP, (ULONG_PTR) (LPSTR) ScannerUIHelpIds);
    }

    return (TRUE);
}

BOOL    CScannerProfileManagement::OnContextMenu(HWND hwnd) {

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) ScannerUIHelpIds);

    return (TRUE);
}



//  Monitor Profile Management class- since the mechanism for default
//  profile manipulation is a bit sleazy, so is some of this code.

CONST DWORD MonitorUIHelpIds[] = {
    AddButton,              IDH_MONITORUI_ADD,
    RemoveButton,           IDH_MONITORUI_REMOVE,
    DefaultButton,          IDH_MONITORUI_DEFAULT,
    ProfileListControl,     IDH_MONITORUI_LIST,
#if !defined(_WIN95_)
    ProfileListControlText, IDH_MONITORUI_LIST,
    MonitorName,            IDH_MONITORUI_DISPLAY,
    MonitorNameText,        IDH_MONITORUI_DISPLAY,
    DefaultProfile,         IDH_MONITORUI_PROFILE,
    DefaultProfileText,     IDH_MONITORUI_PROFILE,
#endif
    0, 0
};

//  Initialize lists override- call the base class, then set the default

void    CMonitorProfileManagement::InitList() {

    CDeviceProfileManagement::InitList();

    m_uDefault = m_cpaProfile.Count() ? 0 : (unsigned) -1;
}

//  Fill list override- write the correct default and call the base function

void    CMonitorProfileManagement::FillList(DWORD dwFlags) {

    //  If we are initializing list box, we want to put focus on
    //  "default" profile. here we won't below FillList set focus
    //  to first one.

    if (dwFlags & DEVLIST_ONINIT) {
        dwFlags |= DEVLIST_NOSELECT;
    }

    CDeviceProfileManagement::FillList(dwFlags);

    //  There is either no default profile, an existing profile is the
    //  default, or a newly selected one is.  Some people just like the
    //  selection operator.

    //  if there is only 1 profile in list box, we treat it as default profile.
    
    if (SendMessage(m_hwndList,LB_GETCOUNT,0,0) == 1) {
        m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 0, 0);
    }

    if (m_uDefault == -1) {

        // There is no profile associated for this device.

        CString csNoProfile;
        csNoProfile.Load(NoProfileString);
        SetDlgItemText(m_hwnd, DefaultProfile, csNoProfile);        

    } else {

        // If the default has been deleted, set default as last in list.

        if (m_uDefault >= (m_cpaProfile.Count() + m_cpaAdds.Count())) {

            m_uDefault = (m_cpaProfile.Count() + m_cpaAdds.Count()) - 1;
        }

        // Put default profile name in UI.

        CProfile *pcpDefault = (m_uDefault < m_cpaProfile.Count()) ? \
                                           m_cpaProfile[m_uDefault] : \
                                           m_cpaAdds[m_uDefault - m_cpaProfile.Count()];

        SetDlgItemText(m_hwnd, DefaultProfile, pcpDefault -> GetName());

        // If we are initialing list box, put focus on default profile.

        if (dwFlags & DEVLIST_ONINIT) {

            LRESULT idSelect = SendMessage(m_hwndList, LB_FINDSTRINGEXACT,
                                   (WPARAM) -1, (LPARAM) (LPCTSTR) pcpDefault -> GetName());

            // if could not find, just select first item.

            if (idSelect == LB_ERR) {
                idSelect = 0;
            }

            // Select it.

            SendMessage(m_hwndList, LB_SETCURSEL, idSelect, 0);
        }
    }

    //  03-08-1997  Bob_Kjelgaard@Prodigy.Net   Memphis RAID 18420
    //  Disable the Default button if there aren't any profiles

    // We do it here, because this gets called any time the list changes.   
    // only allow Default button to be enabled if
    // the dialog isn't read only.
    // the remove button should remain dissabled
    // under all conditions while the user is not
    // administrator.

    if (m_bReadOnly) {
        EnableWindow(GetDlgItem(m_hwnd, RemoveButton), FALSE);
    } else {
        EnableWindow(GetDlgItem(m_hwnd, DefaultButton),
                     m_cpaAdds.Count() + m_cpaProfile.Count() - m_cuaRemovals.Count());
    }
}

//  Constructor

CMonitorProfileManagement::CMonitorProfileManagement(LPCTSTR lpstrName,
                                                     LPCTSTR lpstrFriendlyName,
                                                     HINSTANCE hiWhere) :
  CDeviceProfileManagement(lpstrName, hiWhere, MonitorUI, CLASS_MONITOR) {


   // if the user is not the administrator,
   // make this property sheet read only.

   m_bReadOnly = !IsAdmin();

   // Keep friendly name in MonitorProfileManagement class.

   m_csDeviceFriendlyName = lpstrFriendlyName;
}

//  UI Initialization

BOOL    CMonitorProfileManagement::OnInit() {

    //  Do common initializations

    CDeviceProfileManagement::OnInit();

    //  Mark the device name in the space provided

    SetDlgItemText(m_hwnd, MonitorName, m_csDeviceFriendlyName);
    
    //  Now, see if we have sufficient authority to administer the monitor

    if(m_bReadOnly) {

        //  User is not Admin, Disable all of the controls

        EnableWindow(GetDlgItem(m_hwnd, AddButton), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, RemoveButton), FALSE);
        EnableWindow(GetDlgItem(m_hwnd, DefaultButton), FALSE);

        //  EnableWindow(m_hwndList, FALSE);

        //  Set the focus to the OK button

        SetFocus(GetDlgItem(m_hwndSheet, IDOK));
        return  FALSE;  //  Because we moved the focus!
    }

    return  TRUE;
}

//  Command processing- we never let them click into the edit control, to
//  prevent them from editing it.

BOOL    CMonitorProfileManagement::OnCommand(WORD wNotifyCode, WORD wid,
                                             HWND hwndCtl) {

    switch  (wNotifyCode) {

        case    LBN_DBLCLK: {

            //  Retrieve the ID of the new default profile          
            //  only accept dblclk changes if the dialog
            //  is not read only - i.e. user is admin

            if  (!m_bReadOnly) {

                int id = (int)SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);
                m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, id, 0);

                //  Change has been made, update the list

                FillList(DEVLIST_CHANGED);
            }

            return  TRUE;
        }

        case    BN_CLICKED:

            switch  (wid) {

                case    RemoveButton: {

                    //  Make sure we've tracked the default profile correctly
                    //  when a profile is removed.
                    //  All cases break, because we then want the base class to
                    //  process this message.

                    LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                    unsigned uTarget = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA,
                        id, 0);

                    if  (uTarget > m_uDefault || m_uDefault == (unsigned) -1)
                        break;  //  Nothing here to worry about

                    if  (m_uDefault == uTarget) {

                        if (CGlobals::ReportEx(AskRemoveDefault, m_hwnd, FALSE,
                                               MB_YESNO|MB_ICONEXCLAMATION,0) == IDYES) {

                            //  The default has been deleted- the profile
                            //  at the top of monitor profile list will be
                            //  made the default profile, if we have

                            LRESULT itemCount = SendMessage(m_hwndList, LB_GETCOUNT, 0, 0);

                            if ((itemCount != LB_ERR) && (itemCount > 1)) {
                                m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 0, 0);
                                if (m_uDefault == uTarget) {
                                    m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, 1, 0);
                                }
                            } else {
                                m_uDefault = -1;
                            }

                            break;
                        } else {
                            return TRUE; // operation cancelled.
                        }
                    }

                    if  (uTarget < m_cpaProfile.Count())
                        break;  // We're fine

                    //  Must be an added profile below us in the list was
                    //  zapped- we need to decrement ourselves.

                    m_uDefault--;
                    break;
                }

                case    DefaultButton: {

                    LRESULT id = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                    m_uDefault = (unsigned)SendMessage(m_hwndList, LB_GETITEMDATA, id, 0);

                    //  Change has been made, update the list

                    FillList(DEVLIST_CHANGED);

                    return  TRUE;
                }
            }

        //  Deliberate fall-through (use a break if you add a case here)
    }

    //  Use common command handling if not handled above
    return  CDeviceProfileManagement::OnCommand(wNotifyCode, wid, hwndCtl);
}

//  Property Sheet notification processing

BOOL    CMonitorProfileManagement::OnNotify(int idCtrl, LPNMHDR pnmh) {

    switch  (pnmh -> code) {

        case    PSN_APPLY: {

            DisableApplyButton();

            //  If nothing changed, nothing need to do.

            if (!SettingChanged())
                return TRUE;

            //  If the user hasn't selected a default, and we have
            //  associated profiles, then we can't allow this.

            //  03-08-1997  A-RobKj Fix for Memphis RAID 18416- if there's
            //  only one profile left, then it must be the default.

            if  (m_uDefault == (unsigned) -1 && (m_cpaAdds.Count() +
                 m_cpaProfile.Count() - m_cuaRemovals.Count()) > 1) {

                CGlobals::Report(NoDefaultProfile, m_hwndSheet);
                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                break;
            }

            //  ATTENTION: This behavior is hardly depend on EnumColorProfiles() API

            //  OK, if the default profile has changed, we have to delete default
            //  profile associations, and do the association for default profile
            //  in "last".

            //  Let the base class handle the cases where the default hasn't
            //  changed, or we started with no profiles and still have none.
            //
            //  03-08-1997  Sleazy code note.  The case where no default is
            //  selected but only one is assigned will now fall here.  Since the
            //  default happens to be the "last", and there only is one, letting
            //  the base class handle it is not a problem.  The list filling
            //  code will take care of the rest for us.

            if  (m_uDefault == (unsigned) -1) break;

            //  Remove default first (if default is associated), then associate later.

            if  (m_uDefault < m_cpaProfile.Count())
                m_cpaProfile[m_uDefault] -> Dissociate(m_csDevice);

            //  Now do the other removals (actually just dissociations)

            for (unsigned u = 0; u < m_cuaRemovals.Count(); u++) {
                m_cpaProfile[m_cuaRemovals[u]] -> Dissociate(m_csDevice);
            }

            //  Add in the new ones

            for (u = 0; u < m_cpaAdds.Count(); u++) {
                if  (m_uDefault >= m_cpaProfile.Count())
                    if  (u == (m_uDefault - m_cpaProfile.Count()))
                        continue;   // this is default, will be done later

                //  OK, add it back in...
                m_cpaAdds[u] -> Associate(m_csDevice);
            }

            //  Finally, associate default profile.

            if  (m_uDefault < m_cpaProfile.Count())
                m_cpaProfile[m_uDefault] -> Associate(m_csDevice);
            else
                m_cpaAdds[m_uDefault - m_cpaProfile.Count()] -> Associate(m_csDevice);

            //  Update the various working structures...

            InitList();
            FillList();

            SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);

            //  Now, we have updated settings.

            SettingChanged(FALSE);
        }
    }

    //  Let the base class handle everything else

    return  CDeviceProfileManagement::OnNotify(idCtrl, pnmh);
}

//  Context-sensitive help handler

BOOL    CMonitorProfileManagement::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
            HELP_WM_HELP, (ULONG_PTR) (LPSTR) MonitorUIHelpIds);
    }

    return (TRUE);
}

BOOL    CMonitorProfileManagement::OnContextMenu(HWND hwnd) {

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) MonitorUIHelpIds);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\icmuihlp.h ===
//
// Mon-8/4/97
//
// Help ID strings and map numbers for color_cs.rtf
//
//

#include <help.h>

#define WINDOWS_HELP_FILE   TEXT("windows.hlp")

// Help topics.
//
// Click to associate the selected device with the profile displayed on the Profile Information tab.

#define IDH_DISABLED               (-1)


#define IDH_ASSOCDEVICE_ADD        99990000 // Color Mgt, Associate Device tab on Color Profile property sheet

// Removes the association between the selected device and the profile displayed on the Profile Information tab.

#define IDH_ASSOCDEVICE_REMOVE     99990001 // Color Mgt, Associate Device tab on Color Profile property sheet

#if !defined(_WIN95_)

// Displays the name of the color profile you want to associate to a device.
//
// (Winnt Only)

#define IDH_ASSOCDEVICE_NAME       99990002 // Color Mgt, Associate Device tab on Color Profile property sheet

// Lists the hardware devices on this computer that are associated with this color profile.
//
// (Winnt Only)

#define IDH_ASSOCDEVICE_LIST       99982140 // Color Mgt, Associate Device, List 

#endif // !defined(_WIN95_)

// Click to associate a new profile with this printer.

#define IDH_110_132                99810132 // Color Mgt, Printer, Add Button
#define IDH_PRINTERUI_ADD          99810132

// Removes a profile from the list.

#define IDH_110_133                99790133 // Color Mgt, Printer, Remove Button
#define IDH_PRINTERUI_REMOVE       99790133

// Lists all the color profiles currently associated with this printer.
// Click a profile to make it the active profile.

#define IDH_110_141                99960141 // Color Mgt, Printer, List Box, 
#define IDH_PRINTERUI_LIST	       99960141	


// printer ui automatic profile selection radio button

#define IDH_PRINTERUI_AUTOMATIC    99990006

// printer ui manual selection radio button

#define IDH_PRINTERUI_MANUAL       99990007

// Printer UI default text item

#define IDH_PRINTERUI_DEFAULTTEXT  99990008

// Set as default printer ui button.

#define IDH_PRINTERUI_DEFAULTBTN   99990009


// Click to associate a new profile with this monitor.

#define IDH_111_132                99821132 // color mgt, Monitor, Add Button
#define IDH_MONITORUI_ADD          99821132

// Removes a profile from the list.

#define IDH_111_133                99801133 // Color Mgt, Monitor, Remove Button
#define IDH_MONITORUI_REMOVE       99801133

// Makes the selected profile the default profile.

#define IDH_111_134                99781134 // Color Mgt, Set as Default
#define IDH_MONITORUI_DEFAULT      99781134

// Lists all the color profiles currently associated with this monitor.
// Click a profile to make it the active profile. Otherwise, the default profile is the active profile.

#define IDH_111_141                99971141 // Color Mgt, Monitor, List box
#define IDH_MONITORUI_LIST         99971141

// Displays the name of the current monitor.

#define IDH_111_150                99891150 // Color Mgt, Monitor, name here	
#define IDH_MONITORUI_DISPLAY      99891150	

// Displays the name of the current default profile for this monitor.

#define IDH_111_152                99851152 // Color mgt, Monitor, Edit
#define IDH_MONITORUI_PROFILE      99851152

#if defined(_WIN95_)

// Click to associate the selected device with this color profile.

#define IDH_112_130                99832130
#define IDH_ADDDEVICEUI_ADD        99832130

#else

#define IDH_112_130                IDH_ASSOCDEVICE_ADD 
#define IDH_ADDDEVICEUI_ADD        IDH_ASSOCDEVICE_ADD 

#endif // defined(_WIN95_)

#if defined(_WIN95_)

// Lists all the hardware devices on this computer that can be associated with this color profile.

#define IDH_112_140                99982140 // Color Mgt, Add Device, List Box
#define IDH_ADDDEVICEUI_LIST       99982140

#else

// Lists the hardware devices on this computer that can be associated with this color profile.

#define IDH_112_140                99982141 // Color Mgt, Add Device, List Box
#define IDH_ADDDEVICEUI_LIST       99982141

#endif

#if defined(_WIN95_)

// Saves your changes and leaves the dialog box open.

#define IDH_1548_1024              99861024
#define IDH_ICMUI_APPLY            99861024

#else

#define IDH_ICMUI_APPLY            IDH_COMM_APPLYNOW
#define IDH_1548_1024              IDH_COMM_APPLYNOW

#endif // defined(_WIN95_)

// Click to enable color management for this document.

#define IDH_1548_1040              99941040 // Color Mgt, Enable 
#define IDH_APPUI_ICM              99941040

#if defined(_WIN95_)

// Lists the profiles you can use with this monitor.

#define IDH_1548_1136              99911136
#define IDH_APPUI_MONITOR          99911136

#else

#define IDH_1548_1136              IDH_MONITORUI_LIST
#define IDH_APPUI_MONITOR          IDH_MONITORUI_LIST

#endif // defined(_WIN95_)

#if defined(_WIN95_)

// Lists the profiles you can use with this printer.

#define IDH_1548_1137              99901137
#define IDH_APPUI_PRINTER          99901137

#else

#define IDH_1548_1137              IDH_PRINTERUI_LIST
#define IDH_APPUI_PRINTER          IDH_PRINTERUI_LIST

#endif // defined(_WIN95_)

// Lists the rendering intents you can use.
//
//  A rendering intent is the approach used to map the colors of an image 
// to the color gamut of a monitor or printer. The color gamut is the range
// of color that a device can produce.
//
//  Perceptual matching is best for photographic images.
// All the colors of one gamut are scaled to fit within another gamut.
// The relationship between colors is maintained.
//
//  Saturation matching is best for graphs and pie charts,
// in which vividness is more important than actual color. The relative
// saturation of colors is maintained from gamut to gamut. Colors outside
// the gamut are changed to colors of the same saturation, but different
// degrees of brightness, at the edge of the gamut.
//
//  Relative Colorimetric matching is best for logo images,
// in which a few colors must be matched exactly. The colors that fall
// within the gamuts of both devices are left unchanged. Other colors 
// may map to a single color, however, resulting in tone compression.
//
//  Absolute Colorimetric matching is used for mapping to a device-independent
// color space. The result is an idealized print viewed on a perfect paper with
// a large dynamic range and color gamut.

#define IDH_1548_1138              99881138 // Color Mgt, Rendering Intent
#define IDH_APPUI_INTENT           99881138

// Lists the profiles you can use to emulate another device on your monitor and printer.
// The profile could represent another monitor or printer, a printing press, color space,
// or any other output device.

#define IDH_1548_1139              99871139 // Color Mgt, Profile other device
#define IDH_APPUI_EMULATE          99871139

// Click to turn on basic color management, which coordinates the way a document's 
// colors appear on your monitor and printer.

#define IDH_1548_1056              99771056 // Color Mgt, Basic Color Mgt
#define IDH_APPUI_BASIC            99771056

// Click to turn on proofing, which lets you simulate or emulate
// how colors will appear on a certain printer or monitor.

#define IDH_1548_1057              99991057 // Color Mgt, Proofing
#define IDH_APPUI_PROOF            99991057

// Lists the rendering intents you can use.
//
//  A rendering intent is the approach used to map the colors of an image
// to the color gamut of a monitor or printer. The color gamut is the range
// of color that a device can produce.
//
//  Perceptual matching is best for photographic images. 
// All the colors of one gamut are scaled to fit within another gamut.
// The relationship between colors is maintained.
//
//  Saturation matching is best for graphs and pie charts,
// in which vividness is more important than actual color. The relative
// saturation of colors is maintained from gamut to gamut. Colors outside
// the gamut are changed to colors of the same saturation, but different
// brightness, at the edge of the gamut.
//
//  Relative Colorimetric matching is best for logo images,
// in which a few colors must be matched exactly. The colors that fall 
// within the gamuts of both devices are left unchanged. Other colors
// may map to a single color, however, resulting in tone compression.
//
//  Absolute Colorimetric matching is used for mapping to a device-independent 
// color space. The result is an idealized print viewed on a perfect paper with
// a large dynamic range and color gamut.
 
#define IDH_1548_1140              99841140	// Color Mgt, Rendering Intent
#define IDH_APPUI_INTENT2          99841140 // not used (same as above)

#if !defined(_WIN95_)

// Display the name of the color profile being used by this file.

#define IDH_colormanage_profile_name 99990003 // Color Mgt, Imaging, Profile Name
#define IDH_APPUI_SOURCE             99990003

#define IDH_SCANNERUI_LIST           11023    // Color Mgt, list of profiles
#define IDH_SCANNERUI_ADD            11024    // Color Mgt, add button
#define IDH_SCANNERUI_REMOVE         11025    // Color Mgt, remove button

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\icmui.h ===
/******************************************************************************

  Header File:  Profile Management UI.H

  Defines the class(es) used in implementing the ICM 2.0 UI.  Most of these are
  defined in other headers, but are assembled here by reference.  

  Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:

  10-24-96  a-robkj@microsoft.com (Pretty Penny Enterprises) began coding this
  01-08-97  KjelgaardR@acm.org  Added color printer determination function to
            the CGlobals class.

******************************************************************************/

#undef  WIN32_LEAN_AND_MEAN
#if !defined(STRICT)
#define STRICT
#endif

#include    <Windows.H>
#include    <commctrl.h>
#include    <crtdbg.h>
#include    <dlgs.h>
#include    <icmpriv.h>

// #include    "PropDlg.H"
#include    "ProfInfo.H"
#include    "ProfAssoc.H"
#include    "Resource.H"
#include    "DevProp.H"
#include    "IcmUIHlp.H"

//  To handle various globals, etc., we implement the following class (with no
//  non-static members).  I'll admit to being a real bigot about global data.

class CGlobals {
    static int      m_icDLLReferences;
    static HMODULE  m_hmThisDll;
    //  List of profiles kept here to speed GetIconLocation up
    static CStringArray m_csaProfiles;
    static BOOL         m_bIsValid;

public:
    
    static void Attach() { m_icDLLReferences++; }
    static void Detach() { m_icDLLReferences--; }
    static int& ReferenceCounter() { return m_icDLLReferences; }
    static void SetHandle(HMODULE hmNew) { 
        if  (!m_hmThisDll) 
            m_hmThisDll = hmNew; 
    }

    static HMODULE  Instance() { 
        return m_hmThisDll;
    }
    
    static HRESULT  CanUnload() { 
        return (!m_icDLLReferences && CShellExtensionPage::OKToClose()) ?
            S_OK : S_FALSE;
    }

    //  Error routine to report problems via a Message box.  Pass the String ID
    //  of the error...

    static void Report(int idError, HWND hwndParent = NULL);
    static int  ReportEx(int idError, HWND hwndParent, BOOL bSystemMessage, UINT uType, DWORD dwNumMsg, ...);

    //  Routines for maintenance of a cached set of installed profiles to speed
    //  up GetIconLocation

    static BOOL IsInstalled(CString& csProfile);
    static void InvalidateList() { m_bIsValid = FALSE; }


    // Routine for determining a printer's hdc
    // Caller is responsible for calling DeleteDC() on 
    // the returned value.
    // Note that this routine uses CreateIC() to get an
    // information context rather than CreateDC() to get the
    // device context.
    static HDC GetPrinterHDC(LPCTSTR lpctstrName);

    //  Routine for determining if a printer is monochrome or color
    static BOOL ThisIsAColorPrinter(LPCTSTR lpctstrName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profile.h ===
/******************************************************************************

  Header File:  ICC Profile.H

  This defines the C++ class we encapsulate the profile in.  It also defines
  the base class for device enumeration.  All activity related to the profile,
  including installations, associations, and so forth, is encapsulated in the
  CProfile class.  The UI classes themselves never call an ICM API, but are
  instead concerned with simply handling the interface.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  10-31-96  A-RobKj (Pretty Penny Enterprises) began encapsulating
  11-22-96  A-RobKj changed associations from string array to uint array to
                    facilitate the spec'd device naming conventions, and
                    filtering of lists for previously installed devices.

  12-04-96  A-RobKj Added the CProfileArray class to make the Device
                    management UI more efficient.

  12-13-96  A-RobKj Moved the CDeviceList derived classes here, so I can use
                    them elsewhere.

******************************************************************************/

#if !defined(ICC_PROFILE_CLASS)

#define ICC_PROFILE_CLASS

#include    "StringAr.H"
#include    "Dialog.H"

//  CDeviceList class

/******************************************************************************

  Highlights:

  This is a base class for the enumeration and reporting of Device
  class-specific information.  The spec is such that a device can be associated
  with a friendly name, but displayed in the UI with an enhanced name.  Also,
  the method for enumerating a device can differ from class to class.

  This base class is usable for cases where there is no means of enumerating
  devices currently.  It reports that there are no devices.
  To make overrides easier, the default display name returns the friendly name,
  so derived classes where this is the case do not need to override this
  method.

******************************************************************************/

class CDeviceList { //  Device-specific information- base class
    CString m_csDummy;

public:
    CDeviceList() {}
    ~CDeviceList() {}

    virtual unsigned    Count() { return    0; }
    virtual CString&    DeviceName(unsigned u) { return m_csDummy; }
    virtual CString&    DisplayName(unsigned u) { return DeviceName(u); }
    virtual void        Enumerate() {}
    virtual BOOL        IsValidDeviceName(LPCTSTR lpstr) { return FALSE; }
};

//  Device Enumeration classes- these must all derive from CDeviceList

//  The CPrinterList class handles printers.  Enumeration is via the Win32
//  spooler API.

class CPrinterList : public CDeviceList {
    CStringArray    m_csaDeviceNames;
    CStringArray    m_csaDisplayNames;

public:
    CPrinterList() {}
    ~CPrinterList() {}

    virtual unsigned    Count() { return m_csaDeviceNames.Count(); }
    virtual CString&    DeviceName(unsigned u) { return m_csaDeviceNames[u]; }
    virtual CString&    DisplayName(unsigned u) { return m_csaDisplayNames[u]; }

    virtual void        Enumerate();
    virtual BOOL        IsValidDeviceName(LPCTSTR lpstr);
};

//  The CMonitorList class handles monitors.  Enumeration is via a private ICM
//  API.

class CMonitorList : public CDeviceList {
    CStringArray    m_csaDeviceNames;
    CStringArray    m_csaDisplayNames;

    CString         m_csPrimaryDeviceName;

public:
    CMonitorList() {}
    ~CMonitorList() {}

    virtual unsigned    Count() { return m_csaDeviceNames.Count(); }
    virtual CString&    DeviceName(unsigned u) { return m_csaDeviceNames[u]; }
    virtual CString&    DisplayName(unsigned u) { return m_csaDisplayNames[u]; }

    virtual CString&    PrimaryDeviceName() { return m_csPrimaryDeviceName; }

    virtual void        Enumerate();
    virtual BOOL        IsValidDeviceName(LPCTSTR lpstr);

    virtual LPCSTR      DeviceNameToDisplayName(LPCTSTR lpstr);
};

//  The CScannerList class handles scanners.  Enumeration is via the STI
//  interface.

class CScannerList : public CDeviceList {
    CStringArray    m_csaDeviceNames;
    CStringArray    m_csaDisplayNames;

public:
    CScannerList() {}
    ~CScannerList() {}

    virtual unsigned    Count() { return m_csaDeviceNames.Count(); }
    virtual CString&    DeviceName(unsigned u) { return m_csaDeviceNames[u]; }
    virtual CString&    DisplayName(unsigned u) { return m_csaDisplayNames[u]; }

    virtual void        Enumerate();
    virtual BOOL        IsValidDeviceName(LPCTSTR lpstr);
};

//  The CAllDeviceList class shows everything.  We enumerate by combining the
//  results of enumerating all of the other classes.

class CAllDeviceList : public CDeviceList {
    CStringArray    m_csaDeviceNames;
    CStringArray    m_csaDisplayNames;

public:
    CAllDeviceList() {}
    ~CAllDeviceList() {}

    virtual unsigned    Count() { return m_csaDeviceNames.Count(); }
    virtual CString&    DeviceName(unsigned u) { return m_csaDeviceNames[u]; }
    virtual CString&    DisplayName(unsigned u) { return m_csaDisplayNames[u]; }

    virtual void        Enumerate();
    virtual BOOL        IsValidDeviceName(LPCTSTR lpstr);
};

//  CProfile class

class CProfile {

    HPROFILE        m_hprof;                //  Profile handle
    PROFILEHEADER   m_phThis;               //  Profile header
    CString         m_csName;
    BOOL            m_bIsInstalled, m_bInstallChecked, m_bAssociationsChecked,
                    m_bDevicesChecked;
    CDeviceList     *m_pcdlClass;           //  Devices of this class
    CUintArray      m_cuaAssociation;       //  Associated devices (indices)
    char            m_acTag[MAX_PATH * 2];
    void    InstallCheck();
    void    AssociationCheck();
    void    DeviceCheck();

public:

    static void Enumerate(ENUMTYPE& et, CStringArray& csaList);
    static void Enumerate(ENUMTYPE& et, CStringArray& csaList, CStringArray& csaDesc);
    static void Enumerate(ENUMTYPE& et, class CProfileArray& cpaList);
    static const CString  ColorDirectory();

    CProfile(LPCTSTR lpstr);
    ~CProfile();

    //  Queries

    CString GetName() { return m_csName.NameOnly(); }
    DWORD   GetType() { return m_hprof ? m_phThis.phClass : 0; }
    DWORD   GetCMM()  { return m_hprof ? m_phThis.phCMMType : 0; }

    // Inquire the color space information from the header
    DWORD   GetColorSpace() {return m_hprof ? m_phThis.phDataColorSpace : 0;}

    BOOL    IsInstalled() {
        if  (!m_bInstallChecked)
            InstallCheck();
        return m_bIsInstalled;
    }
    BOOL    IsValid() {
        BOOL bValid = FALSE;

        if (m_hprof)
            IsColorProfileValid(m_hprof, &bValid);

        return  bValid;
    }

    unsigned    DeviceCount() {
        if (m_pcdlClass) {
          if (!m_bDevicesChecked)
              DeviceCheck();
          return m_pcdlClass -> Count();
        } else {
          return 0;                           // low memory - m_pcdlClass allocation failed
        }
    }

    unsigned    AssociationCount() {
        if  (!m_bAssociationsChecked)
            AssociationCheck();
        return m_cuaAssociation.Count();
    }

    LPCTSTR     DeviceName(unsigned u) {
        if (m_pcdlClass) {
          if  (!m_bDevicesChecked)
              DeviceCheck();
          return m_pcdlClass -> DeviceName(u);
        } else {
          return TEXT("");                    // low memory - m_pcdlClass allocation failed
        }
    }

    LPCTSTR     DisplayName(unsigned u) {
        if (m_pcdlClass) {
          if  (!m_bDevicesChecked)
              DeviceCheck();
          return m_pcdlClass -> DisplayName(u);
        } else {
          return TEXT("");                    // low memory - m_pcdlClass allocation failed
        }
    }

    unsigned    Association(unsigned u) {
        if  (!m_bAssociationsChecked)
            AssociationCheck();
        return m_cuaAssociation[u];
    }

    LPCSTR      TagContents(TAGTYPE tt, unsigned uOffset = 0);

    //  Operations

    BOOL    Install();
    void    Uninstall(BOOL bDelete);
    void    Associate(LPCTSTR lpstrNew);
    void    Dissociate(LPCTSTR lpstrNew);

};

//  CProfileArray class- this is a list of profiles- it is used by the Device
//  Management UI, so we only construct a CProfile object once per profile.

class   CProfileArray {
    CProfile        *m_aStore[20];
    CProfileArray   *m_pcpaNext;
    unsigned        m_ucUsed;

    const unsigned ChunkSize() const {
        return sizeof m_aStore / sizeof m_aStore[0];
    }

    CProfile    *Borrow();

public:

    CProfileArray();
    ~CProfileArray();

    unsigned    Count() const { return m_ucUsed; }

    //  Add an item
    void        Add(LPCTSTR lpstrNew);

    CProfile    *operator [](unsigned u) const;

    void        Remove(unsigned u);
    void        Empty();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profassoc.h ===
/******************************************************************************

  Header File:  Profile Association Page.H

  Defines the class used to display the profile association sheet.

  Copyright (c) 1996 by Microsoft Corporation

  Change History:

  05-09-97 hideyukn - Created

******************************************************************************/

#include    "PropPage.H"
#include    "Profile.H"

//  CProfileInformationPage class- this handles the Profile Information page(s)

class CProfileAssociationPage: public CShellExtensionPage {

    CString     m_csProfile;

    CProfile   *m_pcpTarget;

    CUintArray  m_cuaAdd;       //  Device associatins to be added
    CUintArray  m_cuaDelete;    //  Device associations to zap

    CUintArray  m_cuaAssociate; //  Tentative list of associated devices

    BOOL        m_bAssociationChanged;

public:

    CProfileAssociationPage(HINSTANCE hiWhere, LPCTSTR lpstrTarget);
    ~CProfileAssociationPage();

    VOID ConstructAssociations();
    VOID UpdateDeviceListBox();

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndControl);
    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh);
    virtual BOOL    OnDestroy();

    virtual BOOL    OnHelp(LPHELPINFO pHelp);
    virtual BOOL    OnContextMenu(HWND hwnd);

    HINSTANCE   Instance() { return m_psp.hInstance; }

    CProfile *  Profile() { return m_pcpTarget; }

    void        Associate(unsigned uAdd);
    void        Dissociate(unsigned uRemove);
    unsigned    Association(unsigned u) {
        return  m_cuaAssociate[u]; 
    }
    unsigned    AssociationCount() const { 
        return  m_cuaAssociate.Count();
    }
    BOOL        AssociationChanged()    {
        return m_bAssociationChanged;
    }

    VOID        DeviceListChanged()     {
        ConstructAssociations();
    }

    LPCTSTR     DisplayName(unsigned u) { 
        return m_pcpTarget->DisplayName(m_cuaAssociate[u]);
    }
};


//  The CAddDeviceDialog class handles the Add Device Dialog, which can be called
//  from the Association page.

class CAddDeviceDialog: public CDialog {
    CProfileAssociationPage  *m_pcpasBoss;
    HWND                      m_hwndList, m_hwndButton;
    BOOL                      m_bCanceled;

public:

    CAddDeviceDialog(CProfileAssociationPage *pcpas, HWND hwndParent);

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotification, WORD wid, HWND hwndControl);

    virtual BOOL    OnHelp(LPHELPINFO pHelp);
    virtual BOOL    OnContextMenu(HWND hwnd);

    BOOL            bCanceled()    {return m_bCanceled;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profinfo.cpp ===
/******************************************************************************

  Source File:  Profile Information Page.CPP

  This implements the class used to display the profile information page in the
  property page handler for the shell extension.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  11-01-96  a-robkj@microsoft.com pieced this one together for the first time

******************************************************************************/

#include    "ICMUI.H"

#include    "Resource.H"

static const TCHAR  sacDefaultCMM[] = _TEXT("icm32.dll");

//  It looks like the way to make the icon draw is to subclass the Icon control
//  in the window.  So, here's a Window Procedure for the subclass

//  CProfileInformationPage member functions

//  Class Constructor

CProfileInformationPage::CProfileInformationPage(HINSTANCE hiWhere,
                                                 LPCTSTR lpstrTarget) {
    m_pcpTarget = NULL;
    m_csProfile = lpstrTarget;
    m_psp.dwSize = sizeof m_psp;
    m_psp.dwFlags |= PSP_USETITLE;
    m_psp.hInstance = hiWhere;
    m_psp.pszTemplate = MAKEINTRESOURCE(ProfilePropertyPage);
    m_psp.pszTitle = MAKEINTRESOURCE(ProfilePropertyString);
}

//  Class destructor

CProfileInformationPage::~CProfileInformationPage() {
    if (m_pcpTarget) {
        delete m_pcpTarget;
    }
}

//  Dialog box (property sheet) initialization

BOOL    CProfileInformationPage::OnInit() {

    m_pcpTarget = new CProfile(m_csProfile);

    if (m_pcpTarget) {

        //  Retrieve the 'desc' key, and put it in the description field
        LPCSTR szDesc = m_pcpTarget->TagContents('desc', 4);
        if(szDesc)
            SetDlgItemTextA(m_hwnd, ProfileDescription, szDesc);
     
        //  Get the copyright info from the 'cprt' tag
        LPCSTR szCprt = m_pcpTarget->TagContents('cprt');
        if(szCprt)
            SetDlgItemTextA(m_hwnd, ProfileProducerInfo, szCprt);

        //  Get the profile info from the 'vued' tag, not 'K007' tag
        LPCSTR lpAdditionalInfo = m_pcpTarget->TagContents('vued',4);

        if (lpAdditionalInfo) {
            SetDlgItemTextA(m_hwnd, AdditionalProfileInfo, lpAdditionalInfo);
        } else {
            CString csNoAdditionalInfo;
            csNoAdditionalInfo.Load(NoAdditionalInfo);
            SetDlgItemTextA(m_hwnd, AdditionalProfileInfo, (LPCSTR)csNoAdditionalInfo);
        }

        //  Set the CMM description and bitmap- these are supposed
        //  to come from the CMM.

        //  Get the CMM Name- this must be in char form

        union {
            char    acCMM[5];
            DWORD   dwCMM;
        };

        dwCMM = m_pcpTarget->GetCMM();
        acCMM[4] = '\0';

        //  Use it to form a key into the ICM registry.  If we find it, get
        //  the CMM name.  If we don't, then use the default CMM name (icm32)

#ifdef UNICODE
        CString csKey =
            CString(_TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\")) +
            (LPCTSTR) CString(acCMM);
#else
        CString csKey =
            CString(_TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ICM\\")) +
            (LPCTSTR) CString(acCMM);
#endif

        HKEY    hkCMM;

        if  (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, csKey, &hkCMM)) {
            TCHAR   acValue[MAX_PATH];

            dwCMM = MAX_PATH;

            if  (ERROR_SUCCESS == RegEnumValue(hkCMM, 0, acValue, &dwCMM, NULL,
                 NULL, NULL, NULL))
                 csKey = acValue;
            else
                csKey = sacDefaultCMM;

            RegCloseKey(hkCMM);
        }
        else
            csKey = sacDefaultCMM;

        //  See if we can get an instance handle for the DLL...

        HINSTANCE   hi = LoadLibrary(csKey);

        if  (!hi)
            return  TRUE;     //  Nothing to do, here, let the defaults prevail.

        //  Get description and icon identifier from CMS dll

        DWORD dwCMMIcon = 0, dwCMMDescription = 0;

typedef BOOL (*FPCMGETINFO)(DWORD);

        FPCMGETINFO fpCMGetInfo;

        fpCMGetInfo = (FPCMGETINFO) GetProcAddress(hi,"CMGetInfo");

        if (fpCMGetInfo) {

            dwCMMIcon = (*fpCMGetInfo)(CMM_LOGOICON);
            dwCMMDescription = (*fpCMGetInfo)(CMM_DESCRIPTION);

            if (dwCMMDescription) {
                //  Write the description, if there is one.
                csKey.Load(dwCMMDescription, hi);
                if  ((LPCTSTR) csKey)
                    SetDlgItemText(m_hwnd, CMMDescription, csKey);
            }

            if (dwCMMIcon) {
                //  Change/Create the Icon, if there is one.
                HICON   hiCMM = LoadIcon(hi, MAKEINTRESOURCE(dwCMMIcon));
                if  (hiCMM)
                    SendDlgItemMessage(m_hwnd, CMMIcon, STM_SETICON, (WPARAM) hiCMM, 0);
            }
        }

        return  TRUE;
    } else {
        return  FALSE;
    }
}

BOOL    CProfileInformationPage::OnDestroy() {

    if (m_pcpTarget) {
        delete m_pcpTarget;
        m_pcpTarget = (CProfile *) NULL;
    }

    return FALSE;  // still need to handle this message by def. proc.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profassoc.cpp ===
/******************************************************************************

  Source File:  Profile Association Page.CPP

  Copyright (c) 1997 by Microsoft Corporation

  Change History:

  05-09-1997 hideyukn - Created

******************************************************************************/

#include    "ICMUI.H"

#include    "Resource.H"

//  It looks like the way to make the icon draw is to subclass the Icon control
//  in the window.  So, here's a Window Procedure for the subclass

CONST DWORD ProfileAssociationUIHelpIds[] = {
    AddButton,             IDH_ASSOCDEVICE_ADD,
    RemoveButton,          IDH_ASSOCDEVICE_REMOVE,
#if !defined(_WIN95_) // context-sentitive help
    ProfileFilename,       IDH_ASSOCDEVICE_NAME,
    DeviceListControl,     IDH_ASSOCDEVICE_LIST,
    DeviceListControlText, IDH_ASSOCDEVICE_LIST,
    StatusIcon,            IDH_DISABLED,
#endif
    0, 0
};

//  CProfileAssociationPage member functions

//  Class Constructor

CProfileAssociationPage::CProfileAssociationPage(HINSTANCE hiWhere,
                                                 LPCTSTR lpstrTarget) {
    m_pcpTarget = NULL;
    m_csProfile = lpstrTarget;
    m_psp.dwSize = sizeof m_psp;
    m_psp.dwFlags |= PSP_USETITLE;
    m_psp.hInstance = hiWhere;
    m_psp.pszTemplate = MAKEINTRESOURCE(AssociateDevicePage);
    m_psp.pszTitle = MAKEINTRESOURCE(AssociatePropertyString);
}

//  Class destructor

CProfileAssociationPage::~CProfileAssociationPage() {
    if (m_pcpTarget) {
        delete m_pcpTarget;
    }
}

//  Dialog box (property sheet) initialization

BOOL    CProfileAssociationPage::OnInit() {

    m_pcpTarget = new CProfile(m_csProfile);

    if (m_pcpTarget) {

        // Set profile filename

        SetDlgItemText(m_hwnd, ProfileFilename, m_pcpTarget->GetName());

        // Update ICON to show installed/non-installed status.

        HICON hIcon = LoadIcon(CGlobals::Instance(),
                               MAKEINTRESOURCE(m_pcpTarget->IsInstalled() ? DefaultIcon : UninstalledIcon));

        if (hIcon) {
            SendDlgItemMessage(m_hwnd, StatusIcon, STM_SETICON, (WPARAM) hIcon, 0);
        }

        // Clean up add/delete list.

        m_cuaAdd.Empty();
        m_cuaDelete.Empty();

        // Build tentitive association list.

        ConstructAssociations();

        // And then, fill up device listbox

        UpdateDeviceListBox();

        // And set focus on AddButton.

        SetFocus(GetDlgItem(m_hwnd,AddButton));

        DisableApplyButton();
        SettingChanged(FALSE);

        return TRUE;

    } else {
        return FALSE;
    }
}

//  Private ConstructAssociations function- this constructs the list of
//  tentative associations- this starts out as the true list from the profile
//  object.

VOID    CProfileAssociationPage::ConstructAssociations() {

    m_cuaAssociate.Empty(); //  Clean it up!

    for (unsigned u = 0; u < m_pcpTarget->AssociationCount(); u++) {

        for (unsigned uDelete = 0;
             uDelete < m_cuaDelete.Count();
             uDelete++) {
            if  (m_cuaDelete[uDelete] == m_pcpTarget->Association(u))
                break;
        }

        if  (uDelete == m_cuaDelete.Count())    //  Not yet deleted
            m_cuaAssociate.Add(m_pcpTarget->Association(u));
    }

    //  Now, add any added associations

    for (u = 0; u < m_cuaAdd.Count(); u++)
        m_cuaAssociate.Add(m_cuaAdd[u]);
}

//  Public method for noting tentative associations to be added

void    CProfileAssociationPage::Associate(unsigned uAdd) {

    //  First, see if it's on the delete list.  If it is, remove it from there
    //  Otherwise, add us to the add list, if it's a new association.

    for (unsigned u = 0; u < m_cuaDelete.Count(); u++)
        if  (uAdd == m_cuaDelete[u])
            break;

    if  (u < m_cuaDelete.Count())
        m_cuaDelete.Remove(u);
    else {
        for (u = 0; u < m_cuaAssociate.Count(); u++)
            if  (m_cuaAssociate[u] == uAdd)
                break;
        if  (u == m_cuaAssociate.Count())
            m_cuaAdd.Add(uAdd);
    }

    DeviceListChanged();
}

//  Public Method for removing tentative associations

void    CProfileAssociationPage::Dissociate(unsigned uRemove) {

    //  First, see if it's on the add list.  If it is, remove it from there
    //  Otherwise, add us to the delete list.

    for (unsigned u = 0; u < m_cuaAdd.Count(); u++)
        if  (uRemove == m_cuaAdd[u])
            break;

    if  (u < m_cuaAdd.Count())
        m_cuaAdd.Remove(u);
    else
        m_cuaDelete.Add(uRemove);

    DeviceListChanged();
}

VOID    CProfileAssociationPage::UpdateDeviceListBox() {

    //  Add the associations to the list

    SendDlgItemMessage(m_hwnd, DeviceListControl, LB_RESETCONTENT, 0, 0);

    for (unsigned u = 0; u < AssociationCount(); u++ ) {
        LRESULT iItem = SendDlgItemMessage(m_hwnd, DeviceListControl, LB_ADDSTRING,
            0, (LPARAM) DisplayName(u));
        SendDlgItemMessage(m_hwnd, DeviceListControl, LB_SETITEMDATA, iItem,
            (LPARAM) Association(u));
    }

    //  If there are no associations, disable the Remove Devices button

    HWND hwndRemove = GetDlgItem(m_hwnd,RemoveButton);

    // If focus is on Remove, move it to Add button.

    if (GetFocus() == hwndRemove) {

        HWND hwndAdd = GetDlgItem(m_hwnd, AddButton);

        SetFocus(hwndAdd);
        SendMessage(hwndRemove, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
        SendMessage(hwndAdd, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
    }

    EnableWindow(hwndRemove, !!(AssociationCount()));

    //  If there is any device, set focus to 1st entry.

    if  (SendDlgItemMessage(m_hwnd, DeviceListControl, LB_GETCOUNT, 0, 0))
        SendDlgItemMessage(m_hwnd, DeviceListControl, LB_SETCURSEL, 0, 0);
}

BOOL    CProfileAssociationPage::OnCommand(WORD wNotifyCode, WORD wid, HWND hwndControl) {

    switch (wid) {

        case AddButton :
            if  (wNotifyCode == BN_CLICKED) {
                CAddDeviceDialog cadd(this, m_hwnd);
                if (!cadd.bCanceled()) {
                    UpdateDeviceListBox();
                    EnableApplyButton();
                    SettingChanged(TRUE);
                }
                return  TRUE;
            }
            break;

        case RemoveButton :
            if  (wNotifyCode == BN_CLICKED) {
                LRESULT i = SendDlgItemMessage(m_hwnd, DeviceListControl,
                    LB_GETCURSEL, 0, 0);

                if  (i == -1)
                    return  TRUE;

                unsigned uItem = (unsigned)SendDlgItemMessage(m_hwnd, DeviceListControl,
                    LB_GETITEMDATA, i, 0);
                Dissociate(uItem);
                UpdateDeviceListBox();
                EnableApplyButton();
                SettingChanged(TRUE);
                return  TRUE;
            }
            break;

        case DeviceListControl :
            if (wNotifyCode == LBN_SELCHANGE) {
                EnableWindow(GetDlgItem(m_hwnd, RemoveButton),
                    -1 != SendDlgItemMessage(m_hwnd, DeviceListControl, LB_GETCURSEL, 0, 0));
                return  TRUE;
            }
            break;
    }

    return TRUE;
}

BOOL    CProfileAssociationPage::OnDestroy() {

    if (m_pcpTarget) {
        delete m_pcpTarget;
        m_pcpTarget = (CProfile *) NULL;
    }

    return FALSE;  // still need to handle this message by def. proc.
}

//  Common control notification override

BOOL    CProfileAssociationPage::OnNotify(int idCtrl, LPNMHDR pnmh) {

    switch  (pnmh -> code) {

        case PSN_APPLY: {

            if (SettingChanged()) {

                //  Disable apply button, because current request are
                //  going to be "Applied".

                DisableApplyButton();

                //  We are going to update changed.

                SettingChanged(FALSE);

                //  Remove any associations we're removing

                while   (m_cuaDelete.Count()) {
                    m_pcpTarget->Dissociate(m_pcpTarget->DeviceName(m_cuaDelete[0]));
                    m_cuaDelete.Remove(0);
                }

                //  Add any associations we're adding

                while   (m_cuaAdd.Count()) {
                    m_pcpTarget->Associate(m_pcpTarget->DeviceName(m_cuaAdd[0]));
                    m_cuaAdd.Remove(0);
                }

                //  Re-create CProfile object.
                //

                delete m_pcpTarget;
                m_pcpTarget = new CProfile(m_csProfile);

                if (!m_pcpTarget)
                {
                    // WINBUG #83126 2-7-2000 bhouse Improve error handling in OnNotify
                    // Old Comment:
                    //   - proper error should happen.

                    return FALSE;
                }

                //  Re-Build tentitive association list.

                ConstructAssociations();

                UpdateDeviceListBox();

                //  check the install status to refect icon.

                HICON hIcon = LoadIcon(CGlobals::Instance(),
                                   MAKEINTRESOURCE(m_pcpTarget->IsInstalled() ? DefaultIcon : UninstalledIcon));

                if (hIcon) {
                    SendDlgItemMessage(m_hwnd, StatusIcon, STM_SETICON, (WPARAM) hIcon, 0);
                }
            }

            break;
        }
    }

    return TRUE;
}

//  Context-sensitive help handler

BOOL    CProfileAssociationPage::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
                HELP_WM_HELP, (ULONG_PTR) (LPSTR) ProfileAssociationUIHelpIds);
    }

    return (TRUE);
}

BOOL    CProfileAssociationPage::OnContextMenu(HWND hwnd) {

    DWORD iCtrlID = GetDlgCtrlID(hwnd);

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) ProfileAssociationUIHelpIds);

    return (TRUE);
}

//  Context Help for AddDevice Dialog.

CONST DWORD AddDeviceUIHelpIds[] = {
    AddDeviceButton,       IDH_ADDDEVICEUI_ADD,
    DeviceListControl,     IDH_ADDDEVICEUI_LIST,
    DeviceListControlText, IDH_ADDDEVICEUI_LIST,
    0, 0
};

//  CAddDeviceDialog class constructor

CAddDeviceDialog::CAddDeviceDialog(CProfileAssociationPage *pcpas,
                                   HWND hwndParent) :
    CDialog(pcpas->Instance(), AddDeviceDialog, hwndParent) {
    m_pcpasBoss = pcpas;
    m_bCanceled = TRUE;
    DoModal();
}

//  Dialog Initialization routine

BOOL    CAddDeviceDialog::OnInit() {

    CProfile * pcpThis = m_pcpasBoss->Profile();

    m_hwndList   = GetDlgItem(m_hwnd, DeviceListControl);
    m_hwndButton = GetDlgItem(m_hwnd, AddDeviceButton);

    //  This must not list associated (tentatively) devices, per the spec

    for (unsigned uDevice = 0; uDevice < pcpThis->DeviceCount(); uDevice++) {
        for (unsigned u = 0; u < m_pcpasBoss->AssociationCount(); u++)
            if  (uDevice == m_pcpasBoss->Association(u))
                break;
        if  (u < m_pcpasBoss->AssociationCount())
            continue;   //  Don't insert this one...

        LRESULT idItem = SendMessage(m_hwndList, LB_ADDSTRING, (WPARAM)0,
            (LPARAM) pcpThis->DisplayName(uDevice));
        SendMessage(m_hwndList, LB_SETITEMDATA, idItem, (LPARAM) uDevice);
    }

    if  (SendMessage(m_hwndList, LB_GETCOUNT, 0, 0))
        SendMessage(m_hwndList, LB_SETCURSEL, 0, 0);

    EnableWindow(m_hwndButton, -1 !=
        SendMessage(m_hwndList, LB_GETCURSEL, 0, 0));

    return  TRUE;
}

//  Dialog notification handler

BOOL    CAddDeviceDialog::OnCommand(WORD wNotification, WORD wid,
                                    HWND hwndControl){

    switch  (wNotification) {

        case    LBN_SELCHANGE:
            EnableWindow(m_hwndButton, -1 !=
                SendMessage(m_hwndList, LB_GETCURSEL, 0, 0));
            return  TRUE;

        case    BN_CLICKED:
            if  (wid == AddDeviceButton) {

                LRESULT i = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                if  (i == -1)
                    return  TRUE;

                unsigned uItem = (unsigned) SendMessage(m_hwndList,
                    LB_GETITEMDATA, i, 0);

                m_pcpasBoss->Associate(uItem);

                // Selection has been made.

                m_bCanceled = FALSE;
            }
            break;

        case    LBN_DBLCLK:
            return  OnCommand(BN_CLICKED, AddDeviceButton, m_hwndButton);
    }

    return  CDialog::OnCommand(wNotification, wid, hwndControl);
}

//  Context-sensitive help handler

BOOL    CAddDeviceDialog::OnHelp(LPHELPINFO pHelp) {

    if (pHelp->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) pHelp->hItemHandle, WINDOWS_HELP_FILE,
                HELP_WM_HELP, (ULONG_PTR) (LPSTR) AddDeviceUIHelpIds);
    }

    return (TRUE);
}

BOOL    CAddDeviceDialog::OnContextMenu(HWND hwnd) {

    DWORD iCtrlID = GetDlgCtrlID(hwnd);

    WinHelp(hwnd, WINDOWS_HELP_FILE,
            HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) AddDeviceUIHelpIds);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profile.cpp ===
/******************************************************************************

  Source File:  ICC Profile.CPP

  This implements the class we use to encapsulate everything we will ever care
  to know about a profile, including the classes we need to support
  associations and the like.

  Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:

  10-31-96  A-RobKj (Pretty Penny Enterprises) began encapsulating it
  12-04-96  A-RobKj Added the CProfileArray and CAllDeviceList classes
  12-13-96  A-RobKj Modified for faster operation (more lazy evaluation,
                    and common DLL-wide database for installation checks)
                    Also moved CDeviceList derived classes to the header, so
                    I can use them other places, as well...
  01-07-97  KjelgaardR@acm.org  Fixed CProfileArray::Empty- wasn't setting Next
            object pointer to NULL after deleting said object (Fixed GP fault).
  01-08-97  KjelgaardR@acm.org  Modified printer enumeration routine to only
            enumerate color models (uses Global utility function).

******************************************************************************/

#include    "ICMUI.H"
#include    <shlobj.h>
#include    "shellext.h"
#include    "..\mscms\sti.h"

typedef HRESULT (__stdcall *PFNSTICREATEINSTANCE)(HINSTANCE, DWORD, PSTI*, LPDWORD);

TCHAR  gszStiDll[]             = __TEXT("sti.dll");
char   gszStiCreateInstance[]  = "StiCreateInstance";

//  Printer DeviceEnumeration method

void    CPrinterList::Enumerate() {

#if !defined(_WIN95_) // CPrinterList::Enumetate()

    //  Enumerate all local printers

    DWORD   dwcNeeded, dwcReturned;
    EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &dwcNeeded,
        &dwcReturned);

    union {
        PBYTE   pBuff;
        PPRINTER_INFO_4 ppi4;
    };

    pBuff = new BYTE[dwcNeeded];

    while   (pBuff && !EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, pBuff,
        dwcNeeded, &dwcNeeded, &dwcReturned) &&
        GetLastError() == ERROR_MORE_DATA) {
        delete [] pBuff;
        pBuff = new BYTE[dwcNeeded];
    }

    if  (pBuff) {

        for (unsigned u = 0; u < dwcReturned; u++)
            if  (CGlobals::ThisIsAColorPrinter(ppi4[u].pPrinterName)) {
                m_csaDeviceNames.Add(ppi4[u].pPrinterName);
                m_csaDisplayNames.Add(ppi4[u].pPrinterName);
            }

        delete [] pBuff;
    }

    //  Now, enumerate all the connected printers

    EnumPrinters(PRINTER_ENUM_CONNECTIONS, NULL, 4, NULL, 0, &dwcNeeded,
        &dwcReturned);

    pBuff = new BYTE[dwcNeeded];

    while   (pBuff && !EnumPrinters(PRINTER_ENUM_CONNECTIONS, NULL, 4, pBuff,
        dwcNeeded, &dwcNeeded, &dwcReturned) &&
        GetLastError() == ERROR_MORE_DATA) {
        delete [] pBuff;
        pBuff = new BYTE[dwcNeeded];
    }

    if  (!pBuff)
        return;

    for (unsigned u = 0; u < dwcReturned; u++)
        if  (CGlobals::ThisIsAColorPrinter(ppi4[u].pPrinterName)) {
            m_csaDeviceNames.Add(ppi4[u].pPrinterName);
            m_csaDisplayNames.Add(ppi4[u].pPrinterName);
        }

    delete [] pBuff;

#else 

    //  Enumerate all local printers

    DWORD   dwcNeeded, dwcReturned;
    EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &dwcNeeded,
        &dwcReturned);

    union {
        PBYTE   pBuff;
        PPRINTER_INFO_5 ppi5;
    };

    pBuff = new BYTE[dwcNeeded];

    while   (pBuff && !EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, pBuff,
        dwcNeeded, &dwcNeeded, &dwcReturned) &&
        GetLastError() == ERROR_MORE_DATA) {
        delete [] pBuff;
        pBuff = new BYTE[dwcNeeded];
    }

    if  (pBuff) {

        for (unsigned u = 0; u < dwcReturned; u++) {
            if  (CGlobals::ThisIsAColorPrinter(ppi5[u].pPrinterName)) {
                m_csaDeviceNames.Add(ppi5[u].pPrinterName);
                m_csaDisplayNames.Add(ppi5[u].pPrinterName);
            }
        }

        delete [] pBuff;
    }
#endif
}

//  Printer Name Validity Check

BOOL    CPrinterList::IsValidDeviceName(LPCTSTR lpstrRef) {

    if  (!lpstrRef) return  FALSE;

    if  (!Count())
        Enumerate();

    for (unsigned u = 0; u < Count(); u++)
        if  (!lstrcmpi(m_csaDeviceNames[u], lpstrRef))
            break;

    return  u < Count();
}

//  Private monitor enumeration function- note this is ANSI only...

extern "C" BOOL WINAPI  EnumerateMonitors(LPBYTE pBuffer, PDWORD pdwcbNeeded,
                                          PDWORD pdwcReturned);

//  CMonitor class enumerator

void    CMonitorList::Enumerate() {

    ULONG          ulSerialNumber = 1;
    ULONG          ulDeviceIndex  = 0;
    DISPLAY_DEVICE ddPriv;

    ddPriv.cb = sizeof(ddPriv);

    // Enumurate display adaptor on the system.

    while (EnumDisplayDevices(NULL, ulDeviceIndex, &ddPriv, 0))
    {
        ULONG          ulMonitorIndex = 0;
        DISPLAY_DEVICE ddPrivMonitor;

        ddPrivMonitor.cb = sizeof(ddPrivMonitor);

        // then, enumurate monitor device, attached the display adaptor.

        while (EnumDisplayDevices(ddPriv.DeviceName, ulMonitorIndex, &ddPrivMonitor, 0))
        {
            TCHAR DisplayNameBuf[256]; // number: devicename - 256 is good enough.

            // Insert PnP id as device name.

            m_csaDeviceNames.Add(ddPrivMonitor.DeviceID);

            // If this is primary display device, remember it.

            if (ddPriv.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
            {
                m_csPrimaryDeviceName = ddPrivMonitor.DeviceID;
            }

            // Build display name.

            wsprintf(DisplayNameBuf,TEXT("%d. %s"),ulSerialNumber,ddPrivMonitor.DeviceString);
            m_csaDisplayNames.Add(DisplayNameBuf);

            ulMonitorIndex++;
            ulSerialNumber++;
            ddPrivMonitor.cb = sizeof(ddPrivMonitor);
        }

        ulDeviceIndex++;
        ddPriv.cb = sizeof(ddPriv);
    }
}

//  Monitor Name Validity Check

BOOL    CMonitorList::IsValidDeviceName(LPCTSTR lpstrRef) {

    if  (!lpstrRef) return  FALSE;

    if  (!Count())
        Enumerate();

    for (unsigned u = 0; u < Count(); u++)
        if  (!lstrcmpi(m_csaDeviceNames[u], lpstrRef))
            break;

    return  u < Count();
}

LPCSTR  CMonitorList::DeviceNameToDisplayName(LPCTSTR lpstrRef) {

    if  (!lpstrRef) return NULL;

    if  (!Count())
        Enumerate();

    for (unsigned u = 0; u < Count(); u++)
        if  (!lstrcmpi(m_csaDeviceNames[u], lpstrRef))
            return (LPCSTR)(m_csaDisplayNames[u]);

    return NULL;
}  

//  Scanner DeviceEnumeration method

void    CScannerList::Enumerate() {

    PFNSTICREATEINSTANCE    pStiCreateInstance;
    PSTI                    pSti = NULL;
    PSTI_DEVICE_INFORMATION pDevInfo;
    PVOID                   pBuffer = NULL;
    HINSTANCE               hModule;
    HRESULT                 hres;
    DWORD                   i, dwItemsReturned;
    #ifndef UNICODE
    char                    szName[256];
    #endif

    if (!(hModule = LoadLibrary(gszStiDll)))
    {
        _RPTF1(_CRT_WARN, "Error loading sti.dll: %d\n",
               GetLastError());
        return;
    }

    if (!(pStiCreateInstance = (PFNSTICREATEINSTANCE)GetProcAddress(hModule, gszStiCreateInstance)))
    {
        _RPTF0(_CRT_WARN, "Error getting proc StiCreateInstance\n");
        goto EndEnumerate;
    }

    hres = (*pStiCreateInstance)(GetModuleHandle(NULL), STI_VERSION, &pSti, NULL);

    if (FAILED(hres))
    {
        _RPTF1(_CRT_WARN, "Error creating sti instance: %d\n", hres);
        goto EndEnumerate;
    }

    hres = pSti->GetDeviceList(0, 0, &dwItemsReturned, &pBuffer);

    if (FAILED(hres) || !pBuffer)
    {
        _RPTF0(_CRT_WARN, "Error getting scanner devices\n");
        goto EndEnumerate;
    }

    pDevInfo = (PSTI_DEVICE_INFORMATION) pBuffer;

    for (i=0; i<dwItemsReturned; i++, pDevInfo++)
    {
        #ifndef UNICODE
        DWORD dwLen;                    // length of Ansi string
        BOOL  bUsedDefaultChar;

        dwLen = (lstrlenW(pDevInfo->pszLocalName) + 1) * sizeof(char);

        //
        // Convert Unicode name to Ansi
        //
        if (WideCharToMultiByte(CP_ACP, 0, pDevInfo->szDeviceInternalName, -1, szName,
              dwLen, NULL, &bUsedDefaultChar) && ! bUsedDefaultChar)
        {
            m_csaDeviceNames.Add(szName);
        }
        else
        {
            _RPTF0(_CRT_WARN, "Error converting internalName to Unicode name\n");
        }

        if (WideCharToMultiByte(CP_ACP, 0, pDevInfo->pszLocalName, -1, szName,
              dwLen, NULL, &bUsedDefaultChar) && ! bUsedDefaultChar)
        {
            m_csaDisplayNames.Add(szName);
        }
        else
        {
            _RPTF0(_CRT_WARN, "Error converting deviceName to Unicode name\n");
        }

        #else
        m_csaDeviceNames.Add(pDevInfo->szDeviceInternalName);
        m_csaDisplayNames.Add(pDevInfo->pszLocalName);
        #endif
    }

EndEnumerate:
    if (pBuffer)
    {
        LocalFree(pBuffer);
    }

    if (pSti)
    {
        pSti->Release();
    }

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return;
}

//  Scanner Name Validity Check

BOOL    CScannerList::IsValidDeviceName(LPCTSTR lpstrRef) {

    if  (!lpstrRef) return  FALSE;

    if  (!Count())
        Enumerate();

    for (unsigned u = 0; u < Count(); u++)
        if  (!lstrcmpi(m_csaDeviceNames[u], lpstrRef))
            break;

    return  u < Count();
}

//  CAllDeviceList class enumerator

void    CAllDeviceList::Enumerate() {

    CMonitorList    cml;
    CPrinterList    cpl;
    CScannerList    csl;

    cml.Enumerate();
    cpl.Enumerate();
    csl.Enumerate();

    for (unsigned u = 0; u < cpl.Count(); u++) {
        m_csaDeviceNames.Add(cpl.DeviceName(u));
        m_csaDisplayNames.Add(cpl.DisplayName(u));
    }

    for (u = 0; u < cml.Count(); u++) {
        m_csaDeviceNames.Add(cml.DeviceName(u));
        m_csaDisplayNames.Add(cml.DisplayName(u));
    }

    for (u = 0; u < csl.Count(); u++) {
        m_csaDeviceNames.Add(csl.DeviceName(u));
        m_csaDisplayNames.Add(csl.DisplayName(u));
    }
}

//  Device Name Validity Check

BOOL    CAllDeviceList::IsValidDeviceName(LPCTSTR lpstrRef) {

    if  (!lpstrRef) return  FALSE;

    if  (!Count())
        Enumerate();

    for (unsigned u = 0; u < Count(); u++)
        if  (!lstrcmpi(m_csaDeviceNames[u], lpstrRef))
            break;

    return  u < Count();
}

//  CProfile member functions

//  The following static functions fills the appropriate array using the
//  profiles that match the search criteria goven.

void    CProfile::Enumerate(ENUMTYPE& et, CStringArray& csaList) {

    //  Enumerate the existing profiles

    DWORD   dwBuffer =0, dwcProfiles;

    csaList.Empty();

    EnumColorProfiles(NULL, &et, NULL, &dwBuffer, &dwcProfiles);

    if  (!dwBuffer) {
        _RPTF2(_CRT_WARN,
            "CProfile::Enumerate(String)- empty list- dwBuffer %d Error %d\n",
            dwBuffer, GetLastError());
        return;
    }

    union {
        PBYTE   pbBuffer;
        PTSTR   pstrBuffer;
    };

    pbBuffer = new BYTE[dwBuffer];

    if (pbBuffer) {

        if  (EnumColorProfiles(NULL, &et, pbBuffer, &dwBuffer, &dwcProfiles)) {
            for (PTSTR pstrMe = pstrBuffer;
                 dwcProfiles--;
                 pstrMe += 1 + lstrlen(pstrMe)) {
                _RPTF1(_CRT_WARN, "CProfile::Enumerate(String) %s found\n",
                    pstrMe);
                csaList.Add(pstrMe);
            }
        }

        delete [] pbBuffer;
    }
}

void    CProfile::Enumerate(ENUMTYPE& et, CStringArray& csaList, CStringArray& csaDesc) {

    //  Enumerate the existing profiles

    DWORD   dwBuffer =0, dwcProfiles;

    csaList.Empty();

    EnumColorProfiles(NULL, &et, NULL, &dwBuffer, &dwcProfiles);

    if  (!dwBuffer) {
        _RPTF2(_CRT_WARN,
            "CProfile::Enumerate(String)- empty list- dwBuffer %d Error %d\n",
            dwBuffer, GetLastError());
        return;
    }

    union {
        PBYTE   pbBuffer;
        PTSTR   pstrBuffer;
    };

    pbBuffer = new BYTE[dwBuffer];

    if (pbBuffer) {

        if  (EnumColorProfiles(NULL, &et, pbBuffer, &dwBuffer, &dwcProfiles)) {
            for (PTSTR pstrMe = pstrBuffer;
                 dwcProfiles--;
                 pstrMe += 1 + lstrlen(pstrMe)) {
                _RPTF1(_CRT_WARN, "CProfile::Enumerate(String) %s found\n",
                    pstrMe);

                CProfile cp(pstrMe);

                if (cp.IsValid()) {

                    CString csDescription = cp.TagContents('desc', 4);

                    if (csDescription.IsEmpty()) {
                        csaDesc.Add(pstrMe);
                    } else {
                        csaDesc.Add((LPTSTR)csDescription);
                    }

                    csaList.Add(pstrMe);
                }
            }
        }

        delete [] pbBuffer;
    }
}

void    CProfile::Enumerate(ENUMTYPE& et, CProfileArray& cpaList) {

    //  Enumerate the existing profiles

    DWORD   dwBuffer = 0, dwcProfiles;

    cpaList.Empty();

    EnumColorProfiles(NULL, &et, NULL, &dwBuffer, &dwcProfiles);

    if  (!dwBuffer) {
        _RPTF2(_CRT_WARN,
            "CProfile::Enumerate(Profile)- empty list- dwBuffer %d Error %d\n",
            dwBuffer, GetLastError());
        return;
    }

    union {
        PBYTE   pbBuffer;
        PTSTR   pstrBuffer;
    };

    pbBuffer = new BYTE[dwBuffer];

    if (pbBuffer) {

        if  (EnumColorProfiles(NULL, &et, pbBuffer, &dwBuffer, &dwcProfiles)) {
            for (PTSTR pstrMe = pstrBuffer;
                 dwcProfiles--;
                 pstrMe += 1 + lstrlen(pstrMe)) {
                _RPTF1(_CRT_WARN, "CProfile::Enumerate(Profile) %s added\n",
                    pstrMe);
                cpaList.Add(pstrMe);
            }
        }

        delete [] pbBuffer;
    }

}

//  This retrieves the color directory name.  Since it is a const, we whouldn't
//  be calling it too often...

const CString   CProfile::ColorDirectory() {
    TCHAR   acDirectory[MAX_PATH];
    DWORD   dwccDir = MAX_PATH;

    GetColorDirectory(NULL, acDirectory, &dwccDir);

    return  acDirectory;
}

//  This checks for profile installation

void    CProfile::InstallCheck() {

    //  Enumerate the existing profiles, so we can see if this one's been
    //  installed, already.

    ENUMTYPE    et = {sizeof (ENUMTYPE), ENUM_TYPE_VERSION, 0, NULL};

    CStringArray    csaWork;

    Enumerate(et, csaWork);

    for (unsigned u = 0; u < csaWork.Count(); u++)
        if  (!lstrcmpi(csaWork[u].NameOnly(), m_csName.NameOnly()))
            break;

    m_bIsInstalled = u < csaWork.Count();
    m_bInstallChecked = TRUE;
}

//  This Checks for Associated Devices

void    CProfile::AssociationCheck() {

    m_bAssociationsChecked = TRUE;

    //  If the profile isn't installed, associations are moot...

    if  (!IsInstalled())
        return;

    //  The final step is to build a list of associations

    ENUMTYPE        et = {sizeof (ENUMTYPE), ENUM_TYPE_VERSION, ET_DEVICENAME};
    CStringArray    csaWork;

    for (unsigned u = 0; u < DeviceCount(); u++) {

        et.pDeviceName = m_pcdlClass -> DeviceName(u);

        Enumerate(et, csaWork);

        //  We track associations by index into the total device list...

        for (unsigned uProfile = 0; uProfile < csaWork.Count(); uProfile++)
            if  (!lstrcmpi(csaWork[uProfile].NameOnly(), m_csName.NameOnly())){
                m_cuaAssociation.Add(u);    //  Found one!
                break;
            }
    }
}

//  This determines the device list of related class...

void    CProfile::DeviceCheck() {

    //  Enumerate the available devices of this type in the csaDevice Array

    m_pcdlClass -> Enumerate();
    m_bDevicesChecked = TRUE;
}

//  Class constructor

CProfile::CProfile(LPCTSTR lpstrTarget) {

    _ASSERTE(lpstrTarget && *lpstrTarget);

    m_pcdlClass = NULL;

    //  First, let's make sure it's the real McCoy

    PROFILE     prof = { PROFILE_FILENAME,
                         (LPVOID) lpstrTarget,
                         (1 + lstrlen(lpstrTarget)) * sizeof(TCHAR)};

    m_hprof = OpenColorProfile(&prof, PROFILE_READ,
                                      FILE_SHARE_READ|FILE_SHARE_WRITE,
                                      OPEN_EXISTING);

    if  (!m_hprof)
        return;

    if  (!GetColorProfileHeader(m_hprof, &m_phThis)) {
        CloseColorProfile(m_hprof);
        m_hprof = NULL;
        return;
    }

    m_csName = lpstrTarget;
    m_bInstallChecked = m_bDevicesChecked = m_bAssociationsChecked = FALSE;

    //  Init the DeviceList pointer, because it doesn't cost much...

    switch  (m_phThis.phClass) {
        case    CLASS_PRINTER:

            //  Our device list is a printer list

            m_pcdlClass = new CPrinterList;
            break;

        case     CLASS_SCANNER:

            //  Our device list is a scanner list

            m_pcdlClass = new CScannerList;
            break;


        case    CLASS_MONITOR:

            //  Our device list is a monitor list

        #if 1 // ALLOW_MONITOR_PROFILE_TO_ANY_DEVICE
            m_pcdlClass = new CAllDeviceList;
        #else
            m_pcdlClass = new CMonitorList;
        #endif
            break;

        case    CLASS_COLORSPACE:

            //  List everything we can count

            m_pcdlClass = new CAllDeviceList;
            break;

        default:
            //  Use the base device class (i.e., no devices of this type).
            m_pcdlClass = new CDeviceList;
    }
}

//  Destructor

CProfile::~CProfile() {
    if  (m_hprof)
        CloseColorProfile(m_hprof);
    if  (m_pcdlClass)
        delete  m_pcdlClass;
}

//  Tag retrieval function

LPCSTR  CProfile::TagContents(TAGTYPE tt, unsigned uOffset) {

    DWORD   dwcNeeded = sizeof m_acTag;
    BOOL    bIgnore;

    if  (!GetColorProfileElement(m_hprof, tt, 8 + uOffset, &dwcNeeded, m_acTag,
         &bIgnore))
        return  NULL;   //  Nothing to copy!
    else
        return  m_acTag;
}

//  Profile Installation function

BOOL    CProfile::Install() {

    if  (!InstallColorProfile(NULL, m_csName)) {
        CGlobals::ReportEx(InstFailedWithName,NULL,FALSE,
                           MB_OK|MB_ICONEXCLAMATION,1,m_csName.NameAndExtension());
        return (FALSE);
    } else {
        m_bIsInstalled = TRUE;
        CGlobals::InvalidateList();
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, (LPCTSTR) m_csName, NULL);

        _RPTF1(_CRT_WARN, "CProfile::Install %s succeeded\n",
            (LPCSTR) m_csName);
        return (TRUE);
    }
}

//  Profile Uninstallation function

void    CProfile::Uninstall(BOOL bDelete) {

    while   (AssociationCount()) {    // Dissociate all uses
        Dissociate(DeviceName(m_cuaAssociation[0]));
        m_cuaAssociation.Remove(0);
    }

    if  (m_hprof)
    {
        CloseColorProfile(m_hprof);
        m_hprof = NULL;
    }

    if  (!UninstallColorProfile(NULL, m_csName.NameAndExtension(), bDelete)) {
        CGlobals::ReportEx(UninstFailedWithName,NULL,FALSE,
                           MB_OK|MB_ICONEXCLAMATION,1,m_csName.NameAndExtension());
    } else {
        m_bIsInstalled = FALSE;
        CGlobals::InvalidateList();
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, (LPCTSTR) m_csName, NULL);

        _RPTF1(_CRT_WARN, "CProfile::Uninstall %s succeeded\n",
            (LPCSTR) m_csName);
    }
}

//  Association

void    CProfile::Associate(LPCTSTR lpstrDevice) {

    // if the profile is not installed, install it first.

    BOOL bInstalled = FALSE;

    // Install profile, if not installed, yet.
    if  (!IsInstalled()) {
        bInstalled = Install();
    } else
        bInstalled = TRUE;

    if  (bInstalled) {
        if  (!AssociateColorProfileWithDevice(NULL, m_csName.NameAndExtension(),
            lpstrDevice)) {
            CGlobals::ReportEx(AssocFailedWithName,NULL,FALSE,1,
                               MB_OK|MB_ICONEXCLAMATION,m_csName.NameAndExtension());
        } else
            _RPTF2(_CRT_WARN, "CProfile::Associate %s with %s succeeded\n",
                lpstrDevice, (LPCTSTR) m_csName.NameAndExtension());
    }
}

//  Dissociation

void    CProfile::Dissociate(LPCTSTR lpstrDevice) {
    if  (!DisassociateColorProfileFromDevice(NULL, m_csName.NameAndExtension(),
        lpstrDevice)) {
        CGlobals::ReportEx(DisassocFailedWithName,NULL,FALSE,1,
                           MB_OK|MB_ICONEXCLAMATION,m_csName.NameAndExtension());
    } else
        _RPTF2(_CRT_WARN, "CProfile::Dissociate %s from %s succeeded\n",
            lpstrDevice, (LPCTSTR) m_csName.NameAndExtension());
}

//  CProfileArray class- Same basic implementation, different base type.

CProfile    *CProfileArray::Borrow() {
    CProfile    *pcpReturn = m_aStore[0];

    memcpy((LPSTR) m_aStore, (LPSTR) (m_aStore + 1),
        (ChunkSize() - 1) * sizeof m_aStore[0]);

    if  (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcpaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = (CProfile *) NULL;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcpaNext) {
        delete  m_pcpaNext;
        m_pcpaNext = NULL;
    }

    return  pcpReturn;
}

CProfileArray::CProfileArray() {
    m_ucUsed = 0;
    m_pcpaNext = NULL;
    memset(m_aStore, 0, sizeof m_aStore);
}

CProfileArray::~CProfileArray() {
    Empty();
}

void    CProfileArray::Empty() {
    if  (!m_ucUsed) return;

    if  (m_pcpaNext) {
        delete  m_pcpaNext;
        m_pcpaNext = NULL;
        m_ucUsed = ChunkSize();
    }

    while   (m_ucUsed--)
        delete  m_aStore[m_ucUsed];

    m_ucUsed = 0;
    memset(m_aStore, 0, sizeof m_aStore);
}

//  Add an item
void    CProfileArray::Add(LPCTSTR lpstrNew) {
    _ASSERTE(lpstrNew && *lpstrNew);

    if  (m_ucUsed < ChunkSize()) {
        m_aStore[m_ucUsed++] = new  CProfile(lpstrNew);
        return;
    }

    //  Not enough space!  Add another record, if there isn't one

    if  (!m_pcpaNext)
        m_pcpaNext = new CProfileArray;

    //  Add the profile to the next array (recursive call!)

    //  Note: if we failed to get memory above, we simply fail to add the
    //  object.

    if  (m_pcpaNext) {
        m_pcpaNext -> Add(lpstrNew);
        m_ucUsed++;
    }
}

CProfile    *CProfileArray::operator [](unsigned u) const {
    return  u < ChunkSize() ?
        m_aStore[u] : m_pcpaNext -> operator[](u - ChunkSize());
}

void    CProfileArray::Remove(unsigned u) {

    if  (u > m_ucUsed)
        return;

    if  (u >= ChunkSize()) {
        m_pcpaNext -> Remove(u - ChunkSize());
        return;
    }

    delete  m_aStore[u];

    memmove((LPSTR) (m_aStore + u), (LPSTR) (m_aStore + u + 1),
        (ChunkSize() - (u + 1)) * sizeof m_aStore[0]);

    if (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcpaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = (CProfile *) NULL;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcpaNext) {
        delete  m_pcpaNext;
        m_pcpaNext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profprop.h ===
/******************************************************************************

  Header File:  Profile Property Sheet.H

  This defines the classes used to implement the profile management property
  sheet as defined in the ICM 2.0 shell extension functional specification.

  This class supplies one of two basic dialogs, depending upon whether or not
  the profile has already been installed.  We use the C++ profile class to
  hide any details of that knowledge from this code.

  All structures needed by any of the individual pages or resulting dialogs
  are kept here.  This allows us to easily handle the final Install/Don't
  Install/Associate/Don't Associate decisions.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version

******************************************************************************/

#if !defined(PROFILE_PROPSHEET)

#define PROFILE_PROPSHEET

#include    "Profile.H"
#include    "Dialog.H"

//  class   CProfilePropertySheet - cpps

class CProfilePropertySheet : public CDialog {

    CProfile&   m_cpTarget;
    CDialog     *m_pcdPage[2];
    RECT        m_rcTab;        //  Client area of tab Control
    BOOL        m_bDelete;
    CUintArray  m_cuaAdd;       //  Device associatins to be added
    CUintArray  m_cuaDelete;    //  Device associations to zap
    CUintArray  m_cuaAssociate; //  Tentative list of associated devices

    void    ConstructAssociations();

public:

    CProfilePropertySheet(HINSTANCE hiWhere, CProfile& cpTarget);

    ~CProfilePropertySheet();

    HWND        Window() const { return m_hwnd; }
    HINSTANCE   Instance() const { return m_hiWhere; }
    CProfile&   Profile() { return m_cpTarget; }
    BOOL        DeleteIsOK() const { return m_bDelete; }
    unsigned    AssociationCount() const { 
        return  m_cuaAssociate.Count();
    }

    unsigned    Association(unsigned u) { return m_cuaAssociate[u]; }

    LPCTSTR     DisplayName(unsigned u) { 
        return m_cpTarget.DisplayName(m_cuaAssociate[u]);
    }

    void    DeleteOnUninstall(BOOL bOn) {
        m_bDelete = bOn;
    }

    void    Associate(unsigned u);
    void    Dissociate(unsigned u);

    virtual BOOL    OnInit();
    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh);
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndControl);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profinfo.h ===
/******************************************************************************

  Header File:  Profile Information Page.H

  Defines the class used to display the profile information sheet.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  10-24-96  a-robkj@microsoft.com (Pretty Penny Enterprises) began coding this

******************************************************************************/

#include    "PropPage.H"
#include    "Profile.H"

//  CProfileInformationPage class- this handles the Profile Information page(s)

class CProfileInformationPage: public CShellExtensionPage {

    CString    m_csProfile;
    CProfile * m_pcpTarget;

public:

    CProfileInformationPage(HINSTANCE hiWhere, LPCTSTR lpstrTarget);
    ~CProfileInformationPage();

    virtual BOOL    OnInit();
    virtual BOOL    OnDestroy();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\profprop.cpp ===
/******************************************************************************

  Source File:  Profile Property Sheet.CPP

  This implements the code for the profile property sheet.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version

******************************************************************************/

#include    "ICMUI.H"

#include    "Resource.H"

//  Private ConstructAssociations function- this constructs the list of
//  tentative associations- this starts out as the true list from the profile
//  object, but reflects all adds and deletes made on the Advanced page.

void    CProfilePropertySheet::ConstructAssociations() {

    m_cuaAssociate.Empty(); //  Clean it up!

    for (unsigned u = 0; u < m_cpTarget.AssociationCount(); u++) {
        for (unsigned uDelete = 0; 
             uDelete < m_cuaDelete.Count(); 
             uDelete++)

            if  (m_cuaDelete[uDelete] == m_cpTarget.Association(u))
                break;

        if  (uDelete == m_cuaDelete.Count())    //  Not yet deleted
            m_cuaAssociate.Add(m_cpTarget.Association(u));
    }

    //  Now, add any added associations

    for (u = 0; u < m_cuaAdd.Count(); u++)
        m_cuaAssociate.Add(m_cuaAdd[u]);
}


//  Class constructor- we use one dialog for the installed case, and another
//  for the uninstalled one.  This traded code for resource size, since the
//  two forms are similar enough I can use the same code to handle both.

//  This is a tricky constructor- it actually presents the dialog when the
//  instance is constructed.

CProfilePropertySheet::CProfilePropertySheet(HINSTANCE hiWhere,
                                            CProfile& cpTarget) :
    CDialog(hiWhere, 
        cpTarget.IsInstalled() ? UninstallInterface : InstallInterface), 
        m_cpTarget(cpTarget) {

    if  (!cpTarget.IsValid()) {
        for (int i = 0; i < sizeof m_pcdPage / sizeof m_pcdPage[0]; i++)
            m_pcdPage[i] = NULL;

        CGlobals::Report(InvalidProfileString, m_hwndParent);
        return;
    }

    m_bDelete = FALSE;
    ConstructAssociations();

    DoModal();
}

//  Class destructor- we have to get rid of the individual pages

CProfilePropertySheet::~CProfilePropertySheet() {
    for (int i = 0; i < sizeof m_pcdPage / sizeof (m_pcdPage[0]); i++)
        if  (m_pcdPage[i])
            delete  m_pcdPage[i];
}

//  Public method for noting tentative associations to be added

void    CProfilePropertySheet::Associate(unsigned uAdd) {
    //  First, see if it's on the delete list.  If it is, remove it from there
    //  Otherwise, add us to the add list, if it's a new association.

    for (unsigned u = 0; u < m_cuaDelete.Count(); u++)
        if  (uAdd == m_cuaDelete[u])
            break;

    if  (u < m_cuaDelete.Count())
        m_cuaDelete.Remove(u);
    else {
        for (u = 0; u < m_cuaAssociate.Count(); u++)
            if  (m_cuaAssociate[u] == uAdd)
                break;
        if  (u == m_cuaAssociate.Count())
            m_cuaAdd.Add(uAdd);
    }

    ConstructAssociations();
}

//  Public Method for removing tentative associations

void    CProfilePropertySheet::Dissociate(unsigned uRemove) {
    //  First, see if it's on the add list.  If it is, remove it from there
    //  Otherwise, add us to the delete list.

    for (unsigned u = 0; u < m_cuaAdd.Count(); u++)
        if  (uRemove == m_cuaAdd[u])
            break;

    if  (u < m_cuaAdd.Count())
        m_cuaAdd.Remove(u);
    else
        m_cuaDelete.Add(uRemove);

    ConstructAssociations();
}

//  Dialog Initialization override

BOOL    CProfilePropertySheet::OnInit() {

    CString csWork;
    TC_ITEM tciThis = {TCIF_TEXT, 0, 0, NULL, 0, -1, 0};

    //  We'll begin by determining the bounding rectangle of the client
    //  area of the tab control

    RECT rcWork;

    GetWindowRect(GetDlgItem(m_hwnd, TabControl), &m_rcTab);
    GetWindowRect(m_hwnd, &rcWork);
    OffsetRect(&m_rcTab, -rcWork.left, -rcWork.top);
    SendDlgItemMessage(m_hwnd, TabControl, TCM_ADJUSTRECT, FALSE, 
        (LPARAM) &m_rcTab);

    //  Then, we create the classes for the two descendants, and
    //  initialize the first dialog.
    
    m_pcdPage[0] = new CInstallPage(this);
    m_pcdPage[1] = new CAdvancedPage(this);
    m_pcdPage[0] -> Create();
    m_pcdPage[0] -> Adjust(m_rcTab);
    
    //  Then, initialize the tab control

    csWork.Load(m_cpTarget.IsInstalled() ? 
        ShortUninstallString : ShortInstallString);

    tciThis.pszText = const_cast<LPTSTR>((LPCTSTR) csWork);

    SendDlgItemMessage(m_hwnd, TabControl, TCM_INSERTITEM, 0, 
        (LPARAM) &tciThis);

    csWork.Load(AdvancedString);

    tciThis.pszText = const_cast<LPTSTR>((LPCTSTR) csWork);

    SendDlgItemMessage(m_hwnd, TabControl, TCM_INSERTITEM, 1, 
        (LPARAM) &tciThis);

    //  Finally, let's set the icons for this little monster...

    HICON   hi = LoadIcon(m_hiWhere, 
        MAKEINTRESOURCE(m_cpTarget.IsInstalled() ? 
            DefaultIcon : UninstalledIcon));

    SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM) hi);

    return  TRUE;   //  We've not set the focus anywhere
}

//  Common control notification override

BOOL    CProfilePropertySheet::OnNotify(int idCtrl, LPNMHDR pnmh) {

    int iPage = !!SendMessage(pnmh -> hwndFrom, TCM_GETCURSEL, 0, 0);

    switch  (pnmh -> code) {
        case    TCN_SELCHANGING:

            m_pcdPage[iPage] -> Destroy();
            return  FALSE;      //  Allow the selection to change.

        case    TCN_SELCHANGE:

            //  Create the appropriate dialog

            m_pcdPage[iPage] -> Create();
            m_pcdPage[iPage] -> Adjust(m_rcTab);

            return  TRUE;
    }

    return  TRUE;   //  Claim to have handled it (perhaps a bit bogus).
}

//  Control Notification override

BOOL    CProfilePropertySheet::OnCommand(WORD wNotifyCode, WORD wid, 
                                         HWND hwndControl) {
    switch  (wid) {

        case    IDOK:

            if  (wNotifyCode == BN_CLICKED && !m_cpTarget.IsInstalled())
                m_cpTarget.Install();
            //  Remove any associations we're removing
            while   (m_cuaDelete.Count()) {
                m_cpTarget.Dissociate(m_cpTarget.Device(m_cuaDelete[0]));
                m_cuaDelete.Remove(0);
            }
            //  Add any associations we're adding
            while   (m_cuaAdd.Count()) {
                m_cpTarget.Associate(m_cpTarget.Device(m_cuaAdd[0]));
                m_cuaAdd.Remove(0);
            }
            break;

        case    UninstallButton:

            if  (wNotifyCode == BN_CLICKED)
                m_cpTarget.Uninstall(m_bDelete);
            break;
    }
    
    return  CDialog::OnCommand(wNotifyCode, wid, hwndControl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\propdlg.h ===
/******************************************************************************

  Header File:  Property Dialogs.H

  This header defines several classes used for property pages in the UI.  Each
  class is a derived class from CDialog and is described in more detail at the
  point it is defined.

  Each of these classes maintain a reference to the CProfilePropertySheet class
  and use it for the bulk of their information retrieval and interaction.  The
  underlying profile information is available via the Profile() method of
  CProfilePropertySheet.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version

******************************************************************************/

#if !defined(PROPERTY_DIALOGS)

#define PROPERTY_DIALOGS

#include    "ProfProp.H"

/******************************************************************************

  The CInstallPage class presents the dialog on either the install or uninstall
  tab, based upon whether or not the supplied profile is installed.  The two
  dialogs are similar enough that one piece of code will initialize both.

******************************************************************************/

//  CInstallPage class- this encapsulates the Install/Uninstall sheet

class   CInstallPage : public CDialog {
    CProfilePropertySheet&  m_cppsBoss;

public:

    CInstallPage(CProfilePropertySheet *pcppsBoss);
    ~CInstallPage();

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);
};

/******************************************************************************

  The CAdvancedPage handles the dialog on the Advanced tab of the UI.  This
  dialog and its handling are the same whether or not the profile is installed.

******************************************************************************/

//  CAdvancedPage class- this handles the Advanced property page

class CAdvancedPage: public CDialog {
    CProfilePropertySheet&  m_cppsBoss;

    void    Update();   //  Update the list and controls

public:

    CAdvancedPage(CProfilePropertySheet *pcppsBoss);
    ~CAdvancedPage();

    virtual BOOL    OnInit();
    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl);
};

/******************************************************************************

  The CAddDeviceDialog class handles the Add Device Dialog, which can be called
  from the Advanced tab.

******************************************************************************/

class CAddDeviceDialog: public CDialog {
    CProfilePropertySheet&  m_cppsBoss;
    HWND                    m_hwndList, m_hwndButton;

public:

    CAddDeviceDialog(CProfilePropertySheet& cpps, HWND hwndParent);

    virtual BOOL    OnInit();

    virtual BOOL    OnCommand(WORD wNotification, WORD wid, HWND hwndControl);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\proppage.cpp ===
/******************************************************************************

  Source File:  Property Page.CPP

  Implements the CPropertyPage class.  See the associated header file for
  details.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version
  12-04-96  a-robkj@microsoft.com   retrieve handle to sheet, Create a derived
                                    class for shell extension pages

******************************************************************************/

#include    "ICMUI.H"

//  CPropertyPage member functions

//  Class constructor- basic initializations.  Any remaining PROPSHEETPAGE
//  initializations are expected to be done by the derived class.

CPropertyPage::CPropertyPage() {
    m_psp.dwSize = sizeof m_psp;
    m_psp.pfnDlgProc = (DLGPROC) DialogProc;
    m_psp.lParam = (LPARAM) this;
    m_psp.dwFlags = PSP_DEFAULT;    //  Can be overriden later
	m_hpsp = NULL;
    m_bChanged = FALSE;
}

//  Handle retrieval- I'll admit an addiction to one-liners

HPROPSHEETPAGE  CPropertyPage::Handle() {
    return m_hpsp = (m_hpsp ? m_hpsp : CreatePropertySheetPage(&m_psp));
}

//  Dialog Procedure

BOOL CALLBACK   CPropertyPage::DialogProc(HWND hwndPage, UINT uMsg, WPARAM wp,
                                          LPARAM lp) {

    CPropertyPage   *pcppMe =
        (CPropertyPage *) GetWindowLongPtr(hwndPage, DWLP_USER);

    switch  (uMsg) {

        case    WM_INITDIALOG:

            //  In this case, lp points to the PROPSHEETHEADER that created
            //  us.  We look into its lParam member for our this pointer,
            //  and store this in the dialog's private data.  This lets us
            //  use the pointer to get at all of our overridable functions.

            pcppMe = (CPropertyPage *) ((LPPROPSHEETPAGE) lp) -> lParam;

            SetWindowLongPtr(hwndPage, DWLP_USER, (LONG_PTR) pcppMe);
            pcppMe -> m_hwnd = hwndPage;

            //  Now, see if the derived class has any initialization needs

            return  pcppMe -> OnInit();

        //  Overridable processing for standard control notifications

        case    WM_COMMAND:

            return  pcppMe -> OnCommand(HIWORD(wp), LOWORD(wp), (HWND) lp);

        case    WM_DESTROY:

            return  pcppMe -> OnDestroy();

        case    WM_HELP:

            return  pcppMe -> OnHelp((LPHELPINFO) lp);

        case    WM_CONTEXTMENU:

            return  pcppMe -> OnContextMenu((HWND) wp);

        //  Overridable processing for common control notifications

        case    WM_NOTIFY:  {

            //  If the message is PSM_SETACTIVE, note the property sheet hwnd

            LPNMHDR pnmh = (LPNMHDR) lp;

            if  (pnmh -> code == PSN_SETACTIVE)
                pcppMe -> m_hwndSheet = pnmh -> hwndFrom;
            return  pcppMe -> OnNotify((int) wp, pnmh);
        }

    }

    return  FALSE;  //  We didn't handle the message.
}

//  CShellExtensionPage class member methods

CShellExtensionPage *CShellExtensionPage::m_pcsepAnchor = NULL;

//  We enable reference counting, partially because on NT, the Window handle
//  sometimes appears invalid even while the dialog is up.  However, we also
//  keep the chaining mechanism, as this is the only sane way we have of
//  freeing up the object instances we've created.

CShellExtensionPage::CShellExtensionPage() {

    if  (m_pcsepAnchor) {

        // If there is a cell other than anchor, update its list.
        if (m_pcsepAnchor -> m_pcsepNext)
            m_pcsepAnchor -> m_pcsepNext -> m_pcsepPrevious = this;
        // Insert this cell right after the anchor.
        m_pcsepPrevious = m_pcsepAnchor;
        m_pcsepNext = m_pcsepAnchor -> m_pcsepNext;
        m_pcsepAnchor -> m_pcsepNext = this;
    }
    else {

        m_pcsepAnchor = this;
        m_pcsepNext = m_pcsepPrevious = NULL;
    }

    m_psp.pcRefParent = (UINT *) &CGlobals::ReferenceCounter();
    m_psp.dwFlags |= PSP_USEREFPARENT;
}

CShellExtensionPage::~CShellExtensionPage() {

    if  (this == m_pcsepAnchor) {
        m_pcsepAnchor = m_pcsepNext; 
        if (m_pcsepAnchor) {
            // Anchor never has previous.
            m_pcsepAnchor -> m_pcsepPrevious = NULL;
        }
    }
    else {
        m_pcsepPrevious -> m_pcsepNext = m_pcsepNext;
        // If there is other cell following this, update it.
        if (m_pcsepNext)
            m_pcsepNext -> m_pcsepPrevious = m_pcsepPrevious;
    }
}

//  This little ditty lets us decide when it's safe to unload the DLL- it also
//  guarantees all class destructors are called as sheets get closed by the
//  various potential callers.

BOOL    CShellExtensionPage::OKToClose() {

    while   (m_pcsepAnchor) {
        if  (IsWindow(m_pcsepAnchor -> m_hwnd))
            return  FALSE;  //  This page is still alive!

        delete  m_pcsepAnchor;  //  Page isn't alive, delete it...
    }

    return  TRUE;   //  No more pages allocated
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\propdlg.cpp ===
/******************************************************************************

  Source File: Property Dialogs.CPP

  Implements the dialogs used in the Profile Management UI.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version

******************************************************************************/

#include    "ICMUI.H"

#include    <stdlib.h>
#include    "Resource.H"

//  CInstallPage member functions

//  Class constructor

CInstallPage::CInstallPage(CProfilePropertySheet *pcpps) :
    CDialog(pcpps -> Instance(),
        pcpps -> Profile().IsInstalled() ? UninstallPage : InstallPage, 
        pcpps -> Window()), m_cppsBoss(*pcpps){ }

CInstallPage::~CInstallPage() {}

//  OnInit function- this initializes the property page

BOOL    CInstallPage::OnInit() {

    SetDlgItemText(m_hwnd, ProfileNameControl, m_cppsBoss.Profile().GetName());
    if  (m_cppsBoss.Profile().IsInstalled())
        CheckDlgButton(m_hwnd, DeleteFileControl, 
            m_cppsBoss.DeleteIsOK() ? BST_CHECKED : BST_UNCHECKED);

    return  TRUE;
}

BOOL    CInstallPage::OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl) {
    switch  (wid) {
        case    DeleteFileControl:

            if  (wNotifyCode == BN_CLICKED) {
                m_cppsBoss.DeleteOnUninstall(
                    IsDlgButtonChecked(m_hwnd, DeleteFileControl) == 
                        BST_CHECKED);
                return  TRUE;
            }

            break;

        case    ProfileNameControl:
            if  (wNotifyCode == EN_SETFOCUS) {
                //  We don't want the entire string selected and scrolled
                SendDlgItemMessage(m_hwnd, ProfileNameControl, EM_SETSEL,
                    0, 0);
                return  TRUE;
            }
            break;
    }

    return  FALSE;
}

//  CAdvancedPage member functions

CAdvancedPage::CAdvancedPage(CProfilePropertySheet *pcpps) :
    CDialog(pcpps -> Instance(), AdvancedPage, pcpps -> Window()), 
        m_cppsBoss(*pcpps){ }

//  Class destructor

CAdvancedPage::~CAdvancedPage() {}

//  Update private function- fill the list box, and set all the buttons
//  properly.

void    CAdvancedPage::Update() {

    //  Add the associations to the list

    SendDlgItemMessage(m_hwnd, DeviceListControl, LB_RESETCONTENT, 0, 0);

    for (unsigned u = m_cppsBoss.AssociationCount(); u--; ) {
        int iItem = SendDlgItemMessage(m_hwnd, DeviceListControl, LB_ADDSTRING,
            0, (LPARAM) m_cppsBoss.DisplayName(u));
        SendDlgItemMessage(m_hwnd, DeviceListControl, LB_SETITEMDATA, iItem,
            (LPARAM) m_cppsBoss.Association(u));
    }

    //  If there are no associations, disable the Remove Devices button

    EnableWindow(GetDlgItem(m_hwnd, RemoveDeviceButton), 
        m_cppsBoss.Profile().AssociationCount());

    //  If there are no devices, or all are associated, disable the Add 
    //  Devices button.

    EnableWindow(GetDlgItem(m_hwnd, AddDeviceButton), 
        m_cppsBoss.Profile().DeviceCount() && 
            m_cppsBoss.Profile().DeviceCount() > m_cppsBoss.AssociationCount());
}

//  OnInit function- this initializes the property page

BOOL    CAdvancedPage::OnInit() {

    SetDlgItemText(m_hwnd, ProfileNameControl, m_cppsBoss.Profile().GetName());

    //  Add the associations to the list, etc.

    Update();
    return  TRUE;
}

//  OnCommand override- handles control notifications

BOOL    CAdvancedPage::OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl) {

    switch  (wid) {

        case    AddDeviceButton:

            if  (wNotifyCode == BN_CLICKED) {
                CAddDeviceDialog    cadd(m_cppsBoss, m_hwnd);
                Update();
                return  TRUE;
            }
            break;

        case    RemoveDeviceButton:

            if  (wNotifyCode == BN_CLICKED) {

                int i = SendDlgItemMessage(m_hwnd, DeviceListControl,
                    LB_GETCURSEL, 0, 0);

                if  (i == -1)
                    return  TRUE;

                unsigned uItem = SendDlgItemMessage(m_hwnd, DeviceListControl,
                    LB_GETITEMDATA, i, 0);
                m_cppsBoss.Dissociate(uItem);
                Update();
                return  TRUE;
            }
            break;

        case    DeviceListControl:
            switch  (wNotifyCode) {

                case    LBN_SELCHANGE:
                    EnableWindow(GetDlgItem(m_hwnd, RemoveDeviceButton),
                        -1 != SendMessage(hwndCtl, LB_GETCURSEL, 0, 0));
                    return  TRUE;
            }
            break;
    }

    return  FALSE;
}


//  CAddDeviceDialog class constructor

CAddDeviceDialog::CAddDeviceDialog(CProfilePropertySheet& cpps, 
                                   HWND hwndParent) : 
    CDialog(cpps.Instance(), AddDeviceDialog, hwndParent), m_cppsBoss(cpps) {
    DoModal();
}

//  Dialog Initialization routine

BOOL    CAddDeviceDialog::OnInit() {

    CProfile&   cpThis = m_cppsBoss.Profile();
    m_hwndList = GetDlgItem(m_hwnd, DeviceListControl);
    m_hwndButton = GetDlgItem(m_hwnd, AddDeviceButton);

    //  This must not list associated (tentatively) devices, per the spec

    for (unsigned uDevice = 0; uDevice < cpThis.DeviceCount(); uDevice++) {
        for (unsigned u = 0; u < m_cppsBoss.AssociationCount(); u++)
            if  (uDevice == m_cppsBoss.Association(u))
                break;
        if  (u < m_cppsBoss.AssociationCount())
            continue;   //  Don't insert this one...
        int idItem = SendMessage(m_hwndList, LB_ADDSTRING, 0, 
            (LPARAM) cpThis.DisplayName(uDevice));
        SendMessage(m_hwndList, LB_SETITEMDATA, idItem, (LPARAM) uDevice);
    }

    if  (SendMessage(m_hwndList, LB_GETCOUNT, 0, 0))
        SendMessage(m_hwndList, LB_SETCURSEL, 0, 0);
    
    EnableWindow(m_hwndButton, -1 !=  
        SendMessage(m_hwndList, LB_GETCURSEL, 0, 0));
    return  TRUE;
}

//  Dialog notification handler

BOOL    CAddDeviceDialog::OnCommand(WORD wNotification, WORD wid, 
                                    HWND hwndControl){

    switch  (wNotification) {

        case    LBN_SELCHANGE:
            EnableWindow(m_hwndButton, -1 != 
                SendMessage(m_hwndList, LB_GETCURSEL, 0, 0));
            return  TRUE;

        case    BN_CLICKED:
            if  (wid == AddDeviceButton) {

                int i = SendMessage(m_hwndList, LB_GETCURSEL, 0, 0);

                if  (i == -1)
                    return  TRUE;

                unsigned uItem = (unsigned) SendMessage(m_hwndList, 
                    LB_GETITEMDATA, i, 0);
                m_cppsBoss.Associate(uItem);
            }
            break;

        case    LBN_DBLCLK: 
            return  OnCommand(BN_CLICKED, AddDeviceButton, m_hwndButton);
    }

    return  CDialog::OnCommand(wNotification, wid, hwndControl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\proppage.h ===
/******************************************************************************

  Header File:  Property Page.H

  This defines the C++ class used to encapsulate property pages.  This class
  has a static method for the dialog procedure, which automatically caches the
  "this" pointer for the class in the DWL_USER field of the windows internal
  structure for the dialog used for the property page.  This hand-off is
  accomplished by setting the lParam field of the PROPSHEETPAGE structure to
  the "this" pointer.  It also saves the dialog handle in a protected member
  for easy access from derived classes.

  To create a C++ class for any specific property sheet, derive the class
  from this class, providing the dialog ID and instance handle needed to get
  the resource in the m_psp member.

  The dialog procedure then provides virtual functions for Windows messages
  of interest.  I've added these as needed.  If I were going to a truly 
  universal class of this sort, I'd just as well go to MFC, and save the 
  debugging time, so this approach seems reasonable to me.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version

******************************************************************************/

#if !defined(PROPERTY_PAGE)

#define PROPERTY_PAGE

//  CPropertyPage class- abstracts a property page for us

class CPropertyPage {

    //  Basic dialog procedure for all derived classes

    static BOOL CALLBACK    DialogProc(HWND hwndPage, UINT uMsg, WPARAM wp,
                                       LPARAM lp);

    //  These elements should be protected (only available to derived classes)

protected:
    PROPSHEETPAGE   m_psp;
    HWND            m_hwnd, m_hwndSheet;
    HPROPSHEETPAGE  m_hpsp;

    BOOL            m_bChanged;

public:

    CPropertyPage();    //  Default Constructor
    virtual ~CPropertyPage() {}

    HPROPSHEETPAGE  Handle();   //  Calls CreatePropertySheetPage, if needed

    VOID            EnableApplyButton() {
        SendMessage(m_hwndSheet, PSM_CHANGED, (WPARAM) m_hwnd, 0);
    }

    VOID            DisableApplyButton() {
        SendMessage(m_hwndSheet, PSM_UNCHANGED, (WPARAM) m_hwnd, 0);
    }

    BOOL            SettingChanged()    {
        return m_bChanged;
    }

    VOID            SettingChanged(BOOL b) {
        m_bChanged = b;
    }

    //  virtual functions- these get redefined on an as needed basis for
    //  any specialized handling desired by any derived classes.

    //  The default handling allows one to initially display the sheet with
    //  no coding beyond the constructor for the derived class

    virtual BOOL    OnCommand(WORD wNotifyCode, WORD wid, HWND hwndCtl) {
        return FALSE;
    }

    virtual BOOL    OnNotify(int idCtrl, LPNMHDR pnmh) {
        return  FALSE;
    }

    virtual BOOL    OnInit() { return TRUE; }

    virtual BOOL    OnDestroy() { return FALSE; }

    virtual BOOL    OnHelp(LPHELPINFO pHelp) { return TRUE; }
    virtual BOOL    OnContextMenu(HWND hwnd) { return TRUE; }
};

/******************************************************************************

  Shell Extension property page class

  Noteworthy details:

  These pages are displayed by the shell.  The thread of execution is such that
  we create the page, then return to the shell.  The shell will then attempt to
  unload the extension.  It will query CanDllUnloadNow to do this.  Since
  freeing the library frees the page template and dialog procedure, we can't
  allow this to happen while any instances of this class exist.

  However, the shell doesn't know this is a class, so it won't destroy it.

  What I've done is build a circular chain of all of the instances of this
  class, anchored in a private static class member.  A public static method
  (OKToClose) then walks the chain.  If an instance's window handle is no
  longer valid, then the shell has finished with it, and we delete it.  The
  criterion for closing then becomes not finding a valid handle (so we don't
  delay unloading by any lazy evaluation, such as requiring an empty chain
  on entry).

  All Property pages displayed by a property sheet extension should be derived
  from this class.

  While a mechanism is provided by property sheets for a reference count
  maintenance mechanism, this mechanism will not call any class destructor-
  this could lead to memory leaks, which is why I've chosen this method.

******************************************************************************/

class CShellExtensionPage: public CPropertyPage {

    static  CShellExtensionPage *m_pcsepAnchor; //  Anchor the chain of these

    CShellExtensionPage *m_pcsepPrevious, *m_pcsepNext;

public:

    CShellExtensionPage();
    ~CShellExtensionPage();

    static BOOL OKToClose();
};


#endif  //  Keep us from getting multiply defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for the Integrated Color Matching User
  Interface DLL

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  12-14-96  a-robkj@microsoft.com   Added this header to the .H file
                                    originally generated by Developer Studio

******************************************************************************/

#include <dlgs.h>

//
// Resource ID for string table
//
#define ShortInstallString              1
#define ShortUninstallString            2
#define AdvancedString                  3

#define InstallProfileMenuString        4
#define UninstallProfileMenuString      5
#define AssociateMenuString             6

#define ProfilePropertyString           7
#define AssociatePropertyString         8
#define MessageBoxTitle                 9
#define AddProfileAssociation           10

#define AddButtonText                   11

#define DefaultSourceString             12
#define PerceptualString                13
#define Occupied0                       14
#define Occupied1                       15
#define Occupied2                       16

#define ClassMonitorString              17
#define ClassPrinterString              18
#define ClassScannerString              19
#define ClassLinkString                 20
#define ClassAbstractString             21
#define ClassColorSpaceString           22
#define ClassNamedString                23

#define NoDefaultProfile                24
#define NoProfileString                 25
#define NoPrintersInstalled             26
#define NoAdditionalInfo                27
#define NotColorPrinter                 28

#define InvalidProfileString            29
#define MismatchDeviceType              30
#define InstFailedWithName              31
#define UninstFailedWithName            32
#define AssocFailedWithName             33
#define DisassocFailedWithName          34

#define IccProfileFilterString          35
#define AllProfileFilterString          36
#define TooManyFileSelected             37

#define UnsupportedProfile              38

#define UninstallProfileContextMenuString      39
#define UninstallMultiProfileContextMenuString 40
#define InstallProfileContextMenuString        41
#define InstallMultiProfileContextMenuString   42
#define AssociateContextMenuString             43

#define AskRemoveDefault                       44

// Resource string name for the friendly filename used for .icc and .icm
// profiles - required for MUI.

#define FriendlyTypeName                       45

/////////////////////////////////////////////////////////////////////////////

//
// Resource ID for dialogs
//
#define DefaultIcon                     100
#define UninstalledIcon                 101

#define PrinterUI                       110
#define MonitorUI                       111
#define ScannerUI                       112
#define AddDeviceDialog                 113
#define ProfilePropertyPage             114
#define AssociateDevicePage             115

#define ProfileDescription              120
#define AdditionalProfileInfo           121
#define ProfileProducerInfo             122

#define AddDeviceButton                 130
#define RemoveDeviceButton              131
#define AddButton                       132
#define RemoveButton                    133
#define DefaultButton                   134
#define AutoSelButton                   135
#define ManualSelButton                 136

#define DeviceListControl               140
#define DeviceListControlText           141
#define ProfileListControl              142
#define ProfileListControlText          143
#define DescriptionText                 144
#define PrinterUIIcon                   145
#define AutoSelText                     146
#define ManualSelText                   147

#define MonitorName                     150
#define MonitorNameText                 151
#define DefaultProfile                  152
#define DefaultProfileText              153
#define ProfileFilename                 154

#define CMMDescription                  160
#define CMMIcon                         161
#define StatusIcon                      162

//
// SetupColorMatch UI resource IDs (0x4??)
//
#define ApplyButton                     psh1
#define SourceProfile                   edt1
#define EnableICM                       chx1
#define EnableBasic                     rad1
#define EnableProofing                  rad2
#define MonitorProfileLabel             stc1
#define PrinterProfileLabel             stc2
#define RenderingIntentLabel            stc3
#define TargetProfileLabel              stc4
#define TargetIntentLabel               stc5
#define RenderingIntentText1            stc6
#define SourceProfileLabel              stc7
#define MonitorProfile                  cmb1
#define PrinterProfile                  cmb2
#define RenderingIntent                 cmb3
#define TargetProfile                   cmb4
#define TargetIntent                    cmb5

//
// SetupColorMatch UI Dialog (1551)
//
#define ApplicationUI                   COLORMGMTDLGORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\shellext.cpp ===
/*****************************************************************************

  Source File:  Shell Extension Classes.CPP

  This file implements the Shell Extension classes.

  Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:

  10-28-96  A-RobKj (Pretty Penny Enterprises) began coding
  12-04-96  A-RobKj Added the printer tab support
  12-13-96  A-RobKj Modified for faster Icon extraction
  01-07-97  KjelgaardR@ACM.Org  Removed IContextMenu functions in favor of
            an exported ManageColorProfile procedure.  This supplies a
            language-independent "Open" item that works with either mouse
            button.
  01-08-97  KjelgaardR@acm.org  Added utility routine to determine if a printer
            is a color model.  Modified printer UI to only add pages for color
            printers.

******************************************************************************/

#include    "ICMUI.H"

#include    <shlobj.h>
#include    <string.h>

#include    <initguid.h>
#include    <shfusion.h>

#include    "ShellExt.H"
#include    "Resource.H"

//  Declare some storage space for the global statics

int     CGlobals::m_icDLLReferences = 0;
HMODULE CGlobals::m_hmThisDll = NULL;
CStringArray    CGlobals::m_csaProfiles;
BOOL            CGlobals::m_bIsValid = FALSE;

//  Some global useful procs- an error reporter

void    CGlobals::Report(int idError, HWND m_hwndParent) {
    CString csMessage, csTitle;

    csMessage.Load(idError);
    csTitle.Load(MessageBoxTitle);

    MessageBox(m_hwndParent, csMessage, csTitle, MB_OK|MB_ICONEXCLAMATION);
}

int    CGlobals::ReportEx(int idError, HWND m_hwndParent,
                          BOOL bSystemMessage, UINT uType, DWORD dwNumMsg, ...) {
    CString csMessage, csTitle;
    va_list argList;

    va_start(argList,dwNumMsg);
    csMessage.LoadAndFormat(idError,NULL,bSystemMessage,dwNumMsg,&argList);
    csTitle.Load(MessageBoxTitle);
    va_end(argList);

    return (MessageBox(m_hwndParent, csMessage, csTitle, uType));
}

//  A profile status checker

BOOL    CGlobals::IsInstalled(CString& csProfile) {
//    if  (!m_bIsValid) {
        ENUMTYPE    et = {sizeof et, ENUM_TYPE_VERSION, 0, NULL};

        CProfile::Enumerate(et, m_csaProfiles);
        m_bIsValid = TRUE;
//    }

    for (unsigned u = 0; u < m_csaProfiles.Count(); u++)
        if  (!lstrcmpi(csProfile.NameOnly(), m_csaProfiles[u].NameOnly()))
            break;

    return  u < m_csaProfiles.Count();
}

//  Utility routine to report if a printer is color or monochrome
BOOL CGlobals::ThisIsAColorPrinter(LPCTSTR lpstrName) {
  HDC hdcThis = CGlobals::GetPrinterHDC(lpstrName);
  BOOL bReturn = FALSE;
  if  (hdcThis) {
    bReturn =  2 < (unsigned) GetDeviceCaps(hdcThis, NUMCOLORS);
    DeleteDC(hdcThis);
  }
  return bReturn;
}

// Utility to determine the hdc for a printer
// The caller is responsible for calling
// DeleteDC() on the result
HDC CGlobals::GetPrinterHDC(LPCTSTR lpstrName) {

    HANDLE  hPrinter;   //  Get a handle on it...
    LPTSTR  lpstrMe = const_cast <LPTSTR> (lpstrName);

    if  (!OpenPrinter(lpstrMe, &hPrinter, NULL)) {
        _RPTF2(_CRT_WARN, "Unable to open printer '%s'- error %d\n", lpstrName,
            GetLastError());
        return  FALSE;
    }

    //  First, use DocumentProperties to find the correct DEVMODE size- we
    //  must use the DEVMODE to force color on, in case the user's defaults
    //  have turned it off...

    unsigned short lcbNeeded = (unsigned short) DocumentProperties(NULL, hPrinter, lpstrMe, NULL,
        NULL, 0);

    if  (lcbNeeded <= 0) {
        _RPTF2(_CRT_WARN,
            "Document Properties (get size) for '%s' returned %d\n", lpstrName,
            lcbNeeded);
        ClosePrinter(hPrinter);
        return  FALSE;
    }

    HDC hdcThis = NULL;

    union {
        LPBYTE      lpb;
        LPDEVMODE   lpdm;
    };

    lpb = new BYTE[lcbNeeded];

    if  (lpb) {

        ZeroMemory(lpb,lcbNeeded);
        lpdm -> dmSize = lcbNeeded;
        lpdm -> dmFields = DM_COLOR;
        lpdm -> dmColor = DMCOLOR_COLOR;
        if  (IDOK == DocumentProperties(NULL, hPrinter, lpstrMe, lpdm, lpdm,
            DM_IN_BUFFER | DM_OUT_BUFFER)) {

            //  Turn off ICM, since not nessesary here.
            //
            lpdm -> dmICMMethod = DMICMMETHOD_NONE;

            //  Finally, we can create the DC!
            //  Note: we're not actually creating a DC, just an IC
            hdcThis = CreateIC(NULL, lpstrName, NULL, lpdm);
        } else {
            _RPTF2(_CRT_WARN,
                "DocumentProperties (retrieve) on '%s' failed- error %d\n",
                lpstrName, GetLastError());
        }
        delete lpb;
    }
    else
        _RPTF2(_CRT_WARN, "ThisIsAColorPrinter(%s) failed to get %d bytes\n",
            lpstrName, lcbNeeded);

    ClosePrinter(hPrinter);

    return hdcThis;
}

//  Required Shell Extension DLL interfaces

STDAPI  DllCanUnloadNow() {
    return  CGlobals::CanUnload();
}

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvOut) {
    return  CIcmUiFactory::KeyToTheFactory(rclsid, riid, ppvOut);
}

extern "C" int APIENTRY DllMain(HMODULE hmThis, DWORD dwReason,
                                LPVOID lpvReserved) {
#if defined(DEBUG) || defined(_DEBUG)
    static  HANDLE  hfWarnings; //  Log file
#endif
    switch  (dwReason) {

        case    DLL_PROCESS_ATTACH:

            SHFusionInitializeFromModuleID(hmThis, SHFUSION_CPL_RESOURCE_ID);
            
            //  Save the handle
            CGlobals::SetHandle(hmThis);
#if defined(DEBUG) || defined(_DEBUG)
            _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_WNDW);
            _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
            hfWarnings = CreateFileA("C:\\ICMUIWarn.Txt", GENERIC_WRITE, 0,
                NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

            if  (hfWarnings!= INVALID_HANDLE_VALUE) {
                SetFilePointer(hfWarnings, 0, NULL, FILE_END);
                _CrtSetReportFile(_CRT_WARN, hfWarnings);
            }
            _RPTF1(_CRT_WARN, "ICMUI DLL being loaded- handle %X\n", hmThis);
#endif
            break;

        case    DLL_PROCESS_DETACH:
            

#if defined(DEBUG) || defined(_DEBUG)
            _RPTF0(_CRT_WARN, "ICMUI DLL being unloaded\n");

            if  (hfWarnings != INVALID_HANDLE_VALUE)
                CloseHandle(hfWarnings);
#endif

            SHFusionUninitialize();

    }

    return  1;
}

//  CIcmUiFactory member functions- these are used to provide external access
//  to the class factory.  The shell uses these to initialize extensions for
//  both context menus and property sheets, both of which we provide,
//  fortunately in the same object...

CIcmUiFactory::CIcmUiFactory(REFCLSID rclsid) {
    m_ulcReferences = 0;
    CGlobals::Attach();
    if  (IsEqualIID(rclsid, CLSID_ICM))
        m_utThis = IsProfile;
    else if (IsEqualIID(rclsid, CLSID_PRINTERUI))
        m_utThis = IsPrinter;
    else if (IsEqualIID(rclsid, CLSID_SCANNERUI))
        m_utThis = IsScanner;
    else
        m_utThis = IsMonitor;
}

STDMETHODIMP    CIcmUiFactory::QueryInterface(REFIID riid, void **ppvObject) {

    if  (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = this;
        AddRef();
        return  NOERROR;
    }
    //  Asked for an interface we ain't got!
    *ppvObject = NULL;
    return  E_NOINTERFACE;
}

//  IClassFactory interface functions

STDMETHODIMP    CIcmUiFactory::CreateInstance(LPUNKNOWN punk, REFIID riid,
                                              void **ppvInstance) {

    *ppvInstance = NULL;

    if  (punk)  //  We don't allow aggregation
        return  CLASS_E_NOAGGREGATION;

    //  We simply create a new ICM UI object, and return an interface to it.
    //  This will get queried by the shell for IExtShellInit, and the init job
    //  will be done.

    CICMUserInterface   *pcicmui = new CICMUserInterface(m_utThis);

    if  (!pcicmui)
        return  E_OUTOFMEMORY;

    //  Let's be paranoid- if the QueryInterface failes, kill the ICMUI object,
    //  so we can still be unloaded!

    HRESULT hrReturn = pcicmui -> QueryInterface(riid, ppvInstance);

    if  (!*ppvInstance)
        delete  pcicmui;

    return  hrReturn;
}


//  Key to the factory is a static function that allows outsiders to instance
//  the class factory.  So, the caller will first instance the factory, then
//  instance implementations of the interfaces it needs using the factory
//  instance it receives from here.

HRESULT CIcmUiFactory::KeyToTheFactory(REFCLSID rclsid, REFIID riid,
                                       void **ppvObject) {
  
    *ppvObject = NULL;

    if  (!IsEqualIID(rclsid, CLSID_ICM) &&
         !IsEqualIID(rclsid, CLSID_MONITORUI) &&
         !IsEqualIID(rclsid, CLSID_SCANNERUI) &&
         !IsEqualIID(rclsid, CLSID_PRINTERUI))
        return  CLASS_E_CLASSNOTAVAILABLE;

    CIcmUiFactory   *pciuf = new CIcmUiFactory(rclsid);

    if  (!pciuf)
        return  E_OUTOFMEMORY;

    HRESULT hrReturn = pciuf -> QueryInterface(riid, ppvObject);

    if  (!*ppvObject)
        delete  pciuf;

    return  hrReturn;
}

/******************************************************************************

  ICM UI class methods- these do the true interface work of the DLL.

******************************************************************************/


CICMUserInterface::CICMUserInterface(UITYPE utThis) {
    m_lpdoTarget = NULL;
    m_ulcReferences = 0;
    m_utThis = utThis;
    CGlobals::Attach();
    _RPTF2(_CRT_WARN, "CICMUserInterface(%d) constructed @ %lX\n", utThis, this);
}
//  QueryInterface gets a bit long, but not too badly.  The casts are needed
//  because we use multiple inheritance- casting the this pointer to a base
//  class actually returns a this pointer for that base class' part of the
//  instance.  Unlike single inheritance, the this pointer for the
//  CICMUserInterface class does not directly reference ANY of the base
//  classes.

STDMETHODIMP    CICMUserInterface::QueryInterface(REFIID riid,
                                                  void **ppvObject) {
    *ppvObject = NULL;  //  Assume the worst
    //  Since the device UI support a different set of functions, let's be
    //  particular about which interfaces we claim to support when...
    if  (m_utThis > IsProfile) {
        if  (IsEqualIID(riid, IID_IUnknown) ||
                IsEqualIID(riid, IID_IShellExtInit))
            *ppvObject = (IShellExtInit *) this;
        if  (IsEqualIID(riid, IID_IShellPropSheetExt))
               *ppvObject = (IShellPropSheetExt *) this;
    }
    else {
        if  (IsEqualIID(riid, IID_IUnknown) ||
                IsEqualIID(riid, IID_IContextMenu))
            *ppvObject = (IContextMenu *) this;

        if  (IsEqualIID(riid, IID_IShellExtInit))
            *ppvObject = (IShellExtInit *) this;

        if  (IsEqualIID(riid, IID_IExtractIcon))
            *ppvObject = (IExtractIcon *) this;

        if  (IsEqualIID(riid, IID_IPersistFile) ||
                IsEqualIID(riid, IID_IPersist))
            *ppvObject = (IPersistFile *) this;

        if  (IsEqualIID(riid, IID_IShellPropSheetExt))
            *ppvObject = (IShellPropSheetExt *) this;
    }

    if  (*ppvObject)
        ((IUnknown *) *ppvObject) -> AddRef();

    _RPTF2(_CRT_WARN, "CICMUserInterace::QueryInterface(%lX) returns %lX\n",
        this, ppvObject);

    return  *ppvObject ? NOERROR : E_NOINTERFACE;
}

//  IShellExtInit member function- this interface needs only one

STDMETHODIMP    CICMUserInterface::Initialize(LPCITEMIDLIST pcidlFolder,
                                              LPDATAOBJECT pdoTarget,
                                              HKEY hKeyID) {

    _RPTF0(_CRT_WARN, "CICMUserInterface::Initialize\n");

    //  The target data object is an HDROP, or list of files from the shell.

    if  (m_lpdoTarget) {
        m_lpdoTarget -> Release();
        m_lpdoTarget = NULL;
    }

    if  (pdoTarget) {
        m_lpdoTarget = pdoTarget;
        m_lpdoTarget -> AddRef();
    }

    return  NOERROR;
}

//  IExtractIcon interface functions- for now, we'll default to providing a
//  default icon from our DLL.  We provide one icon for installed profiles,
//  and a second for uninstalled ones.

STDMETHODIMP    CICMUserInterface::GetIconLocation(UINT uFlags,
                                                   LPTSTR lpstrTarget,
                                                   UINT uccTarget,
                                                   int *piIndex,
                                                   UINT *puFlags) {

    *puFlags = (GIL_NOTFILENAME|GIL_DONTCACHE); // Make shell call our Extract function
                                                // And don't cache in the callee.

    return S_FALSE;
}

STDMETHODIMP    CICMUserInterface::Extract(LPCTSTR lpstrFile, UINT nIconIndex,
                            HICON *phiconLarge, HICON *phiconSmall,
                            UINT nIconSize) {

    *phiconSmall = *phiconLarge = LoadIcon(CGlobals::Instance(),
        MAKEINTRESOURCE(CGlobals::IsInstalled(m_csFile) ? DefaultIcon : UninstalledIcon));

    return NOERROR;
}

//  IPersistFile functions- there's only one worth implementing

STDMETHODIMP    CICMUserInterface::Load(LPCOLESTR lpwstrFileName,
                                        DWORD dwMode) {
    //  This interface is used to initialize the icon handler- it will
    //  receive the profile name, which we will save for later use.
    //  The CString assigment operator handles any encoding converions needed
    //  encoding conversions for us.

    m_csFile = lpwstrFileName;

    return  m_csFile.IsEmpty() ? E_OUTOFMEMORY : NO_ERROR;
}

//  IContextMenu functions-

STDMETHODIMP    CICMUserInterface::QueryContextMenu(HMENU hMenu, UINT indexMenu,
                                                    UINT idCmdFirst, UINT idCmdLast,
                                                    UINT uFlags) {

    //  Only CMF_NORMAL and CMF_EXPLORE case will be handled.
    //
    //  CMF_CANRENAME     -  This flag is set if the calling application supports
    //                      renaming of items. A context menu extension or drag-and-drop
    //                      handler should ignore this flag. A namespace extension should
    //                      add a rename item to the menu if applicable.
    //  CMF_DEFAULTONLY   -  This flag is set when the user is activating the default action,
    //                      typically by double-clicking. This flag provides a hint for the
    //                      context menu extension to add nothing if it does not modify the
    //                      default item in the menu. A context menu extension or drag-and-drop
    //                      handler should not add any menu items if this value is specified.
    //                      A namespace extension should add only the default item (if any).
    //  CMF_EXPLORE       -  This flag is set when Windows Explorer's tree window is present.
    //                      Context menu handlers should ignore this value.
    //  CMF_INCLUDESTATIC -  This flag is set when a static menu is being constructed.
    //                      Only the browser should use this flag. All other context menu
    //                      extensions should ignore this flag.
    //  CMF_NODEFAULT     -  This flag is set if no item in the menu should be the default item.
    //                      A context menu extension or drag-and-drop handler should ignore this
    //                      flag. A namespace extension should not set any of the menu items to
    //                      the default.
    //  CMF_NORMAL        -  Indicates normal operation. A context menu extension, namespace extension,
    //                      or drag-and-drop handler can add all menu items.
    //  CMF_NOVERBS       -  This flag is set for items displayed in the "Send To:" menu.
    //                      Context menu handlers should ignore this value.
    //  CMF_VERBSONLY     -  This flag is set if the context menu is for a shortcut object.
    //                      Context menu handlers should ignore this value.

    if (((uFlags & 0x000F) == CMF_NORMAL) || (uFlags & CMF_EXPLORE))
    {
        //
        //  Load the profile(s) in the list.
        //
        {
            FORMATETC       fmte = {CF_HDROP, (DVTARGETDEVICE FAR *)NULL,
                                    DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
            STGMEDIUM       stgm;
            HRESULT         hres = m_lpdoTarget ?
                                   m_lpdoTarget -> GetData(&fmte, &stgm) : E_FAIL;

            if  (!SUCCEEDED(hres))
                return  NOERROR;    //  Why bother reporting a failure, here?

            UINT    ucFiles = stgm.hGlobal ?
                DragQueryFile((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

            if  (!ucFiles) {
                ReleaseStgMedium(&stgm);
                return  NOERROR;    //  Shouldn't happen, but it's not important
            }
            else if (ucFiles == 1)
                m_bMultiSelection = FALSE;
            else
                m_bMultiSelection = TRUE;

            // Assume in installed context, but we will scan the selected item
            // is really installed everything.

            m_bInstalledContext = TRUE;

            TCHAR   acFile[_MAX_PATH];

            for (UINT u = 0; u < ucFiles; u++) {

                DragQueryFile((HDROP) stgm.hGlobal, u, acFile,
                    sizeof acFile/ sizeof acFile[0]);

                CString csFile = acFile;

                m_bInstalledContext = (m_bInstalledContext && CGlobals::IsInstalled(csFile));
            }

            ReleaseStgMedium(&stgm);
        }

        UINT idCmd = idCmdFirst;

        CString csInstallMenu, csAssociateMenu;

        //  If every profile(s) are already installed on this system,
        //  display "Uninstall Profile", otherwise display "Install Profile"

        csInstallMenu.Load(m_bInstalledContext ? UninstallProfileMenuString : InstallProfileMenuString);
        ::InsertMenu(hMenu,indexMenu,MF_STRING|MF_BYPOSITION,idCmd,csInstallMenu);

        //  Set "Install Profile" or "Uninstall Profile" as default.

        SetMenuDefaultItem(hMenu,indexMenu,TRUE);

        //  Increment Menu pos. and item id.

        indexMenu++; idCmd++;

        //  Add "Associate..." menu item

        csAssociateMenu.Load(AssociateMenuString);
        ::InsertMenu(hMenu,indexMenu++,MF_STRING|MF_BYPOSITION,idCmd++,csAssociateMenu);

        //  But if we have multi selection, disable "Associate..."

        if (m_bMultiSelection)
            ::EnableMenuItem(hMenu,(idCmd-1),MF_GRAYED);
        return (idCmd - idCmdFirst); // return number of menu inserted.
    }

    return NOERROR;
}

STDMETHODIMP    CICMUserInterface::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi) {

    //  If HIWORD(lpcmi->lpVerb) then we have been called programmatically and
    //  lpVerb us a command that should be invoked. Otherwise, the shell has
    //  called us, abd LOWORD(lpcmi->lpVerb) is the menu ID the user has selected.
    //  Actually, it's (menu ID - icmdFirst) from QueryContextMenu().

    if (!HIWORD((ULONG)(ULONG_PTR)lpcmi->lpVerb))  {

        FORMATETC       fmte = {CF_HDROP, (DVTARGETDEVICE FAR *)NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM       stgm;
        HRESULT         hres = m_lpdoTarget ?
            m_lpdoTarget -> GetData(&fmte, &stgm) : E_FAIL;

        if  (!SUCCEEDED(hres))
            return  NOERROR;    //  Why bother reporting a failure, here?

        UINT    ucFiles = stgm.hGlobal ?
            DragQueryFile((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

        if  (!ucFiles) {
            ReleaseStgMedium(&stgm);
            return  NOERROR;    //  Shouldn't happen, but it's not important
        }

        UINT idCmd = LOWORD(lpcmi->lpVerb);

        // Walk through every selected item to install/uninstall.

        for (UINT u = 0; u < ucFiles; u++) {

            TCHAR   acFile[_MAX_PATH];

            DragQueryFile((HDROP) stgm.hGlobal, u, acFile,
                sizeof acFile/ sizeof acFile[0]);

            switch (idCmd) {

                case    0: {   // Install/Uninstall was selected.

                    // during the installation or un-installation,
                    // change the cursor icon to IDC_APPSTARTING.

                    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL,IDC_APPSTARTING));

                    CProfile csProfile(acFile);

                    if (m_bInstalledContext) {

                        // All selected profile is already installed, then
                        // Uninstall every profile(s) are selected if installed.

                        if (csProfile.IsInstalled()) {
                            csProfile.Uninstall(FALSE); // never delete file from disk.
                        }
                    }
                    else {

                        // Some of selected profile is not installed, then
                        // Install every profile(s) are selected if not installed, yet.

                        if (!csProfile.IsInstalled()) {
                            csProfile.Install();
                        }
                    }

                    SetCursor(hCursorOld);

                    break;
                }

                case    1: {   // "Associate..." was selected.

                    CString csProfileName;

                    // Get profile "friendly" name.
                    {
                        CProfile csProfile(acFile);
                        csProfileName = csProfile.GetName();
                    } // de-constructer for csProfile should be here.

                    // Create PropertySheet with "Profile Information" and
                    // "Associate Device" pages

                    PROPSHEETHEADER psh;
                    HPROPSHEETPAGE  hpsp[2];

                    CProfileInformationPage *pcpip =                       
                        new CProfileInformationPage(CGlobals::Instance(), acFile);
                    CProfileAssociationPage *pcpap =
                        new CProfileAssociationPage(CGlobals::Instance(), acFile);
                    if( (pcpip!=NULL)&&(pcpap!=NULL) ) {    
                        hpsp[0] = pcpip->Handle();
                        hpsp[1] = pcpap->Handle();
    
                        ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    
                        // fill the property sheet structure.
    
                        psh.dwSize = sizeof(PROPSHEETHEADER);
                        psh.hInstance = CGlobals::Instance();
                        psh.hwndParent = NULL;
                        psh.nStartPage = 1; // Active "Associate Device" page.
                        psh.nPages = 2;
                        psh.phpage = hpsp;
                        psh.pszCaption = csProfileName;
    
                        PropertySheet(&psh);
    
                        delete pcpip; delete pcpap;
                        break;
                    } else {
                      if(pcpip) delete pcpip;
                      if(pcpap) delete pcpap;
                      return E_OUTOFMEMORY;
                    }
                }
            } // switch (idCmd)
        } // for (UINT u = 0; u < ucFiles; u++)

        ReleaseStgMedium(&stgm);

    } // if (!HIWORD(lpcmi->lpVerb))

    return NOERROR;
}

/* Supprisingly the code casts the unicode string to an
 * asciiz string and passes it. One assumes that nobody
 * actually interprets the string pointer as ascii on the
 * way to its destination where it is reinterpreted
 * as a pointer to a unicode string.
 */
STDMETHODIMP    CICMUserInterface::GetCommandString(UINT_PTR idCmd, UINT uFlags,
                                                    UINT FAR *reserved, LPSTR pszName,
                                                    UINT cchMax) {
    CString csReturnString;

    switch (idCmd) {
        case    0: {   // Install/Uninstall was selected.
          if(m_bMultiSelection) {
            csReturnString.Load(m_bInstalledContext ? UninstallMultiProfileContextMenuString : InstallMultiProfileContextMenuString);
          } else {
            csReturnString.Load(m_bInstalledContext ? UninstallProfileContextMenuString : InstallProfileContextMenuString);
          }
          lstrcpyn((LPTSTR)pszName, csReturnString, cchMax);
          break;
        }

        case    1: {   // Associate... was seleted.
          if (!m_bMultiSelection) {
            csReturnString.Load(AssociateContextMenuString);
            lstrcpyn((LPTSTR)pszName, csReturnString, cchMax);
          }
          break;
        }
    }

    return NOERROR;
}

//  IPropSheetExt functions- again, we only need to implement one of these
//  Since we now support two different interfaces, the actual implementation
//  is done in a private method germane to the desired interface.

STDMETHODIMP    CICMUserInterface::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                            LPARAM lParam) {
    _RPTF0(_CRT_WARN, "CICMUserInterface::AddPages\n");

    HRESULT hResult = NOERROR;
    
    switch  (m_utThis) {
        case    IsProfile: {
            hResult = AddProfileTab(lpfnAddPage, lParam);
            if (hResult == NOERROR) {
                hResult = AddAssociateTab(lpfnAddPage, lParam);
            }
            break;
        }

        case    IsMonitor: {
            hResult = AddMonitorTab(lpfnAddPage, lParam);
            break;
        }

        case    IsPrinter: {
            hResult = AddPrinterTab(lpfnAddPage, lParam);
            break;
        }

        case    IsScanner: {
            hResult = AddScannerTab(lpfnAddPage, lParam);
            break;
        }
    }

    return  hResult;
}

//  This member function handles the ICC profile information sheet.
//  In this case, the data object given via IShellExtInit::Initialize is
//  an HDROP (list of fully qualified file names).

HRESULT CICMUserInterface::AddProfileTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                        LPARAM lParam) {
    _RPTF0(_CRT_WARN, "CICMUserInterface::AddProfileTab\n");

    TCHAR   acFile[_MAX_PATH];

    //  Load the profile(s) in the list.

    if(m_lpdoTarget) {
        FORMATETC       fmte = {CF_HDROP, (DVTARGETDEVICE FAR *)NULL,
                                DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM       stgm;
        HRESULT         hres = m_lpdoTarget -> GetData(&fmte, &stgm);

        if  (!SUCCEEDED(hres) || !stgm.hGlobal)
            return  NOERROR;    //  Why bother reporting a failure, here?

        UINT    ucFiles = stgm.hGlobal ?
            DragQueryFile((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

        if  (ucFiles != 1) {
            ReleaseStgMedium(&stgm);
            return  NOERROR;
        }

        DragQueryFile((HDROP) stgm.hGlobal, 0, acFile,
            sizeof acFile/ sizeof acFile[0]);

        ReleaseStgMedium(&stgm);
    }

    //  Create the property sheet- it will get deleted if it is not in
    //  use when the shell tries to unload the extension

    CProfileInformationPage *pcpip =
        new CProfileInformationPage(CGlobals::Instance(), acFile);

    if  ((pcpip != NULL && pcpip -> Handle()) && !(*lpfnAddPage)(pcpip -> Handle(), lParam))
        DestroyPropertySheetPage(pcpip -> Handle());

    return  NOERROR;
}

//  This member function handles the associate device tab

HRESULT CICMUserInterface::AddAssociateTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                           LPARAM lParam) {

    _RPTF0(_CRT_WARN, "CICMUserInterface::AddAssociateTab\n");

    TCHAR   acFile[_MAX_PATH];

    //  Load the profile(s) in the list.

    if(m_lpdoTarget) {
        FORMATETC       fmte = {CF_HDROP, (DVTARGETDEVICE FAR *)NULL,
                                DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM       stgm;
        HRESULT         hres = m_lpdoTarget -> GetData(&fmte, &stgm);

        if  (!SUCCEEDED(hres) || !stgm.hGlobal)
            return  NOERROR;    //  Why bother reporting a failure, here?

        UINT    ucFiles = stgm.hGlobal ?
            DragQueryFile((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

        if  (ucFiles != 1) {
            ReleaseStgMedium(&stgm);
            return  NOERROR;
        }

        DragQueryFile((HDROP) stgm.hGlobal, 0, acFile,
            sizeof acFile/ sizeof acFile[0]);

        ReleaseStgMedium(&stgm);
    }

    //  Create the property sheet- it will get deleted if it is not in
    //  use when the shell tries to unload the extension

    CProfileAssociationPage *pcpap =
        new CProfileAssociationPage(CGlobals::Instance(), acFile);

    if  ((pcpap != NULL && pcpap -> Handle()) && !(*lpfnAddPage)(pcpap -> Handle(), lParam))
        DestroyPropertySheetPage(pcpap -> Handle());

    return  NOERROR;
}

//  This member function handles the monitor color management tab
//  In this case, no data object is given.

//  Private monitor enumeration function

HRESULT CICMUserInterface::AddMonitorTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                         LPARAM lParam) {

    //  Create the property sheet- it will get deleted if it is not in
    //  use when the shell tries to unload the extension

    CString csMonitorDevice;
    CString csMonitorFriendlyName;

    STGMEDIUM stgm;
    STGMEDIUM *pstgm = (STGMEDIUM *) NULL;

    if (m_lpdoTarget) {

        FORMATETC fmte = { (CLIPFORMAT)RegisterClipboardFormat(_TEXT("Display Device")),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        // Get device name from IDataObject.

        HRESULT   hres = m_lpdoTarget -> GetData(&fmte, &stgm);

        if  (!SUCCEEDED(hres) || !stgm.hGlobal) {
            return  NOERROR;    //  Why bother reporting a failure, here?
        }

        // The storage contains Display device path (\\.\DisplayX) in UNICODE.

        pstgm = &stgm;
        LPCWSTR lpDeviceName = (LPCWSTR) GlobalLock(pstgm->hGlobal);
        CString csMonitorDevicePath = lpDeviceName;

        // Query the device id, friendly name and other on the display device.

        DISPLAY_DEVICE ddPriv;

        ddPriv.cb = sizeof(ddPriv);

        if (!EnumDisplayDevices((LPCTSTR)csMonitorDevicePath, 0, &ddPriv, 0))
        {
            return  NOERROR;    //  Why bother reporting a failure, here?
        }

        #if HIDEYUKN_DBG
            MessageBox(NULL,csMonitorDevicePath,TEXT(""),MB_OK);
            MessageBox(NULL,(LPCTSTR)ddPriv.DeviceID,TEXT(""),MB_OK);
            MessageBox(NULL,(LPCTSTR)ddPriv.DeviceString,TEXT(""),MB_OK);
        #endif

        // Use deviceId (PnP Id) as device name, and set friendly name

        csMonitorDevice       = (LPTSTR)(ddPriv.DeviceID);
        csMonitorFriendlyName = (LPTSTR)(ddPriv.DeviceString);
    }
    else
    {
        // if we don't have IDataObject, enumerate monitor,
        // then use 1st entry.

        CMonitorList    cml;
        cml.Enumerate();
        _ASSERTE(cml.Count());  // At least, we should have one Monitor.
        csMonitorDevice = csMonitorFriendlyName = cml.DeviceName(0);
    }

    CMonitorProfileManagement *pcmpm =
        new CMonitorProfileManagement(csMonitorDevice,
                                      csMonitorFriendlyName,
                                      CGlobals::Instance());


    if  ((pcmpm != NULL) && !(*lpfnAddPage)(pcmpm -> Handle(), lParam))
        DestroyPropertySheetPage(pcmpm -> Handle());

    if (pstgm) {
        GlobalUnlock(pstgm->hGlobal);
        ReleaseStgMedium(pstgm);
    }

    return  NOERROR;
}

//  Private scanner enumeration function

HRESULT CICMUserInterface::AddScannerTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                         LPARAM lParam) {

    //  Create the property sheet- it will get deleted if it is not in
    //  use when the shell tries to unload the extension

    CString csScannerDevice;

    STGMEDIUM stgm;
    STGMEDIUM *pstgm = (STGMEDIUM *) NULL;

    if (m_lpdoTarget) {
        FORMATETC fmte = { (CLIPFORMAT)RegisterClipboardFormat(_TEXT("STIDeviceName")),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        // Get device name from IDataObject.

        HRESULT   hres = m_lpdoTarget -> GetData(&fmte, &stgm);

        if  (!SUCCEEDED(hres) || !stgm.hGlobal) {
            return  NOERROR;    //  Why bother reporting a failure, here?
        }

        // The storage contains Scanner in UNICODE string.

        pstgm = &stgm;
        LPCWSTR lpDeviceName = (LPCWSTR) GlobalLock(pstgm->hGlobal);
        csScannerDevice = lpDeviceName;

        #if HIDEYUKN_DBG
            MessageBox(NULL,csScannerDevice,TEXT(""),MB_OK);
        #endif

    } else {

        // if we don't have IDataObject, enumerate monitor,
        // then use 1st entry.

        CScannerList csl;
        csl.Enumerate();
        _ASSERTE(csl.Count());
        csScannerDevice = csl.DeviceName(0);
    }

    CScannerProfileManagement *pcspm =
        new CScannerProfileManagement(csScannerDevice, CGlobals::Instance());

    if  ((pcspm != NULL) && !(*lpfnAddPage)(pcspm -> Handle(), lParam))
        DestroyPropertySheetPage(pcspm -> Handle());

    if (pstgm) {
        GlobalUnlock(pstgm->hGlobal);
        ReleaseStgMedium(pstgm);
    }

    return  NOERROR;
}

//  The following is a helper function- it takes a Shell ID List array,
//  representing a printer in a printers folder, and a CString.  It
//  initializes the CString with the correct name of the printer.

static void RetrievePrinterName(LPIDA lpida, CString& csTarget) {

    //  Extract the container (Printers Folder) and target (Printer)
    //  IDs from the array.

    LPCITEMIDLIST pciilContainer =
        (LPCITEMIDLIST)((LPBYTE) lpida + lpida -> aoffset[0]);

    LPCITEMIDLIST pciilTarget =
        (LPCITEMIDLIST)((LPBYTE) lpida + lpida -> aoffset[1]);

    if  (!pciilContainer || !pciilTarget)
        return;

    //  Get a pointer to the printers folder.

    LPSHELLFOLDER   psfDesktop, psfPrinterFolder;

    if  (FAILED(SHGetDesktopFolder(&psfDesktop)))
        return;

    if  (FAILED(psfDesktop -> BindToObject(pciilContainer, NULL,
            IID_IShellFolder, (void **) &psfPrinterFolder))) {
        psfDesktop -> Release();
        return;
    }

    //  Retrieve the printer's display name

    STRRET  strret;

    if  (FAILED(psfPrinterFolder ->
            GetDisplayNameOf(pciilTarget, SHGDN_FORPARSING, &strret))) {
        psfPrinterFolder -> Release();
        psfDesktop -> Release();
        return;
    }

    //  Copy the display name- the CString class now handles any encoding
    //  issues

    switch  (strret.uType) {

        case    STRRET_WSTR:

            //  This is a Unicode string which was IMalloc'd

            csTarget = strret.pOleStr;

            IMalloc *pim;

            if  (SUCCEEDED(CoGetMalloc(1, &pim))) {
                pim -> Free(strret.pOleStr);
                pim -> Release();
            }

            break;

        case    STRRET_CSTR:

            //  This is an ANSI string in the buffer

            csTarget = strret.cStr;
            break;

        case    STRRET_OFFSET:

            //  This is an ANSI string at the given offset into the SHITEMID
            //  which pciilTarget points to.

            csTarget = (LPCSTR) pciilTarget + strret.uOffset;

    }
    psfPrinterFolder -> Release();
    psfDesktop -> Release();
}

//  Private member function for handling the printer profile manamgment tab.

HRESULT CICMUserInterface::AddPrinterTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                         LPARAM lParam) {

    //  The list is formatted as a Shell IDList Array

    FORMATETC       fmte = { (CLIPFORMAT)RegisterClipboardFormat(_TEXT("Shell IDList Array")),
                             (DVTARGETDEVICE FAR *) NULL,
                             DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM       stgm;
    HRESULT         hres = m_lpdoTarget ?
        m_lpdoTarget -> GetData(&fmte, &stgm) : 0;

    if  (!SUCCEEDED(hres) || !stgm.hGlobal)
        return  NOERROR;    //  Why bother reporting a failure, here?

    CString csPrinter;

    RetrievePrinterName((LPIDA) stgm.hGlobal, csPrinter);

    #if HIDEYUKN_DBG
        MessageBox(NULL,csPrinter,TEXT(""),MB_OK);
    #endif

    //  If this is not a color printer, forget it...


    if  (!CGlobals::ThisIsAColorPrinter(csPrinter)) {
        ReleaseStgMedium(&stgm);
        return  NOERROR;
    }

    //  Create the property sheet- it will get deleted if it is not in use when
    //  the shell tries to unload the extension


    CPrinterProfileManagement *pcppm =
            new CPrinterProfileManagement(csPrinter, CGlobals::Instance());

    ReleaseStgMedium(&stgm);

    if  (!pcppm)
        return  E_OUTOFMEMORY;

    if  (!(*lpfnAddPage)(pcppm -> Handle(), lParam))
        DestroyPropertySheetPage(pcppm -> Handle());

    return  NOERROR;
}

PSTR
GetFilenameFromPath(
    PSTR pPathName
    )
{
    DWORD dwLen;                    // length of pathname

    dwLen = lstrlenA(pPathName);

    //
    // Go to the end of the pathname, and start going backwards till
    // you reach the beginning or a backslash
    //

    pPathName += dwLen;

    while (dwLen-- && --pPathName)
    {
        if (*pPathName == '\\')
        {
            pPathName++;
            break;
        }
    }

    //
    // if *pPathName is zero, then we had a string that ends in a backslash
    //

    return *pPathName ? pPathName : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\shellext.h ===
/******************************************************************************

  Source File:  Shell Extension Classes.H

  This file defines the Shell extension classes.  Since the ICM UI is a shell
  extension, these are essential.  Rather than slavishly including sample code,
  this has been written as much as possible from scratch.

  If you're not familiar with OLE, then this is going to be a bit difficult
  going.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  10-28-96 A-RobKj (Pretty Penny Enterprises) began coding
  12-03-96 A-RobKj moved the CGlobals class to the pre-comp header file.
  01-07-97 KjelgaardR@acm.org   Stubbed IContextMenu interface for profile
            management in favor of shell association which uses a RunDLL
            Entry point- this allows invocation via Enter, and double-click

******************************************************************************/

// The class ID of this Shell extension is taken from the one used on Win95.

//  This was a deliberate decision, to ease the upgrade process.
//
// class id:  dbce2480-c732-101b-be72-ba78e9ad5b27
//
                                  
DEFINE_GUID(CLSID_ICM, 0xDBCE2480L, 0xC732, 0x101B, 0xBE, 0x72, 0xBA, 0x78, 
            0xE9, 0xAD, 0x5B, 0x27);

//  This class ID is for the printer profile management UI.  It is implemented
//  within the same module, for now, but having a separate GUID makes it
//  easier to implement separately later, if so desired.  It also simplifies
//  implementation.

//  Class ID:  675f097e-4c4d-11d0-b6c1-0800091aa605

DEFINE_GUID(CLSID_PRINTERUI, 0x675F097EL, 0x4C4D, 0x11D0, 0xB6, 0xC1, 0x08,
             0x00, 0x09, 0x1A, 0xA6, 0x05);

//  This class ID is used (at least temporarily) for the display profile
//  management UI.  If I wind up not needing it, I will convert it to a
//  different class (such as scanners or cameras)

//  Class ID: 5db2625a-54df-11d0-b6c4-0800091aa605

DEFINE_GUID(CLSID_MONITORUI, 0x5db2625a, 0x54df, 0x11d0, 0xb6, 0xc4, 0x08, 
            0x00, 0x09, 0x1a, 0xa6, 0x05);

//  This class ID is used (at least temporarily) for the scanner/camera profile
//  management UI.

//  Class ID: 176d6597-26d3-11d1-b350-080036a75b03

DEFINE_GUID(CLSID_SCANNERUI, 0x176d6597, 0x26d3, 0x11d1, 0xb3, 0x50, 0x08,
            0x00, 0x36, 0xa7, 0x5b, 0x03);

typedef enum    {IsProfile, IsPrinter, IsScanner, IsMonitor} UITYPE;

//  First of all, we're going to need a class factory.  The shell uses this
//  factory to create instances of the objects which implement the interfaces
//  it needs.

class CIcmUiFactory : public IClassFactory
{
    ULONG   m_ulcReferences;
    UITYPE  m_utThis;

public:
    CIcmUiFactory(REFCLSID rclsid);
    ~CIcmUiFactory() { CGlobals::Detach(); }

    //IUnknown interface
    STDMETHODIMP            QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG)    AddRef() { return ++m_ulcReferences; }
    STDMETHODIMP_(ULONG)    Release() {
        if  (--m_ulcReferences) 
            return  m_ulcReferences;

        delete  this;
        return  0L;
    }

    //IClassFactory interface
    STDMETHODIMP    CreateInstance(LPUNKNOWN punk, REFIID riid, 
                                   void **ppvObject);
    STDMETHODIMP    LockServer(BOOL) { return NOERROR; }

    static SCODE    KeyToTheFactory(REFCLSID rclsid, REFIID riid, 
                                    void **ppvObject);
};

//  This class implements the entire extension- it includes a context menu
//  handler, and Icon handler, and a property sheet extension.

class CICMUserInterface : public IContextMenu, IShellExtInit, IExtractIcon, 
                                    IPersistFile, IShellPropSheetExt
{
    ULONG           m_ulcReferences;
    LPDATAOBJECT    m_lpdoTarget;
    CString         m_csFile;         //  Profile for icon extraction
    //check this - m_acWork doesn't appear to be referenced anywhere.
    TCHAR           m_acWork[80];     //  A little work buffer
    UITYPE          m_utThis;
    BOOL            m_bInstalledContext, // 'True' when every selected file(s) are installed
                    m_bMultiSelection;

    HRESULT         AddPrinterTab(LPFNADDPROPSHEETPAGE lpfnAddPage, 
                                  LPARAM lParam);

    HRESULT         AddAssociateTab(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                    LPARAM lParam);

    HRESULT         AddProfileTab(LPFNADDPROPSHEETPAGE lpfnAddPage, 
                                  LPARAM lParam);

    HRESULT         AddScannerTab(LPFNADDPROPSHEETPAGE lpfnAddPage, 
                                  LPARAM lParam);

    HRESULT         AddMonitorTab(LPFNADDPROPSHEETPAGE lpfnAddPage, 
                                  LPARAM lParam);

public:
    CICMUserInterface(UITYPE utThis);

    ~CICMUserInterface() { 

        if  (m_lpdoTarget)
            m_lpdoTarget -> Release();
        CGlobals::Detach();
    }

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef() { return ++m_ulcReferences; }
    STDMETHODIMP_(ULONG)    Release() {
        if  (--m_ulcReferences) 
            return  m_ulcReferences;
        
        delete  this;
        return  0L;
    }

    //  IContextMenu methods
    STDMETHODIMP    QueryContextMenu(HMENU hMenu, UINT indexMenu, 
                                     UINT idCmdFirst, UINT idCmdLast, 
                                     UINT uFlags);
   
    STDMETHODIMP    InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP    GetCommandString(UINT_PTR idCmd, UINT uFlags, 
                                     UINT FAR *reserved, LPSTR pszName, 
                                     UINT cchMax);

    //  IShellExtInit methods
    STDMETHODIMP    Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                               HKEY hKeyID);

    //  IExtractIcon methods
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax,
                                    int *piIndex, UINT *pwFlags);

    STDMETHODIMP    Extract(LPCTSTR pszFile, UINT nIconIndex, 
                            HICON *phiconLarge, HICON *phiconSmall, 
                            UINT nIconSize);

    //  IPersistFile methods- note that (as the OLE documentation says) only 
    //  Load ever gets used.  GetClassID is from IPersist, from which
    //  IPersistFile is derived.  We fail everything we don't expect to see
    //  called.

    STDMETHODIMP    GetClassID(LPCLSID lpClassID) { return E_FAIL; }

    STDMETHODIMP    IsDirty() { return S_FALSE; }

    STDMETHODIMP    Load(LPCOLESTR lpszFileName, DWORD grfMode);

    STDMETHODIMP    Save(LPCOLESTR lpszFileName, BOOL fRemember) {
        return  E_FAIL;
    }

    STDMETHODIMP    SaveCompleted(LPCOLESTR lpszFileName) { return E_FAIL; }

    STDMETHODIMP    GetCurFile(LPOLESTR FAR* lplpszFileName) {
        return  E_FAIL;
    }

    //  IShellPropSheetExt methods
    STDMETHODIMP    AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    
    STDMETHODIMP    ReplacePage(UINT uPageID, 
                                LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                LPARAM lParam) { return E_FAIL; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\stringar.cpp ===
/******************************************************************************

  Header File:  String Array.CPP

  Implements the String Array class- see the related header for the declaration
  of this class.

  This class will do arrays in chunks- if the total array exceeds the size of
  one chunk, we chain more instances together, then use recursion to do the
  work.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version
  12-04-96  a-robkj@microsoft.com   Added LoadString and IsEmpty to CString
                                    Also fixed bug in Remove where
                                    u > ChunkSize (wasn't exiting)
  12-11-96  a-robkj@microsoft.com   Let CString do ANSI/UNICODE conversions
                                    automagically to ease some API issues
  01-07-97  KjelgaardR@acm.org  Fixed CStringArray::Empty and CUintArray::Empty
            to NULL pointer to next chunk after deleting it.  Led to GP faults
            if we needed to use the chunk again.

******************************************************************************/

#include    "ICMUI.H"

//  Convert a UNICODE string to a new ANSI buffer

void    CString::Flip(LPCWSTR lpstrIn, LPSTR& lpstrOut) {
    if  (!lpstrIn) {
        lpstrOut = NULL;
        return;
    }
    int iLength = WideCharToMultiByte(CP_ACP, 0, lpstrIn, -1, NULL, 0, NULL,
        NULL);

    if  (!iLength) {
        lpstrOut = NULL;
        return;
    }

    lpstrOut = (LPSTR) malloc(++iLength);
    if(lpstrOut) {
        WideCharToMultiByte(CP_ACP, 0, lpstrIn, -1, lpstrOut, iLength, NULL,
            NULL);
    }
}

//  Convert an ANSI string to a new UNICODE buffer

void    CString::Flip(LPCSTR lpstrIn, LPWSTR& lpstrOut) {
    if  (!lpstrIn) {
        lpstrOut = NULL;
        return;
    }

    int iLength = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrIn, -1,
        NULL, 0);

    if  (!iLength) {
        lpstrOut = NULL;
        return;
    }

    lpstrOut = (LPWSTR) malloc(++iLength * sizeof (WCHAR));
    if(lpstrOut) {
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrIn, -1, lpstrOut,
            iLength);
    }
}

//  Empty the string, and free all memory.

void    CString::Empty() {
    if  (m_acContents)
        free(m_acContents);

    if  (m_acConverted)
        free(m_acConverted);

    m_acContents = NULL;
    m_acConverted = NULL;
    m_bConverted = FALSE;
}

//  Compare with other CString

BOOL    CString::IsEqualString(CString& csRef1)
{
    if (IsEmpty() || csRef1.IsEmpty())
        return (FALSE);

    return (_tcsicmp(m_acContents,(LPTSTR)csRef1) == 0);
}

CString::CString() {
    m_acContents = NULL;
    m_acConverted = NULL;
    m_bConverted = FALSE;
}

CString::CString(const CString& csRef) {
    m_acContents = csRef.m_acContents ? _tcsdup(csRef.m_acContents) : NULL;
    m_acConverted = NULL;
    m_bConverted = FALSE;
}

CString::CString(LPCTSTR lpstrRef) {
    m_acContents = lpstrRef ? _tcsdup(lpstrRef) : NULL;
    m_acConverted = NULL;
    m_bConverted = FALSE;
}

CString::CString(LPCOSTR lpstrRef) {
    m_acConverted = NULL;
    m_bConverted = FALSE;

    if  (!lpstrRef) {
        m_acContents = NULL;
        return;
    }

    Flip(lpstrRef, m_acContents);
}

//  Class destructor

CString::~CString() {
    Empty();
}

//  Report string in non-native encoding

CString::operator LPCOSTR() {
    if  (!m_bConverted) {
        Flip(m_acContents, m_acConverted);
        m_bConverted = TRUE;
    }
    return  m_acConverted;
}

const CString& CString::operator =(const CString& csSrc) {
    Empty();
    m_acContents = csSrc.m_acContents ? _tcsdup(csSrc.m_acContents) : NULL;
    return  *this;
}

const CString& CString::operator =(LPCTSTR lpstrSrc) {
    Empty();
    m_acContents = lpstrSrc ? _tcsdup(lpstrSrc) : NULL;
    return  *this;
}

const CString& CString::operator =(LPCOSTR lpstrSrc) {
    Empty();
    Flip(lpstrSrc, m_acContents);
    return  *this;
}

CString CString::NameOnly() const {
    TCHAR   acName[_MAX_FNAME];

    if  (!m_acContents)
        return  *this;

    _tsplitpath(m_acContents, NULL, NULL, acName, NULL);

    return  acName;
}

CString CString::NameAndExtension() const {
    TCHAR   acName[_MAX_FNAME], acExtension[_MAX_EXT];

    if  (!m_acContents)
        return  *this;

    _tsplitpath(m_acContents, NULL, NULL, acName, acExtension);

    lstrcat(acName, acExtension);

    return  acName;
}

void    CString::Load(int id, HINSTANCE hi) {

    if  (!hi)
        hi = CGlobals::Instance();

    TCHAR   acWork[MAX_PATH];
    if(LoadString(hi, id, acWork, MAX_PATH) > 0)
        *this = acWork;
    else
        *this = TEXT("");
}

//  03-20-1997  Bob_Kjelgaard@Prodigy.Net   Part of RAID 22289.
//  Add a method for loading text from a windows handle

void    CString::Load(HWND hwnd) {
    Empty();

    int iccNeeded = GetWindowTextLength(hwnd);
    if  (!iccNeeded)
        return;
    m_acContents = (LPTSTR) malloc(++iccNeeded * sizeof (TCHAR));
    if(m_acContents) {
      GetWindowText(hwnd, m_acContents, iccNeeded);
    }
}

void    CString::LoadAndFormat(int id, HINSTANCE hiWhere, BOOL bSystemMessage,
                               DWORD dwNumMsg, va_list *argList) {
    Empty();

    TCHAR   acWork[1024];
    CString csTemplate;
    LPTSTR  lpSource;
    DWORD   dwFlags;

    if (bSystemMessage) {
        lpSource = NULL;
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;
    } else {
        csTemplate.Load(id);
        lpSource = csTemplate;
        dwFlags = FORMAT_MESSAGE_FROM_STRING;
        id = 0;
    }

    if (FormatMessage(dwFlags,lpSource, id, 0, acWork, 1024, argList)) {
        *this = acWork;
    }
}

CString operator +(const CString& csRef, LPCTSTR lpstrRef) {
    if  (!lpstrRef || !*lpstrRef)
        return  csRef;

    if  (csRef.IsEmpty())
        return  lpstrRef;

    CString csReturn;

    csReturn.m_acContents = (LPTSTR) malloc((1 + lstrlen(csRef.m_acContents) +
        lstrlen(lpstrRef)) * sizeof(TCHAR));
    if(csReturn.m_acContents) {
        lstrcat(lstrcpy(csReturn.m_acContents, csRef.m_acContents), lpstrRef);
    }

    return  csReturn;
}

//  CStringArray classes- these manage an array of strings,
//  but the methods are geared to list-style management.

//  Borrow first element from next chunk

LPCTSTR CStringArray::Borrow() {

    LPCTSTR lpstrReturn = m_aStore[0];

    memcpy((LPSTR) m_aStore, (LPSTR) (m_aStore + 1),
        (ChunkSize() - 1) * sizeof m_aStore[0]);

    if  (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcsaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = (LPCTSTR) NULL;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcsaNext) {
        delete  m_pcsaNext;
        m_pcsaNext = NULL;
    }

    return  lpstrReturn;
}

//  ctor

CStringArray::CStringArray() {
    m_ucUsed = 0;
    m_pcsaNext = NULL;
}

//  dtor

CStringArray::~CStringArray() {
    Empty();
}

//  Empty the list/array

void    CStringArray::Empty() {

    if  (!m_ucUsed) return;

    if  (m_pcsaNext) {
        delete  m_pcsaNext;
        m_pcsaNext = NULL;
    }
    m_ucUsed = 0;
}

unsigned    CStringArray::Map(LPCTSTR lpstrRef) {

    for (unsigned u = 0; u < m_ucUsed; u++)
        if  (!lstrcmpi(operator[](u), lpstrRef))
            break;

    return  u;
}

//  Add an item

void    CStringArray::Add(LPCTSTR lpstrNew) {

    if  (m_ucUsed < ChunkSize()) {
        m_aStore[m_ucUsed++] = lpstrNew;
        return;
    }

    //  Not enough space!  Add another record, if there isn't one

    if  (!m_pcsaNext)
        m_pcsaNext = new CStringArray;

    //  Add the string to the next array (recursive call!)

    if  (m_pcsaNext) {
        m_pcsaNext -> Add(lpstrNew);
        m_ucUsed++;
    }
}

//  define an indexing operator

CString&    CStringArray::operator [](unsigned u) const {
    _ASSERTE(u < m_ucUsed);

    return  u < ChunkSize() ?
        (CString&)m_aStore[u] : m_pcsaNext -> operator[](u - ChunkSize());
}

//  Remove the string at some index, shifting the rest down one slot

void    CStringArray::Remove(unsigned u) {

    if  (u > m_ucUsed)
        return;

    if  (u >= ChunkSize()) {
        m_pcsaNext -> Remove(u - ChunkSize());
        return;
    }

    memmove((LPSTR) (m_aStore + u), (LPSTR) (m_aStore + u + 1),
        (ChunkSize() - (u + 1)) * sizeof m_aStore[0]);

    if  (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcsaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = (LPCTSTR) NULL;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcsaNext) {
        delete  m_pcsaNext;
        m_pcsaNext = NULL;
    }
}

//  CUintArray class- this manages an array/list of unsigned integers
//  The implementation is quite similar to the CStringArray's.  Why
//  bother to do it different, after all?

unsigned    CUintArray::Borrow() {

    unsigned    uReturn = m_aStore[0];

    memcpy((LPSTR) m_aStore, (LPSTR) (m_aStore + 1),
        (ChunkSize() - 1) * sizeof m_aStore[0]);

    if  (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcuaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = 0;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcuaNext) {
        delete  m_pcuaNext;
        m_pcuaNext = NULL;
    }

    return  uReturn;
}

CUintArray::CUintArray() {
    m_ucUsed = 0;
    m_pcuaNext = NULL;
}

CUintArray::~CUintArray() {
    Empty();
}

void    CUintArray::Empty() {

    if  (!m_ucUsed) return;

    if  (m_pcuaNext) {
        delete  m_pcuaNext;
        m_pcuaNext = NULL;
    }
    m_ucUsed = 0;
}

//  Add an item
void    CUintArray::Add(unsigned uNew) {

    if  (m_ucUsed < ChunkSize()) {
        m_aStore[m_ucUsed++] = uNew;
        return;
    }

    //  Not enough space!  Add another record, if there isn't one

    if  (!m_pcuaNext)
        m_pcuaNext = new CUintArray;

    //  Add the item to the next array (recursive call!)

    if  (m_pcuaNext) {
        m_pcuaNext -> Add(uNew);
        m_ucUsed++;
    }
}

unsigned    CUintArray::operator [](unsigned u) const {
    return  u < m_ucUsed ? u < ChunkSize() ?
        m_aStore[u] : m_pcuaNext -> operator[](u - ChunkSize()) : 0;
}

void    CUintArray::Remove(unsigned u) {

    if  (u > m_ucUsed)
        return;

    if  (u >= ChunkSize()) {
        m_pcuaNext -> Remove(u - ChunkSize());
        return;
    }

    memmove((LPSTR) (m_aStore + u), (LPSTR) (m_aStore + u + 1),
        (ChunkSize() - (u + 1)) * sizeof m_aStore[0]);

    if  (m_ucUsed > ChunkSize())
        m_aStore[ChunkSize() - 1] = m_pcuaNext -> Borrow();
    else
        m_aStore[ChunkSize() - 1] = 0;

    m_ucUsed--;

    if  (m_ucUsed <= ChunkSize() && m_pcuaNext) {
        delete  m_pcuaNext;
        m_pcuaNext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmupg\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmupg\icmupg.h ===
/****************************Module*Header******************************\
* Module Name: ICMUPG.H
*
* Module Descripton: Single header file that will be precompiled. This
*   should be included first in all the source files.
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  14 March 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#ifndef _ICMUPG_H_
#define _ICMUPG_H_

#include "stdlib.h"
#include "windows.h"
#include "windowsx.h"
#include "winspool.h"

#include "icm.h"
#include "debug.h"

#endif      // ifndef _ICMUPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\sources.inc ===
!IF 0

Build Control File for the ICM 2.0 User Interface DLL

Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved

A Pretty Penny Enterprises Production

Change History:
Unknown creation date, et al.
01-08-97    KjelgaardR@acm.org  Had to add Gdi32 library...

        ..\ProfProp.CPP \
        ..\PropDlg.CPP  \

!ENDIF

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

UMTYPE=windows
TARGETNAME=icmui
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)
TARGETTYPE=DYNLINK
DLLBASE=@$(COFFBASE_TXT_FILE),icmui

INCLUDES=..\.;$(ICMROOT)\inc;$(ICMROOT)\mscms;$(INCLUDES);$(SHELL_INC_PATH)

DLLENTRY=_DllMainCRTStartup

NTKEEPRESOURCETMPFILES=1

USE_MSVCRT=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0500

SOURCES=..\Dialog.CPP   \
        ..\Profile.CPP  \
        ..\ProfInfo.CPP \
        ..\ProfAssoc.CPP\
        ..\PropPage.CPP \
        ..\ShellExt.CPP \
        ..\StringAr.CPP \
        ..\DevProp.CPP  \
        ..\AppUi.CPP    \
        ..\IcmUi.rc

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib          \
           $(SDK_LIB_PATH)\shell32.lib           \
           $(SDK_LIB_PATH)\winspool.lib          \
           $(ICMROOT)\mscms\winnt\$(O)\mscms.lib \
           $(SDK_LIB_PATH)\uuid.lib              \
           $(WINDOWS_LIB_PATH)\user32p.lib       \
           $(SDK_LIB_PATH)\advapi32.lib          \
           $(SDK_LIB_PATH)\ole32.lib             \
           $(SDK_LIB_PATH)\gdi32.lib             \
           $(SHELL_LIB_PATH)\shfusion.lib        \
           $(SDK_LIB_PATH)\shlwapi.lib
           
# some obscure locally defined symbol problem in shfusion.lib
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4217

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\IcmUi.H
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=..\$(TARGETNAME).def

#
# Fusionized
#
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=icmui.manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmui\stringar.h ===
/******************************************************************************

  Header File:  String Array.H

  This provides a relatively simple C++ class for manipulating an array of
  character strings.  In this project, we use it for lists of associated
  devices, or potential associated devices, etc.  I'm not currently sorting
  this list.

  The class declaration may look a bit bizarre.  Since most of the arrays
  will in fact be rather small, I picked a decent size.  When they get bigger,
  I'll chain them internally and use recursion to perform any needed function.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:

  11-01-96  a-robkj@microsoft.com- original version
  12-04-96  a-robkj@microsoft.com   Added LoadString and IsEmpty to CString

******************************************************************************/

#if !defined(STRING_ARRAY)

#if defined(UNICODE)

#define LPCOSTR LPCSTR
#define LPOSTR  LPSTR
#define OCHAR   CHAR

#if !defined(_UNICODE)
#define _UNICODE
#endif

#else

#define LPCOSTR LPCWSTR
#define LPOSTR  LPWSTR
#define OCHAR   WCHAR

#endif
#include    <tchar.h>

#define STRING_ARRAY

class CString {
    LPTSTR  m_acContents;
    LPOSTR  m_acConverted;
    BOOL    m_bConverted;
    void    Flip(LPCWSTR lpstrIn, LPSTR& lpstrOut);
    void    Flip(LPCSTR lpstrIn, LPWSTR& lpstrOut);

public:
    CString();
    CString(const CString& csRef);
    CString(LPCTSTR lpstrRef);
    CString(LPCOSTR lpstrRef);

    ~CString();

    BOOL    IsEmpty() const { return !m_acContents || !m_acContents[0]; }
    void    Empty();

    operator LPCTSTR() const { return m_acContents; }
    operator LPTSTR() const { return m_acContents; }
    operator LPARAM() const { return (LPARAM) m_acContents; }
    operator LPCOSTR();
    const CString& operator = (const CString& csSrc);
    const CString& operator = (LPCTSTR lpstrSrc);
    const CString& operator = (LPCOSTR lpstrSrc);
    CString NameOnly() const;
    CString NameAndExtension() const;
    void    Load(int id, HINSTANCE hiWhere = NULL);
    void    Load(HWND hwnd);
    void    LoadAndFormat(int id,
                          HINSTANCE hiWhere,
                          BOOL bSystemMessage,
                          DWORD dwNumMsg,
                          va_list *argList);
    BOOL    IsEqualString(CString& csRef1);

    friend CString operator + (const CString& csRef1, LPCTSTR lpstrRef2);
};

class CStringArray {
    CString         m_aStore[20];
    CStringArray    *m_pcsaNext;
    unsigned        m_ucUsed;

    const unsigned ChunkSize() const { 
        return sizeof m_aStore / sizeof m_aStore[0];
    }

    LPCTSTR Borrow();

public:

    CStringArray();
    ~CStringArray();

    unsigned    Count() const { return m_ucUsed; }

    //  Add an item
    void        Add(LPCTSTR lpstrNew);

    CString&    operator [](unsigned u) const;

    void        Remove(unsigned u);
    void        Empty();

    //  Return index of string in array- array count if not present

    unsigned    Map(LPCTSTR lpstrRef);
};

class CUintArray {
    unsigned        m_aStore[20];
    CUintArray      *m_pcuaNext;
    unsigned        m_ucUsed;

    const unsigned ChunkSize() const { 
        return sizeof m_aStore / sizeof m_aStore[0];
    }

    unsigned    Borrow();

public:

    CUintArray();
    ~CUintArray();

    unsigned    Count() const { return m_ucUsed; }

    //  Add an item
    void    Add(unsigned u);

    unsigned    operator [](unsigned u) const;

    void    Remove(unsigned u);
    void    Empty();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\icmupg\icmupg.c ===
/****************************Module*Header******************************\
* Module Name: ICMUPG.C
*
* Module Descripton: This file has code that upgrades Win9x ICM to
*                    Memphis and NT 5.0
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  14 November 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "icmupg.h"
#include "msg.h"
#include <setupapi.h>
#include <stdio.h>


//#define ICM_MIG_DEBUG

#ifdef UNICODE
error.
This dll needs to be built with ANSI, not UNICODE because it must run on
Win95, Win98 and on Windows 2000
#endif


//
// Local typedefs
//

typedef struct tagMANUMODELIDS {
    DWORD dwManuID;
    DWORD dwModelID;
} MANUMODELIDS, *PMANUMODELIDS;

typedef struct tagREGDATA {
    DWORD dwRefCount;
    DWORD dwManuID;
    DWORD dwModelID;
} REGDATA, *PREGDATA;

typedef BOOL (WINAPI *PFNINSTALLCOLORPROFILEA)(PSTR, PSTR);
typedef BOOL (WINAPI *PFNINSTALLCOLORPROFILE)(LPCTSTR, LPCTSTR);
typedef BOOL (WINAPI *PFNENUMCOLORPROFILES)(PCTSTR, PENUMTYPE, PBYTE, PDWORD, PDWORD);

typedef struct {
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;


//
// Global variables
//

TCHAR  const gszICMRegPath[]     = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICM";
TCHAR  const gszProfile[]        = "profile";
TCHAR  const gszMSCMSdll[]       = "mscms.dll";

char   const gszProductID[]      = "Microsoft Color Management System";

char   const gszInstallColorProfile[] = "InstallColorProfileA";
char   const gszGetColorDirectory[]   = "GetColorDirectoryA";
char   const gszEnumColorProfiles[]   = "EnumColorProfilesA";
VENDORINFO   gVendorInfo;
char         gszMigInf[MAX_PATH];
char   const gszFullICMRegPath[]      = "\"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICM\"";

char   const gszInstallColorProfileA[] = "InstallColorProfileA";


//BOOL gbWin98 = FALSE;

#if DBG
DWORD  gdwDebugControl;
#endif
TCHAR  szValue[MAX_PATH];
TCHAR  szName[MAX_PATH];

PFNINSTALLCOLORPROFILEA pInstallColorProfileA = NULL;
PFNINSTALLCOLORPROFILE pInstallColorProfile = NULL;
PFNENUMCOLORPROFILES   pEnumColorProfiles = NULL;

//
// Local functions
//

VOID  InternalUpgradeICM();
VOID  UpgradeClass(HKEY);
BOOL  AssociateMonitorProfile();
BOOL  AssociatePrinterProfiles(HKEY);
VOID  InstallProfiles();
VOID  DeleteOldICMKey();
void  GetManuAndModelIDs(PTSTR, DWORD*, DWORD*);
int   lstrcmpn(PTSTR, PTSTR, DWORD);

HINSTANCE hinstMigDll;


BOOL WINAPI 
DllEntryPoint(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpReserved) {
  if(dwReason==DLL_PROCESS_ATTACH) {
    hinstMigDll = hinstDll;
  }
  return TRUE;
}



/******************************************************************************
 *
 *                            QueryVersion
 *
 *  Function:
 *       This function is called to get the DLL version information.
 *
 *  Arguments:
 *       pszProductID - Fill in a unique string identifying us.
 *       puDllVersion - Our DLL version
 *
 *       None of the other arguments are used
 *
 *  Returns:
 *       ERROR_SUCCESS to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
QueryVersion(
	OUT LPCSTR  *pszProductID,
	OUT LPUINT  puDllVersion,
	OUT LPINT   *pCodePageArray,	OPTIONAL
	OUT LPCSTR  *ppszExeNamesBuf,	OPTIONAL
	OUT PVENDORINFO  *ppVendorInfo
	)
{
    *pszProductID = gszProductID;
    *puDllVersion = 1;
    *ppszExeNamesBuf    = NULL;
    *pCodePageArray = NULL;
    *ppVendorInfo = &gVendorInfo;
    memset(&gVendorInfo, 0, sizeof(VENDORINFO));
    FormatMessageA(
                 FORMAT_MESSAGE_FROM_HMODULE,
                 hinstMigDll,
                 MSG_VI_COMPANY_NAME,
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                 gVendorInfo.CompanyName,
                 sizeof(gVendorInfo.CompanyName),
                 NULL
                 );

    FormatMessageA(
                 FORMAT_MESSAGE_FROM_HMODULE,
                 hinstMigDll,
                 MSG_VI_SUPPORT_NUMBER,
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                 gVendorInfo.SupportNumber,
                 sizeof(gVendorInfo.SupportNumber),
                 NULL
                 );

    FormatMessageA(
                 FORMAT_MESSAGE_FROM_HMODULE,
                 hinstMigDll,
                 MSG_VI_SUPPORT_URL,
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                 gVendorInfo.SupportUrl,
                 sizeof(gVendorInfo.SupportUrl),
                 NULL
                 );

    FormatMessageA(
                 FORMAT_MESSAGE_FROM_HMODULE,
                 hinstMigDll,
                 MSG_VI_INSTRUCTIONS,
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                 gVendorInfo.InstructionsToUser,
                 sizeof(gVendorInfo.InstructionsToUser),
                 NULL
                 );
    WARNING((__TEXT("QueryVersion called\n")));
    return ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            Initialize9x
 *
 *  Function:
 *       This function is called when upgrading to NT 5.0 from Win9x on the
 *       Win9x side.
 *
 *  Arguments:
 *       pszWorkingDir - Directory where migrate.inf will be found
 *
 *  Returns:
 *       ERROR_SUCCESS to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
Initialize9x(
    IN  LPCSTR   pszWorkingDir,
    IN  LPCSTR   pszSourceDir,
    IN  LPVOID   pvReserved
    )
{
  //
  // Lets figure out if we're on a Win98 or Win95 system
  // We don't migrate Win95 because Win95 doesn't have a 
  // profile database to migrate.
  //

/*  OSVERSIONINFO osVer;

  osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
  GetVersionEx(&osVer);
  gbWin98 = 
    (osVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
    ( (osVer.dwMajorVersion > 4) ||
    ( (osVer.dwMajorVersion == 4) && (osVer.dwMinorVersion > 0) ) );
 */
  WARNING((__TEXT("Initialize9x called\n")));
   
  lstrcpyA(gszMigInf, pszWorkingDir);
  lstrcatA(gszMigInf, "\\migrate.inf");

  return ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            MigrateUser9x
 *
 *  Function:
 *       This function is called on Win9x to upgrade per user settings.
 *
 *  Arguments:
 *       None of the arguments are used
 *
 *  Returns:
 *       ERROR_SUCCES to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
MigrateUser9x(
    IN  HWND     hwndParent,
    IN  LPCSTR   pszUnattendFile,
    IN  HKEY     hUserRegKey,
    IN  LPCSTR   pszUserName,
    LPVOID       pvReserved
    )
{
    //
    // Nothing to do
    //

    WARNING((__TEXT("MigrateUser9x called\n")));
    return  ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            MigrateSystem9x
 *
 *  Function:
 *       This function is called on the Win9x to upgrade system settings.
 *
 *  Arguments:
 *       None of the arguments are used
 *
 *  Returns:
 *       ERROR_SUCCES to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
MigrateSystem9x(
    IN  HWND    hwndParent,
    IN  LPCSTR  pszUnattendFile,
    LPVOID      pvReserved
    )
{
    DWORD            nProfiles;
    DWORD            dwSize;
    char             szColorDir[MAX_PATH];
    char             szNewColorDir[MAX_PATH];
    char             szDrive[2];
    HMODULE          hModule;
    ENUMTYPE         et = {sizeof (ENUMTYPE), ENUM_TYPE_VERSION, 0, NULL};    
    PBYTE            pBuffer;
    PSTR             pstrBuffer;
    PSTR             pstrTraversal;

    WARNING((__TEXT("MigrateSystem9x called\n")));
    
    //
    // Produce the Win9x Color Directory.
    //

    if(GetWindowsDirectoryA(szColorDir, MAX_PATH)==0)
    {
        // If we can't get the windows directory during an upgrade, we can't do anything
        return ERROR_BAD_PATHNAME;        
    }
    
    if (szColorDir[lstrlenA(szColorDir)-1] != '\\') 
    {
        lstrcatA(szColorDir,"\\");
    }
    lstrcatA(szColorDir, "system\\color\\");
    
    if(GetWindowsDirectoryA(szNewColorDir, MAX_PATH)==0)
    {
        // If we can't get the windows directory during an upgrade, we can't do anything
        return ERROR_BAD_PATHNAME;        
    }
    if (szNewColorDir[lstrlenA(szNewColorDir)-1] != '\\') 
    {
        lstrcatA(szNewColorDir,"\\");
    }
    lstrcatA(szNewColorDir, "system32\\spool\\drivers\\color\\");


    //
    // If this is a Win95 system we have nothing to do because
    // Win95 doesn't have a color profile database.
    //

    
    //
    // We can't have mscms as an implib because when they try to load us in
    // Win95, they won't find mscms.dll and reject us.
    //
    
    hModule = LoadLibrary(gszMSCMSdll);
    if (hModule) {
      #ifdef ICM_MIG_DEBUG
      WritePrivateProfileStringA("ICM Debug", "hModule", "not NULL", gszMigInf);
      WritePrivateProfileStringA("ICM Debug", "gbWin98", "TRUE", gszMigInf);
      #endif

      pEnumColorProfiles = (PFNENUMCOLORPROFILES)GetProcAddress(hModule, gszEnumColorProfiles);
      if (pEnumColorProfiles) {
        
        #ifdef ICM_MIG_DEBUG
        WritePrivateProfileStringA("ICM Debug", "pEnumColorProfiles", "not NULL", gszMigInf);
        #endif

        //
        // Compute the size of the EnumColorProfiles buffer.
        //
    
        dwSize = 0;
        pEnumColorProfiles(NULL, &et, NULL, &dwSize, &nProfiles);
        
        if(dwSize==0) 
        {
          #ifdef ICM_MIG_DEBUG
          WritePrivateProfileStringA("ICM Debug", "dwSize", "0", gszMigInf);
          #endif 
          //
          // Need to exit - nothing to do if there are no profiles installed,
          // except to move the directory and registry settings.
          //
          WARNING((__TEXT("No profiles installed\n")));
          goto EndMigrateSystem9x;
        }
    
    
        //
        // Enumerate all the currently installed color profiles.
        //

        #ifdef ICM_MIG_DEBUG
        WritePrivateProfileStringA("ICM Debug", "Enumerate", "Start", gszMigInf);
        #endif 

        pBuffer = (BYTE *)malloc(dwSize);
        pstrBuffer = (PSTR)pBuffer;
        
        #ifdef ICM_MIG_DEBUG
        WritePrivateProfileStringA("ICM Debug", "Enumerate", "TRUE", gszMigInf);
        #endif         
        
        if(pEnumColorProfiles(NULL, &et, pBuffer, &dwSize, &nProfiles))
        {            
            #ifdef ICM_MIG_DEBUG
            WritePrivateProfileStringA("ICM Debug", "Enumerate", "for", gszMigInf);
            #endif 

            for(pstrTraversal = pstrBuffer;
                nProfiles--;
                pstrTraversal += 1 + lstrlenA(pstrTraversal)) {

                //
                // Write the fact into the Migration Information file.
                //
                
                WritePrivateProfileStringA("Installed ICM Profiles", pstrTraversal, "1", gszMigInf);
            }
        }
        free(pBuffer);
      } 
      #ifdef ICM_MIG_DEBUG
        else {
        WritePrivateProfileStringA("ICM Debug", "pEnumColorProfiles", "NULL", gszMigInf);
      }
      #endif

  
      EndMigrateSystem9x:
      if (hModule)
      {
          FreeLibrary(hModule);
      }
  }
  #ifdef ICM_MIG_DEBUG
    else {
    WritePrivateProfileStringA("ICM Debug", "hModule", "NULL", gszMigInf);    
    WritePrivateProfileStringA("ICM Debug", "gbWin98", "FALSE", gszMigInf);
  }
  #endif

  //
  // We'll handle the ICM branch of the registry
  //

  WritePrivateProfileStringA("Handled", gszFullICMRegPath, "Registry", gszMigInf);

      
  //
  // We'll be moving the entire subdirectory.
  //

  WritePrivateProfileStringA("Moved", szColorDir, szNewColorDir, gszMigInf);


  return  ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            InitializeNT
 *
 *  Function:
 *       This function is called when upgrading to NT 5.0 from Win9x on the NT
 *       side. Its main purpose is to initialize us.
 *
 *  Arguments:
 *       None of the arguments are used
 *
 *  Returns:
 *       ERROR_SUCCESS to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR pszWorkingDir,
    IN  LPCWSTR pszSourceDir,
    LPVOID      pvReserved
    )
{
    SetupOpenLog(FALSE);
    SetupLogError("ICM Migration: InitializeNT called\r\n", LogSevInformation);
    return ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            MigrateUserNT
 *
 *  Function:
 *       This function is called on the NT to upgrade per user settings.
 *
 *  Arguments:
 *       None of the arguments are used
 *
 *  Returns:
 *       ERROR_SUCCES to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
MigrateUserNT(
    IN  HANDLE    hUnattendInf,
    IN  HKEY      hUserRegKey,
    IN  LPCWSTR   pszUserName,
    LPVOID        pvReserved
    )
{
    SetupLogError("ICM Migration: MigrateUserNT called\r\n", LogSevInformation);

    //
    // Nothing to do
    //

    return  ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                            MigrateSystemNT
 *
 *  Function:
 *       This function is called on the Win9x to upgrade system settings. This
 *       is where we upgrade ICM 2.0
 *
 *  Arguments:
 *       None of the other arguments are used
 *
 *  Returns:
 *       ERROR_SUCCES to indicate success
 *
 ******************************************************************************/

LONG
CALLBACK
MigrateSystemNT(
    IN  HANDLE  hUnattendInf,
    LPVOID      pvReserved
    )
{
    HINSTANCE hModule;
    LONG      rc = ERROR_FILE_NOT_FOUND;
    CHAR      szMessage[MAX_PATH];

    SetupLogError("ICM Migration: MigrateSystemNT called\r\n", LogSevInformation);
    
    //
    // We can't have mscms as an implib because when they try to load us in
    // Win95, they won't find mscms.dll and reject us.
    //

    hModule = LoadLibrary(gszMSCMSdll);
    if (!hModule)
    {
        sprintf(szMessage, "ICM Migration: Fatal Error, cannot load mscms.dll. Error %d\r\n", GetLastError());
        SetupLogError(szMessage, LogSevFatalError);
        return rc;
    }

    pInstallColorProfileA = (PFNINSTALLCOLORPROFILEA)GetProcAddress(hModule, gszInstallColorProfileA);
    pInstallColorProfile = (PFNINSTALLCOLORPROFILE)GetProcAddress(hModule, gszInstallColorProfile);

    if (!pInstallColorProfile || !pInstallColorProfileA)
    {
        SetupLogError("ICM Migration: Fatal Error, cannot find mscms functions. \r\n", LogSevFatalError);
        goto EndMigrateSystemNT;
    }

    InternalUpgradeICM();   // Upgrade over Win9x
    InstallProfiles();      // Install all profiles in the old color directory
    DeleteOldICMKey();

    rc = ERROR_SUCCESS;

EndMigrateSystemNT:

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return rc;
}


/******************************************************************************
 *
 *                           DeleteOldICMKey
 *
 *  Function:
 *       This function deletes the ICM key and subkeys from the Windows branch.
 *
 *  Arguments:
 *       None
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
DeleteOldICMKey()
{
    HKEY      hkICM = NULL;         // key to ICM branch in registry
    DWORD nSubkeys, i;
    TCHAR szKeyName[32];

    //
    // Open the registry path where profiles used to be kept
    //

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, gszICMRegPath, 0, NULL, 
                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                       NULL, &hkICM, NULL) != ERROR_SUCCESS)
    {
        
        SetupLogError("ICM Migration: Cannot open ICM branch of registry\r\n", LogSevError);
        return;
    }

    if (RegQueryInfoKey(hkICM, NULL, NULL, 0, &nSubkeys, NULL, NULL,
        NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
    {
        SetupLogError("ICM Migration: Cannot enumerate ICM branch of registry\r\n", LogSevError);
        goto EndDeleteOldICMKey;
    }

    //
    // Go through all the device classes and delete all subkeys - this should
    // only be one level deep
    //

    for (i=nSubkeys; i>0; i--)
    {
        RegEnumKey(hkICM, i-1, szKeyName, sizeof(szKeyName));
        RegDeleteKey(hkICM, szKeyName);
    }

EndDeleteOldICMKey:
    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    RegDeleteKey(HKEY_LOCAL_MACHINE, gszICMRegPath);

    return;
}


//
// Move directory with contents.
// Note this is not recursive.
// The purpose of this routine is to move the old color directory to the 
// new color directory. During setup the new color directory may have already
// been created and populated with files. Vendor apps may have populated the 
// old color directory with private subdirectories and files which will not 
// appear in the new directory created by setup. This routine is designed 
// to move those files.
//
// Note it'll fail to move a subdirectory of the old color directory if 
// a similar subdirectory exists in the new color directory - this should not
// be the case.
//
// s and d should have the trailing slash.
//

void MyMoveDir(char *s, char *d) {
  WIN32_FIND_DATA rf;
  HANDLE hf;
  char s2[MAX_PATH];
  char s_[MAX_PATH];
  char d_[MAX_PATH];
  char err[MAX_PATH];

  //
  // If MoveFileEx succeeds, we're done.
  //

  if(!MoveFileEx(s, d, MOVEFILE_REPLACE_EXISTING)) {
    sprintf(s2, "%s*", s);
    hf = FindFirstFile(s2, &rf);
    do {
      // don't move . and ..
      if(!(strcmp(".", rf.cFileName)==0 ||
           strcmp("..", rf.cFileName)==0) ) {
        sprintf(s_, "%s%s", s, rf.cFileName);
        sprintf(d_, "%s%s", d, rf.cFileName);
        if(!MoveFileEx(s_, d_, MOVEFILE_REPLACE_EXISTING)) {
          int e = GetLastError();  
          sprintf(err, "ICM Migration: Failed the move of %s with %d\r\n", s_, e);
          SetupLogError(err, LogSevError);
        } else {
          sprintf(err, "ICM Migration: Moved %s to %s\n", s_, d_);
          SetupLogError(err, LogSevInformation);
        }
      }

    } while(FindNextFile(hf, &rf));
    FindClose(hf);
  }

  //
  // source directory should theoretically be empty at this point
  // If there are errors, we'll leave files behind and report this in 
  // the setup log as a LogSevError.
  //
}



/******************************************************************************
 *
 *                           InstallProfiles
 *
 *  Function:
 *       This function installs all profiles in %windir%\system\color.
 *       This is used when upgrading from Win9x to NT 5.0.
 *
 *  Arguments:
 *       None
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
InstallProfiles()
{
    WIN32_FIND_DATAA wfd;
    PSTR             pNewColorDirEnd;
    HANDLE           hFindFile;
    CHAR             szOldColorDir[MAX_PATH];
    CHAR             szNewColorDir[MAX_PATH];
    CHAR             szReturnString[2];
    CHAR             szDefaultString[2];
    CHAR             szMessage[2*MAX_PATH+100];

    if(GetWindowsDirectoryA(szOldColorDir, MAX_PATH)==0)
    {
        // If we can't get the windows directory during an upgrade, we can't do anything
        sprintf(szMessage, "ICM Migration: GetWindowsDirectory() failed with code %d\r\n", GetLastError());
        SetupLogError(szMessage, LogSevFatalError);
        return;        
    }

    if (szOldColorDir[lstrlenA(szOldColorDir)-1] != '\\')
        lstrcatA(szOldColorDir, "\\");
    lstrcatA(szOldColorDir, "system\\color\\");


    if(GetWindowsDirectoryA(szNewColorDir, MAX_PATH)==0)
    {
        // If we can't get the windows directory during an upgrade, we can't do anything
        sprintf(szMessage, "ICM Migration: GetWindowsDirectory() failed with code %d\r\n", GetLastError());
        SetupLogError(szMessage, LogSevFatalError);
        return;        
    }
    
    if (szNewColorDir[lstrlenA(szNewColorDir)-1] != '\\')
    {
        lstrcatA(szNewColorDir, "\\");
    }
    lstrcatA(szNewColorDir, "system32\\spool\\drivers\\color\\");

    ASSERT(pInstallColorProfileA != NULL);


    //
    // Eat any errors on the MoveFile. This is just in case the migration 
    // was stopped after a previous move and now the source doesn't exist.
    //

    MyMoveDir(szOldColorDir, szNewColorDir);

    //
    // Now we have presumably moved everything so run through the list of 
    // previously installed profiles and install those in the new directory
    // (if we find them).
    //

    pNewColorDirEnd = szNewColorDir + lstrlenA(szNewColorDir);
    lstrcatA(szNewColorDir, "*.*");

    szDefaultString[0]='0';
    szDefaultString[1]=0;
    hFindFile = FindFirstFileA(szNewColorDir, &wfd);


    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            lstrcpyA(pNewColorDirEnd, wfd.cFileName);

            //
            // Check to see if the profile was installed on Win9x
            //

            GetPrivateProfileStringA("Installed ICM Profiles", wfd.cFileName, szDefaultString, szReturnString, 2, gszMigInf);

            //
            // If it was installed, attempt to install it on NT
            //

            if(szReturnString[0]=='1') { 
                if (!(*pInstallColorProfileA)(NULL, szNewColorDir))
                {
                    sprintf(szMessage, "ICM Migration: Error %d installing profile %s\r\n", GetLastError(), szNewColorDir);
                    SetupLogError(szMessage, LogSevError);
                }
                else
                {
                    sprintf(szMessage, "ICM Migration: Installed profile %s\r\n", szNewColorDir);
                    SetupLogError(szMessage, LogSevInformation);
                }
            }

        } while (FindNextFileA(hFindFile, &wfd));

        FindClose(hFindFile);
    }
    else
    {
        SetupLogError("ICM Migration: FindFirstFile returned an invalid handle\r\n", LogSevFatalError);
    }
}


/******************************************************************************
 *
 *                           InternalUpgradeICM
 *
 *  Function:
 *       This function forms the core of the upgrade code. It installs all
 *       profiles in the regsitry, and associates with the right devices
 *
 *  Arguments:
 *       None
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
InternalUpgradeICM()
{
    HKEY      hkICM = NULL;         // key to ICM branch in registry
    HKEY      hkDevice = NULL;      // key to ICM device branch in registry
    int       i;                    // counter variable
    TCHAR    *pszClasses[] = {      // different profile classes
        __TEXT("mntr"),
        __TEXT("prtr"),
        __TEXT("scnr"),
        __TEXT("link"),
        __TEXT("abst"),
        __TEXT("spac"),
        __TEXT("nmcl")
    };
    CHAR szMessage[MAX_PATH];
    LONG errcode;

    //
    // Open the registry path where profiles are kept
    //
    
    if (errcode = RegCreateKeyEx(HKEY_LOCAL_MACHINE, gszICMRegPath, 0, NULL, 
                                 REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                                 &hkICM, NULL) != ERROR_SUCCESS)
    {
        sprintf(szMessage, "ICM Migration: Fatal Error, cannot open registry entry (%s) code:%d\r\n", 
                gszICMRegPath, errcode);
        SetupLogError(szMessage, LogSevFatalError);
        return;
    }

    //
    // Go through all the device classes and install the profiles
    //

    for (i=0; i<sizeof(pszClasses)/sizeof(PTSTR); i++)
    {
        if (RegOpenKeyEx(hkICM, pszClasses[i], 0, KEY_ALL_ACCESS, &hkDevice) != ERROR_SUCCESS)
        {
            continue;           // go to next key
        }
       
        sprintf(szMessage, "ICM Migration: Upgrading %s\r\n", pszClasses[i]);
        SetupLogError(szMessage, LogSevInformation);
        UpgradeClass(hkDevice);

        RegCloseKey(hkDevice);
    }

    //
    // Set default monitor profile
    //

    // AssociateMonitorProfile(); - Not needed for Memphis
    // If Pnp moves everything from Win9x PnP S/W section to NT 5.0 PnP S/W
    // section, then we don't need this for NT either

    if (hkICM)
    {
        RegCloseKey(hkICM);
    }

    return;
}


/******************************************************************************
 *
 *                           UpgradeClass
 *
 *  Function:
 *       This function recursively calls itself to go down a registry path
 *       till it reaches the leaf, and installs all profiles it finds there
 *
 *  Arguments:
 *       hKey            - registry key for root node
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
UpgradeClass(
    HKEY  hKey
    )
{
    HKEY  hSubkey;
    DWORD nSubkeys, nValues, i, cbName, cbValue;
    TCHAR szKeyName[32];
    CHAR  szMessage[MAX_PATH];

    //
    // If there is an error, return
    //

    if (RegQueryInfoKey(hKey, NULL, NULL, 0, &nSubkeys, NULL, NULL,
        &nValues, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
    {
        return;
    }

    if (nSubkeys > 0)
    {
        //
        // This is not the leaf node, recurse
        //

        for (i=nSubkeys; i>0; i--)
        {
            RegEnumKey(hKey, i-1, szKeyName, sizeof(szKeyName));
            if (RegOpenKeyEx(hKey, szKeyName, 0, KEY_ALL_ACCESS, &hSubkey) == ERROR_SUCCESS)
            {
                UpgradeClass(hSubkey);
                RegCloseKey(hSubkey);
                RegDeleteKey(hKey, szKeyName);
            }
        }
    }
    else
    {
        //
        // This is the leaf node - install all the profiles registered
        //

        ASSERT(pInstallColorProfile != NULL);

        for (i=nValues; i>0; i--)
        {
            cbName = MAX_PATH;
            cbValue = MAX_PATH;
            if (RegEnumValue(hKey, i-1, szName, &cbName, 0, NULL, (LPBYTE)szValue,
                &cbValue) == ERROR_SUCCESS)
            {
                if (! lstrcmpn(szName, (PTSTR)gszProfile, lstrlen(gszProfile)))
                {
                    if (! (*pInstallColorProfile)(NULL, szValue))
                    {
                        sprintf(szMessage, "ICM Migration: Error installing profile %s\r\n", szValue);
                        SetupLogError(szMessage, LogSevError);
                    }
                    else
                    {
                        sprintf(szMessage, "ICM Migration: Installed profile %s\r\n", szValue);
                        SetupLogError(szMessage, LogSevInformation);
                    }            
                }
                else
                {
                    PTSTR pProfile;
                
                    //
                    // We might be upgrading over Memphis or later
                    // In Memphis it is "file name" "value" instead of
                    // "profilexx" "value" in Win95 & OSR2
                    //
                
                    if (szName[1] == ':')
                    {
                        //
                        // Assume full path name
                        //
                
                        pProfile = szName;
                
                    }
                    else
                    {
                        GetWindowsDirectory(szValue, MAX_PATH);
                        if (szValue[lstrlen(szValue)-1] != '\\')
                            lstrcat(szValue, __TEXT("\\"));
                        lstrcat(szValue, __TEXT("system\\color\\"));
                        lstrcat(szValue, szName);
                        pProfile = szValue;
                    }
                
                    if (! (*pInstallColorProfile)(NULL, pProfile))
                    {
                        sprintf(szMessage, "ICM Migration: Error installing profile %s\r\n", pProfile);
                        SetupLogError(szMessage, LogSevError);
                    }
                    else
                    {
                        sprintf(szMessage, "ICM Migration: Installed Profile %s\r\n", pProfile);
                        SetupLogError(szMessage, LogSevInformation);
                    }
                }                
                RegDeleteValue(hKey, szName);
            }
        }
    }

    return;
}


/******************************************************************************
 *
 *                            lstrcmpn
 *
 *  Function:
 *       This function compares dwLen characters of two strings and decides if
 *       they are equal
 *
 *  Arguments:
 *       pStr1           - pointer to string 1
 *       pStr2           - pointer to string 2
 *       dwLen           - number of characters to compare
 *
 *  Returns:
 *       Zero if the strings are equal, non zero otherwise
 *
 ******************************************************************************/

int
lstrcmpn(
    PTSTR pStr1,
    PTSTR pStr2,
    DWORD dwLen
    )
{
    //
    // Assume no NULL strings
    //

    while (*pStr1 && *pStr2 && --dwLen)
    {
        if (*pStr1 != *pStr2)
            break;

        pStr1++;
        pStr2++;
    }

    return (int)(*pStr1 - *pStr2);
}
#if DBG

/******************************************************************************
 *
 *                              MyDebugPrint
 *
 *  Function:
 *       This function takes a format string and paramters, composes a string
 *       and sends it out to the debug port. Available only in debug build.
 *
 *  Arguments:
 *       pFormat  - pointer to format string
 *       .......  - parameters based on the format string like printf()
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
MyDebugPrintA(
    PSTR pFormat,
    ...
    )
{
    char     szBuffer[256];
    va_list  arglist;

    va_start(arglist, pFormat);
    wvsprintfA(szBuffer, pFormat, arglist);
    va_end(arglist);

    OutputDebugStringA(szBuffer);

    return;
}


VOID
MyDebugPrintW(
    PWSTR pFormat,
    ...
    )
{
    WCHAR    szBuffer[256];
    va_list  arglist;

    va_start(arglist, pFormat);
    wvsprintfW(szBuffer, pFormat, arglist);
    va_end(arglist);

    OutputDebugStringW(szBuffer);

    return;
}

/******************************************************************************
 *
 *                              StripDirPrefixA
 *
 *  Function:
 *       This function takes a path name and returns a pointer to the filename
 *       part. This is availabel only for the debug build.
 *
 *  Arguments:
 *       pszPathName - path name of file (can be file name alone)
 *
 *  Returns:
 *       A pointer to the file name
 *
 ******************************************************************************/

PSTR
StripDirPrefixA(
    PSTR pszPathName
    )
{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif

#ifdef STANDALONE

//
// For testing
//

main()
{
    UpgradeICM(NULL, NULL, NULL, 0);
    
    TCHAR buffer[MAX_PATH];
    MigrateInit(buffer, NULL, 0, NULL, NULL);
    MigrateInit(NULL, NULL, 0, NULL, NULL);
    MigrateLocalMachine(NULL, NULL);
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calcenf.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngineF_h
#define LHCalcEngineF_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G16_F 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\app.h ===
/*
	File:		LHApplication.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHApplication_h
#define LHApplication_h

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif

#define MAX_ELEMENT_PER_PIXEL   17 /* 16 Colors + Alpha */
typedef struct LH_CMBitmapPlane 
{
	char *						image[MAX_ELEMENT_PER_PIXEL];	/* used for plane-interleaved data		*/
	long 						width;							/* count of pixel in a line				*/
	long 						height;							/* line count							*/
	long 						rowBytes;						/* Offset to next line					*/
	long 						elementOffset;					/* Offset to next element in a plane	*/
	long 						pixelSize;						/* not used								*/
	CMBitmapColorSpace			space;							/* color space							*/
	long 						user1;							/* not used								*/
	long						user2;							/* not used								*/
} LH_CMBitmapPlane;

/* example:
	convert CMYK plane interleaved (InPtr) to BGR pixel interleaved (OutPtr)
	InBitMap.width = OutBitMap.width = 200;
	InBitMap.height = OutBitMap.height = 100;
	InBitMap.rowBytes = 200;
	InBitMap.elementOffset = 1;
	InBitMap.space = cmCMYK32Space;
	InBitMap.image[0] = InPtr+InBitMap.rowBytes*0;
	InBitMap.image[1] = InPtr+InBitMap.rowBytes*1;
	InBitMap.image[2] = InPtr+InBitMap.rowBytes*2;
	InBitMap.image[3] = InPtr+InBitMap.rowBytes*3;
	OutBitMap.rowBytes = 200 * 3;
	OutBitMap.elementOffset = 3;
	OutBitMap.space = cmRGB24Space;
 	OutBitMap.image[0] = OutPtr+2;
	OutBitMap.image[1] = OutPtr+1;
	OutBitMap.image[2] = OutPtr+0;
	
	Only 8 bit or 16 bit data allowed.
*/
#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calcndim.h ===
/*
	File:		LHCalcNDim.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcNDim_h
#define LHCalcNDim_h
/*--------------------------------------------------------------------------------------------------------------
	DoNDim prototypes
  --------------------------------------------------------------------------------------------------------------*/
CMError	CalcNDim_Data8To8_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data8To16_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To8_Lut8		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );
									  
CMError	CalcNDim_Data16To16_Lut8	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );
									  
CMError	CalcNDim_Data8To8_Lut16		( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data8To16_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To8_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

CMError	CalcNDim_Data16To16_Lut16	( CMCalcParamPtr calcParam,
									  CMLutParamPtr  lutParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calceng1.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngine1Dim_h
#define LHCalcEngine1Dim_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

#ifndef LHCalcEngine_h
typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#endif
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc1toX_Di8_Do8_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do8_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do16_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di8_Do16_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do8_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do8_Lut16_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do16_Lut8_G128 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc1toX_Di16_Do16_Lut16_G128 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calceng.h ===
/*
	File:		LHCalcEngine.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHCalcEngine_h
#define LHCalcEngine_h

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

typedef unsigned char  LH_UINT8;
typedef unsigned short LH_UINT16;
typedef unsigned long  LH_UINT32;
#undef  LH_CALC_ENGINE_UNDEF_MODE
#undef  LH_CALC_ENGINE_P_TO_P
#undef  LH_CALC_ENGINE_P_TO_U			
#undef  LH_CALC_ENGINE_U_TO_P
#undef  LH_CALC_ENGINE_U_TO_U		
#define LH_CALC_ENGINE_UNDEF_MODE           0
#define LH_CALC_ENGINE_P_TO_P               1
#define LH_CALC_ENGINE_P_TO_U		        2				
#define LH_CALC_ENGINE_U_TO_P			    3
#define LH_CALC_ENGINE_U_TO_U			    4				

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut8_G16		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to3_Di8_Do8_Lut16_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut16_G16		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut8_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to4_Di8_Do8_Lut16_G32 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut16_G32		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8 			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G8			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut8_G8			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut8_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc4to3_Di8_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut16_G8		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8 			( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
								 
								 
CMError	LHCalc4to4_Di8_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G8 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G16 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut8_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut8_G16_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to3_Di8_Do8_Lut16_G32_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to3_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to3_Di16_Do16_Lut16_G16_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 3 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut8_G32_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut8_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc3to4_Di8_Do8_Lut16_G32_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do16_Lut16_G32_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc3to4_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc3to4_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 3
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut8_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


CMError	LHCalc4to3_Di8_Do8_Lut16_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do16_Lut16_G8_LO		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do16_Lut16_G8_LO	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
								 
CMError	LHCalc4to3_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to3_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 


/*--------------------------------------------------------------------------------------------------------------
	calc 4 to 4
  --------------------------------------------------------------------------------------------------------------*/
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut8_G16_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut8_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
								 
								 
CMError	LHCalc4to4_Di8_Do8_Lut16_G8_LO 		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G8_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

CMError	LHCalc4to4_Di8_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di16_Do8_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di8_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 
CMError	LHCalc4to4_Di16_Do16_Lut16_G16_LO 	( CMCalcParamPtr calcParam,
											  CMLutParamPtr lutParam );		 

/*--------------------------------------------------------------------------------------------------------------
	calc routines for non in place matching
  --------------------------------------------------------------------------------------------------------------*/
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
CMError	LHCalc3to3_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to3_Di8_Do8_Lut8_G32_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc3to4_Di8_Do8_Lut8_G32_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif							 
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
CMError	LHCalc4to3_Di8_Do8_Lut8_G8_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to3_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G8_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
CMError	LHCalc4to4_Di8_Do8_Lut8_G16_Old		( CMCalcParamPtr calcParam,
											  CMLutParamPtr  lutParam );
#endif							 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\inc\debug.h ===
/****************************Module*Header******************************\
* Module Name: DEBUG.H
*
* Module Descripton: Debugging macros for ICM project
*
* Warnings:
*
* Issues:
*
* Created:  8 January 1996
* Author:   Srinivasan Chandraekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

//
// These are used for debugging purposes, and do not generate code in the
// retail version of the driver.
//
// A global variable (again present only in the debug build) maintains the
// current debug level in the low order WORD. The high order WORD is treated
// as a bitfield and is used to give more flexibility to debugging.
//

PSTR StripDirPrefixA(PSTR);
VOID MyDebugPrintW(PWSTR, ...);
VOID MyDebugPrintA(PSTR, ...);

#ifdef UNICODE
#define MyDebugPrint    MyDebugPrintW
#else
#define MyDebugPrint    MyDebugPrintA
#endif

#define DBGPRINT            MyDebugPrint
#define DBGPRINTA           MyDebugPrintA
#define DBGBREAK()          DebugBreak()

//
// List of debug levels for low WORD of gdwDebugControl
//

#define DBG_LEVEL_VERBOSE   0x00000001
#define DBG_LEVEL_TERSE     0x00000002
#define DBG_LEVEL_WARNING   0x00000003
#define DBG_LEVEL_ERROR     0x00000004
#define DBG_LEVEL_FATAL     0x00000005

//
// Bits used in the high WORD of gdwDebugControl
//

#define FLAG_TRACEAPI       0x00010000      // Trace API entries

#define CHECK_DBG_LEVEL(level)  ((level) >= gdwDebugControl)

#define TRACEAPI(funcname)                                              \
    {                                                                   \
        if (gdwDebugControl & FLAG_TRACEAPI)                            \
        {                                                               \
            DBGPRINTA("ICM: Entering function ");                       \
            DBGPRINT funcname;                                          \
        }                                                               \
    }

#define DBGMSG(level, mesg)                                             \
    {                                                                   \
        if (CHECK_DBG_LEVEL(level))                                     \
        {                                                               \
            DBGPRINTA("ICM: %s (%d): ",                                 \
                    StripDirPrefixA(__FILE__), __LINE__);               \
            DBGPRINT mesg;                                              \
        }                                                               \
    }

//
// These are the main macros that you'll be using in your code.
// For giving additional parameters enclose the parameters in
// paranthesis as shown in the example below.
//
// WARNING((__TEXT("Out of memory")));
// ERR((__TEXT("Incorrect return value: %d"), rc));  // Note extra brackets
//

#define VERBOSE(mesg)       DBGMSG(DBG_LEVEL_VERBOSE, mesg)
#define TERSE(mesg)         DBGMSG(DBG_LEVEL_TERSE,   mesg)
#define WARNING(mesg)       DBGMSG(DBG_LEVEL_WARNING, mesg)
#define ERR(mesg)           DBGMSG(DBG_LEVEL_ERROR,   mesg)
#define FATAL(mesg)         DBGMSG(DBG_LEVEL_FATAL,   mesg)

//
// These macros are for Asserting and work independently of the
// debugging variable.
//

#define ASSERT(expr)                                                    \
    {                                                                   \
        if (! (expr)) {                                                 \
            DBGPRINTA("ICM: Assertion failed: %s (%d)\n",               \
                    StripDirPrefixA(__FILE__), __LINE__);               \
            DBGBREAK();                                                 \
        }                                                               \
    }

//
// For giving additional parameters, enclose the message and the other
// parameters in extra paranthesis as shown below.
//
// ASSERTMSG(x>0, "x less than 0");
// ASSERTMSG(x>0, ("x less than 0: x=%d", x));
//

#define ASSERTMSG(expr, mesg)                                           \
    {                                                                   \
        if (! (expr)) {                                                 \
            DBGPRINTA("ICM: Assertion failed: %s (%d)\n",               \
                    StripDirPrefixA(__FILE__), __LINE__);               \
            DBGPRINT mesg;                                              \
            DBGPRINTA("\n");                                            \
            DBGBREAK();                                                 \
        }                                                               \
    }

#define RIP(mesg)                                                       \
    {                                                                   \
        DBGPRINTA("ICM: ");                                             \
        DBGPRINT mesg;                                                  \
        DBGBREAK();                                                     \
    }

#else   // !DBG

#define TRACEAPI(mesg)
#define DBGMSG(level, mesg)
#define VERBOSE(mesg)
#define TERSE(mesg)
#define WARNING(mesg)
#define ERR(mesg)
#define FATAL(mesg)

#define ASSERT(expr)
#define ASSERTMSG(expr, mesg)

#define RIP(mesg)

#endif  // !DBG

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calcnd3.c ===
/*
	File:		LHCalcND3_Lut16.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcNDim_Lut16ID
#else
#define DebugPrint(x)
#endif

#define CLIPPWord(x,a,b) ((x)<(a)?(LH_UINT16)(a):((x)>(b)?(LH_UINT16)(b):(LH_UINT16)(x+.5)))
#define CLIPP(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))

#define UNROLL_NDIM 1
#if UNROLL_NDIM
CMError Calc323Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc324Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc423Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc424Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
#define NDIM_IN_DIM 3
#define NDIM_OUT_DIM 3
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc323Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	LH_UINT16 ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc323Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc323Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 3
#define NDIM_OUT_DIM 4
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc324Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	LH_UINT16 ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc324Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc324Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 4
#define NDIM_OUT_DIM 3
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc423Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	LH_UINT16 ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc423Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc423Dim_Data8To8_Lut16")
	return noErr;
}

#undef NDIM_IN_DIM
#undef NDIM_OUT_DIM
#undef aElutShift
#undef aElutShiftNum
#define NDIM_IN_DIM 4
#define NDIM_OUT_DIM 4
#define aElutShift (16-adr_breite_elut)
#define aElutShiftNum (1<<aElutShift)

CMError Calc424Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register long aAlutShift,aElutOffset,aAlutOffset;
    register long aElutWordSize;
    register long aAlutWordSize;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
	register unsigned long ii,jj;
    register long aOutputPackMode8Bit;
	LH_UINT16 ein_Cache[8];
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("Calc424Dim_Data8To8_Lut16")
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
#if NDIM_IN_DIM == 4
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
#endif
	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
#if NDIM_OUT_DIM == 4
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
#endif

	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + (NDIM_IN_DIM * 2);
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutWordSize = lutParam->inputLutWordSize;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

 	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
   /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,adr_bereich_elut,aElutWordSize,ein_lut,
				NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,adr_bereich_alut,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
					
	{
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						adr_bereich_elut,adr_breite_elut,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						adr_bereich_alut,adr_breite_alut,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						NDIM_IN_DIM,NDIM_OUT_DIM,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
		}
    #endif
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =NDIM_OUT_DIM;
    for( i=0; i<(long)NDIM_IN_DIM; i++){
        theXlutOffsets[ NDIM_IN_DIM-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(adr_bereich_alut/2))/adr_bereich_alut = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			
			        jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[0] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[0];
		        	ein_reg[0] = (LH_UINT16)jj;

			        jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[1] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[1];
		        	ein_reg[1] = (LH_UINT16)jj;

					jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[2] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[2];
		        	ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
					jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
					ko0 = jj - ( jj >> ( adr_breite_elut ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += adr_bereich_elut;
		        	adr[3] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[3];
		        	ein_reg[3] = (LH_UINT16)jj;
#endif
		
	

	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }

        accu[0]=0;
        accu[1]=0;
        accu[2]=0;
#if NDIM_OUT_DIM == 4
        accu[3]=0;
#endif
        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=Xlut[adrAdr+(0)]*ko;
                    accu[1]+=Xlut[adrAdr+(1)]*ko;
                    accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif

                adrAdr = (adr0 + adrOffset);
#endif

                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
 #if NDIM_OUT_DIM == 4
               accu[3]+=Xlut[adrAdr+3]*ko0;
 #endif
       }
       else{

                jj = Index[0];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[1];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

                jj = Index[2];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);

#if NDIM_IN_DIM == 4
                jj = Index[3];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
                adrAdr = (adr0 + adrOffset);
#endif
                accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
               accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
        }

		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
			}
			else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
			}
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
					for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-adr_breite_alut);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
	                jj=ein_Cache[0]=(*(LH_UINT16 *)inputData[0]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[0] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-0-1)*bit_breit_adr);
	                ein_reg[0] = (LH_UINT16)jj;

	                jj=ein_Cache[1]=(*(LH_UINT16 *)inputData[1]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[1] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-1-1)*bit_breit_adr);
	                ein_reg[1] = (LH_UINT16)jj;

	                jj=ein_Cache[2]=(*(LH_UINT16 *)inputData[2]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[2] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-2-1)*bit_breit_adr);
	                ein_reg[2] = (LH_UINT16)jj;

#if NDIM_IN_DIM == 4
	                jj=ein_Cache[3]=(*(LH_UINT16 *)inputData[3]);
	                ko0 = jj - ( jj >> ( adr_breite_elut ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += adr_bereich_elut;
	                adr[3] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((NDIM_IN_DIM-3-1)*bit_breit_adr);
	                ein_reg[3] = (LH_UINT16)jj;
#endif	
	        adr0 *= NDIM_OUT_DIM;
	
	        {								/* a kind of */
	            register long Hold;
	            
			
				Index[0] = 0;
				Index[1] = 1;
				Index[2] = 2;
#if NDIM_IN_DIM == 4
				Index[3] = 3;
#endif
					if( adr[0] < adr[1] ){
						Hold = Index[0];
						Index[0] = Index[1];
						Index[1] = Hold;
					}

					if( adr[Index[1]] < adr[2] ){
						Hold = Index[1];
						Index[1] = Index[2];
						Index[2] = Hold;
						if( adr[Index[0]] < adr[Index[1]] ){
							Hold = Index[0];
							Index[0] = Index[1];
							Index[1] = Hold;
						}
					}

#if NDIM_IN_DIM == 4
					if( adr[Index[2]] < adr[3] ){
						Hold = Index[2];
						Index[2] = Index[3];
						Index[3] = Hold;
						if( adr[Index[1]] < adr[Index[2]] ){
							Hold = Index[1];
							Index[1] = Index[2];
							Index[2] = Hold;
							if( adr[Index[0]] < adr[Index[1]] ){
								Hold = Index[0];
								Index[0] = Index[1];
								Index[1] = Hold;
							}
						}
					}
#endif
	        }
	
			accu[0]=0;
			accu[1]=0;
			accu[2]=0;
#if NDIM_OUT_DIM == 4
			accu[3]=0;
#endif
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
						accu[0]+=Xlut[adrAdr+(0)]*ko;
						accu[1]+=Xlut[adrAdr+(1)]*ko;
						accu[2]+=Xlut[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
						accu[3]+=Xlut[adrAdr+(3)]*ko;
#endif
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
                accu[0]+=Xlut[adrAdr+0]*ko0;
                accu[1]+=Xlut[adrAdr+1]*ko0;
                accu[2]+=Xlut[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=Xlut[adrAdr+3]*ko0;
#endif
	        }
	        else{
	                jj = Index[0];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[1];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

	                jj = Index[2];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);

#if NDIM_IN_DIM == 4
	                jj = Index[3];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(NDIM_IN_DIM-1-jj)*bit_breit_adr);
	
	                    accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+(0)]*ko;
	                    accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+(1)]*ko;
	                    accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+(2)]*ko;
#if NDIM_OUT_DIM == 4
	                    accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+(3)]*ko;
#endif
	
	                adrAdr = (adr0 + NDIM_OUT_DIM*adrOffset);
#endif
				accu[0]+=((LH_UINT8 *)Xlut)[adrAdr+0]*ko0;
                accu[1]+=((LH_UINT8 *)Xlut)[adrAdr+1]*ko0;
                accu[2]+=((LH_UINT8 *)Xlut)[adrAdr+2]*ko0;
#if NDIM_OUT_DIM == 4
				accu[3]+=((LH_UINT8 *)Xlut)[adrAdr+3]*ko0;
#endif
	        }
	
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<NDIM_OUT_DIM; ++ii){
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += adr_bereich_alut;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
				else{
					for( ii=0; ii<NDIM_OUT_DIM; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( adr_breite_alut ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - adr_breite_alut;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += adr_bereich_alut;
					}
				}
	        }
	
			while (--i){
			   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
					inputData[jj] += (NDIM_IN_DIM * 2);
				}
			   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
					outputData[jj] += OutputIncrement;
				}
	
				{
				   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<NDIM_IN_DIM ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*outputData[jj] = outputData[jj][-(long)(NDIM_OUT_DIM )];
					}
				}
				else{
				   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)(NDIM_OUT_DIM * 2)]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<NDIM_IN_DIM; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<NDIM_OUT_DIM; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("Calc424Dim_Data8To8_Lut16")
	return noErr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\calcndim.c ===
/*
	File:		LHCalcNDim_Lut16.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#define UNROLL_NDIM 1
#if UNROLL_NDIM

CMError Calc323Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc324Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc423Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
CMError Calc424Dim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam);
#endif
#define SHRINK_FACTOR 13
/*
#define FARBR_FILES 1
#define FARBR_DEBUG 1
#define FARBR_DEBUG0 1
*/
#if FARBR_FILES
#include "stdio.h"
#include "string.h"
void WriteLuts(	char *theName,long WordSize,long aElutAdrSize,long aElutWordSize,LH_UINT16 *Elut,
				long aXlutInDim,long aXlutOutDim,long aXlutAdrSize,long aXlutWordSize,LH_UINT16 *Xlut,
				long aAlutAdrSize,long aAlutWordSize,LH_UINT16 *aus_lut);
#endif

#ifdef DEBUG_OUTPUT
#define kThisFile kLHCalcNDim_Lut16ID
#else
#define DebugPrint(x)
#endif

#define CLIPPWord(x,a,b) ((x)<(a)?(LH_UINT16)(a):((x)>(b)?(LH_UINT16)(b):(LH_UINT16)(x+.5)))
#define CLIPP(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))
/*
	 DoNDim
  */
CMError CalcNDim_Data8To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
	
{
	LH_UINT8 * inputData[8], *outputData[8];
	UINT32 InputIncrement, OutputIncrement, inputDataRowOffset, outputDataRowOffset, Pixelcount, LineCount;
   	register unsigned long adr0;
    register unsigned long ko0;
    unsigned long accu[8];
    register long i;
    /*long Offsets[8];*/
    
    register unsigned long nDim;
    register long aElutShift,aAlutShift,aElutOffset,aAlutOffset;
    register unsigned long aElutAdrSize;
    register long aElutAdrShift;
    register long aElutWordSize;
    register long aAlutAdrSize;
    register long aAlutAdrShift;
    register long aAlutWordSize;
    register unsigned long aXlutInDim;
    register unsigned long aXlutOutDim;
    register long aXlutAdrSize;
    register long aXlutAdrShift;
    register unsigned long aXlutWordSize;
    register long aInputPackMode8Bit;
    register long aOutputPackMode8Bit;
    register long aElutShiftNum;
	register unsigned long ii,jj;
	LH_UINT16 ein_Cache[8];
	
	
	LH_UINT16 * aus_lut	= (LH_UINT16*)lutParam->outputLut;
	LH_UINT16 * ein_lut	= (LH_UINT16*)lutParam->inputLut;
	LH_UINT16 * Xlut 	= (LH_UINT16*)lutParam->colorLut;
	
	Boolean aCopyAlpha;
   
	#ifdef DEBUG_OUTPUT
	long err = noErr;
	#endif
	LH_START_PROC("CalcNDim_Data8To8_Lut16")
#if UNROLL_NDIM
	if( lutParam->colorLutInDim == 3 &&
		calcParam->cmInputPixelOffset == 6 ){
		if(	lutParam->colorLutOutDim == 3 &&
			(	calcParam->cmOutputPixelOffset == 3 ||
				calcParam->cmOutputPixelOffset == 6)){
			return Calc323Dim_Data8To8_Lut16( calcParam, lutParam );
		}
		if(	lutParam->colorLutOutDim == 4 &&
			(	calcParam->cmOutputPixelOffset == 4 ||
				calcParam->cmOutputPixelOffset == 8) ){
			return Calc324Dim_Data8To8_Lut16( calcParam, lutParam );
		}
	}
	if( lutParam->colorLutInDim == 4 &&
		calcParam->cmInputPixelOffset == 8 ){
		if(	lutParam->colorLutOutDim == 3 &&
			(	calcParam->cmOutputPixelOffset == 3 ||
				calcParam->cmOutputPixelOffset == 6) ){
			return Calc423Dim_Data8To8_Lut16( calcParam, lutParam );
		}
		if(	lutParam->colorLutOutDim == 4 &&
			(	calcParam->cmOutputPixelOffset == 4 ||
				calcParam->cmOutputPixelOffset == 8) ){
			return Calc424Dim_Data8To8_Lut16( calcParam, lutParam );
		}
	}
#endif
	
	inputData[0] = (LH_UINT8 *)calcParam->inputData[0];
	inputData[1] = (LH_UINT8 *)calcParam->inputData[1];
	inputData[2] = (LH_UINT8 *)calcParam->inputData[2];
	inputData[3] = (LH_UINT8 *)calcParam->inputData[3];
	inputData[4] = (LH_UINT8 *)calcParam->inputData[4];
	inputData[5] = (LH_UINT8 *)calcParam->inputData[5];
	inputData[6] = (LH_UINT8 *)calcParam->inputData[6];
	inputData[7] = (LH_UINT8 *)calcParam->inputData[7];

	outputData[0] = (LH_UINT8 *)calcParam->outputData[0];
	outputData[1] = (LH_UINT8 *)calcParam->outputData[1];
	outputData[2] = (LH_UINT8 *)calcParam->outputData[2];
	outputData[3] = (LH_UINT8 *)calcParam->outputData[3];
	outputData[4] = (LH_UINT8 *)calcParam->outputData[4];
	outputData[5] = (LH_UINT8 *)calcParam->outputData[5];
	outputData[6] = (LH_UINT8 *)calcParam->outputData[6];
	outputData[7] = (LH_UINT8 *)calcParam->outputData[7];
	InputIncrement = calcParam->cmInputPixelOffset;
	OutputIncrement = calcParam->cmOutputPixelOffset;
	inputDataRowOffset = calcParam->cmInputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmInputPixelOffset + InputIncrement;
	outputDataRowOffset = calcParam->cmOutputBytesPerLine - calcParam->cmPixelPerLine * calcParam->cmOutputPixelOffset + OutputIncrement;

	Pixelcount = calcParam->cmPixelPerLine;
	LineCount = calcParam->cmLineCount;

	aElutAdrSize = lutParam->inputLutEntryCount;
	for ( i = 1; (i < 32) && (aElutAdrSize >> i); i++)
		aElutAdrShift = i;
	aElutWordSize = lutParam->inputLutWordSize;
	aAlutAdrSize = lutParam->outputLutEntryCount;
	for ( i = 1; (i < 32) && (aAlutAdrSize >> i); i++)
		aAlutAdrShift = i;
	aAlutWordSize = lutParam->outputLutWordSize;
	aXlutInDim = lutParam->colorLutInDim;
	aXlutOutDim = lutParam->colorLutOutDim;
	aXlutAdrSize = lutParam->colorLutGridPoints;
	for ( i = 1; (i < 32) && (aXlutAdrSize >> i); i++)
		aXlutAdrShift = i;
	aXlutWordSize = lutParam->colorLutWordSize;

	aInputPackMode8Bit = calcParam->cmInputColorSpace & cm8PerChannelPacking || calcParam->cmInputColorSpace & cmLong8ColorPacking;
	aOutputPackMode8Bit = calcParam->cmOutputColorSpace & cm8PerChannelPacking || calcParam->cmOutputColorSpace & cmLong8ColorPacking;
	
    /*DebugPrint("DoNDim with %d input elements\n",aByteCount);*/
	#if FARBR_FILES
	WriteLuts( 	"DoNDim",1,aElutAdrSize,aElutWordSize,ein_lut,
				aXlutInDim,aXlutOutDim,aXlutAdrSize,aXlutWordSize,(LH_UINT16 *)Xlut,aAlutAdrSize,aAlutWordSize,(LH_UINT16 *)aus_lut);
    #endif

	i=0;
			
	
	if( calcParam->copyAlpha )aCopyAlpha = 1;
	else aCopyAlpha = 0;
	if( aXlutInDim > 7 || aXlutOutDim > 7 )aCopyAlpha = 0;
	if( aInputPackMode8Bit != aOutputPackMode8Bit )aCopyAlpha = 0;
	
	nDim=aXlutInDim;
	
	if( aInputPackMode8Bit ){
		aElutShift = aElutAdrShift-8;
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	else{
		aElutShift = 16-aElutAdrShift;
		if( aElutShift < 0 )
		{
			#ifdef DEBUG_OUTPUT
			DebugPrint(" DoNDim-Error: aElutShift < 0 (aElutShift = %d)\n",aElutShift);
			#endif
			return cmparamErr;
		}
	}
	
	if( aOutputPackMode8Bit ){
		aAlutShift = (aAlutWordSize-8);		
	}
	else{
		aAlutShift = (16 - aAlutWordSize);		
	}
        
	#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugReserved1) ){
		    DebugPrint("aElutAdrSize=%lx,aElutAdrShift=%lx,aElutWordSize=%lx,ein_lut=%lx,\n",
						aElutAdrSize,aElutAdrShift,aElutWordSize,ein_lut);
			DebugPrint("aAlutAdrSize=%lx,aAlutAdrShift=%lx,aAlutWordSize=%lx,aus_lut=%lx,\n",
						aAlutAdrSize,aAlutAdrShift,aAlutWordSize,aus_lut);
			DebugPrint("aXlutInDim=%lx,aXlutOutDim=%lx,aXlutAdrSize=%lx,aXlutAdrShift=%lx,aXlutWordSize=%lx,Xlut=%lx,\n",
						aXlutInDim,aXlutOutDim,aXlutAdrSize,aXlutAdrShift,aXlutWordSize,Xlut);
			DebugPrint("aInputPackMode8Bit=%lx,aOutputPackMode8Bit=%lx\n",
						aInputPackMode8Bit,aOutputPackMode8Bit );
		}
    #endif
    aElutShiftNum = 1<<aElutShift;
    
    /*if( 1 )*/
    if( aXlutAdrSize != (1<<aXlutAdrShift )){
    register long aXlutOffset;
#if FARBR_DEBUG
    register long aXlutPlaneOffset;
#endif
    long theXlutOffsets[8]; 
    register unsigned long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutInShiftNum;
    register long aElutWordSizeMask = (1<<aElutWordSize) - 1;
    register unsigned long aAlutRound;
   aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    aAlutInShiftNum = (1<<aAlutInShift);

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  DoNDim gripoints = %ld\n",aXlutAdrSize);
#endif
    if( aElutWordSize <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: (1<<aElutWordSize)/aXlutAdrSize <= 0 %d\n",(1<<aElutWordSize)/aXlutAdrSize);
#endif
        return cmparamErr;
    }
    if( aAlutInShift <= 0 ){
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: aAlutInShift <= 0 %d\n",aAlutInShift);
#endif
        return cmparamErr;
    }
    aXlutOffset =aXlutOutDim;
    for( i=0; i<(long)nDim; i++){
        theXlutOffsets[ nDim-1-i] = aXlutOffset;
        aXlutOffset *=aXlutAdrSize;
    }
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );

#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugReserved1) )
            DebugPrint(" aElutWordSize((1<<aElutWordSize)-0) = %ld\n aAlutInShift:((1<<aXlutWordSize)*aElutWordSize+(aAlutAdrSize/2))/aAlutAdrSize = %ld\n",aElutWordSize,aAlutInShift);
#endif
    
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        LH_UINT16 ein_reg[8];
	       	register unsigned long  adrAdr,ko,adrOffset;
	
	        adr0=0;
			aElutOffset = 0;
			jj=0;
			if( aInputPackMode8Bit ){
				for( ii=0; ii<nDim; ii++){ 
			        jj=ein_lut[((*(LH_UINT8 *)&ein_Cache[ii]=*inputData[ii])<<aElutShift)+aElutOffset];
			        jj *= aXlutAdrSize;
			        aElutOffset += aElutAdrSize;
		        	adr[ii] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[ii];
		        	ein_reg[ii] = (LH_UINT16)jj;
				}
			}
			else{
				for( ii=0; ii<nDim; ii++){ 
			        jj=ein_Cache[ii]=(*(LH_UINT16 *)inputData[ii]);
					ko0 = jj - ( jj >> ( aElutAdrShift ));
					ko = ko0 & ( aElutShiftNum - 1 );
					ko0 = ko0 >> aElutShift;
					ko0 += aElutOffset;
			       	jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
			        jj *= aXlutAdrSize;
			        aElutOffset += aElutAdrSize;
		        	adr[ii] = jj & aElutWordSizeMask;
		        	jj = jj >> aElutWordSize;
		        	adr0 += (jj)*theXlutOffsets[ii];
		        	ein_reg[ii] = (LH_UINT16)jj;
				}
			}
	
       	#if FARBR_DEBUG
		aXlutPlaneOffset = nDim;
        DebugPrint("i=%ld o=%ld\n",i,o);
        if( aInputPackMode < k3ShortsUnpacked ){ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_arr[i+ii]); DebugPrint("\n");}
        else{ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",aEinArr[i+ii]); DebugPrint("\n");}
        DebugPrint("ein_reg=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_reg[ii]/aXlutAdrSize); DebugPrint("\n");
	    DebugPrint("adr=(d)");for( ii=0; ii<nDim; ++ii) DebugPrint("%ld ",adr[ii] ); DebugPrint("\n");
        #endif

       	{								/* a kind of*/
			register unsigned long Top, Gap;
			register long Hold,Switches;
			
			Gap = nDim;
			
			for( ii=0; ii<nDim; ++ii){
				Index[ii] = ii;
			}
			do{
				/*Gap = (Gap * 10 ) / SHRINK_FACTOR;*/
				Gap = (Gap * ((10*16)/SHRINK_FACTOR) ) >>4;
				if( Gap == 0 ) Gap = 1;
				Switches = 0;
				Top = nDim - Gap;
				for( ii=0; ii<Top; ++ii){
					jj = ii + Gap;
					if( adr[Index[ii]] < adr[Index[jj]] ){
						Hold = Index[ii];
						Index[ii] = Index[jj];
						Index[jj] = Hold;
						Switches = 1;
					}
				}
			}while( Switches || Gap > 1 );
		}
		#if FARBR_DEBUG
	    DebugPrint("Index=");
	    for( ii=0; ii<nDim; ++ii){
	    	DebugPrint("%3ld ",Index[ii] );
	    }
	    DebugPrint("\n");
        #endif

        for( jj=0; jj<aXlutOutDim; ++jj)accu[jj]=0;

        ko0 = (1<<aElutWordSize);
        adrAdr=adr0;
        adrOffset=0;
        if( aXlutWordSize  == 16 ){
            for( ii=0; ii<nDim; ++ii){
                jj = Index[ii];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko);
#endif
                    accu[jj]+=Xlut[adrAdr+(jj)]*ko;
                }

                adrAdr = (adr0 + adrOffset);
            }
               for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko0);
#endif
                accu[jj]+=Xlut[adrAdr+jj]*ko0;
            }
        }
        else{

            for( ii=0; ii<nDim; ++ii){
                jj = Index[ii];
                ko = ko0 - adr[jj];
                ko0 = adr[jj];

                if( ein_reg[jj] < (LH_UINT16)(aXlutAdrSize-1) )
                    adrOffset += theXlutOffsets[jj];

                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko);
#endif
                    accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko;
                }

                adrAdr = (adr0 + adrOffset);
            }
               for( jj=0; jj<aXlutOutDim; ++jj){		    		
#if FARBR_DEBUG
                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj*aXlutPlaneOffset),Xlut[adrAdr+(jj*aXlutPlaneOffset)],ko0);
#endif
                accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+jj]*ko0;
                /*ii = accu[jj]+((LH_UINT8 *)Xlut)[adrAdr+jj]*ko0;
                accu[jj] = ii +( ii >> 8 );*/
            }
        }

#if FARBR_DEBUG
        DebugPrint("accu=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",accu[ii] ); DebugPrint("\n");
#endif
		aAlutOffset = 0;

	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<aXlutOutDim; ++ii){
	#if FARBR_DEBUG
	                ii = ((accu[ii]) >> aAlutInShift)+aAlutOffset;
	                DebugPrint("adr:((accu[ii]) >> aAlutInShift)+aAlutOffset = %ld\n",ii);
	                DebugPrint("aus_lut[%ld]=%ld aus_lut[%ld]=%ld aus_lut[%ld]=%ld \n",ii-1,aus_lut[ii-1],ii,aus_lut[ii],ii+1,aus_lut[ii+1]);
	#endif
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
	       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}
					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += aAlutAdrSize;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
				else{
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) ; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
	        }
	        #if FARBR_DEBUG
		    if( aOutputPackMode8Bit ){DebugPrint("outputData=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",outputData[ii+o] ); DebugPrint("\n");}
		    else{DebugPrint("outputData=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aAusArr[ii+o] ); DebugPrint("\n");}
			#endif
			if( aCopyAlpha ){
				if( aOutputPackMode8Bit )
					*outputData[aXlutOutDim] = *inputData[aXlutInDim];
				else
					*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
			}
			while (--i){
			   	for( jj=0; jj<aXlutInDim; ++jj){
					inputData[jj] += InputIncrement;
				}
			   	for( jj=0; jj<aXlutOutDim; ++jj){
					outputData[jj] += OutputIncrement;
				}
				if( aCopyAlpha ){
					inputData[aXlutInDim] += InputIncrement;
					outputData[aXlutOutDim] += OutputIncrement;
				}
	
				if( aInputPackMode8Bit ){
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *inputData[jj] ^ *(LH_UINT8 *)(&ein_Cache[jj]) )break;
					}
				}
				else{
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<aXlutInDim ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*outputData[jj] = outputData[jj][-(long)OutputIncrement];
					}
					if( aCopyAlpha ){
						*outputData[aXlutOutDim] = *inputData[aXlutInDim];
					}
				}
				else{
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)OutputIncrement]);
					}
					if( aCopyAlpha ){
						*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<aXlutInDim; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<aXlutOutDim; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
			if( aCopyAlpha ){
				inputData[aXlutInDim] += inputDataRowOffset;
				outputData[aXlutOutDim] += outputDataRowOffset;
			}
		}
    }
    }
    else{

    register unsigned long  bit_breit_selektor;
    register unsigned long  bit_maske_selektor;
    register unsigned long  bit_breit_adr;
    register unsigned long  bit_maske_adr;
    register unsigned long  aAlutInShiftNum;
    register long aAlutInShift;
    register long aAlutInShiftRemainder;
    register unsigned long aAlutRound;
    /*register long aXlutPlaneShift = aXlutAdrShift*aXlutInDim;*/
    bit_breit_selektor=aElutWordSize-aXlutAdrShift;
    if( aElutWordSize-aXlutAdrShift < 0 )
    {
#ifdef DEBUG_OUTPUT
        DebugPrint(" DoNDim-Error: bit_breit_selektor < 0 (bit_breit_selektor = %d)\n",bit_breit_selektor);
#endif
        return cmparamErr;
    }
    bit_maske_selektor=(1<<bit_breit_selektor)-1;
    bit_breit_adr=aXlutAdrShift;
    bit_maske_adr=((1<<bit_breit_adr)-1)<<bit_breit_selektor;
    aAlutInShift = (aXlutWordSize+bit_breit_selektor-aAlutAdrShift);
    /*aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
    aAlutInShiftRemainder = 0;
    if( aAlutInShift > 16 ){
    	aAlutInShiftRemainder = aAlutInShift - 16;
    	aAlutInShift = 16;
    }
    	
    aAlutInShiftNum = (1<<aAlutInShift);
    
	aAlutRound = 1<<( aAlutInShift + aAlutShift - 1 );
	while (LineCount){
		i = Pixelcount;
		
		while (i){
	
	        long adr[8],Index[8];
	        /*LH_UINT16 *ein_lut = (LH_UINT16 *)ein_lut;*/
	        LH_UINT16 ein_reg[8];
	           register unsigned long  adrAdr,ko,adrOffset;
	        /*register unsigned long aIndex;*/
	
	        adr0=0;
	        aElutOffset = 0;
	        jj=0;
			if( aInputPackMode8Bit ){
	            for( ii=0; ii<nDim; ii++){ 
	                jj=ein_lut[((*(LH_UINT8 *)&ein_Cache[ii]=*inputData[ii])<<aElutShift)+aElutOffset];
	                aElutOffset += aElutAdrSize;
	                adr[ii] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((nDim-ii-1)*bit_breit_adr);
	                ein_reg[ii] = (LH_UINT16)jj;
	            }
	        }
	        else{
	            for( ii=0; ii<nDim; ii++){ 
	                jj=ein_Cache[ii]=(*(LH_UINT16 *)inputData[ii]);
	                ko0 = jj - ( jj >> ( aElutAdrShift ));
	                ko = ko0 & ( aElutShiftNum - 1 );
	                ko0 = ko0 >> aElutShift;
	                ko0 += aElutOffset;
	                   jj = ( ein_lut[ ko0 ] * ( aElutShiftNum - ko ) + ein_lut[ ko0 +1 ] * ko ) >> aElutShift;
	
	                aElutOffset += aElutAdrSize;
	                adr[ii] = (jj & bit_maske_selektor);
	                adr0 |= ((jj & bit_maske_adr)>>bit_breit_selektor)<<((nDim-ii-1)*bit_breit_adr);
	                ein_reg[ii] = (LH_UINT16)jj;
	            }
	        }
	
	        adr0 *= aXlutOutDim;
	#if FARBR_DEBUG
	        DebugPrint("i=%ld o=%ld\n",i,o);
	        DebugPrint("adr0=%ld\n",adr0);
	        if( aInputPackMode < k3ShortsUnpacked ){ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_arr[i+ii]); DebugPrint("\n");}
	        else{ DebugPrint("ein_arr=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",aEinArr[i+ii]); DebugPrint("\n");}
	        DebugPrint("ein_reg=(d)");for(ii=0; ii<nDim; ++ii) DebugPrint("%ld ",ein_reg[ii]); DebugPrint("\n");
	        DebugPrint("adr=(d)");for( ii=0; ii<nDim; ++ii) DebugPrint("%ld ",adr[ii] ); DebugPrint("\n");
	#endif
	
	           {								/* a kind of */
	            register unsigned long Top, Gap;
	            register long Hold,Switches;
	            
	            Gap = nDim;
	            
	            for( ii=0; ii<nDim; ++ii){
	                Index[ii] = ii;
	            }
	            do{
	                /*Gap = (Gap * 10 ) / SHRINK_FACTOR;*/
	                Gap = (Gap * ((10*16)/SHRINK_FACTOR) ) >>4;
	                if( Gap == 0 ) Gap = 1;
	                Switches = 0;
	                Top = nDim - Gap;
	                for( ii=0; ii<Top; ++ii){
	                    jj = ii + Gap;
	                    if( adr[Index[ii]] < adr[Index[jj]] ){
	                        Hold = Index[ii];
	                        Index[ii] = Index[jj];
	                        Index[jj] = Hold;
	                        Switches = 1;
	                    }
	                }
	            }while( Switches || Gap > 1 );
	        }
	#if FARBR_DEBUG
	        DebugPrint("Index=");
	        for( ii=0; ii<nDim; ++ii){
	            DebugPrint("%3ld ",Index[ii] );
	        }
	        DebugPrint("\n");
	#endif
	
	           for( jj=0; jj<aXlutOutDim; ++jj)accu[jj]=0;
	
	        ko0 = bit_maske_selektor+1;
	        adrAdr=adr0;
	        adrOffset=0;
	
	        if( aXlutWordSize  == 16 ){
	            for( ii=0; ii<nDim; ++ii){
	                jj = Index[ii];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(nDim-1-jj)*bit_breit_adr);
	
	                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko);
	#endif
	                    accu[jj]+=Xlut[adrAdr+(jj)]*ko;
	                }
	
	                adrAdr = (adr0 + aXlutOutDim*adrOffset);
	            }
	               for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko0);
	#endif
	                accu[jj]+=Xlut[adrAdr+(jj)]*ko0;
	            }
	        }
	        else{
	
	            for( ii=0; ii<nDim; ++ii){
	                jj = Index[ii];
	                ko = ko0 - adr[jj];
	                ko0 = adr[jj];
	
	                if( ein_reg[jj] < bit_maske_adr )
	                    adrOffset |= (1<<(nDim-1-jj)*bit_breit_adr);
	
	                   for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko);
	#endif
	                    accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko;
	                }
	
	                adrAdr = (adr0 + aXlutOutDim*adrOffset);
	            }
	               for( jj=0; jj<aXlutOutDim; ++jj){		    		
	#if FARBR_DEBUG
	                    DebugPrint("jj=(d)%ld adrAdr=%lx Address=%lx Xlut[Address]=(d)%ld ko=(d)%ld\n",jj,adrAdr,adrAdr+(jj),Xlut[adrAdr+(jj)],ko0);
	#endif
	                accu[jj]+=((LH_UINT8 *)Xlut)[adrAdr+(jj)]*ko0;
	            }
	        }
	
	#if FARBR_DEBUG
	        DebugPrint("accu=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",accu[ii] ); DebugPrint("\n");
	#endif
	        aAlutOffset = 0;
	
	        if( aOutputPackMode8Bit ){
	        	for( ii=0; ii<aXlutOutDim; ++ii){
	#if FARBR_DEBUG
	                ii = ((accu[ii]) >> aAlutInShift)+aAlutOffset;
	                DebugPrint("adr:((accu[ii]) >> aAlutInShift)+aAlutOffset = %ld\n",ii);
	                DebugPrint("aus_lut[%ld]=%ld aus_lut[%ld]=%ld aus_lut[%ld]=%ld \n",ii-1,aus_lut[ii-1],ii,aus_lut[ii],ii+1,aus_lut[ii+1]);
	#endif
					jj = accu[ii];
					jj = jj + ( jj >> aXlutWordSize );

					ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; 	/*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/

					ko = ko0 & (aAlutInShiftNum - 1 );
					ko0 = ko0 >> aAlutInShift;
					ko0 += aAlutOffset;
 					if( aAlutWordSize <= 8)
	       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) >> ( aAlutInShift );
 					else{
						jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko );
						jj = jj - ( jj >> aAlutShift );
						jj = ( jj + aAlutRound ) >> (aAlutInShift + aAlutShift);
					}

					*outputData[ii] = (LH_UINT8)jj;
	                aAlutOffset += aAlutAdrSize;
	            }
	        }
	        else{
				if( aXlutWordSize >= 16 ){
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))) >> aAlutInShiftRemainder; /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
				else{
					for( ii=0; ii<aXlutOutDim; ++ii){
						jj = accu[ii];
						jj = jj + ( jj >> aXlutWordSize ) + ( jj >> 2*aXlutWordSize );
              			ko0 = (jj - ( jj >> ( aAlutAdrShift ))); /*	aAlutInShift = aXlutWordSize + aElutWordSize - aAlutAdrShift;*/
		
						ko = ko0 & (aAlutInShiftNum - 1 );
						ko0 = ko0 >> aAlutInShift;
						ko0 += aAlutOffset;
	 					if( aAlutWordSize <= 8)
		       				jj = ( ((LH_UINT8*)aus_lut)[ ko0 ] * ( aAlutInShiftNum - ko ) + ((LH_UINT8*)aus_lut)[ ko0 +1 ] * ko ) << ( aAlutShift - aAlutInShift );
	 					else
		       				jj = ( aus_lut[ ko0 ] * ( aAlutInShiftNum - ko ) + aus_lut[ ko0 +1 ] * ko ) >> (aAlutInShift- aAlutShift);
						*((LH_UINT16 *)outputData[ii]) =  (LH_UINT16)jj;
						aAlutOffset += aAlutAdrSize;
					}
				}
	        }
	
	#if FARBR_DEBUG
	        if( aOutputPackMode < k3ShortsUnpacked ){DebugPrint("aus_arr=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aus_arr[ii+o] ); DebugPrint("\n");}
	        else{DebugPrint("aus_arr=(d)");for( ii=0; ii<aXlutOutDim; ++ii) DebugPrint("%3ld ",aAusArr[ii+o] ); DebugPrint("\n");}
	#endif
			if( aCopyAlpha ){
				if( aOutputPackMode8Bit )
					*outputData[aXlutOutDim] = *inputData[aXlutInDim];
				else
					*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
			}
			while (--i){
			   	for( jj=0; jj<aXlutInDim; ++jj){
					inputData[jj] += InputIncrement;
				}
			   	for( jj=0; jj<aXlutOutDim; ++jj){
					outputData[jj] += OutputIncrement;
				}
				if( aCopyAlpha ){
					inputData[aXlutInDim] += InputIncrement;
					outputData[aXlutOutDim] += OutputIncrement;
				}
	
				if( aInputPackMode8Bit ){
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *inputData[jj] ^ *(LH_UINT8 *)(&ein_Cache[jj]) )break;
					}
				}
				else{
				   	for( jj=0; jj<aXlutInDim; ++jj){
						if( *((LH_UINT16 *)inputData[jj]) ^ ein_Cache[jj] )break;
					}
				}
				if( jj<aXlutInDim ) break;
				if( aOutputPackMode8Bit ){
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*outputData[jj] = outputData[jj][-(long)OutputIncrement];
					}
					if( aCopyAlpha ){
						*outputData[aXlutOutDim] = *inputData[aXlutInDim];
					}
				}
				else{
				   	for( jj=0; jj<aXlutOutDim; ++jj){
						*((LH_UINT16 *)outputData[jj]) = *(LH_UINT16 *)(&outputData[jj][-(long)OutputIncrement]);
					}
					if( aCopyAlpha ){
						*((LH_UINT16 *)outputData[aXlutOutDim]) = *((LH_UINT16 *)inputData[aXlutInDim]);
					}
				}
			}
		}
		
	   	if( --LineCount ){
		   	for( jj=0; jj<aXlutInDim; ++jj){
				inputData[jj] += inputDataRowOffset;
			}
		   	for( jj=0; jj<aXlutOutDim; ++jj){
				outputData[jj] += outputDataRowOffset;
			}
			if( aCopyAlpha ){
				inputData[aXlutInDim] += inputDataRowOffset;
				outputData[aXlutOutDim] += outputDataRowOffset;
			}
		}
    }
    }

	/* UNLOCK_DATA( aElutHdle ); */
	/* UNLOCK_DATA( aAlutHdle ); */
	/* UNLOCK_DATA( aXlutHdle ); */

	LH_END_PROC("CalcNDim_Data8To8_Lut16")
	return noErr;
}


/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data8To16_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To8_Lut16
  */
CMError CalcNDim_Data16To8_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data16To16_Lut16
  */
CMError CalcNDim_Data16To16_Lut16 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data8To8_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To8_Lut16
  */
CMError CalcNDim_Data16To8_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data16To16_Lut16
  */
CMError CalcNDim_Data8To16_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}

/*
   CalcNDim_Data8To16_Lut16
  */
CMError CalcNDim_Data16To16_Lut8 	(CMCalcParamPtr calcParam,
									 CMLutParamPtr  lutParam)
{
	return CalcNDim_Data8To8_Lut16( calcParam, lutParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\defines.h ===
/*
	File:		LHDefines.h

	Contains:	defines for the CMM

	Written by:	Werner Neubrand

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHDefines_h
#define LHDefines_h

#ifndef LUTS_ARE_PTR_BASED
#define LUTS_ARE_PTR_BASED 0
#else
#define LUTS_ARE_PTR_BASED 1
#endif

/* made a few changes to get it to compile with MrC and SC. */
#if LUTS_ARE_PTR_BASED
	#define LUT_DATA_TYPE		void*
	#define CUBE_DATA_TYPE		void*
	#define DATA_2_PTR
	#define GETDATASIZE(x)		GetPtrSize(x)
	#define SETDATASIZE(x,y)	SetPtrSize(x,y)
	#define LOCK_DATA(x)
	#define UNLOCK_DATA(x)
	#define ALLOC_DATA(x,y)		SmartNewPtr(x,y)
	#define DISPOSE_DATA(x)		DisposePtr((Ptr)(x))
	#define DISPOSE_IF_DATA(x)	DisposeIfPtr((Ptr)(x))
#else
	#define LUT_DATA_TYPE		void**
	#define CUBE_DATA_TYPE		void**
	#define DATA_2_PTR *
	#define GETDATASIZE(x)		GetHandleSize((Handle)(x))
	#define SETDATASIZE(x,y)	SetHandleSize((Handle)(x),(y))
	#define LOCK_DATA(x)		HLock((Handle)(x))
	#define UNLOCK_DATA(x)		HUnlock((Handle)(x))
	#define ALLOC_DATA(x,y)		(void **)SmartNewHandle(x,y)
	#define DISPOSE_DATA(x)		(void **)DisposeHandle((Handle)(x))
	#define DISPOSE_IF_DATA(x)	(void **)DisposeIfHandle((Handle)(x))
#endif


#define		kDoDefaultLut	0
#define		kDoGamutLut		1

#define		kNoInfo			0
#define		kDoXYZ2Lab		1
#define		kDoLab2XYZ		2

#define		kNumOfRGBchannels 3
#define		kNumOfLab_XYZchannels 3

/*							these constants are the defaults for Do3D and hardware			*/
/*- BYTE ---------------------------------------------------------------------------------- */
#define     adr_bereich_elut       256	/* ElutAdrSize   |  Elut pixeloriented 256 entries 10 bit each dim.	*/
#define     adr_breite_elut          8	/* ElutAdrShift  |  2^8 = 256										*/
#define     bit_breite_elut         10  /* ElutWordSize														*/


#define     adr_bereich_alut      1024	/* AlutAdrSize   |  Alut pixeloriented 1024 entries 8 bit each dim.	*/
#define     adr_breite_alut         10	/* AlutAdrShift  |  2^10 = 1024										*/
#define     bit_breite_alut          8
		
/* constants for the profheader-flags *
#define		kQualityMask		0x00030000
#define		kLookupOnlyMask		0x00040000
#define		kCreateGamutLutMask	0x00080000
#define		kUseRelColorimetric	0x00100000*/
							
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\dondim.h ===
/*
	File:		LHDoNDim.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHDoNDim_h
#define LHDoNDim_h

#if powerc
#pragma options align=mac68k
#endif

/* typedef double Matrix2D[3][3]; 	*/
typedef struct{ 	
                long 		aElutAdrSize;					/* Count of Adresses of Elut ( for one Dimension )*/
                long 		aElutAdrShift;					/* Count of used bits ( MUST BE = 2^ aElutAdrSize )*/
                long 		aElutWordSize;					/* Count of bits of each entry ( e.g. 10 for partly used UINT16 )*/
                Boolean 	separateEluts;					/* 0= same Elut for all Dimensions; 1= separate Eluts*/
                UINT16 		*ein_lut;						/* Pointer to Elut*/
                long 		aAlutAdrSize;					/* Count of Adresses of Alut ( for one Dimension )		*/
                long		aAlutAdrShift;					/* Count of used bits ( MUST BE = 2^ aAlutAdrSize )*/
                long 		aAlutWordSize;					/* Count of bits of each entry ( e.g. 16 for fully used UINT16 )*/
                Boolean 	separateAluts;					/* 0= same Alut for all Dimensions; 1= separate Aluts*/
                UINT8 		*aus_lut;						/* Pointer to Alut*/
                Matrix2D	*theMatrix;						/* Pointer to Matrix*/
                long 		aPointCount;					/* Count of input pixels*/
                long 		gridPoints;						/* gridpoints*/
                long 		aBufferByteCount;				/* BufferByteCount*/
                UINT8		*theArr;						/* Input/Output array*/
}DoMatrixForCubeStruct,*DoMatrixForCubeStructPtr;

#if powerc
#pragma options align=reset
#endif
/*					DoMatrixForCube*/
/*	works with planeinterleaved Elut, Alut*/
/*	but with pixelinterleaved data ( BYTES/WORDs).*/
/*	Elut, Alut must have 2^n UINT16 entries. */
/*	Matrix is 3*3 double.*/
#ifdef __cplusplus
extern "C" {
#endif
void DoMatrixForCube16( DoMatrixForCubeStructPtr aStructPtr );
void DoOnlyMatrixForCube16( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube );
void DoOnlyMatrixForCube( Matrix2D	*theMatrix, Ptr aXlut, long aPointCount, long gridPointsCube );

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\engine1d.c ===
/*
	File:		Engine1D.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#define smallCode 1

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<7)-1)<< (LH_BIT_BREIT_INTERNAL-7))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-7)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

{
	LH_UINT32 ein_regr;
	LH_DATA_IN_TYPE ein_cache;
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;

	LH_UINT8 	Mode;
	LH_UINT8	LH_DATA_OUT_COUNT = (LH_UINT8)lutParam->colorLutOutDim;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}
 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (LH_DATA_IN_TYPE)((aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT ));
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (LH_DATA_IN_TYPE)((aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT ));
		       	ein_regr = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regr = My_InputLut[(ein_cache=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut +
						((ein_regr >> LH_BIT_BREIT_SELEKTOR)*LH_DATA_OUT_COUNT);
			ein_regr &= LH_BIT_MASKE_SELEKTOR;

			ako0 = (LH_ADR_BEREICH_SEL) - ein_regr;
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_OUT_SIZE_16
	
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
			*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
			*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
			*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );

			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			aVal =					 (ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT]);
			aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
			aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
			ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
			aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
			*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
			}}
			
			#else
			*output0 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			*output1 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
			paNewVal0++;
			*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			*output3 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
			}}
			#endif
			
			#else
			*output0 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
			if( LH_DATA_OUT_COUNT > 1 ){
			paNewVal0++;
			*output1 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
			paNewVal0++;
			*output2 = My_OutputLut[((ako0	 	* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
			if( LH_DATA_OUT_COUNT > 3 ){
			paNewVal0++;
			*output3 = My_OutputLut[((ako0 		* paNewVal0[0] +
									  ein_regr	* paNewVal0[LH_DATA_OUT_COUNT])>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
			}}
			#endif

			#if LH_DATA_OUT_SIZE_16 && ! LH_LUT_DATA_SIZE_16
			*output0 |= (*output0 << 8);
			if( LH_DATA_OUT_COUNT > 1 ){
			*output1 |= (*output1 << 8);
			*output2 |= (*output2 << 8);
			if( LH_DATA_OUT_COUNT > 3 ){
			*output3 |= (*output3 << 8);
			}}
			#endif
			
			if (Mode == LH_CALC_ENGINE_P_TO_P)
			{
				while (--i)
				{
					input0 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;

					if ((*input0 ^ ein_cache)){
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
					*output1 = output1[-outputOffset];
					*output2 = output2[-outputOffset];
					if( LH_DATA_OUT_COUNT > 3 ){
					*output3 = output3[-outputOffset];
					}}
				}
			}
			else if (Mode == LH_CALC_ENGINE_P_TO_U)
			{
				if( LH_DATA_OUT_COUNT == 1 ){
					*output1 &= Mask;
				}else if( LH_DATA_OUT_COUNT == 3 ){
					*output3 &= Mask;
				}else{
					*output4 &= Mask;
				}
				while (--i)
				{
					input0 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					output4 += outputOffset;
					if ((*input0 ^ ein_cache)){
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
						*output1 = output1[-outputOffset];
						*output2 = output2[-outputOffset];
						if( LH_DATA_OUT_COUNT > 3 ){
							*output3 = output3[-outputOffset];
							*output4 &= Mask;
						}
						else{
							*output3 &= Mask;
						}
					}
					else{
						*output1 &= Mask;
					}
				}
			}
			else
			{
				if( LH_DATA_OUT_COUNT == 1 ){
					*output1 = (LH_DATA_OUT_TYPE)*input1;
				}else if( LH_DATA_OUT_COUNT == 3 ){
					*output3 = (LH_DATA_OUT_TYPE)*input1;
				}else{
					*output4 = (LH_DATA_OUT_TYPE)*input1;
				}
				while (--i)
				{								/*U_TO_U*/
					input0 += inputOffset;
					input1 += inputOffset;
					output0 += outputOffset;
					output1 += outputOffset;
					output2 += outputOffset;
					output3 += outputOffset;
					output4 += outputOffset;
					if ((*input0 ^ ein_cache))
					{
						break;
					}
					*output0 = output0[-outputOffset];
					if( LH_DATA_OUT_COUNT > 1 ){
						*output1 = output1[-outputOffset];
						*output2 = output2[-outputOffset];
						if( LH_DATA_OUT_COUNT > 3 ){
							*output3 = output3[-outputOffset];
							*output4 = (LH_DATA_OUT_TYPE)*input1;
						}
						else{
							*output3 = (LH_DATA_OUT_TYPE)*input1;
						}
					}
					else{
						*output1 = (LH_DATA_OUT_TYPE)*input1;
					}
				}
			}
		}
		if (--LineCount)
		{
			j++;
			input0 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[0] + j * calcParam->cmInputBytesPerLine);
			input1 = (LH_DATA_IN_TYPE *)((LH_UINT8 *)calcParam->inputData[1] + j * calcParam->cmInputBytesPerLine);

			output0 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[0] + j * calcParam->cmOutputBytesPerLine);
			output1 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[1] + j * calcParam->cmOutputBytesPerLine);
			output2 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[2] + j * calcParam->cmOutputBytesPerLine);
			output3 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[3] + j * calcParam->cmOutputBytesPerLine);
			output4 = (LH_DATA_OUT_TYPE *)((LH_UINT8 *)calcParam->outputData[4] + j * calcParam->cmOutputBytesPerLine);
		}
	}
	LH_END_PROC(LH_CALC_PROC_NAME)
	return 0;
}
#undef LH_CALC_PROC_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm\lh_core\engine.c ===
/*
	File:		LHCalcEngine.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#undef LH_DATA_IN_TYPE
#undef LH_DATA_OUT_TYPE
#undef LH_LUT_DATA_TYPE
#undef LH_DATA_IN_COUNT
#undef LH_DATA_OUT_COUNT
#undef LH_DATA_SHR
#undef LH_DATA_SHR_CORR
#undef LH_LUT_DATA_SHR
#undef LH_BIT_BREIT_INTERNAL
#if LH_DATA_IN_SIZE_16
#define LH_DATA_IN_TYPE LH_UINT16
#else
#define LH_DATA_IN_TYPE LH_UINT8
#endif
#if LH_DATA_OUT_SIZE_16
#define LH_DATA_OUT_TYPE LH_UINT16
#else
#define LH_DATA_OUT_TYPE LH_UINT8
#endif
#if LH_LUT_DATA_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#define LH_LUT_DATA_TYPE LH_UINT16
#else
#if LH_DATA_IN_SIZE_16
#define LH_BIT_BREIT_INTERNAL 	16
#else
#define LH_BIT_BREIT_INTERNAL 	10
#endif
#define LH_LUT_DATA_TYPE LH_UINT8
#endif

#if LH_DATA_IN_COUNT_4
#define LH_DATA_IN_COUNT 		4
#else
#define LH_DATA_IN_COUNT 		3
#endif

#if LH_DATA_OUT_COUNT_4
#define LH_DATA_OUT_COUNT 		4
#else
#define LH_DATA_OUT_COUNT 		3
#endif

#define LH_BIT_MASKE_ADR (((1<<LH_BIT_BREIT_ADR)-1)<< (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR))
#define LH_BIT_BREIT_SELEKTOR (LH_BIT_BREIT_INTERNAL-LH_BIT_BREIT_ADR)
#define LH_BIT_MASKE_SELEKTOR ((1<<LH_BIT_BREIT_SELEKTOR)-1)

#define LH_ADR_BEREICH_SEL 		(1<<LH_BIT_BREIT_SELEKTOR)

#if LH_LUT_DATA_SIZE_16
#define LH_DATA_SHR               (16+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)  /* z.B. 16+11-10=17 */
#define LH_DATA_SHR_CORR 8		/* notwendig bei LH_DATA_SHR > 16 */
#define LH_LUT_DATA_SHR  16		/* Normierung bei Alutinterpolation */
#else
#define LH_DATA_SHR               (8+LH_BIT_BREIT_SELEKTOR-LH_ADR_BREIT_AUS_LUT)   /* z.B. 8+7-10=5 */
#define LH_LUT_DATA_SHR  8		/* Normierung bei Alutinterpolation */
#endif

#if LH_DATA_IN_COUNT_4
{

 	LH_UINT32 ein_regY;
	LH_UINT32 ein_regM;
	LH_UINT32 ein_regC;
	LH_UINT32 ein_regK;
	LH_DATA_IN_TYPE ein_cache[4];
	LH_LUT_DATA_TYPE * paNewVal0;
	LH_UINT32 ako0;
	LH_UINT32 ako1;
	LH_UINT32 ako2;
	LH_UINT32 ako3;

	LH_UINT8 	Mode;
	LH_UINT32 	PixelCount, LineCount, i, j;
	long inputOffset,outputOffset;
	LH_DATA_IN_TYPE * input0 = (LH_DATA_IN_TYPE *)calcParam->inputData[0];
	LH_DATA_IN_TYPE * input1 = (LH_DATA_IN_TYPE *)calcParam->inputData[1];
	LH_DATA_IN_TYPE * input2 = (LH_DATA_IN_TYPE *)calcParam->inputData[2];
	LH_DATA_IN_TYPE * input3 = (LH_DATA_IN_TYPE *)calcParam->inputData[3];
	LH_DATA_IN_TYPE * input4 = (LH_DATA_IN_TYPE *)calcParam->inputData[4];

	LH_DATA_OUT_TYPE * output0 = (LH_DATA_OUT_TYPE *)calcParam->outputData[0];
	LH_DATA_OUT_TYPE * output1 = (LH_DATA_OUT_TYPE *)calcParam->outputData[1];
	LH_DATA_OUT_TYPE * output2 = (LH_DATA_OUT_TYPE *)calcParam->outputData[2];
	LH_DATA_OUT_TYPE * output3 = (LH_DATA_OUT_TYPE *)calcParam->outputData[3];
	LH_DATA_OUT_TYPE * output4 = (LH_DATA_OUT_TYPE *)calcParam->outputData[4];

	LH_UINT16 * My_InputLut = (LH_UINT16 *)lutParam->inputLut;
	LH_LUT_DATA_TYPE * My_OutputLut = (LH_LUT_DATA_TYPE *)lutParam->outputLut;
	LH_LUT_DATA_TYPE * My_ColorLut = (LH_LUT_DATA_TYPE *)lutParam->colorLut;

	LH_DATA_OUT_TYPE Mask = (LH_DATA_OUT_TYPE)-1;

#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC(LH_CALC_PROC_NAME)

	#if LH_DATA_IN_SIZE_16
	inputOffset = (long)calcParam->cmInputPixelOffset / 2;
	#else
	inputOffset = (long)calcParam->cmInputPixelOffset;
	#endif
	#if LH_DATA_OUT_SIZE_16
	outputOffset = (long)calcParam->cmOutputPixelOffset / 2;
	#else
	outputOffset = (long)calcParam->cmOutputPixelOffset;
	#endif

	if (calcParam->clearMask)
		Mask = 0;
	Mode = LH_CALC_ENGINE_UNDEF_MODE;


	if ((calcParam->cmInputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmInputBytesPerLine) && (calcParam->cmOutputPixelOffset * calcParam->cmPixelPerLine == calcParam->cmOutputBytesPerLine))
	{
		PixelCount = calcParam->cmPixelPerLine * calcParam->cmLineCount;
		LineCount = 1;
	}
	else
	{
		PixelCount = calcParam->cmPixelPerLine;
		LineCount = calcParam->cmLineCount;
	}
	if (calcParam->copyAlpha )
	{
			Mode = LH_CALC_ENGINE_U_TO_U;
	}
	else
	{
		if (calcParam->clearMask)
			Mode = LH_CALC_ENGINE_P_TO_U;
		else
			Mode = LH_CALC_ENGINE_P_TO_P;
	}

 	j = 0;
	while (LineCount)
	{
		i = PixelCount;
		while (i)
		{
			#if LH_LUT_DATA_SIZE_16
			#if LH_DATA_IN_SIZE_16 || LH_DATA_OUT_SIZE_16
    	   		register LH_UINT32 ko;
			#endif
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   	#endif
			#if LH_DATA_OUT_SIZE_16
	       		register LH_UINT32 aVal;
    	   	#endif
			#if LH_DATA_IN_SIZE_16
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 16-LH_ADR_BREIT_EIN_LUT );
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#else
			#if LH_DATA_IN_SIZE_16
	       		register LH_DATA_IN_TYPE aValIn;
    	   		register LH_UINT32 ko;
				aValIn = (ein_cache[0]=*input0) - ( *input0 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regC = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >>( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[1]=*input1) - ( *input1 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regM = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
		       	
				aValIn = (ein_cache[2]=*input2) - ( *input2 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regY = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );

				aValIn = (ein_cache[3]=*input3) - ( *input3 >> ( LH_ADR_BREIT_EIN_LUT ));
				ko = aValIn & ( (1<<( 16-LH_ADR_BREIT_EIN_LUT ))-1 );
				aValIn = (aValIn >> ( 16-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT );
		       	ein_regK = ( My_InputLut[aValIn] * ( (1<<( 16-LH_ADR_BREIT_EIN_LUT )) - ko ) + My_InputLut[aValIn +1] * ko ) >> ( 10-LH_ADR_BREIT_EIN_LUT );
			/*ein_regC = My_InputLut[(*input0>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(*input1>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(*input2>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(*input3>>( 10-LH_ADR_BREIT_EIN_LUT )) + ( 3 << LH_ADR_BREIT_EIN_LUT )];*/
			#else
			ein_regC = My_InputLut[(ein_cache[0]=*input0) + ( 0 << LH_ADR_BREIT_EIN_LUT )];
			ein_regM = My_InputLut[(ein_cache[1]=*input1) + ( 1 << LH_ADR_BREIT_EIN_LUT )];
			ein_regY = My_InputLut[(ein_cache[2]=*input2) + ( 2 << LH_ADR_BREIT_EIN_LUT )];
			ein_regK = My_InputLut[(ein_cache[3]=*input3) + ( 3 << LH_ADR_BREIT_EIN_LUT )];
			#endif
			#endif
			paNewVal0 = (LH_LUT_DATA_TYPE *)My_ColorLut + 
						((((((((ein_regC & LH_BIT_MASKE_ADR) << LH_BIT_BREIT_ADR) +
							   (ein_regM & LH_BIT_MASKE_ADR)) << LH_BIT_BREIT_ADR) +
							   (ein_regY & LH_BIT_MASKE_ADR))>> (LH_BIT_BREIT_SELEKTOR-LH_BIT_BREIT_ADR)) + 
						       (ein_regK >> LH_BIT_BREIT_SELEKTOR))*LH_DATA_OUT_COUNT);
			ein_regC &= LH_BIT_MASKE_SELEKTOR;
			ein_regM &= LH_BIT_MASKE_SELEKTOR;
			ein_regY &= LH_BIT_MASKE_SELEKTOR;
			ein_regK &= LH_BIT_MASKE_SELEKTOR;
			if (ein_regY >= ein_regC)
			{
		        if( ein_regM >= ein_regC )
		        {
		            if( ein_regY >= ein_regM )	 	   /*  YMCK !*/
		            {	   		
		            	if( ein_regC >= ein_regK )
		            	{
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regC;
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  YMKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regM;
							ako2 = ein_regM - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  YKMC !*/
						{	 
							ako0 = LH_ADR_BEREICH_SEL - ein_regY;
							ako1 = ein_regY - ein_regK;
							ako2 = ein_regK - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else{	 						/*  KYMC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regY;
							ako2 = ein_regY - ein_regM;
							ako3 = ein_regM - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}	
		            }
		            else
		            { 								/*  MYCK !*/
		            	if( ein_regC >= ein_regK )
		            	{				  
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regC;						    
							ako3 = ein_regC - ein_regK;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regK * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regY >= ein_regK )	/*  MYKC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regY;
							ako2 = ein_regY - ein_regK;
							ako3 = ein_regK - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else if(ein_regM >= ein_regK )	/*  MKYC !*/
						{	 	
							ako0 = LH_ADR_BEREICH_SEL - ein_regM;
							ako1 = ein_regM - ein_regK;
							ako2 = ein_regK - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 0 << LH_ADR_BREIT_AUS_LUT );
					       	*output0 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 1 << LH_ADR_BREIT_AUS_LUT );
					       	*output1 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							aVal =					 (	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 2 << LH_ADR_BREIT_AUS_LUT );
					       	*output2 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
	
							#if LH_DATA_OUT_COUNT_4
							aVal =					 (	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] );
							aVal = aVal + ( aVal >> ( LH_LUT_DATA_SHR ));
							aVal = aVal - ( aVal >> ( LH_ADR_BREIT_AUS_LUT ));
							ko = (aVal>>LH_DATA_SHR_CORR) & ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR))-1 );
							aVal = (aVal >> ( LH_DATA_SHR )) + ( 3 << LH_ADR_BREIT_AUS_LUT );
					       	*output3 = (LH_DATA_OUT_TYPE)((My_OutputLut[aVal] * ( (1<<( LH_DATA_SHR - LH_DATA_SHR_CORR )) - ko ) + My_OutputLut[aVal +1] * ko)>>(LH_DATA_SHR - LH_DATA_SHR_CORR) );
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)]>>8;
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)]>>8;
							#endif
							#endif
							
							#else
							*output0 = My_OutputLut[((	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+0] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+0] )>>LH_DATA_SHR) + (0<<LH_ADR_BREIT_AUS_LUT)];
							*output1 = My_OutputLut[((	ako0 * paNewVal0[1] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+1] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+1] )>>LH_DATA_SHR) + (1<<LH_ADR_BREIT_AUS_LUT)];
							*output2 = My_OutputLut[((	ako0 * paNewVal0[2] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+2] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+2] )>>LH_DATA_SHR) + (2<<LH_ADR_BREIT_AUS_LUT)];
							#if LH_DATA_OUT_COUNT_4
							*output3 = My_OutputLut[((	ako0 * paNewVal0[3] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0) * LH_DATA_OUT_COUNT)+3] + 
					        							ako2 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        							ako3 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] + 
					        						ein_regC * paNewVal0[(((((((1<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1)<<LH_BIT_BREIT_ADR) | 1) * LH_DATA_OUT_COUNT)+3] )>>LH_DATA_SHR) + (3<<LH_ADR_BREIT_AUS_LUT)];
							#endif
							#endif
						}
						else
						{							/*  KMYC !*/
							ako0 = LH_ADR_BEREICH_SEL - ein_regK;
							ako1 = ein_regK - ein_regM;
							ako2 = ein_regM - ein_regY;
							ako3 = ein_regY - ein_regC;
							#if LH_LUT_DATA_SIZE_16
							#if LH_DATA_OUT_SIZE_16
			   		
							aVal =					 (	ako0 * paNewVal0[0] + 
					        							ako1 * paNewVal0[(((((((0<<LH_BIT_BREIT_ADR) | 0)<<LH_BIT_BREIT_ADR) | 0)<